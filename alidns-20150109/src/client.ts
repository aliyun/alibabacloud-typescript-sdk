// This file is auto-generated, don't edit it
/**
 */
import Util, * as $Util from '@alicloud/tea-util';
import OpenApi, * as $OpenApi from '@alicloud/openapi-client';
import OpenApiUtil from '@alicloud/openapi-util';
import EndpointUtil from '@alicloud/endpoint-util';
import * as $tea from '@alicloud/tea-typescript';

export class AddCustomLineRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The CIDR blocks.
   * 
   * This parameter is required.
   */
  ipSegment?: AddCustomLineRequestIpSegment[];
  /**
   * @remarks
   * The language.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The name of the custom line.
   * 
   * This parameter is required.
   */
  lineName?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      ipSegment: 'IpSegment',
      lang: 'Lang',
      lineName: 'LineName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      ipSegment: { 'type': 'array', 'itemType': AddCustomLineRequestIpSegment },
      lang: 'string',
      lineName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddCustomLineResponseBody extends $tea.Model {
  /**
   * @remarks
   * The code of the custom line.
   * 
   * @example
   * hra0yc-597
   */
  lineCode?: string;
  /**
   * @remarks
   * The unique ID of the custom line.
   * 
   * @example
   * 597
   */
  lineId?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * B57C121B-A45F-44D8-A9B2-13E5A5044195
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      lineCode: 'LineCode',
      lineId: 'LineId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lineCode: 'string',
      lineId: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddCustomLineResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddCustomLineResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddCustomLineResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddDnsCacheDomainRequest extends $tea.Model {
  /**
   * @remarks
   * The maximum TTL period of the cached data retrieved from the origin DNS server. Unit: seconds. Valid values: 30 to 86400.
   * 
   * This parameter is required.
   * 
   * @example
   * 86400
   */
  cacheTtlMax?: number;
  /**
   * @remarks
   * The minimum time-to-live (TTL) period of the cached data retrieved from the origin Domain Name System (DNS) server. Unit: seconds. Valid values: 30 to 86400.
   * 
   * This parameter is required.
   * 
   * @example
   * 30
   */
  cacheTtlMin?: number;
  /**
   * @remarks
   * The domain name.
   * 
   * This parameter is required.
   * 
   * @example
   * dns.example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The instance ID of the cache-accelerated domain name.
   * 
   * This parameter is required.
   * 
   * @example
   * dns-cn-j6666
   */
  instanceId?: string;
  /**
   * @remarks
   * The language.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The remarks.
   * 
   * @example
   * test
   */
  remark?: string;
  /**
   * @remarks
   * The origin DNS servers. A maximum of 10 origin DNS servers are supported.
   * 
   * This parameter is required.
   */
  sourceDnsServer?: AddDnsCacheDomainRequestSourceDnsServer[];
  /**
   * @remarks
   * Specifies whether the origin DNS server supports Extension Mechanisms for DNS (EDNS). Valid values: NOT_SUPPORT and SUPPORT.
   * 
   * This parameter is required.
   * 
   * @example
   * SUPPORT
   */
  sourceEdns?: string;
  /**
   * @remarks
   * The origin protocol policy. Valid values: TCP and UDP. Default value: UDP.
   * 
   * This parameter is required.
   * 
   * @example
   * UDP
   */
  sourceProtocol?: string;
  static names(): { [key: string]: string } {
    return {
      cacheTtlMax: 'CacheTtlMax',
      cacheTtlMin: 'CacheTtlMin',
      domainName: 'DomainName',
      instanceId: 'InstanceId',
      lang: 'Lang',
      remark: 'Remark',
      sourceDnsServer: 'SourceDnsServer',
      sourceEdns: 'SourceEdns',
      sourceProtocol: 'SourceProtocol',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cacheTtlMax: 'number',
      cacheTtlMin: 'number',
      domainName: 'string',
      instanceId: 'string',
      lang: 'string',
      remark: 'string',
      sourceDnsServer: { 'type': 'array', 'itemType': AddDnsCacheDomainRequestSourceDnsServer },
      sourceEdns: 'string',
      sourceProtocol: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddDnsCacheDomainResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * B57C121B-A45F-44D8-A9B2-XXXXXXX
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddDnsCacheDomainResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddDnsCacheDomainResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddDnsCacheDomainResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddDnsGtmAccessStrategyRequest extends $tea.Model {
  /**
   * @remarks
   * The address pools in the primary address pool set.
   * 
   * This parameter is required.
   */
  defaultAddrPool?: AddDnsGtmAccessStrategyRequestDefaultAddrPool[];
  /**
   * @remarks
   * The type of the primary address pool. Valid values:
   * 
   * *   IPV4
   * *   IPV6
   * *   DOMAIN
   * 
   * This parameter is required.
   * 
   * @example
   * ipv4
   */
  defaultAddrPoolType?: string;
  /**
   * @remarks
   * Specifies whether to enable DNS resolution with optimal latency for the primary address pool set. Valid values:
   * 
   * *   OPEN
   * *   CLOSE
   * 
   * @example
   * open
   */
  defaultLatencyOptimization?: string;
  /**
   * @remarks
   * The load balancing policy of the primary address pool set. Valid values:
   * 
   * *   ALL_RR: returns all addresses.
   * *   RATIO: returns addresses by weight.
   * 
   * @example
   * all_rr
   */
  defaultLbaStrategy?: string;
  /**
   * @remarks
   * The maximum number of addresses returned from the primary address pool set.
   * 
   * @example
   * 3
   */
  defaultMaxReturnAddrNum?: number;
  /**
   * @remarks
   * The minimum number of available addresses in the primary address pool set.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  defaultMinAvailableAddrNum?: number;
  /**
   * @remarks
   * The address pools in the secondary address pool set. If no address pool exists in the secondary address pool set, set this parameter to EMPTY.
   */
  failoverAddrPool?: AddDnsGtmAccessStrategyRequestFailoverAddrPool[];
  /**
   * @remarks
   * The type of the secondary address pool. Valid values:
   * 
   * *   IPV4
   * *   IPV6
   * *   DOMAIN
   * 
   * @example
   * ipv4
   */
  failoverAddrPoolType?: string;
  /**
   * @remarks
   * Specifies whether to enable DNS resolution with optimal latency for the secondary address pool set. Valid values:
   * 
   * *   OPEN
   * *   CLOSE
   * 
   * @example
   * open
   */
  failoverLatencyOptimization?: string;
  /**
   * @remarks
   * The load balancing policy of the secondary address pool set. Valid values:
   * 
   * *   ALL_RR: returns all addresses.
   * *   RATIO: returns addresses by weight.
   * 
   * @example
   * all_rr
   */
  failoverLbaStrategy?: string;
  /**
   * @remarks
   * The maximum number of addresses returned from the secondary address pool set.
   * 
   * @example
   * 1
   */
  failoverMaxReturnAddrNum?: number;
  /**
   * @remarks
   * The minimum number of available addresses in the secondary address pool set.
   * 
   * @example
   * 1
   */
  failoverMinAvailableAddrNum?: number;
  /**
   * @remarks
   * The instance ID.
   * 
   * This parameter is required.
   * 
   * @example
   * instance1
   */
  instanceId?: string;
  /**
   * @remarks
   * The language of the values for specific response parameters. Default value: en. Valid values: en, zh, and ja.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The Domain Name System (DNS) request source. For example: `["default", "drpeng"]` indicates Global and Dr. Peng Group.
   * 
   * @example
   * ["default", "drpeng"]
   */
  lines?: string;
  /**
   * @remarks
   * The type of the access policy. Valid values:
   * 
   * *   GEO: geographical location-based access policy
   * *   LATENCY: latency-based access policy
   * 
   * This parameter is required.
   * 
   * @example
   * geo
   */
  strategyMode?: string;
  /**
   * @remarks
   * The name of the access policy.
   * 
   * This parameter is required.
   * 
   * @example
   * testStrategyName
   */
  strategyName?: string;
  static names(): { [key: string]: string } {
    return {
      defaultAddrPool: 'DefaultAddrPool',
      defaultAddrPoolType: 'DefaultAddrPoolType',
      defaultLatencyOptimization: 'DefaultLatencyOptimization',
      defaultLbaStrategy: 'DefaultLbaStrategy',
      defaultMaxReturnAddrNum: 'DefaultMaxReturnAddrNum',
      defaultMinAvailableAddrNum: 'DefaultMinAvailableAddrNum',
      failoverAddrPool: 'FailoverAddrPool',
      failoverAddrPoolType: 'FailoverAddrPoolType',
      failoverLatencyOptimization: 'FailoverLatencyOptimization',
      failoverLbaStrategy: 'FailoverLbaStrategy',
      failoverMaxReturnAddrNum: 'FailoverMaxReturnAddrNum',
      failoverMinAvailableAddrNum: 'FailoverMinAvailableAddrNum',
      instanceId: 'InstanceId',
      lang: 'Lang',
      lines: 'Lines',
      strategyMode: 'StrategyMode',
      strategyName: 'StrategyName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      defaultAddrPool: { 'type': 'array', 'itemType': AddDnsGtmAccessStrategyRequestDefaultAddrPool },
      defaultAddrPoolType: 'string',
      defaultLatencyOptimization: 'string',
      defaultLbaStrategy: 'string',
      defaultMaxReturnAddrNum: 'number',
      defaultMinAvailableAddrNum: 'number',
      failoverAddrPool: { 'type': 'array', 'itemType': AddDnsGtmAccessStrategyRequestFailoverAddrPool },
      failoverAddrPoolType: 'string',
      failoverLatencyOptimization: 'string',
      failoverLbaStrategy: 'string',
      failoverMaxReturnAddrNum: 'number',
      failoverMinAvailableAddrNum: 'number',
      instanceId: 'string',
      lang: 'string',
      lines: 'string',
      strategyMode: 'string',
      strategyName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddDnsGtmAccessStrategyResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 29D0F8F8-5499-4F6C-9FDC-1EE13BF55925
   */
  requestId?: string;
  /**
   * @remarks
   * The ID of the access policy.
   * 
   * @example
   * testStrategyId1
   */
  strategyId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      strategyId: 'StrategyId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      strategyId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddDnsGtmAccessStrategyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddDnsGtmAccessStrategyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddDnsGtmAccessStrategyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddDnsGtmAddressPoolRequest extends $tea.Model {
  /**
   * @remarks
   * The address pools.
   * 
   * This parameter is required.
   */
  addr?: AddDnsGtmAddressPoolRequestAddr[];
  /**
   * @remarks
   * The number of consecutive failures.
   * 
   * @example
   * 1
   */
  evaluationCount?: number;
  /**
   * @remarks
   * The instance ID.
   * 
   * This parameter is required.
   * 
   * @example
   * instance1
   */
  instanceId?: string;
  /**
   * @remarks
   * The health check interval. Unit: seconds.
   * 
   * @example
   * 1
   */
  interval?: number;
  /**
   * @remarks
   * The nodes for monitoring.
   */
  ispCityNode?: AddDnsGtmAddressPoolRequestIspCityNode[];
  /**
   * @remarks
   * The language of the values of specific response parameters. Default value: en. Valid values: en, zh, and ja.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The load balancing policy of the address pool. Valid values:
   * 
   * *   ALL_RR: returns all addresses.
   * *   RATIO: returns addresses by weight.
   * 
   * This parameter is required.
   * 
   * @example
   * all_rr
   */
  lbaStrategy?: string;
  /**
   * @remarks
   * The extended information. The required parameters vary based on the value of ProtocolType.
   * 
   * *   When ProtocolType is set to HTTP or HTTPS:
   * 
   *     *   port: the port that you want to check
   * 
   *     *   host: the host settings
   * 
   *     *   path: the URL path
   * 
   *     *   code: the return code. The health check result is deemed abnormal if the returned value is greater than the specified value.
   * 
   *     *   failureRate: the failure rate
   * 
   *     *   sni: specifies whether to enable server name indication (SNI). This parameter is available only when ProtocolType is set to HTTPS. Valid values:
   * 
   *         *   true: enables SNI.
   *         *   other: disables SNI.
   * 
   *     *   nodeType: the type of the node for monitoring when Type is set to DOMAIN. Valid values:
   * 
   *         *   IPV4
   *         *   IPV6
   * 
   * *   When ProtocolType is set to PING:
   * 
   *     *   failureRate: the failure rate
   * 
   *     *   packetNum: the number of ping packets
   * 
   *     *   packetLossRate: the loss rate of ping packets
   * 
   *     *   nodeType: the type of the node for monitoring when Type is set to DOMAIN. Valid values:
   * 
   *         *   IPV4
   *         *   IPV6
   * 
   * *   When ProtocolType is set to TCP:
   * 
   *     *   port: the port that you want to check
   * 
   *     *   failureRate: the failure rate
   * 
   *     *   nodeType: the type of the node for monitoring when Type is set to DOMAIN. Valid values:
   * 
   *         *   IPV4
   *         *   IPV6
   * 
   * @example
   * {\\"code\\":200,\\"path\\":\\"\\\\index.htm\\",\\"host\\":\\"aliyun.com\\"}
   */
  monitorExtendInfo?: string;
  /**
   * @remarks
   * Specifies whether to enable the health check feature. If you set this parameter to OPEN, the system verifies the health check configurations. If you set this parameter to CLOSE, the system discards the health check configurations. Default value: CLOSE. Valid values:
   * 
   * *   OPEN: enables the health check feature.
   * *   CLOSE: disables the health check feature.
   * 
   * @example
   * open
   */
  monitorStatus?: string;
  /**
   * @remarks
   * The name of the address pool.
   * 
   * This parameter is required.
   * 
   * @example
   * test
   */
  name?: string;
  /**
   * @remarks
   * The health check protocol. Valid values:
   * 
   * *   HTTP
   * *   HTTPS
   * *   PING
   * *   TCP
   * 
   * @example
   * http
   */
  protocolType?: string;
  /**
   * @remarks
   * The timeout period. Unit: milliseconds.
   * 
   * @example
   * 1
   */
  timeout?: number;
  /**
   * @remarks
   * The type of the address pool. Valid values:
   * 
   * *   IPV4: IPv4 address
   * *   IPV6: IPv6 address
   * *   DOMAIN: domain name
   * 
   * This parameter is required.
   * 
   * @example
   * ipv4
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      addr: 'Addr',
      evaluationCount: 'EvaluationCount',
      instanceId: 'InstanceId',
      interval: 'Interval',
      ispCityNode: 'IspCityNode',
      lang: 'Lang',
      lbaStrategy: 'LbaStrategy',
      monitorExtendInfo: 'MonitorExtendInfo',
      monitorStatus: 'MonitorStatus',
      name: 'Name',
      protocolType: 'ProtocolType',
      timeout: 'Timeout',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addr: { 'type': 'array', 'itemType': AddDnsGtmAddressPoolRequestAddr },
      evaluationCount: 'number',
      instanceId: 'string',
      interval: 'number',
      ispCityNode: { 'type': 'array', 'itemType': AddDnsGtmAddressPoolRequestIspCityNode },
      lang: 'string',
      lbaStrategy: 'string',
      monitorExtendInfo: 'string',
      monitorStatus: 'string',
      name: 'string',
      protocolType: 'string',
      timeout: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddDnsGtmAddressPoolResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the address pool.
   * 
   * @example
   * testpool1
   */
  addrPoolId?: string;
  /**
   * @remarks
   * The ID of the health check task.
   * 
   * @example
   * test1
   */
  monitorConfigId?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 6856BCF6-11D6-4D7E-AC53-FD579933522B
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      addrPoolId: 'AddrPoolId',
      monitorConfigId: 'MonitorConfigId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addrPoolId: 'string',
      monitorConfigId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddDnsGtmAddressPoolResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddDnsGtmAddressPoolResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddDnsGtmAddressPoolResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddDnsGtmMonitorRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the address pool.
   * 
   * This parameter is required.
   * 
   * @example
   * pool1
   */
  addrPoolId?: string;
  /**
   * @remarks
   * The maximum number of consecutive exceptions detected. If the number of consecutive exceptions detected reaches the maximum number, the application service is deemed abnormal.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  evaluationCount?: number;
  /**
   * @remarks
   * The health check interval. Unit: seconds.
   * 
   * This parameter is required.
   * 
   * @example
   * 60
   */
  interval?: number;
  /**
   * @remarks
   * The monitored nodes.
   * 
   * This parameter is required.
   */
  ispCityNode?: AddDnsGtmMonitorRequestIspCityNode[];
  /**
   * @remarks
   * The language of the values of specific response parameters. Default value: en. Valid values: en, zh, and ja.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The extended information, that is, the parameters required for the protocol. Different protocols require different parameters:
   * 
   * *   HTTP or HTTPS:
   * 
   *     *   port: the port to check.
   * 
   *     *   host: the host configuration.
   * 
   *     *   path: the health check URL.
   * 
   *     *   code: the status code threshold. If the returned status code is greater than the specified threshold, the application service is deemed abnormal.
   * 
   *     *   failureRate: the failure rate.
   * 
   *     *   sni: specifies whether to enable Server Name Indication (SNI). This parameter is only required for the HTTPS protocol. Valid values:
   * 
   *         *   true: enables SNI.
   *         *   false: disables SNI.
   * 
   *     *   nodeType: the type of the monitored node when the address pool type is DOMAIN. Valid values:
   * 
   *         *   IPV4
   *         *   IPV6
   * 
   * *   PING:
   * 
   *     *   failureRate: the failure rate.
   * 
   *     *   packetNum: the number of ping packets.
   * 
   *     *   packetLossRate: the loss rate of ping packets.
   * 
   *     *   nodeType: the type of the monitored node when the address pool type is DOMAIN. Valid values:
   * 
   *         *   IPV4
   *         *   IPV6
   * 
   * *   TCP:
   * 
   *     *   port: the port to check.
   * 
   *     *   failureRate: the failure rate.
   * 
   *     *   nodeType: the type of the monitored node when the address pool type is DOMAIN. Valid values:
   * 
   *         *   IPV4
   *         *   IPV6
   * 
   * This parameter is required.
   * 
   * @example
   * {\\"code\\":200,\\"path\\":\\"\\\\index.htm\\",\\"host\\":\\"aliyun.com\\"}
   */
  monitorExtendInfo?: string;
  /**
   * @remarks
   * The protocol used for the health check. Valid values:
   * 
   * *   HTTP
   * *   HTTPS
   * *   PING
   * *   TCP
   * 
   * This parameter is required.
   * 
   * @example
   * http
   */
  protocolType?: string;
  /**
   * @remarks
   * The health check timeout period. Unit: milliseconds.
   * 
   * This parameter is required.
   * 
   * @example
   * 30000
   */
  timeout?: number;
  static names(): { [key: string]: string } {
    return {
      addrPoolId: 'AddrPoolId',
      evaluationCount: 'EvaluationCount',
      interval: 'Interval',
      ispCityNode: 'IspCityNode',
      lang: 'Lang',
      monitorExtendInfo: 'MonitorExtendInfo',
      protocolType: 'ProtocolType',
      timeout: 'Timeout',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addrPoolId: 'string',
      evaluationCount: 'number',
      interval: 'number',
      ispCityNode: { 'type': 'array', 'itemType': AddDnsGtmMonitorRequestIspCityNode },
      lang: 'string',
      monitorExtendInfo: 'string',
      protocolType: 'string',
      timeout: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddDnsGtmMonitorResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the health check configuration.
   * 
   * @example
   * MonitorConfigId1
   */
  monitorConfigId?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 6856BCF6-11D6-4D7E-AC53-FD579933522B
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      monitorConfigId: 'MonitorConfigId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      monitorConfigId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddDnsGtmMonitorResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddDnsGtmMonitorResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddDnsGtmMonitorResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddDomainRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name.
   * 
   * This parameter is required.
   * 
   * @example
   * dns-example.top
   */
  domainName?: string;
  /**
   * @remarks
   * The ID of the group to which the domain name will belong. The default value is the ID of the default group.
   * 
   * @example
   * 2223
   */
  groupId?: string;
  /**
   * @remarks
   * The language.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The ID of the resource group.
   * 
   * @example
   * rg-resourcegroupid
   */
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      groupId: 'GroupId',
      lang: 'Lang',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      groupId: 'string',
      lang: 'string',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddDomainResponseBody extends $tea.Model {
  /**
   * @remarks
   * The Domain Name System (DNS) servers configured for the domain name.
   */
  dnsServers?: AddDomainResponseBodyDnsServers;
  /**
   * @remarks
   * The ID of the domain name.
   * 
   * @example
   * 00efd71a-770e-4255-b54e-6fe5659baffe
   */
  domainId?: string;
  /**
   * @remarks
   * The domain name.
   * 
   * @example
   * dns-example.top
   */
  domainName?: string;
  /**
   * @remarks
   * The ID of the domain name group.
   * 
   * @example
   * 2223
   */
  groupId?: string;
  /**
   * @remarks
   * The name of the domain name group.
   * 
   * @example
   * MyGroup
   */
  groupName?: string;
  /**
   * @remarks
   * The Punycode for the domain name. This parameter is returned only for Chinese domain names.
   * 
   * @example
   * xn--fsq270a.com
   */
  punyCode?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 536E9CAD-DB30-4647-AC87-AA5CC38C5382
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      dnsServers: 'DnsServers',
      domainId: 'DomainId',
      domainName: 'DomainName',
      groupId: 'GroupId',
      groupName: 'GroupName',
      punyCode: 'PunyCode',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dnsServers: AddDomainResponseBodyDnsServers,
      domainId: 'string',
      domainName: 'string',
      groupId: 'string',
      groupName: 'string',
      punyCode: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddDomainResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddDomainResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddDomainResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddDomainBackupRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name.
   * 
   * This parameter is required.
   * 
   * @example
   * test.aliyun.com
   */
  domainName?: string;
  /**
   * @remarks
   * The language in which you want the values of some response parameters to be returned. These response parameters support multiple languages.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The backup cycle. Valid values:
   * 
   * *   **DAY**: Backs up data once every day.
   * *   **HOUR**: Backs up data once every hour.
   * 
   * This parameter is required.
   * 
   * @example
   * HOUR
   */
  periodType?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      lang: 'Lang',
      periodType: 'PeriodType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      lang: 'string',
      periodType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddDomainBackupResponseBody extends $tea.Model {
  /**
   * @remarks
   * The domain name.
   * 
   * @example
   * test.aliyun.com
   */
  domainName?: string;
  /**
   * @remarks
   * The backup cycle.
   * 
   * @example
   * DAY
   */
  periodType?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * FD552816-FCC8-4832-B4A2-2DA0C2BA1688
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      periodType: 'PeriodType',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      periodType: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddDomainBackupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddDomainBackupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddDomainBackupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddDomainGroupRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the domain name group.
   * 
   * This parameter is required.
   * 
   * @example
   * MyGroup
   */
  groupName?: string;
  /**
   * @remarks
   * The language.
   * 
   * @example
   * en
   */
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      groupName: 'GroupName',
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupName: 'string',
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddDomainGroupResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the domain name group.
   * 
   * @example
   * 2223
   */
  groupId?: string;
  /**
   * @remarks
   * The name of the domain name group.
   * 
   * @example
   * NewName
   */
  groupName?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 536E9CAD-DB30-4647-AC87-AA5CC38C5382
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      groupName: 'GroupName',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      groupName: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddDomainGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddDomainGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddDomainGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddDomainRecordRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The language.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The DNS resolution line. Default value: **default**. For more information, see
   * 
   * [DNS lines](https://www.alibabacloud.com/help/zh/doc-detail/29807.htm).
   * 
   * @example
   * default
   */
  line?: string;
  /**
   * @remarks
   * The priority of the mail exchanger (MX) record. Valid values: `1 to 50`.
   * 
   * This parameter must be specified if the type of the DNS record is MX. A smaller value indicates a higher priority.
   * 
   * @example
   * 1
   */
  priority?: number;
  /**
   * @remarks
   * The hostname.
   * 
   * For example, if you want to resolve @.example.com, you must set RR to an at sign (@) instead of leaving it empty.
   * 
   * This parameter is required.
   * 
   * @example
   * www
   */
  RR?: string;
  /**
   * @remarks
   * The time-to-live (TTL) of the DNS record. Default value: 600. Unit: seconds. For more information, see
   * 
   * [TTL definition](https://www.alibabacloud.com/help/zh/doc-detail/29806.htm).
   * 
   * @example
   * 600
   */
  TTL?: number;
  /**
   * @remarks
   * The type of the DNS record. For more information, see
   * 
   * [DNS record types](https://www.alibabacloud.com/help/zh/doc-detail/29805.htm).
   * 
   * This parameter is required.
   * 
   * @example
   * A
   */
  type?: string;
  /**
   * @remarks
   * The IP address of the client.
   * 
   * @example
   * 192.0.2.0
   */
  userClientIp?: string;
  /**
   * @remarks
   * The record value.
   * 
   * This parameter is required.
   * 
   * @example
   * 192.0.2.254
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      lang: 'Lang',
      line: 'Line',
      priority: 'Priority',
      RR: 'RR',
      TTL: 'TTL',
      type: 'Type',
      userClientIp: 'UserClientIp',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      lang: 'string',
      line: 'string',
      priority: 'number',
      RR: 'string',
      TTL: 'number',
      type: 'string',
      userClientIp: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddDomainRecordResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the DNS record.
   * 
   * @example
   * 9999985
   */
  recordId?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 536E9CAD-DB30-4647-AC87-AA5CC38C5382
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      recordId: 'RecordId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      recordId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddDomainRecordResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddDomainRecordResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddDomainRecordResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGtmAccessStrategyRequest extends $tea.Model {
  /**
   * @remarks
   * The line codes of access regions.
   * 
   * This parameter is required.
   * 
   * @example
   * ["default", "drpeng"]
   */
  accessLines?: string;
  /**
   * @remarks
   * The ID of the default address pool.
   * 
   * This parameter is required.
   * 
   * @example
   * hrsix
   */
  defaultAddrPoolId?: string;
  /**
   * @remarks
   * The ID of the failover address pool.
   * 
   * If the failover address pool is not set, pass the **Empty** value.
   * 
   * This parameter is required.
   * 
   * @example
   * hrsyw
   */
  failoverAddrPoolId?: string;
  /**
   * @remarks
   * The ID of the GTM instance for which you want to create an access policy.
   * 
   * This parameter is required.
   * 
   * @example
   * instance1
   */
  instanceId?: string;
  /**
   * @remarks
   * The language used by the user.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The name of the access policy.
   * 
   * This parameter is required.
   */
  strategyName?: string;
  static names(): { [key: string]: string } {
    return {
      accessLines: 'AccessLines',
      defaultAddrPoolId: 'DefaultAddrPoolId',
      failoverAddrPoolId: 'FailoverAddrPoolId',
      instanceId: 'InstanceId',
      lang: 'Lang',
      strategyName: 'StrategyName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessLines: 'string',
      defaultAddrPoolId: 'string',
      failoverAddrPoolId: 'string',
      instanceId: 'string',
      lang: 'string',
      strategyName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGtmAccessStrategyResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 29D0F8F8-5499-4F6C-9FDC-1EE13BF55925
   */
  requestId?: string;
  /**
   * @remarks
   * The ID of the access policy created.
   * 
   * @example
   * strategyid
   */
  strategyId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      strategyId: 'StrategyId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      strategyId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGtmAccessStrategyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddGtmAccessStrategyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddGtmAccessStrategyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGtmAddressPoolRequest extends $tea.Model {
  /**
   * @remarks
   * The address pools.
   * 
   * This parameter is required.
   */
  addr?: AddGtmAddressPoolRequestAddr[];
  /**
   * @remarks
   * The number of consecutive failures.
   * 
   * @example
   * 2
   */
  evaluationCount?: number;
  /**
   * @remarks
   * The ID of the GTM instance for which you want to create an address pool.
   * 
   * This parameter is required.
   * 
   * @example
   * gtm-cn-xxxxxxx
   */
  instanceId?: string;
  /**
   * @remarks
   * The health check interval. Unit: seconds. Set the value to 60.
   * 
   * @example
   * 60
   */
  interval?: number;
  /**
   * @remarks
   * The monitored nodes.
   */
  ispCityNode?: AddGtmAddressPoolRequestIspCityNode[];
  /**
   * @remarks
   * The language of the values of specific response parameters.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The minimum number of available addresses in the address pool.
   * 
   * This parameter is required.
   * 
   * @example
   * 2
   */
  minAvailableAddrNum?: number;
  /**
   * @remarks
   * The extended information. The required parameters vary based on the value of ProtocolType.
   * 
   * When ProtocolType is set to HTTP or HTTPS:
   * 
   * *   port: the port that you want to check
   * *   failureRate: the failure rate
   * *   code: the return code. The health check result is deemed abnormal if the returned value is greater than the specified value. Valid values: 400 and 500.
   * *   host: the host settings
   * *   path: the URL path
   * 
   * When ProtocolType is set to PING:
   * 
   * *   packetNum: the number of ping packets
   * *   packetLossRate: the packet loss rate
   * *   failureRate: the failure rate
   * 
   * When ProtocolType is set to TCP:
   * 
   * *   port: the port that you want to check
   * *   failureRate: the failure rate
   * 
   * @example
   * {"host":"aliyun.com","port":80}
   */
  monitorExtendInfo?: string;
  /**
   * @remarks
   * Specifies whether to enable the health check. Valid values:
   * 
   * *   **OPEN**: enables the health check.
   * *   **CLOSE**: disables the health check. This is the default value.
   * 
   * @example
   * OPEN
   */
  monitorStatus?: string;
  /**
   * @remarks
   * The name of the address pool.
   * 
   * This parameter is required.
   * 
   * @example
   * Alibaba Cloud cluster
   */
  name?: string;
  /**
   * @remarks
   * The health check protocol. Valid values:
   * 
   * *   HTTP
   * *   HTTPS
   * *   Ping
   * *   TCP
   * 
   * @example
   * HTTPS
   */
  protocolType?: string;
  /**
   * @remarks
   * The timeout period. Unit: milliseconds. Valid values: 2000, 3000, 5000, and 10000.
   * 
   * @example
   * 60
   */
  timeout?: number;
  /**
   * @remarks
   * The type of the address pool. Valid values:
   * 
   * *   **IP**: IPv4 address
   * *   **DOMAIN**: domain name
   * 
   * This parameter is required.
   * 
   * @example
   * IP
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      addr: 'Addr',
      evaluationCount: 'EvaluationCount',
      instanceId: 'InstanceId',
      interval: 'Interval',
      ispCityNode: 'IspCityNode',
      lang: 'Lang',
      minAvailableAddrNum: 'MinAvailableAddrNum',
      monitorExtendInfo: 'MonitorExtendInfo',
      monitorStatus: 'MonitorStatus',
      name: 'Name',
      protocolType: 'ProtocolType',
      timeout: 'Timeout',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addr: { 'type': 'array', 'itemType': AddGtmAddressPoolRequestAddr },
      evaluationCount: 'number',
      instanceId: 'string',
      interval: 'number',
      ispCityNode: { 'type': 'array', 'itemType': AddGtmAddressPoolRequestIspCityNode },
      lang: 'string',
      minAvailableAddrNum: 'number',
      monitorExtendInfo: 'string',
      monitorStatus: 'string',
      name: 'string',
      protocolType: 'string',
      timeout: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGtmAddressPoolResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the address pool created.
   * 
   * @example
   * hraf3x
   */
  addrPoolId?: string;
  /**
   * @remarks
   * The ID of the health check configuration.
   * 
   * @example
   * hraf14
   */
  monitorConfigId?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 6856BCF6-11D6-4D7E-AC53-FD579933522B
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      addrPoolId: 'AddrPoolId',
      monitorConfigId: 'MonitorConfigId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addrPoolId: 'string',
      monitorConfigId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGtmAddressPoolResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddGtmAddressPoolResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddGtmAddressPoolResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGtmMonitorRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the address pool.
   * 
   * This parameter is required.
   * 
   * @example
   * xxxx
   */
  addrPoolId?: string;
  /**
   * @remarks
   * The number of consecutive failures.
   * 
   * This parameter is required.
   * 
   * @example
   * 3
   */
  evaluationCount?: number;
  /**
   * @remarks
   * The health check interval. Unit: seconds. Set the value to 60.
   * 
   * This parameter is required.
   * 
   * @example
   * 60
   */
  interval?: number;
  /**
   * @remarks
   * The nodes for monitoring.
   * 
   * This parameter is required.
   */
  ispCityNode?: AddGtmMonitorRequestIspCityNode[];
  /**
   * @remarks
   * The language.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The extended information. The required parameters vary based on the health check protocol.
   * 
   * HTTP or HTTPS
   * 
   * *   port: the port that you want to check
   * *   failureRate: the failure rate
   * *   code: the return code. The health check result is deemed abnormal if the returned value is greater than the specified value. Valid values: 400 and 500.
   * *   host: the host settings
   * *   path: the URL path
   * 
   * PING
   * 
   * *   packetNum: the number of ping packets
   * *   packetLossRate: the packet loss rate
   * *   failureRate: the failure rate
   * 
   * TCP
   * 
   * *   port: the port that you want to check
   * *   failureRate: the failure rate
   * 
   * This parameter is required.
   * 
   * @example
   * {\\"code\\":200,\\"path\\":\\"/index.htm\\",\\"host\\":\\"aliyun.com\\"}
   */
  monitorExtendInfo?: string;
  /**
   * @remarks
   * The protocol used for the health check. Valid values:
   * 
   * *   HTTP
   * *   HTTPS
   * *   PING
   * *   TCP
   * 
   * This parameter is required.
   * 
   * @example
   * HTTP
   */
  protocolType?: string;
  /**
   * @remarks
   * The health check timeout period. Unit: milliseconds. Valid values: 2000, 3000, 5000, and 10000.
   * 
   * This parameter is required.
   * 
   * @example
   * 3000
   */
  timeout?: number;
  static names(): { [key: string]: string } {
    return {
      addrPoolId: 'AddrPoolId',
      evaluationCount: 'EvaluationCount',
      interval: 'Interval',
      ispCityNode: 'IspCityNode',
      lang: 'Lang',
      monitorExtendInfo: 'MonitorExtendInfo',
      protocolType: 'ProtocolType',
      timeout: 'Timeout',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addrPoolId: 'string',
      evaluationCount: 'number',
      interval: 'number',
      ispCityNode: { 'type': 'array', 'itemType': AddGtmMonitorRequestIspCityNode },
      lang: 'string',
      monitorExtendInfo: 'string',
      protocolType: 'string',
      timeout: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGtmMonitorResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the health check configuration.
   * 
   * @example
   * 1234abc
   */
  monitorConfigId?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 6856BCF6-11D6-4D7E-AC53-FD579933522B
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      monitorConfigId: 'MonitorConfigId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      monitorConfigId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGtmMonitorResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddGtmMonitorResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddGtmMonitorResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGtmRecoveryPlanRequest extends $tea.Model {
  /**
   * @remarks
   * The list of IDs of faulty address pools.
   * 
   * This parameter is required.
   * 
   * @example
   * ["hra0or"]
   */
  faultAddrPool?: string;
  /**
   * @remarks
   * The language used by the user.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The name of the disaster recovery plan that you want to create.
   * 
   * This parameter is required.
   * 
   * @example
   * name-example
   */
  name?: string;
  /**
   * @remarks
   * The remarks on the disaster recovery plan.
   * 
   * @example
   * remark
   */
  remark?: string;
  static names(): { [key: string]: string } {
    return {
      faultAddrPool: 'FaultAddrPool',
      lang: 'Lang',
      name: 'Name',
      remark: 'Remark',
    };
  }

  static types(): { [key: string]: any } {
    return {
      faultAddrPool: 'string',
      lang: 'string',
      name: 'string',
      remark: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGtmRecoveryPlanResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the disaster recovery plan created.
   * 
   * @example
   * 100
   */
  recoveryPlanId?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 6856BCF6-11D6-4D7E-AC53-FD579933522B
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      recoveryPlanId: 'RecoveryPlanId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      recoveryPlanId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGtmRecoveryPlanResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddGtmRecoveryPlanResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddGtmRecoveryPlanResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindInstanceDomainsRequest extends $tea.Model {
  /**
   * @remarks
   * The domain names.
   * 
   * >  Separate multiple domain names with commas (,). Up to 100 domain names can be entered.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com,example.net
   */
  domainNames?: string;
  /**
   * @remarks
   * The instance ID.
   * 
   * This parameter is required.
   * 
   * @example
   * sdfasdf
   */
  instanceId?: string;
  /**
   * @remarks
   * The language.
   * 
   * @example
   * en
   */
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      domainNames: 'DomainNames',
      instanceId: 'InstanceId',
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainNames: 'string',
      instanceId: 'string',
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindInstanceDomainsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The number of domain names that failed to be bound to the instance.
   * 
   * @example
   * 0
   */
  failedCount?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 536E9CAD-DB30-4647-AC87-AA5CC38C5382
   */
  requestId?: string;
  /**
   * @remarks
   * The number of domain names that are bound to the instance.
   * 
   * @example
   * 2
   */
  successCount?: number;
  static names(): { [key: string]: string } {
    return {
      failedCount: 'FailedCount',
      requestId: 'RequestId',
      successCount: 'SuccessCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failedCount: 'number',
      requestId: 'string',
      successCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindInstanceDomainsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: BindInstanceDomainsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BindInstanceDomainsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeDomainGroupRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The ID of the destination domain name group.
   * 
   * *   If you do not specify GroupId, the domain name is moved to the default group.
   * *   If you set GroupId to an empty string, the domain name is moved to the default group.
   * *   If you set GroupId to defaultGroup, the domain name is moved to the default group.
   * *   If you do not set GroupId to one of the preceding values and set GroupId to an existing group ID, the domain name is moved to the existing group. If you set GroupId to a group ID that does not exist, the domain name remains in the original group.
   * 
   * @example
   * 2223
   */
  groupId?: string;
  /**
   * @remarks
   * The language.
   * 
   * @example
   * en
   */
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      groupId: 'GroupId',
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      groupId: 'string',
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeDomainGroupResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the destination domain name group.
   * 
   * @example
   * 2223
   */
  groupId?: string;
  /**
   * @remarks
   * The name of the destination domain name group.
   * 
   * @example
   * MyGroup
   */
  groupName?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 536E9CAD-DB30-4647-AC87-AA5CC38C5382
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      groupName: 'GroupName',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      groupName: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeDomainGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ChangeDomainGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ChangeDomainGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeDomainOfDnsProductRequest extends $tea.Model {
  /**
   * @remarks
   * Specifies whether to force bind a domain name to the instance.
   * 
   * @example
   * false
   */
  force?: boolean;
  /**
   * @remarks
   * The ID of the Alibaba Cloud DNS instance.
   * 
   * This parameter is required.
   * 
   * @example
   * i-7sb
   */
  instanceId?: string;
  /**
   * @remarks
   * The language in which you want the values of some response parameters to be returned. These response parameters support multiple languages.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The domain name that you want to bind to the instance. If you do not specify this parameter, this operation unbinds the original domain name from the instance.
   * 
   * @example
   * newdomain.com
   */
  newDomain?: string;
  /**
   * @remarks
   * The IP address of the client.
   * 
   * @example
   * 1.1.1.1
   */
  userClientIp?: string;
  static names(): { [key: string]: string } {
    return {
      force: 'Force',
      instanceId: 'InstanceId',
      lang: 'Lang',
      newDomain: 'NewDomain',
      userClientIp: 'UserClientIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      force: 'boolean',
      instanceId: 'string',
      lang: 'string',
      newDomain: 'string',
      userClientIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeDomainOfDnsProductResponseBody extends $tea.Model {
  /**
   * @remarks
   * The original domain name that was bound to the instance. If the value of this parameter is empty, the instance is bound with a domain name for the first time.
   * 
   * @example
   * originaldomain.com
   */
  originalDomain?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 536E9CAD-DB30-4647-AC87-AA5CC38C5382
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      originalDomain: 'OriginalDomain',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      originalDomain: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeDomainOfDnsProductResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ChangeDomainOfDnsProductResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ChangeDomainOfDnsProductResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CopyGtmConfigRequest extends $tea.Model {
  /**
   * @remarks
   * The type of the object that you want to copy. Only the INSTANCE type is supported.
   * 
   * This parameter is required.
   * 
   * @example
   * INSTANCE
   */
  copyType?: string;
  /**
   * @remarks
   * The language that specific response parameters will use.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The ID of the source object. Only instance IDs are supported.
   * 
   * This parameter is required.
   * 
   * @example
   * gtm-cn-0pp1j84v60d
   */
  sourceId?: string;
  /**
   * @remarks
   * The ID of the target object. Only instance IDs are supported.
   * 
   * This parameter is required.
   * 
   * @example
   * gtm-cn-v0h1gaujg06
   */
  targetId?: string;
  static names(): { [key: string]: string } {
    return {
      copyType: 'CopyType',
      lang: 'Lang',
      sourceId: 'SourceId',
      targetId: 'TargetId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      copyType: 'string',
      lang: 'string',
      sourceId: 'string',
      targetId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CopyGtmConfigResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 389DFFA3-77A5-4A9E-BF3D-147C6F98A5BA
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CopyGtmConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CopyGtmConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CopyGtmConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCloudGtmAddressRequest extends $tea.Model {
  /**
   * @example
   * zh-CN
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 223.5.XX.XX
   */
  address?: string;
  attributeInfo?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * auto
   */
  availableMode?: string;
  /**
   * @example
   * 1ae05db4-10e7-11ef-b126-00163e24**22
   */
  clientToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * enable
   */
  enableStatus?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * p50_ok
   */
  healthJudgement?: string;
  healthTasks?: CreateCloudGtmAddressRequestHealthTasks[];
  /**
   * @example
   * available
   */
  manualAvailableStatus?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * Address-1
   */
  name?: string;
  /**
   * @example
   * test
   */
  remark?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * IPv4
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      address: 'Address',
      attributeInfo: 'AttributeInfo',
      availableMode: 'AvailableMode',
      clientToken: 'ClientToken',
      enableStatus: 'EnableStatus',
      healthJudgement: 'HealthJudgement',
      healthTasks: 'HealthTasks',
      manualAvailableStatus: 'ManualAvailableStatus',
      name: 'Name',
      remark: 'Remark',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      address: 'string',
      attributeInfo: 'string',
      availableMode: 'string',
      clientToken: 'string',
      enableStatus: 'string',
      healthJudgement: 'string',
      healthTasks: { 'type': 'array', 'itemType': CreateCloudGtmAddressRequestHealthTasks },
      manualAvailableStatus: 'string',
      name: 'string',
      remark: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCloudGtmAddressShrinkRequest extends $tea.Model {
  /**
   * @example
   * zh-CN
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 223.5.XX.XX
   */
  address?: string;
  attributeInfo?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * auto
   */
  availableMode?: string;
  /**
   * @example
   * 1ae05db4-10e7-11ef-b126-00163e24**22
   */
  clientToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * enable
   */
  enableStatus?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * p50_ok
   */
  healthJudgement?: string;
  healthTasksShrink?: string;
  /**
   * @example
   * available
   */
  manualAvailableStatus?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * Address-1
   */
  name?: string;
  /**
   * @example
   * test
   */
  remark?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * IPv4
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      address: 'Address',
      attributeInfo: 'AttributeInfo',
      availableMode: 'AvailableMode',
      clientToken: 'ClientToken',
      enableStatus: 'EnableStatus',
      healthJudgement: 'HealthJudgement',
      healthTasksShrink: 'HealthTasks',
      manualAvailableStatus: 'ManualAvailableStatus',
      name: 'Name',
      remark: 'Remark',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      address: 'string',
      attributeInfo: 'string',
      availableMode: 'string',
      clientToken: 'string',
      enableStatus: 'string',
      healthJudgement: 'string',
      healthTasksShrink: 'string',
      manualAvailableStatus: 'string',
      name: 'string',
      remark: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCloudGtmAddressResponseBody extends $tea.Model {
  /**
   * @example
   * addr-8951821811436**192
   */
  addressId?: string;
  /**
   * @example
   * 46973D4C-E3E4-4ABA-9190-9A9DE406C7E
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      addressId: 'AddressId',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addressId: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCloudGtmAddressResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateCloudGtmAddressResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateCloudGtmAddressResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCloudGtmAddressPoolRequest extends $tea.Model {
  /**
   * @example
   * en-US
   */
  acceptLanguage?: string;
  /**
   * @example
   * Address pool-1
   */
  addressPoolName?: string;
  /**
   * @example
   * IPv4
   */
  addressPoolType?: string;
  /**
   * @example
   * 1ae05db4-10e7-11ef-b126-00163e24**22
   */
  clientToken?: string;
  /**
   * @example
   * enable
   */
  enableStatus?: string;
  /**
   * @example
   * any_ok
   */
  healthJudgement?: string;
  /**
   * @example
   * app
   */
  remark?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      addressPoolName: 'AddressPoolName',
      addressPoolType: 'AddressPoolType',
      clientToken: 'ClientToken',
      enableStatus: 'EnableStatus',
      healthJudgement: 'HealthJudgement',
      remark: 'Remark',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      addressPoolName: 'string',
      addressPoolType: 'string',
      clientToken: 'string',
      enableStatus: 'string',
      healthJudgement: 'string',
      remark: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCloudGtmAddressPoolResponseBody extends $tea.Model {
  /**
   * @example
   * pool-89528023225442**16
   */
  addressPoolId?: string;
  /**
   * @example
   * 46973D4C-E3E4-4ABA-9190-9A9DE406C7E
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      addressPoolId: 'AddressPoolId',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addressPoolId: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCloudGtmAddressPoolResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateCloudGtmAddressPoolResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateCloudGtmAddressPoolResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCloudGtmInstanceConfigRequest extends $tea.Model {
  /**
   * @example
   * en-US
   */
  acceptLanguage?: string;
  /**
   * @example
   * 1ae05db4-10e7-11ef-b126-00163e24**22
   */
  clientToken?: string;
  /**
   * @example
   * enable
   */
  enableStatus?: string;
  /**
   * @example
   * gtm-cn-jmp3qnw**03
   */
  instanceId?: string;
  /**
   * @example
   * test
   */
  remark?: string;
  /**
   * @example
   * www
   */
  scheduleHostname?: string;
  /**
   * @example
   * A
   */
  scheduleRrType?: string;
  /**
   * @example
   * custom
   */
  scheduleZoneMode?: string;
  /**
   * @example
   * example.com
   */
  scheduleZoneName?: string;
  /**
   * @example
   * 30
   */
  ttl?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      clientToken: 'ClientToken',
      enableStatus: 'EnableStatus',
      instanceId: 'InstanceId',
      remark: 'Remark',
      scheduleHostname: 'ScheduleHostname',
      scheduleRrType: 'ScheduleRrType',
      scheduleZoneMode: 'ScheduleZoneMode',
      scheduleZoneName: 'ScheduleZoneName',
      ttl: 'Ttl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      clientToken: 'string',
      enableStatus: 'string',
      instanceId: 'string',
      remark: 'string',
      scheduleHostname: 'string',
      scheduleRrType: 'string',
      scheduleZoneMode: 'string',
      scheduleZoneName: 'string',
      ttl: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCloudGtmInstanceConfigResponseBody extends $tea.Model {
  /**
   * @example
   * config-000**1
   */
  configId?: boolean;
  /**
   * @example
   * 536E9CAD-DB30-4647-AC87-AA5CC38C5382
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'boolean',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCloudGtmInstanceConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateCloudGtmInstanceConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateCloudGtmInstanceConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCloudGtmMonitorTemplateRequest extends $tea.Model {
  /**
   * @example
   * en-US
   */
  acceptLanguage?: string;
  /**
   * @example
   * 1ae05db4-10e7-11ef-b126-00163e24**22
   */
  clientToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 2
   */
  evaluationCount?: number;
  /**
   * @example
   * {\\"code\\":200,\\"path\\":\\"\\\\index.htm\\",\\"host\\":\\"aliyun.com\\"}
   */
  extendInfo?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 50
   */
  failureRate?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 60
   */
  interval?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * IPv4
   */
  ipVersion?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  ispCityNodes?: CreateCloudGtmMonitorTemplateRequestIspCityNodes[];
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * Ping-IPv4
   */
  name?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * ping
   */
  protocol?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 5000
   */
  timeout?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      clientToken: 'ClientToken',
      evaluationCount: 'EvaluationCount',
      extendInfo: 'ExtendInfo',
      failureRate: 'FailureRate',
      interval: 'Interval',
      ipVersion: 'IpVersion',
      ispCityNodes: 'IspCityNodes',
      name: 'Name',
      protocol: 'Protocol',
      timeout: 'Timeout',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      clientToken: 'string',
      evaluationCount: 'number',
      extendInfo: 'string',
      failureRate: 'number',
      interval: 'number',
      ipVersion: 'string',
      ispCityNodes: { 'type': 'array', 'itemType': CreateCloudGtmMonitorTemplateRequestIspCityNodes },
      name: 'string',
      protocol: 'string',
      timeout: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCloudGtmMonitorTemplateShrinkRequest extends $tea.Model {
  /**
   * @example
   * en-US
   */
  acceptLanguage?: string;
  /**
   * @example
   * 1ae05db4-10e7-11ef-b126-00163e24**22
   */
  clientToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 2
   */
  evaluationCount?: number;
  /**
   * @example
   * {\\"code\\":200,\\"path\\":\\"\\\\index.htm\\",\\"host\\":\\"aliyun.com\\"}
   */
  extendInfo?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 50
   */
  failureRate?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 60
   */
  interval?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * IPv4
   */
  ipVersion?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  ispCityNodesShrink?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * Ping-IPv4
   */
  name?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * ping
   */
  protocol?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 5000
   */
  timeout?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      clientToken: 'ClientToken',
      evaluationCount: 'EvaluationCount',
      extendInfo: 'ExtendInfo',
      failureRate: 'FailureRate',
      interval: 'Interval',
      ipVersion: 'IpVersion',
      ispCityNodesShrink: 'IspCityNodes',
      name: 'Name',
      protocol: 'Protocol',
      timeout: 'Timeout',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      clientToken: 'string',
      evaluationCount: 'number',
      extendInfo: 'string',
      failureRate: 'number',
      interval: 'number',
      ipVersion: 'string',
      ispCityNodesShrink: 'string',
      name: 'string',
      protocol: 'string',
      timeout: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCloudGtmMonitorTemplateResponseBody extends $tea.Model {
  /**
   * @example
   * B57C121B-A45F-44D8-A9B2-13E5A5044195
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * mtp-89518052425100**80
   */
  templateId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      success: 'Success',
      templateId: 'TemplateId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      success: 'boolean',
      templateId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCloudGtmMonitorTemplateResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateCloudGtmMonitorTemplateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateCloudGtmMonitorTemplateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePdnsAppKeyRequest extends $tea.Model {
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePdnsAppKeyResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePdnsAppKeyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreatePdnsAppKeyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreatePdnsAppKeyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePdnsUdpIpSegmentRequest extends $tea.Model {
  ip?: string;
  lang?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      ip: 'Ip',
      lang: 'Lang',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ip: 'string',
      lang: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePdnsUdpIpSegmentResponseBody extends $tea.Model {
  requestId?: string;
  validMessage?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      validMessage: 'ValidMessage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      validMessage: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePdnsUdpIpSegmentResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreatePdnsUdpIpSegmentResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreatePdnsUdpIpSegmentResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCloudGtmAddressRequest extends $tea.Model {
  /**
   * @example
   * en-US
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * addr-895182181143688192
   */
  addressId?: string;
  /**
   * @example
   * 1ae05db4-10e7-11ef-b126-00163e24**22
   */
  clientToken?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      addressId: 'AddressId',
      clientToken: 'ClientToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      addressId: 'string',
      clientToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCloudGtmAddressResponseBody extends $tea.Model {
  /**
   * @example
   * 6856BCF6-11D6-4D7E-AC53-FD579933522B
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCloudGtmAddressResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteCloudGtmAddressResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteCloudGtmAddressResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCloudGtmAddressPoolRequest extends $tea.Model {
  /**
   * @example
   * en-US
   */
  acceptLanguage?: string;
  /**
   * @example
   * pool-89528023225442**16
   */
  addressPoolId?: string;
  /**
   * @example
   * 1ae05db4-10e7-11ef-b126-00163e24**22
   */
  clientToken?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      addressPoolId: 'AddressPoolId',
      clientToken: 'ClientToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      addressPoolId: 'string',
      clientToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCloudGtmAddressPoolResponseBody extends $tea.Model {
  /**
   * @example
   * pool-89528023225442**16
   */
  addressPoolId?: string;
  /**
   * @example
   * 536E9CAD-DB30-4647-AC87-AA5CC38C5382
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      addressPoolId: 'AddressPoolId',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addressPoolId: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCloudGtmAddressPoolResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteCloudGtmAddressPoolResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteCloudGtmAddressPoolResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCloudGtmInstanceConfigRequest extends $tea.Model {
  /**
   * @example
   * en-US
   */
  acceptLanguage?: string;
  /**
   * @example
   * 1ae05db4-10e7-11ef-b126-00163e24**22
   */
  clientToken?: string;
  /**
   * @example
   * config-000**1
   */
  configId?: string;
  /**
   * @example
   * gtm-cn-jmp3qnw**03
   */
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      clientToken: 'ClientToken',
      configId: 'ConfigId',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      clientToken: 'string',
      configId: 'string',
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCloudGtmInstanceConfigResponseBody extends $tea.Model {
  /**
   * @example
   * 6856BCF6-11D6-4D7E-AC53-FD579933522B
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCloudGtmInstanceConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteCloudGtmInstanceConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteCloudGtmInstanceConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCloudGtmMonitorTemplateRequest extends $tea.Model {
  /**
   * @example
   * en-US
   */
  acceptLanguage?: string;
  /**
   * @example
   * 1ae05db4-10e7-11ef-b126-00163e24**22
   */
  clientToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * mtp-89518052425100**80
   */
  templateId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      clientToken: 'ClientToken',
      templateId: 'TemplateId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      clientToken: 'string',
      templateId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCloudGtmMonitorTemplateResponseBody extends $tea.Model {
  /**
   * @example
   * 536E9CAD-DB30-4647-AC87-AA5CC38C5382
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCloudGtmMonitorTemplateResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteCloudGtmMonitorTemplateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteCloudGtmMonitorTemplateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCustomLinesRequest extends $tea.Model {
  /**
   * @remarks
   * The language.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The unique IDs of the custom lines that you want to delete. Separate the unique IDs with commas (,).
   * 
   * This parameter is required.
   * 
   * @example
   * 1234,1235
   */
  lineIds?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      lineIds: 'LineIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      lineIds: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCustomLinesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * B57C121B-A45F-44D8-A9B2-13E5A5044195
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCustomLinesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteCustomLinesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteCustomLinesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDnsCacheDomainRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name.
   * 
   * This parameter is required.
   * 
   * @example
   * dns-example.top
   */
  domainName?: string;
  /**
   * @remarks
   * The language.
   * 
   * @example
   * en
   */
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDnsCacheDomainResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 536E9CAD-DB30-4647-AC87-AA5CC38C5382
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDnsCacheDomainResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteDnsCacheDomainResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteDnsCacheDomainResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDnsGtmAccessStrategyRequest extends $tea.Model {
  /**
   * @remarks
   * The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The ID of the access policy.
   * 
   * This parameter is required.
   * 
   * @example
   * testStrategyId1
   */
  strategyId?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      strategyId: 'StrategyId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      strategyId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDnsGtmAccessStrategyResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 29D0F8F8-5499-4F6C-9FDC-1EE13BF55925
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDnsGtmAccessStrategyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteDnsGtmAccessStrategyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteDnsGtmAccessStrategyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDnsGtmAddressPoolRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the address pool.
   * 
   * This parameter is required.
   * 
   * @example
   * testpool1
   */
  addrPoolId?: string;
  /**
   * @remarks
   * The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.
   * 
   * @example
   * en
   */
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      addrPoolId: 'AddrPoolId',
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addrPoolId: 'string',
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDnsGtmAddressPoolResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 6856BCF6-11D6-4D7E-AC53-FD579933522B
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDnsGtmAddressPoolResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteDnsGtmAddressPoolResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteDnsGtmAddressPoolResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDomainRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The language.
   * 
   * @example
   * en
   */
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDomainResponseBody extends $tea.Model {
  /**
   * @remarks
   * The domain name.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 536E9CAD-DB30-4647-AC87-AA5CC38C5382
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDomainResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteDomainResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteDomainResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDomainGroupRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the domain name group.
   * 
   * This parameter is required.
   * 
   * @example
   * 2223
   */
  groupId?: string;
  /**
   * @remarks
   * The language type.
   * 
   * @example
   * en
   */
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDomainGroupResponseBody extends $tea.Model {
  /**
   * @remarks
   * The name of the domain name group.
   * 
   * @example
   * MyGroup
   */
  groupName?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 536E9CAD-DB30-4647-AC87-AA5CC38C5382
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      groupName: 'GroupName',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupName: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDomainGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteDomainGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteDomainGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDomainRecordRequest extends $tea.Model {
  /**
   * @remarks
   * The language.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The ID of the DNS record.
   * 
   * This parameter is returned when you add a DNS record or when you query a list of DNS records.
   * 
   * This parameter is required.
   * 
   * @example
   * 9999985
   */
  recordId?: string;
  /**
   * @remarks
   * The IP address of the client.
   * 
   * @example
   * 192.0.2.0
   */
  userClientIp?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      recordId: 'RecordId',
      userClientIp: 'UserClientIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      recordId: 'string',
      userClientIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDomainRecordResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the DNS record.
   * 
   * @example
   * 9999985
   */
  recordId?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 536E9CAD-DB30-4647-AC87-AA5CC38C5382
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      recordId: 'RecordId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      recordId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDomainRecordResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteDomainRecordResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteDomainRecordResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGtmAccessStrategyRequest extends $tea.Model {
  /**
   * @remarks
   * The language used by the user.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The ID of the access policy that you want to delete.
   * 
   * @example
   * hrskc
   */
  strategyId?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      strategyId: 'StrategyId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      strategyId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGtmAccessStrategyResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 29D0F8F8-5499-4F6C-9FDC-1EE13BF55925
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGtmAccessStrategyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteGtmAccessStrategyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteGtmAccessStrategyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGtmAddressPoolRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the address pool that you want to delete.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  addrPoolId?: string;
  /**
   * @remarks
   * The language used by the user.
   * 
   * @example
   * en
   */
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      addrPoolId: 'AddrPoolId',
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addrPoolId: 'string',
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGtmAddressPoolResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 6856BCF6-11D6-4D7E-AC53-FD579933522B
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGtmAddressPoolResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteGtmAddressPoolResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteGtmAddressPoolResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGtmRecoveryPlanRequest extends $tea.Model {
  /**
   * @remarks
   * The language used by the user.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The ID of the disaster recovery plan that you want to delete.
   * 
   * This parameter is required.
   * 
   * @example
   * 100
   */
  recoveryPlanId?: number;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      recoveryPlanId: 'RecoveryPlanId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      recoveryPlanId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGtmRecoveryPlanResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 6856BCF6-11D6-4D7E-AC53-FD579933522B
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGtmRecoveryPlanResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteGtmRecoveryPlanResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteGtmRecoveryPlanResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSubDomainRecordsRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The language type.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The host record.
   * 
   * For example, to resolve @.example.com, you must set RR to an at sign (@) instead of leaving it blank.
   * 
   * This parameter is required.
   * 
   * @example
   * www
   */
  RR?: string;
  /**
   * @remarks
   * The type of the DNS record. If you do not specify this parameter, all DNS record types corresponding to the subdomain name are returned.
   * 
   * DNS record types include **A, MX, CNAME, TXT, REDIRECT_URL, FORWORD_URL, NS, AAAA, and SRV**. The value is not case-sensitive.
   * 
   * @example
   * A
   */
  type?: string;
  /**
   * @remarks
   * The IP address of the client.
   * 
   * @example
   * 192.0.2.0
   */
  userClientIp?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      lang: 'Lang',
      RR: 'RR',
      type: 'Type',
      userClientIp: 'UserClientIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      lang: 'string',
      RR: 'string',
      type: 'string',
      userClientIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSubDomainRecordsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The host record.
   * 
   * @example
   * www
   */
  RR?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 536E9CAD-DB30-4647-AC87-AA5CC38C5382
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of deleted DNS records.
   * 
   * @example
   * 1
   */
  totalCount?: string;
  static names(): { [key: string]: string } {
    return {
      RR: 'RR',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      RR: 'string',
      requestId: 'string',
      totalCount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSubDomainRecordsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteSubDomainRecordsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteSubDomainRecordsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBatchResultCountRequest extends $tea.Model {
  /**
   * @remarks
   * The type of the batch operation. Valid values:
   * 
   * *   **DOMAIN_ADD**: adds domain names in batches.
   * *   **DOMAIN_DEL**: deletes domain names in batches.
   * *   **RR_ADD**: adds DNS records in batches.
   * *   **RR_DEL**: deletes DNS records in batches.
   * 
   * @example
   * DOMAIN_ADD
   */
  batchType?: string;
  /**
   * @remarks
   * The language type.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The ID of the task.
   * 
   * If you specify TaskId, the execution result of the specified task is returned. If you do not specify TaskId, the execution result of the last task is returned.
   * 
   * @example
   * 123456
   */
  taskId?: number;
  static names(): { [key: string]: string } {
    return {
      batchType: 'BatchType',
      lang: 'Lang',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      batchType: 'string',
      lang: 'string',
      taskId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBatchResultCountResponseBody extends $tea.Model {
  /**
   * @remarks
   * The type of the batch operation.
   * 
   * @example
   * DOMAIN_ADD
   */
  batchType?: string;
  /**
   * @remarks
   * The total number of domain names or DNS records that failed to be processed.
   * 
   * @example
   * 2
   */
  failedCount?: number;
  /**
   * @remarks
   * The cause of the execution failure.
   * 
   * @example
   * failed_reason
   */
  reason?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 75446CC1-FC9A-4595-8D96-089D73D7A63D
   */
  requestId?: string;
  /**
   * @remarks
   * The status of the task. Valid values:
   * 
   * *   **-1**: No task for importing domain names or DNS records is submitted.
   * *   **0**: The task is being processed.
   * *   **1**: The task is completed.
   * *   **2**: The task failed.
   * 
   * @example
   * 0
   */
  status?: number;
  /**
   * @remarks
   * The total number of successfully processed domain names or DNS records.
   * 
   * @example
   * 2
   */
  successCount?: number;
  /**
   * @remarks
   * The ID of the last task.
   * 
   * @example
   * 123456
   */
  taskId?: number;
  /**
   * @remarks
   * The total number of DNS records that were processed in batches.
   * 
   * @example
   * 4
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      batchType: 'BatchType',
      failedCount: 'FailedCount',
      reason: 'Reason',
      requestId: 'RequestId',
      status: 'Status',
      successCount: 'SuccessCount',
      taskId: 'TaskId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      batchType: 'string',
      failedCount: 'number',
      reason: 'string',
      requestId: 'string',
      status: 'number',
      successCount: 'number',
      taskId: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBatchResultCountResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeBatchResultCountResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeBatchResultCountResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBatchResultDetailRequest extends $tea.Model {
  /**
   * @remarks
   * The type of the batch operation. Valid values:
   * 
   * *   **DOMAIN_ADD**: adds domain names in batches.
   * *   **DOMAIN_DEL**: deletes domain names in batches.
   * *   **RR_ADD**: adds Domain Name System (DNS) records in batches.
   * *   **RR_DEL**: deletes DNS records in batches.
   * 
   * @example
   * DOMAIN_ADD
   */
  batchType?: string;
  /**
   * @remarks
   * The language.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The page number. Default value: **1**.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The execution result. If you do not specify this parameter, all results are returned.
   * 
   * @example
   * SUCCESS
   */
  status?: string;
  /**
   * @remarks
   * The ID of the batch operation task.
   * 
   * @example
   * 83618818
   */
  taskId?: number;
  static names(): { [key: string]: string } {
    return {
      batchType: 'BatchType',
      lang: 'Lang',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      status: 'Status',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      batchType: 'string',
      lang: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      status: 'string',
      taskId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBatchResultDetailResponseBody extends $tea.Model {
  /**
   * @remarks
   * The detailed results of the batch operation.
   */
  batchResultDetails?: DescribeBatchResultDetailResponseBodyBatchResultDetails;
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 75446CC1-FC9A-4595-8D96-089D73D7A63D
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      batchResultDetails: 'BatchResultDetails',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      batchResultDetails: DescribeBatchResultDetailResponseBodyBatchResultDetails,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBatchResultDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeBatchResultDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeBatchResultDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudGtmAddressRequest extends $tea.Model {
  /**
   * @example
   * en-US
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * addr-89518218114368**92
   */
  addressId?: string;
  /**
   * @example
   * 1ae05db4-10e7-11ef-b126-00163e24**22
   */
  clientToken?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      addressId: 'AddressId',
      clientToken: 'ClientToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      addressId: 'string',
      clientToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudGtmAddressResponseBody extends $tea.Model {
  /**
   * @example
   * 223.5.XX.XX
   */
  address?: string;
  /**
   * @example
   * addr-89518218114368**92
   */
  addressId?: string;
  attributeInfo?: string;
  /**
   * @example
   * auto
   */
  availableMode?: string;
  /**
   * @example
   * available
   */
  availableStatus?: string;
  /**
   * @example
   * 2024-03-23T13:09Z
   */
  createTime?: string;
  /**
   * @example
   * 1527690629357
   */
  createTimestamp?: number;
  /**
   * @example
   * enable
   */
  enableStatus?: string;
  /**
   * @example
   * p50_ok
   */
  healthJudgement?: string;
  /**
   * @example
   * ok
   */
  healthStatus?: string;
  healthTasks?: DescribeCloudGtmAddressResponseBodyHealthTasks;
  /**
   * @example
   * available
   */
  manualAvailableStatus?: string;
  /**
   * @example
   * test
   */
  name?: string;
  /**
   * @example
   * test1
   */
  remark?: string;
  /**
   * @example
   * B57C121B-A45F-44D8-A9B2-13E5A5044195
   */
  requestId?: string;
  /**
   * @example
   * IPv4
   */
  type?: string;
  /**
   * @example
   * 2024-03-29T13:20Z
   */
  updateTime?: string;
  /**
   * @example
   * 1527690629357
   */
  updateTimestamp?: number;
  static names(): { [key: string]: string } {
    return {
      address: 'Address',
      addressId: 'AddressId',
      attributeInfo: 'AttributeInfo',
      availableMode: 'AvailableMode',
      availableStatus: 'AvailableStatus',
      createTime: 'CreateTime',
      createTimestamp: 'CreateTimestamp',
      enableStatus: 'EnableStatus',
      healthJudgement: 'HealthJudgement',
      healthStatus: 'HealthStatus',
      healthTasks: 'HealthTasks',
      manualAvailableStatus: 'ManualAvailableStatus',
      name: 'Name',
      remark: 'Remark',
      requestId: 'RequestId',
      type: 'Type',
      updateTime: 'UpdateTime',
      updateTimestamp: 'UpdateTimestamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      address: 'string',
      addressId: 'string',
      attributeInfo: 'string',
      availableMode: 'string',
      availableStatus: 'string',
      createTime: 'string',
      createTimestamp: 'number',
      enableStatus: 'string',
      healthJudgement: 'string',
      healthStatus: 'string',
      healthTasks: DescribeCloudGtmAddressResponseBodyHealthTasks,
      manualAvailableStatus: 'string',
      name: 'string',
      remark: 'string',
      requestId: 'string',
      type: 'string',
      updateTime: 'string',
      updateTimestamp: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudGtmAddressResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeCloudGtmAddressResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeCloudGtmAddressResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudGtmAddressPoolRequest extends $tea.Model {
  /**
   * @example
   * en-US
   */
  acceptLanguage?: string;
  /**
   * @example
   * pool-89564674533755**96
   */
  addressPoolId?: string;
  /**
   * @example
   * 1ae05db4-10e7-11ef-b126-00163e24**22
   */
  clientToken?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      addressPoolId: 'AddressPoolId',
      clientToken: 'ClientToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      addressPoolId: 'string',
      clientToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudGtmAddressPoolResponseBody extends $tea.Model {
  /**
   * @example
   * round_robin
   */
  addressLbStrategy?: string;
  /**
   * @example
   * pool-89564674533755**96
   */
  addressPoolId?: string;
  /**
   * @example
   * AddressPool-1
   */
  addressPoolName?: string;
  /**
   * @example
   * IPv4
   */
  addressPoolType?: string;
  addresses?: DescribeCloudGtmAddressPoolResponseBodyAddresses;
  /**
   * @example
   * available
   */
  availableStatus?: string;
  /**
   * @example
   * 2024-03-15T01:46Z
   */
  createTime?: string;
  /**
   * @example
   * 1527690629357
   */
  createTimestamp?: number;
  /**
   * @example
   * enable
   */
  enableStatus?: string;
  /**
   * @example
   * any_ok
   */
  healthJudgement?: string;
  /**
   * @example
   * ok
   */
  healthStatus?: string;
  /**
   * @example
   * test
   */
  remark?: string;
  /**
   * @example
   * 6856BCF6-11D6-4D7E-AC53-FD579933522B
   */
  requestId?: string;
  /**
   * @example
   * preemptive
   */
  sequenceLbStrategyMode?: string;
  /**
   * @example
   * 2024-03-15T01:46Z
   */
  updateTime?: string;
  /**
   * @example
   * 1527690629357
   */
  updateTimestamp?: number;
  static names(): { [key: string]: string } {
    return {
      addressLbStrategy: 'AddressLbStrategy',
      addressPoolId: 'AddressPoolId',
      addressPoolName: 'AddressPoolName',
      addressPoolType: 'AddressPoolType',
      addresses: 'Addresses',
      availableStatus: 'AvailableStatus',
      createTime: 'CreateTime',
      createTimestamp: 'CreateTimestamp',
      enableStatus: 'EnableStatus',
      healthJudgement: 'HealthJudgement',
      healthStatus: 'HealthStatus',
      remark: 'Remark',
      requestId: 'RequestId',
      sequenceLbStrategyMode: 'SequenceLbStrategyMode',
      updateTime: 'UpdateTime',
      updateTimestamp: 'UpdateTimestamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addressLbStrategy: 'string',
      addressPoolId: 'string',
      addressPoolName: 'string',
      addressPoolType: 'string',
      addresses: DescribeCloudGtmAddressPoolResponseBodyAddresses,
      availableStatus: 'string',
      createTime: 'string',
      createTimestamp: 'number',
      enableStatus: 'string',
      healthJudgement: 'string',
      healthStatus: 'string',
      remark: 'string',
      requestId: 'string',
      sequenceLbStrategyMode: 'string',
      updateTime: 'string',
      updateTimestamp: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudGtmAddressPoolResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeCloudGtmAddressPoolResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeCloudGtmAddressPoolResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudGtmAddressPoolReferenceRequest extends $tea.Model {
  /**
   * @example
   * en-US
   */
  acceptLanguage?: string;
  /**
   * @example
   * pool-89528023225442**16
   */
  addressPoolId?: string;
  /**
   * @example
   * 1ae05db4-10e7-11ef-b126-00163e24**22
   */
  clientToken?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      addressPoolId: 'AddressPoolId',
      clientToken: 'ClientToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      addressPoolId: 'string',
      clientToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudGtmAddressPoolReferenceResponseBody extends $tea.Model {
  /**
   * @example
   * pool-89528023225442**16
   */
  addressPoolId?: string;
  /**
   * @example
   * app
   */
  addressPoolName?: string;
  instanceConfigs?: DescribeCloudGtmAddressPoolReferenceResponseBodyInstanceConfigs;
  /**
   * @example
   * 853805EA-3D47-47D5-9A1A-A45C24313ABD
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      addressPoolId: 'AddressPoolId',
      addressPoolName: 'AddressPoolName',
      instanceConfigs: 'InstanceConfigs',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addressPoolId: 'string',
      addressPoolName: 'string',
      instanceConfigs: DescribeCloudGtmAddressPoolReferenceResponseBodyInstanceConfigs,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudGtmAddressPoolReferenceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeCloudGtmAddressPoolReferenceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeCloudGtmAddressPoolReferenceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudGtmAddressReferenceRequest extends $tea.Model {
  /**
   * @example
   * en-US
   */
  acceptLanguage?: string;
  /**
   * @example
   * addr-89518218114368**92
   */
  addressId?: string;
  /**
   * @example
   * 1ae05db4-10e7-11ef-b126-00163e24**22
   */
  clientToken?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      addressId: 'AddressId',
      clientToken: 'ClientToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      addressId: 'string',
      clientToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudGtmAddressReferenceResponseBody extends $tea.Model {
  /**
   * @example
   * 223.5.XX.XX
   */
  address?: string;
  /**
   * @example
   * addr-89564584963974**40
   */
  addressId?: string;
  addressPools?: DescribeCloudGtmAddressReferenceResponseBodyAddressPools;
  /**
   * @example
   * Address-1
   */
  name?: string;
  /**
   * @example
   * 536E9CAD-DB30-4647-AC87-AA5CC38C5382
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      address: 'Address',
      addressId: 'AddressId',
      addressPools: 'AddressPools',
      name: 'Name',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      address: 'string',
      addressId: 'string',
      addressPools: DescribeCloudGtmAddressReferenceResponseBodyAddressPools,
      name: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudGtmAddressReferenceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeCloudGtmAddressReferenceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeCloudGtmAddressReferenceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudGtmGlobalAlertRequest extends $tea.Model {
  /**
   * @example
   * en-US
   */
  acceptLanguage?: string;
  /**
   * @example
   * 1ae05db4-10e7-11ef-b126-00163e24**22
   */
  clientToken?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      clientToken: 'ClientToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      clientToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudGtmGlobalAlertResponseBody extends $tea.Model {
  alertConfig?: DescribeCloudGtmGlobalAlertResponseBodyAlertConfig;
  alertGroup?: DescribeCloudGtmGlobalAlertResponseBodyAlertGroup;
  /**
   * @example
   * B57C121B-A45F-44D8-A9B2-13E5A5044195
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      alertConfig: 'AlertConfig',
      alertGroup: 'AlertGroup',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertConfig: DescribeCloudGtmGlobalAlertResponseBodyAlertConfig,
      alertGroup: DescribeCloudGtmGlobalAlertResponseBodyAlertGroup,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudGtmGlobalAlertResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeCloudGtmGlobalAlertResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeCloudGtmGlobalAlertResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudGtmInstanceConfigAlertRequest extends $tea.Model {
  /**
   * @example
   * en-US
   */
  acceptLanguage?: string;
  /**
   * @example
   * 1ae05db4-10e7-11ef-b126-00163e24**22
   */
  clientToken?: string;
  /**
   * @example
   * Config-000**11
   */
  configId?: string;
  /**
   * @example
   * gtm-cn-wwo3a3hbz**
   */
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      clientToken: 'ClientToken',
      configId: 'ConfigId',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      clientToken: 'string',
      configId: 'string',
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudGtmInstanceConfigAlertResponseBody extends $tea.Model {
  alertConfig?: DescribeCloudGtmInstanceConfigAlertResponseBodyAlertConfig;
  alertGroup?: DescribeCloudGtmInstanceConfigAlertResponseBodyAlertGroup;
  /**
   * @example
   * global
   */
  alertMode?: string;
  /**
   * @example
   * Config-000**11
   */
  configId?: string;
  /**
   * @example
   * gtm-cn-wwo3a3hbz**
   */
  instanceId?: string;
  /**
   * @example
   * 0F32959D-417B-4D66-8463-68606605E3E2
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      alertConfig: 'AlertConfig',
      alertGroup: 'AlertGroup',
      alertMode: 'AlertMode',
      configId: 'ConfigId',
      instanceId: 'InstanceId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertConfig: DescribeCloudGtmInstanceConfigAlertResponseBodyAlertConfig,
      alertGroup: DescribeCloudGtmInstanceConfigAlertResponseBodyAlertGroup,
      alertMode: 'string',
      configId: 'string',
      instanceId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudGtmInstanceConfigAlertResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeCloudGtmInstanceConfigAlertResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeCloudGtmInstanceConfigAlertResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudGtmInstanceConfigFullInfoRequest extends $tea.Model {
  /**
   * @example
   * en-US
   */
  acceptLanguage?: string;
  /**
   * @example
   * 1ae05db4-10e7-11ef-b126-00163e24**22
   */
  clientToken?: string;
  /**
   * @example
   * Config-000**11
   */
  configId?: string;
  /**
   * @example
   * gtm-cn-wwo3a3hbz**
   */
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      clientToken: 'ClientToken',
      configId: 'ConfigId',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      clientToken: 'string',
      configId: 'string',
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudGtmInstanceConfigFullInfoResponseBody extends $tea.Model {
  /**
   * @example
   * round_robin
   */
  addressPoolLbStrategy?: string;
  addressPools?: DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPools;
  /**
   * @example
   * [{\\"NoticeType\\":\\"addr_alert\\",\\"SmsNotice\\":true,\\"EmailNotice\\":true,\\"DingtalkNotice\\":true},{\\"NoticeType\\":\\"addr_resume\\",\\"SmsNotice\\":true,\\"EmailNotice\\":true,\\"DingtalkNotice\\":true},{\\"NoticeType\\":\\"addr_pool_unavailable\\",\\"SmsNotice\\":true,\\"EmailNotice\\":true,\\"DingtalkNotice\\":true},{\\"NoticeType\\":\\"addr_pool_available\\",\\"SmsNotice\\":true,\\"EmailNotice\\":true,\\"DingtalkNotice\\":true}]"
   */
  alertConfig?: string;
  alertGroup?: string;
  /**
   * @example
   * available
   */
  availableStatus?: string;
  /**
   * @example
   * dns_gtm_public_cn
   */
  commodityCode?: string;
  /**
   * @example
   * Config-000**11
   */
  configId?: string;
  /**
   * @example
   * 2024-03-15T01:46Z
   */
  createTime?: string;
  /**
   * @example
   * 1527690629357
   */
  createTimestamp?: number;
  /**
   * @example
   * enable
   */
  enableStatus?: string;
  /**
   * @example
   * ok
   */
  healthStatus?: string;
  /**
   * @example
   * gtm-cn-wwo3a3hbz**
   */
  instanceId?: string;
  /**
   * @example
   * test
   */
  instanceName?: string;
  /**
   * @example
   * test
   */
  remark?: string;
  /**
   * @example
   * 29D0F8F8-5499-4F6C-9FDC-1EE13BF55925
   */
  requestId?: string;
  /**
   * @example
   * www.example.com
   */
  scheduleDomainName?: string;
  /**
   * @example
   * www
   */
  scheduleHostname?: string;
  /**
   * @example
   * A
   */
  scheduleRrType?: string;
  /**
   * @example
   * custom
   */
  scheduleZoneMode?: string;
  /**
   * @example
   * example.com
   */
  scheduleZoneName?: string;
  /**
   * @example
   * preemptive
   */
  sequenceLbStrategyMode?: string;
  /**
   * @example
   * 60
   */
  ttl?: number;
  /**
   * @example
   * 2024-03-15T01:46Z
   */
  updateTime?: string;
  /**
   * @example
   * 1527690629357
   */
  updateTimestamp?: number;
  /**
   * @example
   * ultimate
   */
  versionCode?: string;
  static names(): { [key: string]: string } {
    return {
      addressPoolLbStrategy: 'AddressPoolLbStrategy',
      addressPools: 'AddressPools',
      alertConfig: 'AlertConfig',
      alertGroup: 'AlertGroup',
      availableStatus: 'AvailableStatus',
      commodityCode: 'CommodityCode',
      configId: 'ConfigId',
      createTime: 'CreateTime',
      createTimestamp: 'CreateTimestamp',
      enableStatus: 'EnableStatus',
      healthStatus: 'HealthStatus',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      remark: 'Remark',
      requestId: 'RequestId',
      scheduleDomainName: 'ScheduleDomainName',
      scheduleHostname: 'ScheduleHostname',
      scheduleRrType: 'ScheduleRrType',
      scheduleZoneMode: 'ScheduleZoneMode',
      scheduleZoneName: 'ScheduleZoneName',
      sequenceLbStrategyMode: 'SequenceLbStrategyMode',
      ttl: 'Ttl',
      updateTime: 'UpdateTime',
      updateTimestamp: 'UpdateTimestamp',
      versionCode: 'VersionCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addressPoolLbStrategy: 'string',
      addressPools: DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPools,
      alertConfig: 'string',
      alertGroup: 'string',
      availableStatus: 'string',
      commodityCode: 'string',
      configId: 'string',
      createTime: 'string',
      createTimestamp: 'number',
      enableStatus: 'string',
      healthStatus: 'string',
      instanceId: 'string',
      instanceName: 'string',
      remark: 'string',
      requestId: 'string',
      scheduleDomainName: 'string',
      scheduleHostname: 'string',
      scheduleRrType: 'string',
      scheduleZoneMode: 'string',
      scheduleZoneName: 'string',
      sequenceLbStrategyMode: 'string',
      ttl: 'number',
      updateTime: 'string',
      updateTimestamp: 'number',
      versionCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudGtmInstanceConfigFullInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeCloudGtmInstanceConfigFullInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeCloudGtmInstanceConfigFullInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudGtmMonitorTemplateRequest extends $tea.Model {
  /**
   * @example
   * en-US
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * mtp-89518052425100**80
   */
  templateId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      templateId: 'TemplateId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      templateId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudGtmMonitorTemplateResponseBody extends $tea.Model {
  /**
   * @example
   * 2024-03-23T13:09Z
   */
  createTime?: string;
  /**
   * @example
   * 1527690629357
   */
  createTimestamp?: number;
  /**
   * @example
   * 2
   */
  evaluationCount?: number;
  /**
   * @example
   * {\\"code\\":200,\\"path\\":\\"\\\\index.htm\\",\\"host\\":\\"aliyun.com\\"}
   */
  extendInfo?: string;
  /**
   * @example
   * 50
   */
  failureRate?: number;
  /**
   * @example
   * 60
   */
  interval?: number;
  /**
   * @example
   * IPv4
   */
  ipVersion?: string;
  ispCityNodes?: DescribeCloudGtmMonitorTemplateResponseBodyIspCityNodes;
  /**
   * @example
   * Ping-IPv4
   */
  name?: string;
  /**
   * @example
   * ping
   */
  protocol?: string;
  /**
   * @example
   * test
   */
  remark?: string;
  /**
   * @example
   * 6AEC7A64-3CB1-4C49-8B35-0B901F1E26BF
   */
  requestId?: string;
  /**
   * @example
   * mtp-89518052425100**80
   */
  templateId?: string;
  /**
   * @example
   * 5000
   */
  timeout?: number;
  /**
   * @example
   * 2024-03-29T13:20Z
   */
  updateTime?: string;
  /**
   * @example
   * 1527690629357
   */
  updateTimestamp?: number;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      createTimestamp: 'CreateTimestamp',
      evaluationCount: 'EvaluationCount',
      extendInfo: 'ExtendInfo',
      failureRate: 'FailureRate',
      interval: 'Interval',
      ipVersion: 'IpVersion',
      ispCityNodes: 'IspCityNodes',
      name: 'Name',
      protocol: 'Protocol',
      remark: 'Remark',
      requestId: 'RequestId',
      templateId: 'TemplateId',
      timeout: 'Timeout',
      updateTime: 'UpdateTime',
      updateTimestamp: 'UpdateTimestamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'string',
      createTimestamp: 'number',
      evaluationCount: 'number',
      extendInfo: 'string',
      failureRate: 'number',
      interval: 'number',
      ipVersion: 'string',
      ispCityNodes: DescribeCloudGtmMonitorTemplateResponseBodyIspCityNodes,
      name: 'string',
      protocol: 'string',
      remark: 'string',
      requestId: 'string',
      templateId: 'string',
      timeout: 'number',
      updateTime: 'string',
      updateTimestamp: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudGtmMonitorTemplateResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeCloudGtmMonitorTemplateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeCloudGtmMonitorTemplateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudGtmSummaryRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh-CN: Chinese
   * *   en-US: English
   * 
   * @example
   * en-US
   */
  acceptLanguage?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudGtmSummaryResponseBody extends $tea.Model {
  /**
   * @remarks
   * The total number of instances within the current account.
   * 
   * @example
   * 10
   */
  instanceTotalCount?: number;
  /**
   * @remarks
   * The total number of configured health check tasks.
   * 
   * @example
   * 20
   */
  monitorTaskTotalCount?: number;
  /**
   * @remarks
   * The quota on the number of health check tasks.
   * 
   * @example
   * 101
   */
  monitorTaskTotalQuota?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 199C3699-9A7B-41A1-BB5A-F1E862D3CB38
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceTotalCount: 'InstanceTotalCount',
      monitorTaskTotalCount: 'MonitorTaskTotalCount',
      monitorTaskTotalQuota: 'MonitorTaskTotalQuota',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceTotalCount: 'number',
      monitorTaskTotalCount: 'number',
      monitorTaskTotalQuota: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudGtmSummaryResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeCloudGtmSummaryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeCloudGtmSummaryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudGtmSystemLinesResponseBody extends $tea.Model {
  /**
   * @example
   * 389DFFA3-77A5-4A9E-BF3D-147C6F98A5BA
   */
  requestId?: string;
  systemLines?: DescribeCloudGtmSystemLinesResponseBodySystemLines;
  systemLinesTree?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      systemLines: 'SystemLines',
      systemLinesTree: 'SystemLinesTree',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      systemLines: DescribeCloudGtmSystemLinesResponseBodySystemLines,
      systemLinesTree: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudGtmSystemLinesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeCloudGtmSystemLinesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeCloudGtmSystemLinesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCustomLineRequest extends $tea.Model {
  /**
   * @remarks
   * The language.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The unique ID of the custom line.
   * 
   * @example
   * 597
   */
  lineId?: number;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      lineId: 'LineId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      lineId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCustomLineResponseBody extends $tea.Model {
  /**
   * @remarks
   * The code of the custom line.
   * 
   * @example
   * hra0yc-597
   */
  code?: string;
  /**
   * @remarks
   * The domain name.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The ID of the custom line.
   * 
   * @example
   * 597
   */
  id?: number;
  /**
   * @remarks
   * The CIDR blocks. Separate IP addresses with a hyphen (-). Enter a CIDR block in each row. You can enter 1 to 50 CIDR blocks at a time. If a CIDR block contains only one IP address, enter the IP address in the format of IP1-IP1. Different CIDR blocks cannot be overlapped.
   */
  ipSegmentList?: DescribeCustomLineResponseBodyIpSegmentList[];
  /**
   * @remarks
   * The name of the custom line.
   */
  name?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * B57C121B-A45F-44D8-A9B2-13E5A5044195
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      domainName: 'DomainName',
      id: 'Id',
      ipSegmentList: 'IpSegmentList',
      name: 'Name',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      domainName: 'string',
      id: 'number',
      ipSegmentList: { 'type': 'array', 'itemType': DescribeCustomLineResponseBodyIpSegmentList },
      name: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCustomLineResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeCustomLineResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeCustomLineResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCustomLinesRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The language.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      lang: 'Lang',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      lang: 'string',
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCustomLinesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The custom lines.
   */
  customLines?: DescribeCustomLinesResponseBodyCustomLines[];
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * B57C121B-A45F-44D8-A9B2-13E5A5044195
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of custom lines.
   * 
   * @example
   * 1
   */
  totalItems?: number;
  /**
   * @remarks
   * The total number of returned pages.
   * 
   * @example
   * 1
   */
  totalPages?: number;
  static names(): { [key: string]: string } {
    return {
      customLines: 'CustomLines',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalItems: 'TotalItems',
      totalPages: 'TotalPages',
    };
  }

  static types(): { [key: string]: any } {
    return {
      customLines: { 'type': 'array', 'itemType': DescribeCustomLinesResponseBodyCustomLines },
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalItems: 'number',
      totalPages: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCustomLinesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeCustomLinesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeCustomLinesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDNSSLBSubDomainsRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The language.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The page number. Pages start from page **1**. Default value: **1**.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Valid values: **1 to 100**. Default value: **20**.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The hostname.
   * 
   * @example
   * test
   */
  rr?: string;
  /**
   * @remarks
   * The IP address of the client.
   * 
   * @example
   * 1.1.1.1
   */
  userClientIp?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      lang: 'Lang',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      rr: 'Rr',
      userClientIp: 'UserClientIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      lang: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      rr: 'string',
      userClientIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDNSSLBSubDomainsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The page number. Pages start from page **1**. Default value: **1**.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Valid values: **1 to 100**. Default value: **20**.
   * 
   * @example
   * 1
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 536E9CAD-DB30-4647-AC87-AA5CC38C5382
   */
  requestId?: string;
  /**
   * @remarks
   * The subdomains for which weighted round-robin is enabled.
   */
  slbSubDomains?: DescribeDNSSLBSubDomainsResponseBodySlbSubDomains;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      slbSubDomains: 'SlbSubDomains',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      slbSubDomains: DescribeDNSSLBSubDomainsResponseBodySlbSubDomains,
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDNSSLBSubDomainsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDNSSLBSubDomainsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDNSSLBSubDomainsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsCacheDomainsRequest extends $tea.Model {
  /**
   * @remarks
   * The keyword for searches in "%KeyWord%" mode. The value is not case-sensitive.
   * 
   * @example
   * a\\"\\"
   */
  keyword?: string;
  /**
   * @remarks
   * The language.
   * 
   * @example
   * zh
   */
  lang?: string;
  /**
   * @remarks
   * The page number. Pages start from page 1. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Valid values: **1 to 100**. Default value: **20**.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      keyword: 'Keyword',
      lang: 'Lang',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      keyword: 'string',
      lang: 'string',
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsCacheDomainsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The domain names.
   */
  domains?: DescribeDnsCacheDomainsResponseBodyDomains[];
  /**
   * @remarks
   * The page number. Pages start from page **1**. Default value: **1**.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Valid values: 1 to 100. Default value: 20.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 57121A9C-CDCF-541F-AD39-275D89099420
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 3
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      domains: 'Domains',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domains: { 'type': 'array', 'itemType': DescribeDnsCacheDomainsResponseBodyDomains },
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsCacheDomainsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDnsCacheDomainsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDnsCacheDomainsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmAccessStrategiesRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * instance1
   */
  instanceId?: string;
  /**
   * @remarks
   * The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * @example
   * 1
   */
  pageSize?: number;
  /**
   * @remarks
   * The type of the access policy. Valid values:
   * 
   * *   GEO: geographical location-based
   * *   LATENCY: latency-based
   * 
   * This parameter is required.
   * 
   * @example
   * geo
   */
  strategyMode?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      lang: 'Lang',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      strategyMode: 'StrategyMode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      lang: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      strategyMode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmAccessStrategiesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 1
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0CCC9971-CEC9-4132-824B-4AE611C07623
   */
  requestId?: string;
  /**
   * @remarks
   * The access policies.
   */
  strategies?: DescribeDnsGtmAccessStrategiesResponseBodyStrategies;
  /**
   * @remarks
   * The total number of entries returned on all pages.
   * 
   * @example
   * 11
   */
  totalItems?: number;
  /**
   * @remarks
   * The total number of pages returned.
   * 
   * @example
   * 11
   */
  totalPages?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      strategies: 'Strategies',
      totalItems: 'TotalItems',
      totalPages: 'TotalPages',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      strategies: DescribeDnsGtmAccessStrategiesResponseBodyStrategies,
      totalItems: 'number',
      totalPages: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmAccessStrategiesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDnsGtmAccessStrategiesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDnsGtmAccessStrategiesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmAccessStrategyRequest extends $tea.Model {
  /**
   * @remarks
   * The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The ID of the access policy.
   * 
   * This parameter is required.
   * 
   * @example
   * strategyId1
   */
  strategyId?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      strategyId: 'StrategyId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      strategyId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmAccessStrategyResponseBody extends $tea.Model {
  /**
   * @remarks
   * The primary/secondary switchover policy for address pool groups. Valid values:
   * 
   * *   AUTO: performs automatic switchover between the primary and secondary address pool groups upon failures.
   * *   DEFAULT: uses the primary address pool group.
   * *   FAILOVER: uses the secondary address pool group.
   * 
   * @example
   * auto
   */
  accessMode?: string;
  /**
   * @remarks
   * The time when the access policy was created.
   * 
   * @example
   * 2018-08-09T00:10Z
   */
  createTime?: string;
  /**
   * @remarks
   * The timestamp that indicates when the access policy was created.
   * 
   * @example
   * 1533773400000
   */
  createTimestamp?: number;
  /**
   * @remarks
   * The status of the primary address pool group. Valid values:
   * 
   * *   AVAILABLE: available
   * *   NOT_AVAILABLE: unavailable
   * 
   * @example
   * AVAILABLE
   */
  defaultAddrPoolGroupStatus?: string;
  /**
   * @remarks
   * The type of the primary address pool. Valid values:
   * 
   * *   IPV4
   * *   IPV6
   * *   DOMAIN
   * 
   * @example
   * ipv4
   */
  defaultAddrPoolType?: string;
  /**
   * @remarks
   * The address pools in the primary address pool group.
   */
  defaultAddrPools?: DescribeDnsGtmAccessStrategyResponseBodyDefaultAddrPools;
  /**
   * @remarks
   * The number of available addresses in the primary address pool.
   * 
   * @example
   * 1
   */
  defaultAvailableAddrNum?: number;
  /**
   * @remarks
   * Indicates whether scheduling optimization for latency resolution was enabled for the primary address pool group. Valid values:
   * 
   * *   OPEN: enabled
   * *   CLOSE: disabled
   * 
   * @example
   * open
   */
  defaultLatencyOptimization?: string;
  /**
   * @remarks
   * The load balancing policy of the primary address pool group. Valid values:
   * 
   * *   ALL_RR: returns all addresses.
   * *   RATIO: returns addresses by weight.
   * 
   * @example
   * all_rr
   */
  defaultLbaStrategy?: string;
  /**
   * @remarks
   * The maximum number of addresses returned from the primary address pool group.
   * 
   * @example
   * 1
   */
  defaultMaxReturnAddrNum?: number;
  /**
   * @remarks
   * The minimum number of available addresses in the primary address pool group.
   * 
   * @example
   * 1
   */
  defaultMinAvailableAddrNum?: number;
  /**
   * @remarks
   * The type of the active address pool group. Valid values:
   * 
   * *   DEFAULT: the primary address pool group
   * *   FAILOVER: the secondary address pool group
   * 
   * @example
   * DEFAULT
   */
  effectiveAddrPoolGroupType?: string;
  /**
   * @remarks
   * The status of the secondary address pool group. Valid values:
   * 
   * *   AVAILABLE: available
   * *   NOT_AVAILABLE: unavailable
   * 
   * @example
   * AVAILABLE
   */
  failoverAddrPoolGroupStatus?: string;
  /**
   * @remarks
   * The type of the secondary address pool. Valid values:
   * 
   * *   IPV4
   * *   IPV6
   * *   DOMAIN
   * 
   * @example
   * ipv4
   */
  failoverAddrPoolType?: string;
  /**
   * @remarks
   * The address pools in the secondary address pool group.
   */
  failoverAddrPools?: DescribeDnsGtmAccessStrategyResponseBodyFailoverAddrPools;
  /**
   * @remarks
   * The number of available addresses in the secondary address pool.
   * 
   * @example
   * 1
   */
  failoverAvailableAddrNum?: number;
  /**
   * @remarks
   * Indicates whether scheduling optimization for latency resolution was enabled for the secondary address pool group. Valid values:
   * 
   * *   OPEN: enabled
   * *   CLOSE: disabled
   * 
   * @example
   * open
   */
  failoverLatencyOptimization?: string;
  /**
   * @remarks
   * The load balancing policy of the secondary address pool group. Valid values:
   * 
   * *   ALL_RR: returns all addresses.
   * *   RATIO: returns addresses by weight.
   * 
   * @example
   * all_rr
   */
  failoverLbaStrategy?: string;
  /**
   * @remarks
   * The maximum number of addresses returned from the secondary address pool group.
   * 
   * @example
   * 1
   */
  failoverMaxReturnAddrNum?: number;
  /**
   * @remarks
   * The minimum number of available addresses in the secondary address pool group.
   * 
   * @example
   * 1
   */
  failoverMinAvailableAddrNum?: number;
  /**
   * @remarks
   * The ID of the associated instance.
   * 
   * @example
   * instance1
   */
  instanceId?: string;
  /**
   * @remarks
   * The source regions.
   */
  lines?: DescribeDnsGtmAccessStrategyResponseBodyLines;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * BA1608CA-834C-4E63-8682-8AF0B11ED72D
   */
  requestId?: string;
  /**
   * @remarks
   * The ID of the access policy.
   * 
   * @example
   * strategyId1
   */
  strategyId?: string;
  /**
   * @remarks
   * The type of the access policy. Valid values:
   * 
   * *   GEO: geographical location-based
   * *   LATENCY: latency-based
   * 
   * @example
   * geo
   */
  strategyMode?: string;
  /**
   * @remarks
   * The name of the access policy.
   * 
   * @example
   * strategyName1
   */
  strategyName?: string;
  static names(): { [key: string]: string } {
    return {
      accessMode: 'AccessMode',
      createTime: 'CreateTime',
      createTimestamp: 'CreateTimestamp',
      defaultAddrPoolGroupStatus: 'DefaultAddrPoolGroupStatus',
      defaultAddrPoolType: 'DefaultAddrPoolType',
      defaultAddrPools: 'DefaultAddrPools',
      defaultAvailableAddrNum: 'DefaultAvailableAddrNum',
      defaultLatencyOptimization: 'DefaultLatencyOptimization',
      defaultLbaStrategy: 'DefaultLbaStrategy',
      defaultMaxReturnAddrNum: 'DefaultMaxReturnAddrNum',
      defaultMinAvailableAddrNum: 'DefaultMinAvailableAddrNum',
      effectiveAddrPoolGroupType: 'EffectiveAddrPoolGroupType',
      failoverAddrPoolGroupStatus: 'FailoverAddrPoolGroupStatus',
      failoverAddrPoolType: 'FailoverAddrPoolType',
      failoverAddrPools: 'FailoverAddrPools',
      failoverAvailableAddrNum: 'FailoverAvailableAddrNum',
      failoverLatencyOptimization: 'FailoverLatencyOptimization',
      failoverLbaStrategy: 'FailoverLbaStrategy',
      failoverMaxReturnAddrNum: 'FailoverMaxReturnAddrNum',
      failoverMinAvailableAddrNum: 'FailoverMinAvailableAddrNum',
      instanceId: 'InstanceId',
      lines: 'Lines',
      requestId: 'RequestId',
      strategyId: 'StrategyId',
      strategyMode: 'StrategyMode',
      strategyName: 'StrategyName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessMode: 'string',
      createTime: 'string',
      createTimestamp: 'number',
      defaultAddrPoolGroupStatus: 'string',
      defaultAddrPoolType: 'string',
      defaultAddrPools: DescribeDnsGtmAccessStrategyResponseBodyDefaultAddrPools,
      defaultAvailableAddrNum: 'number',
      defaultLatencyOptimization: 'string',
      defaultLbaStrategy: 'string',
      defaultMaxReturnAddrNum: 'number',
      defaultMinAvailableAddrNum: 'number',
      effectiveAddrPoolGroupType: 'string',
      failoverAddrPoolGroupStatus: 'string',
      failoverAddrPoolType: 'string',
      failoverAddrPools: DescribeDnsGtmAccessStrategyResponseBodyFailoverAddrPools,
      failoverAvailableAddrNum: 'number',
      failoverLatencyOptimization: 'string',
      failoverLbaStrategy: 'string',
      failoverMaxReturnAddrNum: 'number',
      failoverMinAvailableAddrNum: 'number',
      instanceId: 'string',
      lines: DescribeDnsGtmAccessStrategyResponseBodyLines,
      requestId: 'string',
      strategyId: 'string',
      strategyMode: 'string',
      strategyName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmAccessStrategyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDnsGtmAccessStrategyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDnsGtmAccessStrategyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmAccessStrategyAvailableConfigRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * instance1
   */
  instanceId?: string;
  /**
   * @remarks
   * The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The type of the access policy. Valid values:
   * 
   * *   GEO: geographical location-based
   * *   LATENCY: latency-based
   * 
   * This parameter is required.
   * 
   * @example
   * geo
   */
  strategyMode?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      lang: 'Lang',
      strategyMode: 'StrategyMode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      lang: 'string',
      strategyMode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmAccessStrategyAvailableConfigResponseBody extends $tea.Model {
  /**
   * @remarks
   * The available address pools of the domain name type.
   */
  domainAddrPools?: DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyDomainAddrPools;
  /**
   * @remarks
   * The available address pools of the IPv4 type.
   */
  ipv4AddrPools?: DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv4AddrPools;
  /**
   * @remarks
   * The available address pools of the IPv6 type.
   */
  ipv6AddrPools?: DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv6AddrPools;
  /**
   * @remarks
   * The source regions.
   */
  lines?: DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyLines;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * C2851BA9-CE56-49AF-8D12-4FC6A49EE688
   */
  requestId?: string;
  selectedDomainLines?: DescribeDnsGtmAccessStrategyAvailableConfigResponseBodySelectedDomainLines;
  selectedIpv4Lines?: DescribeDnsGtmAccessStrategyAvailableConfigResponseBodySelectedIpv4Lines;
  selectedIpv6Lines?: DescribeDnsGtmAccessStrategyAvailableConfigResponseBodySelectedIpv6Lines;
  /**
   * @remarks
   * Indicates whether we recommend that you set the source region to global.
   * 
   * @example
   * true
   */
  suggestSetDefaultLine?: boolean;
  static names(): { [key: string]: string } {
    return {
      domainAddrPools: 'DomainAddrPools',
      ipv4AddrPools: 'Ipv4AddrPools',
      ipv6AddrPools: 'Ipv6AddrPools',
      lines: 'Lines',
      requestId: 'RequestId',
      selectedDomainLines: 'SelectedDomainLines',
      selectedIpv4Lines: 'SelectedIpv4Lines',
      selectedIpv6Lines: 'SelectedIpv6Lines',
      suggestSetDefaultLine: 'SuggestSetDefaultLine',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainAddrPools: DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyDomainAddrPools,
      ipv4AddrPools: DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv4AddrPools,
      ipv6AddrPools: DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv6AddrPools,
      lines: DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyLines,
      requestId: 'string',
      selectedDomainLines: DescribeDnsGtmAccessStrategyAvailableConfigResponseBodySelectedDomainLines,
      selectedIpv4Lines: DescribeDnsGtmAccessStrategyAvailableConfigResponseBodySelectedIpv4Lines,
      selectedIpv6Lines: DescribeDnsGtmAccessStrategyAvailableConfigResponseBodySelectedIpv6Lines,
      suggestSetDefaultLine: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmAccessStrategyAvailableConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDnsGtmAccessStrategyAvailableConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDnsGtmAccessStrategyAvailableConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmAddrAttributeInfoRequest extends $tea.Model {
  /**
   * @remarks
   * The addresses whose source regions you want to query.
   * 
   * This parameter is required.
   * 
   * @example
   * ["1.1.1.1"]
   */
  addrs?: string;
  /**
   * @remarks
   * The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The type of the addresses. Valid values:
   * 
   * *   IPV4: IPv4 address
   * *   IPV6: IPv6 address
   * *   DOMAIN: domain name
   * 
   * This parameter is required.
   * 
   * @example
   * ipv4
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      addrs: 'Addrs',
      lang: 'Lang',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addrs: 'string',
      lang: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmAddrAttributeInfoResponseBody extends $tea.Model {
  /**
   * @remarks
   * The addresses that were queried.
   */
  addr?: DescribeDnsGtmAddrAttributeInfoResponseBodyAddr;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 6856BCF6-11D6-4D7E-AC53-FD579933522B
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      addr: 'Addr',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addr: DescribeDnsGtmAddrAttributeInfoResponseBodyAddr,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmAddrAttributeInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDnsGtmAddrAttributeInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDnsGtmAddrAttributeInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmAddressPoolAvailableConfigRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * instance1
   */
  instanceId?: string;
  /**
   * @remarks
   * The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.
   * 
   * @example
   * en
   */
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmAddressPoolAvailableConfigResponseBody extends $tea.Model {
  /**
   * @remarks
   * The supported source regions.
   */
  attributeInfos?: DescribeDnsGtmAddressPoolAvailableConfigResponseBodyAttributeInfos;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 199C3699-9A7B-41A1-BB5A-F1E862D3CB38
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      attributeInfos: 'AttributeInfos',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attributeInfos: DescribeDnsGtmAddressPoolAvailableConfigResponseBodyAttributeInfos,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmAddressPoolAvailableConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDnsGtmAddressPoolAvailableConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDnsGtmAddressPoolAvailableConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmAvailableAlertGroupRequest extends $tea.Model {
  /**
   * @remarks
   * The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.
   * 
   * @example
   * en
   */
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmAvailableAlertGroupResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned available alert groups.
   */
  availableAlertGroup?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 6856BCF6-11D6-4D7E-AC53-FD579933522B
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      availableAlertGroup: 'AvailableAlertGroup',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      availableAlertGroup: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmAvailableAlertGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDnsGtmAvailableAlertGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDnsGtmAvailableAlertGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmInstanceRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the instance about which you want to query the information.
   * 
   * This parameter is required.
   * 
   * @example
   * instance1
   */
  instanceId?: string;
  /**
   * @remarks
   * The language in which you want the values of some response parameters to be returned. These response parameters support multiple languages. Default value: en. Valid values: en, zh, and ja.
   * 
   * @example
   * en
   */
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmInstanceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The configurations of the instance.
   */
  config?: DescribeDnsGtmInstanceResponseBodyConfig;
  /**
   * @remarks
   * The time when the instance was created.
   * 
   * @example
   * 2020-10-14T06:58Z
   */
  createTime?: string;
  /**
   * @remarks
   * The UNIX timestamp that indicates when the instance was created.
   * 
   * @example
   * 1602656937000
   */
  createTimestamp?: number;
  /**
   * @remarks
   * The time when the instance expires.
   * 
   * @example
   * 2020-10-14T06:58Z
   */
  expireTime?: string;
  /**
   * @remarks
   * The UNIX timestamp that indicates when the instance expires.
   * 
   * @example
   * 1602656937000
   */
  expireTimestamp?: number;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * instanceid1
   */
  instanceId?: string;
  /**
   * @remarks
   * The billing method. Valid value:
   * 
   * *   Subscription: You can pay in advance for the use of resources.
   * 
   * @example
   * Subscription
   */
  paymentType?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 84314904-D047-4176-A0EC-256D7F68C7F5
   */
  requestId?: string;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs.
   * 
   * @example
   * resourcegroupid1
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The total number of SMS notifications.
   * 
   * @example
   * 100
   */
  smsQuota?: number;
  /**
   * @remarks
   * The total number of detection tasks.
   * 
   * @example
   * 100
   */
  taskQuota?: number;
  /**
   * @remarks
   * The used quota.
   */
  usedQuota?: DescribeDnsGtmInstanceResponseBodyUsedQuota;
  /**
   * @remarks
   * The version of the instance.
   * 
   * @example
   * versioncode1
   */
  versionCode?: string;
  static names(): { [key: string]: string } {
    return {
      config: 'Config',
      createTime: 'CreateTime',
      createTimestamp: 'CreateTimestamp',
      expireTime: 'ExpireTime',
      expireTimestamp: 'ExpireTimestamp',
      instanceId: 'InstanceId',
      paymentType: 'PaymentType',
      requestId: 'RequestId',
      resourceGroupId: 'ResourceGroupId',
      smsQuota: 'SmsQuota',
      taskQuota: 'TaskQuota',
      usedQuota: 'UsedQuota',
      versionCode: 'VersionCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      config: DescribeDnsGtmInstanceResponseBodyConfig,
      createTime: 'string',
      createTimestamp: 'number',
      expireTime: 'string',
      expireTimestamp: 'number',
      instanceId: 'string',
      paymentType: 'string',
      requestId: 'string',
      resourceGroupId: 'string',
      smsQuota: 'number',
      taskQuota: 'number',
      usedQuota: DescribeDnsGtmInstanceResponseBodyUsedQuota,
      versionCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmInstanceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDnsGtmInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDnsGtmInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmInstanceAddressPoolRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the address pool.
   * 
   * This parameter is required.
   * 
   * @example
   * testpool1
   */
  addrPoolId?: string;
  /**
   * @remarks
   * The language of the values of specific response parameters. Default value: en. Valid values: en, zh, and ja.
   * 
   * @example
   * en
   */
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      addrPoolId: 'AddrPoolId',
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addrPoolId: 'string',
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmInstanceAddressPoolResponseBody extends $tea.Model {
  /**
   * @remarks
   * The number of addresses in the address pool.
   * 
   * @example
   * 1
   */
  addrCount?: number;
  /**
   * @remarks
   * The ID of the address pool.
   * 
   * @example
   * testpool1
   */
  addrPoolId?: string;
  /**
   * @remarks
   * The addresses in the address pool.
   */
  addrs?: DescribeDnsGtmInstanceAddressPoolResponseBodyAddrs;
  /**
   * @remarks
   * The time when the address pool was created.
   * 
   * @example
   * 2017-12-28T13:08Z
   */
  createTime?: string;
  /**
   * @remarks
   * The timestamp that indicates the time when the address pool was created.
   * 
   * @example
   * 1527690629357
   */
  createTimestamp?: number;
  /**
   * @remarks
   * The load balancing policy for the address pool. Valid values:
   * 
   * *   ALL_RR: returns all addresses.
   * *   RATIO: returns addresses by weight.
   * 
   * @example
   * all_rr
   */
  lbaStrategy?: string;
  /**
   * @remarks
   * The ID of the health check configuration.
   * 
   * @example
   * test1
   */
  monitorConfigId?: string;
  /**
   * @remarks
   * Indicates the status of the health check. Valid values:
   * 
   * *   OPEN: The health check is enabled.
   * *   CLOSE: The health check is disabled.
   * *   UNCONFIGURED: The health check is not configured.
   * 
   * @example
   * open
   */
  monitorStatus?: string;
  /**
   * @remarks
   * The name of the address pool.
   * 
   * @example
   * test
   */
  name?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 6856BCF6-11D6-4D7E-AC53-FD579933522B
   */
  requestId?: string;
  /**
   * @remarks
   * The type of the address pool. Valid values:
   * 
   * *   IPV4: IPv4 address
   * *   IPV6: IPv6 address
   * *   DOMAIN: domain name
   * 
   * @example
   * ipv4
   */
  type?: string;
  /**
   * @remarks
   * The time when the address pool was last updated.
   * 
   * @example
   * 2017-12-28T13:08Z
   */
  updateTime?: string;
  /**
   * @remarks
   * The timestamp that indicates the time when the address pool was last updated.
   * 
   * @example
   * 1527690629357
   */
  updateTimestamp?: number;
  static names(): { [key: string]: string } {
    return {
      addrCount: 'AddrCount',
      addrPoolId: 'AddrPoolId',
      addrs: 'Addrs',
      createTime: 'CreateTime',
      createTimestamp: 'CreateTimestamp',
      lbaStrategy: 'LbaStrategy',
      monitorConfigId: 'MonitorConfigId',
      monitorStatus: 'MonitorStatus',
      name: 'Name',
      requestId: 'RequestId',
      type: 'Type',
      updateTime: 'UpdateTime',
      updateTimestamp: 'UpdateTimestamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addrCount: 'number',
      addrPoolId: 'string',
      addrs: DescribeDnsGtmInstanceAddressPoolResponseBodyAddrs,
      createTime: 'string',
      createTimestamp: 'number',
      lbaStrategy: 'string',
      monitorConfigId: 'string',
      monitorStatus: 'string',
      name: 'string',
      requestId: 'string',
      type: 'string',
      updateTime: 'string',
      updateTimestamp: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmInstanceAddressPoolResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDnsGtmInstanceAddressPoolResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDnsGtmInstanceAddressPoolResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmInstanceAddressPoolsRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * instance1
   */
  instanceId?: string;
  /**
   * @remarks
   * The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The number of the page to return. Pages start from page 1. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Maximum value: 100. Default value: 20.
   * 
   * @example
   * 1
   */
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      lang: 'Lang',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      lang: 'string',
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmInstanceAddressPoolsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned address pools.
   */
  addrPools?: DescribeDnsGtmInstanceAddressPoolsResponseBodyAddrPools;
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 1
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 6856BCF6-11D6-4D7E-AC53-FD579933522B
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries returned on all pages.
   * 
   * @example
   * 1
   */
  totalItems?: number;
  /**
   * @remarks
   * The total number of pages returned.
   * 
   * @example
   * 1
   */
  totalPages?: number;
  static names(): { [key: string]: string } {
    return {
      addrPools: 'AddrPools',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalItems: 'TotalItems',
      totalPages: 'TotalPages',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addrPools: DescribeDnsGtmInstanceAddressPoolsResponseBodyAddrPools,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalItems: 'number',
      totalPages: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmInstanceAddressPoolsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDnsGtmInstanceAddressPoolsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDnsGtmInstanceAddressPoolsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmInstanceStatusRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * instance1
   */
  instanceId?: string;
  /**
   * @remarks
   * The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.
   * 
   * @example
   * en
   */
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmInstanceStatusResponseBody extends $tea.Model {
  /**
   * @remarks
   * The number of available addresses.
   * 
   * @example
   * 1
   */
  addrAvailableNum?: number;
  /**
   * @remarks
   * The number of unavailable addresses.
   * 
   * @example
   * 1
   */
  addrNotAvailableNum?: number;
  /**
   * @remarks
   * The number of unavailable address pool groups.
   * 
   * @example
   * 1
   */
  addrPoolGroupNotAvailableNum?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 389DFFA3-77A5-4A9E-BF3D-147C6F98A5BA
   */
  requestId?: string;
  /**
   * @remarks
   * The number of access policies that are unavailable in the current active address pool group.
   * 
   * @example
   * 1
   */
  strategyNotAvailableNum?: number;
  /**
   * @remarks
   * The number of access policies switched to the secondary address pool group.
   * 
   * @example
   * 1
   */
  switchToFailoverStrategyNum?: number;
  static names(): { [key: string]: string } {
    return {
      addrAvailableNum: 'AddrAvailableNum',
      addrNotAvailableNum: 'AddrNotAvailableNum',
      addrPoolGroupNotAvailableNum: 'AddrPoolGroupNotAvailableNum',
      requestId: 'RequestId',
      strategyNotAvailableNum: 'StrategyNotAvailableNum',
      switchToFailoverStrategyNum: 'SwitchToFailoverStrategyNum',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addrAvailableNum: 'number',
      addrNotAvailableNum: 'number',
      addrPoolGroupNotAvailableNum: 'number',
      requestId: 'string',
      strategyNotAvailableNum: 'number',
      switchToFailoverStrategyNum: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmInstanceStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDnsGtmInstanceStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDnsGtmInstanceStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmInstanceSystemCnameRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * instance1
   */
  instanceId?: string;
  /**
   * @remarks
   * The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.
   * 
   * @example
   * en
   */
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmInstanceSystemCnameResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 6856BCF6-11D6-4D7E-AC53-FD579933522B
   */
  requestId?: string;
  /**
   * @remarks
   * The CNAME domain name assigned by the system.
   * 
   * @example
   * gtminstance.com
   */
  systemCname?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      systemCname: 'SystemCname',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      systemCname: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmInstanceSystemCnameResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDnsGtmInstanceSystemCnameResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDnsGtmInstanceSystemCnameResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmInstancesRequest extends $tea.Model {
  /**
   * @remarks
   * The keyword that you use for query. Fuzzy search by instance ID or instance name is supported.
   * 
   * @example
   * instance1
   */
  keyword?: string;
  /**
   * @remarks
   * The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * @example
   * 1
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the resource group where you want to query instances.
   * 
   * @example
   * rg-testgroupid
   */
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      keyword: 'Keyword',
      lang: 'Lang',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      keyword: 'string',
      lang: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmInstancesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned instances.
   */
  gtmInstances?: DescribeDnsGtmInstancesResponseBodyGtmInstances[];
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 1
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 84314904-D047-4176-A0EC-256D7F68C7F5
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries returned on all pages.
   * 
   * @example
   * 100
   */
  totalItems?: number;
  /**
   * @remarks
   * The total number of returned pages.
   * 
   * @example
   * 123
   */
  totalPages?: number;
  static names(): { [key: string]: string } {
    return {
      gtmInstances: 'GtmInstances',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalItems: 'TotalItems',
      totalPages: 'TotalPages',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gtmInstances: { 'type': 'array', 'itemType': DescribeDnsGtmInstancesResponseBodyGtmInstances },
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalItems: 'number',
      totalPages: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmInstancesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDnsGtmInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDnsGtmInstancesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmLogsRequest extends $tea.Model {
  /**
   * @remarks
   * The timestamp that specifies the end of the time range to query.
   * 
   * @example
   * 1516779348000
   */
  endTimestamp?: number;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * instance1
   */
  instanceId?: string;
  /**
   * @remarks
   * The keyword for searches in "%KeyWord%" mode. The value is not case-sensitive.
   * 
   * @example
   * demo
   */
  keyword?: string;
  /**
   * @remarks
   * The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The number of the page to return. Pages start from page 1. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Maximum value: 100. Default value: 20.
   * 
   * @example
   * 1
   */
  pageSize?: number;
  /**
   * @remarks
   * The timestamp that specifies the beginning of the time range to query.
   * 
   * @example
   * 1516779348000
   */
  startTimestamp?: number;
  static names(): { [key: string]: string } {
    return {
      endTimestamp: 'EndTimestamp',
      instanceId: 'InstanceId',
      keyword: 'Keyword',
      lang: 'Lang',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      startTimestamp: 'StartTimestamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTimestamp: 'number',
      instanceId: 'string',
      keyword: 'string',
      lang: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      startTimestamp: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmLogsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned logs.
   */
  logs?: DescribeDnsGtmLogsResponseBodyLogs;
  /**
   * @remarks
   * The number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 1
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 50C60A29-2E93-425A-ABA8-068686E28873
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries returned on all pages.
   * 
   * @example
   * 1
   */
  totalItems?: number;
  /**
   * @remarks
   * The total number of pages returned.
   * 
   * @example
   * 1
   */
  totalPages?: number;
  static names(): { [key: string]: string } {
    return {
      logs: 'Logs',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalItems: 'TotalItems',
      totalPages: 'TotalPages',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logs: DescribeDnsGtmLogsResponseBodyLogs,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalItems: 'number',
      totalPages: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmLogsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDnsGtmLogsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDnsGtmLogsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmMonitorAvailableConfigRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the values of specific response parameters. Default value: en. Valid values: en, zh, and ja.
   * 
   * @example
   * en
   */
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmMonitorAvailableConfigResponseBody extends $tea.Model {
  /**
   * @remarks
   * The monitored nodes that can be used to perform health checks on address pools that contain public domain names that are resolved to IPv4 addresses.
   */
  domainIpv4IspCityNodes?: DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodes;
  /**
   * @remarks
   * The monitored nodes that can be used to perform health checks on address pools that contain public domain names that are resolved to IPv6 addresses.
   */
  domainIpv6IspCityNodes?: DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodes;
  /**
   * @remarks
   * The monitored nodes that can be used to perform health checks on address pools that contain public IPv4 addresses.
   */
  ipv4IspCityNodes?: DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodes;
  /**
   * @remarks
   * The monitored nodes that can be used to perform health checks on address pools that contain public IPv6 addresses.
   */
  ipv6IspCityNodes?: DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodes;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 6856BCF6-11D6-4D7E-AC53-FD579933522B
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      domainIpv4IspCityNodes: 'DomainIpv4IspCityNodes',
      domainIpv6IspCityNodes: 'DomainIpv6IspCityNodes',
      ipv4IspCityNodes: 'Ipv4IspCityNodes',
      ipv6IspCityNodes: 'Ipv6IspCityNodes',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainIpv4IspCityNodes: DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodes,
      domainIpv6IspCityNodes: DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodes,
      ipv4IspCityNodes: DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodes,
      ipv6IspCityNodes: DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodes,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmMonitorAvailableConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDnsGtmMonitorAvailableConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDnsGtmMonitorAvailableConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmMonitorConfigRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the values of specific response parameters. Default value: en. Valid values: en, zh, and ja.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The ID of the health check task.
   * 
   * This parameter is required.
   * 
   * @example
   * MonitorConfigId1
   */
  monitorConfigId?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      monitorConfigId: 'MonitorConfigId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      monitorConfigId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmMonitorConfigResponseBody extends $tea.Model {
  /**
   * @remarks
   * The time when the health check task was created.
   * 
   * @example
   * 2017-12-28T13:08Z
   */
  createTime?: string;
  /**
   * @remarks
   * The timestamp that indicates when the health check task was created.
   * 
   * @example
   * 1527690629357
   */
  createTimestamp?: number;
  /**
   * @remarks
   * The number of consecutive times of failed health check attempts.
   * 
   * @example
   * 1
   */
  evaluationCount?: number;
  /**
   * @remarks
   * The interval at which the health check task is executed. Unit: seconds.
   * 
   * @example
   * 1
   */
  interval?: number;
  /**
   * @remarks
   * The monitored node.
   */
  ispCityNodes?: DescribeDnsGtmMonitorConfigResponseBodyIspCityNodes;
  /**
   * @remarks
   * The ID of the health check task.
   * 
   * @example
   * MonitorConfigId1
   */
  monitorConfigId?: string;
  /**
   * @remarks
   * The extended information. The following parameters are required for different health check protocols:
   * 
   * *   HTTP or HTTPS:
   * 
   *     *   port: the check port.
   * 
   *     *   host: the host settings.
   * 
   *     *   path: the URL path.
   * 
   *     *   code: the return code greater than the specified value.
   * 
   *     *   failureRate: the failure rate.
   * 
   *     *   sni: specifies whether to enable server name indication (SNI). This parameter is used only for the HTTPS protocol. Valid values:
   * 
   *         *   true: enable SNI.
   *         *   false: disable SNI.
   * 
   *     *   nodeType: the type of the node to monitor when the address pool type is DOMAIN. Valid values:
   * 
   *         *   IPV4
   *         *   IPV6
   * 
   * *   PING:
   * 
   *     *   failureRate: the failure rate.
   * 
   *     *   packetNum: the number of ping packets.
   * 
   *     *   packetLossRate: the loss rate of ping packets.
   * 
   *     *   nodeType: the type of the node to monitor when the address pool type is DOMAIN. Valid values:
   * 
   *         *   IPV4
   *         *   IPV6
   * 
   * *   TCP:
   * 
   *     *   port: the check port.
   * 
   *     *   failureRate: the failure rate.
   * 
   *     *   nodeType: the type of the node to monitor when the address pool type is DOMAIN. Valid values:
   * 
   *         *   IPV4
   *         *   IPV6
   * 
   * @example
   * {\\"code\\":200,\\"path\\":\\"\\\\index.htm\\",\\"host\\":\\"aliyun.com\\"}
   */
  monitorExtendInfo?: string;
  /**
   * @remarks
   * The health check protocol. Valid values:
   * 
   * *   HTTP
   * *   HTTPS
   * *   PING
   * *   TCP
   * 
   * @example
   * http
   */
  protocolType?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 6856BCF6-11D6-4D7E-AC53-FD579933522B
   */
  requestId?: string;
  /**
   * @remarks
   * The timeout period. Unit: milliseconds.
   * 
   * @example
   * 3000
   */
  timeout?: number;
  /**
   * @remarks
   * The time when the information about the health check task was updated.
   * 
   * @example
   * 2018-01-03T08:57Z
   */
  updateTime?: string;
  /**
   * @remarks
   * The timestamp that indicates when the information about the health check task was updated.
   * 
   * @example
   * 1527690629357
   */
  updateTimestamp?: number;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      createTimestamp: 'CreateTimestamp',
      evaluationCount: 'EvaluationCount',
      interval: 'Interval',
      ispCityNodes: 'IspCityNodes',
      monitorConfigId: 'MonitorConfigId',
      monitorExtendInfo: 'MonitorExtendInfo',
      protocolType: 'ProtocolType',
      requestId: 'RequestId',
      timeout: 'Timeout',
      updateTime: 'UpdateTime',
      updateTimestamp: 'UpdateTimestamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'string',
      createTimestamp: 'number',
      evaluationCount: 'number',
      interval: 'number',
      ispCityNodes: DescribeDnsGtmMonitorConfigResponseBodyIspCityNodes,
      monitorConfigId: 'string',
      monitorExtendInfo: 'string',
      protocolType: 'string',
      requestId: 'string',
      timeout: 'number',
      updateTime: 'string',
      updateTimestamp: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmMonitorConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDnsGtmMonitorConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDnsGtmMonitorConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsProductInstanceRequest extends $tea.Model {
  /**
   * @remarks
   * The instance ID. You can call the **DescribeDomainInfo** operation to obtain the instance ID.
   * 
   * This parameter is required.
   * 
   * @example
   * i-8fxxxx
   */
  instanceId?: string;
  /**
   * @remarks
   * The language.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The IP address of the client.
   * 
   * @example
   * 192.0.2.0
   */
  userClientIp?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      lang: 'Lang',
      userClientIp: 'UserClientIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      lang: 'string',
      userClientIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsProductInstanceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The auto-renewal status of the instance. Valid values:
   * 
   * *   **true**: Auto-renewal is enabled.
   * *   **false**: Auto-renewal is disabled.
   * 
   * @example
   * true
   */
  autoRenewal?: boolean;
  /**
   * @remarks
   * The number of times that you can change the domain names that are bound to the paid Alibaba Cloud DNS instance. This parameter applies to Alibaba Cloud DNS instances of the custom edition.
   * 
   * @example
   * 3
   */
  bindCount?: number;
  /**
   * @remarks
   * The number of domain names that can be bound to the paid Alibaba Cloud DNS instance. This parameter applies to Alibaba Cloud DNS instances of Personal Edition, Enterprise Standard Edition, and Enterprise Ultimate Edition.
   * 
   * @example
   * 5
   */
  bindDomainCount?: number;
  /**
   * @remarks
   * The number of domain names that are bound to the paid Alibaba Cloud DNS instance. This parameter applies to Alibaba Cloud DNS instances of Personal Edition, Enterprise Standard Edition, and Enterprise Ultimate Edition.
   * 
   * @example
   * 3
   */
  bindDomainUsedCount?: number;
  /**
   * @remarks
   * The number of times that you have changed the domain names that are bound to the paid Alibaba Cloud DNS instance. This parameter applies to Alibaba Cloud DNS instances of the custom edition.
   * 
   * @example
   * 1
   */
  bindUsedCount?: number;
  /**
   * @remarks
   * The DDoS protection traffic. Unit: GB.
   * 
   * @example
   * 50
   */
  DDosDefendFlow?: number;
  /**
   * @remarks
   * The DDoS protection frequency. Unit: 10,000 QPS. This parameter applies to Alibaba Cloud DNS instances of the custom edition.
   * 
   * @example
   * 50
   */
  DDosDefendQuery?: number;
  /**
   * @remarks
   * The maximum number of IP addresses that are used for load balancing in a single line of a domain name.
   * 
   * @example
   * 15
   */
  dnsSLBCount?: number;
  /**
   * @remarks
   * The DNS protection level. Valid values:
   * 
   * *   **no**: DNS protection is not provided.
   * *   **basic**: Basic DNS attack defense is provided.
   * *   **advanced**: Advanced DNS attack defense is provided.
   * 
   * @example
   * advanced
   */
  dnsSecurity?: string;
  /**
   * @remarks
   * The DNS servers configured for the domain names.
   */
  dnsServers?: DescribeDnsProductInstanceResponseBodyDnsServers;
  /**
   * @remarks
   * The domain name that is bound to the paid instance.
   * 
   * If no value is returned for this parameter, no domain name is bound to the paid instance.
   * 
   * @example
   * example.com
   */
  domain?: string;
  /**
   * @remarks
   * The type of the instance. Valid values:
   * 
   * *   PUBLIC: authoritative domain name
   * *   CACHE: cache-accelerated domain name
   * 
   * @example
   * PUBLIC
   */
  domainType?: string;
  /**
   * @remarks
   * The time when the instance expired. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
   * 
   * @example
   * 2015-12-12T09:23Z
   */
  endTime?: string;
  /**
   * @remarks
   * The time when the instance expired. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
   * 
   * @example
   * 1474335170000
   */
  endTimestamp?: number;
  /**
   * @remarks
   * Indicates whether global server load balancing (GSLB) is supported.
   * 
   * @example
   * true
   */
  gslb?: boolean;
  /**
   * @remarks
   * The Internet service provider (ISP) lines for DNS resolution.
   */
  ISPLines?: string;
  /**
   * @remarks
   * The regional ISP lines for DNS resolution.
   */
  ISPRegionLines?: string;
  /**
   * @remarks
   * Indicates whether the Domain Name System (DNS) servers stopped responding to all requests sent to the domain names.
   * 
   * @example
   * false
   */
  inBlackHole?: boolean;
  /**
   * @remarks
   * Indicates whether the DNS servers stopped responding to abnormal requests sent to the domain names.
   * 
   * @example
   * false
   */
  inClean?: boolean;
  /**
   * @remarks
   * The ID of the Alibaba Cloud DNS instance.
   * 
   * @example
   * i-8fxxx
   */
  instanceId?: string;
  /**
   * @remarks
   * The interval at which the instance is monitored. Unit: minutes.
   * 
   * @example
   * 50
   */
  monitorFrequency?: number;
  /**
   * @remarks
   * The number of monitoring nodes.
   * 
   * @example
   * 5
   */
  monitorNodeCount?: number;
  /**
   * @remarks
   * The number of monitoring tasks.
   * 
   * @example
   * 2
   */
  monitorTaskCount?: number;
  /**
   * @remarks
   * The DDoS protection traffic outside the Chinese mainland. Unit: GB.
   * 
   * @example
   * 1
   */
  overseaDDosDefendFlow?: number;
  /**
   * @remarks
   * The line outside the Chinese mainland.
   */
  overseaLine?: string;
  /**
   * @remarks
   * The billing method.
   * 
   * @example
   * Subscription
   */
  paymentType?: string;
  /**
   * @remarks
   * Indicates whether regional lines are supported.
   * 
   * @example
   * true
   */
  regionLines?: boolean;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 536E9CAD-DB30-4647-AC87-AA5CC38C5382
   */
  requestId?: string;
  /**
   * @remarks
   * The search engine lines for DNS resolution.
   */
  searchEngineLines?: string;
  /**
   * @remarks
   * The time when the instance was purchased. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
   * 
   * @example
   * 2015-12-12T09:23Z
   */
  startTime?: string;
  /**
   * @remarks
   * The time when the instance was purchased. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
   * 
   * @example
   * 1474335170000
   */
  startTimestamp?: number;
  /**
   * @remarks
   * The number of subdomain name levels.
   * 
   * @example
   * 6
   */
  subDomainLevel?: number;
  /**
   * @remarks
   * The minimum time-to-live (TTL) period. Unit: seconds.
   * 
   * @example
   * 10
   */
  TTLMinValue?: number;
  /**
   * @remarks
   * The number of the forwarded URLs.
   * 
   * @example
   * 20
   */
  URLForwardCount?: number;
  /**
   * @remarks
   * The version code of Alibaba Cloud DNS.
   * 
   * @example
   * version1
   */
  versionCode?: string;
  /**
   * @remarks
   * The edition of Alibaba Cloud DNS.
   */
  versionName?: string;
  static names(): { [key: string]: string } {
    return {
      autoRenewal: 'AutoRenewal',
      bindCount: 'BindCount',
      bindDomainCount: 'BindDomainCount',
      bindDomainUsedCount: 'BindDomainUsedCount',
      bindUsedCount: 'BindUsedCount',
      DDosDefendFlow: 'DDosDefendFlow',
      DDosDefendQuery: 'DDosDefendQuery',
      dnsSLBCount: 'DnsSLBCount',
      dnsSecurity: 'DnsSecurity',
      dnsServers: 'DnsServers',
      domain: 'Domain',
      domainType: 'DomainType',
      endTime: 'EndTime',
      endTimestamp: 'EndTimestamp',
      gslb: 'Gslb',
      ISPLines: 'ISPLines',
      ISPRegionLines: 'ISPRegionLines',
      inBlackHole: 'InBlackHole',
      inClean: 'InClean',
      instanceId: 'InstanceId',
      monitorFrequency: 'MonitorFrequency',
      monitorNodeCount: 'MonitorNodeCount',
      monitorTaskCount: 'MonitorTaskCount',
      overseaDDosDefendFlow: 'OverseaDDosDefendFlow',
      overseaLine: 'OverseaLine',
      paymentType: 'PaymentType',
      regionLines: 'RegionLines',
      requestId: 'RequestId',
      searchEngineLines: 'SearchEngineLines',
      startTime: 'StartTime',
      startTimestamp: 'StartTimestamp',
      subDomainLevel: 'SubDomainLevel',
      TTLMinValue: 'TTLMinValue',
      URLForwardCount: 'URLForwardCount',
      versionCode: 'VersionCode',
      versionName: 'VersionName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoRenewal: 'boolean',
      bindCount: 'number',
      bindDomainCount: 'number',
      bindDomainUsedCount: 'number',
      bindUsedCount: 'number',
      DDosDefendFlow: 'number',
      DDosDefendQuery: 'number',
      dnsSLBCount: 'number',
      dnsSecurity: 'string',
      dnsServers: DescribeDnsProductInstanceResponseBodyDnsServers,
      domain: 'string',
      domainType: 'string',
      endTime: 'string',
      endTimestamp: 'number',
      gslb: 'boolean',
      ISPLines: 'string',
      ISPRegionLines: 'string',
      inBlackHole: 'boolean',
      inClean: 'boolean',
      instanceId: 'string',
      monitorFrequency: 'number',
      monitorNodeCount: 'number',
      monitorTaskCount: 'number',
      overseaDDosDefendFlow: 'number',
      overseaLine: 'string',
      paymentType: 'string',
      regionLines: 'boolean',
      requestId: 'string',
      searchEngineLines: 'string',
      startTime: 'string',
      startTimestamp: 'number',
      subDomainLevel: 'number',
      TTLMinValue: 'number',
      URLForwardCount: 'number',
      versionCode: 'string',
      versionName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsProductInstanceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDnsProductInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDnsProductInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsProductInstancesRequest extends $tea.Model {
  /**
   * @remarks
   * The Sorting direction. Values:
   * * **DESC**: Descending (if not specified, the default is descending order)
   * * **ASC**: Ascending
   * 
   * @example
   * DESC
   */
  direction?: string;
  /**
   * @remarks
   * The type of the domain name. Valid values:
   * 
   * *   PUBLIC (default): hosted public domain name
   * *   CACHE: cached public domain name
   * 
   * @example
   * PUBLIC
   */
  domainType?: string;
  /**
   * @remarks
   * The language of the content within the request and response. Valid values:
   * 
   * *   **zh** : Chinese
   * *   **en** (default) : English
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The Sorting parameter. Values:
   * * createDate: Sort by creation time (if not specified, the default is to sort by creation time)
   * * expireDate: Sort by expiration time
   * 
   * @example
   * createDate
   */
  orderBy?: string;
  /**
   * @remarks
   * The number of the page to return. Pages start from page **1**. Default value: **1**.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Maximum value: **100**. Default value: **20**.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The IP address of the client.
   * 
   * @example
   * 192.0.2.0
   */
  userClientIp?: string;
  /**
   * @remarks
   * The version code of the Alibaba Cloud DNS instance.
   * 
   * @example
   * version1
   */
  versionCode?: string;
  static names(): { [key: string]: string } {
    return {
      direction: 'Direction',
      domainType: 'DomainType',
      lang: 'Lang',
      orderBy: 'OrderBy',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      userClientIp: 'UserClientIp',
      versionCode: 'VersionCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      direction: 'string',
      domainType: 'string',
      lang: 'string',
      orderBy: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      userClientIp: 'string',
      versionCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsProductInstancesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The list of Alibaba Cloud DNS instances obtained by this operation.
   */
  dnsProducts?: DescribeDnsProductInstancesResponseBodyDnsProducts;
  /**
   * @remarks
   * The type of the domain name. Valid values:
   * 
   * *   PUBLIC (default): hosted public domain name
   * *   CACHE: cached public domain name
   * 
   * @example
   * PUBLIC
   */
  domainType?: string;
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 2
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 536E9CAD-DB30-4647-AC87-AA5CC38C5382
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of domain names.
   * 
   * @example
   * 2
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      dnsProducts: 'DnsProducts',
      domainType: 'DomainType',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dnsProducts: DescribeDnsProductInstancesResponseBodyDnsProducts,
      domainType: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsProductInstancesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDnsProductInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDnsProductInstancesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDohAccountStatisticsRequest extends $tea.Model {
  /**
   * @remarks
   * The end of the time range to query. Specify the time in the YYYY-MM-DD format.
   * 
   * The default value is the day when you perform the operation.
   * 
   * @example
   * 2019-07-04
   */
  endDate?: string;
  /**
   * @remarks
   * The language type.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The beginning of the time range to query. Specify the time in the YYYY-MM-DD format.
   * 
   * You can query only the DNS records of the latest 90 days.`The value of StartDate must be greater than or equal to the difference between the current date and 90`.
   * 
   * @example
   * 2019-07-04
   */
  startDate?: string;
  static names(): { [key: string]: string } {
    return {
      endDate: 'EndDate',
      lang: 'Lang',
      startDate: 'StartDate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endDate: 'string',
      lang: 'string',
      startDate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDohAccountStatisticsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0F32959D-417B-4D66-8463-68606605E3E2
   */
  requestId?: string;
  /**
   * @remarks
   * The statistics list.
   */
  statistics?: DescribeDohAccountStatisticsResponseBodyStatistics[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      statistics: 'Statistics',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      statistics: { 'type': 'array', 'itemType': DescribeDohAccountStatisticsResponseBodyStatistics },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDohAccountStatisticsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDohAccountStatisticsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDohAccountStatisticsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDohDomainStatisticsRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range to query. Specify the time in the YYYY-MM-DD format.
   * 
   * The default value is the day when you perform the operation.
   * 
   * @example
   * 2019-07-04
   */
  endDate?: string;
  /**
   * @remarks
   * The language type.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The beginning of the time range to query. Specify the time in the YYYY-MM-DD format.
   * 
   * You can query only the DNS records of the latest 90 days. `The value of StartDate must be greater than or equal to the difference between the current date and 90`.
   * 
   * @example
   * 2019-07-04
   */
  startDate?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endDate: 'EndDate',
      lang: 'Lang',
      startDate: 'StartDate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endDate: 'string',
      lang: 'string',
      startDate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDohDomainStatisticsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0F32959D-417B-4D66-8463-68606605E3E2
   */
  requestId?: string;
  /**
   * @remarks
   * The statistics list.
   */
  statistics?: DescribeDohDomainStatisticsResponseBodyStatistics[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      statistics: 'Statistics',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      statistics: { 'type': 'array', 'itemType': DescribeDohDomainStatisticsResponseBodyStatistics },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDohDomainStatisticsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDohDomainStatisticsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDohDomainStatisticsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDohDomainStatisticsSummaryRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range to query. Specify the time in the YYYY-MM-DD format.
   * 
   * The default value is the day when you perform the operation.
   * 
   * @example
   * 2019-07-04
   */
  endDate?: string;
  /**
   * @remarks
   * The language type.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The number of the page to return. Pages start from page 1. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Maximum value: 100. Default value: 20.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The beginning of the time range to query. Specify the time in the YYYY-MM-DD format.
   * 
   * You can query only the DNS records of the last 90 days. `The value of StartDate must be greater than or equal to the difference between the current date and 90`.
   * 
   * @example
   * 2019-07-04
   */
  startDate?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endDate: 'EndDate',
      lang: 'Lang',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      startDate: 'StartDate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endDate: 'string',
      lang: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      startDate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDohDomainStatisticsSummaryResponseBody extends $tea.Model {
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0F32959D-417B-4D66-8463-68606605E3E2
   */
  requestId?: string;
  /**
   * @remarks
   * The statistics list.
   */
  statistics?: DescribeDohDomainStatisticsSummaryResponseBodyStatistics[];
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 300
   */
  totalItems?: number;
  /**
   * @remarks
   * The total number of pages returned.
   * 
   * @example
   * 50
   */
  totalPages?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      statistics: 'Statistics',
      totalItems: 'TotalItems',
      totalPages: 'TotalPages',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      statistics: { 'type': 'array', 'itemType': DescribeDohDomainStatisticsSummaryResponseBodyStatistics },
      totalItems: 'number',
      totalPages: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDohDomainStatisticsSummaryResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDohDomainStatisticsSummaryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDohDomainStatisticsSummaryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDohSubDomainStatisticsRequest extends $tea.Model {
  /**
   * @remarks
   * The end of the time range to query. Specify the time in the YYYY-MM-DD format.
   * 
   * The default value is the day when you perform the operation.
   * 
   * @example
   * 2019-07-04
   */
  endDate?: string;
  /**
   * @remarks
   * The language type.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The beginning of the time range to query. Specify the time in the YYYY-MM-DD format.
   * 
   * You can query only the DNS records of the latest 90 days. `The value of StartDate must be greater than or equal to the difference between the current date and 90`.
   * 
   * @example
   * 2019-07-04
   */
  startDate?: string;
  /**
   * @remarks
   * The subdomain whose statistics you want to query.
   * 
   * This parameter is required.
   * 
   * @example
   * www.example.com
   */
  subDomain?: string;
  static names(): { [key: string]: string } {
    return {
      endDate: 'EndDate',
      lang: 'Lang',
      startDate: 'StartDate',
      subDomain: 'SubDomain',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endDate: 'string',
      lang: 'string',
      startDate: 'string',
      subDomain: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDohSubDomainStatisticsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0F32959D-417B-4D66-8463-68606605E3E2
   */
  requestId?: string;
  /**
   * @remarks
   * The statistics list.
   */
  statistics?: DescribeDohSubDomainStatisticsResponseBodyStatistics[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      statistics: 'Statistics',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      statistics: { 'type': 'array', 'itemType': DescribeDohSubDomainStatisticsResponseBodyStatistics },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDohSubDomainStatisticsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDohSubDomainStatisticsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDohSubDomainStatisticsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDohSubDomainStatisticsSummaryRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range to query. Specify the time in the YYYY-MM-DD format.
   * 
   * The default value is the day when you query the required data.
   * 
   * @example
   * 2019-07-04
   */
  endDate?: string;
  /**
   * @remarks
   * The language type.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The number of the page to return. Pages start from page 1. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Maximum value: 100. Default value: 20.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The beginning of the time range to query. Specify the time in the YYYY-MM-DD format.
   * 
   * You can query only the DNS records of the last 90 days. `The value of StartDate must be greater than or equal to the difference between the current date and 90`.
   * 
   * @example
   * 2019-07-04
   */
  startDate?: string;
  /**
   * @remarks
   * The subdomain.
   * 
   * @example
   * www.example.com
   */
  subDomain?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endDate: 'EndDate',
      lang: 'Lang',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      startDate: 'StartDate',
      subDomain: 'SubDomain',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endDate: 'string',
      lang: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      startDate: 'string',
      subDomain: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDohSubDomainStatisticsSummaryResponseBody extends $tea.Model {
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0F32959D-417B-4D66-8463-68606605E3E2
   */
  requestId?: string;
  /**
   * @remarks
   * The statistics list.
   */
  statistics?: DescribeDohSubDomainStatisticsSummaryResponseBodyStatistics[];
  /**
   * @remarks
   * Total number of entries returned.
   * 
   * @example
   * 100
   */
  totalItems?: number;
  /**
   * @remarks
   * Total number of pages returned.
   * 
   * @example
   * 50
   */
  totalPages?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      statistics: 'Statistics',
      totalItems: 'TotalItems',
      totalPages: 'TotalPages',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      statistics: { 'type': 'array', 'itemType': DescribeDohSubDomainStatisticsSummaryResponseBodyStatistics },
      totalItems: 'number',
      totalPages: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDohSubDomainStatisticsSummaryResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDohSubDomainStatisticsSummaryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDohSubDomainStatisticsSummaryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDohUserInfoRequest extends $tea.Model {
  /**
   * @remarks
   * The end time for the query. Format: YYYY-MM-DD
   * 
   * If you do not specify this parameter, the default value is the time when you perform the query.
   * 
   * @example
   * 2019-07-04
   */
  endDate?: string;
  /**
   * @remarks
   * The language in which you want the values of some response parameters to be returned. These response parameters support multiple languages.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The start time for the query. Format: YYYY-MM-DD
   * 
   * You can query the user information of the last 90 days only. `Set the parameter to a value no earlier than 90 days from the current time`.
   * 
   * @example
   * 2019-07-04
   */
  startDate?: string;
  static names(): { [key: string]: string } {
    return {
      endDate: 'EndDate',
      lang: 'Lang',
      startDate: 'StartDate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endDate: 'string',
      lang: 'string',
      startDate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDohUserInfoResponseBody extends $tea.Model {
  /**
   * @remarks
   * The number of accessed domains.
   * 
   * @example
   * 123
   */
  domainCount?: number;
  /**
   * @remarks
   * The ID of the Alibaba Cloud public DNS user.
   * 
   * @example
   * 12345678
   */
  pdnsId?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0F32959D-417B-4D66-8463-68606605E3E2
   */
  requestId?: string;
  /**
   * @remarks
   * The number of accessed subdomains.
   * 
   * @example
   * 123
   */
  subDomainCount?: number;
  static names(): { [key: string]: string } {
    return {
      domainCount: 'DomainCount',
      pdnsId: 'PdnsId',
      requestId: 'RequestId',
      subDomainCount: 'SubDomainCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainCount: 'number',
      pdnsId: 'number',
      requestId: 'string',
      subDomainCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDohUserInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDohUserInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDohUserInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainDnssecInfoRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The language.
   * 
   * @example
   * en
   */
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainDnssecInfoResponseBody extends $tea.Model {
  /**
   * @remarks
   * The algorithm type. This parameter is returned if DNSSEC is enabled.
   * 
   * @example
   * 13
   */
  algorithm?: string;
  /**
   * @remarks
   * The digest. This parameter is returned if DNSSEC is enabled.
   * 
   * @example
   * C1A0424B97A049F1F9B2EA139CC298533219668164E343BD21203ABC4608C02A
   */
  digest?: string;
  /**
   * @remarks
   * The digest type. This parameter is returned if DNSSEC is enabled.
   * 
   * @example
   * SHA256
   */
  digestType?: string;
  /**
   * @remarks
   * The domain name.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The delegation signer (DS) record. This parameter is returned if DNSSEC is enabled.
   * 
   * @example
   * example.com. 3600 IN DS 2371 13 2 C1A0424B97A049F1F9B2EA139CC298533219668164E343BD21203ABC4608C02A
   */
  dsRecord?: string;
  /**
   * @remarks
   * The flag. This parameter is returned if DNSSEC is enabled.
   * 
   * @example
   * 257 (KSK)
   */
  flags?: string;
  /**
   * @remarks
   * The key tag. This parameter is returned if DNSSEC is enabled.
   * 
   * @example
   * 54931
   */
  keyTag?: string;
  /**
   * @remarks
   * The public key. This parameter is returned if DNSSEC is enabled.
   * 
   * @example
   * mdsswUyr3DPW132mOi8V9xESWE8jTo0dxCjjnopKl+GqJxpVXckHAeF+KkxLbxILfDLUT0rAK9iUzy1L53eKGQ==
   */
  publicKey?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 536E9CAD-DB30-4647-AC87-AA5CC38C5382
   */
  requestId?: string;
  /**
   * @remarks
   * The state of the DNSSEC. Valid values:
   * 
   * *   ON
   * *   OFF
   * 
   * @example
   * ON
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      algorithm: 'Algorithm',
      digest: 'Digest',
      digestType: 'DigestType',
      domainName: 'DomainName',
      dsRecord: 'DsRecord',
      flags: 'Flags',
      keyTag: 'KeyTag',
      publicKey: 'PublicKey',
      requestId: 'RequestId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      algorithm: 'string',
      digest: 'string',
      digestType: 'string',
      domainName: 'string',
      dsRecord: 'string',
      flags: 'string',
      keyTag: 'string',
      publicKey: 'string',
      requestId: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainDnssecInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDomainDnssecInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDomainDnssecInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainGroupsRequest extends $tea.Model {
  /**
   * @remarks
   * The keyword of the domain name group for searches in %KeyWord% mode. The value is not case-sensitive.
   * 
   * @example
   * Group
   */
  keyWord?: string;
  /**
   * @remarks
   * The language.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The page number. Pages start from page **1**. Default value: **1**.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Valid values: **1 to 100**. Default value: **20**.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      keyWord: 'KeyWord',
      lang: 'Lang',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      keyWord: 'string',
      lang: 'string',
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainGroupsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The domain name groups.
   */
  domainGroups?: DescribeDomainGroupsResponseBodyDomainGroups;
  /**
   * @remarks
   * The page number. Pages start from page **1**. Default value: **1**.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Valid values: **1 to 100**. Default value: **20**.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 536E9CAD-DB30-4647-AC87-AA5CC38C5382
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      domainGroups: 'DomainGroups',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainGroups: DescribeDomainGroupsResponseBodyDomainGroups,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainGroupsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDomainGroupsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDomainGroupsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainInfoRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name.
   * 
   * This parameter is required.
   * 
   * @example
   * dns-example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The language type.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * Specifies whether detailed attributes are required. The default value is **false**, which indicates that detailed attributes are not required.
   * 
   * If you set this parameter to **true**, the values of the following parameters are returned: LineType, MinTtl, RecordLineTreeJson, RecordLines, LineCode, LineDisplayName, LineName, RegionLines, and SlaveDns.
   * 
   * @example
   * true
   */
  needDetailAttributes?: boolean;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      lang: 'Lang',
      needDetailAttributes: 'NeedDetailAttributes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      lang: 'string',
      needDetailAttributes: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainInfoResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the domain name was registered in Alibaba Cloud.
   * 
   * @example
   * true
   */
  aliDomain?: boolean;
  /**
   * @remarks
   * The available time to live (TTL) values that can be configured for the domain name. Available TTL values are not returned by default. If you want to query such information, set NeedDetailAttributes to true.
   */
  availableTtls?: DescribeDomainInfoResponseBodyAvailableTtls;
  /**
   * @remarks
   * The time when the domain name was created.
   * 
   * @example
   * 2015-12-12T09:23Z
   */
  createTime?: string;
  /**
   * @remarks
   * The DNS servers that are used to resolve the domain name.
   */
  dnsServers?: DescribeDomainInfoResponseBodyDnsServers;
  /**
   * @remarks
   * The ID of the domain name.
   * 
   * @example
   * 00efd71a-770e-4255-b54e-6fe5659baffe
   */
  domainId?: string;
  domainLoggingSwitchStatus?: string;
  /**
   * @remarks
   * The domain name.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The ID of the domain name group.
   * 
   * @example
   * 2223
   */
  groupId?: string;
  /**
   * @remarks
   * The name of the domain name group.
   * 
   * @example
   * mygroup
   */
  groupName?: string;
  /**
   * @remarks
   * Indicates whether blackhole filtering was triggered.
   * 
   * @example
   * false
   */
  inBlackHole?: boolean;
  /**
   * @remarks
   * Indicates whether traffic scrubbing was in progress.
   * 
   * @example
   * false
   */
  inClean?: boolean;
  /**
   * @remarks
   * The ID of the Alibaba Cloud DNS instance.
   * 
   * @example
   * i-7bg
   */
  instanceId?: string;
  /**
   * @remarks
   * The type of the DNS request line.
   * 
   * @example
   * region_province
   */
  lineType?: string;
  /**
   * @remarks
   * The minimum TTL value.
   * 
   * @example
   * 1
   */
  minTtl?: number;
  /**
   * @remarks
   * The Punycode for the domain name. This parameter is returned only for Chinese domain names.
   * 
   * @example
   * example.com
   */
  punyCode?: string;
  /**
   * @remarks
   * The tree-structure DNS request lines.
   * 
   * @example
   * {"default":{},"unicom":{},"telecom":{},"mobile":{},"edu":{},"oversea":{},"baidu":{},"biying":{},"google":{}}
   */
  recordLineTreeJson?: string;
  /**
   * @remarks
   * The DNS request lines.
   */
  recordLines?: DescribeDomainInfoResponseBodyRecordLines;
  /**
   * @remarks
   * Indicates whether the DNS request lines are regional lines.
   * 
   * @example
   * false
   */
  regionLines?: boolean;
  /**
   * @remarks
   * The description.
   * 
   * @example
   * remark
   */
  remark?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 536E9CAD-DB30-4647-AC87-AA5CC38C5382
   */
  requestId?: string;
  /**
   * @remarks
   * The ID of the resource group.
   * 
   * @example
   * rg-aek3dj3wvclgcxo
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * Indicates whether secondary DNS is supported.
   * 
   * @example
   * true
   */
  slaveDns?: boolean;
  /**
   * @remarks
   * Indicates whether the queried domain name is a hosted subdomain name. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * false
   */
  subDomain?: boolean;
  /**
   * @remarks
   * The version ID of Alibaba Cloud DNS.
   * 
   * @example
   * version1
   */
  versionCode?: string;
  /**
   * @remarks
   * The edition of Alibaba Cloud DNS.
   */
  versionName?: string;
  static names(): { [key: string]: string } {
    return {
      aliDomain: 'AliDomain',
      availableTtls: 'AvailableTtls',
      createTime: 'CreateTime',
      dnsServers: 'DnsServers',
      domainId: 'DomainId',
      domainLoggingSwitchStatus: 'DomainLoggingSwitchStatus',
      domainName: 'DomainName',
      groupId: 'GroupId',
      groupName: 'GroupName',
      inBlackHole: 'InBlackHole',
      inClean: 'InClean',
      instanceId: 'InstanceId',
      lineType: 'LineType',
      minTtl: 'MinTtl',
      punyCode: 'PunyCode',
      recordLineTreeJson: 'RecordLineTreeJson',
      recordLines: 'RecordLines',
      regionLines: 'RegionLines',
      remark: 'Remark',
      requestId: 'RequestId',
      resourceGroupId: 'ResourceGroupId',
      slaveDns: 'SlaveDns',
      subDomain: 'SubDomain',
      versionCode: 'VersionCode',
      versionName: 'VersionName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliDomain: 'boolean',
      availableTtls: DescribeDomainInfoResponseBodyAvailableTtls,
      createTime: 'string',
      dnsServers: DescribeDomainInfoResponseBodyDnsServers,
      domainId: 'string',
      domainLoggingSwitchStatus: 'string',
      domainName: 'string',
      groupId: 'string',
      groupName: 'string',
      inBlackHole: 'boolean',
      inClean: 'boolean',
      instanceId: 'string',
      lineType: 'string',
      minTtl: 'number',
      punyCode: 'string',
      recordLineTreeJson: 'string',
      recordLines: DescribeDomainInfoResponseBodyRecordLines,
      regionLines: 'boolean',
      remark: 'string',
      requestId: 'string',
      resourceGroupId: 'string',
      slaveDns: 'boolean',
      subDomain: 'boolean',
      versionCode: 'string',
      versionName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDomainInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDomainInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainLogsRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the domain name group.
   * 
   * @example
   * 2223
   */
  groupId?: string;
  /**
   * @remarks
   * The keyword for the query in "%KeyWord%" mode. The keyword is not case-sensitive.
   * 
   * @example
   * test
   */
  keyWord?: string;
  /**
   * @remarks
   * The language in which you want the values of some response parameters to be returned. These response parameters support multiple languages.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The page number to return. The page number starts from **1**. Default value: **1**.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return per page. Maximum value: **100**. Default value: **20**.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The start time for the query. Format: **YYYY-MM-DD**
   * 
   * @example
   * 2019-07-04
   */
  startDate?: string;
  /**
   * @remarks
   * The type of object of which you want to query operation logs. Valid values:
   * 
   * *   domain: domain name
   * *   slavedns: secondary Domain Name System (DNS)
   * 
   * @example
   * domain
   */
  type?: string;
  /**
   * @remarks
   * The end time for the query. Format: **YYYY-MM-DD**
   * 
   * @example
   * 2019-07-04
   */
  endDate?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      keyWord: 'KeyWord',
      lang: 'Lang',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      startDate: 'StartDate',
      type: 'Type',
      endDate: 'endDate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      keyWord: 'string',
      lang: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      startDate: 'string',
      type: 'string',
      endDate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainLogsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The operation logs.
   */
  domainLogs?: DescribeDomainLogsResponseBodyDomainLogs;
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 2
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 536E9CAD-DB30-4647-AC87-AA5CC38C5382
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 2
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      domainLogs: 'DomainLogs',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainLogs: DescribeDomainLogsResponseBodyDomainLogs,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainLogsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDomainLogsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDomainLogsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainNsRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The language.
   * 
   * @example
   * en
   */
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainNsResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether all the name servers are Alibaba Cloud DNS servers.
   * 
   * @example
   * true
   */
  allAliDns?: boolean;
  /**
   * @remarks
   * The cause code of the detection failure.
   * 
   * @example
   * DnsCheck.Failed
   */
  detectFailedReasonCode?: string;
  /**
   * @remarks
   * The DNS server names configured for the domain name.
   */
  dnsServers?: DescribeDomainNsResponseBodyDnsServers;
  /**
   * @remarks
   * The Domain Name System (DNS) server names assigned by Alibaba Cloud DNS.
   */
  expectDnsServers?: DescribeDomainNsResponseBodyExpectDnsServers;
  /**
   * @remarks
   * Indicates whether the name servers include Alibaba Cloud DNS servers.
   * 
   * @example
   * true
   */
  includeAliDns?: boolean;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 16C7DC7A-2FA7-4D14-8B12-88A2BB6373DB
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      allAliDns: 'AllAliDns',
      detectFailedReasonCode: 'DetectFailedReasonCode',
      dnsServers: 'DnsServers',
      expectDnsServers: 'ExpectDnsServers',
      includeAliDns: 'IncludeAliDns',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allAliDns: 'boolean',
      detectFailedReasonCode: 'string',
      dnsServers: DescribeDomainNsResponseBodyDnsServers,
      expectDnsServers: DescribeDomainNsResponseBodyExpectDnsServers,
      includeAliDns: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainNsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDomainNsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDomainNsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainRecordInfoRequest extends $tea.Model {
  /**
   * @remarks
   * The language.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The ID of the DNS record.
   * 
   * This parameter is returned when you add a DNS record or when you query a list of DNS records.
   * 
   * This parameter is required.
   * 
   * @example
   * 9999985
   */
  recordId?: string;
  /**
   * @remarks
   * The IP address of the client.
   * 
   * @example
   * 192.0.2.0
   */
  userClientIp?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      recordId: 'RecordId',
      userClientIp: 'UserClientIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      recordId: 'string',
      userClientIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainRecordInfoResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the domain name.
   * 
   * @example
   * 00efd71a-770e-4255-b54e-6fe5659baffe
   */
  domainId?: string;
  /**
   * @remarks
   * The domain name.
   * 
   * @example
   * dns-example.top
   */
  domainName?: string;
  /**
   * @remarks
   * The ID of the domain name group.
   * 
   * @example
   * 2223
   */
  groupId?: string;
  /**
   * @remarks
   * The name of the domain name group.
   * 
   * @example
   * MyGroup
   */
  groupName?: string;
  /**
   * @remarks
   * The DNS resolution line.
   * 
   * @example
   * default
   */
  line?: string;
  /**
   * @remarks
   * The lock state of the DNS record. Valid values: **true and false**.
   * 
   * @example
   * true
   */
  locked?: boolean;
  /**
   * @remarks
   * The priority of the mail exchanger (MX) record.
   * 
   * @example
   * 5
   */
  priority?: number;
  /**
   * @remarks
   * The Punycode for the domain name. This parameter is returned only for Chinese domain names.
   * 
   * @example
   * xn--fsq270a.com
   */
  punyCode?: string;
  /**
   * @remarks
   * The hostname.
   * 
   * @example
   * @
   */
  RR?: string;
  /**
   * @remarks
   * The ID of the DNS record.
   * 
   * @example
   * 9999985
   */
  recordId?: string;
  /**
   * @remarks
   * The description of your DNS record.
   * 
   * @example
   * test
   */
  remark?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 536E9CAD-DB30-4647-AC87-AA5CC38C5382
   */
  requestId?: string;
  /**
   * @remarks
   * The state of the DNS records. Valid values: **Enable and Disable**.
   * 
   * @example
   * Enable
   */
  status?: string;
  /**
   * @remarks
   * The time-to-live (TTL) of the DNS record.
   * 
   * @example
   * 600
   */
  TTL?: number;
  /**
   * @remarks
   * The type of the DNS record.
   * 
   * @example
   * MX
   */
  type?: string;
  /**
   * @remarks
   * The record value.
   * 
   * @example
   * 1.1.XX.XX
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      domainId: 'DomainId',
      domainName: 'DomainName',
      groupId: 'GroupId',
      groupName: 'GroupName',
      line: 'Line',
      locked: 'Locked',
      priority: 'Priority',
      punyCode: 'PunyCode',
      RR: 'RR',
      recordId: 'RecordId',
      remark: 'Remark',
      requestId: 'RequestId',
      status: 'Status',
      TTL: 'TTL',
      type: 'Type',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainId: 'string',
      domainName: 'string',
      groupId: 'string',
      groupName: 'string',
      line: 'string',
      locked: 'boolean',
      priority: 'number',
      punyCode: 'string',
      RR: 'string',
      recordId: 'string',
      remark: 'string',
      requestId: 'string',
      status: 'string',
      TTL: 'number',
      type: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainRecordInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDomainRecordInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDomainRecordInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainRecordsRequest extends $tea.Model {
  /**
   * @remarks
   * The order in which you want to sort the returned DNS records. Valid values: DESC and ASC. Default value: DESC.
   * 
   * @example
   * DESC
   */
  direction?: string;
  /**
   * @remarks
   * The domain name.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The ID of the domain name group.
   * 
   * *   If you do not specify GroupId, all domain names are queried.
   * *   If you set GroupId to 0, no value is returned.
   * *   If you set GroupId to 1, the domain names in the default group are queried.
   * *   If you set GroupId to -2, all domain names are queried.
   * *   You can also specify GroupId based on the actual group ID.
   * 
   * @example
   * 2223
   */
  groupId?: number;
  /**
   * @remarks
   * The keyword.
   * 
   * @example
   * test
   */
  keyWord?: string;
  /**
   * @remarks
   * The language.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The resolution line. Default value: **default**.
   * 
   * For more information, see
   * 
   * [DNS lines](https://www.alibabacloud.com/help/zh/doc-detail/29807.htm).
   * 
   * @example
   * cn_mobile_anhui
   */
  line?: string;
  /**
   * @remarks
   * The method that is used to sort the returned DNS records. By default, the DNS records are sorted in reverse chronological order based on the time when they were added.
   * 
   * @example
   * default
   */
  orderBy?: string;
  /**
   * @remarks
   * The page number. Pages start from page **1**. Default value: **1**.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Valid values: **1 to 500**. Default value: **20**.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The hostname keyword based on which the system queries DNS records. The system queries DNS records based on the value of this parameter in fuzzy match mode. The value is not case-sensitive.
   * 
   * @example
   * www
   */
  RRKeyWord?: string;
  /**
   * @remarks
   * The search mode. Valid values: **LIKE, EXACT, and ADVANCED**.
   * 
   * *   If you set SearchMode to LIKE or EXACT, specify KeyWord. In this case, RRKeyWord, TypeKeyWord, ValueKeyWord, Type, Line, and Status are invalid.
   * 
   * *   If you set SearchMode to ADVANCED, specify RRKeyWord, TypeKeyWord, ValueKeyWord, Type, Line, and Status.
   * 
   * *   If you do not specify SearchMode, the system determines the search mode based on the following rules:
   * 
   *     *   If KeyWord is specified, the system uses the LIKE mode.
   *     *   If KeyWord is not specified, the system queries DNS records based on values of RRKeyWord and ValueKeyWord in fuzzy match mode, and based on the values of TypeKeyWord, Type, Line, and Status in exact match mode.
   * 
   * @example
   * LIKE
   */
  searchMode?: string;
  /**
   * @remarks
   * The status of the DNS records to query. Valid values: **Enable and Disable**.
   * 
   * @example
   * Enable
   */
  status?: string;
  /**
   * @remarks
   * The type of the DNS records to query. For more information, see
   * 
   * [DNS record types](https://www.alibabacloud.com/help/zh/doc-detail/29805.htm).
   * 
   * @example
   * A
   */
  type?: string;
  /**
   * @remarks
   * The type keyword based on which the system queries DNS records. The system queries DNS records based on the value of this parameter in exact match mode. The value is not case-sensitive.
   * 
   * @example
   * MX
   */
  typeKeyWord?: string;
  /**
   * @remarks
   * The record value keyword based on which the system queries DNS records. The system queries DNS records based on the value of this parameter in fuzzy match mode. The value is not case-sensitive.
   * 
   * @example
   * com
   */
  valueKeyWord?: string;
  static names(): { [key: string]: string } {
    return {
      direction: 'Direction',
      domainName: 'DomainName',
      groupId: 'GroupId',
      keyWord: 'KeyWord',
      lang: 'Lang',
      line: 'Line',
      orderBy: 'OrderBy',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      RRKeyWord: 'RRKeyWord',
      searchMode: 'SearchMode',
      status: 'Status',
      type: 'Type',
      typeKeyWord: 'TypeKeyWord',
      valueKeyWord: 'ValueKeyWord',
    };
  }

  static types(): { [key: string]: any } {
    return {
      direction: 'string',
      domainName: 'string',
      groupId: 'number',
      keyWord: 'string',
      lang: 'string',
      line: 'string',
      orderBy: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      RRKeyWord: 'string',
      searchMode: 'string',
      status: 'string',
      type: 'string',
      typeKeyWord: 'string',
      valueKeyWord: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainRecordsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned Domain Name System (DNS) records.
   */
  domainRecords?: DescribeDomainRecordsResponseBodyDomainRecords;
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 536E9CAD-DB30-4647-AC87-AA5CC38C5382
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 2
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      domainRecords: 'DomainRecords',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainRecords: DescribeDomainRecordsResponseBodyDomainRecords,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainRecordsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDomainRecordsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDomainRecordsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainResolveStatisticsSummaryRequest extends $tea.Model {
  /**
   * @remarks
   * The order in which you want to sort the returned entries. Valid values:
   * 
   * *   DESC: the descending order
   * *   ASC: the ascending order
   * 
   * @example
   * DESC
   */
  direction?: string;
  /**
   * @remarks
   * The end time in the yyyy-MM-dd format, for example, 2023-03-13.
   * 
   * @example
   * 2023-03-01
   */
  endDate?: string;
  /**
   * @remarks
   * The keyword. The Keyword parameter is used together with the SearchMode parameter.
   * 
   * @example
   * test
   */
  keyword?: string;
  /**
   * @remarks
   * The language. Valid values: zh, en, and ja.
   * 
   * @example
   * zh
   */
  lang?: string;
  /**
   * @remarks
   * The number of the page to return. Pages start from page 1. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Valid values: 1 to 1000.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The search mode of the keyword. Valid values:
   * 
   * *   LIKE (default): fuzzy search
   * *   EXACT: exact search
   * 
   * @example
   * EXACT
   */
  searchMode?: string;
  /**
   * @remarks
   * The start time in the yyyy-MM-dd format, for example, 2023-03-01.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-03-01
   */
  startDate?: string;
  /**
   * @remarks
   * The threshold for the number of Domain Name System (DNS) requests. You can query the domain names at the specified quantity level of DNS requests and query the number of DNS requests for each domain name.
   * 
   * If you do not specify this parameter, the data about the domain names that have DNS requests is obtained.
   * 
   * If you set this parameter to a value less than 0, the data about all domain names is obtained.
   * 
   * If you set this parameter to 0, the data about the domain names that do not have DNS requests is obtained.
   * 
   * If you set this parameter to a value greater than 0, the data about the domain names whose number of DNS requests is less than or equal to the value of this parameter is obtained.
   * 
   * @example
   * -1
   */
  threshold?: number;
  static names(): { [key: string]: string } {
    return {
      direction: 'Direction',
      endDate: 'EndDate',
      keyword: 'Keyword',
      lang: 'Lang',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      searchMode: 'SearchMode',
      startDate: 'StartDate',
      threshold: 'Threshold',
    };
  }

  static types(): { [key: string]: any } {
    return {
      direction: 'string',
      endDate: 'string',
      keyword: 'string',
      lang: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      searchMode: 'string',
      startDate: 'string',
      threshold: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainResolveStatisticsSummaryResponseBody extends $tea.Model {
  /**
   * @remarks
   * The page number. Pages start from page **1**. Default value: **1**.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Maximum value: **100**. Default value: **20**.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 6856BCF6-11D6-4D7E-AC53-FD579933522B
   */
  requestId?: string;
  /**
   * @remarks
   * The statistics.
   */
  statistics?: DescribeDomainResolveStatisticsSummaryResponseBodyStatistics[];
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 1
   */
  totalItems?: number;
  /**
   * @remarks
   * The total number of pages returned.
   * 
   * @example
   * 1
   */
  totalPages?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      statistics: 'Statistics',
      totalItems: 'TotalItems',
      totalPages: 'TotalPages',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      statistics: { 'type': 'array', 'itemType': DescribeDomainResolveStatisticsSummaryResponseBodyStatistics },
      totalItems: 'number',
      totalPages: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainResolveStatisticsSummaryResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDomainResolveStatisticsSummaryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDomainResolveStatisticsSummaryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainStatisticsRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The type of the domain name. Valid values:
   * 
   * *   PUBLIC (default): hosted public domain name
   * *   CACHE: cached public domain name
   * 
   * @example
   * PUBLIC CACHE
   */
  domainType?: string;
  /**
   * @remarks
   * The end date of the query. Specify the end date in the **YYYY-MM-DD** format.
   * 
   * The default value is the day when you query the data.
   * 
   * @example
   * 2019-07-04
   */
  endDate?: string;
  /**
   * @remarks
   * The language.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The start date of the query. Specify the start date in the **YYYY-MM-DD** format.
   * 
   * You can only query the DNS records within the last 90 days.``
   * 
   * This parameter is required.
   * 
   * @example
   * 2019-07-04
   */
  startDate?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      domainType: 'DomainType',
      endDate: 'EndDate',
      lang: 'Lang',
      startDate: 'StartDate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      domainType: 'string',
      endDate: 'string',
      lang: 'string',
      startDate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainStatisticsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 6AEC7A64-3CB1-4C49-8B35-0B901F1E26BF
   */
  requestId?: string;
  /**
   * @remarks
   * The statistics on the Domain Name System (DNS) requests.
   */
  statistics?: DescribeDomainStatisticsResponseBodyStatistics;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      statistics: 'Statistics',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      statistics: DescribeDomainStatisticsResponseBodyStatistics,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainStatisticsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDomainStatisticsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDomainStatisticsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainStatisticsSummaryRequest extends $tea.Model {
  /**
   * @remarks
   * The end of the time range to query. Specify the time in the **YYYY-MM-DD** format.
   * 
   * The default value is the day when you perform the operation.
   * 
   * @example
   * 2019-07-04
   */
  endDate?: string;
  /**
   * @remarks
   * The keyword for searches in %KeyWord% mode. The value is not case-sensitive.
   * 
   * @example
   * test
   */
  keyword?: string;
  /**
   * @remarks
   * The language type.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The number of the page to return. Pages start from page **1**. Default value: **1**.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Maximum value: **100**. Minimum value: **1**. Default value: **20**.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The search mode of the keyword. Valid values:
   * 
   * *   **LIKE**: fuzzy match (default).
   * *   **EXACT**: exact match.
   * 
   * @example
   * LIKE
   */
  searchMode?: string;
  /**
   * @remarks
   * The beginning of the time range to query. Specify the time in the **YYYY-MM-DD** format.
   * 
   * You can only query DNS records of the last 90 days.
   * 
   * This parameter is required.
   * 
   * @example
   * 2019-07-04
   */
  startDate?: string;
  /**
   * @remarks
   * The threshold of query volume that can be obtained. You can also obtain data about a domain name with the query volume less than or equal to the threshold. For example, if you set this parameter to 100, you can query domain names with less than 100 queries.
   * 
   * @example
   * 12
   */
  threshold?: number;
  static names(): { [key: string]: string } {
    return {
      endDate: 'EndDate',
      keyword: 'Keyword',
      lang: 'Lang',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      searchMode: 'SearchMode',
      startDate: 'StartDate',
      threshold: 'Threshold',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endDate: 'string',
      keyword: 'string',
      lang: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      searchMode: 'string',
      startDate: 'string',
      threshold: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainStatisticsSummaryResponseBody extends $tea.Model {
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 5
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CC625C21-8832-4683-BF10-C3CFB1A4FA13
   */
  requestId?: string;
  /**
   * @remarks
   * The statistics on the Domain Name System (DNS) requests.
   */
  statistics?: DescribeDomainStatisticsSummaryResponseBodyStatistics;
  /**
   * @remarks
   * The total number of data records.
   * 
   * @example
   * 68
   */
  totalItems?: number;
  /**
   * @remarks
   * The total number of returned pages.
   * 
   * @example
   * 14
   */
  totalPages?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      statistics: 'Statistics',
      totalItems: 'TotalItems',
      totalPages: 'TotalPages',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      statistics: DescribeDomainStatisticsSummaryResponseBodyStatistics,
      totalItems: 'number',
      totalPages: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainStatisticsSummaryResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDomainStatisticsSummaryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDomainStatisticsSummaryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainsRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the domain name group. If you do not specify this parameter, all domain names are queried by default.
   * 
   * @example
   * 2223
   */
  groupId?: string;
  /**
   * @remarks
   * The keyword for searches in "%KeyWord%" mode. The value is not case-sensitive.
   * 
   * @example
   * com
   */
  keyWord?: string;
  /**
   * @remarks
   * The language type.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The number of the page to return. Pages start from page **1**. Default value: **1**.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Maximum value: **100**. Default value: **20**.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the resource group.
   * 
   * @example
   * rg-resourcegroupid01
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The search mode. Valid values:
   * 
   * *   **LIKE**: fuzzy match.
   * *   **EXACT**: exact match.
   * 
   * @example
   * LIKE
   */
  searchMode?: string;
  /**
   * @remarks
   * Specifies whether to query the starmark of the domain name.
   * 
   * @example
   * true
   */
  starmark?: boolean;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      keyWord: 'KeyWord',
      lang: 'Lang',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      resourceGroupId: 'ResourceGroupId',
      searchMode: 'SearchMode',
      starmark: 'Starmark',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      keyWord: 'string',
      lang: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      resourceGroupId: 'string',
      searchMode: 'string',
      starmark: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The domain names.
   */
  domains?: DescribeDomainsResponseBodyDomains;
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 2
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 68386699-8B9E-4D5B-BC4C-75A28F6C2A00
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of domain names.
   * 
   * @example
   * 2
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      domains: 'Domains',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domains: DescribeDomainsResponseBodyDomains,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDomainsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDomainsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmAccessStrategiesRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the GTM instance whose access policies you want to query.
   * 
   * @example
   * instance1
   */
  instanceId?: string;
  /**
   * @remarks
   * The language used by the user.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return per page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      lang: 'Lang',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      lang: 'string',
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmAccessStrategiesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The number of the page returned.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0CCC9971-CEC9-4132-824B-4AE611C07623
   */
  requestId?: string;
  /**
   * @remarks
   * The returned list of access policies of the GTM instance.
   */
  strategies?: DescribeGtmAccessStrategiesResponseBodyStrategies;
  /**
   * @remarks
   * The total number of entries returned on all pages.
   * 
   * @example
   * 1
   */
  totalItems?: number;
  /**
   * @remarks
   * The total number of pages returned.
   * 
   * @example
   * 1
   */
  totalPages?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      strategies: 'Strategies',
      totalItems: 'TotalItems',
      totalPages: 'TotalPages',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      strategies: DescribeGtmAccessStrategiesResponseBodyStrategies,
      totalItems: 'number',
      totalPages: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmAccessStrategiesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeGtmAccessStrategiesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeGtmAccessStrategiesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmAccessStrategyRequest extends $tea.Model {
  /**
   * @remarks
   * The language used by the user.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The ID of the access policy that you want to query.
   * 
   * This parameter is required.
   * 
   * @example
   * hra0hs
   */
  strategyId?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      strategyId: 'StrategyId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      strategyId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmAccessStrategyResponseBody extends $tea.Model {
  /**
   * @remarks
   * The access policy.
   * 
   * @example
   * AUTO
   */
  accessMode?: string;
  /**
   * @remarks
   * The access status. Valid values:
   * 
   * *   **DEFAULT**: Indicates normal when the default address pool is accessed.
   * *   **FAILOVER**: Indicates an exception when a failover address pool is accessed.
   * 
   * @example
   * DEFAULT
   */
  accessStatus?: string;
  /**
   * @remarks
   * Indicates whether health check is enabled for the default address pool.
   * 
   * @example
   * OPEN
   */
  defaultAddrPoolMonitorStatus?: string;
  /**
   * @remarks
   * The name of the default address pool.
   */
  defaultAddrPoolName?: string;
  /**
   * @remarks
   * The availability status of the default address pool.
   * 
   * @example
   * AVAILABLE
   */
  defaultAddrPoolStatus?: string;
  /**
   * @remarks
   * The ID of the default address pool.
   * 
   * @example
   * hra0i1
   */
  defultAddrPoolId?: string;
  /**
   * @remarks
   * The ID of the failover address pool.
   * 
   * @example
   * hra0i2
   */
  failoverAddrPoolId?: string;
  /**
   * @remarks
   * Indicates whether health check is enabled for the failover address pool.
   * 
   * @example
   * OPEN
   */
  failoverAddrPoolMonitorStatus?: string;
  /**
   * @remarks
   * The name of the failover address pool.
   */
  failoverAddrPoolName?: string;
  /**
   * @remarks
   * The availability status of the failover address pool.
   * 
   * @example
   * AVAILABLE
   */
  failoverAddrPoolStatus?: string;
  /**
   * @remarks
   * The ID of the GTM instance whose access policy details you want to query.
   * 
   * @example
   * instance1
   */
  instanceId?: string;
  /**
   * @remarks
   * The returned lines of access regions.
   */
  lines?: DescribeGtmAccessStrategyResponseBodyLines;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * BA1608CA-834C-4E63-8682-8AF0B11ED72D
   */
  requestId?: string;
  /**
   * @remarks
   * The ID of the access policy queried.
   * 
   * @example
   * hra0hs
   */
  strategyId?: string;
  /**
   * @remarks
   * The mode of traffic scheduling.
   * 
   * @example
   * SELF_DEFINED
   */
  strategyMode?: string;
  /**
   * @remarks
   * The name of the access policy queried.
   */
  strategyName?: string;
  static names(): { [key: string]: string } {
    return {
      accessMode: 'AccessMode',
      accessStatus: 'AccessStatus',
      defaultAddrPoolMonitorStatus: 'DefaultAddrPoolMonitorStatus',
      defaultAddrPoolName: 'DefaultAddrPoolName',
      defaultAddrPoolStatus: 'DefaultAddrPoolStatus',
      defultAddrPoolId: 'DefultAddrPoolId',
      failoverAddrPoolId: 'FailoverAddrPoolId',
      failoverAddrPoolMonitorStatus: 'FailoverAddrPoolMonitorStatus',
      failoverAddrPoolName: 'FailoverAddrPoolName',
      failoverAddrPoolStatus: 'FailoverAddrPoolStatus',
      instanceId: 'InstanceId',
      lines: 'Lines',
      requestId: 'RequestId',
      strategyId: 'StrategyId',
      strategyMode: 'StrategyMode',
      strategyName: 'StrategyName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessMode: 'string',
      accessStatus: 'string',
      defaultAddrPoolMonitorStatus: 'string',
      defaultAddrPoolName: 'string',
      defaultAddrPoolStatus: 'string',
      defultAddrPoolId: 'string',
      failoverAddrPoolId: 'string',
      failoverAddrPoolMonitorStatus: 'string',
      failoverAddrPoolName: 'string',
      failoverAddrPoolStatus: 'string',
      instanceId: 'string',
      lines: DescribeGtmAccessStrategyResponseBodyLines,
      requestId: 'string',
      strategyId: 'string',
      strategyMode: 'string',
      strategyName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmAccessStrategyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeGtmAccessStrategyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeGtmAccessStrategyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmAccessStrategyAvailableConfigRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the Global Traffic Manager (GTM) instance.
   * 
   * This parameter is required.
   * 
   * @example
   * gtm-cn-xxxx
   */
  instanceId?: string;
  /**
   * @remarks
   * The language.
   * 
   * @example
   * en
   */
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmAccessStrategyAvailableConfigResponseBody extends $tea.Model {
  /**
   * @remarks
   * The address pools.
   */
  addrPools?: DescribeGtmAccessStrategyAvailableConfigResponseBodyAddrPools;
  /**
   * @remarks
   * The Domain Name System (DNS) request sources.
   */
  lines?: DescribeGtmAccessStrategyAvailableConfigResponseBodyLines;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * C2851BA9-CE56-49AF-8D12-4FC6A49EE688
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the global line is recommended.
   * 
   * @example
   * True
   */
  suggestSetDefaultLine?: boolean;
  static names(): { [key: string]: string } {
    return {
      addrPools: 'AddrPools',
      lines: 'Lines',
      requestId: 'RequestId',
      suggestSetDefaultLine: 'SuggestSetDefaultLine',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addrPools: DescribeGtmAccessStrategyAvailableConfigResponseBodyAddrPools,
      lines: DescribeGtmAccessStrategyAvailableConfigResponseBodyLines,
      requestId: 'string',
      suggestSetDefaultLine: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmAccessStrategyAvailableConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeGtmAccessStrategyAvailableConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeGtmAccessStrategyAvailableConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmAvailableAlertGroupRequest extends $tea.Model {
  /**
   * @remarks
   * The language used by the user.
   * 
   * @example
   * en
   */
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmAvailableAlertGroupResponseBody extends $tea.Model {
  /**
   * @remarks
   * The available alert groups of the GTM instance.
   */
  availableAlertGroup?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 29D0F8F8-5499-4F6C-9FDC-1EE13BF55925
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      availableAlertGroup: 'AvailableAlertGroup',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      availableAlertGroup: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmAvailableAlertGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeGtmAvailableAlertGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeGtmAvailableAlertGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmInstanceRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the GTM instance.
   * 
   * This parameter is required.
   * 
   * @example
   * instance1
   */
  instanceId?: string;
  /**
   * @remarks
   * The language of the values of specific response parameters.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * Specifies whether additional information is required. Default value: **false**. If the value is **true**, the AccessStrategyNum and AddressPoolNum parameters are returned.
   * 
   * @example
   * false
   */
  needDetailAttributes?: boolean;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      lang: 'Lang',
      needDetailAttributes: 'NeedDetailAttributes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      lang: 'string',
      needDetailAttributes: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmInstanceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The number of access policies of the GTM instance.
   * 
   * @example
   * 5
   */
  accessStrategyNum?: number;
  /**
   * @remarks
   * The number of address pools of the GTM instance.
   * 
   * @example
   * 5
   */
  addressPoolNum?: number;
  /**
   * @remarks
   * The alert group of the GTM instance.
   * 
   * @example
   * [\\\\"Daily test - R\\&D group\\\\"]
   */
  alertGroup?: string;
  /**
   * @remarks
   * The domain name of the GTM instance to which the service domain name is mapped by using a CNAME record.
   * 
   * @example
   * instance1.14.com
   */
  cname?: string;
  /**
   * @remarks
   * Indicates whether the CNAME is a custom domain name or is assigned by the system. Valid values:
   * 
   * *   **SYSTEM_ASSIGN**
   * *   **CUSTOM**
   * 
   * @example
   * SYSTEM_ASSIGN
   */
  cnameMode?: string;
  /**
   * @remarks
   * The time when the GTM instance was created.
   * 
   * @example
   * 2018-06-06T11:34Z
   */
  createTime?: string;
  /**
   * @remarks
   * The timestamp that indicates the time when the GTM instance was created.
   * 
   * @example
   * 1528284856000
   */
  createTimestamp?: number;
  /**
   * @remarks
   * The time when the GTM instance expires.
   * 
   * @example
   * 2018-06-06T11:34Z
   */
  expireTime?: string;
  /**
   * @remarks
   * The timestamp that indicates the time when the GTM instance expires.
   * 
   * @example
   * 1528284856000
   */
  expireTimestamp?: number;
  /**
   * @remarks
   * The ID of the GTM instance.
   * 
   * @example
   * instance1
   */
  instanceId?: string;
  /**
   * @remarks
   * The name of the GTM instance.
   * 
   * @example
   * test
   */
  instanceName?: string;
  /**
   * @remarks
   * The load balancing policy. Valid values:
   * 
   * *   **ALL_RR**: round robin
   * *   **RATIO**: weighted round-robin
   * 
   * @example
   * RATIO
   */
  lbaStrategy?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * E41AA251-F9BA-48C6-99B2-2B82B26A573A
   */
  requestId?: string;
  /**
   * @remarks
   * The ID of the resource group.
   * 
   * @example
   * rg-testgroupid
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The global time to live (TTL).
   * 
   * @example
   * 60
   */
  ttl?: number;
  /**
   * @remarks
   * The domain name of the application.
   * 
   * @example
   * www.example.com
   */
  userDomainName?: string;
  /**
   * @remarks
   * The version code.
   * 
   * @example
   * biaozhun
   */
  versionCode?: string;
  static names(): { [key: string]: string } {
    return {
      accessStrategyNum: 'AccessStrategyNum',
      addressPoolNum: 'AddressPoolNum',
      alertGroup: 'AlertGroup',
      cname: 'Cname',
      cnameMode: 'CnameMode',
      createTime: 'CreateTime',
      createTimestamp: 'CreateTimestamp',
      expireTime: 'ExpireTime',
      expireTimestamp: 'ExpireTimestamp',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      lbaStrategy: 'LbaStrategy',
      requestId: 'RequestId',
      resourceGroupId: 'ResourceGroupId',
      ttl: 'Ttl',
      userDomainName: 'UserDomainName',
      versionCode: 'VersionCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessStrategyNum: 'number',
      addressPoolNum: 'number',
      alertGroup: 'string',
      cname: 'string',
      cnameMode: 'string',
      createTime: 'string',
      createTimestamp: 'number',
      expireTime: 'string',
      expireTimestamp: 'number',
      instanceId: 'string',
      instanceName: 'string',
      lbaStrategy: 'string',
      requestId: 'string',
      resourceGroupId: 'string',
      ttl: 'number',
      userDomainName: 'string',
      versionCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmInstanceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeGtmInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeGtmInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmInstanceAddressPoolRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the address pool that you want to query.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  addrPoolId?: string;
  /**
   * @remarks
   * The language used by the user.
   * 
   * @example
   * en
   */
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      addrPoolId: 'AddrPoolId',
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addrPoolId: 'string',
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmInstanceAddressPoolResponseBody extends $tea.Model {
  /**
   * @remarks
   * The number of addresses in the address pool queried.
   * 
   * @example
   * 2
   */
  addrCount?: number;
  /**
   * @remarks
   * The ID of the address pool.
   * 
   * @example
   * 1234abc
   */
  addrPoolId?: string;
  /**
   * @remarks
   * The addresses in the address pool.
   */
  addrs?: DescribeGtmInstanceAddressPoolResponseBodyAddrs;
  /**
   * @remarks
   * The time when the address pool was created.
   * 
   * @example
   * 2017-12-28T13:08Z
   */
  createTime?: string;
  /**
   * @example
   * 1527690629357
   */
  createTimestamp?: number;
  /**
   * @remarks
   * The minimum number of available addresses in the address pool.
   * 
   * @example
   * 2
   */
  minAvailableAddrNum?: number;
  /**
   * @remarks
   * The health check ID of the address pool.
   * 
   * @example
   * 100abc
   */
  monitorConfigId?: string;
  /**
   * @remarks
   * Indicates whether health check was enabled for the address pool. Valid values:
   * 
   * *   **OPEN**: Enabled
   * *   **CLOSE**: Disabled
   * *   **UNCONFIGURED**: Not configured
   * 
   * @example
   * OPEN
   */
  monitorStatus?: string;
  /**
   * @remarks
   * The name of the address pool.
   */
  name?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 6856BCF6-11D6-4D7E-AC53-FD579933522B
   */
  requestId?: string;
  /**
   * @remarks
   * The availability status of the address pool. Valid values:
   * 
   * *   **AVAILABLE**: Available
   * *   **NOT_AVAILABLE**: Unavailable
   * 
   * @example
   * AVAILABLE
   */
  status?: string;
  /**
   * @remarks
   * The type of the address pool. Valid values:
   * 
   * *   **IP**: IP address
   * *   **DOMAIN**: Domain name
   * 
   * @example
   * IP
   */
  type?: string;
  /**
   * @remarks
   * The last time when the address pool was updated.
   * 
   * @example
   * 2017-12-28T13:08Z
   */
  updateTime?: string;
  /**
   * @remarks
   * A timestamp that indicates the last time the address pool was updated.
   * 
   * @example
   * 1527690629357
   */
  updateTimestamp?: number;
  static names(): { [key: string]: string } {
    return {
      addrCount: 'AddrCount',
      addrPoolId: 'AddrPoolId',
      addrs: 'Addrs',
      createTime: 'CreateTime',
      createTimestamp: 'CreateTimestamp',
      minAvailableAddrNum: 'MinAvailableAddrNum',
      monitorConfigId: 'MonitorConfigId',
      monitorStatus: 'MonitorStatus',
      name: 'Name',
      requestId: 'RequestId',
      status: 'Status',
      type: 'Type',
      updateTime: 'UpdateTime',
      updateTimestamp: 'UpdateTimestamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addrCount: 'number',
      addrPoolId: 'string',
      addrs: DescribeGtmInstanceAddressPoolResponseBodyAddrs,
      createTime: 'string',
      createTimestamp: 'number',
      minAvailableAddrNum: 'number',
      monitorConfigId: 'string',
      monitorStatus: 'string',
      name: 'string',
      requestId: 'string',
      status: 'string',
      type: 'string',
      updateTime: 'string',
      updateTimestamp: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmInstanceAddressPoolResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeGtmInstanceAddressPoolResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeGtmInstanceAddressPoolResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmInstanceAddressPoolsRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the GTM instance that you want to query.
   * 
   * This parameter is required.
   * 
   * @example
   * gtmtest
   */
  instanceId?: string;
  /**
   * @remarks
   * The language used by the user.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The number of the page to return. Pages start from page **1**. Default value: **1**.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return per page. Maximum value: **100**. Default value: **20**.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      lang: 'Lang',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      lang: 'string',
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmInstanceAddressPoolsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned list of address pools of the GTM instance.
   */
  addrPools?: DescribeGtmInstanceAddressPoolsResponseBodyAddrPools;
  /**
   * @remarks
   * The number of the page returned.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 6856BCF6-11D6-4D7E-AC53-FD579933522B
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries returned on all pages.
   * 
   * @example
   * 2
   */
  totalItems?: number;
  /**
   * @remarks
   * The total number of pages returned.
   * 
   * @example
   * 1
   */
  totalPages?: number;
  static names(): { [key: string]: string } {
    return {
      addrPools: 'AddrPools',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalItems: 'TotalItems',
      totalPages: 'TotalPages',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addrPools: DescribeGtmInstanceAddressPoolsResponseBodyAddrPools,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalItems: 'number',
      totalPages: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmInstanceAddressPoolsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeGtmInstanceAddressPoolsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeGtmInstanceAddressPoolsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmInstanceStatusRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the instance to query.
   * 
   * This parameter is required.
   * 
   * @example
   * instance1
   */
  instanceId?: string;
  /**
   * @remarks
   * The language in which you want the values of some response parameters to be returned. These response parameters support multiple languages.
   * 
   * @example
   * en
   */
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmInstanceStatusResponseBody extends $tea.Model {
  /**
   * @remarks
   * The number of unavailable addresses.
   * 
   * @example
   * 10
   */
  addrNotAvailableNum?: number;
  /**
   * @remarks
   * The number of unavailable address pools.
   * 
   * @example
   * 10
   */
  addrPoolNotAvailableNum?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 389DFFA3-77A5-4A9E-BF3D-147C6F98A5BA
   */
  requestId?: string;
  /**
   * @remarks
   * The status of the instance. Valid values:
   * 
   * *   ALLOW: Operations on the instance are allowed.
   * *   DENY: Operations on the instance are not allowed.
   * 
   * @example
   * ALLOW
   */
  status?: string;
  /**
   * @remarks
   * List of reasons for an instance status. Valid values:
   * 
   * *   INSTANCE_OPERATE_BLACK_LIST: The instance is in the blacklist.
   * *   BETA_INSTANCE: The instance is in public preview.
   * 
   * @example
   * ["BETA_INSTANCE"]
   */
  statusReason?: string;
  /**
   * @remarks
   * The number of access policies that are unavailable in the active address pool.
   * 
   * @example
   * 10
   */
  strategyNotAvailableNum?: number;
  /**
   * @remarks
   * The number of access policies that fail over to the secondary address pool.
   * 
   * @example
   * 10
   */
  switchToFailoverStrategyNum?: number;
  static names(): { [key: string]: string } {
    return {
      addrNotAvailableNum: 'AddrNotAvailableNum',
      addrPoolNotAvailableNum: 'AddrPoolNotAvailableNum',
      requestId: 'RequestId',
      status: 'Status',
      statusReason: 'StatusReason',
      strategyNotAvailableNum: 'StrategyNotAvailableNum',
      switchToFailoverStrategyNum: 'SwitchToFailoverStrategyNum',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addrNotAvailableNum: 'number',
      addrPoolNotAvailableNum: 'number',
      requestId: 'string',
      status: 'string',
      statusReason: 'string',
      strategyNotAvailableNum: 'number',
      switchToFailoverStrategyNum: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmInstanceStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeGtmInstanceStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeGtmInstanceStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmInstanceSystemCnameRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the Global Traffic Manager (GTM) instance.
   * 
   * This parameter is required.
   * 
   * @example
   * instance1
   */
  instanceId?: string;
  /**
   * @remarks
   * The language used by the user.
   * 
   * @example
   * en
   */
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmInstanceSystemCnameResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 6856BCF6-11D6-4D7E-AC53-FD579933522B
   */
  requestId?: string;
  /**
   * @remarks
   * The CNAME record assigned by the system.
   * 
   * @example
   * gtm-cn-mp91004xxxx.gtm-a2b4.com
   */
  systemCname?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      systemCname: 'SystemCname',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      systemCname: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmInstanceSystemCnameResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeGtmInstanceSystemCnameResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeGtmInstanceSystemCnameResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmInstancesRequest extends $tea.Model {
  /**
   * @remarks
   * The keyword that you use for query. Exact match is supported by instance ID or instance name.
   * 
   * @example
   * test
   */
  keyword?: string;
  /**
   * @remarks
   * The language in which you want the values of some response parameters to be returned. These response parameters support multiple languages.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * Specifies whether additional information is required. Default value: **false**.
   * 
   * @example
   * false
   */
  needDetailAttributes?: boolean;
  /**
   * @remarks
   * The page number to return.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return per page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the resource group.
   * 
   * @example
   * rg-xxxxx
   */
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      keyword: 'Keyword',
      lang: 'Lang',
      needDetailAttributes: 'NeedDetailAttributes',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      keyword: 'string',
      lang: 'string',
      needDetailAttributes: 'boolean',
      pageNumber: 'number',
      pageSize: 'number',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmInstancesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The list of queried instances.
   */
  gtmInstances?: DescribeGtmInstancesResponseBodyGtmInstances;
  /**
   * @remarks
   * The returned page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 193B0163-7F93-42DF-AB05-ACEEB7D22707
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 1
   */
  totalItems?: number;
  /**
   * @remarks
   * The total number of pages returned.
   * 
   * @example
   * 1
   */
  totalPages?: number;
  static names(): { [key: string]: string } {
    return {
      gtmInstances: 'GtmInstances',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalItems: 'TotalItems',
      totalPages: 'TotalPages',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gtmInstances: DescribeGtmInstancesResponseBodyGtmInstances,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalItems: 'number',
      totalPages: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmInstancesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeGtmInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeGtmInstancesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmLogsRequest extends $tea.Model {
  /**
   * @remarks
   * The timestamp that specifies the end of the time range to query.
   * 
   * @example
   * 1363453350000
   */
  endTimestamp?: number;
  /**
   * @remarks
   * The ID of the GTM instance whose logs you want to query.
   * 
   * @example
   * gtm-cn-xxxxx
   */
  instanceId?: string;
  /**
   * @remarks
   * The keyword for searching logs, in case-insensitive "%Keyword%" format.
   * 
   * @example
   * test
   */
  keyword?: string;
  /**
   * @remarks
   * The language used by the user.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The number of the page to return. Pages start from page **1**. Default value: **1**.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Maximum value: **100**. Default value: **20**.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The beginning of the time range to query.
   * 
   * @example
   * 1363453340000
   */
  startTimestamp?: number;
  static names(): { [key: string]: string } {
    return {
      endTimestamp: 'EndTimestamp',
      instanceId: 'InstanceId',
      keyword: 'Keyword',
      lang: 'Lang',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      startTimestamp: 'StartTimestamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTimestamp: 'number',
      instanceId: 'string',
      keyword: 'string',
      lang: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      startTimestamp: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmLogsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The list of logs returned.
   */
  logs?: DescribeGtmLogsResponseBodyLogs;
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 50C60A29-2E93-425A-ABA8-068686E28873
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries returned on all pages.
   * 
   * @example
   * 224
   */
  totalItems?: number;
  /**
   * @remarks
   * The total number of pages returned.
   * 
   * @example
   * 224
   */
  totalPages?: number;
  static names(): { [key: string]: string } {
    return {
      logs: 'Logs',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalItems: 'TotalItems',
      totalPages: 'TotalPages',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logs: DescribeGtmLogsResponseBodyLogs,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalItems: 'number',
      totalPages: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmLogsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeGtmLogsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeGtmLogsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmMonitorAvailableConfigRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the values of specific response parameters.
   * 
   * @example
   * en
   */
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmMonitorAvailableConfigResponseBody extends $tea.Model {
  /**
   * @remarks
   * The monitored nodes.
   */
  ispCityNodes?: DescribeGtmMonitorAvailableConfigResponseBodyIspCityNodes;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 6856BCF6-11D6-4D7E-AC53-FD579933522B
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      ispCityNodes: 'IspCityNodes',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ispCityNodes: DescribeGtmMonitorAvailableConfigResponseBodyIspCityNodes,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmMonitorAvailableConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeGtmMonitorAvailableConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeGtmMonitorAvailableConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmMonitorConfigRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the values of specific response parameters.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The ID of the health check configuration.
   * 
   * This parameter is required.
   * 
   * @example
   * 100
   */
  monitorConfigId?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      monitorConfigId: 'MonitorConfigId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      monitorConfigId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmMonitorConfigResponseBody extends $tea.Model {
  /**
   * @remarks
   * The time when the health check configuration was created.
   * 
   * @example
   * 2017-12-28T13:08Z
   */
  createTime?: string;
  /**
   * @remarks
   * The timestamp that indicates the time when the health check configuration was created.
   * 
   * @example
   * 1527690629357
   */
  createTimestamp?: number;
  /**
   * @remarks
   * The maximum number of consecutive exceptions detected. If the number of consecutive exceptions detected reaches the maximum number, the application service is deemed abnormal.
   * 
   * @example
   * 3
   */
  evaluationCount?: number;
  /**
   * @remarks
   * The health check interval. Unit: seconds. The value is 60.
   * 
   * @example
   * 60
   */
  interval?: number;
  /**
   * @remarks
   * The monitored nodes.
   */
  ispCityNodes?: DescribeGtmMonitorConfigResponseBodyIspCityNodes;
  /**
   * @remarks
   * The ID of the health check configuration.
   * 
   * @example
   * 1234abc
   */
  monitorConfigId?: string;
  /**
   * @remarks
   * The extended information, that is, the parameters required for the protocol. Different protocols require different parameters:
   * 
   * HTTP or HTTPS:
   * 
   * *   port: the port to check.
   * *   failureRate: the failure rate.
   * *   code: the status code threshold. If the returned status code is greater than the specified threshold, the application service is deemed abnormal. Valid values: 400 and 500.
   * *   host: the host configuration.
   * *   path: the health check URL.
   * 
   * PING:
   * 
   * *   packetNum: the number of ping packets.
   * *   packetLossRate: the loss rate of ping packets.
   * *   failureRate: the failure rate.
   * 
   * TCP:
   * 
   * *   port: the port to check.
   * *   failureRate: the failure rate.
   * 
   * @example
   * {\\"code\\":200,\\"path\\":\\"\\\\index.htm\\",\\"host\\":\\"aliyun.com\\"}
   */
  monitorExtendInfo?: string;
  /**
   * @remarks
   * The protocol used for the health check.
   * 
   * @example
   * HTTP
   */
  protocolType?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 6856BCF6-11D6-4D7E-AC53-FD579933522B
   */
  requestId?: string;
  /**
   * @remarks
   * The health check timeout period. Unit: milliseconds. Valid values: 2000, 3000, 5000, and 10000.
   * 
   * @example
   * 3000
   */
  timeout?: number;
  /**
   * @remarks
   * The time when the health check configuration was last updated.
   * 
   * @example
   * 2017-12-28T13:08Z
   */
  updateTime?: string;
  /**
   * @remarks
   * The timestamp that indicates the time when the health check configuration was last updated.
   * 
   * @example
   * 1527690629357
   */
  updateTimestamp?: number;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      createTimestamp: 'CreateTimestamp',
      evaluationCount: 'EvaluationCount',
      interval: 'Interval',
      ispCityNodes: 'IspCityNodes',
      monitorConfigId: 'MonitorConfigId',
      monitorExtendInfo: 'MonitorExtendInfo',
      protocolType: 'ProtocolType',
      requestId: 'RequestId',
      timeout: 'Timeout',
      updateTime: 'UpdateTime',
      updateTimestamp: 'UpdateTimestamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'string',
      createTimestamp: 'number',
      evaluationCount: 'number',
      interval: 'number',
      ispCityNodes: DescribeGtmMonitorConfigResponseBodyIspCityNodes,
      monitorConfigId: 'string',
      monitorExtendInfo: 'string',
      protocolType: 'string',
      requestId: 'string',
      timeout: 'number',
      updateTime: 'string',
      updateTimestamp: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmMonitorConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeGtmMonitorConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeGtmMonitorConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmRecoveryPlanRequest extends $tea.Model {
  /**
   * @remarks
   * The language used by the user.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The ID of the disaster recovery plan that you want to query.
   * 
   * This parameter is required.
   * 
   * @example
   * 100
   */
  recoveryPlanId?: number;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      recoveryPlanId: 'RecoveryPlanId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      recoveryPlanId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmRecoveryPlanResponseBody extends $tea.Model {
  /**
   * @remarks
   * The time when the disaster recovery plan was created.
   * 
   * @example
   * 2019-08-11T05:04Z
   */
  createTime?: string;
  /**
   * @example
   * 1565499867000
   */
  createTimestamp?: number;
  /**
   * @remarks
   * The number of faulty address pools.
   * 
   * @example
   * 2
   */
  faultAddrPoolNum?: number;
  /**
   * @remarks
   * The list of faulty address pools.
   */
  faultAddrPools?: DescribeGtmRecoveryPlanResponseBodyFaultAddrPools;
  /**
   * @remarks
   * The last time when the recovery plan was executed.
   * 
   * @example
   * 2019-08-11T05:04Z
   */
  lastExecuteTime?: string;
  /**
   * @remarks
   * A timestamp that indicates the last time when the recovery plan was executed.
   * 
   * @example
   * 1565505898000
   */
  lastExecuteTimestamp?: number;
  /**
   * @remarks
   * The last time when the disaster recovery plan was rolled back.
   * 
   * @example
   * 2019-08-11T06:45Z
   */
  lastRollbackTime?: string;
  /**
   * @remarks
   * A timestamp that indicates the last time when the disaster recovery plan was rolled back.
   * 
   * @example
   * 1565505919000
   */
  lastRollbackTimestamp?: number;
  /**
   * @remarks
   * The name of the disaster recovery plan queried.
   * 
   * @example
   * name-example
   */
  name?: string;
  /**
   * @remarks
   * The ID of the disaster recovery plan queried.
   * 
   * @example
   * 55
   */
  recoveryPlanId?: number;
  /**
   * @remarks
   * The remarks on the disaster recovery plan.
   * 
   * @example
   * remark-example
   */
  remark?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0A5F4315-D6E8-435E-82DF-24F4C97D6999
   */
  requestId?: string;
  /**
   * @remarks
   * The status of the disaster recovery plan queried.
   * 
   * @example
   * UNEXECUTED
   */
  status?: string;
  /**
   * @remarks
   * The last time when the disaster recovery plan was updated.
   * 
   * @example
   * 2019-08-11T06:45Z
   */
  updateTime?: string;
  /**
   * @remarks
   * A timestamp that indicates the last time when the disaster recovery plan was updated.
   * 
   * @example
   * 1565499867000
   */
  updateTimestamp?: number;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      createTimestamp: 'CreateTimestamp',
      faultAddrPoolNum: 'FaultAddrPoolNum',
      faultAddrPools: 'FaultAddrPools',
      lastExecuteTime: 'LastExecuteTime',
      lastExecuteTimestamp: 'LastExecuteTimestamp',
      lastRollbackTime: 'LastRollbackTime',
      lastRollbackTimestamp: 'LastRollbackTimestamp',
      name: 'Name',
      recoveryPlanId: 'RecoveryPlanId',
      remark: 'Remark',
      requestId: 'RequestId',
      status: 'Status',
      updateTime: 'UpdateTime',
      updateTimestamp: 'UpdateTimestamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'string',
      createTimestamp: 'number',
      faultAddrPoolNum: 'number',
      faultAddrPools: DescribeGtmRecoveryPlanResponseBodyFaultAddrPools,
      lastExecuteTime: 'string',
      lastExecuteTimestamp: 'number',
      lastRollbackTime: 'string',
      lastRollbackTimestamp: 'number',
      name: 'string',
      recoveryPlanId: 'number',
      remark: 'string',
      requestId: 'string',
      status: 'string',
      updateTime: 'string',
      updateTimestamp: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmRecoveryPlanResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeGtmRecoveryPlanResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeGtmRecoveryPlanResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmRecoveryPlanAvailableConfigRequest extends $tea.Model {
  /**
   * @remarks
   * The language used by the user.
   * 
   * @example
   * en
   */
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmRecoveryPlanAvailableConfigResponseBody extends $tea.Model {
  /**
   * @remarks
   * The list of GTM instances involved in the disaster recovery plan.
   */
  instances?: DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstances;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * F8F8EF50-8B7F-4702-B294-97170A423403
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      instances: 'Instances',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instances: DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstances,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmRecoveryPlanAvailableConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeGtmRecoveryPlanAvailableConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeGtmRecoveryPlanAvailableConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmRecoveryPlansRequest extends $tea.Model {
  /**
   * @remarks
   * The keyword for the query. Fuzzy match is supported by disaster recovery plan name.
   * 
   * @example
   * test
   */
  keyword?: string;
  /**
   * @remarks
   * The language in which you want the values of some response parameters to be returned. These response parameters support multiple languages.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The page number to return. The page number starts from **1**. Default value: **1**.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return per page. Maximum value: **100**. Default value: **20**.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      keyword: 'Keyword',
      lang: 'Lang',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      keyword: 'string',
      lang: 'string',
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmRecoveryPlansResponseBody extends $tea.Model {
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The details about the queried disaster recovery plans.
   */
  recoveryPlans?: DescribeGtmRecoveryPlansResponseBodyRecoveryPlans;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 2BA072CF-CA21-4A34-B6C2-227BE2C58079
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 10
   */
  totalItems?: number;
  /**
   * @remarks
   * The total number of pages returned.
   * 
   * @example
   * 1
   */
  totalPages?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      recoveryPlans: 'RecoveryPlans',
      requestId: 'RequestId',
      totalItems: 'TotalItems',
      totalPages: 'TotalPages',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      recoveryPlans: DescribeGtmRecoveryPlansResponseBodyRecoveryPlans,
      requestId: 'string',
      totalItems: 'number',
      totalPages: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmRecoveryPlansResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeGtmRecoveryPlansResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeGtmRecoveryPlansResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceDomainsRequest extends $tea.Model {
  /**
   * @remarks
   * The instance ID.
   * 
   * This parameter is required.
   * 
   * @example
   * weriwieru
   */
  instanceId?: string;
  /**
   * @remarks
   * The language.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The number of the page to return. Pages start from page 1. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Valid values: 1 to 100. Default value: 20.
   * 
   * @example
   * 2
   */
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      lang: 'Lang',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      lang: 'string',
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceDomainsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The domain names that are bound to the Alibaba Cloud DNS instance.
   */
  instanceDomains?: DescribeInstanceDomainsResponseBodyInstanceDomains[];
  /**
   * @remarks
   * The page number. Pages start from page **1**. Default value: **1**.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Valid values: **1 to 100**. Default value: **20**.
   * 
   * @example
   * 2
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 68386699-8B9E-4D5B-BC4C-75A28F6C2A00
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries returned on all pages.
   * 
   * @example
   * 2
   */
  totalItems?: number;
  /**
   * @remarks
   * The total number of pages returned.
   * 
   * @example
   * 2
   */
  totalPages?: number;
  static names(): { [key: string]: string } {
    return {
      instanceDomains: 'InstanceDomains',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalItems: 'TotalItems',
      totalPages: 'TotalPages',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceDomains: { 'type': 'array', 'itemType': DescribeInstanceDomainsResponseBodyInstanceDomains },
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalItems: 'number',
      totalPages: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceDomainsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeInstanceDomainsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeInstanceDomainsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInternetDnsLogsRequest extends $tea.Model {
  accountId?: number;
  /**
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @example
   * 1709196299999
   */
  endTimestamp?: number;
  /**
   * @example
   * en
   */
  lang?: string;
  /**
   * @example
   * AUTHORITY
   */
  module?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * {"sourceIp":"59.82.XX.XX","queryType":"A"}
   */
  queryCondition?: string;
  /**
   * @example
   * 1709192640000
   */
  startTimestamp?: number;
  static names(): { [key: string]: string } {
    return {
      accountId: 'AccountId',
      domainName: 'DomainName',
      endTimestamp: 'EndTimestamp',
      lang: 'Lang',
      module: 'Module',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      queryCondition: 'QueryCondition',
      startTimestamp: 'StartTimestamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'number',
      domainName: 'string',
      endTimestamp: 'number',
      lang: 'string',
      module: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      queryCondition: 'string',
      startTimestamp: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInternetDnsLogsResponseBody extends $tea.Model {
  /**
   * @example
   * true
   */
  complete?: boolean;
  /**
   * @example
   * 1
   */
  curPage?: number;
  logs?: DescribeInternetDnsLogsResponseBodyLogs;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * 536E9CAD-DB30-4647-AC87-AA5CC38C5382
   */
  requestId?: string;
  /**
   * @example
   * 5
   */
  totalPage?: number;
  /**
   * @example
   * 48
   */
  totalSize?: number;
  static names(): { [key: string]: string } {
    return {
      complete: 'Complete',
      curPage: 'CurPage',
      logs: 'Logs',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalPage: 'TotalPage',
      totalSize: 'TotalSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      complete: 'boolean',
      curPage: 'number',
      logs: DescribeInternetDnsLogsResponseBodyLogs,
      pageSize: 'number',
      requestId: 'string',
      totalPage: 'number',
      totalSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInternetDnsLogsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeInternetDnsLogsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeInternetDnsLogsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeIspFlushCacheInstancesRequest extends $tea.Model {
  direction?: string;
  isp?: string;
  keyword?: string;
  lang?: string;
  orderBy?: string;
  pageNumber?: number;
  pageSize?: number;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      direction: 'Direction',
      isp: 'Isp',
      keyword: 'Keyword',
      lang: 'Lang',
      orderBy: 'OrderBy',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      direction: 'string',
      isp: 'string',
      keyword: 'string',
      lang: 'string',
      orderBy: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeIspFlushCacheInstancesResponseBody extends $tea.Model {
  ispFlushCacheInstances?: DescribeIspFlushCacheInstancesResponseBodyIspFlushCacheInstances[];
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  totalItems?: number;
  totalPages?: number;
  static names(): { [key: string]: string } {
    return {
      ispFlushCacheInstances: 'IspFlushCacheInstances',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalItems: 'TotalItems',
      totalPages: 'TotalPages',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ispFlushCacheInstances: { 'type': 'array', 'itemType': DescribeIspFlushCacheInstancesResponseBodyIspFlushCacheInstances },
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalItems: 'number',
      totalPages: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeIspFlushCacheInstancesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeIspFlushCacheInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeIspFlushCacheInstancesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeIspFlushCacheRemainQuotaRequest extends $tea.Model {
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeIspFlushCacheRemainQuotaResponseBody extends $tea.Model {
  requestId?: string;
  telecomRemainQuota?: number;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      telecomRemainQuota: 'TelecomRemainQuota',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      telecomRemainQuota: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeIspFlushCacheRemainQuotaResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeIspFlushCacheRemainQuotaResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeIspFlushCacheRemainQuotaResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeIspFlushCacheTaskRequest extends $tea.Model {
  lang?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  taskId?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      taskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeIspFlushCacheTaskResponseBody extends $tea.Model {
  createTime?: string;
  createTimestamp?: number;
  domainName?: string;
  flushCacheResults?: DescribeIspFlushCacheTaskResponseBodyFlushCacheResults[];
  instanceId?: string;
  instanceName?: string;
  isp?: string;
  requestId?: string;
  taskId?: string;
  taskStatus?: string;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      createTimestamp: 'CreateTimestamp',
      domainName: 'DomainName',
      flushCacheResults: 'FlushCacheResults',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      isp: 'Isp',
      requestId: 'RequestId',
      taskId: 'TaskId',
      taskStatus: 'TaskStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'string',
      createTimestamp: 'number',
      domainName: 'string',
      flushCacheResults: { 'type': 'array', 'itemType': DescribeIspFlushCacheTaskResponseBodyFlushCacheResults },
      instanceId: 'string',
      instanceName: 'string',
      isp: 'string',
      requestId: 'string',
      taskId: 'string',
      taskStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeIspFlushCacheTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeIspFlushCacheTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeIspFlushCacheTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeIspFlushCacheTasksRequest extends $tea.Model {
  direction?: string;
  domainName?: string;
  instanceId?: string;
  isp?: string;
  lang?: string;
  orderBy?: string;
  pageNumber?: number;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      direction: 'Direction',
      domainName: 'DomainName',
      instanceId: 'InstanceId',
      isp: 'Isp',
      lang: 'Lang',
      orderBy: 'OrderBy',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      direction: 'string',
      domainName: 'string',
      instanceId: 'string',
      isp: 'string',
      lang: 'string',
      orderBy: 'string',
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeIspFlushCacheTasksResponseBody extends $tea.Model {
  ispFlushCacheTasks?: DescribeIspFlushCacheTasksResponseBodyIspFlushCacheTasks[];
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  totalItems?: number;
  totalPages?: number;
  static names(): { [key: string]: string } {
    return {
      ispFlushCacheTasks: 'IspFlushCacheTasks',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalItems: 'TotalItems',
      totalPages: 'TotalPages',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ispFlushCacheTasks: { 'type': 'array', 'itemType': DescribeIspFlushCacheTasksResponseBodyIspFlushCacheTasks },
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalItems: 'number',
      totalPages: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeIspFlushCacheTasksResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeIspFlushCacheTasksResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeIspFlushCacheTasksResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePdnsAccountSummaryRequest extends $tea.Model {
  endDate?: string;
  lang?: string;
  startDate?: string;
  static names(): { [key: string]: string } {
    return {
      endDate: 'EndDate',
      lang: 'Lang',
      startDate: 'StartDate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endDate: 'string',
      lang: 'string',
      startDate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePdnsAccountSummaryResponseBody extends $tea.Model {
  data?: DescribePdnsAccountSummaryResponseBodyData;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: DescribePdnsAccountSummaryResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePdnsAccountSummaryResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribePdnsAccountSummaryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribePdnsAccountSummaryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePdnsAppKeyRequest extends $tea.Model {
  appKeyId?: string;
  authCode?: string;
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      appKeyId: 'AppKeyId',
      authCode: 'AuthCode',
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appKeyId: 'string',
      authCode: 'string',
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePdnsAppKeyResponseBody extends $tea.Model {
  appKey?: DescribePdnsAppKeyResponseBodyAppKey;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      appKey: 'AppKey',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appKey: DescribePdnsAppKeyResponseBodyAppKey,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePdnsAppKeyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribePdnsAppKeyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribePdnsAppKeyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePdnsAppKeysRequest extends $tea.Model {
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePdnsAppKeysResponseBody extends $tea.Model {
  appKeys?: DescribePdnsAppKeysResponseBodyAppKeys[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      appKeys: 'AppKeys',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appKeys: { 'type': 'array', 'itemType': DescribePdnsAppKeysResponseBodyAppKeys },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePdnsAppKeysResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribePdnsAppKeysResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribePdnsAppKeysResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePdnsOperateLogsRequest extends $tea.Model {
  actionType?: string;
  endDate?: string;
  keyword?: string;
  lang?: string;
  pageNumber?: number;
  pageSize?: number;
  startDate?: string;
  static names(): { [key: string]: string } {
    return {
      actionType: 'ActionType',
      endDate: 'EndDate',
      keyword: 'Keyword',
      lang: 'Lang',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      startDate: 'StartDate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actionType: 'string',
      endDate: 'string',
      keyword: 'string',
      lang: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      startDate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePdnsOperateLogsResponseBody extends $tea.Model {
  logs?: DescribePdnsOperateLogsResponseBodyLogs[];
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      logs: 'Logs',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logs: { 'type': 'array', 'itemType': DescribePdnsOperateLogsResponseBodyLogs },
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePdnsOperateLogsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribePdnsOperateLogsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribePdnsOperateLogsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePdnsRequestStatisticRequest extends $tea.Model {
  domainName?: string;
  endDate?: string;
  lang?: string;
  startDate?: string;
  subDomain?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endDate: 'EndDate',
      lang: 'Lang',
      startDate: 'StartDate',
      subDomain: 'SubDomain',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endDate: 'string',
      lang: 'string',
      startDate: 'string',
      subDomain: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePdnsRequestStatisticResponseBody extends $tea.Model {
  data?: DescribePdnsRequestStatisticResponseBodyData[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': DescribePdnsRequestStatisticResponseBodyData },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePdnsRequestStatisticResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribePdnsRequestStatisticResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribePdnsRequestStatisticResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePdnsRequestStatisticsRequest extends $tea.Model {
  domainName?: string;
  endDate?: string;
  lang?: string;
  pageNumber?: number;
  pageSize?: number;
  startDate?: string;
  subDomain?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endDate: 'EndDate',
      lang: 'Lang',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      startDate: 'StartDate',
      subDomain: 'SubDomain',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endDate: 'string',
      lang: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      startDate: 'string',
      subDomain: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePdnsRequestStatisticsResponseBody extends $tea.Model {
  data?: DescribePdnsRequestStatisticsResponseBodyData[];
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': DescribePdnsRequestStatisticsResponseBodyData },
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePdnsRequestStatisticsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribePdnsRequestStatisticsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribePdnsRequestStatisticsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePdnsThreatLogsRequest extends $tea.Model {
  endDate?: string;
  keyword?: string;
  lang?: string;
  pageNumber?: number;
  pageSize?: number;
  startDate?: string;
  threatLevel?: string;
  threatSourceIp?: string;
  threatType?: string;
  static names(): { [key: string]: string } {
    return {
      endDate: 'EndDate',
      keyword: 'Keyword',
      lang: 'Lang',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      startDate: 'StartDate',
      threatLevel: 'ThreatLevel',
      threatSourceIp: 'ThreatSourceIp',
      threatType: 'ThreatType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endDate: 'string',
      keyword: 'string',
      lang: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      startDate: 'string',
      threatLevel: 'string',
      threatSourceIp: 'string',
      threatType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePdnsThreatLogsResponseBody extends $tea.Model {
  logs?: DescribePdnsThreatLogsResponseBodyLogs[];
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      logs: 'Logs',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logs: { 'type': 'array', 'itemType': DescribePdnsThreatLogsResponseBodyLogs },
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePdnsThreatLogsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribePdnsThreatLogsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribePdnsThreatLogsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePdnsThreatStatisticRequest extends $tea.Model {
  endDate?: string;
  lang?: string;
  startDate?: string;
  threatSourceIp?: string;
  static names(): { [key: string]: string } {
    return {
      endDate: 'EndDate',
      lang: 'Lang',
      startDate: 'StartDate',
      threatSourceIp: 'ThreatSourceIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endDate: 'string',
      lang: 'string',
      startDate: 'string',
      threatSourceIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePdnsThreatStatisticResponseBody extends $tea.Model {
  data?: DescribePdnsThreatStatisticResponseBodyData[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': DescribePdnsThreatStatisticResponseBodyData },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePdnsThreatStatisticResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribePdnsThreatStatisticResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribePdnsThreatStatisticResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePdnsThreatStatisticsRequest extends $tea.Model {
  direction?: string;
  domainName?: string;
  endDate?: string;
  lang?: string;
  orderBy?: string;
  pageNumber?: number;
  pageSize?: number;
  startDate?: string;
  subDomain?: string;
  threatLevel?: string;
  threatSourceIp?: string;
  threatType?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      direction: 'Direction',
      domainName: 'DomainName',
      endDate: 'EndDate',
      lang: 'Lang',
      orderBy: 'OrderBy',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      startDate: 'StartDate',
      subDomain: 'SubDomain',
      threatLevel: 'ThreatLevel',
      threatSourceIp: 'ThreatSourceIp',
      threatType: 'ThreatType',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      direction: 'string',
      domainName: 'string',
      endDate: 'string',
      lang: 'string',
      orderBy: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      startDate: 'string',
      subDomain: 'string',
      threatLevel: 'string',
      threatSourceIp: 'string',
      threatType: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePdnsThreatStatisticsResponseBody extends $tea.Model {
  data?: DescribePdnsThreatStatisticsResponseBodyData[];
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': DescribePdnsThreatStatisticsResponseBodyData },
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePdnsThreatStatisticsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribePdnsThreatStatisticsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribePdnsThreatStatisticsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePdnsUdpIpSegmentsRequest extends $tea.Model {
  lang?: string;
  pageNumber?: number;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePdnsUdpIpSegmentsResponseBody extends $tea.Model {
  ipSegments?: DescribePdnsUdpIpSegmentsResponseBodyIpSegments[];
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  totalPages?: string;
  static names(): { [key: string]: string } {
    return {
      ipSegments: 'IpSegments',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
      totalPages: 'TotalPages',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ipSegments: { 'type': 'array', 'itemType': DescribePdnsUdpIpSegmentsResponseBodyIpSegments },
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
      totalPages: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePdnsUdpIpSegmentsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribePdnsUdpIpSegmentsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribePdnsUdpIpSegmentsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePdnsUserInfoRequest extends $tea.Model {
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePdnsUserInfoResponseBody extends $tea.Model {
  requestId?: string;
  userInfo?: DescribePdnsUserInfoResponseBodyUserInfo;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      userInfo: 'UserInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      userInfo: DescribePdnsUserInfoResponseBodyUserInfo,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePdnsUserInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribePdnsUserInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribePdnsUserInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRecordLogsRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The keyword for searches in "%KeyWord%" mode. The value is not case-sensitive.
   * 
   * @example
   * test
   */
  keyWord?: string;
  /**
   * @remarks
   * The language.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The page number. Pages start from page **1**. Default value: **1**.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Valid values: **1 to 100**. Default value: **20**.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The start date of the query. Specify the start date in the **YYYY-MM-DD** format.
   * 
   * @example
   * 2015-12-12
   */
  startDate?: string;
  /**
   * @remarks
   * The IP address of the client.
   * 
   * @example
   * 1.1.1.1
   */
  userClientIp?: string;
  /**
   * @remarks
   * The end date of the query. Specify the end date in the **YYYY-MM-DD** format.
   * 
   * @example
   * 2015-12-12
   */
  endDate?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      keyWord: 'KeyWord',
      lang: 'Lang',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      startDate: 'StartDate',
      userClientIp: 'UserClientIp',
      endDate: 'endDate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      keyWord: 'string',
      lang: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      startDate: 'string',
      userClientIp: 'string',
      endDate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRecordLogsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 2
   */
  pageSize?: number;
  /**
   * @remarks
   * The operation logs.
   */
  recordLogs?: DescribeRecordLogsResponseBodyRecordLogs;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 536E9CAD-DB30-4647-AC87-AA5CC38C5382
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 2
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      recordLogs: 'RecordLogs',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      recordLogs: DescribeRecordLogsResponseBodyRecordLogs,
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRecordLogsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeRecordLogsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeRecordLogsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRecordResolveStatisticsSummaryRequest extends $tea.Model {
  /**
   * @remarks
   * The order in which the returned entries are sorted. Valid values:
   * 
   * *   DESC (default): descending order
   * *   ASC: ascending order
   * 
   * @example
   * DESC
   */
  direction?: string;
  /**
   * @remarks
   * The domain name.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The type of the domain name. The parameter value is not case-sensitive. Valid values:
   * 
   * *   PUBLIC (default): hosted public domain name
   * *   CACHE: cache-accelerated domain name
   * 
   * @example
   * PUBLIC
   */
  domainType?: string;
  /**
   * @remarks
   * The end date of the time range to be queried. Specify the time in the yyyy-MM-dd format, such as 2023-03-13.
   * 
   * @example
   * 2023-03-29
   */
  endDate?: string;
  /**
   * @remarks
   * The keyword. Keyword is used together with SearchMode.
   * 
   * @example
   * test
   */
  keyword?: string;
  /**
   * @remarks
   * The language. Valid values: zh, en, and ja.
   * 
   * @example
   * zh
   */
  lang?: string;
  /**
   * @remarks
   * The number of the page to return. Pages start from page 1. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Valid values: 1 to 1000.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The search mode of the keyword. Valid values:
   * 
   * *   LIKE (default): fuzzy search
   * *   EXACT: exact search
   * 
   * @example
   * LIKE
   */
  searchMode?: string;
  /**
   * @remarks
   * The start date of the time range to be queried. Specify the time in the yyyy-MM-dd format, such as 2023-03-01.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-03-29
   */
  startDate?: string;
  /**
   * @remarks
   * The threshold for the number of Domain Name System (DNS) requests. You can query the subdomain names at the specified quantity level of DNS requests and query the number of DNS requests for each subdomain name.
   * 
   * If you do not specify this parameter, the data about the subdomain names that have DNS requests is obtained.
   * 
   * If you set this parameter to a value less than 0, the data about all subdomain names is obtained.
   * 
   * If you set this parameter to 0, the data about the subdomain names that do not have DNS requests is obtained.
   * 
   * If you set this parameter to a value greater than 0, the data about the subdomain names whose number of DNS requests is less than or equal to the value of this parameter is obtained.
   * 
   * @example
   * -1
   */
  threshold?: number;
  static names(): { [key: string]: string } {
    return {
      direction: 'Direction',
      domainName: 'DomainName',
      domainType: 'DomainType',
      endDate: 'EndDate',
      keyword: 'Keyword',
      lang: 'Lang',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      searchMode: 'SearchMode',
      startDate: 'StartDate',
      threshold: 'Threshold',
    };
  }

  static types(): { [key: string]: any } {
    return {
      direction: 'string',
      domainName: 'string',
      domainType: 'string',
      endDate: 'string',
      keyword: 'string',
      lang: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      searchMode: 'string',
      startDate: 'string',
      threshold: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRecordResolveStatisticsSummaryResponseBody extends $tea.Model {
  /**
   * @remarks
   * The page number. Pages start from page 1. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Valid values: **1 to 500**. Default value: **20**.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 389DFFA3-77A5-4A9E-BF3D-147C6F98A5BA
   */
  requestId?: string;
  /**
   * @remarks
   * The statistics.
   */
  statistics?: DescribeRecordResolveStatisticsSummaryResponseBodyStatistics[];
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 1
   */
  totalItems?: number;
  /**
   * @remarks
   * The total number of pages returned.
   * 
   * @example
   * 1
   */
  totalPages?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      statistics: 'Statistics',
      totalItems: 'TotalItems',
      totalPages: 'TotalPages',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      statistics: { 'type': 'array', 'itemType': DescribeRecordResolveStatisticsSummaryResponseBodyStatistics },
      totalItems: 'number',
      totalPages: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRecordResolveStatisticsSummaryResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeRecordResolveStatisticsSummaryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeRecordResolveStatisticsSummaryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRecordStatisticsRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name.
   * 
   * This parameter is required.
   * 
   * @example
   * dns-example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The type of the domain name. The parameter value is not case-sensitive. Valid values:
   * 
   * *   PUBLIC (default): hosted public domain name
   * *   CACHE: cache-accelerated domain name
   * 
   * @example
   * PUBLIC
   */
  domainType?: string;
  /**
   * @remarks
   * The end date of the query. Specify the end date in the **YYYY-MM-DD** format.
   * 
   * The default value is the day when you query the data.
   * 
   * @example
   * 2019-07-04
   */
  endDate?: string;
  /**
   * @remarks
   * The language.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The hostname. If you want to resolve the subdomain name www.dns-exmaple.top, set this parameter to www.
   * 
   * This parameter is required.
   * 
   * @example
   * www
   */
  rr?: string;
  /**
   * @remarks
   * The start date of the query. Specify the start date in the **YYYY-MM-DD** format.
   * 
   * You can only query the DNS records within the last 90 days.``
   * 
   * If the time range is less than or equal to seven days, data is returned on an hourly basis.````
   * 
   * If the time range is greater than seven days, data is returned on a daily basis.````
   * 
   * This parameter is required.
   * 
   * @example
   * 2019-07-04
   */
  startDate?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      domainType: 'DomainType',
      endDate: 'EndDate',
      lang: 'Lang',
      rr: 'Rr',
      startDate: 'StartDate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      domainType: 'string',
      endDate: 'string',
      lang: 'string',
      rr: 'string',
      startDate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRecordStatisticsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 6AEC7A64-3CB1-4C49-8B35-0B901F1E26BF
   */
  requestId?: string;
  /**
   * @remarks
   * The statistics on the DNS requests.
   */
  statistics?: DescribeRecordStatisticsResponseBodyStatistics;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      statistics: 'Statistics',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      statistics: DescribeRecordStatisticsResponseBodyStatistics,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRecordStatisticsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeRecordStatisticsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeRecordStatisticsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRecordStatisticsSummaryRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name.
   * 
   * This parameter is required.
   * 
   * @example
   * dns-example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The type of the domain name. The parameter value is not case-sensitive. Valid values:
   * 
   * *   PUBLIC (default): hosted public domain name
   * *   CACHE: cache-accelerated domain name
   * 
   * @example
   * PUBLIC
   */
  domainType?: string;
  /**
   * @remarks
   * The end date of the query. Specify the start date in the **YYYY-MM-DD** format.
   * 
   * The default value is the day when you query the data.
   * 
   * @example
   * 2019-07-04
   */
  endDate?: string;
  /**
   * @remarks
   * The keyword for searches in %KeyWord% mode. The value is not case-sensitive.
   * 
   * @example
   * test
   */
  keyword?: string;
  /**
   * @remarks
   * The language.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The page number. Pages start from page **1**. Default value: **1**.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Valid values: **1 to 100**. Default value: **20**.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The search mode of the keyword. Valid values:
   * 
   * *   **LIKE** (default): fuzzy search
   * *   **EXACT**: exact search
   * 
   * @example
   * EXACT
   */
  searchMode?: string;
  /**
   * @remarks
   * The start date of the query. Specify the start date in the **YYYY-MM-DD** format.
   * 
   * You can only query the DNS records within the last 90 days.``
   * 
   * This parameter is required.
   * 
   * @example
   * 2019-07-04
   */
  startDate?: string;
  /**
   * @remarks
   * The maximum number of DNS requests that you can obtain. You can obtain data about a domain name with DNS request volume less than or equal to the maximum number. For example, if you set this parameter to 100, you can query domain names with less than 100 DNS requests.
   * 
   * @example
   * 12
   */
  threshold?: number;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      domainType: 'DomainType',
      endDate: 'EndDate',
      keyword: 'Keyword',
      lang: 'Lang',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      searchMode: 'SearchMode',
      startDate: 'StartDate',
      threshold: 'Threshold',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      domainType: 'string',
      endDate: 'string',
      keyword: 'string',
      lang: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      searchMode: 'string',
      startDate: 'string',
      threshold: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRecordStatisticsSummaryResponseBody extends $tea.Model {
  /**
   * @remarks
   * The page number. Pages start from page **1**. Default value: **1**.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Valid values: **1 to 100**. Default value: **20**.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * E49F0023-4A98-486F-8BA3-6003D5664105
   */
  requestId?: string;
  /**
   * @remarks
   * The DNS requests.
   */
  statistics?: DescribeRecordStatisticsSummaryResponseBodyStatistics;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 3
   */
  totalItems?: number;
  /**
   * @remarks
   * The total number of pages returned.
   * 
   * @example
   * 1
   */
  totalPages?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      statistics: 'Statistics',
      totalItems: 'TotalItems',
      totalPages: 'TotalPages',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      statistics: DescribeRecordStatisticsSummaryResponseBodyStatistics,
      totalItems: 'number',
      totalPages: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRecordStatisticsSummaryResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeRecordStatisticsSummaryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeRecordStatisticsSummaryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSubDomainRecordsRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The language.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The DNS resolution line.
   * 
   * @example
   * default
   */
  line?: string;
  /**
   * @remarks
   * The page number. Pages start from page **1**. Default value: **1**.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Valid values: **1 to 100**. Default value: **20**.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * If you set SubDomain to `a.www.example.com` and leave
   * 
   * DomainName empty, the system returns the DNS records that contain the hostname `a.www` for the domain name example.com. If you set SubDomain to a.www.example.com and set DomainName to www.example.com, the system returns the DNS records that contain the hostname `a` for the domain name www.example.com. If you set SubDomain to a.www.example.com and set DomainName to a.www.example.com, the system returns the DNS records that contain the hostname `@` for the domain name a.www.example.com.
   * 
   * This parameter is required.
   * 
   * @example
   * a.www.example.com
   */
  subDomain?: string;
  /**
   * @remarks
   * The type of DNS records. If you do not specify this parameter, all types of DNS records for the subdomain name are returned.
   * 
   * Valid values: **A, MX, CNAME, TXT, REDIRECT_URL, FORWORD_URL, NS, AAAA, and SRV**.
   * 
   * @example
   * MX
   */
  type?: string;
  /**
   * @remarks
   * The IP address of the client.
   * 
   * @example
   * 192.0.2.0
   */
  userClientIp?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      lang: 'Lang',
      line: 'Line',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      subDomain: 'SubDomain',
      type: 'Type',
      userClientIp: 'UserClientIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      lang: 'string',
      line: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      subDomain: 'string',
      type: 'string',
      userClientIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSubDomainRecordsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned DNS records.
   */
  domainRecords?: DescribeSubDomainRecordsResponseBodyDomainRecords;
  /**
   * @remarks
   * The page number. Pages start from page **1**. Default value: **1**.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 2
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 536E9CAD-DB30-4647-AC87-AA5CC38C5382
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 2
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      domainRecords: 'DomainRecords',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainRecords: DescribeSubDomainRecordsResponseBodyDomainRecords,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSubDomainRecordsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeSubDomainRecordsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSubDomainRecordsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSupportLinesRequest extends $tea.Model {
  /**
   * @remarks
   * 
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * 
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * IP
   * 
   * @example
   * 1.1.*.*
   */
  userClientIp?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      lang: 'Lang',
      userClientIp: 'UserClientIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      lang: 'string',
      userClientIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSupportLinesResponseBody extends $tea.Model {
  /**
   * @remarks
   * 
   */
  recordLines?: DescribeSupportLinesResponseBodyRecordLines;
  /**
   * @remarks
   * ID
   * 
   * @example
   * CFDA0830-7D6E-4C13-8632-B57C7EDCF079
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      recordLines: 'RecordLines',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      recordLines: DescribeSupportLinesResponseBodyRecordLines,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSupportLinesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeSupportLinesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSupportLinesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTagsRequest extends $tea.Model {
  /**
   * @remarks
   * The language in which you want the values of some response parameters to be returned. These response parameters support multiple languages. Default value: en. Valid values: en, zh, and ja.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The page number. Pages start from page **1**. Default value: **1**.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return per page. Default value: 200.
   * 
   * @example
   * 200
   */
  pageSize?: number;
  /**
   * @remarks
   * The type of the resources from which you want to query tags. Set the value to DOMAIN.
   * 
   * This parameter is required.
   * 
   * @example
   * DOMAIN
   */
  resourceType?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      resourceType: 'ResourceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      resourceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTagsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The page number. Pages start from page **1**. Default value: **1**.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 200.
   * 
   * @example
   * 200
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 89184F33-48A1-4401-9C0F-40E45DB091AB
   */
  requestId?: string;
  /**
   * @remarks
   * The tags added to the resource.
   */
  tags?: DescribeTagsResponseBodyTags[];
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 5
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      tags: 'Tags',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      tags: { 'type': 'array', 'itemType': DescribeTagsResponseBodyTags },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTagsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeTagsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeTagsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTransferDomainsRequest extends $tea.Model {
  /**
   * @remarks
   * Specifies the domain name for which you want to view the transfer record.
   * 
   * @example
   * alidns.com
   */
  domainName?: string;
  /**
   * @remarks
   * The user ID from which the domain name was transferred to the current account.
   * 
   * @example
   * 123456
   */
  fromUserId?: number;
  /**
   * @remarks
   * The language.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The page number. Pages start from page 1. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Valid values: 1 to 100. Default value: 20.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The user ID to which the domain name was transferred from the current account.
   * 
   * @example
   * 123456
   */
  targetUserId?: number;
  /**
   * @remarks
   * The transfer type. Valid values:
   * 
   * *   IN: The domain name was transferred to the current account.
   * *   OUT: The domain name was transferred from the current account.
   * 
   * This parameter is required.
   * 
   * @example
   * IN
   */
  transferType?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      fromUserId: 'FromUserId',
      lang: 'Lang',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      targetUserId: 'TargetUserId',
      transferType: 'TransferType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      fromUserId: 'number',
      lang: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      targetUserId: 'number',
      transferType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTransferDomainsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The domain names that were transferred between accounts.
   */
  domainTransfers?: DescribeTransferDomainsResponseBodyDomainTransfers;
  /**
   * @remarks
   * The page number. Pages start from page **1**. Default value: **1**.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Valid values: 1 to 100. Default value: 20.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 536E9CAD-DB30-4647-AC87-AA5CC38C5382
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      domainTransfers: 'DomainTransfers',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainTransfers: DescribeTransferDomainsResponseBodyDomainTransfers,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTransferDomainsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeTransferDomainsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeTransferDomainsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExecuteGtmRecoveryPlanRequest extends $tea.Model {
  /**
   * @remarks
   * The language used by the user.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The ID of the disaster recovery plan that you want to executed.
   * 
   * This parameter is required.
   * 
   * @example
   * 100
   */
  recoveryPlanId?: number;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      recoveryPlanId: 'RecoveryPlanId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      recoveryPlanId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExecuteGtmRecoveryPlanResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 6856BCF6-11D6-4D7E-AC53-FD579933522B
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExecuteGtmRecoveryPlanResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ExecuteGtmRecoveryPlanResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ExecuteGtmRecoveryPlanResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMainDomainNameRequest extends $tea.Model {
  /**
   * @remarks
   * The string. The string can be up to 128 characters in length.
   * 
   * This parameter is required.
   * 
   * @example
   * www.example.com
   */
  inputString?: string;
  /**
   * @remarks
   * The language.
   * 
   * @example
   * en
   */
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      inputString: 'InputString',
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      inputString: 'string',
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMainDomainNameResponseBody extends $tea.Model {
  /**
   * @remarks
   * The level of the entered domain name.
   * 
   * @example
   * 2
   */
  domainLevel?: number;
  /**
   * @remarks
   * The domain name.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The hostname.
   * 
   * @example
   * www
   */
  RR?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 536E9CAD-DB30-4647-AC87-AA5CC38C5382
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      domainLevel: 'DomainLevel',
      domainName: 'DomainName',
      RR: 'RR',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainLevel: 'number',
      domainName: 'string',
      RR: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMainDomainNameResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetMainDomainNameResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetMainDomainNameResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTxtRecordForVerifyRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The language.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The feature verified by using the TXT record. Valid values:
   * 
   * *   ADD_SUB_DOMAIN
   * *   RETRIEVAL
   * 
   * This parameter is required.
   * 
   * @example
   * ADD_SUB_DOMAIN
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      lang: 'Lang',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      lang: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTxtRecordForVerifyResponseBody extends $tea.Model {
  /**
   * @remarks
   * The domain name.
   * 
   * >  If you do not specify this parameter, it is not returned.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  parentDomainName?: string;
  /**
   * @remarks
   * The hostname.
   * 
   * @example
   * aliyunRetrieval
   */
  RR?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 9CC0D642-49D4-48DE-A1A5-9F218652E4A7
   */
  requestId?: string;
  /**
   * @remarks
   * The record value.
   * 
   * >  The validity period is three days.
   * 
   * @example
   * c99419e6997f41daaa3e*****
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      parentDomainName: 'ParentDomainName',
      RR: 'RR',
      requestId: 'RequestId',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      parentDomainName: 'string',
      RR: 'string',
      requestId: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTxtRecordForVerifyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetTxtRecordForVerifyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetTxtRecordForVerifyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudGtmAddressPoolsRequest extends $tea.Model {
  /**
   * @example
   * en-US
   */
  acceptLanguage?: string;
  /**
   * @example
   * AddressPool-1
   */
  addressPoolName?: string;
  /**
   * @example
   * IPv4
   */
  addressPoolType?: string;
  /**
   * @example
   * 1ae05db4-10e7-11ef-b126-00163e24**22
   */
  clientToken?: string;
  /**
   * @example
   * enable
   */
  enableStatus?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @example
   * test
   */
  remark?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      addressPoolName: 'AddressPoolName',
      addressPoolType: 'AddressPoolType',
      clientToken: 'ClientToken',
      enableStatus: 'EnableStatus',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      remark: 'Remark',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      addressPoolName: 'string',
      addressPoolType: 'string',
      clientToken: 'string',
      enableStatus: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      remark: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudGtmAddressPoolsResponseBody extends $tea.Model {
  addressPools?: ListCloudGtmAddressPoolsResponseBodyAddressPools;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @example
   * 536E9CAD-DB30-4647-AC87-AA5CC38C5382
   */
  requestId?: string;
  /**
   * @example
   * 11
   */
  totalItems?: number;
  /**
   * @example
   * 1
   */
  totalPages?: number;
  static names(): { [key: string]: string } {
    return {
      addressPools: 'AddressPools',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalItems: 'TotalItems',
      totalPages: 'TotalPages',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addressPools: ListCloudGtmAddressPoolsResponseBodyAddressPools,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalItems: 'number',
      totalPages: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudGtmAddressPoolsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListCloudGtmAddressPoolsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListCloudGtmAddressPoolsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudGtmAddressesRequest extends $tea.Model {
  /**
   * @example
   * en-US
   */
  acceptLanguage?: string;
  /**
   * @example
   * 223.5.XX.XX
   */
  address?: string;
  /**
   * @example
   * addr-89518218114368**92
   */
  addressId?: string;
  /**
   * @example
   * 1ae05db4-10e7-11ef-b126-00163e24**22
   */
  clientToken?: string;
  /**
   * @example
   * enable
   */
  enableStatus?: string;
  /**
   * @example
   * ok
   */
  healthStatus?: string;
  /**
   * @example
   * mtp-89518052425100**80
   */
  monitorTemplateId?: string;
  /**
   * @example
   * test
   */
  name?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @example
   * IPv4
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      address: 'Address',
      addressId: 'AddressId',
      clientToken: 'ClientToken',
      enableStatus: 'EnableStatus',
      healthStatus: 'HealthStatus',
      monitorTemplateId: 'MonitorTemplateId',
      name: 'Name',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      address: 'string',
      addressId: 'string',
      clientToken: 'string',
      enableStatus: 'string',
      healthStatus: 'string',
      monitorTemplateId: 'string',
      name: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudGtmAddressesResponseBody extends $tea.Model {
  addresses?: ListCloudGtmAddressesResponseBodyAddresses;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @example
   * 536E9CAD-DB30-4647-AC87-AA5CC38C5382
   */
  requestId?: string;
  /**
   * @example
   * 30
   */
  totalItems?: number;
  /**
   * @example
   * 2
   */
  totalPages?: number;
  static names(): { [key: string]: string } {
    return {
      addresses: 'Addresses',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalItems: 'TotalItems',
      totalPages: 'TotalPages',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addresses: ListCloudGtmAddressesResponseBodyAddresses,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalItems: 'number',
      totalPages: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudGtmAddressesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListCloudGtmAddressesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListCloudGtmAddressesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudGtmAlertLogsRequest extends $tea.Model {
  /**
   * @example
   * ALERT
   */
  actionType?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1711328826977
   */
  endTimestamp?: number;
  /**
   * @example
   * GTM_ADDRESS
   */
  entityType?: string;
  /**
   * @example
   * pool-895280232254422016
   */
  keyword?: string;
  /**
   * @example
   * zh-CN
   */
  lang?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1611328826977
   */
  startTimestamp?: number;
  static names(): { [key: string]: string } {
    return {
      actionType: 'ActionType',
      endTimestamp: 'EndTimestamp',
      entityType: 'EntityType',
      keyword: 'Keyword',
      lang: 'Lang',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      startTimestamp: 'StartTimestamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actionType: 'string',
      endTimestamp: 'number',
      entityType: 'string',
      keyword: 'string',
      lang: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      startTimestamp: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudGtmAlertLogsResponseBody extends $tea.Model {
  logs?: ListCloudGtmAlertLogsResponseBodyLogs;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @example
   * 536E9CAD-DB30-4647-AC87-AA5CC38C5382
   */
  requestId?: string;
  /**
   * @example
   * 15
   */
  totalItems?: number;
  /**
   * @example
   * 1
   */
  totalPages?: number;
  static names(): { [key: string]: string } {
    return {
      logs: 'Logs',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalItems: 'TotalItems',
      totalPages: 'TotalPages',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logs: ListCloudGtmAlertLogsResponseBodyLogs,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalItems: 'number',
      totalPages: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudGtmAlertLogsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListCloudGtmAlertLogsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListCloudGtmAlertLogsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudGtmAvailableAlertGroupsRequest extends $tea.Model {
  /**
   * @example
   * en-US
   */
  acceptLanguage?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudGtmAvailableAlertGroupsResponseBody extends $tea.Model {
  alertGroups?: ListCloudGtmAvailableAlertGroupsResponseBodyAlertGroups;
  /**
   * @example
   * 536E9CAD-DB30-4647-AC87-AA5CC38C5382
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      alertGroups: 'AlertGroups',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertGroups: ListCloudGtmAvailableAlertGroupsResponseBodyAlertGroups,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudGtmAvailableAlertGroupsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListCloudGtmAvailableAlertGroupsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListCloudGtmAvailableAlertGroupsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudGtmInstanceConfigsRequest extends $tea.Model {
  /**
   * @example
   * en-US
   */
  acceptLanguage?: string;
  /**
   * @example
   * 1ae05db4-10e7-11ef-b126-00163e24**22
   */
  clientToken?: string;
  /**
   * @example
   * enable
   */
  enableStatus?: string;
  /**
   * @example
   * gtm-cn-wwo3a3hbz**
   */
  instanceId?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @example
   * test
   */
  remark?: string;
  /**
   * @example
   * www.example.com
   */
  scheduleDomainName?: string;
  /**
   * @example
   * example.com
   */
  scheduleZoneName?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      clientToken: 'ClientToken',
      enableStatus: 'EnableStatus',
      instanceId: 'InstanceId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      remark: 'Remark',
      scheduleDomainName: 'ScheduleDomainName',
      scheduleZoneName: 'ScheduleZoneName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      clientToken: 'string',
      enableStatus: 'string',
      instanceId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      remark: 'string',
      scheduleDomainName: 'string',
      scheduleZoneName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudGtmInstanceConfigsResponseBody extends $tea.Model {
  instanceConfigs?: ListCloudGtmInstanceConfigsResponseBodyInstanceConfigs;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @example
   * 536E9CAD-DB30-4647-AC87-AA5CC38C5382
   */
  requestId?: string;
  /**
   * @example
   * 10
   */
  totalItems?: number;
  /**
   * @example
   * 1
   */
  totalPages?: number;
  static names(): { [key: string]: string } {
    return {
      instanceConfigs: 'InstanceConfigs',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalItems: 'TotalItems',
      totalPages: 'TotalPages',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceConfigs: ListCloudGtmInstanceConfigsResponseBodyInstanceConfigs,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalItems: 'number',
      totalPages: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudGtmInstanceConfigsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListCloudGtmInstanceConfigsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListCloudGtmInstanceConfigsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudGtmInstancesRequest extends $tea.Model {
  /**
   * @example
   * en-US
   */
  acceptLanguage?: string;
  /**
   * @example
   * 1ae05db4-10e7-11ef-b126-00163e24**22
   */
  clientToken?: string;
  /**
   * @example
   * gtm-cn-jmp3qnw**03
   */
  instanceId?: string;
  /**
   * @example
   * test
   */
  instanceName?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 20
   */
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      clientToken: 'ClientToken',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      clientToken: 'string',
      instanceId: 'string',
      instanceName: 'string',
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudGtmInstancesResponseBody extends $tea.Model {
  instances?: ListCloudGtmInstancesResponseBodyInstances;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @example
   * 536E9CAD-DB30-4647-AC87-AA5CC38C5382
   */
  requestId?: string;
  /**
   * @example
   * 15
   */
  totalItems?: number;
  /**
   * @example
   * 1
   */
  totalPages?: number;
  static names(): { [key: string]: string } {
    return {
      instances: 'Instances',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalItems: 'TotalItems',
      totalPages: 'TotalPages',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instances: ListCloudGtmInstancesResponseBodyInstances,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalItems: 'number',
      totalPages: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudGtmInstancesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListCloudGtmInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListCloudGtmInstancesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudGtmMonitorNodesRequest extends $tea.Model {
  /**
   * @example
   * en-US
   */
  acceptLanguage?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudGtmMonitorNodesResponseBody extends $tea.Model {
  ipv4IspCityNodes?: ListCloudGtmMonitorNodesResponseBodyIpv4IspCityNodes;
  ipv6IspCityNodes?: ListCloudGtmMonitorNodesResponseBodyIpv6IspCityNodes;
  /**
   * @example
   * 536E9CAD-DB30-4647-AC87-AA5CC38C5382
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      ipv4IspCityNodes: 'Ipv4IspCityNodes',
      ipv6IspCityNodes: 'Ipv6IspCityNodes',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ipv4IspCityNodes: ListCloudGtmMonitorNodesResponseBodyIpv4IspCityNodes,
      ipv6IspCityNodes: ListCloudGtmMonitorNodesResponseBodyIpv6IspCityNodes,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudGtmMonitorNodesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListCloudGtmMonitorNodesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListCloudGtmMonitorNodesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudGtmMonitorTemplatesRequest extends $tea.Model {
  /**
   * @example
   * en-US
   */
  acceptLanguage?: string;
  /**
   * @example
   * IPv4
   */
  ipVersion?: string;
  /**
   * @example
   * IPv4-Ping
   */
  name?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @example
   * ping
   */
  protocol?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      ipVersion: 'IpVersion',
      name: 'Name',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      protocol: 'Protocol',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      ipVersion: 'string',
      name: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      protocol: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudGtmMonitorTemplatesResponseBody extends $tea.Model {
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @example
   * 75446CC1-FC9A-4595-8D96-089D73D7A63D
   */
  requestId?: string;
  templates?: ListCloudGtmMonitorTemplatesResponseBodyTemplates;
  /**
   * @example
   * 30
   */
  totalItems?: number;
  /**
   * @example
   * 2
   */
  totalPages?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      templates: 'Templates',
      totalItems: 'TotalItems',
      totalPages: 'TotalPages',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      templates: ListCloudGtmMonitorTemplatesResponseBodyTemplates,
      totalItems: 'number',
      totalPages: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudGtmMonitorTemplatesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListCloudGtmMonitorTemplatesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListCloudGtmMonitorTemplatesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTagResourcesRequest extends $tea.Model {
  /**
   * @remarks
   * The language in which you want some response parameters to be returned.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The token that determines the start point of the query.
   * 
   * @example
   * 4698691
   */
  nextToken?: string;
  /**
   * @remarks
   * The ID of the resource.
   */
  resourceId?: string[];
  /**
   * @remarks
   * The resource type.
   * 
   * This parameter is required.
   * 
   * @example
   * DOMAIN
   */
  resourceType?: string;
  /**
   * @remarks
   * An array of tag key-value pairs.
   */
  tag?: ListTagResourcesRequestTag[];
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      nextToken: 'NextToken',
      resourceId: 'ResourceId',
      resourceType: 'ResourceType',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      nextToken: 'string',
      resourceId: { 'type': 'array', 'itemType': 'string' },
      resourceType: 'string',
      tag: { 'type': 'array', 'itemType': ListTagResourcesRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTagResourcesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The token used to start the next query. If no value is returned for NextToken, no next queries are sent.
   * 
   * @example
   * 4698691
   */
  nextToken?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 61092C8D-6AEB-4310-B74D-C632F89BF4FB
   */
  requestId?: string;
  /**
   * @remarks
   * Details of the resource and tags, including the resource ID, the resource type, tag keys, and tag values.
   */
  tagResources?: ListTagResourcesResponseBodyTagResources[];
  static names(): { [key: string]: string } {
    return {
      nextToken: 'NextToken',
      requestId: 'RequestId',
      tagResources: 'TagResources',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nextToken: 'string',
      requestId: 'string',
      tagResources: { 'type': 'array', 'itemType': ListTagResourcesResponseBodyTagResources },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTagResourcesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListTagResourcesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListTagResourcesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyHichinaDomainDNSRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The language type.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The IP address of the client.
   * 
   * @example
   * 192.0.2.0
   */
  userClientIp?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      lang: 'Lang',
      userClientIp: 'UserClientIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      lang: 'string',
      userClientIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyHichinaDomainDNSResponseBody extends $tea.Model {
  /**
   * @remarks
   * The list of DNS servers after the domain name is changed.
   */
  newDnsServers?: ModifyHichinaDomainDNSResponseBodyNewDnsServers;
  /**
   * @remarks
   * The list of DNS servers before the domain name is changed.
   */
  originalDnsServers?: ModifyHichinaDomainDNSResponseBodyOriginalDnsServers;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 536E9CAD-DB30-4647-AC87-AA5CC38C5382
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      newDnsServers: 'NewDnsServers',
      originalDnsServers: 'OriginalDnsServers',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      newDnsServers: ModifyHichinaDomainDNSResponseBodyNewDnsServers,
      originalDnsServers: ModifyHichinaDomainDNSResponseBodyOriginalDnsServers,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyHichinaDomainDNSResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyHichinaDomainDNSResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyHichinaDomainDNSResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class MoveDomainResourceGroupRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the values of specific response parameters. Default value: en. Valid values: en, zh, and ja.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The ID of the new resource group.
   * 
   * This parameter is required.
   * 
   * @example
   * rg-aekzzk7hx3glaoq
   */
  newResourceGroupId?: string;
  /**
   * @remarks
   * The resource ID. If Tag is left empty, ResourceId is required.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  resourceId?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      newResourceGroupId: 'NewResourceGroupId',
      resourceId: 'ResourceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      newResourceGroupId: 'string',
      resourceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class MoveDomainResourceGroupResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * C6F1D541-E7A6-447A-A2B5-9F7A20B2A8FB
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class MoveDomainResourceGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: MoveDomainResourceGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: MoveDomainResourceGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class MoveGtmResourceGroupRequest extends $tea.Model {
  /**
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * AgIDE1MA_XXX
   */
  newResourceGroupId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * rg-aekzzk7hx3*****
   */
  resourceId?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      newResourceGroupId: 'NewResourceGroupId',
      resourceId: 'ResourceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      newResourceGroupId: 'string',
      resourceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class MoveGtmResourceGroupResponseBody extends $tea.Model {
  /**
   * @example
   * C6F1D541-E7A6-447A-A2B5-9F7A20B2A8FB
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class MoveGtmResourceGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: MoveGtmResourceGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: MoveGtmResourceGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OperateBatchDomainRequest extends $tea.Model {
  /**
   * @remarks
   * The DNS records. You can submit up to 1000 DNS records.
   * 
   * This parameter is required.
   */
  domainRecordInfo?: OperateBatchDomainRequestDomainRecordInfo[];
  /**
   * @remarks
   * The language.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The type of the batch operation. Valid values:
   * 
   * *   **DOMAIN_ADD**: adds domain names in batches.
   * *   **DOMAIN_DEL**: deletes domain names in batches.
   * *   **RR_ADD**: adds DNS records in batches.
   * *   **RR_DEL**: deletes DNS records in batches. This operation deletes the DNS records with the specified hostname or record value. If you do not specify the Rr and Value parameters, this operation deletes the DNS records that are added for the specified domain names.
   * 
   * This parameter is required.
   * 
   * @example
   * RR_ADD
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      domainRecordInfo: 'DomainRecordInfo',
      lang: 'Lang',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainRecordInfo: { 'type': 'array', 'itemType': OperateBatchDomainRequestDomainRecordInfo },
      lang: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OperateBatchDomainResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 75446CC1-FC9A-4595-8D96-089D73D7A63D
   */
  requestId?: string;
  /**
   * @remarks
   * The task ID.
   * 
   * @example
   * 345345
   */
  taskId?: number;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      taskId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OperateBatchDomainResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: OperateBatchDomainResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: OperateBatchDomainResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PausePdnsServiceRequest extends $tea.Model {
  lang?: string;
  serviceType?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      serviceType: 'ServiceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      serviceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PausePdnsServiceResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PausePdnsServiceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: PausePdnsServiceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PausePdnsServiceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PreviewGtmRecoveryPlanRequest extends $tea.Model {
  /**
   * @remarks
   * The language used by the user.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The number of the page to return. Pages start from page **1**. Default value: **1**.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on per page. Maximum value: **20**. Default value: **5**.
   * 
   * @example
   * 5
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the disaster recovery plan that you want to preview.
   * 
   * This parameter is required.
   * 
   * @example
   * 100
   */
  recoveryPlanId?: number;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      recoveryPlanId: 'RecoveryPlanId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      recoveryPlanId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PreviewGtmRecoveryPlanResponseBody extends $tea.Model {
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 5
   */
  pageSize?: number;
  /**
   * @remarks
   * The returned preview information of the disaster recovery plan.
   */
  previews?: PreviewGtmRecoveryPlanResponseBodyPreviews;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 853805EA-3D47-47D5-9A1A-A45C24313ABD
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries returned on all pages.
   * 
   * @example
   * 15
   */
  totalItems?: number;
  /**
   * @remarks
   * The total number of pages returned.
   * 
   * @example
   * 3
   */
  totalPages?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      previews: 'Previews',
      requestId: 'RequestId',
      totalItems: 'TotalItems',
      totalPages: 'TotalPages',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      previews: PreviewGtmRecoveryPlanResponseBodyPreviews,
      requestId: 'string',
      totalItems: 'number',
      totalPages: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PreviewGtmRecoveryPlanResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: PreviewGtmRecoveryPlanResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PreviewGtmRecoveryPlanResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemovePdnsAppKeyRequest extends $tea.Model {
  appKeyId?: string;
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      appKeyId: 'AppKeyId',
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appKeyId: 'string',
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemovePdnsAppKeyResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemovePdnsAppKeyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RemovePdnsAppKeyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RemovePdnsAppKeyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemovePdnsUdpIpSegmentRequest extends $tea.Model {
  ip?: string;
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      ip: 'Ip',
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ip: 'string',
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemovePdnsUdpIpSegmentResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemovePdnsUdpIpSegmentResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RemovePdnsUdpIpSegmentResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RemovePdnsUdpIpSegmentResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReplaceCloudGtmAddressPoolAddressRequest extends $tea.Model {
  /**
   * @example
   * en-US
   */
  acceptLanguage?: string;
  /**
   * @example
   * pool-89618921167339**24
   */
  addressPoolId?: string;
  addresses?: ReplaceCloudGtmAddressPoolAddressRequestAddresses[];
  /**
   * @example
   * 1ae05db4-10e7-11ef-b126-00163e24**22
   */
  clientToken?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      addressPoolId: 'AddressPoolId',
      addresses: 'Addresses',
      clientToken: 'ClientToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      addressPoolId: 'string',
      addresses: { 'type': 'array', 'itemType': ReplaceCloudGtmAddressPoolAddressRequestAddresses },
      clientToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReplaceCloudGtmAddressPoolAddressShrinkRequest extends $tea.Model {
  /**
   * @example
   * en-US
   */
  acceptLanguage?: string;
  /**
   * @example
   * pool-89618921167339**24
   */
  addressPoolId?: string;
  addressesShrink?: string;
  /**
   * @example
   * 1ae05db4-10e7-11ef-b126-00163e24**22
   */
  clientToken?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      addressPoolId: 'AddressPoolId',
      addressesShrink: 'Addresses',
      clientToken: 'ClientToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      addressPoolId: 'string',
      addressesShrink: 'string',
      clientToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReplaceCloudGtmAddressPoolAddressResponseBody extends $tea.Model {
  /**
   * @example
   * pool-89618921167339**24
   */
  addressPoolId?: string;
  /**
   * @example
   * B57C121B-A45F-44D8-A9B2-13E5A5044195
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      addressPoolId: 'AddressPoolId',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addressPoolId: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReplaceCloudGtmAddressPoolAddressResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ReplaceCloudGtmAddressPoolAddressResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ReplaceCloudGtmAddressPoolAddressResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReplaceCloudGtmInstanceConfigAddressPoolRequest extends $tea.Model {
  /**
   * @example
   * en-US
   */
  acceptLanguage?: string;
  addressPools?: ReplaceCloudGtmInstanceConfigAddressPoolRequestAddressPools[];
  /**
   * @example
   * 1ae05db4-10e7-11ef-b126-00163e24**22
   */
  clientToken?: string;
  /**
   * @example
   * Config-000**11
   */
  configId?: string;
  /**
   * @example
   * gtm-cn-wwo3a3hbz**
   */
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      addressPools: 'AddressPools',
      clientToken: 'ClientToken',
      configId: 'ConfigId',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      addressPools: { 'type': 'array', 'itemType': ReplaceCloudGtmInstanceConfigAddressPoolRequestAddressPools },
      clientToken: 'string',
      configId: 'string',
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReplaceCloudGtmInstanceConfigAddressPoolShrinkRequest extends $tea.Model {
  /**
   * @example
   * en-US
   */
  acceptLanguage?: string;
  addressPoolsShrink?: string;
  /**
   * @example
   * 1ae05db4-10e7-11ef-b126-00163e24**22
   */
  clientToken?: string;
  /**
   * @example
   * Config-000**11
   */
  configId?: string;
  /**
   * @example
   * gtm-cn-wwo3a3hbz**
   */
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      addressPoolsShrink: 'AddressPools',
      clientToken: 'ClientToken',
      configId: 'ConfigId',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      addressPoolsShrink: 'string',
      clientToken: 'string',
      configId: 'string',
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReplaceCloudGtmInstanceConfigAddressPoolResponseBody extends $tea.Model {
  /**
   * @example
   * 536E9CAD-DB30-4647-AC87-AA5CC38C5382
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReplaceCloudGtmInstanceConfigAddressPoolResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ReplaceCloudGtmInstanceConfigAddressPoolResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ReplaceCloudGtmInstanceConfigAddressPoolResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResumePdnsServiceRequest extends $tea.Model {
  lang?: string;
  serviceType?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      serviceType: 'ServiceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      serviceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResumePdnsServiceResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResumePdnsServiceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ResumePdnsServiceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ResumePdnsServiceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RetrieveDomainRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The language.
   * 
   * @example
   * en
   */
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RetrieveDomainResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 9CC0D642-49D4-48DE-A1A5-9F218652E4A7
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RetrieveDomainResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RetrieveDomainResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RetrieveDomainResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RollbackGtmRecoveryPlanRequest extends $tea.Model {
  /**
   * @remarks
   * The language used by the user.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The ID of the disaster recovery plan that you want to roll back.
   * 
   * This parameter is required.
   * 
   * @example
   * 100
   */
  recoveryPlanId?: number;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      recoveryPlanId: 'RecoveryPlanId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      recoveryPlanId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RollbackGtmRecoveryPlanResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 853805EA-3D47-47D5-9A1A-A45C24313ABD
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RollbackGtmRecoveryPlanResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RollbackGtmRecoveryPlanResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RollbackGtmRecoveryPlanResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchCloudGtmAddressPoolsRequest extends $tea.Model {
  /**
   * @example
   * en-US
   */
  acceptLanguage?: string;
  /**
   * @example
   * AddressPool-1
   */
  addressPoolName?: string;
  /**
   * @example
   * IPv4
   */
  addressPoolType?: string;
  /**
   * @example
   * available
   */
  availableStatus?: string;
  /**
   * @example
   * 1ae05db4-10e7-11ef-b126-00163e24**22
   */
  clientToken?: string;
  /**
   * @example
   * enable
   */
  enableStatus?: string;
  /**
   * @example
   * ok
   */
  healthStatus?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @example
   * test
   */
  remark?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      addressPoolName: 'AddressPoolName',
      addressPoolType: 'AddressPoolType',
      availableStatus: 'AvailableStatus',
      clientToken: 'ClientToken',
      enableStatus: 'EnableStatus',
      healthStatus: 'HealthStatus',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      remark: 'Remark',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      addressPoolName: 'string',
      addressPoolType: 'string',
      availableStatus: 'string',
      clientToken: 'string',
      enableStatus: 'string',
      healthStatus: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      remark: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchCloudGtmAddressPoolsResponseBody extends $tea.Model {
  addressPools?: SearchCloudGtmAddressPoolsResponseBodyAddressPools;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @example
   * 536E9CAD-DB30-4647-AC87-AA5CC38C5382
   */
  requestId?: string;
  /**
   * @example
   * 11
   */
  totalItems?: number;
  /**
   * @example
   * 1
   */
  totalPages?: number;
  static names(): { [key: string]: string } {
    return {
      addressPools: 'AddressPools',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalItems: 'TotalItems',
      totalPages: 'TotalPages',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addressPools: SearchCloudGtmAddressPoolsResponseBodyAddressPools,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalItems: 'number',
      totalPages: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchCloudGtmAddressPoolsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SearchCloudGtmAddressPoolsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SearchCloudGtmAddressPoolsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchCloudGtmAddressesRequest extends $tea.Model {
  /**
   * @example
   * en-US
   */
  acceptLanguage?: string;
  /**
   * @example
   * 223.5.XX.XX
   */
  address?: string;
  /**
   * @example
   * addr-89518218114368**92
   */
  addressId?: string;
  /**
   * @example
   * available
   */
  availableStatus?: string;
  /**
   * @example
   * enable
   */
  enableStatus?: string;
  /**
   * @example
   * ok
   */
  healthStatus?: string;
  /**
   * @example
   * Ping-IPv4
   */
  monitorTemplateName?: string;
  /**
   * @example
   * or
   */
  nameSearchCondition?: string;
  names?: string[];
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @example
   * or
   */
  remarkSearchCondition?: string;
  remarks?: string[];
  /**
   * @example
   * IPv4
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      address: 'Address',
      addressId: 'AddressId',
      availableStatus: 'AvailableStatus',
      enableStatus: 'EnableStatus',
      healthStatus: 'HealthStatus',
      monitorTemplateName: 'MonitorTemplateName',
      nameSearchCondition: 'NameSearchCondition',
      names: 'Names',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      remarkSearchCondition: 'RemarkSearchCondition',
      remarks: 'Remarks',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      address: 'string',
      addressId: 'string',
      availableStatus: 'string',
      enableStatus: 'string',
      healthStatus: 'string',
      monitorTemplateName: 'string',
      nameSearchCondition: 'string',
      names: { 'type': 'array', 'itemType': 'string' },
      pageNumber: 'number',
      pageSize: 'number',
      remarkSearchCondition: 'string',
      remarks: { 'type': 'array', 'itemType': 'string' },
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchCloudGtmAddressesResponseBody extends $tea.Model {
  addresses?: SearchCloudGtmAddressesResponseBodyAddresses;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @example
   * 536E9CAD-DB30-4647-AC87-AA5CC38C5382
   */
  requestId?: string;
  /**
   * @example
   * 15
   */
  totalItems?: number;
  /**
   * @example
   * 1
   */
  totalPages?: number;
  static names(): { [key: string]: string } {
    return {
      addresses: 'Addresses',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalItems: 'TotalItems',
      totalPages: 'TotalPages',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addresses: SearchCloudGtmAddressesResponseBodyAddresses,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalItems: 'number',
      totalPages: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchCloudGtmAddressesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SearchCloudGtmAddressesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SearchCloudGtmAddressesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchCloudGtmInstanceConfigsRequest extends $tea.Model {
  /**
   * @example
   * zh-CN
   */
  acceptLanguage?: string;
  /**
   * @example
   * available
   */
  availableStatus?: string;
  /**
   * @example
   * 1ae05db4-10e7-11ef-b126-00163e24**22
   */
  clientToken?: string;
  /**
   * @example
   * enable
   */
  enableStatus?: string;
  /**
   * @example
   * ok
   */
  healthStatus?: string;
  /**
   * @example
   * gtm-cn-wwo3a3hbz**
   */
  instanceId?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @example
   * test
   */
  remark?: string;
  /**
   * @example
   * www.example.com
   */
  scheduleDomainName?: string;
  /**
   * @example
   * example.com
   */
  scheduleZoneName?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      availableStatus: 'AvailableStatus',
      clientToken: 'ClientToken',
      enableStatus: 'EnableStatus',
      healthStatus: 'HealthStatus',
      instanceId: 'InstanceId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      remark: 'Remark',
      scheduleDomainName: 'ScheduleDomainName',
      scheduleZoneName: 'ScheduleZoneName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      availableStatus: 'string',
      clientToken: 'string',
      enableStatus: 'string',
      healthStatus: 'string',
      instanceId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      remark: 'string',
      scheduleDomainName: 'string',
      scheduleZoneName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchCloudGtmInstanceConfigsResponseBody extends $tea.Model {
  instanceConfigs?: SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigs;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @example
   * 6AEC7A64-3CB1-4C49-8B35-0B901F1E26BF
   */
  requestId?: string;
  /**
   * @example
   * 15
   */
  totalItems?: number;
  /**
   * @example
   * 1
   */
  totalPages?: number;
  static names(): { [key: string]: string } {
    return {
      instanceConfigs: 'InstanceConfigs',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalItems: 'TotalItems',
      totalPages: 'TotalPages',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceConfigs: SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigs,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalItems: 'number',
      totalPages: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchCloudGtmInstanceConfigsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SearchCloudGtmInstanceConfigsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SearchCloudGtmInstanceConfigsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchCloudGtmInstancesRequest extends $tea.Model {
  /**
   * @example
   * en-US
   */
  acceptLanguage?: string;
  /**
   * @example
   * 1ae05db4-10e7-11ef-b126-00163e24**22
   */
  clientToken?: string;
  /**
   * @example
   * gtm-cn-wwo3a3hbz**
   */
  instanceId?: string;
  /**
   * @example
   * test
   */
  instanceName?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 20
   */
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      clientToken: 'ClientToken',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      clientToken: 'string',
      instanceId: 'string',
      instanceName: 'string',
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchCloudGtmInstancesResponseBody extends $tea.Model {
  instances?: SearchCloudGtmInstancesResponseBodyInstances;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @example
   * 6856BCF6-11D6-4D7E-AC53-FD579933522B
   */
  requestId?: string;
  /**
   * @example
   * 10
   */
  totalItems?: number;
  /**
   * @example
   * 1
   */
  totalPages?: number;
  static names(): { [key: string]: string } {
    return {
      instances: 'Instances',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalItems: 'TotalItems',
      totalPages: 'TotalPages',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instances: SearchCloudGtmInstancesResponseBodyInstances,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalItems: 'number',
      totalPages: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchCloudGtmInstancesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SearchCloudGtmInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SearchCloudGtmInstancesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchCloudGtmMonitorTemplatesRequest extends $tea.Model {
  /**
   * @example
   * en-US
   */
  acceptLanguage?: string;
  /**
   * @example
   * IPv4
   */
  ipVersion?: string;
  /**
   * @example
   * IPv4-Ping
   */
  name?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @example
   * ping
   */
  protocol?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      ipVersion: 'IpVersion',
      name: 'Name',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      protocol: 'Protocol',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      ipVersion: 'string',
      name: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      protocol: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchCloudGtmMonitorTemplatesResponseBody extends $tea.Model {
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @example
   * 536E9CAD-DB30-4647-AC87-AA5CC38C5382
   */
  requestId?: string;
  templates?: SearchCloudGtmMonitorTemplatesResponseBodyTemplates;
  /**
   * @example
   * 1
   */
  totalItems?: number;
  /**
   * @example
   * 1
   */
  totalPages?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      templates: 'Templates',
      totalItems: 'TotalItems',
      totalPages: 'TotalPages',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      templates: SearchCloudGtmMonitorTemplatesResponseBodyTemplates,
      totalItems: 'number',
      totalPages: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchCloudGtmMonitorTemplatesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SearchCloudGtmMonitorTemplatesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SearchCloudGtmMonitorTemplatesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDNSSLBStatusRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The language.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The DNS resolution line. The line can be the default line, China Telecom, and China Mobile.
   * 
   * @example
   * China Mobile.
   */
  line?: string;
  /**
   * @remarks
   * Specifies whether to enable or disable weighted round-robin. Valid values:
   * 
   * *   **true** (default): enables weighted round-robin.
   * *   **false**: disables weighted round-robin.
   * 
   * @example
   * true
   */
  open?: boolean;
  /**
   * @remarks
   * The subdomain name for which you want to enable weighted round-robin. Set the parameter to @.example.com instead of example.com.
   * 
   * This parameter is required.
   * 
   * @example
   * www.example.com
   */
  subDomain?: string;
  /**
   * @remarks
   * The type of the Domain Name System (DNS) record. Valid values: A and AAAA. Default value: A.
   * 
   * @example
   * A
   */
  type?: string;
  /**
   * @remarks
   * The IP address of the client.
   * 
   * @example
   * 192.0.2.0
   */
  userClientIp?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      lang: 'Lang',
      line: 'Line',
      open: 'Open',
      subDomain: 'SubDomain',
      type: 'Type',
      userClientIp: 'UserClientIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      lang: 'string',
      line: 'string',
      open: 'boolean',
      subDomain: 'string',
      type: 'string',
      userClientIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDNSSLBStatusResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether weighted round-robin is enabled for the subdomain name.
   * 
   * @example
   * true
   */
  open?: boolean;
  /**
   * @remarks
   * The number of A records that are matched.
   * 
   * @example
   * 8
   */
  recordCount?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 536E9CAD-DB30-4647-AC87-AA5CC38C5382
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      open: 'Open',
      recordCount: 'RecordCount',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      open: 'boolean',
      recordCount: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDNSSLBStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SetDNSSLBStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetDNSSLBStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDnsGtmAccessModeRequest extends $tea.Model {
  /**
   * @remarks
   * The primary/secondary switchover policy for address pool groups. Valid values:
   * 
   * *   AUTO: performs automatic switchover between the primary and secondary address pool groups upon failures.
   * *   DEFAULT: uses the primary address pool group.
   * *   FAILOVER: uses the secondary address pool group.
   * 
   * This parameter is required.
   * 
   * @example
   * auto
   */
  accessMode?: string;
  /**
   * @remarks
   * The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The ID of the policy.
   * 
   * This parameter is required.
   * 
   * @example
   * strategyId
   */
  strategyId?: string;
  static names(): { [key: string]: string } {
    return {
      accessMode: 'AccessMode',
      lang: 'Lang',
      strategyId: 'StrategyId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessMode: 'string',
      lang: 'string',
      strategyId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDnsGtmAccessModeResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 29D0F8F8-5499-4F6C-9FDC-1EE13BF55925
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDnsGtmAccessModeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SetDnsGtmAccessModeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetDnsGtmAccessModeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDnsGtmMonitorStatusRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the values for specific response parameters. Default value: en. Valid values: en, zh, and ja.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The ID of the health check task.
   * 
   * This parameter is required.
   * 
   * @example
   * MonitorConfigId1
   */
  monitorConfigId?: string;
  /**
   * @remarks
   * Specifies whether to enable the health check feature. Valid values:
   * 
   * *   OPEN: enables the health check feature.
   * *   CLOSE: disables the health check feature.
   * 
   * This parameter is required.
   * 
   * @example
   * open
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      monitorConfigId: 'MonitorConfigId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      monitorConfigId: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDnsGtmMonitorStatusResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 6856BCF6-11D6-4D7E-AC53-FD579933522B
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDnsGtmMonitorStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SetDnsGtmMonitorStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetDnsGtmMonitorStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDomainDnssecStatusRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name for which you want to set the DNSSEC status.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The language in which you want the values of some response parameters to be returned. These response parameters support multiple languages. Default value: en. Valid values: en, zh, and ja.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The DNSSEC status. Valid values:
   * 
   * *   ON: enables DNSSEC for the domain name.
   * *   OFF: disables DNSSEC for the domain name.
   * 
   * This parameter is required.
   * 
   * @example
   * ON
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      lang: 'Lang',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      lang: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDomainDnssecStatusResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 536E9CAD-DB30-4647-AC87-AA5CC38C5382
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDomainDnssecStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SetDomainDnssecStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetDomainDnssecStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDomainRecordStatusRequest extends $tea.Model {
  /**
   * @remarks
   * The language.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The ID of the DNS record.
   * 
   * This parameter is required.
   * 
   * @example
   * 9999985
   */
  recordId?: string;
  /**
   * @remarks
   * The state of the DNS record. Valid values:
   * 
   * *   **Enable**: enables the DNS record.
   * *   **Disable**: disables the DNS record.
   * 
   * This parameter is required.
   * 
   * @example
   * Disable
   */
  status?: string;
  /**
   * @remarks
   * The IP address of the client.
   * 
   * @example
   * 192.0.2.0
   */
  userClientIp?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      recordId: 'RecordId',
      status: 'Status',
      userClientIp: 'UserClientIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      recordId: 'string',
      status: 'string',
      userClientIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDomainRecordStatusResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the DNS record.
   * 
   * @example
   * 9999985
   */
  recordId?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 536E9CAD-DB30-4647-AC87-AA5CC38C5382
   */
  requestId?: string;
  /**
   * @remarks
   * The status of the DNS record.
   * 
   * @example
   * Disable
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      recordId: 'RecordId',
      requestId: 'RequestId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      recordId: 'string',
      requestId: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDomainRecordStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SetDomainRecordStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetDomainRecordStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetGtmAccessModeRequest extends $tea.Model {
  /**
   * @remarks
   * The target access policy of the GTM instance. Valid values:
   * 
   * *   **AUTO**: Automatic switch
   * *   **DEFAULT**: Default address pool
   * *   **FAILOVER**: Failover address pool
   * 
   * This parameter is required.
   * 
   * @example
   * AUTO
   */
  accessMode?: string;
  /**
   * @remarks
   * The language used by the user.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The ID of the access policy.
   * 
   * This parameter is required.
   * 
   * @example
   * hra0hx
   */
  strategyId?: string;
  static names(): { [key: string]: string } {
    return {
      accessMode: 'AccessMode',
      lang: 'Lang',
      strategyId: 'StrategyId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessMode: 'string',
      lang: 'string',
      strategyId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetGtmAccessModeResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 29D0F8F8-5499-4F6C-9FDC-1EE13BF55925
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetGtmAccessModeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SetGtmAccessModeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetGtmAccessModeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetGtmMonitorStatusRequest extends $tea.Model {
  /**
   * @remarks
   * The language used by the user.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The health check ID.
   * 
   * This parameter is required.
   * 
   * @example
   * abc1234
   */
  monitorConfigId?: string;
  /**
   * @remarks
   * Specifies whether health check is enabled for the address pool. Valid values:
   * 
   * *   **OPEN**: Enabled
   * *   **CLOSE**: Disabled
   * 
   * This parameter is required.
   * 
   * @example
   * OPEN
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      monitorConfigId: 'MonitorConfigId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      monitorConfigId: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetGtmMonitorStatusResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 6856BCF6-11D6-4D7E-AC53-FD579933522B
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetGtmMonitorStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SetGtmMonitorStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetGtmMonitorStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitIspFlushCacheTaskRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   */
  clientToken?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  domainName?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  isp?: string[];
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      clientToken: 'ClientToken',
      domainName: 'DomainName',
      isp: 'Isp',
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clientToken: 'string',
      domainName: 'string',
      isp: { 'type': 'array', 'itemType': 'string' },
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitIspFlushCacheTaskResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitIspFlushCacheTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SubmitIspFlushCacheTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SubmitIspFlushCacheTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SwitchDnsGtmInstanceStrategyModeRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the GTM instance.
   * 
   * This parameter is required.
   * 
   * @example
   * instance1
   */
  instanceId?: string;
  /**
   * @remarks
   * The language of the values of specific response parameters. Default value: en. Valid values: en, zh, and ja.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The access policy type. Valid values:
   * 
   * *   GEO: geographical location-based
   * *   LATENCY: latency-based
   * 
   * This parameter is required.
   * 
   * @example
   * GEO
   */
  strategyMode?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      lang: 'Lang',
      strategyMode: 'StrategyMode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      lang: 'string',
      strategyMode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SwitchDnsGtmInstanceStrategyModeResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 6856BCF6-11D6-4D7E-AC53-FD579933522B
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SwitchDnsGtmInstanceStrategyModeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SwitchDnsGtmInstanceStrategyModeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SwitchDnsGtmInstanceStrategyModeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TagResourcesRequest extends $tea.Model {
  /**
   * @remarks
   * The language.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The resource ID.
   * 
   * This parameter is required.
   * 
   * @example
   * dns-example.com
   */
  resourceId?: string[];
  /**
   * @remarks
   * The resource type.
   * 
   * This parameter is required.
   * 
   * @example
   * DOMAIN
   */
  resourceType?: string;
  /**
   * @remarks
   * The tag to add to the resource.
   * 
   * This parameter is required.
   */
  tag?: TagResourcesRequestTag[];
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      resourceId: 'ResourceId',
      resourceType: 'ResourceType',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      resourceId: { 'type': 'array', 'itemType': 'string' },
      resourceType: 'string',
      tag: { 'type': 'array', 'itemType': TagResourcesRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TagResourcesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 635B0CCD-15A7-48C9-B4D6-628FF57FF4B8
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TagResourcesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: TagResourcesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: TagResourcesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TransferDomainRequest extends $tea.Model {
  /**
   * @remarks
   * The domain names. Separate multiple domain names with commas (,). Only domain names registered with Alibaba Cloud are supported.
   * 
   * This parameter is required.
   * 
   * @example
   * test1.com,test2.com
   */
  domainNames?: string;
  /**
   * @remarks
   * The language of the content within the request and response. Default value: **zh**. Valid values:
   * 
   * *   **zh**: Chinese
   * *   **en**: English
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The description of the domain name.
   * 
   * @example
   * test domain transfer
   */
  remark?: string;
  /**
   * @remarks
   * The destination user ID. The domain names and their Domain Name System (DNS) records are transferred to the destination user ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 12345678
   */
  targetUserId?: number;
  static names(): { [key: string]: string } {
    return {
      domainNames: 'DomainNames',
      lang: 'Lang',
      remark: 'Remark',
      targetUserId: 'TargetUserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainNames: 'string',
      lang: 'string',
      remark: 'string',
      targetUserId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TransferDomainResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 536E9CAD-DB30-4647-AC87-AA5CC38C5382
   */
  requestId?: string;
  /**
   * @remarks
   * The task ID.
   * 
   * @example
   * 112233
   */
  taskId?: number;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      taskId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TransferDomainResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: TransferDomainResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: TransferDomainResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnbindInstanceDomainsRequest extends $tea.Model {
  /**
   * @remarks
   * The domain names.
   * 
   * Separate multiple domain names with commas (,). Up to 100 domain names can be entered.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com,example.net
   */
  domainNames?: string;
  /**
   * @remarks
   * The instance ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 123
   */
  instanceId?: string;
  /**
   * @remarks
   * The language.
   * 
   * @example
   * en
   */
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      domainNames: 'DomainNames',
      instanceId: 'InstanceId',
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainNames: 'string',
      instanceId: 'string',
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnbindInstanceDomainsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The number of domain names that failed to be unbound from the instance.
   * 
   * @example
   * 0
   */
  failedCount?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 123
   */
  requestId?: string;
  /**
   * @remarks
   * The number of domain names that are unbound from the instance.
   * 
   * @example
   * 2
   */
  successCount?: number;
  static names(): { [key: string]: string } {
    return {
      failedCount: 'FailedCount',
      requestId: 'RequestId',
      successCount: 'SuccessCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failedCount: 'number',
      requestId: 'string',
      successCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnbindInstanceDomainsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UnbindInstanceDomainsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UnbindInstanceDomainsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UntagResourcesRequest extends $tea.Model {
  /**
   * @remarks
   * Specifies whether to remove all tags. Default value: false. This parameter is valid only when TagKey is left empty. Valid values: true and false.
   * 
   * @example
   * false
   */
  all?: boolean;
  /**
   * @remarks
   * The language.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The resource ID.
   * 
   * This parameter is required.
   * 
   * @example
   * The type of the resource.
   */
  resourceId?: string[];
  /**
   * @remarks
   * The resource type.
   * 
   * This parameter is required.
   * 
   * @example
   * DOMAIN
   */
  resourceType?: string;
  /**
   * @remarks
   * The tags added to the resource.
   * 
   * @example
   * The domain name.
   */
  tagKey?: string[];
  static names(): { [key: string]: string } {
    return {
      all: 'All',
      lang: 'Lang',
      resourceId: 'ResourceId',
      resourceType: 'ResourceType',
      tagKey: 'TagKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      all: 'boolean',
      lang: 'string',
      resourceId: { 'type': 'array', 'itemType': 'string' },
      resourceType: 'string',
      tagKey: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UntagResourcesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * F152A869-DF77-4DF1-9A00-4E06978FE6A1
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UntagResourcesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UntagResourcesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UntagResourcesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateAppKeyStateRequest extends $tea.Model {
  appKeyId?: string;
  lang?: string;
  state?: string;
  static names(): { [key: string]: string } {
    return {
      appKeyId: 'AppKeyId',
      lang: 'Lang',
      state: 'State',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appKeyId: 'string',
      lang: 'string',
      state: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateAppKeyStateResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateAppKeyStateResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateAppKeyStateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateAppKeyStateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCloudGtmAddressRequest extends $tea.Model {
  /**
   * @example
   * en-US
   */
  acceptLanguage?: string;
  /**
   * @example
   * 223.5.XX.XX
   */
  address?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * addr-89518218114368**92
   */
  addressId?: string;
  attributeInfo?: string;
  /**
   * @example
   * 1ae05db4-10e7-11ef-b126-00163e24**22
   */
  clientToken?: string;
  /**
   * @example
   * p50_ok
   */
  healthJudgement?: string;
  healthTasks?: UpdateCloudGtmAddressRequestHealthTasks[];
  /**
   * @example
   * Address-1
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      address: 'Address',
      addressId: 'AddressId',
      attributeInfo: 'AttributeInfo',
      clientToken: 'ClientToken',
      healthJudgement: 'HealthJudgement',
      healthTasks: 'HealthTasks',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      address: 'string',
      addressId: 'string',
      attributeInfo: 'string',
      clientToken: 'string',
      healthJudgement: 'string',
      healthTasks: { 'type': 'array', 'itemType': UpdateCloudGtmAddressRequestHealthTasks },
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCloudGtmAddressShrinkRequest extends $tea.Model {
  /**
   * @example
   * en-US
   */
  acceptLanguage?: string;
  /**
   * @example
   * 223.5.XX.XX
   */
  address?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * addr-89518218114368**92
   */
  addressId?: string;
  attributeInfo?: string;
  /**
   * @example
   * 1ae05db4-10e7-11ef-b126-00163e24**22
   */
  clientToken?: string;
  /**
   * @example
   * p50_ok
   */
  healthJudgement?: string;
  healthTasksShrink?: string;
  /**
   * @example
   * Address-1
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      address: 'Address',
      addressId: 'AddressId',
      attributeInfo: 'AttributeInfo',
      clientToken: 'ClientToken',
      healthJudgement: 'HealthJudgement',
      healthTasksShrink: 'HealthTasks',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      address: 'string',
      addressId: 'string',
      attributeInfo: 'string',
      clientToken: 'string',
      healthJudgement: 'string',
      healthTasksShrink: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCloudGtmAddressResponseBody extends $tea.Model {
  /**
   * @example
   * 6856BCF6-11D6-4D7E-AC53-FD579933522B
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCloudGtmAddressResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateCloudGtmAddressResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateCloudGtmAddressResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCloudGtmAddressEnableStatusRequest extends $tea.Model {
  /**
   * @example
   * en-US
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * addr-89518218114368**92
   */
  addressId?: string;
  /**
   * @example
   * 1ae05db4-10e7-11ef-b126-00163e24**22
   */
  clientToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * enable
   */
  enableStatus?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      addressId: 'AddressId',
      clientToken: 'ClientToken',
      enableStatus: 'EnableStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      addressId: 'string',
      clientToken: 'string',
      enableStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCloudGtmAddressEnableStatusResponseBody extends $tea.Model {
  /**
   * @example
   * 536E9CAD-DB30-4647-AC87-AA5CC38C5382
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCloudGtmAddressEnableStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateCloudGtmAddressEnableStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateCloudGtmAddressEnableStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCloudGtmAddressManualAvailableStatusRequest extends $tea.Model {
  /**
   * @example
   * en-US
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * addr-89518218114368**92
   */
  addressId?: string;
  /**
   * @example
   * manual
   */
  availableMode?: string;
  /**
   * @example
   * 1ae05db4-10e7-11ef-b126-00163e24**22
   */
  clientToken?: string;
  /**
   * @example
   * available
   */
  manualAvailableStatus?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      addressId: 'AddressId',
      availableMode: 'AvailableMode',
      clientToken: 'ClientToken',
      manualAvailableStatus: 'ManualAvailableStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      addressId: 'string',
      availableMode: 'string',
      clientToken: 'string',
      manualAvailableStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCloudGtmAddressManualAvailableStatusResponseBody extends $tea.Model {
  /**
   * @example
   * 0F32959D-417B-4D66-8463-68606605E3E2
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCloudGtmAddressManualAvailableStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateCloudGtmAddressManualAvailableStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateCloudGtmAddressManualAvailableStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCloudGtmAddressPoolBasicConfigRequest extends $tea.Model {
  /**
   * @example
   * en-US
   */
  acceptLanguage?: string;
  /**
   * @example
   * pool-89528023225442**16
   */
  addressPoolId?: string;
  /**
   * @example
   * app
   */
  addressPoolName?: string;
  /**
   * @example
   * 1ae05db4-10e7-11ef-b126-00163e24**22
   */
  clientToken?: string;
  /**
   * @example
   * any_ok
   */
  healthJudgement?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      addressPoolId: 'AddressPoolId',
      addressPoolName: 'AddressPoolName',
      clientToken: 'ClientToken',
      healthJudgement: 'HealthJudgement',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      addressPoolId: 'string',
      addressPoolName: 'string',
      clientToken: 'string',
      healthJudgement: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCloudGtmAddressPoolBasicConfigResponseBody extends $tea.Model {
  /**
   * @example
   * pool-89528023225442**16
   */
  addressPoolId?: string;
  /**
   * @example
   * 536E9CAD-DB30-4647-AC87-AA5CC38C5382
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      addressPoolId: 'AddressPoolId',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addressPoolId: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCloudGtmAddressPoolBasicConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateCloudGtmAddressPoolBasicConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateCloudGtmAddressPoolBasicConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCloudGtmAddressPoolEnableStatusRequest extends $tea.Model {
  /**
   * @example
   * en-US
   */
  acceptLanguage?: string;
  /**
   * @example
   * pool-89528023225442**16
   */
  addressPoolId?: string;
  /**
   * @example
   * 1ae05db4-10e7-11ef-b126-00163e24**22
   */
  clientToken?: string;
  /**
   * @example
   * enable
   */
  enableStatus?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      addressPoolId: 'AddressPoolId',
      clientToken: 'ClientToken',
      enableStatus: 'EnableStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      addressPoolId: 'string',
      clientToken: 'string',
      enableStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCloudGtmAddressPoolEnableStatusResponseBody extends $tea.Model {
  /**
   * @example
   * pool-89528023225442**16
   */
  addressPoolId?: string;
  /**
   * @example
   * 89184F33-48A1-4401-9C0F-40E45DB091AB
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      addressPoolId: 'AddressPoolId',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addressPoolId: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCloudGtmAddressPoolEnableStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateCloudGtmAddressPoolEnableStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateCloudGtmAddressPoolEnableStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCloudGtmAddressPoolLbStrategyRequest extends $tea.Model {
  /**
   * @example
   * en-US
   */
  acceptLanguage?: string;
  /**
   * @example
   * sequence
   */
  addressLbStrategy?: string;
  /**
   * @example
   * pool-89528023225442**16
   */
  addressPoolId?: string;
  /**
   * @example
   * 1ae05db4-10e7-11ef-b126-00163e24**22
   */
  clientToken?: string;
  /**
   * @example
   * preemptive
   */
  sequenceLbStrategyMode?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      addressLbStrategy: 'AddressLbStrategy',
      addressPoolId: 'AddressPoolId',
      clientToken: 'ClientToken',
      sequenceLbStrategyMode: 'SequenceLbStrategyMode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      addressLbStrategy: 'string',
      addressPoolId: 'string',
      clientToken: 'string',
      sequenceLbStrategyMode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCloudGtmAddressPoolLbStrategyResponseBody extends $tea.Model {
  /**
   * @example
   * pool-89528023225442**16
   */
  addressPoolId?: string;
  /**
   * @example
   * B57C121B-A45F-44D8-A9B2-13E5A5044195
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      addressPoolId: 'AddressPoolId',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addressPoolId: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCloudGtmAddressPoolLbStrategyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateCloudGtmAddressPoolLbStrategyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateCloudGtmAddressPoolLbStrategyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCloudGtmAddressPoolRemarkRequest extends $tea.Model {
  /**
   * @example
   * en-US
   */
  acceptLanguage?: string;
  /**
   * @example
   * pool-89528023225442**16
   */
  addressPoolId?: string;
  /**
   * @example
   * 1ae05db4-10e7-11ef-b126-00163e24**22
   */
  clientToken?: string;
  /**
   * @example
   * test
   */
  remark?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      addressPoolId: 'AddressPoolId',
      clientToken: 'ClientToken',
      remark: 'Remark',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      addressPoolId: 'string',
      clientToken: 'string',
      remark: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCloudGtmAddressPoolRemarkResponseBody extends $tea.Model {
  /**
   * @example
   * pool-89528023225442**16
   */
  addressPoolId?: string;
  /**
   * @example
   * 536E9CAD-DB30-4647-AC87-AA5CC38C5382
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      addressPoolId: 'AddressPoolId',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addressPoolId: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCloudGtmAddressPoolRemarkResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateCloudGtmAddressPoolRemarkResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateCloudGtmAddressPoolRemarkResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCloudGtmAddressRemarkRequest extends $tea.Model {
  /**
   * @example
   * en-US
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * addr-89518218114368**92
   */
  addressId?: string;
  /**
   * @example
   * 1ae05db4-10e7-11ef-b126-00163e24**22
   */
  clientToken?: string;
  /**
   * @example
   * test
   */
  remark?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      addressId: 'AddressId',
      clientToken: 'ClientToken',
      remark: 'Remark',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      addressId: 'string',
      clientToken: 'string',
      remark: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCloudGtmAddressRemarkResponseBody extends $tea.Model {
  /**
   * @example
   * B57C121B-A45F-44D8-A9B2-13E5A5044195
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCloudGtmAddressRemarkResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateCloudGtmAddressRemarkResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateCloudGtmAddressRemarkResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCloudGtmGlobalAlertRequest extends $tea.Model {
  /**
   * @example
   * en-US
   */
  acceptLanguage?: string;
  alertConfig?: UpdateCloudGtmGlobalAlertRequestAlertConfig[];
  alertGroup?: string[];
  /**
   * @example
   * 1ae05db4-10e7-11ef-b126-00163e24**22
   */
  clientToken?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      alertConfig: 'AlertConfig',
      alertGroup: 'AlertGroup',
      clientToken: 'ClientToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      alertConfig: { 'type': 'array', 'itemType': UpdateCloudGtmGlobalAlertRequestAlertConfig },
      alertGroup: { 'type': 'array', 'itemType': 'string' },
      clientToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCloudGtmGlobalAlertShrinkRequest extends $tea.Model {
  /**
   * @example
   * en-US
   */
  acceptLanguage?: string;
  alertConfigShrink?: string;
  alertGroupShrink?: string;
  /**
   * @example
   * 1ae05db4-10e7-11ef-b126-00163e24**22
   */
  clientToken?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      alertConfigShrink: 'AlertConfig',
      alertGroupShrink: 'AlertGroup',
      clientToken: 'ClientToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      alertConfigShrink: 'string',
      alertGroupShrink: 'string',
      clientToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCloudGtmGlobalAlertResponseBody extends $tea.Model {
  /**
   * @example
   * B57C121B-A45F-44D8-A9B2-13E5A5044195
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCloudGtmGlobalAlertResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateCloudGtmGlobalAlertResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateCloudGtmGlobalAlertResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCloudGtmInstanceConfigAlertRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh-CN: Chinese
   * *   en-US: English
   * 
   * @example
   * zh-CN
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The alert configurations.
   */
  alertConfig?: UpdateCloudGtmInstanceConfigAlertRequestAlertConfig[];
  /**
   * @remarks
   * The alert contact groups.
   */
  alertGroup?: string[];
  /**
   * @remarks
   * The alert configuration mode of the instance. Valid values:
   * 
   * *   global: global alert configuration
   * *   instance_config: custom alert configuration
   * 
   * @example
   * global
   */
  alertMode?: string;
  /**
   * @remarks
   * The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
   * 
   * @example
   * 1ae05db4-10e7-11ef-b126-00163e24**22
   */
  clientToken?: string;
  /**
   * @remarks
   * The configuration ID of the access domain name. Two configuration IDs exist when an A record and an AAAA record are configured for the access domain name that is bound to the GTM instance. This ID uniquely identifies a configuration.
   * 
   * @example
   * Config-000**11
   */
  configId?: string;
  /**
   * @remarks
   * The ID of the Global Traffic Manager (GTM) 3.0 instance.
   * 
   * @example
   * gtm-cn-zz11t58**0s
   */
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      alertConfig: 'AlertConfig',
      alertGroup: 'AlertGroup',
      alertMode: 'AlertMode',
      clientToken: 'ClientToken',
      configId: 'ConfigId',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      alertConfig: { 'type': 'array', 'itemType': UpdateCloudGtmInstanceConfigAlertRequestAlertConfig },
      alertGroup: { 'type': 'array', 'itemType': 'string' },
      alertMode: 'string',
      clientToken: 'string',
      configId: 'string',
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCloudGtmInstanceConfigAlertShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   zh-CN: Chinese
   * *   en-US: English
   * 
   * @example
   * zh-CN
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The alert configurations.
   */
  alertConfigShrink?: string;
  /**
   * @remarks
   * The alert contact groups.
   */
  alertGroupShrink?: string;
  /**
   * @remarks
   * The alert configuration mode of the instance. Valid values:
   * 
   * *   global: global alert configuration
   * *   instance_config: custom alert configuration
   * 
   * @example
   * global
   */
  alertMode?: string;
  /**
   * @remarks
   * The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
   * 
   * @example
   * 1ae05db4-10e7-11ef-b126-00163e24**22
   */
  clientToken?: string;
  /**
   * @remarks
   * The configuration ID of the access domain name. Two configuration IDs exist when an A record and an AAAA record are configured for the access domain name that is bound to the GTM instance. This ID uniquely identifies a configuration.
   * 
   * @example
   * Config-000**11
   */
  configId?: string;
  /**
   * @remarks
   * The ID of the Global Traffic Manager (GTM) 3.0 instance.
   * 
   * @example
   * gtm-cn-zz11t58**0s
   */
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      alertConfigShrink: 'AlertConfig',
      alertGroupShrink: 'AlertGroup',
      alertMode: 'AlertMode',
      clientToken: 'ClientToken',
      configId: 'ConfigId',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      alertConfigShrink: 'string',
      alertGroupShrink: 'string',
      alertMode: 'string',
      clientToken: 'string',
      configId: 'string',
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCloudGtmInstanceConfigAlertResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 536E9CAD-DB30-4647-AC87-AA5CC38C5382
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCloudGtmInstanceConfigAlertResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateCloudGtmInstanceConfigAlertResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateCloudGtmInstanceConfigAlertResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCloudGtmInstanceConfigBasicRequest extends $tea.Model {
  /**
   * @example
   * en-US
   */
  acceptLanguage?: string;
  /**
   * @example
   * 1ae05db4-10e7-11ef-b126-00163e24**22
   */
  clientToken?: string;
  /**
   * @example
   * Config-000**11
   */
  configId?: string;
  /**
   * @example
   * gtm-cn-wwo3a3hbz**
   */
  instanceId?: string;
  /**
   * @example
   * www
   */
  scheduleHostname?: string;
  /**
   * @example
   * example.com
   */
  scheduleZoneName?: string;
  ttl?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      clientToken: 'ClientToken',
      configId: 'ConfigId',
      instanceId: 'InstanceId',
      scheduleHostname: 'ScheduleHostname',
      scheduleZoneName: 'ScheduleZoneName',
      ttl: 'Ttl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      clientToken: 'string',
      configId: 'string',
      instanceId: 'string',
      scheduleHostname: 'string',
      scheduleZoneName: 'string',
      ttl: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCloudGtmInstanceConfigBasicResponseBody extends $tea.Model {
  /**
   * @example
   * 6856BCF6-11D6-4D7E-AC53-FD579933522B
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCloudGtmInstanceConfigBasicResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateCloudGtmInstanceConfigBasicResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateCloudGtmInstanceConfigBasicResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCloudGtmInstanceConfigEnableStatusRequest extends $tea.Model {
  /**
   * @example
   * zh-CN
   */
  acceptLanguage?: string;
  /**
   * @example
   * 1ae05db4-10e7-11ef-b126-00163e24**22
   */
  clientToken?: string;
  /**
   * @example
   * Config-000**11
   */
  configId?: string;
  /**
   * @example
   * enable
   */
  enableStatus?: string;
  /**
   * @example
   * gtm-cn-wwo3a3hbz**
   */
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      clientToken: 'ClientToken',
      configId: 'ConfigId',
      enableStatus: 'EnableStatus',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      clientToken: 'string',
      configId: 'string',
      enableStatus: 'string',
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCloudGtmInstanceConfigEnableStatusResponseBody extends $tea.Model {
  /**
   * @example
   * 29D0F8F8-5499-4F6C-9FDC-1EE13BF55925
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCloudGtmInstanceConfigEnableStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateCloudGtmInstanceConfigEnableStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateCloudGtmInstanceConfigEnableStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCloudGtmInstanceConfigLbStrategyRequest extends $tea.Model {
  /**
   * @example
   * en-US
   */
  acceptLanguage?: string;
  /**
   * @example
   * sequence
   */
  addressPoolLbStrategy?: string;
  /**
   * @example
   * 1ae05db4-10e7-11ef-b126-00163e24**22
   */
  clientToken?: string;
  /**
   * @example
   * Config-000**11
   */
  configId?: string;
  /**
   * @example
   * gtm-cn-wwo3a3hbz**
   */
  instanceId?: string;
  /**
   * @example
   * preemptive
   */
  sequenceLbStrategyMode?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      addressPoolLbStrategy: 'AddressPoolLbStrategy',
      clientToken: 'ClientToken',
      configId: 'ConfigId',
      instanceId: 'InstanceId',
      sequenceLbStrategyMode: 'SequenceLbStrategyMode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      addressPoolLbStrategy: 'string',
      clientToken: 'string',
      configId: 'string',
      instanceId: 'string',
      sequenceLbStrategyMode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCloudGtmInstanceConfigLbStrategyResponseBody extends $tea.Model {
  /**
   * @example
   * 0F32959D-417B-4D66-8463-68606605E3E2
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCloudGtmInstanceConfigLbStrategyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateCloudGtmInstanceConfigLbStrategyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateCloudGtmInstanceConfigLbStrategyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCloudGtmInstanceConfigRemarkRequest extends $tea.Model {
  /**
   * @example
   * en-US
   */
  acceptLanguage?: string;
  /**
   * @example
   * 1ae05db4-10e7-11ef-b126-00163e24**22
   */
  clientToken?: string;
  /**
   * @example
   * Config-000**11
   */
  configId?: string;
  /**
   * @example
   * gtm-cn-wwo3a3hbz**
   */
  instanceId?: string;
  /**
   * @example
   * API
   */
  remark?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      clientToken: 'ClientToken',
      configId: 'ConfigId',
      instanceId: 'InstanceId',
      remark: 'Remark',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      clientToken: 'string',
      configId: 'string',
      instanceId: 'string',
      remark: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCloudGtmInstanceConfigRemarkResponseBody extends $tea.Model {
  /**
   * @example
   * B57C121B-A45F-44D8-A9B2-13E5A5044195
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCloudGtmInstanceConfigRemarkResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateCloudGtmInstanceConfigRemarkResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateCloudGtmInstanceConfigRemarkResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCloudGtmInstanceNameRequest extends $tea.Model {
  /**
   * @example
   * en-US
   */
  acceptLanguage?: string;
  /**
   * @example
   * 1ae05db4-10e7-11ef-b126-00163e24**22
   */
  clientToken?: string;
  /**
   * @example
   * gtm-cn-jmp3qnw**03
   */
  instanceId?: string;
  /**
   * @example
   * test
   */
  instanceName?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      clientToken: 'ClientToken',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      clientToken: 'string',
      instanceId: 'string',
      instanceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCloudGtmInstanceNameResponseBody extends $tea.Model {
  /**
   * @example
   * 29D0F8F8-5499-4F6C-9FDC-1EE13BF55925
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCloudGtmInstanceNameResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateCloudGtmInstanceNameResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateCloudGtmInstanceNameResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCloudGtmMonitorTemplateRequest extends $tea.Model {
  /**
   * @example
   * en-US
   */
  acceptLanguage?: string;
  /**
   * @example
   * 1ae05db4-10e7-11ef-b126-00163e24**22
   */
  clientToken?: string;
  /**
   * @example
   * 2
   */
  evaluationCount?: number;
  /**
   * @example
   * {\\"code\\":200,\\"path\\":\\"\\\\index.htm\\",\\"host\\":\\"aliyun.com\\"}
   */
  extendInfo?: string;
  /**
   * @example
   * 50
   */
  failureRate?: number;
  /**
   * @example
   * 60
   */
  interval?: number;
  ispCityNodes?: UpdateCloudGtmMonitorTemplateRequestIspCityNodes[];
  /**
   * @example
   * Ping-IPv4
   */
  name?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * mtp-89518052425100**80
   */
  templateId?: string;
  /**
   * @example
   * 5000
   */
  timeout?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      clientToken: 'ClientToken',
      evaluationCount: 'EvaluationCount',
      extendInfo: 'ExtendInfo',
      failureRate: 'FailureRate',
      interval: 'Interval',
      ispCityNodes: 'IspCityNodes',
      name: 'Name',
      templateId: 'TemplateId',
      timeout: 'Timeout',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      clientToken: 'string',
      evaluationCount: 'number',
      extendInfo: 'string',
      failureRate: 'number',
      interval: 'number',
      ispCityNodes: { 'type': 'array', 'itemType': UpdateCloudGtmMonitorTemplateRequestIspCityNodes },
      name: 'string',
      templateId: 'string',
      timeout: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCloudGtmMonitorTemplateShrinkRequest extends $tea.Model {
  /**
   * @example
   * en-US
   */
  acceptLanguage?: string;
  /**
   * @example
   * 1ae05db4-10e7-11ef-b126-00163e24**22
   */
  clientToken?: string;
  /**
   * @example
   * 2
   */
  evaluationCount?: number;
  /**
   * @example
   * {\\"code\\":200,\\"path\\":\\"\\\\index.htm\\",\\"host\\":\\"aliyun.com\\"}
   */
  extendInfo?: string;
  /**
   * @example
   * 50
   */
  failureRate?: number;
  /**
   * @example
   * 60
   */
  interval?: number;
  ispCityNodesShrink?: string;
  /**
   * @example
   * Ping-IPv4
   */
  name?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * mtp-89518052425100**80
   */
  templateId?: string;
  /**
   * @example
   * 5000
   */
  timeout?: number;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      clientToken: 'ClientToken',
      evaluationCount: 'EvaluationCount',
      extendInfo: 'ExtendInfo',
      failureRate: 'FailureRate',
      interval: 'Interval',
      ispCityNodesShrink: 'IspCityNodes',
      name: 'Name',
      templateId: 'TemplateId',
      timeout: 'Timeout',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      clientToken: 'string',
      evaluationCount: 'number',
      extendInfo: 'string',
      failureRate: 'number',
      interval: 'number',
      ispCityNodesShrink: 'string',
      name: 'string',
      templateId: 'string',
      timeout: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCloudGtmMonitorTemplateResponseBody extends $tea.Model {
  /**
   * @example
   * 6856BCF6-11D6-4D7E-AC53-FD579933522B
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCloudGtmMonitorTemplateResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateCloudGtmMonitorTemplateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateCloudGtmMonitorTemplateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCloudGtmMonitorTemplateRemarkRequest extends $tea.Model {
  /**
   * @example
   * en-US
   */
  acceptLanguage?: string;
  /**
   * @example
   * 1ae05db4-10e7-11ef-b126-00163e24**22
   */
  clientToken?: string;
  /**
   * @example
   * test
   */
  remark?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * mtp-89518052455928**00
   */
  templateId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      clientToken: 'ClientToken',
      remark: 'Remark',
      templateId: 'TemplateId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      clientToken: 'string',
      remark: 'string',
      templateId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCloudGtmMonitorTemplateRemarkResponseBody extends $tea.Model {
  /**
   * @example
   * 6856BCF6-11D6-4D7E-AC53-FD579933522B
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCloudGtmMonitorTemplateRemarkResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateCloudGtmMonitorTemplateRemarkResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateCloudGtmMonitorTemplateRemarkResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCustomLineRequest extends $tea.Model {
  /**
   * @remarks
   * The CIDR blocks. Separate IP addresses with a hyphen (-). Enter a CIDR block in each row. You can enter 1 to 50 CIDR blocks at a time. If a CIDR block contains only one IP address, enter the IP address in the format of IP1-IP1. Different CIDR blocks cannot be overlapped.
   */
  ipSegment?: UpdateCustomLineRequestIpSegment[];
  /**
   * @remarks
   * The language.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The unique ID of the custom line.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  lineId?: number;
  /**
   * @remarks
   * The name of the custom line. The name must be 1 to 20 characters in length and can contain letters, digits, hyphens (-), and underscores (_).
   */
  lineName?: string;
  static names(): { [key: string]: string } {
    return {
      ipSegment: 'IpSegment',
      lang: 'Lang',
      lineId: 'LineId',
      lineName: 'LineName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ipSegment: { 'type': 'array', 'itemType': UpdateCustomLineRequestIpSegment },
      lang: 'string',
      lineId: 'number',
      lineName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCustomLineResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * B57C121B-A45F-44D8-A9B2-13E5A5044195
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCustomLineResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateCustomLineResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateCustomLineResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDNSSLBWeightRequest extends $tea.Model {
  /**
   * @remarks
   * The language.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The ID of the DNS record.
   * 
   * This parameter is required.
   * 
   * @example
   * 9999985
   */
  recordId?: string;
  /**
   * @remarks
   * The IP address of the client.
   * 
   * @example
   * 1.1.1.1
   */
  userClientIp?: string;
  /**
   * @remarks
   * The weight of the DNS record that you want to specify. Valid values: `1 to 100`.
   * 
   * This parameter is required.
   * 
   * @example
   * 2
   */
  weight?: number;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      recordId: 'RecordId',
      userClientIp: 'UserClientIp',
      weight: 'Weight',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      recordId: 'string',
      userClientIp: 'string',
      weight: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDNSSLBWeightResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the DNS record.
   * 
   * @example
   * 9999985
   */
  recordId?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 536E9CAD-DB30-4647-AC87-AA5CC38C5382
   */
  requestId?: string;
  /**
   * @remarks
   * The updated weight.
   * 
   * @example
   * 2
   */
  weight?: number;
  static names(): { [key: string]: string } {
    return {
      recordId: 'RecordId',
      requestId: 'RequestId',
      weight: 'Weight',
    };
  }

  static types(): { [key: string]: any } {
    return {
      recordId: 'string',
      requestId: 'string',
      weight: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDNSSLBWeightResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateDNSSLBWeightResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateDNSSLBWeightResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDnsCacheDomainRequest extends $tea.Model {
  /**
   * @remarks
   * The maximum TTL period of the cached data retrieved from the origin DNS server. Unit: seconds. Valid values: 30 to 86400.
   * 
   * @example
   * 86400
   */
  cacheTtlMax?: number;
  /**
   * @remarks
   * The minimum time-to-live (TTL) period of the cached data retrieved from the origin Domain Name System (DNS) server. Unit: seconds. Valid values: 30 to 86400.
   * 
   * @example
   * 30
   */
  cacheTtlMin?: number;
  /**
   * @remarks
   * The domain name.
   * 
   * This parameter is required.
   * 
   * @example
   * dns.example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The instance ID of the cache-accelerated domain name.
   * 
   * @example
   * dns-sg-l9u2ux1fw01
   */
  instanceId?: string;
  /**
   * @remarks
   * The language.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The origin DNS servers. A maximum of 10 origin DNS servers are supported.
   */
  sourceDnsServer?: UpdateDnsCacheDomainRequestSourceDnsServer[];
  /**
   * @remarks
   * Specifies whether the origin DNS server supports Extension Mechanisms for DNS (EDNS). Valid values: NOT_SUPPORT and SUPPORT.
   * 
   * @example
   * SUPPORT
   */
  sourceEdns?: string;
  /**
   * @remarks
   * The origin protocol policy. Valid values: TCP and UDP. Default value: UDP.
   * 
   * @example
   * UDP
   */
  sourceProtocol?: string;
  static names(): { [key: string]: string } {
    return {
      cacheTtlMax: 'CacheTtlMax',
      cacheTtlMin: 'CacheTtlMin',
      domainName: 'DomainName',
      instanceId: 'InstanceId',
      lang: 'Lang',
      sourceDnsServer: 'SourceDnsServer',
      sourceEdns: 'SourceEdns',
      sourceProtocol: 'SourceProtocol',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cacheTtlMax: 'number',
      cacheTtlMin: 'number',
      domainName: 'string',
      instanceId: 'string',
      lang: 'string',
      sourceDnsServer: { 'type': 'array', 'itemType': UpdateDnsCacheDomainRequestSourceDnsServer },
      sourceEdns: 'string',
      sourceProtocol: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDnsCacheDomainResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 536E9CAD-DB30-4647-AC87-AA5CC38C5382
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDnsCacheDomainResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateDnsCacheDomainResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateDnsCacheDomainResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDnsCacheDomainRemarkRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name.
   * 
   * This parameter is required.
   * 
   * @example
   * dns-example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The language.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The remarks. The remarks can be up to 50 characters in length and can contain only letters, digits, periods (.), underscores (_), and hyphens (-).
   * 
   * @example
   * test
   */
  remark?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      lang: 'Lang',
      remark: 'Remark',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      lang: 'string',
      remark: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDnsCacheDomainRemarkResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 536E9CAD-DB30-4647-AC87-AA5CC38C5382
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDnsCacheDomainRemarkResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateDnsCacheDomainRemarkResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateDnsCacheDomainRemarkResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDnsGtmAccessStrategyRequest extends $tea.Model {
  /**
   * @remarks
   * The primary/secondary switchover policy for address pool sets. Valid values:
   * 
   * *   AUTO: performs automatic switchover between the primary and secondary address pool sets upon failures.
   * *   DEFAULT: the primary address pool set
   * *   FAILOVER: the secondary address pool set
   * 
   * @example
   * DEFAULT
   */
  accessMode?: string;
  /**
   * @remarks
   * The address pools in the primary address pool set.
   * 
   * This parameter is required.
   */
  defaultAddrPool?: UpdateDnsGtmAccessStrategyRequestDefaultAddrPool[];
  /**
   * @remarks
   * The type of the primary address pool. Valid values:
   * 
   * *   IPV4
   * *   IPV6
   * *   DOMAIN
   * 
   * This parameter is required.
   * 
   * @example
   * ipv4
   */
  defaultAddrPoolType?: string;
  /**
   * @remarks
   * Specifies whether to enable Domain Name System (DNS) resolution with optimal latency for the primary address pool set. Valid values:
   * 
   * *   OPEN
   * *   CLOSE
   * 
   * @example
   * open
   */
  defaultLatencyOptimization?: string;
  /**
   * @remarks
   * The load balancing policy of the primary address pool set. Valid values:
   * 
   * *   ALL_RR: returns all addresses.
   * *   RATIO: returns addresses by weight.
   * 
   * @example
   * all_rr
   */
  defaultLbaStrategy?: string;
  /**
   * @remarks
   * The maximum number of addresses returned from the primary address pool set.
   * 
   * @example
   * 1
   */
  defaultMaxReturnAddrNum?: number;
  /**
   * @remarks
   * The minimum number of available addresses in the primary address pool set.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  defaultMinAvailableAddrNum?: number;
  /**
   * @remarks
   * The address pools in the secondary address pool set. If no address pool exists in the secondary address pool set, set this parameter to EMPTY.
   */
  failoverAddrPool?: UpdateDnsGtmAccessStrategyRequestFailoverAddrPool[];
  /**
   * @remarks
   * The type of the secondary address pool. Valid values:
   * 
   * *   IPV4
   * *   IPV6
   * *   DOMAIN
   * 
   * @example
   * ipv4
   */
  failoverAddrPoolType?: string;
  /**
   * @remarks
   * Specifies whether to enable DNS resolution with optimal latency for the secondary address pool set. Valid values:
   * 
   * *   OPEN
   * *   CLOSE
   * 
   * @example
   * open
   */
  failoverLatencyOptimization?: string;
  /**
   * @remarks
   * The load balancing policy of the secondary address pool set. Valid values:
   * 
   * *   ALL_RR: returns all addresses.
   * *   RATIO: returns addresses by weight.
   * 
   * @example
   * all_rr
   */
  failoverLbaStrategy?: string;
  /**
   * @remarks
   * The maximum number of addresses returned from the secondary address pool set.
   * 
   * @example
   * 1
   */
  failoverMaxReturnAddrNum?: number;
  /**
   * @remarks
   * The minimum number of available addresses in the secondary address pool set.
   * 
   * @example
   * 1
   */
  failoverMinAvailableAddrNum?: number;
  /**
   * @remarks
   * The language of the values for specific response parameters. Default value: en. Valid values: en, zh, and ja.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The line codes of the source regions. Example: `["default", "drpeng"]`, which indicates the global line and Dr. Peng Group line.
   * 
   * @example
   * ["default", "drpeng"]
   */
  lines?: string;
  /**
   * @remarks
   * The ID of the access policy.
   * 
   * This parameter is required.
   * 
   * @example
   * StrategyId1
   */
  strategyId?: string;
  /**
   * @remarks
   * The name of the access policy.
   * 
   * This parameter is required.
   * 
   * @example
   * StrategyName1
   */
  strategyName?: string;
  static names(): { [key: string]: string } {
    return {
      accessMode: 'AccessMode',
      defaultAddrPool: 'DefaultAddrPool',
      defaultAddrPoolType: 'DefaultAddrPoolType',
      defaultLatencyOptimization: 'DefaultLatencyOptimization',
      defaultLbaStrategy: 'DefaultLbaStrategy',
      defaultMaxReturnAddrNum: 'DefaultMaxReturnAddrNum',
      defaultMinAvailableAddrNum: 'DefaultMinAvailableAddrNum',
      failoverAddrPool: 'FailoverAddrPool',
      failoverAddrPoolType: 'FailoverAddrPoolType',
      failoverLatencyOptimization: 'FailoverLatencyOptimization',
      failoverLbaStrategy: 'FailoverLbaStrategy',
      failoverMaxReturnAddrNum: 'FailoverMaxReturnAddrNum',
      failoverMinAvailableAddrNum: 'FailoverMinAvailableAddrNum',
      lang: 'Lang',
      lines: 'Lines',
      strategyId: 'StrategyId',
      strategyName: 'StrategyName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessMode: 'string',
      defaultAddrPool: { 'type': 'array', 'itemType': UpdateDnsGtmAccessStrategyRequestDefaultAddrPool },
      defaultAddrPoolType: 'string',
      defaultLatencyOptimization: 'string',
      defaultLbaStrategy: 'string',
      defaultMaxReturnAddrNum: 'number',
      defaultMinAvailableAddrNum: 'number',
      failoverAddrPool: { 'type': 'array', 'itemType': UpdateDnsGtmAccessStrategyRequestFailoverAddrPool },
      failoverAddrPoolType: 'string',
      failoverLatencyOptimization: 'string',
      failoverLbaStrategy: 'string',
      failoverMaxReturnAddrNum: 'number',
      failoverMinAvailableAddrNum: 'number',
      lang: 'string',
      lines: 'string',
      strategyId: 'string',
      strategyName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDnsGtmAccessStrategyResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 29D0F8F8-5499-4F6C-9FDC-1EE13BF55925
   */
  requestId?: string;
  /**
   * @remarks
   * The ID of the access policy.
   * 
   * @example
   * testStrategyId1
   */
  strategyId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      strategyId: 'StrategyId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      strategyId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDnsGtmAccessStrategyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateDnsGtmAccessStrategyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateDnsGtmAccessStrategyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDnsGtmAddressPoolRequest extends $tea.Model {
  /**
   * @remarks
   * The address pools.
   * 
   * This parameter is required.
   */
  addr?: UpdateDnsGtmAddressPoolRequestAddr[];
  /**
   * @remarks
   * The ID of the address pool.
   * 
   * This parameter is required.
   * 
   * @example
   * testpool1
   */
  addrPoolId?: string;
  /**
   * @remarks
   * The language of the values of specific response parameters. Default value: en. Valid values: en, zh, and ja.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The load balancing policy of the address pool. Valid values:
   * 
   * *   ALL_RR: returns all addresses.
   * *   RATIO: returns addresses by weight.
   * 
   * This parameter is required.
   * 
   * @example
   * all_rr
   */
  lbaStrategy?: string;
  /**
   * @remarks
   * The name of the address pool.
   * 
   * @example
   * testpoolname
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      addr: 'Addr',
      addrPoolId: 'AddrPoolId',
      lang: 'Lang',
      lbaStrategy: 'LbaStrategy',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addr: { 'type': 'array', 'itemType': UpdateDnsGtmAddressPoolRequestAddr },
      addrPoolId: 'string',
      lang: 'string',
      lbaStrategy: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDnsGtmAddressPoolResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 6856BCF6-11D6-4D7E-AC53-FD579933522B
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDnsGtmAddressPoolResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateDnsGtmAddressPoolResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateDnsGtmAddressPoolResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDnsGtmInstanceGlobalConfigRequest extends $tea.Model {
  alertConfig?: UpdateDnsGtmInstanceGlobalConfigRequestAlertConfig[];
  /**
   * @remarks
   * The name of the alert group in the JSON format.
   * 
   * @example
   * alertGroup1
   */
  alertGroup?: string;
  /**
   * @remarks
   * The type of the canonical name (CNAME).
   * 
   * *   Set the value to PUBLIC.
   * 
   * @example
   * public
   */
  cnameType?: string;
  /**
   * @remarks
   * Specifies whether to enable force updates. Valid values:
   * 
   * *   true: enables force update without a conflict alert.
   * *   false: disables force update. If a conflict occurs, the system displays an alert. null: This valid value of ForceUpdate provides the same information as the false value.
   * 
   * @example
   * true
   */
  forceUpdate?: boolean;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * instance1
   */
  instanceId?: string;
  /**
   * @remarks
   * The name of the instance. This parameter is required only for the first update.
   * 
   * @example
   * test
   */
  instanceName?: string;
  /**
   * @remarks
   * The language of the values of specific response parameters. Default value: en. Valid values: en, zh, and ja.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * Specifies whether to use a custom CNAME domain name or a CNAME domain name assigned by the system to access the instance over the Internet. Valid values:
   * 
   * *   SYSTEM_ASSIGN: a CNAME domain name assigned by the system
   * *   CUSTOM: a custom CNAME domain name
   * 
   * @example
   * custom
   */
  publicCnameMode?: string;
  /**
   * @remarks
   * The hostname corresponding to the CNAME domain name that is used to access the instance over the Internet.
   * 
   * @example
   * test.rr
   */
  publicRr?: string;
  /**
   * @remarks
   * The service domain name that is used over the Internet.
   * 
   * @example
   * example.com
   */
  publicUserDomainName?: string;
  /**
   * @remarks
   * The CNAME domain name that is used to access the instance over the Internet, which is the primary domain name. This parameter is required when the PublicCnameMode parameter is set to CUSTOM.
   * 
   * >  You must use the primary domain name. Do not include the hostname specified by the PublicRr parameter.
   * 
   * @example
   * gtm-003.com
   */
  publicZoneName?: string;
  /**
   * @remarks
   * The global time to live (TTL).
   * 
   * @example
   * 1
   */
  ttl?: number;
  static names(): { [key: string]: string } {
    return {
      alertConfig: 'AlertConfig',
      alertGroup: 'AlertGroup',
      cnameType: 'CnameType',
      forceUpdate: 'ForceUpdate',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      lang: 'Lang',
      publicCnameMode: 'PublicCnameMode',
      publicRr: 'PublicRr',
      publicUserDomainName: 'PublicUserDomainName',
      publicZoneName: 'PublicZoneName',
      ttl: 'Ttl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertConfig: { 'type': 'array', 'itemType': UpdateDnsGtmInstanceGlobalConfigRequestAlertConfig },
      alertGroup: 'string',
      cnameType: 'string',
      forceUpdate: 'boolean',
      instanceId: 'string',
      instanceName: 'string',
      lang: 'string',
      publicCnameMode: 'string',
      publicRr: 'string',
      publicUserDomainName: 'string',
      publicZoneName: 'string',
      ttl: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDnsGtmInstanceGlobalConfigResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 29D0F8F8-5499-4F6C-9FDC-1EE13BF55925
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDnsGtmInstanceGlobalConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateDnsGtmInstanceGlobalConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateDnsGtmInstanceGlobalConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDnsGtmMonitorRequest extends $tea.Model {
  /**
   * @remarks
   * The maximum number of consecutive exceptions detected. If the number of consecutive exceptions detected reaches the maximum number, the application service is deemed abnormal.
   * 
   * @example
   * 2
   */
  evaluationCount?: number;
  /**
   * @remarks
   * The health check interval. Unit: seconds.
   * 
   * @example
   * 60
   */
  interval?: number;
  /**
   * @remarks
   * The monitored nodes.
   * 
   * This parameter is required.
   */
  ispCityNode?: UpdateDnsGtmMonitorRequestIspCityNode[];
  /**
   * @remarks
   * The language of the values of specific response parameters. Default value: en. Valid values: en, zh, and ja.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The ID of the health check configuration.
   * 
   * This parameter is required.
   * 
   * @example
   * MonitorConfigId1
   */
  monitorConfigId?: string;
  /**
   * @remarks
   * The extended information. The required parameters vary based on the health check protocol.
   * 
   * *   HTTP or HTTPS
   * 
   *     *   port: the port that you want to check
   * 
   *     *   host: the host settings
   * 
   *     *   path: the URL path
   * 
   *     *   code: the return code. If the return value of code is greater than the specified value, the health check result is deemed abnormal. For example, if code is set to 400 and the code 404 is returned, the health check result is deemed abnormal.
   * 
   *     *   failureRate: the failure rate
   * 
   *     *   sni: specifies whether to enable server name indication (SNI). This parameter is available only when ProtocolType is set to HTTPS. Valid values:
   * 
   *         *   true: enables SNI.
   *         *   false: disables SNI.
   * 
   *     *   nodeType: the type of the monitoring node when the address pool type is domain name. Valid values:
   * 
   *         *   IPV4
   *         *   IPV6
   * 
   * *   PING
   * 
   *     *   failureRate: the failure rate
   * 
   *     *   packetNum: the number of ping packets
   * 
   *     *   packetLossRate: the loss rate of ping packets
   * 
   *     *   nodeType: the type of the monitoring node when the address pool type is domain name. Valid values:
   * 
   *         *   IPV4
   *         *   IPV6
   * 
   * *   TCP
   * 
   *     *   port: the port that you want to check
   * 
   *     *   failureRate: the failure rate
   * 
   *     *   nodeType: the type of the monitoring node when the address pool type is domain name. Valid values:
   * 
   *         *   IPV4
   *         *   IPV6
   * 
   * This parameter is required.
   * 
   * @example
   * {\\"code\\":200,\\"path\\":\\"\\\\index.htm\\",\\"host\\":\\"aliyun.com\\"}
   */
  monitorExtendInfo?: string;
  /**
   * @remarks
   * The protocol used for the health check. Valid values:
   * 
   * *   HTTP
   * *   HTTPS
   * *   PING
   * *   TCP
   * 
   * This parameter is required.
   * 
   * @example
   * http
   */
  protocolType?: string;
  /**
   * @remarks
   * The health check timeout period. Unit: milliseconds.
   * 
   * @example
   * 3000
   */
  timeout?: number;
  static names(): { [key: string]: string } {
    return {
      evaluationCount: 'EvaluationCount',
      interval: 'Interval',
      ispCityNode: 'IspCityNode',
      lang: 'Lang',
      monitorConfigId: 'MonitorConfigId',
      monitorExtendInfo: 'MonitorExtendInfo',
      protocolType: 'ProtocolType',
      timeout: 'Timeout',
    };
  }

  static types(): { [key: string]: any } {
    return {
      evaluationCount: 'number',
      interval: 'number',
      ispCityNode: { 'type': 'array', 'itemType': UpdateDnsGtmMonitorRequestIspCityNode },
      lang: 'string',
      monitorConfigId: 'string',
      monitorExtendInfo: 'string',
      protocolType: 'string',
      timeout: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDnsGtmMonitorResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 6856BCF6-11D6-4D7E-AC53-FD579933522B
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDnsGtmMonitorResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateDnsGtmMonitorResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateDnsGtmMonitorResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDomainGroupRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the domain name group.
   * 
   * This parameter is required.
   * 
   * @example
   * 2223
   */
  groupId?: string;
  /**
   * @remarks
   * The new name of the domain name group.
   * 
   * This parameter is required.
   * 
   * @example
   * NewName
   */
  groupName?: string;
  /**
   * @remarks
   * The language.
   * 
   * @example
   * en
   */
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      groupName: 'GroupName',
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      groupName: 'string',
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDomainGroupResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the domain name group.
   * 
   * @example
   * 2223
   */
  groupId?: string;
  /**
   * @remarks
   * The new name of the domain name group.
   * 
   * @example
   * NewName
   */
  groupName?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 536E9CAD-DB30-4647-AC87-AA5CC38C5382
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      groupName: 'GroupName',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      groupName: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDomainGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateDomainGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateDomainGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDomainRecordRequest extends $tea.Model {
  /**
   * @remarks
   * The language.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The DNS resolution line. Default value: **default**.
   * 
   * For more information, see
   * 
   * [DNS lines](https://www.alibabacloud.com/help/zh/doc-detail/29807.htm).
   * 
   * @example
   * default
   */
  line?: string;
  /**
   * @remarks
   * The priority of the mail exchanger (MX) record. Valid values: `1 to 50`.
   * 
   * This parameter must be specified if the type of the DNS record is MX.
   * 
   * @example
   * 1
   */
  priority?: number;
  /**
   * @remarks
   * The hostname.
   * 
   * For example, if you want to resolve @.example.com, you must set RR to an at sign (@) instead of leaving it empty.
   * 
   * This parameter is required.
   * 
   * @example
   * www
   */
  RR?: string;
  /**
   * @remarks
   * The ID of the DNS record.
   * 
   * This parameter is required.
   * 
   * @example
   * 9999985
   */
  recordId?: string;
  /**
   * @remarks
   * The time-to-live (TTL) of the DNS record. Default value: 600. Unit: seconds.
   * 
   * For more information, see
   * 
   * [TTL definition](https://www.alibabacloud.com/help/zh/doc-detail/29806.htm).
   * 
   * @example
   * 600
   */
  TTL?: number;
  /**
   * @remarks
   * The type of the DNS record. For more information, see
   * 
   * [DNS record types](https://www.alibabacloud.com/help/zh/doc-detail/29805.htm).
   * 
   * This parameter is required.
   * 
   * @example
   * A
   */
  type?: string;
  /**
   * @remarks
   * The IP address of the client.
   * 
   * @example
   * 192.0.2.0
   */
  userClientIp?: string;
  /**
   * @remarks
   * The record value.
   * 
   * This parameter is required.
   * 
   * @example
   * 192.0.2.254
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      line: 'Line',
      priority: 'Priority',
      RR: 'RR',
      recordId: 'RecordId',
      TTL: 'TTL',
      type: 'Type',
      userClientIp: 'UserClientIp',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      line: 'string',
      priority: 'number',
      RR: 'string',
      recordId: 'string',
      TTL: 'number',
      type: 'string',
      userClientIp: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDomainRecordResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the DNS record.
   * 
   * @example
   * 9999985
   */
  recordId?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 536E9CAD-DB30-4647-AC87-AA5CC38C5382
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      recordId: 'RecordId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      recordId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDomainRecordResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateDomainRecordResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateDomainRecordResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDomainRecordRemarkRequest extends $tea.Model {
  /**
   * @remarks
   * The language.
   * 
   * @example
   * cn
   */
  lang?: string;
  /**
   * @remarks
   * The ID of the DNS record.
   * 
   * This parameter is required.
   * 
   * @example
   * 12345678
   */
  recordId?: string;
  /**
   * @remarks
   * The description of the DNS record.
   */
  remark?: string;
  /**
   * @remarks
   * The IP address of the client.
   * 
   * @example
   * 192.0.2.0
   */
  userClientIp?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      recordId: 'RecordId',
      remark: 'Remark',
      userClientIp: 'UserClientIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      recordId: 'string',
      remark: 'string',
      userClientIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDomainRecordRemarkResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 536E9CAD-DB30-4647-AC87-AA5CC38C5382
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDomainRecordRemarkResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateDomainRecordRemarkResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateDomainRecordRemarkResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDomainRemarkRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name that already exists in Alibaba Cloud DNS.
   * 
   * This parameter is required.
   * 
   * @example
   * mydomain.com
   */
  domainName?: string;
  /**
   * @remarks
   * The language.
   * 
   * @example
   * cn
   */
  lang?: string;
  /**
   * @remarks
   * The description of your domain name.
   */
  remark?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      lang: 'Lang',
      remark: 'Remark',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      lang: 'string',
      remark: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDomainRemarkResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 536E9CAD-DB30-4647-AC87-AA5CC38C5382
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDomainRemarkResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateDomainRemarkResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateDomainRemarkResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGtmAccessStrategyRequest extends $tea.Model {
  /**
   * @remarks
   * The line codes of access regions.
   * 
   * @example
   * ["default", "mobile"]
   */
  accessLines?: string;
  /**
   * @remarks
   * The ID of the default address pool.
   * 
   * @example
   * hrsix
   */
  defaultAddrPoolId?: string;
  /**
   * @remarks
   * The ID of the failover address pool.
   * 
   * @example
   * hrsyw
   */
  failoverAddrPoolId?: string;
  /**
   * @remarks
   * The language used by the user.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The ID of the access policy that you want to query for the GTM instance.
   * 
   * This parameter is required.
   * 
   * @example
   * hrmxc
   */
  strategyId?: string;
  /**
   * @remarks
   * The name of the access policy.
   */
  strategyName?: string;
  static names(): { [key: string]: string } {
    return {
      accessLines: 'AccessLines',
      defaultAddrPoolId: 'DefaultAddrPoolId',
      failoverAddrPoolId: 'FailoverAddrPoolId',
      lang: 'Lang',
      strategyId: 'StrategyId',
      strategyName: 'StrategyName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessLines: 'string',
      defaultAddrPoolId: 'string',
      failoverAddrPoolId: 'string',
      lang: 'string',
      strategyId: 'string',
      strategyName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGtmAccessStrategyResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 29D0F8F8-5499-4F6C-9FDC-1EE13BF55925
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGtmAccessStrategyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateGtmAccessStrategyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateGtmAccessStrategyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGtmAddressPoolRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   */
  addr?: UpdateGtmAddressPoolRequestAddr[];
  /**
   * @remarks
   * The ID of the address pool that you want to modify.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234abc
   */
  addrPoolId?: string;
  /**
   * @remarks
   * The language used by the user.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The minimum number of available addresses in the address pool.
   * 
   * @example
   * 2
   */
  minAvailableAddrNum?: number;
  /**
   * @remarks
   * The name of the address pool that you want to modify.
   */
  name?: string;
  /**
   * @remarks
   * The type of the address pool that you want to modify.
   * 
   * This parameter is required.
   * 
   * @example
   * IP
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      addr: 'Addr',
      addrPoolId: 'AddrPoolId',
      lang: 'Lang',
      minAvailableAddrNum: 'MinAvailableAddrNum',
      name: 'Name',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addr: { 'type': 'array', 'itemType': UpdateGtmAddressPoolRequestAddr },
      addrPoolId: 'string',
      lang: 'string',
      minAvailableAddrNum: 'number',
      name: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGtmAddressPoolResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 6856BCF6-11D6-4D7E-AC53-FD579933522B
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGtmAddressPoolResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateGtmAddressPoolResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateGtmAddressPoolResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGtmInstanceGlobalConfigRequest extends $tea.Model {
  /**
   * @remarks
   * The alert group. Only one alert group is supported.
   * 
   * >  This parameter is required only for the first modification.
   */
  alertGroup?: string;
  /**
   * @remarks
   * If you set **CnameMode** to **CUSTOM**, you must specify the CnameCustomDomainName parameter, which must be set to a primary domain name.
   * 
   * @example
   * www.example.com
   */
  cnameCustomDomainName?: string;
  /**
   * @remarks
   * Specifies whether to use a system-assigned canonical name (CNAME) or a custom CNAME to access GTM. Valid values:
   * 
   * *   **SYSTEM_ASSIGN**: system-assigned CNAME
   * *   **CUSTOM**: custom CNAME
   * 
   * @example
   * SYSTEM_ASSIGN
   */
  cnameMode?: string;
  /**
   * @remarks
   * The ID of the GTM instance.
   * 
   * This parameter is required.
   * 
   * @example
   * instance1
   */
  instanceId?: string;
  /**
   * @remarks
   * The name of the GTM instance.
   * 
   * >  This parameter is required only for the first modification.
   */
  instanceName?: string;
  /**
   * @remarks
   * The language.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The balancing policy. Valid values:
   * 
   * *   **ALL_RR**: load balancing
   * *   **RATIO**: weighted round-robin
   * 
   * >  This parameter is required only for the first modification.
   * 
   * @example
   * RATIO
   */
  lbaStrategy?: string;
  /**
   * @remarks
   * The global time-to-live (TTL).
   * 
   * @example
   * 60
   */
  ttl?: number;
  /**
   * @remarks
   * The primary domain name.
   * 
   * >  This parameter is required only for the first modification.
   * 
   * @example
   * www.example.com
   */
  userDomainName?: string;
  static names(): { [key: string]: string } {
    return {
      alertGroup: 'AlertGroup',
      cnameCustomDomainName: 'CnameCustomDomainName',
      cnameMode: 'CnameMode',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      lang: 'Lang',
      lbaStrategy: 'LbaStrategy',
      ttl: 'Ttl',
      userDomainName: 'UserDomainName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertGroup: 'string',
      cnameCustomDomainName: 'string',
      cnameMode: 'string',
      instanceId: 'string',
      instanceName: 'string',
      lang: 'string',
      lbaStrategy: 'string',
      ttl: 'number',
      userDomainName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGtmInstanceGlobalConfigResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 29D0F8F8-5499-4F6C-9FDC-1EE13BF55925
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGtmInstanceGlobalConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateGtmInstanceGlobalConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateGtmInstanceGlobalConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGtmMonitorRequest extends $tea.Model {
  /**
   * @remarks
   * The maximum number of consecutive exceptions detected. If the number of consecutive exceptions detected reaches the maximum number, the application service is deemed abnormal.
   * 
   * @example
   * 3
   */
  evaluationCount?: number;
  /**
   * @remarks
   * The health check interval. Unit: seconds. Set the value to 60.
   * 
   * @example
   * 60
   */
  interval?: number;
  /**
   * @remarks
   * The monitored nodes.
   * 
   * This parameter is required.
   */
  ispCityNode?: UpdateGtmMonitorRequestIspCityNode[];
  /**
   * @remarks
   * The language of the values of specific response parameters.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The ID of the health check configuration.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234abc
   */
  monitorConfigId?: string;
  /**
   * @remarks
   * The extended information, that is, the parameters required for the protocol. Different protocols require different parameters:
   * 
   * HTTP or HTTPS:
   * 
   * *   port: the port to check.
   * *   failureRate: the failure rate.
   * *   code: the status code threshold. If the returned status code is greater than the specified threshold, the application service is deemed abnormal. Valid values: 400 and 500.
   * *   host: the host configuration.
   * *   path: the health check URL.
   * 
   * PING:
   * 
   * *   packetNum: the number of ping packets.
   * *   packetLossRate: the loss rate of ping packets.
   * *   failureRate: the failure rate.
   * 
   * TCP:
   * 
   * *   port: the port to check.
   * *   failureRate: the failure rate.
   * 
   * This parameter is required.
   * 
   * @example
   * {\\"code\\":200,\\"path\\":\\"\\\\index.htm\\",\\"host\\":\\"aliyun.com\\"}
   */
  monitorExtendInfo?: string;
  /**
   * @remarks
   * The protocol used for the health check.
   * 
   * This parameter is required.
   * 
   * @example
   * HTTP
   */
  protocolType?: string;
  /**
   * @remarks
   * The health check timeout period. Unit: milliseconds. Valid values: 2000, 3000, 5000, and 10000.
   * 
   * @example
   * 3000
   */
  timeout?: number;
  static names(): { [key: string]: string } {
    return {
      evaluationCount: 'EvaluationCount',
      interval: 'Interval',
      ispCityNode: 'IspCityNode',
      lang: 'Lang',
      monitorConfigId: 'MonitorConfigId',
      monitorExtendInfo: 'MonitorExtendInfo',
      protocolType: 'ProtocolType',
      timeout: 'Timeout',
    };
  }

  static types(): { [key: string]: any } {
    return {
      evaluationCount: 'number',
      interval: 'number',
      ispCityNode: { 'type': 'array', 'itemType': UpdateGtmMonitorRequestIspCityNode },
      lang: 'string',
      monitorConfigId: 'string',
      monitorExtendInfo: 'string',
      protocolType: 'string',
      timeout: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGtmMonitorResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 6856BCF6-11D6-4D7E-AC53-FD579933522B
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGtmMonitorResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateGtmMonitorResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateGtmMonitorResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGtmRecoveryPlanRequest extends $tea.Model {
  /**
   * @remarks
   * The list of faulty address pools.
   * 
   * @example
   * ["hra0or"]
   */
  faultAddrPool?: string;
  /**
   * @remarks
   * The language in which you want the values of some response parameters to be returned. These response parameters support multiple languages.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The name of the disaster recovery plan.
   * 
   * @example
   * abc
   */
  name?: string;
  /**
   * @remarks
   * The ID of the disaster recovery plan.
   * 
   * This parameter is required.
   * 
   * @example
   * 100
   */
  recoveryPlanId?: number;
  /**
   * @remarks
   * The remarks about the disaster recovery plan.
   * 
   * @example
   * remark
   */
  remark?: string;
  static names(): { [key: string]: string } {
    return {
      faultAddrPool: 'FaultAddrPool',
      lang: 'Lang',
      name: 'Name',
      recoveryPlanId: 'RecoveryPlanId',
      remark: 'Remark',
    };
  }

  static types(): { [key: string]: any } {
    return {
      faultAddrPool: 'string',
      lang: 'string',
      name: 'string',
      recoveryPlanId: 'number',
      remark: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGtmRecoveryPlanResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 6856BCF6-11D6-4D7E-AC53-FD579933522B
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGtmRecoveryPlanResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateGtmRecoveryPlanResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateGtmRecoveryPlanResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateIspFlushCacheInstanceConfigRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   */
  instanceId?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  instanceName?: string;
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      instanceName: 'string',
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateIspFlushCacheInstanceConfigResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateIspFlushCacheInstanceConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateIspFlushCacheInstanceConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateIspFlushCacheInstanceConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ValidateDnsGtmCnameRrCanUseRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   */
  cnameMode?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  cnameRr?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  cnameType?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  cnameZone?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  instanceId?: string;
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      cnameMode: 'CnameMode',
      cnameRr: 'CnameRr',
      cnameType: 'CnameType',
      cnameZone: 'CnameZone',
      instanceId: 'InstanceId',
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cnameMode: 'string',
      cnameRr: 'string',
      cnameType: 'string',
      cnameZone: 'string',
      instanceId: 'string',
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ValidateDnsGtmCnameRrCanUseResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ValidateDnsGtmCnameRrCanUseResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ValidateDnsGtmCnameRrCanUseResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ValidateDnsGtmCnameRrCanUseResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ValidatePdnsUdpIpSegmentRequest extends $tea.Model {
  ip?: string;
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      ip: 'Ip',
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ip: 'string',
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ValidatePdnsUdpIpSegmentResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ValidatePdnsUdpIpSegmentResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ValidatePdnsUdpIpSegmentResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ValidatePdnsUdpIpSegmentResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddCustomLineRequestIpSegment extends $tea.Model {
  /**
   * @remarks
   * The end IP address of the CIDR block.
   * 
   * @example
   * 192.0.2.254
   */
  endIp?: string;
  /**
   * @remarks
   * The start IP address of the CIDR block.
   * 
   * @example
   * 192.0.2.0
   */
  startIp?: string;
  static names(): { [key: string]: string } {
    return {
      endIp: 'EndIp',
      startIp: 'StartIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endIp: 'string',
      startIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddDnsCacheDomainRequestSourceDnsServer extends $tea.Model {
  /**
   * @remarks
   * The domain name or IP address of the origin DNS server.
   * 
   * This parameter is required.
   * 
   * @example
   * 192.0.0.0
   */
  host?: string;
  /**
   * @remarks
   * The port of the origin DNS server.
   * 
   * This parameter is required.
   * 
   * @example
   * 53
   */
  port?: string;
  static names(): { [key: string]: string } {
    return {
      host: 'Host',
      port: 'Port',
    };
  }

  static types(): { [key: string]: any } {
    return {
      host: 'string',
      port: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddDnsGtmAccessStrategyRequestDefaultAddrPool extends $tea.Model {
  /**
   * @remarks
   * The ID of the address pool in the primary address pool set.
   * 
   * @example
   * pool1
   */
  id?: string;
  /**
   * @remarks
   * The weight of the address pool in the primary address pool set.
   * 
   * @example
   * 1
   */
  lbaWeight?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      lbaWeight: 'LbaWeight',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      lbaWeight: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddDnsGtmAccessStrategyRequestFailoverAddrPool extends $tea.Model {
  /**
   * @remarks
   * The ID of the address pool in the secondary address pool set.
   * 
   * @example
   * pool1
   */
  id?: string;
  /**
   * @remarks
   * The weight of the address pool in the secondary address pool set.
   * 
   * @example
   * 1
   */
  lbaWeight?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      lbaWeight: 'LbaWeight',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      lbaWeight: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddDnsGtmAddressPoolRequestAddr extends $tea.Model {
  /**
   * @remarks
   * The address in the address pool.
   * 
   * This parameter is required.
   * 
   * @example
   * 1.1.1.1
   */
  addr?: string;
  /**
   * @remarks
   * The information about the source region of the address. The value of this parameter is a JSON string. Valid values:
   * 
   * *   LineCode: the line code of the source region for the address
   * 
   * *   lineCodeRectifyType: the rectification type of the line code. Default value: AUTO. Valid values:
   * 
   *     *   NO_NEED: no need for rectification
   *     *   RECTIFIED: rectified
   *     *   AUTO: automatic rectification
   * 
   * This parameter is required.
   * 
   * @example
   * default
   */
  attributeInfo?: string;
  /**
   * @remarks
   * The weight of the address pool.
   * 
   * @example
   * 1
   */
  lbaWeight?: number;
  /**
   * @remarks
   * The return mode of the addresses: Valid values:
   * 
   * *   SMART: smart return
   * *   ONLINE: always online
   * *   OFFLINE: always offline
   * 
   * This parameter is required.
   * 
   * @example
   * online
   */
  mode?: string;
  /**
   * @remarks
   * The remarks.
   * 
   * @example
   * test
   */
  remark?: string;
  static names(): { [key: string]: string } {
    return {
      addr: 'Addr',
      attributeInfo: 'AttributeInfo',
      lbaWeight: 'LbaWeight',
      mode: 'Mode',
      remark: 'Remark',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addr: 'string',
      attributeInfo: 'string',
      lbaWeight: 'number',
      mode: 'string',
      remark: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddDnsGtmAddressPoolRequestIspCityNode extends $tea.Model {
  /**
   * @remarks
   * The city code.
   * 
   * Specify the parameter according to the value of CityCode returned by the DescribeGtmMonitorAvailableConfig operation.
   * 
   * @example
   * 503
   */
  cityCode?: string;
  /**
   * @remarks
   * *   The Internet service provider (ISP) node. Specify the parameter according to the value of IspCode returned by the DescribeGtmMonitorAvailableConfig operation.
   * *   If the returned value of GroupType for the DescribeGtmMonitorAvailableConfig operation is BGP or Overseas, IspCode is not required and is set to 465 by default.
   * *   If the returned value of GroupType for the DescribeGtmMonitorAvailableConfig operation is not BGP or Overseas, IspCode is required. When IspCode is specified, CityCode is required.
   * 
   * @example
   * 465
   */
  ispCode?: string;
  static names(): { [key: string]: string } {
    return {
      cityCode: 'CityCode',
      ispCode: 'IspCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cityCode: 'string',
      ispCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddDnsGtmMonitorRequestIspCityNode extends $tea.Model {
  /**
   * @remarks
   * The code of the city where the monitored node is deployed.
   * 
   * @example
   * 123
   */
  cityCode?: string;
  /**
   * @remarks
   * The code of the Internet service provider (ISP) to which the monitored node belongs.
   * 
   * @example
   * 123
   */
  ispCode?: string;
  static names(): { [key: string]: string } {
    return {
      cityCode: 'CityCode',
      ispCode: 'IspCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cityCode: 'string',
      ispCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddDomainResponseBodyDnsServers extends $tea.Model {
  dnsServer?: string[];
  static names(): { [key: string]: string } {
    return {
      dnsServer: 'DnsServer',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dnsServer: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGtmAddressPoolRequestAddr extends $tea.Model {
  /**
   * @remarks
   * The weight of the address pool.
   * 
   * @example
   * 1
   */
  lbaWeight?: number;
  /**
   * @remarks
   * The mode of the address pool. Valid values:
   * 
   * *   **SMART**: smart return
   * *   **ONLINE**: always online
   * *   **OFFLINE**: always offline
   * 
   * @example
   * SMART
   */
  mode?: string;
  /**
   * @remarks
   * The address in the address pool.
   * 
   * @example
   * 1.1.1.1
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      lbaWeight: 'LbaWeight',
      mode: 'Mode',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lbaWeight: 'number',
      mode: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGtmAddressPoolRequestIspCityNode extends $tea.Model {
  /**
   * @remarks
   * The code of the city where the monitored node is deployed. For more information about specific values, see the response parameters of DescribeGtmMonitorAvailableConfig.
   * 
   * @example
   * 546
   */
  cityCode?: string;
  /**
   * @remarks
   * *   The code of the Internet service provider (ISP) to which the monitored node belongs. For more information about specific values, see the response parameters of DescribeGtmMonitorAvailableConfig.
   * *   If the value of the GroupType parameter is BGP or OVERSEAS, IspCode is optional. The default value is 465.
   * *   If the value of the GroupType parameter is not BGP or OVERSEAS, IspCode is required and is used together with CityCode.
   * 
   * @example
   * 465
   */
  ispCode?: string;
  static names(): { [key: string]: string } {
    return {
      cityCode: 'CityCode',
      ispCode: 'IspCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cityCode: 'string',
      ispCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGtmMonitorRequestIspCityNode extends $tea.Model {
  /**
   * @remarks
   * The city code.
   * 
   * Specify the parameter according to the value of CityCode returned by the DescribeGtmMonitorAvailableConfig operation.
   * 
   * @example
   * 503
   */
  cityCode?: string;
  /**
   * @remarks
   * The Internet service provider (ISP) node. Specify the parameter according to the value of IspCode returned by the DescribeGtmMonitorAvailableConfig operation.
   * 
   * *   If the return value of GroupType for the DescribeGtmMonitorAvailableConfig operation is BGP or Overseas, IspCode is not required and is set to 465 by default.
   * *   If the return value of GroupType for the DescribeGtmMonitorAvailableConfig operation is not BGP or Overseas, IspCode is required. When IspCode is specified, CityCode is required.
   * 
   * @example
   * 465
   */
  ispCode?: string;
  static names(): { [key: string]: string } {
    return {
      cityCode: 'CityCode',
      ispCode: 'IspCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cityCode: 'string',
      ispCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCloudGtmAddressRequestHealthTasks extends $tea.Model {
  /**
   * @example
   * 80
   */
  port?: number;
  /**
   * @example
   * mtp-89518052425100**80
   */
  templateId?: string;
  static names(): { [key: string]: string } {
    return {
      port: 'Port',
      templateId: 'TemplateId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      port: 'number',
      templateId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCloudGtmMonitorTemplateRequestIspCityNodes extends $tea.Model {
  /**
   * @example
   * 503
   */
  cityCode?: string;
  /**
   * @example
   * 465
   */
  ispCode?: string;
  static names(): { [key: string]: string } {
    return {
      cityCode: 'CityCode',
      ispCode: 'IspCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cityCode: 'string',
      ispCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBatchResultDetailResponseBodyBatchResultDetailsBatchResultDetail extends $tea.Model {
  /**
   * @remarks
   * The type of the batch operation.
   * 
   * @example
   * DOMAIN_ADD
   */
  batchType?: string;
  /**
   * @remarks
   * The domain name.
   * 
   * @example
   * example.com
   */
  domain?: string;
  /**
   * @remarks
   * The line code.
   * 
   * @example
   * default
   */
  line?: string;
  /**
   * @remarks
   * The new hostname.
   * 
   * @example
   * demo-batch-7
   */
  newRr?: string;
  /**
   * @remarks
   * The new record value.
   * 
   * @example
   * 192.0.2.254
   */
  newValue?: string;
  /**
   * @remarks
   * The time when the operation was performed. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.
   * 
   * @example
   * 2019-08-22 18:02:58
   */
  operateDateStr?: string;
  /**
   * @remarks
   * The priority of the mail exchanger (MX) record.
   * 
   * @example
   * 10
   */
  priority?: string;
  /**
   * @remarks
   * The cause of the execution failure.
   * 
   * @example
   * Task lock fail
   */
  reason?: string;
  /**
   * @remarks
   * The ID of the DNS record.
   * 
   * @example
   * 123456789
   */
  recordId?: string;
  /**
   * @remarks
   * The description of the DNS record.
   * 
   * @example
   * remark
   */
  remark?: string;
  /**
   * @remarks
   * The hostname.
   * 
   * @example
   * www
   */
  rr?: string;
  /**
   * @remarks
   * The status of the DNS record.
   * 
   * @example
   * stop
   */
  rrStatus?: string;
  /**
   * @remarks
   * The execution result of the batch operation. Valid values: **true**: The operation succeeded. **false**: The operation failed.
   * 
   * @example
   * true
   */
  status?: boolean;
  /**
   * @remarks
   * The time-to-live (TTL) of the DNS record.
   * 
   * @example
   * 600
   */
  ttl?: string;
  /**
   * @remarks
   * The type of the DNS record.
   * 
   * @example
   * A
   */
  type?: string;
  /**
   * @remarks
   * The record value.
   * 
   * @example
   * 192.0.2.0
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      batchType: 'BatchType',
      domain: 'Domain',
      line: 'Line',
      newRr: 'NewRr',
      newValue: 'NewValue',
      operateDateStr: 'OperateDateStr',
      priority: 'Priority',
      reason: 'Reason',
      recordId: 'RecordId',
      remark: 'Remark',
      rr: 'Rr',
      rrStatus: 'RrStatus',
      status: 'Status',
      ttl: 'Ttl',
      type: 'Type',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      batchType: 'string',
      domain: 'string',
      line: 'string',
      newRr: 'string',
      newValue: 'string',
      operateDateStr: 'string',
      priority: 'string',
      reason: 'string',
      recordId: 'string',
      remark: 'string',
      rr: 'string',
      rrStatus: 'string',
      status: 'boolean',
      ttl: 'string',
      type: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBatchResultDetailResponseBodyBatchResultDetails extends $tea.Model {
  batchResultDetail?: DescribeBatchResultDetailResponseBodyBatchResultDetailsBatchResultDetail[];
  static names(): { [key: string]: string } {
    return {
      batchResultDetail: 'BatchResultDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      batchResultDetail: { 'type': 'array', 'itemType': DescribeBatchResultDetailResponseBodyBatchResultDetailsBatchResultDetail },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudGtmAddressResponseBodyHealthTasksHealthTask extends $tea.Model {
  /**
   * @example
   * ok
   */
  monitorStatus?: string;
  /**
   * @example
   * 80
   */
  port?: number;
  /**
   * @example
   * mtp-89518052425100**80
   */
  templateId?: string;
  /**
   * @example
   * Ping-IPv4
   */
  templateName?: string;
  static names(): { [key: string]: string } {
    return {
      monitorStatus: 'MonitorStatus',
      port: 'Port',
      templateId: 'TemplateId',
      templateName: 'TemplateName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      monitorStatus: 'string',
      port: 'number',
      templateId: 'string',
      templateName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudGtmAddressResponseBodyHealthTasks extends $tea.Model {
  healthTask?: DescribeCloudGtmAddressResponseBodyHealthTasksHealthTask[];
  static names(): { [key: string]: string } {
    return {
      healthTask: 'HealthTask',
    };
  }

  static types(): { [key: string]: any } {
    return {
      healthTask: { 'type': 'array', 'itemType': DescribeCloudGtmAddressResponseBodyHealthTasksHealthTask },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudGtmAddressPoolResponseBodyAddressesAddressHealthTasksHealthTask extends $tea.Model {
  /**
   * @example
   * 80
   */
  port?: number;
  /**
   * @example
   * mtp-89518052425100**80
   */
  templateId?: string;
  /**
   * @example
   * IPv4-Ping
   */
  templateName?: string;
  static names(): { [key: string]: string } {
    return {
      port: 'Port',
      templateId: 'TemplateId',
      templateName: 'TemplateName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      port: 'number',
      templateId: 'string',
      templateName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudGtmAddressPoolResponseBodyAddressesAddressHealthTasks extends $tea.Model {
  healthTask?: DescribeCloudGtmAddressPoolResponseBodyAddressesAddressHealthTasksHealthTask[];
  static names(): { [key: string]: string } {
    return {
      healthTask: 'HealthTask',
    };
  }

  static types(): { [key: string]: any } {
    return {
      healthTask: { 'type': 'array', 'itemType': DescribeCloudGtmAddressPoolResponseBodyAddressesAddressHealthTasksHealthTask },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudGtmAddressPoolResponseBodyAddressesAddressRequestSource extends $tea.Model {
  requestSource?: string[];
  static names(): { [key: string]: string } {
    return {
      requestSource: 'RequestSource',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestSource: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudGtmAddressPoolResponseBodyAddressesAddress extends $tea.Model {
  /**
   * @example
   * 223.5.XX.XX
   */
  address?: string;
  /**
   * @example
   * addr-89518218114368**92
   */
  addressId?: string;
  attributeInfo?: string;
  /**
   * @example
   * auto
   */
  availableMode?: string;
  /**
   * @example
   * available
   */
  availableStatus?: string;
  /**
   * @example
   * 2024-03-15T01:46Z
   */
  createTime?: string;
  /**
   * @example
   * 1527690629357
   */
  createTimestamp?: number;
  /**
   * @example
   * enable
   */
  enableStatus?: string;
  /**
   * @example
   * any_ok
   */
  healthJudgement?: string;
  /**
   * @example
   * ok
   */
  healthStatus?: string;
  healthTasks?: DescribeCloudGtmAddressPoolResponseBodyAddressesAddressHealthTasks;
  /**
   * @example
   * available
   */
  manualAvailableStatus?: string;
  /**
   * @example
   * Address-1
   */
  name?: string;
  /**
   * @example
   * test
   */
  remark?: string;
  requestSource?: DescribeCloudGtmAddressPoolResponseBodyAddressesAddressRequestSource;
  /**
   * @example
   * false
   */
  seqNonPreemptiveSchedule?: boolean;
  /**
   * @example
   * 1
   */
  serialNumber?: number;
  /**
   * @example
   * IPv4
   */
  type?: string;
  /**
   * @example
   * 2024-03-15T01:46Z
   */
  updateTime?: string;
  /**
   * @example
   * 1527690629357
   */
  updateTimestamp?: number;
  /**
   * @example
   * 1
   */
  weightValue?: number;
  static names(): { [key: string]: string } {
    return {
      address: 'Address',
      addressId: 'AddressId',
      attributeInfo: 'AttributeInfo',
      availableMode: 'AvailableMode',
      availableStatus: 'AvailableStatus',
      createTime: 'CreateTime',
      createTimestamp: 'CreateTimestamp',
      enableStatus: 'EnableStatus',
      healthJudgement: 'HealthJudgement',
      healthStatus: 'HealthStatus',
      healthTasks: 'HealthTasks',
      manualAvailableStatus: 'ManualAvailableStatus',
      name: 'Name',
      remark: 'Remark',
      requestSource: 'RequestSource',
      seqNonPreemptiveSchedule: 'SeqNonPreemptiveSchedule',
      serialNumber: 'SerialNumber',
      type: 'Type',
      updateTime: 'UpdateTime',
      updateTimestamp: 'UpdateTimestamp',
      weightValue: 'WeightValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      address: 'string',
      addressId: 'string',
      attributeInfo: 'string',
      availableMode: 'string',
      availableStatus: 'string',
      createTime: 'string',
      createTimestamp: 'number',
      enableStatus: 'string',
      healthJudgement: 'string',
      healthStatus: 'string',
      healthTasks: DescribeCloudGtmAddressPoolResponseBodyAddressesAddressHealthTasks,
      manualAvailableStatus: 'string',
      name: 'string',
      remark: 'string',
      requestSource: DescribeCloudGtmAddressPoolResponseBodyAddressesAddressRequestSource,
      seqNonPreemptiveSchedule: 'boolean',
      serialNumber: 'number',
      type: 'string',
      updateTime: 'string',
      updateTimestamp: 'number',
      weightValue: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudGtmAddressPoolResponseBodyAddresses extends $tea.Model {
  address?: DescribeCloudGtmAddressPoolResponseBodyAddressesAddress[];
  static names(): { [key: string]: string } {
    return {
      address: 'Address',
    };
  }

  static types(): { [key: string]: any } {
    return {
      address: { 'type': 'array', 'itemType': DescribeCloudGtmAddressPoolResponseBodyAddressesAddress },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudGtmAddressPoolReferenceResponseBodyInstanceConfigsInstanceConfig extends $tea.Model {
  /**
   * @example
   * round_robin
   */
  addressPoolLbStrategy?: string;
  /**
   * @example
   * available
   */
  availableStatus?: string;
  /**
   * @example
   * config-000**1
   */
  configId?: string;
  /**
   * @example
   * enable
   */
  enableStatus?: string;
  /**
   * @example
   * ok
   */
  healthStatus?: string;
  /**
   * @example
   * gtm-cn-jmp3qnw**03
   */
  instanceId?: string;
  /**
   * @example
   * test
   */
  instanceName?: string;
  /**
   * @example
   * test
   */
  remark?: string;
  /**
   * @example
   * www.example.com
   */
  scheduleDomainName?: string;
  /**
   * @example
   * www
   */
  scheduleHostname?: string;
  /**
   * @example
   * A
   */
  scheduleRrType?: string;
  /**
   * @example
   * example.com
   */
  scheduleZoneName?: string;
  /**
   * @example
   * preemptive
   */
  sequenceLbStrategyMode?: string;
  /**
   * @example
   * 30
   */
  ttl?: number;
  /**
   * @example
   * ultimate
   */
  versionCode?: string;
  static names(): { [key: string]: string } {
    return {
      addressPoolLbStrategy: 'AddressPoolLbStrategy',
      availableStatus: 'AvailableStatus',
      configId: 'ConfigId',
      enableStatus: 'EnableStatus',
      healthStatus: 'HealthStatus',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      remark: 'Remark',
      scheduleDomainName: 'ScheduleDomainName',
      scheduleHostname: 'ScheduleHostname',
      scheduleRrType: 'ScheduleRrType',
      scheduleZoneName: 'ScheduleZoneName',
      sequenceLbStrategyMode: 'SequenceLbStrategyMode',
      ttl: 'Ttl',
      versionCode: 'VersionCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addressPoolLbStrategy: 'string',
      availableStatus: 'string',
      configId: 'string',
      enableStatus: 'string',
      healthStatus: 'string',
      instanceId: 'string',
      instanceName: 'string',
      remark: 'string',
      scheduleDomainName: 'string',
      scheduleHostname: 'string',
      scheduleRrType: 'string',
      scheduleZoneName: 'string',
      sequenceLbStrategyMode: 'string',
      ttl: 'number',
      versionCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudGtmAddressPoolReferenceResponseBodyInstanceConfigs extends $tea.Model {
  instanceConfig?: DescribeCloudGtmAddressPoolReferenceResponseBodyInstanceConfigsInstanceConfig[];
  static names(): { [key: string]: string } {
    return {
      instanceConfig: 'InstanceConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceConfig: { 'type': 'array', 'itemType': DescribeCloudGtmAddressPoolReferenceResponseBodyInstanceConfigsInstanceConfig },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudGtmAddressReferenceResponseBodyAddressPoolsAddressPoolInstanceConfigsInstanceConfig extends $tea.Model {
  /**
   * @example
   * round_robin
   */
  addressPoolLbStrategy?: string;
  /**
   * @example
   * available
   */
  availableStatus?: string;
  /**
   * @example
   * config-00**01
   */
  configId?: string;
  /**
   * @example
   * enable
   */
  enableStatus?: string;
  /**
   * @example
   * ok
   */
  healthStatus?: string;
  /**
   * @example
   * gtm-cn-zz11t58**0k
   */
  instanceId?: string;
  /**
   * @example
   * test
   */
  instanceName?: string;
  /**
   * @example
   * test
   */
  remark?: string;
  /**
   * @example
   * www.example.com
   */
  scheduleDomainName?: string;
  /**
   * @example
   * www
   */
  scheduleHostname?: string;
  /**
   * @example
   * A
   */
  scheduleRrType?: string;
  /**
   * @example
   * example.com
   */
  scheduleZoneName?: string;
  /**
   * @example
   * preemptive
   */
  sequenceLbStrategyMode?: string;
  /**
   * @example
   * 30
   */
  ttl?: number;
  /**
   * @example
   * ultimate
   */
  versionCode?: string;
  static names(): { [key: string]: string } {
    return {
      addressPoolLbStrategy: 'AddressPoolLbStrategy',
      availableStatus: 'AvailableStatus',
      configId: 'ConfigId',
      enableStatus: 'EnableStatus',
      healthStatus: 'HealthStatus',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      remark: 'Remark',
      scheduleDomainName: 'ScheduleDomainName',
      scheduleHostname: 'ScheduleHostname',
      scheduleRrType: 'ScheduleRrType',
      scheduleZoneName: 'ScheduleZoneName',
      sequenceLbStrategyMode: 'SequenceLbStrategyMode',
      ttl: 'Ttl',
      versionCode: 'VersionCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addressPoolLbStrategy: 'string',
      availableStatus: 'string',
      configId: 'string',
      enableStatus: 'string',
      healthStatus: 'string',
      instanceId: 'string',
      instanceName: 'string',
      remark: 'string',
      scheduleDomainName: 'string',
      scheduleHostname: 'string',
      scheduleRrType: 'string',
      scheduleZoneName: 'string',
      sequenceLbStrategyMode: 'string',
      ttl: 'number',
      versionCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudGtmAddressReferenceResponseBodyAddressPoolsAddressPoolInstanceConfigs extends $tea.Model {
  instanceConfig?: DescribeCloudGtmAddressReferenceResponseBodyAddressPoolsAddressPoolInstanceConfigsInstanceConfig[];
  static names(): { [key: string]: string } {
    return {
      instanceConfig: 'InstanceConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceConfig: { 'type': 'array', 'itemType': DescribeCloudGtmAddressReferenceResponseBodyAddressPoolsAddressPoolInstanceConfigsInstanceConfig },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudGtmAddressReferenceResponseBodyAddressPoolsAddressPool extends $tea.Model {
  /**
   * @example
   * round_robin
   */
  addressLbStrategy?: string;
  /**
   * @example
   * pool-895280232254422016
   */
  addressPoolId?: string;
  /**
   * @example
   * AddressPool-1
   */
  addressPoolName?: string;
  /**
   * @example
   * IPv4
   */
  addressPoolType?: string;
  /**
   * @example
   * available
   */
  availableStatus?: string;
  /**
   * @example
   * enable
   */
  enableStatus?: string;
  /**
   * @example
   * any_ok
   */
  healthJudgement?: string;
  /**
   * @example
   * ok
   */
  healthStatus?: string;
  instanceConfigs?: DescribeCloudGtmAddressReferenceResponseBodyAddressPoolsAddressPoolInstanceConfigs;
  /**
   * @example
   * pool-1
   */
  remark?: string;
  /**
   * @example
   * preemptive
   */
  sequenceLbStrategyMode?: string;
  static names(): { [key: string]: string } {
    return {
      addressLbStrategy: 'AddressLbStrategy',
      addressPoolId: 'AddressPoolId',
      addressPoolName: 'AddressPoolName',
      addressPoolType: 'AddressPoolType',
      availableStatus: 'AvailableStatus',
      enableStatus: 'EnableStatus',
      healthJudgement: 'HealthJudgement',
      healthStatus: 'HealthStatus',
      instanceConfigs: 'InstanceConfigs',
      remark: 'Remark',
      sequenceLbStrategyMode: 'SequenceLbStrategyMode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addressLbStrategy: 'string',
      addressPoolId: 'string',
      addressPoolName: 'string',
      addressPoolType: 'string',
      availableStatus: 'string',
      enableStatus: 'string',
      healthJudgement: 'string',
      healthStatus: 'string',
      instanceConfigs: DescribeCloudGtmAddressReferenceResponseBodyAddressPoolsAddressPoolInstanceConfigs,
      remark: 'string',
      sequenceLbStrategyMode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudGtmAddressReferenceResponseBodyAddressPools extends $tea.Model {
  addressPool?: DescribeCloudGtmAddressReferenceResponseBodyAddressPoolsAddressPool[];
  static names(): { [key: string]: string } {
    return {
      addressPool: 'AddressPool',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addressPool: { 'type': 'array', 'itemType': DescribeCloudGtmAddressReferenceResponseBodyAddressPoolsAddressPool },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudGtmGlobalAlertResponseBodyAlertConfigAlertConfig extends $tea.Model {
  /**
   * @example
   * false
   */
  dingtalkNotice?: boolean;
  /**
   * @example
   * true
   */
  emailNotice?: boolean;
  /**
   * @example
   * addr_alert
   */
  noticeType?: string;
  /**
   * @example
   * true
   */
  smsNotice?: boolean;
  static names(): { [key: string]: string } {
    return {
      dingtalkNotice: 'DingtalkNotice',
      emailNotice: 'EmailNotice',
      noticeType: 'NoticeType',
      smsNotice: 'SmsNotice',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dingtalkNotice: 'boolean',
      emailNotice: 'boolean',
      noticeType: 'string',
      smsNotice: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudGtmGlobalAlertResponseBodyAlertConfig extends $tea.Model {
  alertConfig?: DescribeCloudGtmGlobalAlertResponseBodyAlertConfigAlertConfig[];
  static names(): { [key: string]: string } {
    return {
      alertConfig: 'AlertConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertConfig: { 'type': 'array', 'itemType': DescribeCloudGtmGlobalAlertResponseBodyAlertConfigAlertConfig },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudGtmGlobalAlertResponseBodyAlertGroup extends $tea.Model {
  alertGroup?: string[];
  static names(): { [key: string]: string } {
    return {
      alertGroup: 'AlertGroup',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertGroup: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudGtmInstanceConfigAlertResponseBodyAlertConfigAlertConfig extends $tea.Model {
  /**
   * @example
   * true
   */
  dingtalkNotice?: boolean;
  /**
   * @example
   * true
   */
  emailNotice?: boolean;
  /**
   * @example
   * addr_alert
   */
  noticeType?: string;
  /**
   * @example
   * true
   */
  smsNotice?: boolean;
  static names(): { [key: string]: string } {
    return {
      dingtalkNotice: 'DingtalkNotice',
      emailNotice: 'EmailNotice',
      noticeType: 'NoticeType',
      smsNotice: 'SmsNotice',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dingtalkNotice: 'boolean',
      emailNotice: 'boolean',
      noticeType: 'string',
      smsNotice: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudGtmInstanceConfigAlertResponseBodyAlertConfig extends $tea.Model {
  alertConfig?: DescribeCloudGtmInstanceConfigAlertResponseBodyAlertConfigAlertConfig[];
  static names(): { [key: string]: string } {
    return {
      alertConfig: 'AlertConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertConfig: { 'type': 'array', 'itemType': DescribeCloudGtmInstanceConfigAlertResponseBodyAlertConfigAlertConfig },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudGtmInstanceConfigAlertResponseBodyAlertGroup extends $tea.Model {
  alertGroup?: string[];
  static names(): { [key: string]: string } {
    return {
      alertGroup: 'AlertGroup',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertGroup: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPoolAddressesAddressRequestSource extends $tea.Model {
  requestSource?: string[];
  static names(): { [key: string]: string } {
    return {
      requestSource: 'RequestSource',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestSource: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPoolAddressesAddress extends $tea.Model {
  /**
   * @example
   * 223.5.XX.XX
   */
  address?: string;
  /**
   * @example
   * addr-89564712295703**96
   */
  addressId?: string;
  attributeInfo?: string;
  /**
   * @example
   * auto
   */
  availableMode?: string;
  /**
   * @example
   * available
   */
  availableStatus?: string;
  /**
   * @example
   * 2024-03-15T01:46Z
   */
  createTime?: string;
  /**
   * @example
   * 1527690629357
   */
  createTimestamp?: number;
  /**
   * @example
   * enable
   */
  enableStatus?: string;
  /**
   * @example
   * any_ok
   */
  healthJudgement?: string;
  /**
   * @example
   * ok
   */
  healthStatus?: string;
  /**
   * @example
   * available
   */
  manualAvailableStatus?: string;
  /**
   * @example
   * Address-1
   */
  name?: string;
  /**
   * @example
   * test
   */
  remark?: string;
  requestSource?: DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPoolAddressesAddressRequestSource;
  /**
   * @example
   * false
   */
  seqNonPreemptiveSchedule?: boolean;
  /**
   * @example
   * 1
   */
  serialNumber?: number;
  /**
   * @example
   * IPv4
   */
  type?: string;
  /**
   * @example
   * 2024-03-15T01:46Z
   */
  updateTime?: string;
  /**
   * @example
   * 1527690629357
   */
  updateTimestamp?: number;
  /**
   * @example
   * 1
   */
  weightValue?: number;
  static names(): { [key: string]: string } {
    return {
      address: 'Address',
      addressId: 'AddressId',
      attributeInfo: 'AttributeInfo',
      availableMode: 'AvailableMode',
      availableStatus: 'AvailableStatus',
      createTime: 'CreateTime',
      createTimestamp: 'CreateTimestamp',
      enableStatus: 'EnableStatus',
      healthJudgement: 'HealthJudgement',
      healthStatus: 'HealthStatus',
      manualAvailableStatus: 'ManualAvailableStatus',
      name: 'Name',
      remark: 'Remark',
      requestSource: 'RequestSource',
      seqNonPreemptiveSchedule: 'SeqNonPreemptiveSchedule',
      serialNumber: 'SerialNumber',
      type: 'Type',
      updateTime: 'UpdateTime',
      updateTimestamp: 'UpdateTimestamp',
      weightValue: 'WeightValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      address: 'string',
      addressId: 'string',
      attributeInfo: 'string',
      availableMode: 'string',
      availableStatus: 'string',
      createTime: 'string',
      createTimestamp: 'number',
      enableStatus: 'string',
      healthJudgement: 'string',
      healthStatus: 'string',
      manualAvailableStatus: 'string',
      name: 'string',
      remark: 'string',
      requestSource: DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPoolAddressesAddressRequestSource,
      seqNonPreemptiveSchedule: 'boolean',
      serialNumber: 'number',
      type: 'string',
      updateTime: 'string',
      updateTimestamp: 'number',
      weightValue: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPoolAddresses extends $tea.Model {
  address?: DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPoolAddressesAddress[];
  static names(): { [key: string]: string } {
    return {
      address: 'Address',
    };
  }

  static types(): { [key: string]: any } {
    return {
      address: { 'type': 'array', 'itemType': DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPoolAddressesAddress },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPoolRequestSource extends $tea.Model {
  requestSource?: string[];
  static names(): { [key: string]: string } {
    return {
      requestSource: 'RequestSource',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestSource: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPool extends $tea.Model {
  /**
   * @example
   * round_robin
   */
  addressLbStrategy?: string;
  /**
   * @example
   * pool-89528023225442**16
   */
  addressPoolId?: string;
  /**
   * @example
   * AddressPool-1
   */
  addressPoolName?: string;
  /**
   * @example
   * IPv4
   */
  addressPoolType?: string;
  addresses?: DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPoolAddresses;
  /**
   * @example
   * available
   */
  availableStatus?: string;
  /**
   * @example
   * 2024-03-15T01:46Z
   */
  createTime?: string;
  /**
   * @example
   * 1527690629357
   */
  createTimestamp?: number;
  /**
   * @example
   * enable
   */
  enableStatus?: string;
  /**
   * @example
   * any_ok
   */
  healthJudgement?: string;
  /**
   * @example
   * ok
   */
  healthStatus?: string;
  requestSource?: DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPoolRequestSource;
  /**
   * @example
   * false
   */
  seqNonPreemptiveSchedule?: boolean;
  /**
   * @example
   * preemptive
   */
  sequenceLbStrategyMode?: string;
  /**
   * @example
   * 1
   */
  serialNumber?: number;
  /**
   * @example
   * 2024-03-15T01:46Z
   */
  updateTime?: string;
  /**
   * @example
   * 1527690629357
   */
  updateTimestamp?: number;
  /**
   * @example
   * 1
   */
  weightValue?: number;
  static names(): { [key: string]: string } {
    return {
      addressLbStrategy: 'AddressLbStrategy',
      addressPoolId: 'AddressPoolId',
      addressPoolName: 'AddressPoolName',
      addressPoolType: 'AddressPoolType',
      addresses: 'Addresses',
      availableStatus: 'AvailableStatus',
      createTime: 'CreateTime',
      createTimestamp: 'CreateTimestamp',
      enableStatus: 'EnableStatus',
      healthJudgement: 'HealthJudgement',
      healthStatus: 'HealthStatus',
      requestSource: 'RequestSource',
      seqNonPreemptiveSchedule: 'SeqNonPreemptiveSchedule',
      sequenceLbStrategyMode: 'SequenceLbStrategyMode',
      serialNumber: 'SerialNumber',
      updateTime: 'UpdateTime',
      updateTimestamp: 'UpdateTimestamp',
      weightValue: 'WeightValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addressLbStrategy: 'string',
      addressPoolId: 'string',
      addressPoolName: 'string',
      addressPoolType: 'string',
      addresses: DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPoolAddresses,
      availableStatus: 'string',
      createTime: 'string',
      createTimestamp: 'number',
      enableStatus: 'string',
      healthJudgement: 'string',
      healthStatus: 'string',
      requestSource: DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPoolRequestSource,
      seqNonPreemptiveSchedule: 'boolean',
      sequenceLbStrategyMode: 'string',
      serialNumber: 'number',
      updateTime: 'string',
      updateTimestamp: 'number',
      weightValue: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPools extends $tea.Model {
  addressPool?: DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPool[];
  static names(): { [key: string]: string } {
    return {
      addressPool: 'AddressPool',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addressPool: { 'type': 'array', 'itemType': DescribeCloudGtmInstanceConfigFullInfoResponseBodyAddressPoolsAddressPool },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudGtmMonitorTemplateResponseBodyIspCityNodesIspCityNode extends $tea.Model {
  /**
   * @example
   * 503
   */
  cityCode?: string;
  cityName?: string;
  /**
   * @example
   * 001
   */
  countryCode?: string;
  countryName?: string;
  groupName?: string;
  /**
   * @example
   * BGP
   */
  groupType?: string;
  /**
   * @example
   * 465
   */
  ispCode?: string;
  ispName?: string;
  static names(): { [key: string]: string } {
    return {
      cityCode: 'CityCode',
      cityName: 'CityName',
      countryCode: 'CountryCode',
      countryName: 'CountryName',
      groupName: 'GroupName',
      groupType: 'GroupType',
      ispCode: 'IspCode',
      ispName: 'IspName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cityCode: 'string',
      cityName: 'string',
      countryCode: 'string',
      countryName: 'string',
      groupName: 'string',
      groupType: 'string',
      ispCode: 'string',
      ispName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudGtmMonitorTemplateResponseBodyIspCityNodes extends $tea.Model {
  ispCityNode?: DescribeCloudGtmMonitorTemplateResponseBodyIspCityNodesIspCityNode[];
  static names(): { [key: string]: string } {
    return {
      ispCityNode: 'IspCityNode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ispCityNode: { 'type': 'array', 'itemType': DescribeCloudGtmMonitorTemplateResponseBodyIspCityNodesIspCityNode },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudGtmSystemLinesResponseBodySystemLinesSystemLine extends $tea.Model {
  /**
   * @example
   * aliyun_r_ap-south-1
   */
  code?: string;
  displayName?: string;
  /**
   * @example
   * true
   */
  isAvailable?: boolean;
  name?: string;
  /**
   * @example
   * String	aliyun
   */
  parentCode?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      displayName: 'DisplayName',
      isAvailable: 'IsAvailable',
      name: 'Name',
      parentCode: 'ParentCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      displayName: 'string',
      isAvailable: 'boolean',
      name: 'string',
      parentCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudGtmSystemLinesResponseBodySystemLines extends $tea.Model {
  systemLine?: DescribeCloudGtmSystemLinesResponseBodySystemLinesSystemLine[];
  static names(): { [key: string]: string } {
    return {
      systemLine: 'SystemLine',
    };
  }

  static types(): { [key: string]: any } {
    return {
      systemLine: { 'type': 'array', 'itemType': DescribeCloudGtmSystemLinesResponseBodySystemLinesSystemLine },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCustomLineResponseBodyIpSegmentList extends $tea.Model {
  /**
   * @remarks
   * The end IP address of the CIDR block.
   * 
   * @example
   * 11.1.1.3
   */
  endIp?: string;
  /**
   * @remarks
   * The start IP address of the CIDR block.
   * 
   * @example
   * 11.1.1.2
   */
  startIp?: string;
  static names(): { [key: string]: string } {
    return {
      endIp: 'EndIp',
      startIp: 'StartIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endIp: 'string',
      startIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCustomLinesResponseBodyCustomLines extends $tea.Model {
  /**
   * @remarks
   * The code of the custom line.
   * 
   * @example
   * hra0yc-597
   */
  code?: string;
  /**
   * @remarks
   * The unique ID of the custom line.
   * 
   * @example
   * 597
   */
  id?: number;
  /**
   * @remarks
   * The name of the custom line.
   * 
   * @example
   * hra0yd-597
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      id: 'Id',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      id: 'number',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomainLineAlgorithmsLineAlgorithm extends $tea.Model {
  /**
   * @remarks
   * The DNS resolution line. The line can be China Telecom, China Mobile, and China Unicom.
   * 
   * @example
   * default
   */
  line?: string;
  /**
   * @remarks
   * Indicates whether weighted round-robin is enabled for the line. Valid values:
   * 
   * *   **true** (default): Weighted round-robin is enabled.
   * *   **false**: Weighted round-robin is disabled.
   * 
   * @example
   * true
   */
  open?: boolean;
  static names(): { [key: string]: string } {
    return {
      line: 'Line',
      open: 'Open',
    };
  }

  static types(): { [key: string]: any } {
    return {
      line: 'string',
      open: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomainLineAlgorithms extends $tea.Model {
  lineAlgorithm?: DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomainLineAlgorithmsLineAlgorithm[];
  static names(): { [key: string]: string } {
    return {
      lineAlgorithm: 'LineAlgorithm',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lineAlgorithm: { 'type': 'array', 'itemType': DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomainLineAlgorithmsLineAlgorithm },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomain extends $tea.Model {
  /**
   * @remarks
   * The lines for which weighted round-robin is enabled.
   */
  lineAlgorithms?: DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomainLineAlgorithms;
  /**
   * @remarks
   * Indicates whether weighted round-robin is enabled for the subdomain.
   * 
   * @example
   * true
   */
  open?: boolean;
  /**
   * @remarks
   * The number of DNS records added for the subdomain.
   * 
   * @example
   * 3
   */
  recordCount?: number;
  /**
   * @remarks
   * The subdomain name.
   * 
   * @example
   * www.example.com
   */
  subDomain?: string;
  /**
   * @remarks
   * The type of the Domain Name System (DNS) record that supports weighted round-robin. Valid values: A, AAAA, and CNAME.
   * 
   * @example
   * A
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      lineAlgorithms: 'LineAlgorithms',
      open: 'Open',
      recordCount: 'RecordCount',
      subDomain: 'SubDomain',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lineAlgorithms: DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomainLineAlgorithms,
      open: 'boolean',
      recordCount: 'number',
      subDomain: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDNSSLBSubDomainsResponseBodySlbSubDomains extends $tea.Model {
  slbSubDomain?: DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomain[];
  static names(): { [key: string]: string } {
    return {
      slbSubDomain: 'SlbSubDomain',
    };
  }

  static types(): { [key: string]: any } {
    return {
      slbSubDomain: { 'type': 'array', 'itemType': DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomain },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsCacheDomainsResponseBodyDomainsSourceDnsServers extends $tea.Model {
  /**
   * @remarks
   * The domain name or IP address of the origin DNS server.
   * 
   * @example
   * ns8.alidns.com
   */
  host?: string;
  /**
   * @remarks
   * The port of the origin DNS server.
   * 
   * @example
   * 53
   */
  port?: string;
  static names(): { [key: string]: string } {
    return {
      host: 'Host',
      port: 'Port',
    };
  }

  static types(): { [key: string]: any } {
    return {
      host: 'string',
      port: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsCacheDomainsResponseBodyDomains extends $tea.Model {
  /**
   * @remarks
   * The maximum time-to-live (TTL) period of the cached data retrieved from the origin DNS server. Unit: seconds. Valid values: 30 to 86400.
   * 
   * @example
   * 86400
   */
  cacheTtlMax?: number;
  /**
   * @remarks
   * The minimum TTL period of the cached data retrieved from the origin DNS server. Unit: seconds. Valid values: 30 to 86400.
   * 
   * @example
   * 30
   */
  cacheTtlMin?: number;
  /**
   * @remarks
   * The time when the domain name was added. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.
   * 
   * @example
   * 2022-10-17T06:13Z
   */
  createTime?: string;
  /**
   * @remarks
   * The time when the domain name was added. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
   * 
   * @example
   * 1660546144000
   */
  createTimestamp?: number;
  /**
   * @remarks
   * The ID of the cache-accelerated domain name.
   * 
   * @example
   * 00efd71a-770e-4255-b54e-6fe5659baffe
   */
  domainId?: string;
  /**
   * @remarks
   * The cache-accelerated domain name.
   * 
   * @example
   * dns-example.top
   */
  domainName?: string;
  /**
   * @remarks
   * The time when the instance expires. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.
   * 
   * @example
   * 2022-12-02T16:00Z
   */
  expireTime?: string;
  /**
   * @remarks
   * The time when the instance expires. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
   * 
   * @example
   * 1692374400000
   */
  expireTimestamp?: number;
  /**
   * @remarks
   * The instance ID of the cache-accelerated domain name.
   * 
   * @example
   * i-7bg
   */
  instanceId?: string;
  /**
   * @remarks
   * The description of the domain name.
   * 
   * @example
   * remark
   */
  remark?: string;
  /**
   * @remarks
   * The origin DNS servers.
   */
  sourceDnsServers?: DescribeDnsCacheDomainsResponseBodyDomainsSourceDnsServers[];
  /**
   * @remarks
   * Specifies whether the origin Domain Name System (DNS) server supports Extension Mechanisms for DNS (EDNS). Valid values: NOT_SUPPORT and SUPPORT.
   * 
   * @example
   * SUPPORT
   */
  sourceEdns?: string;
  /**
   * @remarks
   * The origin protocol policy. Valid values: TCP and UDP. Default value: UDP.
   * 
   * @example
   * UDP
   */
  sourceProtocol?: string;
  /**
   * @remarks
   * The time when the configurations of the domain name were updated. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.
   * 
   * @example
   * 2023-05-22T03:40Z
   */
  updateTime?: string;
  /**
   * @remarks
   * The time when the configurations of the domain name were updated. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
   * 
   * @example
   * 1671690491000
   */
  updateTimestamp?: number;
  /**
   * @remarks
   * The edition code of Alibaba Cloud DNS.
   * 
   * @example
   * ultimate
   */
  versionCode?: string;
  static names(): { [key: string]: string } {
    return {
      cacheTtlMax: 'CacheTtlMax',
      cacheTtlMin: 'CacheTtlMin',
      createTime: 'CreateTime',
      createTimestamp: 'CreateTimestamp',
      domainId: 'DomainId',
      domainName: 'DomainName',
      expireTime: 'ExpireTime',
      expireTimestamp: 'ExpireTimestamp',
      instanceId: 'InstanceId',
      remark: 'Remark',
      sourceDnsServers: 'SourceDnsServers',
      sourceEdns: 'SourceEdns',
      sourceProtocol: 'SourceProtocol',
      updateTime: 'UpdateTime',
      updateTimestamp: 'UpdateTimestamp',
      versionCode: 'VersionCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cacheTtlMax: 'number',
      cacheTtlMin: 'number',
      createTime: 'string',
      createTimestamp: 'number',
      domainId: 'string',
      domainName: 'string',
      expireTime: 'string',
      expireTimestamp: 'number',
      instanceId: 'string',
      remark: 'string',
      sourceDnsServers: { 'type': 'array', 'itemType': DescribeDnsCacheDomainsResponseBodyDomainsSourceDnsServers },
      sourceEdns: 'string',
      sourceProtocol: 'string',
      updateTime: 'string',
      updateTimestamp: 'number',
      versionCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyEffectiveAddrPoolsEffectiveAddrPool extends $tea.Model {
  /**
   * @remarks
   * The number of addresses in the address pool.
   * 
   * @example
   * 3
   */
  addrCount?: number;
  /**
   * @remarks
   * The ID of the address pool.
   * 
   * @example
   * pool1
   */
  id?: string;
  /**
   * @remarks
   * The weight of the address pool.
   * 
   * @example
   * 1
   */
  lbaWeight?: number;
  /**
   * @remarks
   * The name of the address pool.
   * 
   * @example
   * test
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      addrCount: 'AddrCount',
      id: 'Id',
      lbaWeight: 'LbaWeight',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addrCount: 'number',
      id: 'string',
      lbaWeight: 'number',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyEffectiveAddrPools extends $tea.Model {
  effectiveAddrPool?: DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyEffectiveAddrPoolsEffectiveAddrPool[];
  static names(): { [key: string]: string } {
    return {
      effectiveAddrPool: 'EffectiveAddrPool',
    };
  }

  static types(): { [key: string]: any } {
    return {
      effectiveAddrPool: { 'type': 'array', 'itemType': DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyEffectiveAddrPoolsEffectiveAddrPool },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyLinesLine extends $tea.Model {
  /**
   * @remarks
   * The code of the source region group.
   * 
   * @example
   * default
   */
  groupCode?: string;
  /**
   * @remarks
   * The name of the source region group.
   * 
   * @example
   * global
   */
  groupName?: string;
  /**
   * @remarks
   * The line code of the source region.
   * 
   * @example
   * default
   */
  lineCode?: string;
  /**
   * @remarks
   * The line name of the source region.
   * 
   * @example
   * global
   */
  lineName?: string;
  static names(): { [key: string]: string } {
    return {
      groupCode: 'GroupCode',
      groupName: 'GroupName',
      lineCode: 'LineCode',
      lineName: 'LineName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupCode: 'string',
      groupName: 'string',
      lineCode: 'string',
      lineName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyLines extends $tea.Model {
  line?: DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyLinesLine[];
  static names(): { [key: string]: string } {
    return {
      line: 'Line',
    };
  }

  static types(): { [key: string]: any } {
    return {
      line: { 'type': 'array', 'itemType': DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyLinesLine },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategy extends $tea.Model {
  /**
   * @remarks
   * The time when the access policy was created.
   * 
   * @example
   * 2018-08-09T00:10Z
   */
  createTime?: string;
  /**
   * @remarks
   * The timestamp that indicates when the access policy was created.
   * 
   * @example
   * 1533773400000
   */
  createTimestamp?: number;
  /**
   * @remarks
   * The type of the active address pool group. Valid values:
   * 
   * *   DEFAULT: the primary address pool group
   * *   FAILOVER: the secondary address pool group
   * 
   * @example
   * default
   */
  effectiveAddrPoolGroupType?: string;
  /**
   * @remarks
   * The type of the active address pools. Valid values:
   * 
   * *   IPV4
   * *   IPV6
   * *   DOMAIN
   * 
   * @example
   * ipv4
   */
  effectiveAddrPoolType?: string;
  /**
   * @remarks
   * The active address pool groups.
   */
  effectiveAddrPools?: DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyEffectiveAddrPools;
  /**
   * @remarks
   * The load balancing policy of the active address pool group. Data is returned when StrategyMode is set to GEO. Valid values: 
   * 
   * - ALL_RR: returns all addresses.
   * - RATIO: returns addresses by weight.
   * 
   * @example
   * all_rr
   */
  effectiveLbaStrategy?: string;
  /**
   * @remarks
   * The source regions. Data is returned when StrategyMode is set to GEO. Valid values:
   */
  lines?: DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyLines;
  /**
   * @remarks
   * The ID of the access policy.
   * 
   * @example
   * strategyid1
   */
  strategyId?: string;
  /**
   * @remarks
   * The name of the access policy.
   * 
   * @example
   * strategname1
   */
  strategyName?: string;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      createTimestamp: 'CreateTimestamp',
      effectiveAddrPoolGroupType: 'EffectiveAddrPoolGroupType',
      effectiveAddrPoolType: 'EffectiveAddrPoolType',
      effectiveAddrPools: 'EffectiveAddrPools',
      effectiveLbaStrategy: 'EffectiveLbaStrategy',
      lines: 'Lines',
      strategyId: 'StrategyId',
      strategyName: 'StrategyName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'string',
      createTimestamp: 'number',
      effectiveAddrPoolGroupType: 'string',
      effectiveAddrPoolType: 'string',
      effectiveAddrPools: DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyEffectiveAddrPools,
      effectiveLbaStrategy: 'string',
      lines: DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyLines,
      strategyId: 'string',
      strategyName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmAccessStrategiesResponseBodyStrategies extends $tea.Model {
  strategy?: DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategy[];
  static names(): { [key: string]: string } {
    return {
      strategy: 'Strategy',
    };
  }

  static types(): { [key: string]: any } {
    return {
      strategy: { 'type': 'array', 'itemType': DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategy },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmAccessStrategyResponseBodyDefaultAddrPoolsDefaultAddrPool extends $tea.Model {
  /**
   * @remarks
   * The number of addresses in the address pool.
   * 
   * @example
   * 1
   */
  addrCount?: number;
  /**
   * @remarks
   * The ID of the address pool.
   * 
   * @example
   * pool1
   */
  id?: string;
  /**
   * @remarks
   * The weight of the address pool.
   * 
   * @example
   * 1
   */
  lbaWeight?: number;
  /**
   * @remarks
   * The name of the address pool.
   * 
   * @example
   * test
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      addrCount: 'AddrCount',
      id: 'Id',
      lbaWeight: 'LbaWeight',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addrCount: 'number',
      id: 'string',
      lbaWeight: 'number',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmAccessStrategyResponseBodyDefaultAddrPools extends $tea.Model {
  defaultAddrPool?: DescribeDnsGtmAccessStrategyResponseBodyDefaultAddrPoolsDefaultAddrPool[];
  static names(): { [key: string]: string } {
    return {
      defaultAddrPool: 'DefaultAddrPool',
    };
  }

  static types(): { [key: string]: any } {
    return {
      defaultAddrPool: { 'type': 'array', 'itemType': DescribeDnsGtmAccessStrategyResponseBodyDefaultAddrPoolsDefaultAddrPool },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmAccessStrategyResponseBodyFailoverAddrPoolsFailoverAddrPool extends $tea.Model {
  /**
   * @remarks
   * The number of addresses in the address pool.
   * 
   * @example
   * 1
   */
  addrCount?: number;
  /**
   * @remarks
   * The ID of the address pool.
   * 
   * @example
   * pool1
   */
  id?: string;
  /**
   * @remarks
   * The weight of the address pool.
   * 
   * @example
   * 1
   */
  lbaWeight?: number;
  /**
   * @remarks
   * The name of the address pool.
   * 
   * @example
   * test
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      addrCount: 'AddrCount',
      id: 'Id',
      lbaWeight: 'LbaWeight',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addrCount: 'number',
      id: 'string',
      lbaWeight: 'number',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmAccessStrategyResponseBodyFailoverAddrPools extends $tea.Model {
  failoverAddrPool?: DescribeDnsGtmAccessStrategyResponseBodyFailoverAddrPoolsFailoverAddrPool[];
  static names(): { [key: string]: string } {
    return {
      failoverAddrPool: 'FailoverAddrPool',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failoverAddrPool: { 'type': 'array', 'itemType': DescribeDnsGtmAccessStrategyResponseBodyFailoverAddrPoolsFailoverAddrPool },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmAccessStrategyResponseBodyLinesLine extends $tea.Model {
  /**
   * @remarks
   * The code of the source region group.
   * 
   * @example
   * default
   */
  groupCode?: string;
  /**
   * @remarks
   * The name of the source region group.
   * 
   * @example
   * global
   */
  groupName?: string;
  /**
   * @remarks
   * The line code of the source region.
   * 
   * @example
   * default
   */
  lineCode?: string;
  /**
   * @remarks
   * The line name of the source region.
   * 
   * @example
   * global
   */
  lineName?: string;
  static names(): { [key: string]: string } {
    return {
      groupCode: 'GroupCode',
      groupName: 'GroupName',
      lineCode: 'LineCode',
      lineName: 'LineName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupCode: 'string',
      groupName: 'string',
      lineCode: 'string',
      lineName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmAccessStrategyResponseBodyLines extends $tea.Model {
  line?: DescribeDnsGtmAccessStrategyResponseBodyLinesLine[];
  static names(): { [key: string]: string } {
    return {
      line: 'Line',
    };
  }

  static types(): { [key: string]: any } {
    return {
      line: { 'type': 'array', 'itemType': DescribeDnsGtmAccessStrategyResponseBodyLinesLine },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyDomainAddrPoolsDomainAddrPool extends $tea.Model {
  /**
   * @remarks
   * The number of addresses in the address pool.
   * 
   * @example
   * 1
   */
  addrCount?: number;
  /**
   * @remarks
   * The ID of the address pool.
   * 
   * @example
   * pool1
   */
  id?: string;
  /**
   * @remarks
   * The name of the address pool.
   * 
   * @example
   * testpool
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      addrCount: 'AddrCount',
      id: 'Id',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addrCount: 'number',
      id: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyDomainAddrPools extends $tea.Model {
  domainAddrPool?: DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyDomainAddrPoolsDomainAddrPool[];
  static names(): { [key: string]: string } {
    return {
      domainAddrPool: 'DomainAddrPool',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainAddrPool: { 'type': 'array', 'itemType': DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyDomainAddrPoolsDomainAddrPool },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv4AddrPoolsIpv4AddrPool extends $tea.Model {
  /**
   * @remarks
   * The number of addresses in the address pool.
   * 
   * @example
   * 1
   */
  addrCount?: number;
  /**
   * @remarks
   * The ID of the address pool.
   * 
   * @example
   * pool1
   */
  id?: string;
  /**
   * @remarks
   * The name of the address pool.
   * 
   * @example
   * testpool
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      addrCount: 'AddrCount',
      id: 'Id',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addrCount: 'number',
      id: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv4AddrPools extends $tea.Model {
  ipv4AddrPool?: DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv4AddrPoolsIpv4AddrPool[];
  static names(): { [key: string]: string } {
    return {
      ipv4AddrPool: 'Ipv4AddrPool',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ipv4AddrPool: { 'type': 'array', 'itemType': DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv4AddrPoolsIpv4AddrPool },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv6AddrPoolsIpv6AddrPool extends $tea.Model {
  /**
   * @remarks
   * The number of addresses in the address pool.
   * 
   * @example
   * 1
   */
  addrCount?: number;
  /**
   * @remarks
   * The ID of the address pool.
   * 
   * @example
   * pool1
   */
  id?: string;
  /**
   * @remarks
   * The name of the address pool.
   * 
   * @example
   * testpool
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      addrCount: 'AddrCount',
      id: 'Id',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addrCount: 'number',
      id: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv6AddrPools extends $tea.Model {
  ipv6AddrPool?: DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv6AddrPoolsIpv6AddrPool[];
  static names(): { [key: string]: string } {
    return {
      ipv6AddrPool: 'Ipv6AddrPool',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ipv6AddrPool: { 'type': 'array', 'itemType': DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv6AddrPoolsIpv6AddrPool },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyLinesLine extends $tea.Model {
  /**
   * @remarks
   * The parent line code of the source region. Leave it blank if no parent line exists.
   * 
   * @example
   * telecom
   */
  fatherCode?: string;
  /**
   * @remarks
   * The line name of the source region.
   * 
   * @example
   * default
   */
  groupCode?: string;
  /**
   * @remarks
   * The name of the source region group.
   * 
   * @example
   * global
   */
  groupName?: string;
  /**
   * @remarks
   * The line code of the source region.
   * 
   * @example
   * default
   */
  lineCode?: string;
  /**
   * @remarks
   * The code of the source region group.
   * 
   * @example
   * global
   */
  lineName?: string;
  static names(): { [key: string]: string } {
    return {
      fatherCode: 'FatherCode',
      groupCode: 'GroupCode',
      groupName: 'GroupName',
      lineCode: 'LineCode',
      lineName: 'LineName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fatherCode: 'string',
      groupCode: 'string',
      groupName: 'string',
      lineCode: 'string',
      lineName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyLines extends $tea.Model {
  line?: DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyLinesLine[];
  static names(): { [key: string]: string } {
    return {
      line: 'Line',
    };
  }

  static types(): { [key: string]: any } {
    return {
      line: { 'type': 'array', 'itemType': DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyLinesLine },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmAccessStrategyAvailableConfigResponseBodySelectedDomainLines extends $tea.Model {
  selectedDomainLine?: string[];
  static names(): { [key: string]: string } {
    return {
      selectedDomainLine: 'SelectedDomainLine',
    };
  }

  static types(): { [key: string]: any } {
    return {
      selectedDomainLine: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmAccessStrategyAvailableConfigResponseBodySelectedIpv4Lines extends $tea.Model {
  selectedIpv4Line?: string[];
  static names(): { [key: string]: string } {
    return {
      selectedIpv4Line: 'SelectedIpv4Line',
    };
  }

  static types(): { [key: string]: any } {
    return {
      selectedIpv4Line: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmAccessStrategyAvailableConfigResponseBodySelectedIpv6Lines extends $tea.Model {
  selectedIpv6Line?: string[];
  static names(): { [key: string]: string } {
    return {
      selectedIpv6Line: 'SelectedIpv6Line',
    };
  }

  static types(): { [key: string]: any } {
    return {
      selectedIpv6Line: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmAddrAttributeInfoResponseBodyAddrAddrAttributeInfo extends $tea.Model {
  /**
   * @remarks
   * The parent line code of the source region.
   * 
   * @example
   * telecom
   */
  fatherCode?: string;
  /**
   * @remarks
   * The code of the source region group.
   * 
   * @example
   * DEFAULT
   */
  groupCode?: string;
  /**
   * @remarks
   * The name of the source region group.
   * 
   * @example
   * Global
   */
  groupName?: string;
  /**
   * @remarks
   * The line code of the source region.
   * 
   * @example
   * default
   */
  lineCode?: string;
  /**
   * @remarks
   * The line name of the source region.
   * 
   * @example
   * Global
   */
  lineName?: string;
  static names(): { [key: string]: string } {
    return {
      fatherCode: 'FatherCode',
      groupCode: 'GroupCode',
      groupName: 'GroupName',
      lineCode: 'LineCode',
      lineName: 'LineName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fatherCode: 'string',
      groupCode: 'string',
      groupName: 'string',
      lineCode: 'string',
      lineName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmAddrAttributeInfoResponseBodyAddrAddr extends $tea.Model {
  /**
   * @remarks
   * The address that was queried.
   * 
   * @example
   * 1.1.1.1
   */
  addr?: string;
  /**
   * @remarks
   * The source region of the address.
   */
  attributeInfo?: DescribeDnsGtmAddrAttributeInfoResponseBodyAddrAddrAttributeInfo;
  static names(): { [key: string]: string } {
    return {
      addr: 'Addr',
      attributeInfo: 'AttributeInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addr: 'string',
      attributeInfo: DescribeDnsGtmAddrAttributeInfoResponseBodyAddrAddrAttributeInfo,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmAddrAttributeInfoResponseBodyAddr extends $tea.Model {
  addr?: DescribeDnsGtmAddrAttributeInfoResponseBodyAddrAddr[];
  static names(): { [key: string]: string } {
    return {
      addr: 'Addr',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addr: { 'type': 'array', 'itemType': DescribeDnsGtmAddrAttributeInfoResponseBodyAddrAddr },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmAddressPoolAvailableConfigResponseBodyAttributeInfosAttributeInfo extends $tea.Model {
  /**
   * @remarks
   * The parent line code of the source region.
   * 
   * @example
   * telecom
   */
  fatherCode?: string;
  /**
   * @remarks
   * The code of the source region group.
   * 
   * @example
   * default
   */
  groupCode?: string;
  /**
   * @remarks
   * The name of the request source group.
   * 
   * @example
   * global
   */
  groupName?: string;
  /**
   * @remarks
   * The line code of the source region.
   * 
   * @example
   * default
   */
  lineCode?: string;
  /**
   * @remarks
   * The line name of the source region.
   * 
   * @example
   * global
   */
  lineName?: string;
  static names(): { [key: string]: string } {
    return {
      fatherCode: 'FatherCode',
      groupCode: 'GroupCode',
      groupName: 'GroupName',
      lineCode: 'LineCode',
      lineName: 'LineName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fatherCode: 'string',
      groupCode: 'string',
      groupName: 'string',
      lineCode: 'string',
      lineName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmAddressPoolAvailableConfigResponseBodyAttributeInfos extends $tea.Model {
  attributeInfo?: DescribeDnsGtmAddressPoolAvailableConfigResponseBodyAttributeInfosAttributeInfo[];
  static names(): { [key: string]: string } {
    return {
      attributeInfo: 'AttributeInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attributeInfo: { 'type': 'array', 'itemType': DescribeDnsGtmAddressPoolAvailableConfigResponseBodyAttributeInfosAttributeInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmInstanceResponseBodyConfigAlertConfigAlertConfig extends $tea.Model {
  dingtalkNotice?: boolean;
  /**
   * @remarks
   * Indicates whether email notification is configured. Valid values:
   * 
   * *   true: Email notification is configured.
   * *   false: Email notification is not configured. null: Email notification is not configured.
   * 
   * @example
   * true
   */
  emailNotice?: boolean;
  /**
   * @remarks
   * The type of the alert event. Valid values:
   * 
   * *   ADDR_ALERT: The address is unavailable.
   * *   ADDR_RESUME: The address is restored and becomes available.
   * *   ADDR_POOL_GROUP_UNAVAILABLE: The address pool group is unavailable.
   * *   ADDR_POOL_GROUP_AVAILABLE: The address pool group is restored and becomes available.
   * *   ACCESS_STRATEGY_POOL_GROUP_SWITCH: Switchover is triggered between the primary and secondary address pools.
   * *   MONITOR_NODE_IP_CHANGE: The IP address of the monitoring node has changed.
   * 
   * @example
   * ADDR_ALERT
   */
  noticeType?: string;
  /**
   * @remarks
   * Indicates whether SMS notification is configured. Valid values:
   * 
   * *   true: SMS notification is configured.
   * *   false: SMS notification is not configured. null: SMS notification is not configured.
   * 
   * @example
   * true
   */
  smsNotice?: boolean;
  static names(): { [key: string]: string } {
    return {
      dingtalkNotice: 'DingtalkNotice',
      emailNotice: 'EmailNotice',
      noticeType: 'NoticeType',
      smsNotice: 'SmsNotice',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dingtalkNotice: 'boolean',
      emailNotice: 'boolean',
      noticeType: 'string',
      smsNotice: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmInstanceResponseBodyConfigAlertConfig extends $tea.Model {
  alertConfig?: DescribeDnsGtmInstanceResponseBodyConfigAlertConfigAlertConfig[];
  static names(): { [key: string]: string } {
    return {
      alertConfig: 'AlertConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertConfig: { 'type': 'array', 'itemType': DescribeDnsGtmInstanceResponseBodyConfigAlertConfigAlertConfig },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmInstanceResponseBodyConfig extends $tea.Model {
  /**
   * @remarks
   * The alert notification method.
   */
  alertConfig?: DescribeDnsGtmInstanceResponseBodyConfigAlertConfig;
  /**
   * @remarks
   * The name of the alert group.
   * 
   * @example
   * alertgroup1
   */
  alertGroup?: string;
  /**
   * @remarks
   * The type of the CNAME domain name that is used to access the instance. Valid value:
   * 
   * *   PUBLIC: The CNAME domain name is used to access the instance over the Internet.
   * 
   * @example
   * public
   */
  cnameType?: string;
  /**
   * @remarks
   * The name of the instance.
   * 
   * @example
   * instancetest1
   */
  instanceName?: string;
  /**
   * @remarks
   * The domain name that is used to access the instance over the Internet.
   * 
   * @example
   * test.rr.gtm-003.com
   */
  pubicZoneName?: string;
  /**
   * @remarks
   * Indicates whether a custom CNAME domain name or a CNAME domain name assigned by the system is used to access the instance over the Internet. Valid values:
   * 
   * *   CUSTOM: A custom CNAME domain name is used.
   * *   SYSTEM_ASSIGN: A CNAME domain name assigned by the system is used.
   * 
   * @example
   * custom
   */
  publicCnameMode?: string;
  /**
   * @remarks
   * The hostname corresponding to the CNAME domain name that is used to access the instance over the Internet.
   * 
   * @example
   * test.rr
   */
  publicRr?: string;
  /**
   * @remarks
   * The service domain name that is used over the Internet.
   * 
   * @example
   * example.com
   */
  publicUserDomainName?: string;
  /**
   * @remarks
   * The type of the access policy. Valid values:
   * 
   * *   LATENCY: Latency-based
   * *   GEO: Geographical location-based
   * 
   * @example
   * GEO
   */
  strategyMode?: string;
  /**
   * @remarks
   * The global time to live (TTL).
   * 
   * @example
   * 1
   */
  ttl?: number;
  static names(): { [key: string]: string } {
    return {
      alertConfig: 'AlertConfig',
      alertGroup: 'AlertGroup',
      cnameType: 'CnameType',
      instanceName: 'InstanceName',
      pubicZoneName: 'PubicZoneName',
      publicCnameMode: 'PublicCnameMode',
      publicRr: 'PublicRr',
      publicUserDomainName: 'PublicUserDomainName',
      strategyMode: 'StrategyMode',
      ttl: 'Ttl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertConfig: DescribeDnsGtmInstanceResponseBodyConfigAlertConfig,
      alertGroup: 'string',
      cnameType: 'string',
      instanceName: 'string',
      pubicZoneName: 'string',
      publicCnameMode: 'string',
      publicRr: 'string',
      publicUserDomainName: 'string',
      strategyMode: 'string',
      ttl: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmInstanceResponseBodyUsedQuota extends $tea.Model {
  dingtalkUsedCount?: number;
  /**
   * @remarks
   * The total number of emails that were sent.
   * 
   * @example
   * 123
   */
  emailUsedCount?: number;
  /**
   * @remarks
   * The total number of short messages that were sent.
   * 
   * @example
   * 123
   */
  smsUsedCount?: number;
  /**
   * @remarks
   * The number of detection tasks that were created.
   * 
   * @example
   * 123
   */
  taskUsedCount?: number;
  static names(): { [key: string]: string } {
    return {
      dingtalkUsedCount: 'DingtalkUsedCount',
      emailUsedCount: 'EmailUsedCount',
      smsUsedCount: 'SmsUsedCount',
      taskUsedCount: 'TaskUsedCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dingtalkUsedCount: 'number',
      emailUsedCount: 'number',
      smsUsedCount: 'number',
      taskUsedCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmInstanceAddressPoolResponseBodyAddrsAddr extends $tea.Model {
  /**
   * @remarks
   * The address.
   * 
   * @example
   * 1.1.1.1
   */
  addr?: string;
  /**
   * @remarks
   * The status of the last health check on the address. Valid values:
   * 
   * *   OK: No active alerts are triggered.
   * *   ALERT: Alerts are triggered based on the alert rules.
   * 
   * @example
   * ok
   */
  alertStatus?: string;
  /**
   * @remarks
   * The source region of the address.
   * 
   * *   lineCode: the line code of the source region of the address. This parameter is deprecated, and lineCodes prevails.
   * *   lineName: the line name of the source region of the address. This parameter is deprecated.
   * *   lineCodes: the line codes of the source regions of the address.
   * 
   * @example
   * "lineCode":"aliyun_r_cn-zhangjiakou", "lineName": "Alibaba Cloud_China (Zhangjiakou)", "lineCodes": ["aliyun_r_cn-zhangjiakou"]
   */
  attributeInfo?: string;
  /**
   * @remarks
   * The time when the address was added into the address pool.
   * 
   * @example
   * 2017-12-28T13:08Z
   */
  createTime?: string;
  /**
   * @remarks
   * The timestamp that indicates the time when the address was added into the address pool.
   * 
   * @example
   * 1527690629357
   */
  createTimestamp?: number;
  /**
   * @remarks
   * The weight of the address.
   * 
   * @example
   * 1
   */
  lbaWeight?: number;
  /**
   * @remarks
   * The mode of the address. Valid values:
   * 
   * *   SMART: smart return
   * *   ONLINE: always online
   * *   OFFLINE: always offline
   * 
   * @example
   * online
   */
  mode?: string;
  /**
   * @remarks
   * The description of the address.
   * 
   * @example
   * test
   */
  remark?: string;
  /**
   * @remarks
   * The time when the address was last updated.
   * 
   * @example
   * 2017-12-28T13:08Z
   */
  updateTime?: string;
  /**
   * @remarks
   * The timestamp that indicates the time when the address was last updated.
   * 
   * @example
   * 1527690629357
   */
  updateTimestamp?: number;
  static names(): { [key: string]: string } {
    return {
      addr: 'Addr',
      alertStatus: 'AlertStatus',
      attributeInfo: 'AttributeInfo',
      createTime: 'CreateTime',
      createTimestamp: 'CreateTimestamp',
      lbaWeight: 'LbaWeight',
      mode: 'Mode',
      remark: 'Remark',
      updateTime: 'UpdateTime',
      updateTimestamp: 'UpdateTimestamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addr: 'string',
      alertStatus: 'string',
      attributeInfo: 'string',
      createTime: 'string',
      createTimestamp: 'number',
      lbaWeight: 'number',
      mode: 'string',
      remark: 'string',
      updateTime: 'string',
      updateTimestamp: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmInstanceAddressPoolResponseBodyAddrs extends $tea.Model {
  addr?: DescribeDnsGtmInstanceAddressPoolResponseBodyAddrsAddr[];
  static names(): { [key: string]: string } {
    return {
      addr: 'Addr',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addr: { 'type': 'array', 'itemType': DescribeDnsGtmInstanceAddressPoolResponseBodyAddrsAddr },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool extends $tea.Model {
  /**
   * @remarks
   * The number of addresses in the address pool.
   * 
   * @example
   * 1
   */
  addrCount?: number;
  /**
   * @remarks
   * The ID of the address pool.
   * 
   * @example
   * pool-1
   */
  addrPoolId?: string;
  /**
   * @remarks
   * The time when the address pool was created.
   * 
   * @example
   * 2017-12-28T13:08Z
   */
  createTime?: string;
  /**
   * @remarks
   * The timestamp that indicates when the address pool was created.
   * 
   * @example
   * 1527690629357
   */
  createTimestamp?: number;
  /**
   * @remarks
   * The load balancing policy of the address pool. Valid values:
   * 
   * *   ALL_RR: returns all addresses.
   * *   RATIO: returns addresses by weight.
   * 
   * @example
   * all_rr
   */
  lbaStrategy?: string;
  /**
   * @remarks
   * The ID of the health check task.
   * 
   * @example
   * abc123
   */
  monitorConfigId?: string;
  /**
   * @remarks
   * Indicates whether health checks are configured. Valid values:
   * 
   * *   OPEN: enabled
   * *   CLOSE: disabled
   * *   UNCONFIGURED: not configured
   * 
   * @example
   * open
   */
  monitorStatus?: string;
  /**
   * @remarks
   * The name of the address pool.
   * 
   * @example
   * testpool
   */
  name?: string;
  /**
   * @remarks
   * The type of the address pool. Valid values:
   * 
   * *   IPV4: IPv4 address
   * *   IPV6: IPv6 address
   * *   DOMAIN: domain name
   * 
   * @example
   * ipv4
   */
  type?: string;
  /**
   * @remarks
   * The time when the address pool was updated.
   * 
   * @example
   * 2017-12-28T13:08Z
   */
  updateTime?: string;
  /**
   * @remarks
   * The timestamp that indicates when the address pool was updated.
   * 
   * @example
   * 1527690629357
   */
  updateTimestamp?: number;
  static names(): { [key: string]: string } {
    return {
      addrCount: 'AddrCount',
      addrPoolId: 'AddrPoolId',
      createTime: 'CreateTime',
      createTimestamp: 'CreateTimestamp',
      lbaStrategy: 'LbaStrategy',
      monitorConfigId: 'MonitorConfigId',
      monitorStatus: 'MonitorStatus',
      name: 'Name',
      type: 'Type',
      updateTime: 'UpdateTime',
      updateTimestamp: 'UpdateTimestamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addrCount: 'number',
      addrPoolId: 'string',
      createTime: 'string',
      createTimestamp: 'number',
      lbaStrategy: 'string',
      monitorConfigId: 'string',
      monitorStatus: 'string',
      name: 'string',
      type: 'string',
      updateTime: 'string',
      updateTimestamp: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmInstanceAddressPoolsResponseBodyAddrPools extends $tea.Model {
  addrPool?: DescribeDnsGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool[];
  static names(): { [key: string]: string } {
    return {
      addrPool: 'AddrPool',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addrPool: { 'type': 'array', 'itemType': DescribeDnsGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmInstancesResponseBodyGtmInstancesConfigAlertConfig extends $tea.Model {
  dingtalkNotice?: string;
  /**
   * @remarks
   * Indicates whether email notifications were configured. Valid values:
   * 
   * *   true: configured
   * *   false | null: not configured
   * 
   * @example
   * true
   */
  emailNotice?: string;
  /**
   * @remarks
   * The type of the alert event. Valid values:
   * 
   * *   ADDR_ALERT: The address is unavailable.
   * *   ADDR_RESUME: The address is restored and becomes available.
   * *   ADDR_POOL_GROUP_UNAVAILABLE: The address pool group is unavailable.
   * *   ADDR_POOL_GROUP_AVAILABLE: The address pool group is restored and becomes available.
   * *   ACCESS_STRATEGY_POOL_GROUP_SWITCH: Switchover is triggered between the primary and secondary address pools.
   * 
   * @example
   * ADDR_ALERT
   */
  noticeType?: string;
  /**
   * @remarks
   * Indicates whether SMS notifications were configured. Valid values:
   * 
   * *   true: configured
   * *   false | null: not configured
   * 
   * @example
   * true
   */
  smsNotice?: string;
  static names(): { [key: string]: string } {
    return {
      dingtalkNotice: 'DingtalkNotice',
      emailNotice: 'EmailNotice',
      noticeType: 'NoticeType',
      smsNotice: 'SmsNotice',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dingtalkNotice: 'string',
      emailNotice: 'string',
      noticeType: 'string',
      smsNotice: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmInstancesResponseBodyGtmInstancesConfig extends $tea.Model {
  /**
   * @remarks
   * The alert notification methods.
   */
  alertConfig?: DescribeDnsGtmInstancesResponseBodyGtmInstancesConfigAlertConfig[];
  /**
   * @remarks
   * The alert group.
   * 
   * @example
   * testgroup
   */
  alertGroup?: string;
  /**
   * @remarks
   * The access type of the CNAME domain name.
   * 
   * *   The value was set to PUBLIC, which indicates Internet access.
   * 
   * @example
   * public
   */
  cnameType?: string;
  /**
   * @remarks
   * The name of the instance.
   * 
   * @example
   * instanceTest
   */
  instanceName?: string;
  /**
   * @remarks
   * Indicates whether a custom CNAME domain name or a CNAME domain name assigned by the system is used to access GTM over the Internet. Valid values:
   * 
   * *   CUSTOM: a custom CNAME domain name
   * *   SYSTEM_ASSIGN: a CNAME domain name assigned by the system
   * 
   * @example
   * custom
   */
  publicCnameMode?: string;
  /**
   * @example
   * test.rr
   */
  publicRr?: string;
  /**
   * @remarks
   * The website domain name that the user uses on the Internet.
   * 
   * @example
   * example.com
   */
  publicUserDomainName?: string;
  /**
   * @remarks
   * The domain name that is used to access GTM over the Internet.
   * 
   * @example
   * test.rr.gtm-003.com
   */
  publicZoneName?: string;
  /**
   * @remarks
   * The type of the access policy. Valid values:
   * 
   * *   LATENCY: latency-based
   * *   GEO: geographical location-based
   * 
   * @example
   * geo
   */
  strategyMode?: string;
  /**
   * @remarks
   * The global time to live (TTL).
   * 
   * @example
   * 1
   */
  ttl?: number;
  static names(): { [key: string]: string } {
    return {
      alertConfig: 'AlertConfig',
      alertGroup: 'AlertGroup',
      cnameType: 'CnameType',
      instanceName: 'InstanceName',
      publicCnameMode: 'PublicCnameMode',
      publicRr: 'PublicRr',
      publicUserDomainName: 'PublicUserDomainName',
      publicZoneName: 'PublicZoneName',
      strategyMode: 'StrategyMode',
      ttl: 'Ttl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertConfig: { 'type': 'array', 'itemType': DescribeDnsGtmInstancesResponseBodyGtmInstancesConfigAlertConfig },
      alertGroup: 'string',
      cnameType: 'string',
      instanceName: 'string',
      publicCnameMode: 'string',
      publicRr: 'string',
      publicUserDomainName: 'string',
      publicZoneName: 'string',
      strategyMode: 'string',
      ttl: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmInstancesResponseBodyGtmInstancesUsedQuota extends $tea.Model {
  dingtalkUsedCount?: number;
  /**
   * @remarks
   * The total number of email notifications that were sent.
   * 
   * @example
   * 100
   */
  emailUsedCount?: number;
  /**
   * @remarks
   * The total number of SMS notifications that were sent.
   * 
   * @example
   * 100
   */
  smsUsedCount?: number;
  /**
   * @remarks
   * The number of detection tasks that were created.
   * 
   * @example
   * 100
   */
  taskUsedCount?: number;
  static names(): { [key: string]: string } {
    return {
      dingtalkUsedCount: 'DingtalkUsedCount',
      emailUsedCount: 'EmailUsedCount',
      smsUsedCount: 'SmsUsedCount',
      taskUsedCount: 'TaskUsedCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dingtalkUsedCount: 'number',
      emailUsedCount: 'number',
      smsUsedCount: 'number',
      taskUsedCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmInstancesResponseBodyGtmInstances extends $tea.Model {
  /**
   * @remarks
   * The configurations of the instance.
   */
  config?: DescribeDnsGtmInstancesResponseBodyGtmInstancesConfig;
  /**
   * @remarks
   * The time when the instance was created.
   * 
   * @example
   * 2020-10-14T06:58Z
   */
  createTime?: string;
  /**
   * @remarks
   * The timestamp that indicates when the instance was created.
   * 
   * @example
   * 1602658709000
   */
  createTimestamp?: number;
  /**
   * @remarks
   * The time when the instance expires.
   * 
   * @example
   * 2020-10-14T06:58Z
   */
  expireTime?: string;
  /**
   * @remarks
   * The timestamp that indicates when the instance expires.
   * 
   * @example
   * 1602658709000
   */
  expireTimestamp?: number;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * instance1
   */
  instanceId?: string;
  /**
   * @remarks
   * The billing method of the instance.
   * 
   * *   The value is set to Subscription.
   * 
   * @example
   * Subscription
   */
  paymentType?: string;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs.
   * 
   * @example
   * resourceGroupid123
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The total number of SMS notifications.
   * 
   * @example
   * 1
   */
  smsQuota?: number;
  /**
   * @remarks
   * The total number of detection tasks.
   * 
   * @example
   * 1
   */
  taskQuota?: number;
  /**
   * @remarks
   * The used quota.
   */
  usedQuota?: DescribeDnsGtmInstancesResponseBodyGtmInstancesUsedQuota;
  /**
   * @remarks
   * The version of the instance.
   * 
   * @example
   * testVersion1
   */
  versionCode?: string;
  static names(): { [key: string]: string } {
    return {
      config: 'Config',
      createTime: 'CreateTime',
      createTimestamp: 'CreateTimestamp',
      expireTime: 'ExpireTime',
      expireTimestamp: 'ExpireTimestamp',
      instanceId: 'InstanceId',
      paymentType: 'PaymentType',
      resourceGroupId: 'ResourceGroupId',
      smsQuota: 'SmsQuota',
      taskQuota: 'TaskQuota',
      usedQuota: 'UsedQuota',
      versionCode: 'VersionCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      config: DescribeDnsGtmInstancesResponseBodyGtmInstancesConfig,
      createTime: 'string',
      createTimestamp: 'number',
      expireTime: 'string',
      expireTimestamp: 'number',
      instanceId: 'string',
      paymentType: 'string',
      resourceGroupId: 'string',
      smsQuota: 'number',
      taskQuota: 'number',
      usedQuota: DescribeDnsGtmInstancesResponseBodyGtmInstancesUsedQuota,
      versionCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmLogsResponseBodyLogsLog extends $tea.Model {
  /**
   * @remarks
   * The formatted message content.
   * 
   * @example
   * addtest-pool-1
   */
  content?: string;
  /**
   * @remarks
   * The ID of the object on which the operation was performed.
   * 
   * @example
   * 121212
   */
  entityId?: string;
  /**
   * @remarks
   * The name of the object on which the operation was performed.
   * 
   * @example
   * test-pool-1
   */
  entityName?: string;
  /**
   * @remarks
   * The type of the object on which the operation was performed.
   */
  entityType?: string;
  /**
   * @remarks
   * The ID of the record.
   * 
   * @example
   * 6726
   */
  id?: number;
  /**
   * @remarks
   * The operation performed.
   */
  operAction?: string;
  /**
   * @remarks
   * The time when the operation was performed.
   * 
   * @example
   * 2018-01-24T07:35Z
   */
  operTime?: string;
  /**
   * @remarks
   * The timestamp of the operation.
   * 
   * @example
   * 1516779348000
   */
  operTimestamp?: number;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      entityId: 'EntityId',
      entityName: 'EntityName',
      entityType: 'EntityType',
      id: 'Id',
      operAction: 'OperAction',
      operTime: 'OperTime',
      operTimestamp: 'OperTimestamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      entityId: 'string',
      entityName: 'string',
      entityType: 'string',
      id: 'number',
      operAction: 'string',
      operTime: 'string',
      operTimestamp: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmLogsResponseBodyLogs extends $tea.Model {
  log?: DescribeDnsGtmLogsResponseBodyLogsLog[];
  static names(): { [key: string]: string } {
    return {
      log: 'Log',
    };
  }

  static types(): { [key: string]: any } {
    return {
      log: { 'type': 'array', 'itemType': DescribeDnsGtmLogsResponseBodyLogsLog },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodesDomainIpv4IspCityNodeIps extends $tea.Model {
  ip?: string[];
  static names(): { [key: string]: string } {
    return {
      ip: 'Ip',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ip: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodesDomainIpv4IspCityNode extends $tea.Model {
  /**
   * @remarks
   * The code of the city where the monitored node is deployed.
   * 
   * @example
   * 503
   */
  cityCode?: string;
  /**
   * @remarks
   * The display name of the city where the monitored node is deployed.
   * 
   * @example
   * Zhangjiakou
   */
  cityName?: string;
  /**
   * @remarks
   * Indicates whether the monitored node is selected for the health check by default.
   * 
   * @example
   * true
   */
  defaultSelected?: boolean;
  /**
   * @remarks
   * The name of the group to which the monitored node belongs.
   * 
   * @example
   * BGP Nodes
   */
  groupName?: string;
  /**
   * @remarks
   * The type of the group to which the monitored node belongs. Valid values:
   * 
   * *   BGP: BGP nodes
   * *   OVERSEAS: nodes outside the Chinese mainland
   * *   ISP: ISP nodes
   * 
   * @example
   * BGP
   */
  groupType?: string;
  ips?: DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodesDomainIpv4IspCityNodeIps;
  /**
   * @remarks
   * The code of the ISP to which the monitored node belongs.
   * 
   * @example
   * 465
   */
  ispCode?: string;
  /**
   * @remarks
   * The display name of the ISP to which the monitored node belongs.
   * 
   * @example
   * Alibaba
   */
  ispName?: string;
  static names(): { [key: string]: string } {
    return {
      cityCode: 'CityCode',
      cityName: 'CityName',
      defaultSelected: 'DefaultSelected',
      groupName: 'GroupName',
      groupType: 'GroupType',
      ips: 'Ips',
      ispCode: 'IspCode',
      ispName: 'IspName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cityCode: 'string',
      cityName: 'string',
      defaultSelected: 'boolean',
      groupName: 'string',
      groupType: 'string',
      ips: DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodesDomainIpv4IspCityNodeIps,
      ispCode: 'string',
      ispName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodes extends $tea.Model {
  domainIpv4IspCityNode?: DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodesDomainIpv4IspCityNode[];
  static names(): { [key: string]: string } {
    return {
      domainIpv4IspCityNode: 'DomainIpv4IspCityNode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainIpv4IspCityNode: { 'type': 'array', 'itemType': DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodesDomainIpv4IspCityNode },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodesDomainIpv6IspCityNodeIps extends $tea.Model {
  ip?: string[];
  static names(): { [key: string]: string } {
    return {
      ip: 'ip',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ip: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodesDomainIpv6IspCityNode extends $tea.Model {
  /**
   * @remarks
   * The code of the city where the monitored node is deployed.
   * 
   * @example
   * 503
   */
  cityCode?: string;
  /**
   * @remarks
   * The display name of the city where the monitored node is deployed.
   * 
   * @example
   * Zhangjiakou
   */
  cityName?: string;
  /**
   * @remarks
   * Indicates whether the monitored node is selected for the health check by default.
   * 
   * @example
   * false
   */
  defaultSelected?: boolean;
  /**
   * @remarks
   * The name of the group to which the monitored node belongs.
   * 
   * @example
   * BGP Nodes
   */
  groupName?: string;
  /**
   * @remarks
   * The type of the group to which the monitored node belongs. Valid values:
   * 
   * *   BGP: BGP nodes
   * *   OVERSEAS: nodes outside the Chinese mainland
   * *   ISP: ISP nodes
   * 
   * @example
   * BGP
   */
  groupType?: string;
  ips?: DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodesDomainIpv6IspCityNodeIps;
  /**
   * @remarks
   * The code of the ISP to which the monitored node belongs.
   * 
   * @example
   * 465
   */
  ispCode?: string;
  /**
   * @remarks
   * The display name of the ISP to which the monitored node belongs.
   * 
   * @example
   * Alibaba
   */
  ispName?: string;
  static names(): { [key: string]: string } {
    return {
      cityCode: 'CityCode',
      cityName: 'CityName',
      defaultSelected: 'DefaultSelected',
      groupName: 'GroupName',
      groupType: 'GroupType',
      ips: 'Ips',
      ispCode: 'IspCode',
      ispName: 'IspName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cityCode: 'string',
      cityName: 'string',
      defaultSelected: 'boolean',
      groupName: 'string',
      groupType: 'string',
      ips: DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodesDomainIpv6IspCityNodeIps,
      ispCode: 'string',
      ispName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodes extends $tea.Model {
  domainIpv6IspCityNode?: DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodesDomainIpv6IspCityNode[];
  static names(): { [key: string]: string } {
    return {
      domainIpv6IspCityNode: 'DomainIpv6IspCityNode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainIpv6IspCityNode: { 'type': 'array', 'itemType': DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodesDomainIpv6IspCityNode },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodesIpv4IspCityNodeIps extends $tea.Model {
  ip?: string[];
  static names(): { [key: string]: string } {
    return {
      ip: 'Ip',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ip: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodesIpv4IspCityNode extends $tea.Model {
  /**
   * @remarks
   * The code of the city where the monitored node is deployed.
   * 
   * @example
   * 503
   */
  cityCode?: string;
  /**
   * @remarks
   * The display name of the city where the monitored node is deployed.
   * 
   * @example
   * Zhangjiakou
   */
  cityName?: string;
  /**
   * @remarks
   * Indicates whether the monitored node is selected for the health check by default.
   * 
   * @example
   * true
   */
  defaultSelected?: boolean;
  /**
   * @remarks
   * The name of the group to which the monitored node belongs.
   * 
   * @example
   * BGP Nodes
   */
  groupName?: string;
  /**
   * @remarks
   * The type of the group to which the monitored node belongs. Valid values:
   * 
   * *   BGP: Border Gateway Protocol (BGP) nodes
   * *   OVERSEAS: nodes outside the Chinese mainland
   * *   ISP: ISP nodes
   * 
   * @example
   * BGP
   */
  groupType?: string;
  ips?: DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodesIpv4IspCityNodeIps;
  /**
   * @remarks
   * The code of the Internet service provider (ISP) to which the monitored node belongs.
   * 
   * @example
   * 465
   */
  ispCode?: string;
  /**
   * @remarks
   * The display name of the ISP to which the monitored node belongs.
   * 
   * @example
   * Alibaba
   */
  ispName?: string;
  static names(): { [key: string]: string } {
    return {
      cityCode: 'CityCode',
      cityName: 'CityName',
      defaultSelected: 'DefaultSelected',
      groupName: 'GroupName',
      groupType: 'GroupType',
      ips: 'Ips',
      ispCode: 'IspCode',
      ispName: 'IspName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cityCode: 'string',
      cityName: 'string',
      defaultSelected: 'boolean',
      groupName: 'string',
      groupType: 'string',
      ips: DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodesIpv4IspCityNodeIps,
      ispCode: 'string',
      ispName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodes extends $tea.Model {
  ipv4IspCityNode?: DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodesIpv4IspCityNode[];
  static names(): { [key: string]: string } {
    return {
      ipv4IspCityNode: 'Ipv4IspCityNode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ipv4IspCityNode: { 'type': 'array', 'itemType': DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodesIpv4IspCityNode },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodesIpv6IspCityNodeIps extends $tea.Model {
  ip?: string[];
  static names(): { [key: string]: string } {
    return {
      ip: 'Ip',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ip: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodesIpv6IspCityNode extends $tea.Model {
  /**
   * @remarks
   * The code of the city where the monitored node is deployed.
   * 
   * @example
   * 503
   */
  cityCode?: string;
  /**
   * @remarks
   * The display name of the city where the monitored node is deployed.
   * 
   * @example
   * Zhangjiakou
   */
  cityName?: string;
  /**
   * @remarks
   * Indicates whether the monitored node is selected for the health check by default.
   * 
   * @example
   * true
   */
  defaultSelected?: boolean;
  /**
   * @remarks
   * The name of the group to which the monitored node belongs.
   * 
   * @example
   * BGP Nodes
   */
  groupName?: string;
  /**
   * @remarks
   * The type of the group to which the monitored node belongs. Valid values:
   * 
   * *   BGP: BGP nodes
   * *   OVERSEAS: nodes outside the Chinese mainland
   * *   ISP: ISP nodes
   * 
   * @example
   * BGP
   */
  groupType?: string;
  ips?: DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodesIpv6IspCityNodeIps;
  /**
   * @remarks
   * The code of the ISP to which the monitored node belongs.
   * 
   * @example
   * 465
   */
  ispCode?: string;
  /**
   * @remarks
   * The display name of the ISP to which the monitored node belongs.
   * 
   * @example
   * Alibaba
   */
  ispName?: string;
  static names(): { [key: string]: string } {
    return {
      cityCode: 'CityCode',
      cityName: 'CityName',
      defaultSelected: 'DefaultSelected',
      groupName: 'GroupName',
      groupType: 'GroupType',
      ips: 'Ips',
      ispCode: 'IspCode',
      ispName: 'IspName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cityCode: 'string',
      cityName: 'string',
      defaultSelected: 'boolean',
      groupName: 'string',
      groupType: 'string',
      ips: DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodesIpv6IspCityNodeIps,
      ispCode: 'string',
      ispName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodes extends $tea.Model {
  ipv6IspCityNode?: DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodesIpv6IspCityNode[];
  static names(): { [key: string]: string } {
    return {
      ipv6IspCityNode: 'Ipv6IspCityNode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ipv6IspCityNode: { 'type': 'array', 'itemType': DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodesIpv6IspCityNode },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmMonitorConfigResponseBodyIspCityNodesIspCityNode extends $tea.Model {
  /**
   * @remarks
   * The code of the monitored city node.
   * 
   * @example
   * 572
   */
  cityCode?: string;
  /**
   * @remarks
   * The display name of the monitored city node.
   * 
   * @example
   * Qingdao
   */
  cityName?: string;
  /**
   * @remarks
   * The code of the country or region.
   * 
   * @example
   * 001
   */
  countryCode?: string;
  /**
   * @remarks
   * The display name of the country or region.
   * 
   * @example
   * China
   */
  countryName?: string;
  /**
   * @remarks
   * The code of the monitored Internet service provider (ISP) node.
   * 
   * @example
   * 123
   */
  ispCode?: string;
  /**
   * @remarks
   * The name of the ISP.
   * 
   * @example
   * Alibaba
   */
  ispName?: string;
  static names(): { [key: string]: string } {
    return {
      cityCode: 'CityCode',
      cityName: 'CityName',
      countryCode: 'CountryCode',
      countryName: 'CountryName',
      ispCode: 'IspCode',
      ispName: 'IspName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cityCode: 'string',
      cityName: 'string',
      countryCode: 'string',
      countryName: 'string',
      ispCode: 'string',
      ispName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsGtmMonitorConfigResponseBodyIspCityNodes extends $tea.Model {
  ispCityNode?: DescribeDnsGtmMonitorConfigResponseBodyIspCityNodesIspCityNode[];
  static names(): { [key: string]: string } {
    return {
      ispCityNode: 'IspCityNode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ispCityNode: { 'type': 'array', 'itemType': DescribeDnsGtmMonitorConfigResponseBodyIspCityNodesIspCityNode },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsProductInstanceResponseBodyDnsServers extends $tea.Model {
  dnsServer?: string[];
  static names(): { [key: string]: string } {
    return {
      dnsServer: 'DnsServer',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dnsServer: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct extends $tea.Model {
  /**
   * @remarks
   * Indicates whether auto-renewal is enabled for the extra internal bandwidth that you purchased. Valid values:
   * 
   * *   **true**: Auto-renewal is enabled.
   * *   **false**: Auto-renewal is disabled.
   * 
   * > If no extra internal bandwidth is purchased, this parameter is not returned.
   * 
   * @example
   * true
   */
  autoRenewal?: boolean;
  /**
   * @remarks
   * The number of times you can change domain names that are bound to the DNS instance. It can be specified by the user who uses Alibaba Cloud DNS of the custom version.
   * 
   * @example
   * 3
   */
  bindCount?: number;
  /**
   * @remarks
   * The number of domain names that can be bound to the DNS instance.
   * 
   * @example
   * 5
   */
  bindDomainCount?: number;
  /**
   * @remarks
   * The number of domain names that have been bound to the DNS instance.
   * 
   * @example
   * 3
   */
  bindDomainUsedCount?: number;
  /**
   * @remarks
   * The number of times you have changed domain names that are bound to the DNS instance. It can be specified by the user who uses Alibaba Cloud DNS of the custom version.
   * 
   * @example
   * 1
   */
  bindUsedCount?: number;
  /**
   * @remarks
   * The DDoS protection traffic. Unit: GB.
   * 
   * @example
   * 50
   */
  DDosDefendFlow?: number;
  /**
   * @remarks
   * The DDoS protection frequency. Unit: 10,000 QPS.
   * 
   * @example
   * 50
   */
  DDosDefendQuery?: number;
  /**
   * @remarks
   * The number of IP addresses supported by a domain name or line.
   * 
   * @example
   * 15
   */
  dnsSLBCount?: number;
  /**
   * @remarks
   * The DNS security policy. Valid values:
   * 
   * *   **no**: not required.
   * *   **basic**: anti-DDoS basic.
   * *   **advanced**: anti-DDoS advanced.
   * 
   * @example
   * no
   */
  dnsSecurity?: string;
  /**
   * @remarks
   * The bound domain name.
   * 
   * @example
   * example.com
   */
  domain?: string;
  /**
   * @remarks
   * The time at which the instance expired.
   * 
   * @example
   * 2015-12-12T00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The UNIX timestamp representing the expiration time of the instance.
   * 
   * @example
   * 1474335170000
   */
  endTimestamp?: number;
  /**
   * @remarks
   * Indicates whether global server load balancing (GSLB) was allowed.
   * 
   * @example
   * true
   */
  gslb?: boolean;
  /**
   * @remarks
   * The list of ISP lines.
   * 
   * @example
   * China Mobile,China Unicom,China Telecom,China Edu
   */
  ISPLines?: string;
  /**
   * @remarks
   * The list of ISP line subdivisions.
   * 
   * @example
   * Telecom (Province), Mobile (Province), Unicom (Province), Education Network (Province)
   */
  ISPRegionLines?: string;
  /**
   * @remarks
   * Indicates whether the request for domain name resolution was in the black hole.
   * 
   * @example
   * false
   */
  inBlackHole?: boolean;
  /**
   * @remarks
   * Indicates whether the request for domain name resolution was being cleared.
   * 
   * @example
   * false
   */
  inClean?: boolean;
  /**
   * @remarks
   * The ID of the Alibaba Cloud DNS instance.
   * 
   * @example
   * i-8fj
   */
  instanceId?: string;
  /**
   * @remarks
   * The monitoring frequency. Unit: minutes.
   * 
   * @example
   * 50
   */
  monitorFrequency?: number;
  /**
   * @remarks
   * The number of monitored nodes.
   * 
   * @example
   * 5
   */
  monitorNodeCount?: number;
  /**
   * @remarks
   * The number of monitoring tasks.
   * 
   * @example
   * 2
   */
  monitorTaskCount?: number;
  /**
   * @remarks
   * DDoS protection traffic outside China. Unit: GB.
   * 
   * @example
   * 1
   */
  overseaDDosDefendFlow?: number;
  /**
   * @remarks
   * The type of the overseas line.
   * 
   * @example
   * Countries
   */
  overseaLine?: string;
  /**
   * @remarks
   * The billing method. Valid value:
   * 
   * *   Subscription: You can pay in advance for the use of resources.
   * 
   * @example
   * Subscription
   */
  paymentType?: string;
  /**
   * @remarks
   * Indicates whether regional lines were allowed.
   * 
   * @example
   * true
   */
  regionLines?: boolean;
  /**
   * @remarks
   * The list of search engine lines.
   * 
   * @example
   * Search Engine Robots,Google Robots,Baidu Robots,Bing Robots
   */
  searchEngineLines?: string;
  /**
   * @remarks
   * The time when the DNS instance was purchased.
   * 
   * @example
   * 2015-11-12T09:23Z
   */
  startTime?: string;
  /**
   * @remarks
   * The UNIX timestamp representing when the DNS instance was purchased.
   * 
   * @example
   * 1474335170000
   */
  startTimestamp?: number;
  /**
   * @remarks
   * The number of subdomain name levels.
   * 
   * @example
   * 6
   */
  subDomainLevel?: number;
  /**
   * @remarks
   * The minimum TTL. Unit: seconds.
   * 
   * @example
   * 10
   */
  TTLMinValue?: number;
  /**
   * @remarks
   * The URL forwarding quantity.
   * 
   * @example
   * 20
   */
  URLForwardCount?: number;
  /**
   * @remarks
   * The version code of the Alibaba Cloud DNS instance.
   * 
   * @example
   * version1
   */
  versionCode?: string;
  /**
   * @remarks
   * The version name of the Alibaba Cloud DNS instance.
   * 
   * @example
   * Alibaba Cloud DNS
   */
  versionName?: string;
  static names(): { [key: string]: string } {
    return {
      autoRenewal: 'AutoRenewal',
      bindCount: 'BindCount',
      bindDomainCount: 'BindDomainCount',
      bindDomainUsedCount: 'BindDomainUsedCount',
      bindUsedCount: 'BindUsedCount',
      DDosDefendFlow: 'DDosDefendFlow',
      DDosDefendQuery: 'DDosDefendQuery',
      dnsSLBCount: 'DnsSLBCount',
      dnsSecurity: 'DnsSecurity',
      domain: 'Domain',
      endTime: 'EndTime',
      endTimestamp: 'EndTimestamp',
      gslb: 'Gslb',
      ISPLines: 'ISPLines',
      ISPRegionLines: 'ISPRegionLines',
      inBlackHole: 'InBlackHole',
      inClean: 'InClean',
      instanceId: 'InstanceId',
      monitorFrequency: 'MonitorFrequency',
      monitorNodeCount: 'MonitorNodeCount',
      monitorTaskCount: 'MonitorTaskCount',
      overseaDDosDefendFlow: 'OverseaDDosDefendFlow',
      overseaLine: 'OverseaLine',
      paymentType: 'PaymentType',
      regionLines: 'RegionLines',
      searchEngineLines: 'SearchEngineLines',
      startTime: 'StartTime',
      startTimestamp: 'StartTimestamp',
      subDomainLevel: 'SubDomainLevel',
      TTLMinValue: 'TTLMinValue',
      URLForwardCount: 'URLForwardCount',
      versionCode: 'VersionCode',
      versionName: 'VersionName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoRenewal: 'boolean',
      bindCount: 'number',
      bindDomainCount: 'number',
      bindDomainUsedCount: 'number',
      bindUsedCount: 'number',
      DDosDefendFlow: 'number',
      DDosDefendQuery: 'number',
      dnsSLBCount: 'number',
      dnsSecurity: 'string',
      domain: 'string',
      endTime: 'string',
      endTimestamp: 'number',
      gslb: 'boolean',
      ISPLines: 'string',
      ISPRegionLines: 'string',
      inBlackHole: 'boolean',
      inClean: 'boolean',
      instanceId: 'string',
      monitorFrequency: 'number',
      monitorNodeCount: 'number',
      monitorTaskCount: 'number',
      overseaDDosDefendFlow: 'number',
      overseaLine: 'string',
      paymentType: 'string',
      regionLines: 'boolean',
      searchEngineLines: 'string',
      startTime: 'string',
      startTimestamp: 'number',
      subDomainLevel: 'number',
      TTLMinValue: 'number',
      URLForwardCount: 'number',
      versionCode: 'string',
      versionName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDnsProductInstancesResponseBodyDnsProducts extends $tea.Model {
  dnsProduct?: DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct[];
  static names(): { [key: string]: string } {
    return {
      dnsProduct: 'DnsProduct',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dnsProduct: { 'type': 'array', 'itemType': DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDohAccountStatisticsResponseBodyStatistics extends $tea.Model {
  /**
   * @remarks
   * The timestamp.
   * 
   * @example
   * 1544976000000
   */
  timestamp?: number;
  /**
   * @remarks
   * The total number of requests.
   * 
   * @example
   * 3141592653
   */
  totalCount?: number;
  /**
   * @remarks
   * The number of IPv4-based HTTP requests.
   * 
   * @example
   * 3141592653
   */
  v4HttpCount?: number;
  /**
   * @remarks
   * The number of IPv4-based HTTPS requests.
   * 
   * @example
   * 3141592653
   */
  v4HttpsCount?: number;
  /**
   * @remarks
   * The number of IPv6-based HTTP requests.
   * 
   * @example
   * 3141592653
   */
  v6HttpCount?: number;
  /**
   * @remarks
   * The number of IPv6-based HTTPS requests.
   * 
   * @example
   * 3141592653
   */
  v6HttpsCount?: number;
  static names(): { [key: string]: string } {
    return {
      timestamp: 'Timestamp',
      totalCount: 'TotalCount',
      v4HttpCount: 'V4HttpCount',
      v4HttpsCount: 'V4HttpsCount',
      v6HttpCount: 'V6HttpCount',
      v6HttpsCount: 'V6HttpsCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timestamp: 'number',
      totalCount: 'number',
      v4HttpCount: 'number',
      v4HttpsCount: 'number',
      v6HttpCount: 'number',
      v6HttpsCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDohDomainStatisticsResponseBodyStatistics extends $tea.Model {
  /**
   * @remarks
   * The timestamp.
   * 
   * @example
   * 1544976000000
   */
  timestamp?: number;
  /**
   * @remarks
   * The total number of requests.
   * 
   * @example
   * 3141592653
   */
  totalCount?: number;
  /**
   * @remarks
   * The number of IPv4-based HTTP requests.
   * 
   * @example
   * 3141592653
   */
  v4HttpCount?: number;
  /**
   * @remarks
   * The number of IPv4-based HTTPS requests.
   * 
   * @example
   * 3141592653
   */
  v4HttpsCount?: number;
  /**
   * @remarks
   * The number of IPv6-based HTTP requests.
   * 
   * @example
   * 3141592653
   */
  v6HttpCount?: number;
  /**
   * @remarks
   * The number of IPv6-based HTTPS requests.
   * 
   * @example
   * 3141592653
   */
  v6HttpsCount?: number;
  static names(): { [key: string]: string } {
    return {
      timestamp: 'Timestamp',
      totalCount: 'TotalCount',
      v4HttpCount: 'V4HttpCount',
      v4HttpsCount: 'V4HttpsCount',
      v6HttpCount: 'V6HttpCount',
      v6HttpsCount: 'V6HttpsCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timestamp: 'number',
      totalCount: 'number',
      v4HttpCount: 'number',
      v4HttpsCount: 'number',
      v6HttpCount: 'number',
      v6HttpsCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDohDomainStatisticsSummaryResponseBodyStatistics extends $tea.Model {
  /**
   * @remarks
   * The domain name.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The number of HTTP requests.
   * 
   * @example
   * 3141592653
   */
  httpCount?: number;
  /**
   * @remarks
   * The number of HTTPS requests.
   * 
   * @example
   * 3141592653
   */
  httpsCount?: number;
  /**
   * @remarks
   * The number of IP addresses.
   * 
   * @example
   * 20
   */
  ipCount?: number;
  /**
   * @remarks
   * The total number of requests.
   * 
   * @example
   * 14141592653
   */
  totalCount?: number;
  /**
   * @remarks
   * The number of IPv4-based HTTP requests.
   * 
   * @example
   * 3141592653
   */
  v4HttpCount?: number;
  /**
   * @remarks
   * The number of IPv4-based HTTPS requests.
   * 
   * @example
   * 3141592653
   */
  v4HttpsCount?: number;
  /**
   * @remarks
   * The number of IPv6-based HTTP requests.
   * 
   * @example
   * 3141592653
   */
  v6HttpCount?: number;
  /**
   * @remarks
   * The number of IPv6-based HTTPS requests.
   * 
   * @example
   * 3141592653
   */
  v6HttpsCount?: number;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      httpCount: 'HttpCount',
      httpsCount: 'HttpsCount',
      ipCount: 'IpCount',
      totalCount: 'TotalCount',
      v4HttpCount: 'V4HttpCount',
      v4HttpsCount: 'V4HttpsCount',
      v6HttpCount: 'V6HttpCount',
      v6HttpsCount: 'V6HttpsCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      httpCount: 'number',
      httpsCount: 'number',
      ipCount: 'number',
      totalCount: 'number',
      v4HttpCount: 'number',
      v4HttpsCount: 'number',
      v6HttpCount: 'number',
      v6HttpsCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDohSubDomainStatisticsResponseBodyStatistics extends $tea.Model {
  /**
   * @remarks
   * The timestamp.
   * 
   * @example
   * 1544976000000
   */
  timestamp?: number;
  /**
   * @remarks
   * The total number of requests.
   * 
   * @example
   * 3141592653
   */
  totalCount?: number;
  /**
   * @remarks
   * The number of IPv4-based HTTP requests.
   * 
   * @example
   * 3141592653
   */
  v4HttpCount?: number;
  /**
   * @remarks
   * The number of IPv4-based HTTPS requests.
   * 
   * @example
   * 3141592653
   */
  v4HttpsCount?: number;
  /**
   * @remarks
   * The number of IPv6-based HTTP requests.
   * 
   * @example
   * 3141592653
   */
  v6HttpCount?: number;
  /**
   * @remarks
   * The number of IPv6-based HTTPS requests.
   * 
   * @example
   * 3141592653
   */
  v6HttpsCount?: number;
  static names(): { [key: string]: string } {
    return {
      timestamp: 'Timestamp',
      totalCount: 'TotalCount',
      v4HttpCount: 'V4HttpCount',
      v4HttpsCount: 'V4HttpsCount',
      v6HttpCount: 'V6HttpCount',
      v6HttpsCount: 'V6HttpsCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timestamp: 'number',
      totalCount: 'number',
      v4HttpCount: 'number',
      v4HttpsCount: 'number',
      v6HttpCount: 'number',
      v6HttpsCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDohSubDomainStatisticsSummaryResponseBodyStatistics extends $tea.Model {
  /**
   * @remarks
   * The number of HTTP requests.
   * 
   * @example
   * 3141592653
   */
  httpCount?: number;
  /**
   * @remarks
   * The number of HTTPS requests.
   * 
   * @example
   * 3141592653
   */
  httpsCount?: number;
  /**
   * @remarks
   * The number of IP addresses.
   * 
   * @example
   * 20
   */
  ipCount?: number;
  /**
   * @remarks
   * The subdomain.
   * 
   * @example
   * www.example.com
   */
  subDomain?: string;
  /**
   * @remarks
   * Total number of requests.
   * 
   * @example
   * 14141592653
   */
  totalCount?: number;
  /**
   * @remarks
   * The number of IPv4-based HTTP requests.
   * 
   * @example
   * 3141592653
   */
  v4HttpCount?: number;
  /**
   * @remarks
   * The number of IPv4-based HTTPS requests.
   * 
   * @example
   * 3141592653
   */
  v4HttpsCount?: number;
  /**
   * @remarks
   * The number of IPv6-based HTTP requests.
   * 
   * @example
   * 3141592653
   */
  v6HttpCount?: number;
  /**
   * @remarks
   * The number of IPv6-based HTTPS requests.
   * 
   * @example
   * 3141592653
   */
  v6HttpsCount?: number;
  static names(): { [key: string]: string } {
    return {
      httpCount: 'HttpCount',
      httpsCount: 'HttpsCount',
      ipCount: 'IpCount',
      subDomain: 'SubDomain',
      totalCount: 'TotalCount',
      v4HttpCount: 'V4HttpCount',
      v4HttpsCount: 'V4HttpsCount',
      v6HttpCount: 'V6HttpCount',
      v6HttpsCount: 'V6HttpsCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      httpCount: 'number',
      httpsCount: 'number',
      ipCount: 'number',
      subDomain: 'string',
      totalCount: 'number',
      v4HttpCount: 'number',
      v4HttpsCount: 'number',
      v6HttpCount: 'number',
      v6HttpsCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainGroupsResponseBodyDomainGroupsDomainGroup extends $tea.Model {
  /**
   * @remarks
   * The number of domain name groups.
   * 
   * @example
   * 2
   */
  domainCount?: number;
  /**
   * @remarks
   * The ID of the domain name group. Valid values:
   * 
   * *   defaultGroup: the default group
   * *   If an empty string is returned, it indicates the group that contains all domain names.
   * 
   * @example
   * 2223
   */
  groupId?: string;
  /**
   * @remarks
   * The name of the domain name group.
   * 
   * @example
   * MyGroup
   */
  groupName?: string;
  static names(): { [key: string]: string } {
    return {
      domainCount: 'DomainCount',
      groupId: 'GroupId',
      groupName: 'GroupName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainCount: 'number',
      groupId: 'string',
      groupName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainGroupsResponseBodyDomainGroups extends $tea.Model {
  domainGroup?: DescribeDomainGroupsResponseBodyDomainGroupsDomainGroup[];
  static names(): { [key: string]: string } {
    return {
      domainGroup: 'DomainGroup',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainGroup: { 'type': 'array', 'itemType': DescribeDomainGroupsResponseBodyDomainGroupsDomainGroup },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainInfoResponseBodyAvailableTtls extends $tea.Model {
  availableTtl?: string[];
  static names(): { [key: string]: string } {
    return {
      availableTtl: 'AvailableTtl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      availableTtl: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainInfoResponseBodyDnsServers extends $tea.Model {
  dnsServer?: string[];
  static names(): { [key: string]: string } {
    return {
      dnsServer: 'DnsServer',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dnsServer: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainInfoResponseBodyRecordLinesRecordLine extends $tea.Model {
  /**
   * @remarks
   * The code of the parent line. This parameter is not returned if the line has no parent line.
   * 
   * @example
   * internal
   */
  fatherCode?: string;
  /**
   * @remarks
   * The code of the line.
   * 
   * @example
   * cn_region_xibei
   */
  lineCode?: string;
  /**
   * @remarks
   * The name of the parent line.
   */
  lineDisplayName?: string;
  /**
   * @remarks
   * The name of the line.
   */
  lineName?: string;
  static names(): { [key: string]: string } {
    return {
      fatherCode: 'FatherCode',
      lineCode: 'LineCode',
      lineDisplayName: 'LineDisplayName',
      lineName: 'LineName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fatherCode: 'string',
      lineCode: 'string',
      lineDisplayName: 'string',
      lineName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainInfoResponseBodyRecordLines extends $tea.Model {
  recordLine?: DescribeDomainInfoResponseBodyRecordLinesRecordLine[];
  static names(): { [key: string]: string } {
    return {
      recordLine: 'RecordLine',
    };
  }

  static types(): { [key: string]: any } {
    return {
      recordLine: { 'type': 'array', 'itemType': DescribeDomainInfoResponseBodyRecordLinesRecordLine },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainLogsResponseBodyDomainLogsDomainLog extends $tea.Model {
  /**
   * @remarks
   * The operation.
   * 
   * @example
   * Add
   */
  action?: string;
  /**
   * @remarks
   * The time when the operation is performed. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.
   * 
   * @example
   * 2015-12-12T09:23Z
   */
  actionTime?: string;
  /**
   * @remarks
   * The time when the operation was performed. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
   * 
   * @example
   * 143562300000
   */
  actionTimestamp?: number;
  /**
   * @remarks
   * The IP address of the operator.
   * 
   * @example
   * 182.92.253.20
   */
  clientIp?: string;
  /**
   * @remarks
   * The domain name.
   * 
   * @example
   * abc.com
   */
  domainName?: string;
  /**
   * @remarks
   * The message for the operation.
   * 
   * @example
   * To the DNS record list
   */
  message?: string;
  /**
   * @remarks
   * The ID of the private zone.
   * 
   * @example
   * cxfd345sd234
   */
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      action: 'Action',
      actionTime: 'ActionTime',
      actionTimestamp: 'ActionTimestamp',
      clientIp: 'ClientIp',
      domainName: 'DomainName',
      message: 'Message',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      action: 'string',
      actionTime: 'string',
      actionTimestamp: 'number',
      clientIp: 'string',
      domainName: 'string',
      message: 'string',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainLogsResponseBodyDomainLogs extends $tea.Model {
  domainLog?: DescribeDomainLogsResponseBodyDomainLogsDomainLog[];
  static names(): { [key: string]: string } {
    return {
      domainLog: 'DomainLog',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainLog: { 'type': 'array', 'itemType': DescribeDomainLogsResponseBodyDomainLogsDomainLog },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainNsResponseBodyDnsServers extends $tea.Model {
  dnsServer?: string[];
  static names(): { [key: string]: string } {
    return {
      dnsServer: 'DnsServer',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dnsServer: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainNsResponseBodyExpectDnsServers extends $tea.Model {
  expectDnsServer?: string[];
  static names(): { [key: string]: string } {
    return {
      expectDnsServer: 'ExpectDnsServer',
    };
  }

  static types(): { [key: string]: any } {
    return {
      expectDnsServer: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainRecordsResponseBodyDomainRecordsRecord extends $tea.Model {
  /**
   * @remarks
   * The time when the DNS record was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since 00:00:00 UTC on January 1, 1970.
   * 
   * @example
   * 1666501957000
   */
  createTimestamp?: number;
  /**
   * @remarks
   * The domain name.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The resolution line.
   * 
   * @example
   * default
   */
  line?: string;
  /**
   * @remarks
   * Indicates whether the DNS record is locked.
   * 
   * @example
   * false
   */
  locked?: boolean;
  /**
   * @remarks
   * The priority of the mail exchanger (MX) record.
   * 
   * @example
   * 5
   */
  priority?: number;
  /**
   * @remarks
   * The hostname.
   * 
   * @example
   * www
   */
  RR?: string;
  /**
   * @remarks
   * The ID of the DNS record.
   * 
   * @example
   * 9999985
   */
  recordId?: string;
  /**
   * @remarks
   * The description of the DNS record.
   * 
   * @example
   * test
   */
  remark?: string;
  /**
   * @remarks
   * The status of the DNS record.
   * 
   * @example
   * Enable
   */
  status?: string;
  /**
   * @remarks
   * The time-to-live (TTL) of the cached DNS record. Unit: seconds.
   * 
   * @example
   * 600
   */
  TTL?: number;
  /**
   * @remarks
   * The type of the DNS record.
   * 
   * @example
   * MX
   */
  type?: string;
  /**
   * @remarks
   * The time when the DNS record was updated. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since 00:00:00 UTC on January 1, 1970.
   * 
   * @example
   * 1676872961000
   */
  updateTimestamp?: number;
  /**
   * @remarks
   * The record value.
   * 
   * @example
   * mail1.hichina.com
   */
  value?: string;
  /**
   * @remarks
   * The weight of the DNS record.
   * 
   * @example
   * 2
   */
  weight?: number;
  static names(): { [key: string]: string } {
    return {
      createTimestamp: 'CreateTimestamp',
      domainName: 'DomainName',
      line: 'Line',
      locked: 'Locked',
      priority: 'Priority',
      RR: 'RR',
      recordId: 'RecordId',
      remark: 'Remark',
      status: 'Status',
      TTL: 'TTL',
      type: 'Type',
      updateTimestamp: 'UpdateTimestamp',
      value: 'Value',
      weight: 'Weight',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTimestamp: 'number',
      domainName: 'string',
      line: 'string',
      locked: 'boolean',
      priority: 'number',
      RR: 'string',
      recordId: 'string',
      remark: 'string',
      status: 'string',
      TTL: 'number',
      type: 'string',
      updateTimestamp: 'number',
      value: 'string',
      weight: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainRecordsResponseBodyDomainRecords extends $tea.Model {
  record?: DescribeDomainRecordsResponseBodyDomainRecordsRecord[];
  static names(): { [key: string]: string } {
    return {
      record: 'Record',
    };
  }

  static types(): { [key: string]: any } {
    return {
      record: { 'type': 'array', 'itemType': DescribeDomainRecordsResponseBodyDomainRecordsRecord },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainResolveStatisticsSummaryResponseBodyStatistics extends $tea.Model {
  /**
   * @remarks
   * The number of DNS requests.
   * 
   * @example
   * 35509014
   */
  count?: string;
  /**
   * @remarks
   * The domain name.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The type of the domain name. Valid values:
   * 
   * *   PUBLIC: hosted public domain name
   * *   CACHE: cache-accelerated domain name
   * 
   * @example
   * CACHE
   */
  domainType?: string;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      domainName: 'DomainName',
      domainType: 'DomainType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'string',
      domainName: 'string',
      domainType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainStatisticsResponseBodyStatisticsStatistic extends $tea.Model {
  /**
   * @remarks
   * The number of DNS requests.
   * 
   * @example
   * 15292887
   */
  count?: number;
  /**
   * @remarks
   * The domain name.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The statistical timestamp. Unit: milliseconds. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
   * 
   * @example
   * 1556640000000
   */
  timestamp?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      domainName: 'DomainName',
      timestamp: 'Timestamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      domainName: 'string',
      timestamp: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainStatisticsResponseBodyStatistics extends $tea.Model {
  statistic?: DescribeDomainStatisticsResponseBodyStatisticsStatistic[];
  static names(): { [key: string]: string } {
    return {
      statistic: 'Statistic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      statistic: { 'type': 'array', 'itemType': DescribeDomainStatisticsResponseBodyStatisticsStatistic },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainStatisticsSummaryResponseBodyStatisticsStatistic extends $tea.Model {
  /**
   * @remarks
   * The number of DNS requests.
   * 
   * @example
   * 35509014
   */
  count?: number;
  /**
   * @remarks
   * The domain name.
   * 
   * @example
   * ali-gslb.com
   */
  domainName?: string;
  /**
   * @remarks
   * The type of the domain name. The parameter value is not case-sensitive. Valid values:
   * 
   * PUBLIC (default): hosted public domain name
   * 
   * CACHE: cache-accelerated domain name
   * 
   * @example
   * PUBLIC
   */
  domainType?: string;
  /**
   * @remarks
   * Indicates whether the DNS traffic analysis feature is enabled for the domain name. Valid values:
   * 
   * *   OPEN
   * *   CLOSE
   * 
   * @example
   * OPEN
   */
  resolveAnalysisStatus?: string;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      domainName: 'DomainName',
      domainType: 'DomainType',
      resolveAnalysisStatus: 'resolveAnalysisStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      domainName: 'string',
      domainType: 'string',
      resolveAnalysisStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainStatisticsSummaryResponseBodyStatistics extends $tea.Model {
  statistic?: DescribeDomainStatisticsSummaryResponseBodyStatisticsStatistic[];
  static names(): { [key: string]: string } {
    return {
      statistic: 'Statistic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      statistic: { 'type': 'array', 'itemType': DescribeDomainStatisticsSummaryResponseBodyStatisticsStatistic },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainsResponseBodyDomainsDomainDnsServers extends $tea.Model {
  dnsServer?: string[];
  static names(): { [key: string]: string } {
    return {
      dnsServer: 'DnsServer',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dnsServer: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainsResponseBodyDomainsDomainTagsTag extends $tea.Model {
  /**
   * @remarks
   * The key of the tag added to the resource.
   */
  key?: string;
  /**
   * @remarks
   * The value of the tag added to the resource.
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainsResponseBodyDomainsDomainTags extends $tea.Model {
  tag?: DescribeDomainsResponseBodyDomainsDomainTagsTag[];
  static names(): { [key: string]: string } {
    return {
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tag: { 'type': 'array', 'itemType': DescribeDomainsResponseBodyDomainsDomainTagsTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainsResponseBodyDomainsDomain extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the domain name was registered in Alibaba Cloud.
   * 
   * @example
   * true
   */
  aliDomain?: boolean;
  /**
   * @remarks
   * The time when the domain name was added.
   * 
   * @example
   * 2019-01-30T05:25Z
   */
  createTime?: string;
  /**
   * @remarks
   * The time when the domain name was added. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
   * 
   * @example
   * 1660546144000
   */
  createTimestamp?: number;
  /**
   * @remarks
   * The names of the DNS servers configured for the domain name.
   */
  dnsServers?: DescribeDomainsResponseBodyDomainsDomainDnsServers;
  /**
   * @remarks
   * The ID of the domain name.
   * 
   * @example
   * 00efd71a-770e-4255-b54e-6fe5659baffe
   */
  domainId?: string;
  domainLoggingSwitchStatus?: string;
  /**
   * @remarks
   * The domain name.
   * 
   * @example
   * abc.com
   */
  domainName?: string;
  /**
   * @remarks
   * The ID of the domain name group.
   * 
   * @example
   * 2223
   */
  groupId?: string;
  /**
   * @remarks
   * The name of the domain name group.
   * 
   * @example
   * mygroup
   */
  groupName?: string;
  /**
   * @remarks
   * The time when the Alibaba Cloud DNS instance expires.
   * 
   * @example
   * 2020-03-14T16:00Z
   */
  instanceEndTime?: string;
  /**
   * @remarks
   * Indicates whether the Alibaba Cloud DNS instance expires.
   * 
   * @example
   * false
   */
  instanceExpired?: boolean;
  /**
   * @remarks
   * The ID of the Alibaba Cloud DNS instance.
   * 
   * @example
   * i-7bg
   */
  instanceId?: string;
  /**
   * @remarks
   * The Punycode for the domain name. This parameter is returned only for Chinese domain names.
   * 
   * @example
   * abc.com
   */
  punyCode?: string;
  /**
   * @remarks
   * The number of Domain Name System (DNS) records added for the domain name.
   * 
   * @example
   * 100
   */
  recordCount?: number;
  /**
   * @remarks
   * The email address of the registrant.
   * 
   * @example
   * test@example.com
   */
  registrantEmail?: string;
  /**
   * @remarks
   * The description of the domain name.
   * 
   * @example
   * remark
   */
  remark?: string;
  /**
   * @remarks
   * The ID of the resource group to which the domain name belongs.
   * 
   * @example
   * rg-acf
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * Indicates whether the domain name was added to favorites.
   * 
   * @example
   * true
   */
  starmark?: boolean;
  /**
   * @remarks
   * The tags added to the resource.
   */
  tags?: DescribeDomainsResponseBodyDomainsDomainTags;
  /**
   * @remarks
   * The edition code of Alibaba Cloud DNS.
   * 
   * @example
   * version_enterprise_basic
   */
  versionCode?: string;
  /**
   * @remarks
   * The edition of Alibaba Cloud DNS.
   */
  versionName?: string;
  static names(): { [key: string]: string } {
    return {
      aliDomain: 'AliDomain',
      createTime: 'CreateTime',
      createTimestamp: 'CreateTimestamp',
      dnsServers: 'DnsServers',
      domainId: 'DomainId',
      domainLoggingSwitchStatus: 'DomainLoggingSwitchStatus',
      domainName: 'DomainName',
      groupId: 'GroupId',
      groupName: 'GroupName',
      instanceEndTime: 'InstanceEndTime',
      instanceExpired: 'InstanceExpired',
      instanceId: 'InstanceId',
      punyCode: 'PunyCode',
      recordCount: 'RecordCount',
      registrantEmail: 'RegistrantEmail',
      remark: 'Remark',
      resourceGroupId: 'ResourceGroupId',
      starmark: 'Starmark',
      tags: 'Tags',
      versionCode: 'VersionCode',
      versionName: 'VersionName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliDomain: 'boolean',
      createTime: 'string',
      createTimestamp: 'number',
      dnsServers: DescribeDomainsResponseBodyDomainsDomainDnsServers,
      domainId: 'string',
      domainLoggingSwitchStatus: 'string',
      domainName: 'string',
      groupId: 'string',
      groupName: 'string',
      instanceEndTime: 'string',
      instanceExpired: 'boolean',
      instanceId: 'string',
      punyCode: 'string',
      recordCount: 'number',
      registrantEmail: 'string',
      remark: 'string',
      resourceGroupId: 'string',
      starmark: 'boolean',
      tags: DescribeDomainsResponseBodyDomainsDomainTags,
      versionCode: 'string',
      versionName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainsResponseBodyDomains extends $tea.Model {
  domain?: DescribeDomainsResponseBodyDomainsDomain[];
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: { 'type': 'array', 'itemType': DescribeDomainsResponseBodyDomainsDomain },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmAccessStrategiesResponseBodyStrategiesStrategyLinesLine extends $tea.Model {
  /**
   * @remarks
   * The code of the access region group.
   * 
   * @example
   * DEFAULT
   */
  groupCode?: string;
  /**
   * @remarks
   * The name of the access region group.
   */
  groupName?: string;
  /**
   * @remarks
   * The code for the line of the access region.
   * 
   * @example
   * default
   */
  lineCode?: string;
  /**
   * @remarks
   * The name for the line of the access region.
   */
  lineName?: string;
  static names(): { [key: string]: string } {
    return {
      groupCode: 'GroupCode',
      groupName: 'GroupName',
      lineCode: 'LineCode',
      lineName: 'LineName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupCode: 'string',
      groupName: 'string',
      lineCode: 'string',
      lineName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmAccessStrategiesResponseBodyStrategiesStrategyLines extends $tea.Model {
  line?: DescribeGtmAccessStrategiesResponseBodyStrategiesStrategyLinesLine[];
  static names(): { [key: string]: string } {
    return {
      line: 'Line',
    };
  }

  static types(): { [key: string]: any } {
    return {
      line: { 'type': 'array', 'itemType': DescribeGtmAccessStrategiesResponseBodyStrategiesStrategyLinesLine },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmAccessStrategiesResponseBodyStrategiesStrategy extends $tea.Model {
  /**
   * @remarks
   * The access policy. Valid values:
   * 
   * *   **AUTO**: Automatic switch
   * *   **DEFAULT**: Default address pool
   * *   **FAILOVER**: Failover address pool
   * 
   * @example
   * DEFAULT
   */
  accessMode?: string;
  /**
   * @remarks
   * The access status. Valid values:
   * 
   * *   **DEFAULT**: The default address pool is currently accessed.
   * *   **FAILOVER**: The failover address pool is currently accessed.
   * 
   * @example
   * DEFAULT
   */
  accessStatus?: string;
  /**
   * @remarks
   * The time when the access policy was created.
   * 
   * @example
   * 2018-08-09T00:10Z
   */
  createTime?: string;
  /**
   * @example
   * 1533773400000
   */
  createTimestamp?: number;
  /**
   * @remarks
   * The ID of the default address pool.
   * 
   * @example
   * hra0i1
   */
  defaultAddrPoolId?: string;
  /**
   * @remarks
   * Indicates whether health check was enabled for the default address pool. Valid values:
   * 
   * *   **OPEN**: Enabled
   * *   **CLOSE**: Disabled
   * *   **UNCONFIGURED**: Not configured
   * 
   * @example
   * OPEN
   */
  defaultAddrPoolMonitorStatus?: string;
  /**
   * @remarks
   * The name of the default address pool.
   */
  defaultAddrPoolName?: string;
  /**
   * @remarks
   * The availability status of the default address pool. Valid values:
   * 
   * *   **AVAILABLE**: Available
   * *   **NOT_AVAILABLE**: Unavailable
   * 
   * @example
   * AVAILABLE
   */
  defaultAddrPoolStatus?: string;
  /**
   * @remarks
   * The ID of the failover address pool.
   * 
   * @example
   * hra0i2
   */
  failoverAddrPoolId?: string;
  /**
   * @remarks
   * Indicates whether health check was enabled for the failover address pool.
   * 
   * @example
   * OPEN
   */
  failoverAddrPoolMonitorStatus?: string;
  /**
   * @remarks
   * The name of the failover address pool.
   */
  failoverAddrPoolName?: string;
  /**
   * @remarks
   * The availability status of the failover address pool.
   * 
   * @example
   * AVAILABLE
   */
  failoverAddrPoolStatus?: string;
  /**
   * @remarks
   * The ID of the GTM instance whose access policies you want to query.
   * 
   * @example
   * instance1
   */
  instanceId?: string;
  /**
   * @remarks
   * The returned lines of access regions.
   */
  lines?: DescribeGtmAccessStrategiesResponseBodyStrategiesStrategyLines;
  /**
   * @remarks
   * The ID of the access policy.
   * 
   * @example
   * hra0hs
   */
  strategyId?: string;
  /**
   * @remarks
   * The mode of the access policy. **SELF_DEFINED** indicates that the access policy is user-defined.
   * 
   * @example
   * SELF_DEFINED
   */
  strategyMode?: string;
  /**
   * @remarks
   * The name of the access policy.
   */
  strategyName?: string;
  static names(): { [key: string]: string } {
    return {
      accessMode: 'AccessMode',
      accessStatus: 'AccessStatus',
      createTime: 'CreateTime',
      createTimestamp: 'CreateTimestamp',
      defaultAddrPoolId: 'DefaultAddrPoolId',
      defaultAddrPoolMonitorStatus: 'DefaultAddrPoolMonitorStatus',
      defaultAddrPoolName: 'DefaultAddrPoolName',
      defaultAddrPoolStatus: 'DefaultAddrPoolStatus',
      failoverAddrPoolId: 'FailoverAddrPoolId',
      failoverAddrPoolMonitorStatus: 'FailoverAddrPoolMonitorStatus',
      failoverAddrPoolName: 'FailoverAddrPoolName',
      failoverAddrPoolStatus: 'FailoverAddrPoolStatus',
      instanceId: 'InstanceId',
      lines: 'Lines',
      strategyId: 'StrategyId',
      strategyMode: 'StrategyMode',
      strategyName: 'StrategyName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessMode: 'string',
      accessStatus: 'string',
      createTime: 'string',
      createTimestamp: 'number',
      defaultAddrPoolId: 'string',
      defaultAddrPoolMonitorStatus: 'string',
      defaultAddrPoolName: 'string',
      defaultAddrPoolStatus: 'string',
      failoverAddrPoolId: 'string',
      failoverAddrPoolMonitorStatus: 'string',
      failoverAddrPoolName: 'string',
      failoverAddrPoolStatus: 'string',
      instanceId: 'string',
      lines: DescribeGtmAccessStrategiesResponseBodyStrategiesStrategyLines,
      strategyId: 'string',
      strategyMode: 'string',
      strategyName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmAccessStrategiesResponseBodyStrategies extends $tea.Model {
  strategy?: DescribeGtmAccessStrategiesResponseBodyStrategiesStrategy[];
  static names(): { [key: string]: string } {
    return {
      strategy: 'Strategy',
    };
  }

  static types(): { [key: string]: any } {
    return {
      strategy: { 'type': 'array', 'itemType': DescribeGtmAccessStrategiesResponseBodyStrategiesStrategy },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmAccessStrategyResponseBodyLinesLine extends $tea.Model {
  /**
   * @remarks
   * The code of the access region group.
   * 
   * @example
   * DEFAULT
   */
  groupCode?: string;
  /**
   * @remarks
   * The name of the access region group.
   * 
   * @example
   * Global
   */
  groupName?: string;
  /**
   * @remarks
   * The code for the line of the access region.
   * 
   * @example
   * default
   */
  lineCode?: string;
  /**
   * @remarks
   * The name for the line of the access region.
   * 
   * @example
   * Global
   */
  lineName?: string;
  static names(): { [key: string]: string } {
    return {
      groupCode: 'GroupCode',
      groupName: 'GroupName',
      lineCode: 'LineCode',
      lineName: 'LineName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupCode: 'string',
      groupName: 'string',
      lineCode: 'string',
      lineName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmAccessStrategyResponseBodyLines extends $tea.Model {
  line?: DescribeGtmAccessStrategyResponseBodyLinesLine[];
  static names(): { [key: string]: string } {
    return {
      line: 'Line',
    };
  }

  static types(): { [key: string]: any } {
    return {
      line: { 'type': 'array', 'itemType': DescribeGtmAccessStrategyResponseBodyLinesLine },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmAccessStrategyAvailableConfigResponseBodyAddrPoolsAddrPool extends $tea.Model {
  /**
   * @remarks
   * The ID of the address pool.
   * 
   * @example
   * hra0ix
   */
  addrPoolId?: string;
  /**
   * @remarks
   * The name of the address pool.
   * 
   * @example
   * test
   */
  addrPoolName?: string;
  static names(): { [key: string]: string } {
    return {
      addrPoolId: 'AddrPoolId',
      addrPoolName: 'AddrPoolName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addrPoolId: 'string',
      addrPoolName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmAccessStrategyAvailableConfigResponseBodyAddrPools extends $tea.Model {
  addrPool?: DescribeGtmAccessStrategyAvailableConfigResponseBodyAddrPoolsAddrPool[];
  static names(): { [key: string]: string } {
    return {
      addrPool: 'AddrPool',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addrPool: { 'type': 'array', 'itemType': DescribeGtmAccessStrategyAvailableConfigResponseBodyAddrPoolsAddrPool },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmAccessStrategyAvailableConfigResponseBodyLinesLine extends $tea.Model {
  /**
   * @remarks
   * The code of the parent line. No value is returned if no parent line exists.
   * 
   * @example
   * telecom
   */
  fatherCode?: string;
  /**
   * @remarks
   * The group number of the DNS request source.
   * 
   * @example
   * ISP
   */
  groupCode?: string;
  /**
   * @remarks
   * The group name of the DNS request source.
   * 
   * @example
   * Mainland China
   */
  groupName?: string;
  /**
   * @remarks
   * The code of the DNS request source.
   * 
   * @example
   * cn_telecom_hubei
   */
  lineCode?: string;
  /**
   * @remarks
   * The name of the DNS request source.
   * 
   * @example
   * South China
   */
  lineName?: string;
  /**
   * @remarks
   * The state of the line. Valid values:
   * 
   * *   **FORBIDDEN**: The line is unavailable.
   * *   **OPTIONAL**: The line is available.
   * 
   * @example
   * FORBIDDEN
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      fatherCode: 'FatherCode',
      groupCode: 'GroupCode',
      groupName: 'GroupName',
      lineCode: 'LineCode',
      lineName: 'LineName',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fatherCode: 'string',
      groupCode: 'string',
      groupName: 'string',
      lineCode: 'string',
      lineName: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmAccessStrategyAvailableConfigResponseBodyLines extends $tea.Model {
  line?: DescribeGtmAccessStrategyAvailableConfigResponseBodyLinesLine[];
  static names(): { [key: string]: string } {
    return {
      line: 'Line',
    };
  }

  static types(): { [key: string]: any } {
    return {
      line: { 'type': 'array', 'itemType': DescribeGtmAccessStrategyAvailableConfigResponseBodyLinesLine },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmInstanceAddressPoolResponseBodyAddrsAddr extends $tea.Model {
  /**
   * @remarks
   * The ID of the address.
   * 
   * @example
   * 123
   */
  addrId?: number;
  /**
   * @remarks
   * Indicates whether health check was enabled for the address. Valid values:
   * 
   * *   **OK**: Normal
   * *   **ALERT**: Alert
   * 
   * @example
   * OK
   */
  alertStatus?: string;
  /**
   * @remarks
   * The time when the address pool was created.
   * 
   * @example
   * 2017-12-28T13:08Z
   */
  createTime?: string;
  /**
   * @example
   * 1527690629357
   */
  createTimestamp?: number;
  /**
   * @remarks
   * The weight of the address.
   * 
   * @example
   * 1
   */
  lbaWeight?: number;
  /**
   * @remarks
   * The mode of the address. Valid values:
   * 
   * *   **SMART**: Intelligent return
   * *   **ONLINE**: Always online
   * *   **OFFLINE**: Always offline
   * 
   * @example
   * SMART
   */
  mode?: string;
  /**
   * @remarks
   * The last time when the address was updated.
   * 
   * @example
   * 2017-12-28T13:08Z
   */
  updateTime?: string;
  /**
   * @remarks
   * A timestamp that indicates the last time when the address was updated.
   * 
   * @example
   * 1527690629357
   */
  updateTimestamp?: number;
  /**
   * @remarks
   * The address.
   * 
   * @example
   * 1.1.1.1
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      addrId: 'AddrId',
      alertStatus: 'AlertStatus',
      createTime: 'CreateTime',
      createTimestamp: 'CreateTimestamp',
      lbaWeight: 'LbaWeight',
      mode: 'Mode',
      updateTime: 'UpdateTime',
      updateTimestamp: 'UpdateTimestamp',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addrId: 'number',
      alertStatus: 'string',
      createTime: 'string',
      createTimestamp: 'number',
      lbaWeight: 'number',
      mode: 'string',
      updateTime: 'string',
      updateTimestamp: 'number',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmInstanceAddressPoolResponseBodyAddrs extends $tea.Model {
  addr?: DescribeGtmInstanceAddressPoolResponseBodyAddrsAddr[];
  static names(): { [key: string]: string } {
    return {
      addr: 'Addr',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addr: { 'type': 'array', 'itemType': DescribeGtmInstanceAddressPoolResponseBodyAddrsAddr },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool extends $tea.Model {
  /**
   * @remarks
   * The number of addresses in the address pool.
   * 
   * @example
   * 2
   */
  addrCount?: number;
  /**
   * @remarks
   * The ID of the address pool.
   * 
   * @example
   * 1234abc
   */
  addrPoolId?: string;
  /**
   * @remarks
   * The time when this address pool was created.
   * 
   * @example
   * 2017-12-28T13:08Z
   */
  createTime?: string;
  /**
   * @example
   * 1527690629357
   */
  createTimestamp?: number;
  /**
   * @remarks
   * The minimum number of available addresses in the address pool.
   * 
   * @example
   * 2
   */
  minAvailableAddrNum?: number;
  /**
   * @remarks
   * The health check ID of the address pool.
   * 
   * @example
   * 100abc
   */
  monitorConfigId?: string;
  /**
   * @remarks
   * Indicates whether health check was enabled for the address pool. Valid values:
   * 
   * *   **OPEN**: Enabled
   * *   **CLOSE**: Disabled
   * *   **UNCONFIGURED**: Not configured
   * 
   * @example
   * OPEN
   */
  monitorStatus?: string;
  /**
   * @remarks
   * The name of the address pool.
   */
  name?: string;
  /**
   * @remarks
   * The availability status of the address pool. Valid values:
   * 
   * *   **AVAILABLE**: Available
   * *   **NOT_AVAILABLE**: Unavailable
   * 
   * @example
   * AVAILABLE
   */
  status?: string;
  /**
   * @remarks
   * The type of the address pool. Valid values:
   * 
   * *   **IP**: IP address
   * *   **DOMAIN**: Domain name
   * 
   * @example
   * IP
   */
  type?: string;
  /**
   * @remarks
   * The last time when the address pool was updated.
   * 
   * @example
   * 2017-12-28T13:08Z
   */
  updateTime?: string;
  /**
   * @remarks
   * A timestamp that indicates the last time the address pool was updated.
   * 
   * @example
   * 1527690629357
   */
  updateTimestamp?: number;
  static names(): { [key: string]: string } {
    return {
      addrCount: 'AddrCount',
      addrPoolId: 'AddrPoolId',
      createTime: 'CreateTime',
      createTimestamp: 'CreateTimestamp',
      minAvailableAddrNum: 'MinAvailableAddrNum',
      monitorConfigId: 'MonitorConfigId',
      monitorStatus: 'MonitorStatus',
      name: 'Name',
      status: 'Status',
      type: 'Type',
      updateTime: 'UpdateTime',
      updateTimestamp: 'UpdateTimestamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addrCount: 'number',
      addrPoolId: 'string',
      createTime: 'string',
      createTimestamp: 'number',
      minAvailableAddrNum: 'number',
      monitorConfigId: 'string',
      monitorStatus: 'string',
      name: 'string',
      status: 'string',
      type: 'string',
      updateTime: 'string',
      updateTimestamp: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmInstanceAddressPoolsResponseBodyAddrPools extends $tea.Model {
  addrPool?: DescribeGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool[];
  static names(): { [key: string]: string } {
    return {
      addrPool: 'AddrPool',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addrPool: { 'type': 'array', 'itemType': DescribeGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmInstancesResponseBodyGtmInstancesGtmInstance extends $tea.Model {
  /**
   * @remarks
   * The number of access policies.
   * 
   * @example
   * 5
   */
  accessStrategyNum?: number;
  /**
   * @remarks
   * The number of address pools.
   * 
   * @example
   * 5
   */
  addressPoolNum?: number;
  /**
   * @remarks
   * The name of the alert group.
   * 
   * @example
   * [\\\\"R\\&D group\\\\"]
   */
  alertGroup?: string;
  /**
   * @remarks
   * The CNAME domain name that is used to access the instance.
   * 
   * @example
   * instance1.14.com
   */
  cname?: string;
  /**
   * @remarks
   * The CNAME domain name used to access the instance. Valid values:
   * 
   * *   **SYSTEM_ASSIGN**: A CNAME domain name assigned by the system is used.
   * *   **CUSTOM**: A custom CNAME domain name is used.
   * 
   * @example
   * SYSTEM_ASSIGN
   */
  cnameMode?: string;
  /**
   * @remarks
   * The time when the instance was created.
   * 
   * @example
   * 2018-06-06T11:34Z
   */
  createTime?: string;
  /**
   * @remarks
   * The UNIX timestamp that indicates when the instance was created.
   * 
   * @example
   * 1528284856000
   */
  createTimestamp?: number;
  /**
   * @remarks
   * The time when the instance expires.
   * 
   * @example
   * 2018-06-06T11:34Z
   */
  expireTime?: string;
  /**
   * @remarks
   * The UNIX timestamp that indicates when the instance expires.
   * 
   * @example
   * 1528284856000
   */
  expireTimestamp?: number;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * instance1
   */
  instanceId?: string;
  /**
   * @remarks
   * The name of the instance.
   * 
   * @example
   * test
   */
  instanceName?: string;
  /**
   * @remarks
   * The load balancing policy that is used. Valid values:
   * 
   * *   **ALL_RR**: Load balancing
   * *   **RATIO**: Weighted round-robin
   * 
   * @example
   * RATIO
   */
  lbaStrategy?: string;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs.
   * 
   * @example
   * rg-acfm2q2jqpjh***
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The global time to live (TTL).
   * 
   * @example
   * 60
   */
  ttl?: number;
  /**
   * @remarks
   * The domain name of the user.
   * 
   * @example
   * www.example.com
   */
  userDomainName?: string;
  /**
   * @remarks
   * The version code of the instance.
   * 
   * @example
   * biaozhun
   */
  versionCode?: string;
  static names(): { [key: string]: string } {
    return {
      accessStrategyNum: 'AccessStrategyNum',
      addressPoolNum: 'AddressPoolNum',
      alertGroup: 'AlertGroup',
      cname: 'Cname',
      cnameMode: 'CnameMode',
      createTime: 'CreateTime',
      createTimestamp: 'CreateTimestamp',
      expireTime: 'ExpireTime',
      expireTimestamp: 'ExpireTimestamp',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      lbaStrategy: 'LbaStrategy',
      resourceGroupId: 'ResourceGroupId',
      ttl: 'Ttl',
      userDomainName: 'UserDomainName',
      versionCode: 'VersionCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessStrategyNum: 'number',
      addressPoolNum: 'number',
      alertGroup: 'string',
      cname: 'string',
      cnameMode: 'string',
      createTime: 'string',
      createTimestamp: 'number',
      expireTime: 'string',
      expireTimestamp: 'number',
      instanceId: 'string',
      instanceName: 'string',
      lbaStrategy: 'string',
      resourceGroupId: 'string',
      ttl: 'number',
      userDomainName: 'string',
      versionCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmInstancesResponseBodyGtmInstances extends $tea.Model {
  gtmInstance?: DescribeGtmInstancesResponseBodyGtmInstancesGtmInstance[];
  static names(): { [key: string]: string } {
    return {
      gtmInstance: 'GtmInstance',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gtmInstance: { 'type': 'array', 'itemType': DescribeGtmInstancesResponseBodyGtmInstancesGtmInstance },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmLogsResponseBodyLogsLog extends $tea.Model {
  /**
   * @remarks
   * The formatted message content.
   * 
   * @example
   * addtest-pool-1
   */
  content?: string;
  /**
   * @remarks
   * The ID of the object that was operated on.
   * 
   * @example
   * 121212
   */
  entityId?: string;
  /**
   * @remarks
   * The name of the object that was operated on.
   * 
   * @example
   * test-pool-1
   */
  entityName?: string;
  /**
   * @remarks
   * The type of the object that was operated on.
   * 
   * @example
   * POOL
   */
  entityType?: string;
  /**
   * @remarks
   * The ID of the log record.
   * 
   * @example
   * 6726
   */
  id?: number;
  /**
   * @remarks
   * The operation performed.
   * 
   * @example
   * add
   */
  operAction?: string;
  /**
   * @remarks
   * The IP address subject to the operation.
   * 
   * @example
   * 106.11.34.X
   */
  operIp?: string;
  /**
   * @remarks
   * The time when the operation was performed.
   * 
   * @example
   * 2018-01-24T07:35Z
   */
  operTime?: string;
  /**
   * @remarks
   * A timestamp that indicates the time when the operation was performed.
   * 
   * @example
   * 1516779348000
   */
  operTimestamp?: number;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      entityId: 'EntityId',
      entityName: 'EntityName',
      entityType: 'EntityType',
      id: 'Id',
      operAction: 'OperAction',
      operIp: 'OperIp',
      operTime: 'OperTime',
      operTimestamp: 'OperTimestamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      entityId: 'string',
      entityName: 'string',
      entityType: 'string',
      id: 'number',
      operAction: 'string',
      operIp: 'string',
      operTime: 'string',
      operTimestamp: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmLogsResponseBodyLogs extends $tea.Model {
  log?: DescribeGtmLogsResponseBodyLogsLog[];
  static names(): { [key: string]: string } {
    return {
      log: 'Log',
    };
  }

  static types(): { [key: string]: any } {
    return {
      log: { 'type': 'array', 'itemType': DescribeGtmLogsResponseBodyLogsLog },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmMonitorAvailableConfigResponseBodyIspCityNodesIspCityNode extends $tea.Model {
  /**
   * @remarks
   * The code of the city where the monitored node is deployed.
   * 
   * @example
   * 503
   */
  cityCode?: string;
  /**
   * @remarks
   * The display name of the city where the monitored node is deployed.
   * 
   * @example
   * Zhangjiakou
   */
  cityName?: string;
  /**
   * @remarks
   * Indicates whether the monitored node is selected for the health check by default.
   * 
   * @example
   * true
   */
  defaultSelected?: boolean;
  /**
   * @remarks
   * The name of the group to which the monitored node belongs.
   * 
   * Valid values: Overseas Nodes, BGP Nodes, and ISP Nodes.
   * 
   * @example
   * Overseas Nodes
   */
  groupName?: string;
  /**
   * @remarks
   * The type of the group to which the monitored node belongs.
   * 
   * Valid values: BGP, OVERSEAS, and ISP.
   * 
   * @example
   * OVERSEAS
   */
  groupType?: string;
  /**
   * @remarks
   * The code of the Internet service provider (ISP) to which the monitored node belongs.
   * 
   * *   If the value of the GroupType parameter is BGP or OVERSEAS, the value of IspCode is 465 by default.
   * *   If the value of the GroupType parameter is not BGP or OVERSEAS, valid values of IspCode are 232, 132, and 5. and is used together with CityCode.
   * 
   * @example
   * 465
   */
  ispCode?: string;
  /**
   * @remarks
   * The display name of the ISP to which the monitored node belongs.
   * 
   * @example
   * Alibaba
   */
  ispName?: string;
  /**
   * @remarks
   * Indicates whether the monitored node is deployed in the Chinese mainland.
   * 
   * @example
   * true
   */
  mainland?: boolean;
  static names(): { [key: string]: string } {
    return {
      cityCode: 'CityCode',
      cityName: 'CityName',
      defaultSelected: 'DefaultSelected',
      groupName: 'GroupName',
      groupType: 'GroupType',
      ispCode: 'IspCode',
      ispName: 'IspName',
      mainland: 'Mainland',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cityCode: 'string',
      cityName: 'string',
      defaultSelected: 'boolean',
      groupName: 'string',
      groupType: 'string',
      ispCode: 'string',
      ispName: 'string',
      mainland: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmMonitorAvailableConfigResponseBodyIspCityNodes extends $tea.Model {
  ispCityNode?: DescribeGtmMonitorAvailableConfigResponseBodyIspCityNodesIspCityNode[];
  static names(): { [key: string]: string } {
    return {
      ispCityNode: 'IspCityNode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ispCityNode: { 'type': 'array', 'itemType': DescribeGtmMonitorAvailableConfigResponseBodyIspCityNodesIspCityNode },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmMonitorConfigResponseBodyIspCityNodesIspCityNode extends $tea.Model {
  /**
   * @remarks
   * The code of the city where the monitored node is deployed.
   * 
   * @example
   * 503
   */
  cityCode?: string;
  /**
   * @remarks
   * The display name of the city where the monitored node is deployed.
   * 
   * @example
   * Zhangjiakou
   */
  cityName?: string;
  /**
   * @remarks
   * The code of the country where the monitored node is deployed.
   * 
   * @example
   * 001
   */
  countryCode?: string;
  /**
   * @remarks
   * The display name of the country where the monitored node is deployed.
   * 
   * @example
   * China
   */
  countryName?: string;
  /**
   * @remarks
   * The code of the Internet service provider (ISP) to which the monitored node belongs.
   * 
   * @example
   * 465
   */
  ispCode?: string;
  /**
   * @remarks
   * The display name of the ISP to which the monitored node belongs.
   * 
   * @example
   * Alibaba
   */
  ispName?: string;
  static names(): { [key: string]: string } {
    return {
      cityCode: 'CityCode',
      cityName: 'CityName',
      countryCode: 'CountryCode',
      countryName: 'CountryName',
      ispCode: 'IspCode',
      ispName: 'IspName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cityCode: 'string',
      cityName: 'string',
      countryCode: 'string',
      countryName: 'string',
      ispCode: 'string',
      ispName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmMonitorConfigResponseBodyIspCityNodes extends $tea.Model {
  ispCityNode?: DescribeGtmMonitorConfigResponseBodyIspCityNodesIspCityNode[];
  static names(): { [key: string]: string } {
    return {
      ispCityNode: 'IspCityNode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ispCityNode: { 'type': 'array', 'itemType': DescribeGtmMonitorConfigResponseBodyIspCityNodesIspCityNode },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPoolAddrsAddr extends $tea.Model {
  /**
   * @remarks
   * The ID of the address.
   * 
   * @example
   * 739
   */
  id?: number;
  /**
   * @remarks
   * The address work mode. It is the mode that was set for the IP address to work.
   * 
   * @example
   * OFFLINE
   */
  mode?: string;
  /**
   * @remarks
   * The address value.
   * 
   * @example
   * 1.1.1.1
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      mode: 'Mode',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      mode: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPoolAddrs extends $tea.Model {
  addr?: DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPoolAddrsAddr[];
  static names(): { [key: string]: string } {
    return {
      addr: 'Addr',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addr: { 'type': 'array', 'itemType': DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPoolAddrsAddr },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPool extends $tea.Model {
  /**
   * @remarks
   * The ID of the address pool.
   * 
   * @example
   * hra0oq
   */
  addrPoolId?: string;
  /**
   * @remarks
   * The name of the address pool.
   */
  addrPoolName?: string;
  /**
   * @remarks
   * The list of addresses in the address pool.
   */
  addrs?: DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPoolAddrs;
  /**
   * @remarks
   * The ID of the GTM instance.
   * 
   * @example
   * instance-zwy-38
   */
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      addrPoolId: 'AddrPoolId',
      addrPoolName: 'AddrPoolName',
      addrs: 'Addrs',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addrPoolId: 'string',
      addrPoolName: 'string',
      addrs: DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPoolAddrs,
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmRecoveryPlanResponseBodyFaultAddrPools extends $tea.Model {
  faultAddrPool?: DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPool[];
  static names(): { [key: string]: string } {
    return {
      faultAddrPool: 'FaultAddrPool',
    };
  }

  static types(): { [key: string]: any } {
    return {
      faultAddrPool: { 'type': 'array', 'itemType': DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPool },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstanceAddrPoolsAddrPool extends $tea.Model {
  /**
   * @remarks
   * The ID of the address pool.
   */
  addrPoolId?: string;
  /**
   * @remarks
   * The name of the address pool.
   * 
   * @example
   * hra0i9
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      addrPoolId: 'AddrPoolId',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addrPoolId: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstanceAddrPools extends $tea.Model {
  addrPool?: DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstanceAddrPoolsAddrPool[];
  static names(): { [key: string]: string } {
    return {
      addrPool: 'AddrPool',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addrPool: { 'type': 'array', 'itemType': DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstanceAddrPoolsAddrPool },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstance extends $tea.Model {
  /**
   * @remarks
   * The list of address pools for the GTM instance.
   */
  addrPools?: DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstanceAddrPools;
  /**
   * @remarks
   * The ID of the GTM instance.
   * 
   * @example
   * instance-example
   */
  instanceId?: string;
  /**
   * @remarks
   * The name of the GTM instance.
   * 
   * @example
   * instance-name-example
   */
  instanceName?: string;
  static names(): { [key: string]: string } {
    return {
      addrPools: 'AddrPools',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addrPools: DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstanceAddrPools,
      instanceId: 'string',
      instanceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstances extends $tea.Model {
  instance?: DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstance[];
  static names(): { [key: string]: string } {
    return {
      instance: 'Instance',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instance: { 'type': 'array', 'itemType': DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstance },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmRecoveryPlansResponseBodyRecoveryPlansRecoveryPlan extends $tea.Model {
  /**
   * @remarks
   * The time when the disaster recovery plan was created.
   * 
   * @example
   * 2019-08-11T06:45Z
   */
  createTime?: string;
  /**
   * @remarks
   * The UNIX timestamp that indicates when the disaster recovery plan was created.
   * 
   * @example
   * 1565499867000
   */
  createTimestamp?: number;
  /**
   * @remarks
   * The number of faulty address pools.
   * 
   * @example
   * 0
   */
  faultAddrPoolNum?: number;
  /**
   * @remarks
   * The last time when the disaster recovery plan was executed.
   * 
   * @example
   * 2019-08-11T06:44Z
   */
  lastExecuteTime?: string;
  /**
   * @remarks
   * The UNIX timestamp that indicates the last time when the disaster recovery plan was executed.
   * 
   * @example
   * 1565505898000
   */
  lastExecuteTimestamp?: number;
  /**
   * @remarks
   * The last time when the disaster recovery plan was rolled back.
   * 
   * @example
   * 2019-08-11T06:45Z
   */
  lastRollbackTime?: string;
  /**
   * @remarks
   * The UNIX timestamp that indicates the last time when the disaster recovery plan was rolled back.
   * 
   * @example
   * 1565505919000
   */
  lastRollbackTimestamp?: number;
  /**
   * @remarks
   * The name of the disaster recovery plan.
   * 
   * @example
   * name-example
   */
  name?: string;
  /**
   * @remarks
   * The ID of the disaster recovery plan.
   * 
   * @example
   * 55
   */
  recoveryPlanId?: number;
  /**
   * @remarks
   * The remarks about the disaster recovery plan.
   * 
   * @example
   * remark-example
   */
  remark?: string;
  /**
   * @remarks
   * The status of the disaster recovery plan. Valid values:
   * 
   * *   **UNEXECUTED**: The plan is not executed.
   * *   **EXECUTED**: The plan is executed.
   * *   **ROLLED_BACK**: The plan is rolled back.
   * 
   * @example
   * UNEXECUTED
   */
  status?: string;
  /**
   * @remarks
   * The last time when the disaster recovery plan was updated.
   * 
   * @example
   * 2019-08-11T06:45Z
   */
  updateTime?: string;
  /**
   * @remarks
   * The UNIX timestamp that indicates the last time when the disaster recovery plan was updated.
   * 
   * @example
   * 1565505919000
   */
  updateTimestamp?: number;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      createTimestamp: 'CreateTimestamp',
      faultAddrPoolNum: 'FaultAddrPoolNum',
      lastExecuteTime: 'LastExecuteTime',
      lastExecuteTimestamp: 'LastExecuteTimestamp',
      lastRollbackTime: 'LastRollbackTime',
      lastRollbackTimestamp: 'LastRollbackTimestamp',
      name: 'Name',
      recoveryPlanId: 'RecoveryPlanId',
      remark: 'Remark',
      status: 'Status',
      updateTime: 'UpdateTime',
      updateTimestamp: 'UpdateTimestamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'string',
      createTimestamp: 'number',
      faultAddrPoolNum: 'number',
      lastExecuteTime: 'string',
      lastExecuteTimestamp: 'number',
      lastRollbackTime: 'string',
      lastRollbackTimestamp: 'number',
      name: 'string',
      recoveryPlanId: 'number',
      remark: 'string',
      status: 'string',
      updateTime: 'string',
      updateTimestamp: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGtmRecoveryPlansResponseBodyRecoveryPlans extends $tea.Model {
  recoveryPlan?: DescribeGtmRecoveryPlansResponseBodyRecoveryPlansRecoveryPlan[];
  static names(): { [key: string]: string } {
    return {
      recoveryPlan: 'RecoveryPlan',
    };
  }

  static types(): { [key: string]: any } {
    return {
      recoveryPlan: { 'type': 'array', 'itemType': DescribeGtmRecoveryPlansResponseBodyRecoveryPlansRecoveryPlan },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceDomainsResponseBodyInstanceDomains extends $tea.Model {
  /**
   * @remarks
   * The time when the instance was created. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.
   * 
   * @example
   * 2020-03-09T02:15Z
   */
  createTime?: string;
  /**
   * @remarks
   * The time when the instance was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
   * 
   * @example
   * 1583720154000
   */
  createTimestamp?: number;
  /**
   * @remarks
   * The domain name.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      createTimestamp: 'CreateTimestamp',
      domainName: 'DomainName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'string',
      createTimestamp: 'number',
      domainName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInternetDnsLogsResponseBodyLogsLogValue extends $tea.Model {
  value?: string[];
  static names(): { [key: string]: string } {
    return {
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      value: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInternetDnsLogsResponseBodyLogsLog extends $tea.Model {
  /**
   * @example
   * 3583
   */
  dnsMsgId?: string;
  /**
   * @example
   * 1709196249000
   */
  logTime?: number;
  /**
   * @example
   * example.com
   */
  queryName?: string;
  /**
   * @example
   * A
   */
  queryType?: string;
  /**
   * @example
   * 0
   */
  rt?: number;
  /**
   * @example
   * 140.205.XX.XX
   */
  serverIp?: string;
  /**
   * @example
   * 59.82.XX.XX
   */
  sourceIp?: string;
  /**
   * @example
   * NOERROR
   */
  status?: string;
  /**
   * @example
   * 170.33.XX.XX
   */
  subnetIp?: string;
  value?: DescribeInternetDnsLogsResponseBodyLogsLogValue;
  zoneName?: string;
  static names(): { [key: string]: string } {
    return {
      dnsMsgId: 'DnsMsgId',
      logTime: 'LogTime',
      queryName: 'QueryName',
      queryType: 'QueryType',
      rt: 'Rt',
      serverIp: 'ServerIp',
      sourceIp: 'SourceIp',
      status: 'Status',
      subnetIp: 'SubnetIp',
      value: 'Value',
      zoneName: 'ZoneName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dnsMsgId: 'string',
      logTime: 'number',
      queryName: 'string',
      queryType: 'string',
      rt: 'number',
      serverIp: 'string',
      sourceIp: 'string',
      status: 'string',
      subnetIp: 'string',
      value: DescribeInternetDnsLogsResponseBodyLogsLogValue,
      zoneName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInternetDnsLogsResponseBodyLogs extends $tea.Model {
  log?: DescribeInternetDnsLogsResponseBodyLogsLog[];
  static names(): { [key: string]: string } {
    return {
      log: 'Log',
    };
  }

  static types(): { [key: string]: any } {
    return {
      log: { 'type': 'array', 'itemType': DescribeInternetDnsLogsResponseBodyLogsLog },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeIspFlushCacheInstancesResponseBodyIspFlushCacheInstancesQuotaInfo extends $tea.Model {
  instanceQuota?: number;
  instanceQuotaUsed?: number;
  static names(): { [key: string]: string } {
    return {
      instanceQuota: 'InstanceQuota',
      instanceQuotaUsed: 'InstanceQuotaUsed',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceQuota: 'number',
      instanceQuotaUsed: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeIspFlushCacheInstancesResponseBodyIspFlushCacheInstances extends $tea.Model {
  expireTime?: string;
  expireTimestamp?: number;
  instanceId?: string;
  instanceName?: string;
  isp?: string;
  quotaInfo?: DescribeIspFlushCacheInstancesResponseBodyIspFlushCacheInstancesQuotaInfo;
  status?: string;
  versionCode?: string;
  static names(): { [key: string]: string } {
    return {
      expireTime: 'ExpireTime',
      expireTimestamp: 'ExpireTimestamp',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      isp: 'Isp',
      quotaInfo: 'QuotaInfo',
      status: 'Status',
      versionCode: 'VersionCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      expireTime: 'string',
      expireTimestamp: 'number',
      instanceId: 'string',
      instanceName: 'string',
      isp: 'string',
      quotaInfo: DescribeIspFlushCacheInstancesResponseBodyIspFlushCacheInstancesQuotaInfo,
      status: 'string',
      versionCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeIspFlushCacheTaskResponseBodyFlushCacheResultsDnsNodesAnswers extends $tea.Model {
  name?: string;
  record?: string;
  ttl?: number;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      record: 'Record',
      ttl: 'Ttl',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      record: 'string',
      ttl: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeIspFlushCacheTaskResponseBodyFlushCacheResultsDnsNodes extends $tea.Model {
  answers?: DescribeIspFlushCacheTaskResponseBodyFlushCacheResultsDnsNodesAnswers[];
  nodeIp?: string;
  spName?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      answers: 'Answers',
      nodeIp: 'NodeIp',
      spName: 'SpName',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      answers: { 'type': 'array', 'itemType': DescribeIspFlushCacheTaskResponseBodyFlushCacheResultsDnsNodesAnswers },
      nodeIp: 'string',
      spName: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeIspFlushCacheTaskResponseBodyFlushCacheResults extends $tea.Model {
  dnsNodes?: DescribeIspFlushCacheTaskResponseBodyFlushCacheResultsDnsNodes[];
  province?: string;
  static names(): { [key: string]: string } {
    return {
      dnsNodes: 'DnsNodes',
      province: 'Province',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dnsNodes: { 'type': 'array', 'itemType': DescribeIspFlushCacheTaskResponseBodyFlushCacheResultsDnsNodes },
      province: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeIspFlushCacheTasksResponseBodyIspFlushCacheTasks extends $tea.Model {
  createTime?: string;
  createTimestamp?: number;
  domainName?: string;
  instanceId?: string;
  instanceName?: string;
  isp?: string;
  taskId?: string;
  taskStatus?: string;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      createTimestamp: 'CreateTimestamp',
      domainName: 'DomainName',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      isp: 'Isp',
      taskId: 'TaskId',
      taskStatus: 'TaskStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'string',
      createTimestamp: 'number',
      domainName: 'string',
      instanceId: 'string',
      instanceName: 'string',
      isp: 'string',
      taskId: 'string',
      taskStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePdnsAccountSummaryResponseBodyData extends $tea.Model {
  domainCount?: number;
  httpCount?: number;
  httpsCount?: number;
  subDomainCount?: number;
  threatCount?: number;
  totalCount?: number;
  userId?: number;
  static names(): { [key: string]: string } {
    return {
      domainCount: 'DomainCount',
      httpCount: 'HttpCount',
      httpsCount: 'HttpsCount',
      subDomainCount: 'SubDomainCount',
      threatCount: 'ThreatCount',
      totalCount: 'TotalCount',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainCount: 'number',
      httpCount: 'number',
      httpsCount: 'number',
      subDomainCount: 'number',
      threatCount: 'number',
      totalCount: 'number',
      userId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePdnsAppKeyResponseBodyAppKey extends $tea.Model {
  appKeyId?: string;
  appKeySecret?: string;
  createDate?: string;
  createTimestamp?: number;
  state?: string;
  static names(): { [key: string]: string } {
    return {
      appKeyId: 'AppKeyId',
      appKeySecret: 'AppKeySecret',
      createDate: 'CreateDate',
      createTimestamp: 'CreateTimestamp',
      state: 'State',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appKeyId: 'string',
      appKeySecret: 'string',
      createDate: 'string',
      createTimestamp: 'number',
      state: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePdnsAppKeysResponseBodyAppKeys extends $tea.Model {
  appKeyId?: string;
  createDate?: string;
  createTimestamp?: number;
  state?: string;
  static names(): { [key: string]: string } {
    return {
      appKeyId: 'AppKeyId',
      createDate: 'CreateDate',
      createTimestamp: 'CreateTimestamp',
      state: 'State',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appKeyId: 'string',
      createDate: 'string',
      createTimestamp: 'number',
      state: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePdnsOperateLogsResponseBodyLogs extends $tea.Model {
  action?: string;
  operateTime?: string;
  type?: string;
  content?: string;
  static names(): { [key: string]: string } {
    return {
      action: 'Action',
      operateTime: 'OperateTime',
      type: 'Type',
      content: 'content',
    };
  }

  static types(): { [key: string]: any } {
    return {
      action: 'string',
      operateTime: 'string',
      type: 'string',
      content: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePdnsRequestStatisticResponseBodyData extends $tea.Model {
  dohTotalCount?: number;
  httpCount?: number;
  httpsCount?: number;
  ipCount?: number;
  timestamp?: number;
  totalCount?: number;
  udpTotalCount?: number;
  v4Count?: number;
  v4HttpCount?: number;
  v4HttpsCount?: number;
  v6Count?: number;
  v6HttpCount?: number;
  v6HttpsCount?: number;
  static names(): { [key: string]: string } {
    return {
      dohTotalCount: 'DohTotalCount',
      httpCount: 'HttpCount',
      httpsCount: 'HttpsCount',
      ipCount: 'IpCount',
      timestamp: 'Timestamp',
      totalCount: 'TotalCount',
      udpTotalCount: 'UdpTotalCount',
      v4Count: 'V4Count',
      v4HttpCount: 'V4HttpCount',
      v4HttpsCount: 'V4HttpsCount',
      v6Count: 'V6Count',
      v6HttpCount: 'V6HttpCount',
      v6HttpsCount: 'V6HttpsCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dohTotalCount: 'number',
      httpCount: 'number',
      httpsCount: 'number',
      ipCount: 'number',
      timestamp: 'number',
      totalCount: 'number',
      udpTotalCount: 'number',
      v4Count: 'number',
      v4HttpCount: 'number',
      v4HttpsCount: 'number',
      v6Count: 'number',
      v6HttpCount: 'number',
      v6HttpsCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePdnsRequestStatisticsResponseBodyDataThreatInfo extends $tea.Model {
  threatLevel?: string;
  threatType?: string;
  static names(): { [key: string]: string } {
    return {
      threatLevel: 'ThreatLevel',
      threatType: 'ThreatType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      threatLevel: 'string',
      threatType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePdnsRequestStatisticsResponseBodyData extends $tea.Model {
  dohTotalCount?: number;
  domainName?: string;
  httpCount?: number;
  httpsCount?: number;
  ipCount?: number;
  maxThreatLevel?: string;
  subDomain?: string;
  threatCount?: number;
  threatInfo?: DescribePdnsRequestStatisticsResponseBodyDataThreatInfo[];
  totalCount?: number;
  udpTotalCount?: number;
  v4Count?: number;
  v4HttpCount?: number;
  v4HttpsCount?: number;
  v6Count?: number;
  v6HttpCount?: number;
  v6HttpsCount?: number;
  static names(): { [key: string]: string } {
    return {
      dohTotalCount: 'DohTotalCount',
      domainName: 'DomainName',
      httpCount: 'HttpCount',
      httpsCount: 'HttpsCount',
      ipCount: 'IpCount',
      maxThreatLevel: 'MaxThreatLevel',
      subDomain: 'SubDomain',
      threatCount: 'ThreatCount',
      threatInfo: 'ThreatInfo',
      totalCount: 'TotalCount',
      udpTotalCount: 'UdpTotalCount',
      v4Count: 'V4Count',
      v4HttpCount: 'V4HttpCount',
      v4HttpsCount: 'V4HttpsCount',
      v6Count: 'V6Count',
      v6HttpCount: 'V6HttpCount',
      v6HttpsCount: 'V6HttpsCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dohTotalCount: 'number',
      domainName: 'string',
      httpCount: 'number',
      httpsCount: 'number',
      ipCount: 'number',
      maxThreatLevel: 'string',
      subDomain: 'string',
      threatCount: 'number',
      threatInfo: { 'type': 'array', 'itemType': DescribePdnsRequestStatisticsResponseBodyDataThreatInfo },
      totalCount: 'number',
      udpTotalCount: 'number',
      v4Count: 'number',
      v4HttpCount: 'number',
      v4HttpsCount: 'number',
      v6Count: 'number',
      v6HttpCount: 'number',
      v6HttpsCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePdnsThreatLogsResponseBodyLogs extends $tea.Model {
  sourceIp?: string;
  subDomain?: string;
  threatLevel?: string;
  threatTime?: string;
  threatType?: string;
  static names(): { [key: string]: string } {
    return {
      sourceIp: 'SourceIp',
      subDomain: 'SubDomain',
      threatLevel: 'ThreatLevel',
      threatTime: 'ThreatTime',
      threatType: 'ThreatType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sourceIp: 'string',
      subDomain: 'string',
      threatLevel: 'string',
      threatTime: 'string',
      threatType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePdnsThreatStatisticResponseBodyData extends $tea.Model {
  dohTotalCount?: number;
  threatLevel?: string;
  threatType?: string;
  timestamp?: number;
  totalCount?: number;
  udpTotalCount?: number;
  static names(): { [key: string]: string } {
    return {
      dohTotalCount: 'DohTotalCount',
      threatLevel: 'ThreatLevel',
      threatType: 'ThreatType',
      timestamp: 'Timestamp',
      totalCount: 'TotalCount',
      udpTotalCount: 'UdpTotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dohTotalCount: 'number',
      threatLevel: 'string',
      threatType: 'string',
      timestamp: 'number',
      totalCount: 'number',
      udpTotalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePdnsThreatStatisticsResponseBodyData extends $tea.Model {
  dohTotalCount?: number;
  domainCount?: number;
  domainName?: string;
  latestThreatTime?: number;
  maxThreatLevel?: string;
  sourceIp?: string;
  subDomain?: string;
  threatLevel?: string;
  threatType?: string;
  totalCount?: number;
  udpTotalCount?: number;
  static names(): { [key: string]: string } {
    return {
      dohTotalCount: 'DohTotalCount',
      domainCount: 'DomainCount',
      domainName: 'DomainName',
      latestThreatTime: 'LatestThreatTime',
      maxThreatLevel: 'MaxThreatLevel',
      sourceIp: 'SourceIp',
      subDomain: 'SubDomain',
      threatLevel: 'ThreatLevel',
      threatType: 'ThreatType',
      totalCount: 'TotalCount',
      udpTotalCount: 'UdpTotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dohTotalCount: 'number',
      domainCount: 'number',
      domainName: 'string',
      latestThreatTime: 'number',
      maxThreatLevel: 'string',
      sourceIp: 'string',
      subDomain: 'string',
      threatLevel: 'string',
      threatType: 'string',
      totalCount: 'number',
      udpTotalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePdnsUdpIpSegmentsResponseBodyIpSegments extends $tea.Model {
  createDate?: string;
  ip?: string;
  mask?: number;
  name?: string;
  state?: string;
  updateDate?: string;
  static names(): { [key: string]: string } {
    return {
      createDate: 'CreateDate',
      ip: 'Ip',
      mask: 'Mask',
      name: 'Name',
      state: 'State',
      updateDate: 'UpdateDate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createDate: 'string',
      ip: 'string',
      mask: 'number',
      name: 'string',
      state: 'string',
      updateDate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePdnsUserInfoResponseBodyUserInfo extends $tea.Model {
  availableService?: string;
  pdnsId?: number;
  serviceType?: string;
  state?: string;
  statisticSwitchStatus?: string;
  stoppedService?: string;
  static names(): { [key: string]: string } {
    return {
      availableService: 'AvailableService',
      pdnsId: 'PdnsId',
      serviceType: 'ServiceType',
      state: 'State',
      statisticSwitchStatus: 'StatisticSwitchStatus',
      stoppedService: 'StoppedService',
    };
  }

  static types(): { [key: string]: any } {
    return {
      availableService: 'string',
      pdnsId: 'number',
      serviceType: 'string',
      state: 'string',
      statisticSwitchStatus: 'string',
      stoppedService: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRecordLogsResponseBodyRecordLogsRecordLog extends $tea.Model {
  /**
   * @remarks
   * The operation that you performed.
   */
  action?: string;
  /**
   * @remarks
   * The time when you performed the operation.
   * 
   * @example
   * 2015-12-12T09:23Z
   */
  actionTime?: string;
  /**
   * @remarks
   * The time when you performed the operation. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
   * 
   * @example
   * 134514540000
   */
  actionTimestamp?: number;
  /**
   * @remarks
   * The IP address of the operator.
   * 
   * @example
   * 182.92.253.XX
   */
  clientIp?: string;
  /**
   * @remarks
   * The operation message.
   */
  message?: string;
  static names(): { [key: string]: string } {
    return {
      action: 'Action',
      actionTime: 'ActionTime',
      actionTimestamp: 'ActionTimestamp',
      clientIp: 'ClientIp',
      message: 'Message',
    };
  }

  static types(): { [key: string]: any } {
    return {
      action: 'string',
      actionTime: 'string',
      actionTimestamp: 'number',
      clientIp: 'string',
      message: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRecordLogsResponseBodyRecordLogs extends $tea.Model {
  recordLog?: DescribeRecordLogsResponseBodyRecordLogsRecordLog[];
  static names(): { [key: string]: string } {
    return {
      recordLog: 'RecordLog',
    };
  }

  static types(): { [key: string]: any } {
    return {
      recordLog: { 'type': 'array', 'itemType': DescribeRecordLogsResponseBodyRecordLogsRecordLog },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRecordResolveStatisticsSummaryResponseBodyStatistics extends $tea.Model {
  /**
   * @remarks
   * The number of DNS requests.
   * 
   * @example
   * 330
   */
  count?: string;
  /**
   * @remarks
   * The subdomain name.
   * 
   * @example
   * tes.example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The type of the domain name. The parameter value is not case-sensitive. Valid values:
   * 
   * *   PUBLIC (default): hosted public domain name
   * *   CACHE: cache-accelerated domain name
   * 
   * @example
   * PUBLIC
   */
  domainType?: string;
  /**
   * @remarks
   * The subdomain.
   * 
   * @example
   * test.example.com
   */
  subDomain?: string;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      domainName: 'DomainName',
      domainType: 'DomainType',
      subDomain: 'SubDomain',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'string',
      domainName: 'string',
      domainType: 'string',
      subDomain: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRecordStatisticsResponseBodyStatisticsStatistic extends $tea.Model {
  /**
   * @remarks
   * The number of DNS requests.
   * 
   * @example
   * 15292887
   */
  count?: number;
  /**
   * @remarks
   * The statistical timestamp. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
   * 
   * @example
   * 1556640000000
   */
  timestamp?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      timestamp: 'Timestamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      timestamp: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRecordStatisticsResponseBodyStatistics extends $tea.Model {
  statistic?: DescribeRecordStatisticsResponseBodyStatisticsStatistic[];
  static names(): { [key: string]: string } {
    return {
      statistic: 'Statistic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      statistic: { 'type': 'array', 'itemType': DescribeRecordStatisticsResponseBodyStatisticsStatistic },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRecordStatisticsSummaryResponseBodyStatisticsStatistic extends $tea.Model {
  /**
   * @remarks
   * The number of DNS requests.
   * 
   * @example
   * 838711553
   */
  count?: number;
  /**
   * @remarks
   * The subdomain.
   * 
   * @example
   * t1.alitest2.com
   */
  subDomain?: string;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      subDomain: 'SubDomain',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      subDomain: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRecordStatisticsSummaryResponseBodyStatistics extends $tea.Model {
  statistic?: DescribeRecordStatisticsSummaryResponseBodyStatisticsStatistic[];
  static names(): { [key: string]: string } {
    return {
      statistic: 'Statistic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      statistic: { 'type': 'array', 'itemType': DescribeRecordStatisticsSummaryResponseBodyStatisticsStatistic },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSubDomainRecordsResponseBodyDomainRecordsRecord extends $tea.Model {
  /**
   * @remarks
   * The domain name.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The DNS resolution line.
   * 
   * @example
   * default
   */
  line?: string;
  /**
   * @remarks
   * The lock status of the DNS record.
   * 
   * @example
   * false
   */
  locked?: boolean;
  /**
   * @remarks
   * The priority of the mail exchanger (MX) record.
   * 
   * @example
   * 2
   */
  priority?: number;
  /**
   * @remarks
   * The hostname.
   * 
   * @example
   * www
   */
  RR?: string;
  /**
   * @remarks
   * The ID of the DNS record.
   * 
   * @example
   * 9999985
   */
  recordId?: string;
  /**
   * @remarks
   * The description of the DNS record.
   * 
   * @example
   * test
   */
  remark?: string;
  /**
   * @remarks
   * The status of the DNS record.
   * 
   * @example
   * Enable
   */
  status?: string;
  /**
   * @remarks
   * The time-to-live (TTL) of the DNS record.
   * 
   * @example
   * 600
   */
  TTL?: number;
  /**
   * @remarks
   * The type of the DNS record.
   * 
   * @example
   * CNAME
   */
  type?: string;
  /**
   * @remarks
   * The record value.
   * 
   * @example
   * example.net
   */
  value?: string;
  /**
   * @remarks
   * The weight of the DNS record.
   * 
   * @example
   * 10
   */
  weight?: number;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      line: 'Line',
      locked: 'Locked',
      priority: 'Priority',
      RR: 'RR',
      recordId: 'RecordId',
      remark: 'Remark',
      status: 'Status',
      TTL: 'TTL',
      type: 'Type',
      value: 'Value',
      weight: 'Weight',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      line: 'string',
      locked: 'boolean',
      priority: 'number',
      RR: 'string',
      recordId: 'string',
      remark: 'string',
      status: 'string',
      TTL: 'number',
      type: 'string',
      value: 'string',
      weight: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSubDomainRecordsResponseBodyDomainRecords extends $tea.Model {
  record?: DescribeSubDomainRecordsResponseBodyDomainRecordsRecord[];
  static names(): { [key: string]: string } {
    return {
      record: 'Record',
    };
  }

  static types(): { [key: string]: any } {
    return {
      record: { 'type': 'array', 'itemType': DescribeSubDomainRecordsResponseBodyDomainRecordsRecord },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSupportLinesResponseBodyRecordLinesRecordLine extends $tea.Model {
  /**
   * @remarks
   * 2021-12-06T02:47:26.000+0000
   * 
   * @example
   * unicom
   */
  fatherCode?: string;
  /**
   * @remarks
   * Code
   * 
   * @example
   * cn_unicom_shanxi
   */
  lineCode?: string;
  /**
   * @remarks
   * 
   * 
   * @example
   * 
   */
  lineDisplayName?: string;
  /**
   * @remarks
   * 
   * 
   * @example
   * _
   */
  lineName?: string;
  static names(): { [key: string]: string } {
    return {
      fatherCode: 'FatherCode',
      lineCode: 'LineCode',
      lineDisplayName: 'LineDisplayName',
      lineName: 'LineName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fatherCode: 'string',
      lineCode: 'string',
      lineDisplayName: 'string',
      lineName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSupportLinesResponseBodyRecordLines extends $tea.Model {
  recordLine?: DescribeSupportLinesResponseBodyRecordLinesRecordLine[];
  static names(): { [key: string]: string } {
    return {
      recordLine: 'RecordLine',
    };
  }

  static types(): { [key: string]: any } {
    return {
      recordLine: { 'type': 'array', 'itemType': DescribeSupportLinesResponseBodyRecordLinesRecordLine },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTagsResponseBodyTags extends $tea.Model {
  /**
   * @remarks
   * The key of tag N added to the resource.
   * 
   * @example
   * abc
   */
  key?: string;
  /**
   * @remarks
   * The values of tags added to the resource.
   */
  values?: string[];
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      values: 'Values',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      values: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTransferDomainsResponseBodyDomainTransfersDomainTransfer extends $tea.Model {
  /**
   * @remarks
   * The time when the domain name was created. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.
   * 
   * @example
   * 2019-10-30T07:16Z
   */
  createTime?: string;
  /**
   * @remarks
   * The time when the domain name was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
   * 
   * @example
   * 1572419764000
   */
  createTimestamp?: number;
  /**
   * @remarks
   * The domain name.
   * 
   * @example
   * test.com
   */
  domainName?: string;
  /**
   * @remarks
   * The user ID from which the domain name was transferred.
   * 
   * @example
   * 2222
   */
  fromUserId?: number;
  /**
   * @remarks
   * The ID of the domain name that was transferred.
   * 
   * @example
   * 1
   */
  id?: number;
  /**
   * @remarks
   * The user ID to which the domain name was transferred.
   * 
   * @example
   * 111111
   */
  targetUserId?: number;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      createTimestamp: 'CreateTimestamp',
      domainName: 'DomainName',
      fromUserId: 'FromUserId',
      id: 'Id',
      targetUserId: 'TargetUserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'string',
      createTimestamp: 'number',
      domainName: 'string',
      fromUserId: 'number',
      id: 'number',
      targetUserId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTransferDomainsResponseBodyDomainTransfers extends $tea.Model {
  domainTransfer?: DescribeTransferDomainsResponseBodyDomainTransfersDomainTransfer[];
  static names(): { [key: string]: string } {
    return {
      domainTransfer: 'DomainTransfer',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainTransfer: { 'type': 'array', 'itemType': DescribeTransferDomainsResponseBodyDomainTransfersDomainTransfer },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressHealthTasksHealthTask extends $tea.Model {
  /**
   * @example
   * 80
   */
  port?: number;
  /**
   * @example
   * mtp-895180524251002880
   */
  templateId?: string;
  /**
   * @example
   * IPv4-Ping
   */
  templateName?: string;
  static names(): { [key: string]: string } {
    return {
      port: 'Port',
      templateId: 'TemplateId',
      templateName: 'TemplateName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      port: 'number',
      templateId: 'string',
      templateName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressHealthTasks extends $tea.Model {
  healthTask?: ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressHealthTasksHealthTask[];
  static names(): { [key: string]: string } {
    return {
      healthTask: 'HealthTask',
    };
  }

  static types(): { [key: string]: any } {
    return {
      healthTask: { 'type': 'array', 'itemType': ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressHealthTasksHealthTask },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressRequestSource extends $tea.Model {
  requestSource?: string[];
  static names(): { [key: string]: string } {
    return {
      requestSource: 'RequestSource',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestSource: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddress extends $tea.Model {
  /**
   * @example
   * 223.5.XX.XX
   */
  address?: string;
  /**
   * @example
   * addr-895182181143688192
   */
  addressId?: string;
  attributeInfo?: string;
  /**
   * @example
   * auto
   */
  availableMode?: string;
  /**
   * @example
   * available
   */
  availableStatus?: string;
  /**
   * @example
   * 2024-03-15T01:46Z
   */
  createTime?: string;
  /**
   * @example
   * 1527690629357
   */
  createTimestamp?: number;
  /**
   * @example
   * enable
   */
  enableStatus?: string;
  /**
   * @example
   * any_ok
   */
  healthJudgement?: string;
  /**
   * @example
   * ok
   */
  healthStatus?: string;
  healthTasks?: ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressHealthTasks;
  /**
   * @example
   * available
   */
  manualAvailableStatus?: string;
  /**
   * @example
   * Address-1
   */
  name?: string;
  /**
   * @example
   * test
   */
  remark?: string;
  requestSource?: ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressRequestSource;
  seqNonPreemptiveSchedule?: boolean;
  /**
   * @example
   * 1
   */
  serialNumber?: number;
  /**
   * @example
   * IPv4
   */
  type?: string;
  /**
   * @example
   * 2024-03-15T01:46Z
   */
  updateTime?: string;
  /**
   * @example
   * 1527690629357
   */
  updateTimestamp?: number;
  /**
   * @example
   * 1
   */
  weightValue?: number;
  static names(): { [key: string]: string } {
    return {
      address: 'Address',
      addressId: 'AddressId',
      attributeInfo: 'AttributeInfo',
      availableMode: 'AvailableMode',
      availableStatus: 'AvailableStatus',
      createTime: 'CreateTime',
      createTimestamp: 'CreateTimestamp',
      enableStatus: 'EnableStatus',
      healthJudgement: 'HealthJudgement',
      healthStatus: 'HealthStatus',
      healthTasks: 'HealthTasks',
      manualAvailableStatus: 'ManualAvailableStatus',
      name: 'Name',
      remark: 'Remark',
      requestSource: 'RequestSource',
      seqNonPreemptiveSchedule: 'SeqNonPreemptiveSchedule',
      serialNumber: 'SerialNumber',
      type: 'Type',
      updateTime: 'UpdateTime',
      updateTimestamp: 'UpdateTimestamp',
      weightValue: 'WeightValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      address: 'string',
      addressId: 'string',
      attributeInfo: 'string',
      availableMode: 'string',
      availableStatus: 'string',
      createTime: 'string',
      createTimestamp: 'number',
      enableStatus: 'string',
      healthJudgement: 'string',
      healthStatus: 'string',
      healthTasks: ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressHealthTasks,
      manualAvailableStatus: 'string',
      name: 'string',
      remark: 'string',
      requestSource: ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressRequestSource,
      seqNonPreemptiveSchedule: 'boolean',
      serialNumber: 'number',
      type: 'string',
      updateTime: 'string',
      updateTimestamp: 'number',
      weightValue: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddresses extends $tea.Model {
  address?: ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddress[];
  static names(): { [key: string]: string } {
    return {
      address: 'Address',
    };
  }

  static types(): { [key: string]: any } {
    return {
      address: { 'type': 'array', 'itemType': ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddress },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPool extends $tea.Model {
  /**
   * @example
   * round_robin
   */
  addressLbStrategy?: string;
  /**
   * @example
   * pool-89528023225442**16
   */
  addressPoolId?: string;
  /**
   * @example
   * AddressPool-1
   */
  addressPoolName?: string;
  /**
   * @example
   * IPv4
   */
  addressPoolType?: string;
  addresses?: ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddresses;
  /**
   * @example
   * available
   */
  availableStatus?: string;
  /**
   * @example
   * 2024-03-15T01:46Z
   */
  createTime?: string;
  /**
   * @example
   * 1527690629357
   */
  createTimestamp?: number;
  /**
   * @example
   * enable
   */
  enableStatus?: string;
  /**
   * @example
   * any_ok
   */
  healthJudgement?: string;
  /**
   * @example
   * ok
   */
  healthStatus?: string;
  /**
   * @example
   * test
   */
  remark?: string;
  /**
   * @example
   * preemptive
   */
  sequenceLbStrategyMode?: string;
  /**
   * @example
   * 2024-03-15T01:46Z
   */
  updateTime?: string;
  /**
   * @example
   * 1527690629357
   */
  updateTimestamp?: number;
  static names(): { [key: string]: string } {
    return {
      addressLbStrategy: 'AddressLbStrategy',
      addressPoolId: 'AddressPoolId',
      addressPoolName: 'AddressPoolName',
      addressPoolType: 'AddressPoolType',
      addresses: 'Addresses',
      availableStatus: 'AvailableStatus',
      createTime: 'CreateTime',
      createTimestamp: 'CreateTimestamp',
      enableStatus: 'EnableStatus',
      healthJudgement: 'HealthJudgement',
      healthStatus: 'HealthStatus',
      remark: 'Remark',
      sequenceLbStrategyMode: 'SequenceLbStrategyMode',
      updateTime: 'UpdateTime',
      updateTimestamp: 'UpdateTimestamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addressLbStrategy: 'string',
      addressPoolId: 'string',
      addressPoolName: 'string',
      addressPoolType: 'string',
      addresses: ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddresses,
      availableStatus: 'string',
      createTime: 'string',
      createTimestamp: 'number',
      enableStatus: 'string',
      healthJudgement: 'string',
      healthStatus: 'string',
      remark: 'string',
      sequenceLbStrategyMode: 'string',
      updateTime: 'string',
      updateTimestamp: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudGtmAddressPoolsResponseBodyAddressPools extends $tea.Model {
  addressPool?: ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPool[];
  static names(): { [key: string]: string } {
    return {
      addressPool: 'AddressPool',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addressPool: { 'type': 'array', 'itemType': ListCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPool },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudGtmAddressesResponseBodyAddressesAddressHealthTasksHealthTask extends $tea.Model {
  /**
   * @example
   * ok
   */
  monitorStatus?: string;
  /**
   * @example
   * 80
   */
  port?: number;
  /**
   * @example
   * mtp-89518052425100**80
   */
  templateId?: string;
  /**
   * @example
   * Ping-IPv4
   */
  templateName?: string;
  static names(): { [key: string]: string } {
    return {
      monitorStatus: 'MonitorStatus',
      port: 'Port',
      templateId: 'TemplateId',
      templateName: 'TemplateName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      monitorStatus: 'string',
      port: 'number',
      templateId: 'string',
      templateName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudGtmAddressesResponseBodyAddressesAddressHealthTasks extends $tea.Model {
  healthTask?: ListCloudGtmAddressesResponseBodyAddressesAddressHealthTasksHealthTask[];
  static names(): { [key: string]: string } {
    return {
      healthTask: 'HealthTask',
    };
  }

  static types(): { [key: string]: any } {
    return {
      healthTask: { 'type': 'array', 'itemType': ListCloudGtmAddressesResponseBodyAddressesAddressHealthTasksHealthTask },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudGtmAddressesResponseBodyAddressesAddress extends $tea.Model {
  /**
   * @example
   * 223.5.XX.XX
   */
  address?: string;
  /**
   * @example
   * addr-89518218114368**92
   */
  addressId?: string;
  attributeInfo?: string;
  /**
   * @example
   * auto
   */
  availableMode?: string;
  /**
   * @example
   * available
   */
  availableStatus?: string;
  /**
   * @example
   * 2024-03-23T13:09Z
   */
  createTime?: string;
  /**
   * @example
   * 1527690629357
   */
  createTimestamp?: number;
  /**
   * @example
   * enable
   */
  enableStatus?: string;
  /**
   * @example
   * p50_ok
   */
  healthJudgement?: string;
  /**
   * @example
   * ok
   */
  healthStatus?: string;
  healthTasks?: ListCloudGtmAddressesResponseBodyAddressesAddressHealthTasks;
  /**
   * @example
   * available
   */
  manualAvailableStatus?: string;
  /**
   * @example
   * Address-1
   */
  name?: string;
  /**
   * @example
   * app
   */
  remark?: string;
  /**
   * @example
   * IPv4
   */
  type?: string;
  /**
   * @example
   * 2024-03-29T13:20Z
   */
  updateTime?: string;
  /**
   * @example
   * 1527690824357
   */
  updateTimestamp?: number;
  static names(): { [key: string]: string } {
    return {
      address: 'Address',
      addressId: 'AddressId',
      attributeInfo: 'AttributeInfo',
      availableMode: 'AvailableMode',
      availableStatus: 'AvailableStatus',
      createTime: 'CreateTime',
      createTimestamp: 'CreateTimestamp',
      enableStatus: 'EnableStatus',
      healthJudgement: 'HealthJudgement',
      healthStatus: 'HealthStatus',
      healthTasks: 'HealthTasks',
      manualAvailableStatus: 'ManualAvailableStatus',
      name: 'Name',
      remark: 'Remark',
      type: 'Type',
      updateTime: 'UpdateTime',
      updateTimestamp: 'UpdateTimestamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      address: 'string',
      addressId: 'string',
      attributeInfo: 'string',
      availableMode: 'string',
      availableStatus: 'string',
      createTime: 'string',
      createTimestamp: 'number',
      enableStatus: 'string',
      healthJudgement: 'string',
      healthStatus: 'string',
      healthTasks: ListCloudGtmAddressesResponseBodyAddressesAddressHealthTasks,
      manualAvailableStatus: 'string',
      name: 'string',
      remark: 'string',
      type: 'string',
      updateTime: 'string',
      updateTimestamp: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudGtmAddressesResponseBodyAddresses extends $tea.Model {
  address?: ListCloudGtmAddressesResponseBodyAddressesAddress[];
  static names(): { [key: string]: string } {
    return {
      address: 'Address',
    };
  }

  static types(): { [key: string]: any } {
    return {
      address: { 'type': 'array', 'itemType': ListCloudGtmAddressesResponseBodyAddressesAddress },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudGtmAlertLogsResponseBodyLogsLog extends $tea.Model {
  /**
   * @example
   * ALERT
   */
  actionType?: string;
  content?: string;
  /**
   * @example
   * GTM_ADDRESS
   */
  entityType?: string;
  /**
   * @example
   * 1711328826977
   */
  timestamp?: number;
  static names(): { [key: string]: string } {
    return {
      actionType: 'ActionType',
      content: 'Content',
      entityType: 'EntityType',
      timestamp: 'Timestamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actionType: 'string',
      content: 'string',
      entityType: 'string',
      timestamp: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudGtmAlertLogsResponseBodyLogs extends $tea.Model {
  log?: ListCloudGtmAlertLogsResponseBodyLogsLog[];
  static names(): { [key: string]: string } {
    return {
      log: 'Log',
    };
  }

  static types(): { [key: string]: any } {
    return {
      log: { 'type': 'array', 'itemType': ListCloudGtmAlertLogsResponseBodyLogsLog },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudGtmAvailableAlertGroupsResponseBodyAlertGroupsAlertGroup extends $tea.Model {
  groupName?: string;
  static names(): { [key: string]: string } {
    return {
      groupName: 'GroupName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudGtmAvailableAlertGroupsResponseBodyAlertGroups extends $tea.Model {
  alertGroup?: ListCloudGtmAvailableAlertGroupsResponseBodyAlertGroupsAlertGroup[];
  static names(): { [key: string]: string } {
    return {
      alertGroup: 'AlertGroup',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertGroup: { 'type': 'array', 'itemType': ListCloudGtmAvailableAlertGroupsResponseBodyAlertGroupsAlertGroup },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPoolsAddressPoolRequestSource extends $tea.Model {
  requestSource?: string[];
  static names(): { [key: string]: string } {
    return {
      requestSource: 'RequestSource',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestSource: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPoolsAddressPool extends $tea.Model {
  /**
   * @example
   * round_robin
   */
  addressLbStrategy?: string;
  /**
   * @example
   * pool-89528023225442**16
   */
  addressPoolId?: string;
  /**
   * @example
   * AddressPool-1
   */
  addressPoolName?: string;
  /**
   * @example
   * IPv4
   */
  addressPoolType?: string;
  /**
   * @example
   * available
   */
  availableStatus?: string;
  /**
   * @example
   * 2024-03-15T01:46Z
   */
  createTime?: string;
  /**
   * @example
   * 1527690629357
   */
  createTimestamp?: number;
  /**
   * @example
   * enable
   */
  enableStatus?: string;
  /**
   * @example
   * ok
   */
  healthJudgement?: string;
  /**
   * @example
   * ok
   */
  healthStatus?: string;
  requestSource?: ListCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPoolsAddressPoolRequestSource;
  seqNonPreemptiveSchedule?: boolean;
  /**
   * @example
   * preemptive
   */
  sequenceLbStrategyMode?: string;
  /**
   * @example
   * 1
   */
  serialNumber?: number;
  /**
   * @example
   * 2024-03-15T01:46Z
   */
  updateTime?: string;
  /**
   * @example
   * 1527690629357
   */
  updateTimestamp?: number;
  /**
   * @example
   * 1
   */
  weightValue?: number;
  static names(): { [key: string]: string } {
    return {
      addressLbStrategy: 'AddressLbStrategy',
      addressPoolId: 'AddressPoolId',
      addressPoolName: 'AddressPoolName',
      addressPoolType: 'AddressPoolType',
      availableStatus: 'AvailableStatus',
      createTime: 'CreateTime',
      createTimestamp: 'CreateTimestamp',
      enableStatus: 'EnableStatus',
      healthJudgement: 'HealthJudgement',
      healthStatus: 'HealthStatus',
      requestSource: 'RequestSource',
      seqNonPreemptiveSchedule: 'SeqNonPreemptiveSchedule',
      sequenceLbStrategyMode: 'SequenceLbStrategyMode',
      serialNumber: 'SerialNumber',
      updateTime: 'UpdateTime',
      updateTimestamp: 'UpdateTimestamp',
      weightValue: 'WeightValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addressLbStrategy: 'string',
      addressPoolId: 'string',
      addressPoolName: 'string',
      addressPoolType: 'string',
      availableStatus: 'string',
      createTime: 'string',
      createTimestamp: 'number',
      enableStatus: 'string',
      healthJudgement: 'string',
      healthStatus: 'string',
      requestSource: ListCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPoolsAddressPoolRequestSource,
      seqNonPreemptiveSchedule: 'boolean',
      sequenceLbStrategyMode: 'string',
      serialNumber: 'number',
      updateTime: 'string',
      updateTimestamp: 'number',
      weightValue: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPools extends $tea.Model {
  addressPool?: ListCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPoolsAddressPool[];
  static names(): { [key: string]: string } {
    return {
      addressPool: 'AddressPool',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addressPool: { 'type': 'array', 'itemType': ListCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPoolsAddressPool },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfig extends $tea.Model {
  /**
   * @example
   * round_robin
   */
  addressPoolLbStrategy?: string;
  addressPools?: ListCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPools;
  /**
   * @example
   * available
   */
  availableStatus?: string;
  /**
   * @example
   * dns_gtm_public_cn
   */
  commodityCode?: string;
  /**
   * @example
   * Config-000**11
   */
  configId?: string;
  /**
   * @example
   * 2024-03-15T01:46Z
   */
  createTime?: string;
  /**
   * @example
   * 1527690629357
   */
  createTimestamp?: number;
  /**
   * @example
   * enable
   */
  enableStatus?: string;
  /**
   * @example
   * ok
   */
  healthStatus?: string;
  /**
   * @example
   * gtm-cn-wwo3a3hbz**
   */
  instanceId?: string;
  /**
   * @example
   * test
   */
  remark?: string;
  /**
   * @example
   * www.example.com
   */
  scheduleDomainName?: string;
  /**
   * @example
   * www
   */
  scheduleHostname?: string;
  /**
   * @example
   * A
   */
  scheduleRrType?: string;
  /**
   * @example
   * custom
   */
  scheduleZoneMode?: string;
  /**
   * @example
   * example.com
   */
  scheduleZoneName?: string;
  /**
   * @example
   * preemptive
   */
  sequenceLbStrategyMode?: string;
  /**
   * @example
   * 60
   */
  ttl?: number;
  /**
   * @example
   * 2024-03-15T01:46Z
   */
  updateTime?: string;
  /**
   * @example
   * 1527690629357
   */
  updateTimestamp?: number;
  /**
   * @example
   * ultimate
   */
  versionCode?: string;
  static names(): { [key: string]: string } {
    return {
      addressPoolLbStrategy: 'AddressPoolLbStrategy',
      addressPools: 'AddressPools',
      availableStatus: 'AvailableStatus',
      commodityCode: 'CommodityCode',
      configId: 'ConfigId',
      createTime: 'CreateTime',
      createTimestamp: 'CreateTimestamp',
      enableStatus: 'EnableStatus',
      healthStatus: 'HealthStatus',
      instanceId: 'InstanceId',
      remark: 'Remark',
      scheduleDomainName: 'ScheduleDomainName',
      scheduleHostname: 'ScheduleHostname',
      scheduleRrType: 'ScheduleRrType',
      scheduleZoneMode: 'ScheduleZoneMode',
      scheduleZoneName: 'ScheduleZoneName',
      sequenceLbStrategyMode: 'SequenceLbStrategyMode',
      ttl: 'Ttl',
      updateTime: 'UpdateTime',
      updateTimestamp: 'UpdateTimestamp',
      versionCode: 'VersionCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addressPoolLbStrategy: 'string',
      addressPools: ListCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPools,
      availableStatus: 'string',
      commodityCode: 'string',
      configId: 'string',
      createTime: 'string',
      createTimestamp: 'number',
      enableStatus: 'string',
      healthStatus: 'string',
      instanceId: 'string',
      remark: 'string',
      scheduleDomainName: 'string',
      scheduleHostname: 'string',
      scheduleRrType: 'string',
      scheduleZoneMode: 'string',
      scheduleZoneName: 'string',
      sequenceLbStrategyMode: 'string',
      ttl: 'number',
      updateTime: 'string',
      updateTimestamp: 'number',
      versionCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudGtmInstanceConfigsResponseBodyInstanceConfigs extends $tea.Model {
  instanceConfig?: ListCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfig[];
  static names(): { [key: string]: string } {
    return {
      instanceConfig: 'InstanceConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceConfig: { 'type': 'array', 'itemType': ListCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfig },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudGtmInstancesResponseBodyInstancesInstance extends $tea.Model {
  /**
   * @example
   * dns_gtm_public_cn
   */
  commodityCode?: string;
  /**
   * @example
   * 2024-03-15T01:46Z
   */
  createTime?: string;
  /**
   * @example
   * 1231298343343
   */
  createTimestamp?: number;
  /**
   * @example
   * 2024-03-15T01:46Z
   */
  expireTime?: string;
  /**
   * @example
   * 1231298343343
   */
  expireTimestamp?: number;
  /**
   * @example
   * gtm-cn-jmp3qnw**03
   */
  instanceId?: string;
  /**
   * @example
   * test
   */
  instanceName?: string;
  /**
   * @example
   * 100
   */
  monitorTaskQuota?: number;
  /**
   * @example
   * 50
   */
  monthlyEmailUsed?: number;
  /**
   * @example
   * 1000
   */
  monthlySmsQuota?: number;
  /**
   * @example
   * 100
   */
  monthlySmsUsed?: number;
  /**
   * @example
   * 80
   */
  monthlyWebhookUsed?: number;
  /**
   * @example
   * www.example.com
   */
  scheduleDomainName?: string;
  /**
   * @example
   * 2024-03-15T01:46Z
   */
  updateTime?: string;
  /**
   * @example
   * 1231298343343
   */
  updateTimestamp?: number;
  /**
   * @example
   * ultimate
   */
  versionCode?: string;
  static names(): { [key: string]: string } {
    return {
      commodityCode: 'CommodityCode',
      createTime: 'CreateTime',
      createTimestamp: 'CreateTimestamp',
      expireTime: 'ExpireTime',
      expireTimestamp: 'ExpireTimestamp',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      monitorTaskQuota: 'MonitorTaskQuota',
      monthlyEmailUsed: 'MonthlyEmailUsed',
      monthlySmsQuota: 'MonthlySmsQuota',
      monthlySmsUsed: 'MonthlySmsUsed',
      monthlyWebhookUsed: 'MonthlyWebhookUsed',
      scheduleDomainName: 'ScheduleDomainName',
      updateTime: 'UpdateTime',
      updateTimestamp: 'UpdateTimestamp',
      versionCode: 'VersionCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commodityCode: 'string',
      createTime: 'string',
      createTimestamp: 'number',
      expireTime: 'string',
      expireTimestamp: 'number',
      instanceId: 'string',
      instanceName: 'string',
      monitorTaskQuota: 'number',
      monthlyEmailUsed: 'number',
      monthlySmsQuota: 'number',
      monthlySmsUsed: 'number',
      monthlyWebhookUsed: 'number',
      scheduleDomainName: 'string',
      updateTime: 'string',
      updateTimestamp: 'number',
      versionCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudGtmInstancesResponseBodyInstances extends $tea.Model {
  instance?: ListCloudGtmInstancesResponseBodyInstancesInstance[];
  static names(): { [key: string]: string } {
    return {
      instance: 'Instance',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instance: { 'type': 'array', 'itemType': ListCloudGtmInstancesResponseBodyInstancesInstance },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudGtmMonitorNodesResponseBodyIpv4IspCityNodesIpv4IspCityNodeIps extends $tea.Model {
  ip?: string[];
  static names(): { [key: string]: string } {
    return {
      ip: 'Ip',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ip: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudGtmMonitorNodesResponseBodyIpv4IspCityNodesIpv4IspCityNode extends $tea.Model {
  /**
   * @example
   * 503
   */
  cityCode?: string;
  cityName?: string;
  /**
   * @example
   * 001
   */
  countryCode?: string;
  countryName?: string;
  /**
   * @example
   * true
   */
  defaultSelected?: boolean;
  groupName?: string;
  /**
   * @example
   * BGP
   */
  groupType?: string;
  ips?: ListCloudGtmMonitorNodesResponseBodyIpv4IspCityNodesIpv4IspCityNodeIps;
  /**
   * @example
   * 465
   */
  ispCode?: string;
  ispName?: string;
  /**
   * @example
   * node-ewze1bysndy4gf**j8
   */
  nodeId?: string;
  static names(): { [key: string]: string } {
    return {
      cityCode: 'CityCode',
      cityName: 'CityName',
      countryCode: 'CountryCode',
      countryName: 'CountryName',
      defaultSelected: 'DefaultSelected',
      groupName: 'GroupName',
      groupType: 'GroupType',
      ips: 'Ips',
      ispCode: 'IspCode',
      ispName: 'IspName',
      nodeId: 'NodeId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cityCode: 'string',
      cityName: 'string',
      countryCode: 'string',
      countryName: 'string',
      defaultSelected: 'boolean',
      groupName: 'string',
      groupType: 'string',
      ips: ListCloudGtmMonitorNodesResponseBodyIpv4IspCityNodesIpv4IspCityNodeIps,
      ispCode: 'string',
      ispName: 'string',
      nodeId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudGtmMonitorNodesResponseBodyIpv4IspCityNodes extends $tea.Model {
  ipv4IspCityNode?: ListCloudGtmMonitorNodesResponseBodyIpv4IspCityNodesIpv4IspCityNode[];
  static names(): { [key: string]: string } {
    return {
      ipv4IspCityNode: 'Ipv4IspCityNode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ipv4IspCityNode: { 'type': 'array', 'itemType': ListCloudGtmMonitorNodesResponseBodyIpv4IspCityNodesIpv4IspCityNode },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudGtmMonitorNodesResponseBodyIpv6IspCityNodesIpv6IspCityNodeIps extends $tea.Model {
  ip?: string[];
  static names(): { [key: string]: string } {
    return {
      ip: 'Ip',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ip: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudGtmMonitorNodesResponseBodyIpv6IspCityNodesIpv6IspCityNode extends $tea.Model {
  /**
   * @example
   * 503
   */
  cityCode?: string;
  cityName?: string;
  /**
   * @example
   * 001
   */
  countryCode?: string;
  countryName?: string;
  /**
   * @example
   * true
   */
  defaultSelected?: boolean;
  groupName?: string;
  /**
   * @example
   * BGP
   */
  groupType?: string;
  ips?: ListCloudGtmMonitorNodesResponseBodyIpv6IspCityNodesIpv6IspCityNodeIps;
  /**
   * @example
   * 465
   */
  ispCode?: string;
  ispName?: string;
  /**
   * @example
   * node-ewze1bysndy4gf**j8
   */
  nodeId?: string;
  static names(): { [key: string]: string } {
    return {
      cityCode: 'CityCode',
      cityName: 'CityName',
      countryCode: 'CountryCode',
      countryName: 'CountryName',
      defaultSelected: 'DefaultSelected',
      groupName: 'GroupName',
      groupType: 'GroupType',
      ips: 'Ips',
      ispCode: 'IspCode',
      ispName: 'IspName',
      nodeId: 'NodeId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cityCode: 'string',
      cityName: 'string',
      countryCode: 'string',
      countryName: 'string',
      defaultSelected: 'boolean',
      groupName: 'string',
      groupType: 'string',
      ips: ListCloudGtmMonitorNodesResponseBodyIpv6IspCityNodesIpv6IspCityNodeIps,
      ispCode: 'string',
      ispName: 'string',
      nodeId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudGtmMonitorNodesResponseBodyIpv6IspCityNodes extends $tea.Model {
  ipv6IspCityNode?: ListCloudGtmMonitorNodesResponseBodyIpv6IspCityNodesIpv6IspCityNode[];
  static names(): { [key: string]: string } {
    return {
      ipv6IspCityNode: 'Ipv6IspCityNode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ipv6IspCityNode: { 'type': 'array', 'itemType': ListCloudGtmMonitorNodesResponseBodyIpv6IspCityNodesIpv6IspCityNode },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudGtmMonitorTemplatesResponseBodyTemplatesTemplateIspCityNodesIspCityNode extends $tea.Model {
  /**
   * @example
   * 503
   */
  cityCode?: string;
  cityName?: string;
  /**
   * @example
   * 001
   */
  countryCode?: string;
  countryName?: string;
  groupName?: string;
  /**
   * @example
   * BGP
   */
  groupType?: string;
  /**
   * @example
   * 465
   */
  ispCode?: string;
  ispName?: string;
  static names(): { [key: string]: string } {
    return {
      cityCode: 'CityCode',
      cityName: 'CityName',
      countryCode: 'CountryCode',
      countryName: 'CountryName',
      groupName: 'GroupName',
      groupType: 'GroupType',
      ispCode: 'IspCode',
      ispName: 'IspName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cityCode: 'string',
      cityName: 'string',
      countryCode: 'string',
      countryName: 'string',
      groupName: 'string',
      groupType: 'string',
      ispCode: 'string',
      ispName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudGtmMonitorTemplatesResponseBodyTemplatesTemplateIspCityNodes extends $tea.Model {
  ispCityNode?: ListCloudGtmMonitorTemplatesResponseBodyTemplatesTemplateIspCityNodesIspCityNode[];
  static names(): { [key: string]: string } {
    return {
      ispCityNode: 'IspCityNode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ispCityNode: { 'type': 'array', 'itemType': ListCloudGtmMonitorTemplatesResponseBodyTemplatesTemplateIspCityNodesIspCityNode },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudGtmMonitorTemplatesResponseBodyTemplatesTemplate extends $tea.Model {
  /**
   * @example
   * 2024-03-23T13:09Z
   */
  createTime?: string;
  /**
   * @example
   * 1527690629357
   */
  createTimestamp?: number;
  /**
   * @example
   * 2
   */
  evaluationCount?: number;
  /**
   * @example
   * {\\"code\\":200,\\"path\\":\\"\\\\index.htm\\",\\"host\\":\\"aliyun.com\\"}
   */
  extendInfo?: string;
  /**
   * @example
   * 50
   */
  failureRate?: number;
  /**
   * @example
   * 60
   */
  interval?: number;
  /**
   * @example
   * IPv4
   */
  ipVersion?: string;
  ispCityNodes?: ListCloudGtmMonitorTemplatesResponseBodyTemplatesTemplateIspCityNodes;
  /**
   * @example
   * IPv4-Ping
   */
  name?: string;
  /**
   * @example
   * ping
   */
  protocol?: string;
  /**
   * @example
   * test
   */
  remark?: string;
  /**
   * @example
   * mtp-89518052425100**80
   */
  templateId?: string;
  /**
   * @example
   * 5000
   */
  timeout?: number;
  /**
   * @example
   * 2024-03-29T13:20Z
   */
  updateTime?: string;
  /**
   * @example
   * 1527690629357
   */
  updateTimestamp?: number;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      createTimestamp: 'CreateTimestamp',
      evaluationCount: 'EvaluationCount',
      extendInfo: 'ExtendInfo',
      failureRate: 'FailureRate',
      interval: 'Interval',
      ipVersion: 'IpVersion',
      ispCityNodes: 'IspCityNodes',
      name: 'Name',
      protocol: 'Protocol',
      remark: 'Remark',
      templateId: 'TemplateId',
      timeout: 'Timeout',
      updateTime: 'UpdateTime',
      updateTimestamp: 'UpdateTimestamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'string',
      createTimestamp: 'number',
      evaluationCount: 'number',
      extendInfo: 'string',
      failureRate: 'number',
      interval: 'number',
      ipVersion: 'string',
      ispCityNodes: ListCloudGtmMonitorTemplatesResponseBodyTemplatesTemplateIspCityNodes,
      name: 'string',
      protocol: 'string',
      remark: 'string',
      templateId: 'string',
      timeout: 'number',
      updateTime: 'string',
      updateTimestamp: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudGtmMonitorTemplatesResponseBodyTemplates extends $tea.Model {
  template?: ListCloudGtmMonitorTemplatesResponseBodyTemplatesTemplate[];
  static names(): { [key: string]: string } {
    return {
      template: 'Template',
    };
  }

  static types(): { [key: string]: any } {
    return {
      template: { 'type': 'array', 'itemType': ListCloudGtmMonitorTemplatesResponseBodyTemplatesTemplate },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTagResourcesRequestTag extends $tea.Model {
  /**
   * @remarks
   * The key of the tag.
   * 
   * @example
   * abcd
   */
  key?: string;
  /**
   * @remarks
   * The value of the tag.
   * 
   * @example
   * abcd
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTagResourcesResponseBodyTagResources extends $tea.Model {
  /**
   * @remarks
   * The ID of the resource.
   * 
   * @example
   * dns-example.com
   */
  resourceId?: string;
  /**
   * @remarks
   * The type of the resource. Only DOMAIN is returned.
   * 
   * @example
   * DOMAIN
   */
  resourceType?: string;
  /**
   * @remarks
   * The key of the tag.
   * 
   * @example
   * abcd
   */
  tagKey?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * abcd
   */
  tagValue?: string;
  static names(): { [key: string]: string } {
    return {
      resourceId: 'ResourceId',
      resourceType: 'ResourceType',
      tagKey: 'TagKey',
      tagValue: 'TagValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceId: 'string',
      resourceType: 'string',
      tagKey: 'string',
      tagValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyHichinaDomainDNSResponseBodyNewDnsServers extends $tea.Model {
  dnsServer?: string[];
  static names(): { [key: string]: string } {
    return {
      dnsServer: 'DnsServer',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dnsServer: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyHichinaDomainDNSResponseBodyOriginalDnsServers extends $tea.Model {
  dnsServer?: string[];
  static names(): { [key: string]: string } {
    return {
      dnsServer: 'DnsServer',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dnsServer: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OperateBatchDomainRequestDomainRecordInfo extends $tea.Model {
  /**
   * @remarks
   * The domain name.
   * 
   * >  You can submit 1 to 1,000 domain names. Due to the limit on the length of HTTP request headers, excessive domain names are ignored. Do not enter more than 1,000 domain names.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domain?: string;
  /**
   * @remarks
   * The resolution line. Default value: default.
   * 
   * @example
   * default
   */
  line?: string;
  /**
   * @example
   * mail
   */
  newRr?: string;
  /**
   * @example
   * AAAA
   */
  newType?: string;
  /**
   * @example
   * 114.92.XX.XX
   */
  newValue?: string;
  /**
   * @remarks
   * The priority of the mail exchanger (MX) record.
   * 
   * This parameter is required if the type of the DNS record is MX. Default value: 10.
   * 
   * @example
   * 5
   */
  priority?: number;
  /**
   * @remarks
   * The hostname.
   * 
   * >  This parameter is required if you set Type to **RR_ADD** or **RR_DEL**.
   * 
   * @example
   * zhaohui
   */
  rr?: string;
  /**
   * @remarks
   * The time-to-live (TTL) value of the cached DNS record. Unit: seconds. Default value: ***600***.
   * 
   * @example
   * 600
   */
  ttl?: number;
  /**
   * @remarks
   * The type of the DNS record. Valid values: A, AAAA, TXT, MX, and CNAME.
   * 
   * >  This parameter is required if you set Type to **RR_ADD** or **RR_DEL**.
   * 
   * @example
   * MX
   */
  type?: string;
  /**
   * @remarks
   * The record value.
   * 
   * >  This parameter is required if you set Type to **RR_ADD** or **RR_DEL**.
   * 
   * @example
   * fd87da3c4528844d45af39200155a905
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      line: 'Line',
      newRr: 'NewRr',
      newType: 'NewType',
      newValue: 'NewValue',
      priority: 'Priority',
      rr: 'Rr',
      ttl: 'Ttl',
      type: 'Type',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      line: 'string',
      newRr: 'string',
      newType: 'string',
      newValue: 'string',
      priority: 'number',
      rr: 'string',
      ttl: 'number',
      type: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PreviewGtmRecoveryPlanResponseBodyPreviewsPreviewSwitchInfosSwitchInfo extends $tea.Model {
  /**
   * @remarks
   * The formatted message content.
   */
  content?: string;
  /**
   * @remarks
   * The name of the switching policy for address pools.
   * 
   * @example
   * strategy-name-example-1
   */
  strategyName?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      strategyName: 'StrategyName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      strategyName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PreviewGtmRecoveryPlanResponseBodyPreviewsPreviewSwitchInfos extends $tea.Model {
  switchInfo?: PreviewGtmRecoveryPlanResponseBodyPreviewsPreviewSwitchInfosSwitchInfo[];
  static names(): { [key: string]: string } {
    return {
      switchInfo: 'SwitchInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      switchInfo: { 'type': 'array', 'itemType': PreviewGtmRecoveryPlanResponseBodyPreviewsPreviewSwitchInfosSwitchInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PreviewGtmRecoveryPlanResponseBodyPreviewsPreview extends $tea.Model {
  /**
   * @remarks
   * The ID of the GTM instance to which the previewed disaster recovery plan belongs.
   * 
   * @example
   * instance-example
   */
  instanceId?: string;
  /**
   * @remarks
   * The name of the GTM instance to which the previewed disaster recovery plan belongs.
   * 
   * @example
   * name-example
   */
  name?: string;
  /**
   * @remarks
   * The returned information of the switching policies for address pools.
   */
  switchInfos?: PreviewGtmRecoveryPlanResponseBodyPreviewsPreviewSwitchInfos;
  /**
   * @remarks
   * The user\\"s domain name or domain name list.
   * 
   * @example
   * 30.yyy.com
   */
  userDomainName?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      name: 'Name',
      switchInfos: 'SwitchInfos',
      userDomainName: 'UserDomainName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      name: 'string',
      switchInfos: PreviewGtmRecoveryPlanResponseBodyPreviewsPreviewSwitchInfos,
      userDomainName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PreviewGtmRecoveryPlanResponseBodyPreviews extends $tea.Model {
  preview?: PreviewGtmRecoveryPlanResponseBodyPreviewsPreview[];
  static names(): { [key: string]: string } {
    return {
      preview: 'Preview',
    };
  }

  static types(): { [key: string]: any } {
    return {
      preview: { 'type': 'array', 'itemType': PreviewGtmRecoveryPlanResponseBodyPreviewsPreview },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReplaceCloudGtmAddressPoolAddressRequestAddresses extends $tea.Model {
  /**
   * @example
   * addr-89636516932803**44
   */
  addressId?: string;
  requestSource?: string[];
  /**
   * @example
   * 1
   */
  serialNumber?: number;
  /**
   * @example
   * 1
   */
  weightValue?: number;
  static names(): { [key: string]: string } {
    return {
      addressId: 'AddressId',
      requestSource: 'RequestSource',
      serialNumber: 'SerialNumber',
      weightValue: 'WeightValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addressId: 'string',
      requestSource: { 'type': 'array', 'itemType': 'string' },
      serialNumber: 'number',
      weightValue: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReplaceCloudGtmInstanceConfigAddressPoolRequestAddressPools extends $tea.Model {
  /**
   * @example
   * pool-89564542105737**12
   */
  addressPoolId?: string;
  requestSource?: string[];
  /**
   * @example
   * 1
   */
  serialNumber?: number;
  /**
   * @example
   * 1
   */
  weightValue?: number;
  static names(): { [key: string]: string } {
    return {
      addressPoolId: 'AddressPoolId',
      requestSource: 'RequestSource',
      serialNumber: 'SerialNumber',
      weightValue: 'WeightValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addressPoolId: 'string',
      requestSource: { 'type': 'array', 'itemType': 'string' },
      serialNumber: 'number',
      weightValue: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressHealthTasksHealthTask extends $tea.Model {
  /**
   * @example
   * 80
   */
  port?: number;
  /**
   * @example
   * mtp-89518052425100**80
   */
  templateId?: string;
  /**
   * @example
   * IPv4-Ping
   */
  templateName?: string;
  static names(): { [key: string]: string } {
    return {
      port: 'Port',
      templateId: 'TemplateId',
      templateName: 'TemplateName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      port: 'number',
      templateId: 'string',
      templateName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressHealthTasks extends $tea.Model {
  healthTask?: SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressHealthTasksHealthTask[];
  static names(): { [key: string]: string } {
    return {
      healthTask: 'HealthTask',
    };
  }

  static types(): { [key: string]: any } {
    return {
      healthTask: { 'type': 'array', 'itemType': SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressHealthTasksHealthTask },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddress extends $tea.Model {
  /**
   * @example
   * 223.5.XX.XX
   */
  address?: string;
  /**
   * @example
   * addr-895182181143688192
   */
  addressId?: string;
  attributeInfo?: string;
  /**
   * @example
   * auto
   */
  availableMode?: string;
  /**
   * @example
   * available
   */
  availableStatus?: string;
  /**
   * @example
   * 2024-03-15T01:46Z
   */
  createTime?: string;
  /**
   * @example
   * 1527690629357
   */
  createTimestamp?: number;
  /**
   * @example
   * enable
   */
  enableStatus?: string;
  /**
   * @example
   * any_ok
   */
  healthJudgement?: string;
  /**
   * @example
   * ok
   */
  healthStatus?: string;
  healthTasks?: SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressHealthTasks;
  /**
   * @example
   * available
   */
  manualAvailableStatus?: string;
  /**
   * @example
   * Address-1
   */
  name?: string;
  /**
   * @example
   * test
   */
  remark?: string;
  /**
   * @example
   * default
   */
  requestSource?: string;
  /**
   * @example
   * 1
   */
  serialNumber?: number;
  /**
   * @example
   * IPv4
   */
  type?: string;
  /**
   * @example
   * 2024-03-15T01:46Z
   */
  updateTime?: string;
  /**
   * @example
   * 1527690629357
   */
  updateTimestamp?: number;
  /**
   * @example
   * 1
   */
  weightValue?: number;
  static names(): { [key: string]: string } {
    return {
      address: 'Address',
      addressId: 'AddressId',
      attributeInfo: 'AttributeInfo',
      availableMode: 'AvailableMode',
      availableStatus: 'AvailableStatus',
      createTime: 'CreateTime',
      createTimestamp: 'CreateTimestamp',
      enableStatus: 'EnableStatus',
      healthJudgement: 'HealthJudgement',
      healthStatus: 'HealthStatus',
      healthTasks: 'HealthTasks',
      manualAvailableStatus: 'ManualAvailableStatus',
      name: 'Name',
      remark: 'Remark',
      requestSource: 'RequestSource',
      serialNumber: 'SerialNumber',
      type: 'Type',
      updateTime: 'UpdateTime',
      updateTimestamp: 'UpdateTimestamp',
      weightValue: 'WeightValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      address: 'string',
      addressId: 'string',
      attributeInfo: 'string',
      availableMode: 'string',
      availableStatus: 'string',
      createTime: 'string',
      createTimestamp: 'number',
      enableStatus: 'string',
      healthJudgement: 'string',
      healthStatus: 'string',
      healthTasks: SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddressHealthTasks,
      manualAvailableStatus: 'string',
      name: 'string',
      remark: 'string',
      requestSource: 'string',
      serialNumber: 'number',
      type: 'string',
      updateTime: 'string',
      updateTimestamp: 'number',
      weightValue: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddresses extends $tea.Model {
  address?: SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddress[];
  static names(): { [key: string]: string } {
    return {
      address: 'Address',
    };
  }

  static types(): { [key: string]: any } {
    return {
      address: { 'type': 'array', 'itemType': SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddressesAddress },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPool extends $tea.Model {
  /**
   * @example
   * round_robin
   */
  addressLbStrategy?: string;
  /**
   * @example
   * pool-895280232254422016
   */
  addressPoolId?: string;
  /**
   * @example
   * AddressPool-1
   */
  addressPoolName?: string;
  /**
   * @example
   * IPv4
   */
  addressPoolType?: string;
  addresses?: SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddresses;
  /**
   * @example
   * available
   */
  availableStatus?: string;
  /**
   * @example
   * 2024-03-15T01:46Z
   */
  createTime?: string;
  /**
   * @example
   * 1527690629357
   */
  createTimestamp?: number;
  /**
   * @example
   * enable
   */
  enableStatus?: string;
  /**
   * @example
   * any_ok
   */
  healthJudgement?: string;
  /**
   * @example
   * ok
   */
  healthStatus?: string;
  /**
   * @example
   * test
   */
  remark?: string;
  /**
   * @example
   * preemptive
   */
  sequenceLbStrategyMode?: string;
  /**
   * @example
   * 024-03-15T01:46Z
   */
  updateTime?: string;
  /**
   * @example
   * 1527690629357
   */
  updateTimestamp?: number;
  static names(): { [key: string]: string } {
    return {
      addressLbStrategy: 'AddressLbStrategy',
      addressPoolId: 'AddressPoolId',
      addressPoolName: 'AddressPoolName',
      addressPoolType: 'AddressPoolType',
      addresses: 'Addresses',
      availableStatus: 'AvailableStatus',
      createTime: 'CreateTime',
      createTimestamp: 'CreateTimestamp',
      enableStatus: 'EnableStatus',
      healthJudgement: 'HealthJudgement',
      healthStatus: 'HealthStatus',
      remark: 'Remark',
      sequenceLbStrategyMode: 'SequenceLbStrategyMode',
      updateTime: 'UpdateTime',
      updateTimestamp: 'UpdateTimestamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addressLbStrategy: 'string',
      addressPoolId: 'string',
      addressPoolName: 'string',
      addressPoolType: 'string',
      addresses: SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPoolAddresses,
      availableStatus: 'string',
      createTime: 'string',
      createTimestamp: 'number',
      enableStatus: 'string',
      healthJudgement: 'string',
      healthStatus: 'string',
      remark: 'string',
      sequenceLbStrategyMode: 'string',
      updateTime: 'string',
      updateTimestamp: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchCloudGtmAddressPoolsResponseBodyAddressPools extends $tea.Model {
  addressPool?: SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPool[];
  static names(): { [key: string]: string } {
    return {
      addressPool: 'AddressPool',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addressPool: { 'type': 'array', 'itemType': SearchCloudGtmAddressPoolsResponseBodyAddressPoolsAddressPool },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchCloudGtmAddressesResponseBodyAddressesAddressHealthTasksHealthTask extends $tea.Model {
  /**
   * @example
   * ok
   */
  monitorStatus?: string;
  /**
   * @example
   * 80
   */
  port?: number;
  /**
   * @example
   * mtp-895180524251002880
   */
  templateId?: string;
  /**
   * @example
   * IPv4-Ping
   */
  templateName?: string;
  static names(): { [key: string]: string } {
    return {
      monitorStatus: 'MonitorStatus',
      port: 'Port',
      templateId: 'TemplateId',
      templateName: 'TemplateName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      monitorStatus: 'string',
      port: 'number',
      templateId: 'string',
      templateName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchCloudGtmAddressesResponseBodyAddressesAddressHealthTasks extends $tea.Model {
  healthTask?: SearchCloudGtmAddressesResponseBodyAddressesAddressHealthTasksHealthTask[];
  static names(): { [key: string]: string } {
    return {
      healthTask: 'HealthTask',
    };
  }

  static types(): { [key: string]: any } {
    return {
      healthTask: { 'type': 'array', 'itemType': SearchCloudGtmAddressesResponseBodyAddressesAddressHealthTasksHealthTask },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchCloudGtmAddressesResponseBodyAddressesAddress extends $tea.Model {
  /**
   * @example
   * 223.5.XX.XX
   */
  address?: string;
  /**
   * @example
   * addr-89518218114368**92
   */
  addressId?: string;
  attributeInfo?: string;
  /**
   * @example
   * auto
   */
  availableMode?: string;
  /**
   * @example
   * available
   */
  availableStatus?: string;
  /**
   * @example
   * 2024-03-23T13:09Z
   */
  createTime?: string;
  /**
   * @example
   * 1527690629357
   */
  createTimestamp?: number;
  /**
   * @example
   * enable
   */
  enableStatus?: string;
  /**
   * @example
   * p50_ok
   */
  healthJudgement?: string;
  /**
   * @example
   * ok
   */
  healthStatus?: string;
  healthTasks?: SearchCloudGtmAddressesResponseBodyAddressesAddressHealthTasks;
  /**
   * @example
   * available
   */
  manualAvailableStatus?: string;
  /**
   * @example
   * Address-1
   */
  name?: string;
  /**
   * @example
   * test
   */
  remark?: string;
  /**
   * @example
   * IPv4
   */
  type?: string;
  /**
   * @example
   * 2024-03-29T13:20Z
   */
  updateTime?: string;
  /**
   * @example
   * 1527690629357
   */
  updateTimestamp?: number;
  static names(): { [key: string]: string } {
    return {
      address: 'Address',
      addressId: 'AddressId',
      attributeInfo: 'AttributeInfo',
      availableMode: 'AvailableMode',
      availableStatus: 'AvailableStatus',
      createTime: 'CreateTime',
      createTimestamp: 'CreateTimestamp',
      enableStatus: 'EnableStatus',
      healthJudgement: 'HealthJudgement',
      healthStatus: 'HealthStatus',
      healthTasks: 'HealthTasks',
      manualAvailableStatus: 'ManualAvailableStatus',
      name: 'Name',
      remark: 'Remark',
      type: 'Type',
      updateTime: 'UpdateTime',
      updateTimestamp: 'UpdateTimestamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      address: 'string',
      addressId: 'string',
      attributeInfo: 'string',
      availableMode: 'string',
      availableStatus: 'string',
      createTime: 'string',
      createTimestamp: 'number',
      enableStatus: 'string',
      healthJudgement: 'string',
      healthStatus: 'string',
      healthTasks: SearchCloudGtmAddressesResponseBodyAddressesAddressHealthTasks,
      manualAvailableStatus: 'string',
      name: 'string',
      remark: 'string',
      type: 'string',
      updateTime: 'string',
      updateTimestamp: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchCloudGtmAddressesResponseBodyAddresses extends $tea.Model {
  address?: SearchCloudGtmAddressesResponseBodyAddressesAddress[];
  static names(): { [key: string]: string } {
    return {
      address: 'Address',
    };
  }

  static types(): { [key: string]: any } {
    return {
      address: { 'type': 'array', 'itemType': SearchCloudGtmAddressesResponseBodyAddressesAddress },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPoolsAddressPoolRequestSource extends $tea.Model {
  requestSource?: string[];
  static names(): { [key: string]: string } {
    return {
      requestSource: 'RequestSource',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestSource: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPoolsAddressPool extends $tea.Model {
  /**
   * @example
   * round_robin
   */
  addressLbStrategy?: string;
  /**
   * @example
   * pool-89564504435014**60
   */
  addressPoolId?: string;
  /**
   * @example
   * AddressPool-1
   */
  addressPoolName?: string;
  /**
   * @example
   * IPv4
   */
  addressPoolType?: string;
  /**
   * @example
   * available
   */
  availableStatus?: string;
  /**
   * @example
   * 2024-03-15T01:46Z
   */
  createTime?: string;
  /**
   * @example
   * 1527690629357
   */
  createTimestamp?: number;
  /**
   * @example
   * enable
   */
  enableStatus?: string;
  /**
   * @example
   * any_ok
   */
  healthJudgement?: string;
  /**
   * @example
   * ok
   */
  healthStatus?: string;
  requestSource?: SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPoolsAddressPoolRequestSource;
  /**
   * @example
   * false
   */
  seqNonPreemptiveSchedule?: boolean;
  /**
   * @example
   * preemptive
   */
  sequenceLbStrategyMode?: string;
  /**
   * @example
   * 1
   */
  serialNumber?: number;
  /**
   * @example
   * 2024-03-15T01:46Z
   */
  updateTime?: string;
  /**
   * @example
   * 1527690629357
   */
  updateTimestamp?: number;
  /**
   * @example
   * 1
   */
  weightValue?: number;
  static names(): { [key: string]: string } {
    return {
      addressLbStrategy: 'AddressLbStrategy',
      addressPoolId: 'AddressPoolId',
      addressPoolName: 'AddressPoolName',
      addressPoolType: 'AddressPoolType',
      availableStatus: 'AvailableStatus',
      createTime: 'CreateTime',
      createTimestamp: 'CreateTimestamp',
      enableStatus: 'EnableStatus',
      healthJudgement: 'HealthJudgement',
      healthStatus: 'HealthStatus',
      requestSource: 'RequestSource',
      seqNonPreemptiveSchedule: 'SeqNonPreemptiveSchedule',
      sequenceLbStrategyMode: 'SequenceLbStrategyMode',
      serialNumber: 'SerialNumber',
      updateTime: 'UpdateTime',
      updateTimestamp: 'UpdateTimestamp',
      weightValue: 'WeightValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addressLbStrategy: 'string',
      addressPoolId: 'string',
      addressPoolName: 'string',
      addressPoolType: 'string',
      availableStatus: 'string',
      createTime: 'string',
      createTimestamp: 'number',
      enableStatus: 'string',
      healthJudgement: 'string',
      healthStatus: 'string',
      requestSource: SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPoolsAddressPoolRequestSource,
      seqNonPreemptiveSchedule: 'boolean',
      sequenceLbStrategyMode: 'string',
      serialNumber: 'number',
      updateTime: 'string',
      updateTimestamp: 'number',
      weightValue: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPools extends $tea.Model {
  addressPool?: SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPoolsAddressPool[];
  static names(): { [key: string]: string } {
    return {
      addressPool: 'AddressPool',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addressPool: { 'type': 'array', 'itemType': SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPoolsAddressPool },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfig extends $tea.Model {
  /**
   * @example
   * round_robin
   */
  addressPoolLbStrategy?: string;
  addressPools?: SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPools;
  /**
   * @example
   * available
   */
  availableStatus?: string;
  /**
   * @example
   * dns_gtm_public_cn
   */
  commodityCode?: string;
  /**
   * @example
   * Config-000**11
   */
  configId?: string;
  /**
   * @example
   * 2024-03-15T01:46Z
   */
  createTime?: string;
  /**
   * @example
   * 1527690629357
   */
  createTimestamp?: number;
  /**
   * @example
   * enable
   */
  enableStatus?: string;
  /**
   * @example
   * ok
   */
  healthStatus?: string;
  /**
   * @example
   * gtm-cn-x0r38e0**03
   */
  instanceId?: string;
  /**
   * @example
   * test
   */
  remark?: string;
  /**
   * @example
   * www.example.com
   */
  scheduleDomainName?: string;
  /**
   * @example
   * www
   */
  scheduleHostname?: string;
  /**
   * @example
   * A
   */
  scheduleRrType?: string;
  /**
   * @example
   * custom
   */
  scheduleZoneMode?: string;
  /**
   * @example
   * example.com
   */
  scheduleZoneName?: string;
  /**
   * @example
   * preemptive
   */
  sequenceLbStrategyMode?: string;
  /**
   * @example
   * 60
   */
  ttl?: number;
  /**
   * @example
   * 2024-03-15T01:46Z
   */
  updateTime?: string;
  /**
   * @example
   * 1527690629357
   */
  updateTimestamp?: number;
  /**
   * @example
   * ultimate
   */
  versionCode?: string;
  static names(): { [key: string]: string } {
    return {
      addressPoolLbStrategy: 'AddressPoolLbStrategy',
      addressPools: 'AddressPools',
      availableStatus: 'AvailableStatus',
      commodityCode: 'CommodityCode',
      configId: 'ConfigId',
      createTime: 'CreateTime',
      createTimestamp: 'CreateTimestamp',
      enableStatus: 'EnableStatus',
      healthStatus: 'HealthStatus',
      instanceId: 'InstanceId',
      remark: 'Remark',
      scheduleDomainName: 'ScheduleDomainName',
      scheduleHostname: 'ScheduleHostname',
      scheduleRrType: 'ScheduleRrType',
      scheduleZoneMode: 'ScheduleZoneMode',
      scheduleZoneName: 'ScheduleZoneName',
      sequenceLbStrategyMode: 'SequenceLbStrategyMode',
      ttl: 'Ttl',
      updateTime: 'UpdateTime',
      updateTimestamp: 'UpdateTimestamp',
      versionCode: 'VersionCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addressPoolLbStrategy: 'string',
      addressPools: SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfigAddressPools,
      availableStatus: 'string',
      commodityCode: 'string',
      configId: 'string',
      createTime: 'string',
      createTimestamp: 'number',
      enableStatus: 'string',
      healthStatus: 'string',
      instanceId: 'string',
      remark: 'string',
      scheduleDomainName: 'string',
      scheduleHostname: 'string',
      scheduleRrType: 'string',
      scheduleZoneMode: 'string',
      scheduleZoneName: 'string',
      sequenceLbStrategyMode: 'string',
      ttl: 'number',
      updateTime: 'string',
      updateTimestamp: 'number',
      versionCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigs extends $tea.Model {
  instanceConfig?: SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfig[];
  static names(): { [key: string]: string } {
    return {
      instanceConfig: 'InstanceConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceConfig: { 'type': 'array', 'itemType': SearchCloudGtmInstanceConfigsResponseBodyInstanceConfigsInstanceConfig },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchCloudGtmInstancesResponseBodyInstancesInstance extends $tea.Model {
  /**
   * @example
   * dns_gtm_public_cn
   */
  commodityCode?: string;
  /**
   * @example
   * 2024-03-15T01:46Z
   */
  createTime?: string;
  /**
   * @example
   * 1710467214858
   */
  createTimestamp?: number;
  /**
   * @example
   * 2024-09-05T16:00Z
   */
  expireTime?: number;
  /**
   * @example
   * 1725552000000
   */
  expireTimestamp?: string;
  /**
   * @example
   * gtm-cn-wwo3a3hbz**
   */
  instanceId?: string;
  /**
   * @example
   * test
   */
  instanceName?: string;
  /**
   * @example
   * 100
   */
  monitorTaskQuota?: number;
  /**
   * @example
   * 200
   */
  monthlyEmailUsed?: number;
  /**
   * @example
   * 2000
   */
  monthlySmsQuota?: number;
  /**
   * @example
   * 200
   */
  monthlySmsUsed?: number;
  /**
   * @example
   * 100
   */
  monthlyWebhookUsed?: number;
  /**
   * @example
   * www.example.com
   */
  scheduleDomainName?: string;
  /**
   * @example
   * 2024-03-15T01:46Z
   */
  updateTime?: string;
  /**
   * @example
   * 1710467214858
   */
  updateTimestamp?: number;
  /**
   * @example
   * ultimate
   */
  versionCode?: string;
  static names(): { [key: string]: string } {
    return {
      commodityCode: 'CommodityCode',
      createTime: 'CreateTime',
      createTimestamp: 'CreateTimestamp',
      expireTime: 'ExpireTime',
      expireTimestamp: 'ExpireTimestamp',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      monitorTaskQuota: 'MonitorTaskQuota',
      monthlyEmailUsed: 'MonthlyEmailUsed',
      monthlySmsQuota: 'MonthlySmsQuota',
      monthlySmsUsed: 'MonthlySmsUsed',
      monthlyWebhookUsed: 'MonthlyWebhookUsed',
      scheduleDomainName: 'ScheduleDomainName',
      updateTime: 'UpdateTime',
      updateTimestamp: 'UpdateTimestamp',
      versionCode: 'VersionCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commodityCode: 'string',
      createTime: 'string',
      createTimestamp: 'number',
      expireTime: 'number',
      expireTimestamp: 'string',
      instanceId: 'string',
      instanceName: 'string',
      monitorTaskQuota: 'number',
      monthlyEmailUsed: 'number',
      monthlySmsQuota: 'number',
      monthlySmsUsed: 'number',
      monthlyWebhookUsed: 'number',
      scheduleDomainName: 'string',
      updateTime: 'string',
      updateTimestamp: 'number',
      versionCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchCloudGtmInstancesResponseBodyInstances extends $tea.Model {
  instance?: SearchCloudGtmInstancesResponseBodyInstancesInstance[];
  static names(): { [key: string]: string } {
    return {
      instance: 'Instance',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instance: { 'type': 'array', 'itemType': SearchCloudGtmInstancesResponseBodyInstancesInstance },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchCloudGtmMonitorTemplatesResponseBodyTemplatesTemplateIspCityNodesIspCityNode extends $tea.Model {
  /**
   * @example
   * 503
   */
  cityCode?: string;
  cityName?: string;
  /**
   * @example
   * 001
   */
  countryCode?: string;
  countryName?: string;
  /**
   * @example
   * BGP
   */
  groupName?: string;
  /**
   * @example
   * BGP
   */
  groupType?: string;
  /**
   * @example
   * 465
   */
  ispCode?: string;
  ispName?: string;
  static names(): { [key: string]: string } {
    return {
      cityCode: 'CityCode',
      cityName: 'CityName',
      countryCode: 'CountryCode',
      countryName: 'CountryName',
      groupName: 'GroupName',
      groupType: 'GroupType',
      ispCode: 'IspCode',
      ispName: 'IspName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cityCode: 'string',
      cityName: 'string',
      countryCode: 'string',
      countryName: 'string',
      groupName: 'string',
      groupType: 'string',
      ispCode: 'string',
      ispName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchCloudGtmMonitorTemplatesResponseBodyTemplatesTemplateIspCityNodes extends $tea.Model {
  ispCityNode?: SearchCloudGtmMonitorTemplatesResponseBodyTemplatesTemplateIspCityNodesIspCityNode[];
  static names(): { [key: string]: string } {
    return {
      ispCityNode: 'IspCityNode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ispCityNode: { 'type': 'array', 'itemType': SearchCloudGtmMonitorTemplatesResponseBodyTemplatesTemplateIspCityNodesIspCityNode },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchCloudGtmMonitorTemplatesResponseBodyTemplatesTemplate extends $tea.Model {
  /**
   * @example
   * 2024-03-23T13:09Z
   */
  createTime?: string;
  /**
   * @example
   * 1527690629357
   */
  createTimestamp?: number;
  /**
   * @example
   * 2
   */
  evaluationCount?: number;
  /**
   * @example
   * {\\"code\\":200,\\"path\\":\\"\\\\index.htm\\",\\"host\\":\\"aliyun.com\\"}
   */
  extendInfo?: string;
  /**
   * @example
   * 50
   */
  failureRate?: number;
  /**
   * @example
   * 60
   */
  interval?: number;
  /**
   * @example
   * IPv4
   */
  ipVersion?: string;
  ispCityNodes?: SearchCloudGtmMonitorTemplatesResponseBodyTemplatesTemplateIspCityNodes;
  /**
   * @example
   * IPv4-Ping
   */
  name?: string;
  /**
   * @example
   * ping
   */
  protocol?: string;
  /**
   * @example
   * test
   */
  remark?: string;
  /**
   * @example
   * mtp-89518052425100**80
   */
  templateId?: string;
  /**
   * @example
   * 5000
   */
  timeout?: number;
  /**
   * @example
   * 2024-03-29T13:20Z
   */
  updateTime?: string;
  /**
   * @example
   * 1527690629357
   */
  updateTimestamp?: number;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      createTimestamp: 'CreateTimestamp',
      evaluationCount: 'EvaluationCount',
      extendInfo: 'ExtendInfo',
      failureRate: 'FailureRate',
      interval: 'Interval',
      ipVersion: 'IpVersion',
      ispCityNodes: 'IspCityNodes',
      name: 'Name',
      protocol: 'Protocol',
      remark: 'Remark',
      templateId: 'TemplateId',
      timeout: 'Timeout',
      updateTime: 'UpdateTime',
      updateTimestamp: 'UpdateTimestamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'string',
      createTimestamp: 'number',
      evaluationCount: 'number',
      extendInfo: 'string',
      failureRate: 'number',
      interval: 'number',
      ipVersion: 'string',
      ispCityNodes: SearchCloudGtmMonitorTemplatesResponseBodyTemplatesTemplateIspCityNodes,
      name: 'string',
      protocol: 'string',
      remark: 'string',
      templateId: 'string',
      timeout: 'number',
      updateTime: 'string',
      updateTimestamp: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchCloudGtmMonitorTemplatesResponseBodyTemplates extends $tea.Model {
  template?: SearchCloudGtmMonitorTemplatesResponseBodyTemplatesTemplate[];
  static names(): { [key: string]: string } {
    return {
      template: 'Template',
    };
  }

  static types(): { [key: string]: any } {
    return {
      template: { 'type': 'array', 'itemType': SearchCloudGtmMonitorTemplatesResponseBodyTemplatesTemplate },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TagResourcesRequestTag extends $tea.Model {
  /**
   * @remarks
   * The key of tag N to add to the resource. The tag key can be up to 20 characters in length and cannot start with acs: or aliyun.
   * 
   * @example
   * abcd
   */
  key?: string;
  /**
   * @remarks
   * The value of tag N to add to the resource. The tag value can be up to 20 characters in length.
   * 
   * @example
   * abcd
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCloudGtmAddressRequestHealthTasks extends $tea.Model {
  /**
   * @example
   * 80
   */
  port?: number;
  /**
   * @example
   * mtp-89518052425100**80
   */
  templateId?: string;
  static names(): { [key: string]: string } {
    return {
      port: 'Port',
      templateId: 'TemplateId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      port: 'number',
      templateId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCloudGtmGlobalAlertRequestAlertConfig extends $tea.Model {
  /**
   * @example
   * false
   */
  dingtalkNotice?: boolean;
  /**
   * @example
   * true
   */
  emailNotice?: boolean;
  /**
   * @example
   * addr_alert
   */
  noticeType?: string;
  /**
   * @example
   * true
   */
  smsNotice?: boolean;
  static names(): { [key: string]: string } {
    return {
      dingtalkNotice: 'DingtalkNotice',
      emailNotice: 'EmailNotice',
      noticeType: 'NoticeType',
      smsNotice: 'SmsNotice',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dingtalkNotice: 'boolean',
      emailNotice: 'boolean',
      noticeType: 'string',
      smsNotice: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCloudGtmInstanceConfigAlertRequestAlertConfig extends $tea.Model {
  /**
   * @remarks
   * Specifies whether to configure DingTalk notifications. Valid values:
   * 
   * *   true: DingTalk notifications are configured. DingTalk notifications are sent when alerts are triggered.
   * *   false: DingTalk notifications are not configured.
   * 
   * @example
   * true
   */
  dingtalkNotice?: boolean;
  /**
   * @remarks
   * Specifies whether to configure email notifications. Valid values:
   * 
   * *   true: Email notifications are configured. Emails are sent when alerts are triggered.
   * *   false: Email notifications are not configured.
   * 
   * @example
   * true
   */
  emailNotice?: boolean;
  /**
   * @remarks
   * The type of the alert event. Valid values:
   * 
   * *   addr_alert: The address is unavailable.
   * *   addr_resume: The address becomes available.
   * *   addr_pool_unavailable: The address pool is unavailable.
   * *   addr_pool_available: The address pool becomes available.
   * 
   * @example
   * addr_alert
   */
  noticeType?: string;
  /**
   * @remarks
   * Specifies whether to configure text message notifications. Valid values:
   * 
   * *   true: Text message notifications are configured. Text messages are sent when alerts are triggered.
   * *   false: Text message notifications are not configured.
   * 
   * Only the China site (aliyun.com) supports text message notifications.
   * 
   * @example
   * true
   */
  smsNotice?: boolean;
  static names(): { [key: string]: string } {
    return {
      dingtalkNotice: 'DingtalkNotice',
      emailNotice: 'EmailNotice',
      noticeType: 'NoticeType',
      smsNotice: 'SmsNotice',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dingtalkNotice: 'boolean',
      emailNotice: 'boolean',
      noticeType: 'string',
      smsNotice: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCloudGtmMonitorTemplateRequestIspCityNodes extends $tea.Model {
  /**
   * @example
   * 503
   */
  cityCode?: string;
  /**
   * @example
   * 465
   */
  ispCode?: string;
  static names(): { [key: string]: string } {
    return {
      cityCode: 'CityCode',
      ispCode: 'IspCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cityCode: 'string',
      ispCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCustomLineRequestIpSegment extends $tea.Model {
  /**
   * @remarks
   * The end IP address of the CIDR block.
   * 
   * @example
   * 2.2.2.2
   */
  endIp?: string;
  /**
   * @remarks
   * The start IP address of the CIDR block.
   * 
   * @example
   * 1.1.1.1
   */
  startIp?: string;
  static names(): { [key: string]: string } {
    return {
      endIp: 'EndIp',
      startIp: 'StartIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endIp: 'string',
      startIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDnsCacheDomainRequestSourceDnsServer extends $tea.Model {
  /**
   * @remarks
   * The domain name or IP address of the origin DNS server.
   * 
   * @example
   * 223.5.5.5
   */
  host?: string;
  /**
   * @remarks
   * The port of the origin DNS server.
   * 
   * @example
   * 53
   */
  port?: string;
  static names(): { [key: string]: string } {
    return {
      host: 'Host',
      port: 'Port',
    };
  }

  static types(): { [key: string]: any } {
    return {
      host: 'string',
      port: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDnsGtmAccessStrategyRequestDefaultAddrPool extends $tea.Model {
  /**
   * @remarks
   * The ID of the address pool in the primary address pool set.
   * 
   * @example
   * pool1
   */
  id?: string;
  /**
   * @remarks
   * The weight of the address pool in the primary address pool set.
   * 
   * @example
   * 1
   */
  lbaWeight?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      lbaWeight: 'LbaWeight',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      lbaWeight: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDnsGtmAccessStrategyRequestFailoverAddrPool extends $tea.Model {
  /**
   * @remarks
   * The ID of the address pool in the secondary address pool set.
   * 
   * @example
   * pool1
   */
  id?: string;
  /**
   * @remarks
   * The weight of the address pool in the secondary address pool set.
   * 
   * @example
   * 1
   */
  lbaWeight?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      lbaWeight: 'LbaWeight',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      lbaWeight: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDnsGtmAddressPoolRequestAddr extends $tea.Model {
  /**
   * @remarks
   * The address in the address pool.
   * 
   * This parameter is required.
   * 
   * @example
   * 1.1.1.1
   */
  addr?: string;
  /**
   * @remarks
   * The source region of the address, in JSON-formatted string.
   * 
   * *   LineCode: the line code of the source region of the address. The LineCode field is deprecated, and the lineCodes field is used as a substitute.
   * 
   * *   LineCodes: the line code list of the source regions of addresses.
   * 
   * *   lineCodeRectifyType: the rectification type of the line codes. Default value: AUTO. Valid values:
   * 
   *     *   NO_NEED: no need for rectification.
   *     *   RECTIFIED: rectified.
   *     *   AUTO: automatic rectification.
   * 
   * @example
   * Linecode:default,lineCodes:["default"],lineCodeRectifyType:"NO_NEED"
   */
  attributeInfo?: string;
  /**
   * @remarks
   * The weight of the address.
   * 
   * @example
   * 1
   */
  lbaWeight?: number;
  /**
   * @remarks
   * The response mode: Valid values:
   * 
   * *   SMART: smart return.
   * *   ONLINE: always online.
   * *   OFFLINE: always offline.
   * 
   * This parameter is required.
   * 
   * @example
   * online
   */
  mode?: string;
  /**
   * @remarks
   * The additional information about the address.
   * 
   * @example
   * test
   */
  remark?: string;
  static names(): { [key: string]: string } {
    return {
      addr: 'Addr',
      attributeInfo: 'AttributeInfo',
      lbaWeight: 'LbaWeight',
      mode: 'Mode',
      remark: 'Remark',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addr: 'string',
      attributeInfo: 'string',
      lbaWeight: 'number',
      mode: 'string',
      remark: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDnsGtmInstanceGlobalConfigRequestAlertConfig extends $tea.Model {
  /**
   * @example
   * true
   */
  dingtalkNotice?: boolean;
  /**
   * @example
   * true
   */
  emailNotice?: boolean;
  /**
   * @example
   * ADDR_ALERT
   */
  noticeType?: string;
  /**
   * @example
   * true
   */
  smsNotice?: boolean;
  static names(): { [key: string]: string } {
    return {
      dingtalkNotice: 'DingtalkNotice',
      emailNotice: 'EmailNotice',
      noticeType: 'NoticeType',
      smsNotice: 'SmsNotice',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dingtalkNotice: 'boolean',
      emailNotice: 'boolean',
      noticeType: 'string',
      smsNotice: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDnsGtmMonitorRequestIspCityNode extends $tea.Model {
  /**
   * @remarks
   * The code of the city where the monitored node is deployed.
   * 
   * @example
   * 123
   */
  cityCode?: string;
  /**
   * @remarks
   * The code of the Internet service provider (ISP) to which the monitored node belongs.
   * 
   * @example
   * 123
   */
  ispCode?: string;
  static names(): { [key: string]: string } {
    return {
      cityCode: 'CityCode',
      ispCode: 'IspCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cityCode: 'string',
      ispCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGtmAddressPoolRequestAddr extends $tea.Model {
  /**
   * @remarks
   * The weight of the address pool that you want to modify.
   * 
   * @example
   * 1
   */
  lbaWeight?: number;
  /**
   * @remarks
   * The mode of the address pool that you want to modify.
   * 
   * *   **SMART**: Intelligent return
   * *   **ONLINE**: Always online
   * *   **OFFLINE**: Always offline
   * 
   * @example
   * SMART
   */
  mode?: string;
  /**
   * @remarks
   * The addresses in the address pool.
   * 
   * @example
   * 1.1.1.1
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      lbaWeight: 'LbaWeight',
      mode: 'Mode',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lbaWeight: 'number',
      mode: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGtmMonitorRequestIspCityNode extends $tea.Model {
  /**
   * @remarks
   * The code of the city where the monitored node is deployed.
   * 
   * @example
   * 572
   */
  cityCode?: string;
  /**
   * @remarks
   * *   The code of the Internet service provider (ISP) to which the monitored node belongs. For more information about specific values, see the response parameters of DescribeGtmMonitorAvailableConfig.
   * *   If the value of the GroupType parameter is BGP or OVERSEAS, IspCode is optional. The default value is 465.
   * *   If the value of the GroupType parameter is not BGP or OVERSEAS, IspCode is required and is used together with CityCode.
   * 
   * @example
   * 465
   */
  ispCode?: string;
  static names(): { [key: string]: string } {
    return {
      cityCode: 'CityCode',
      ispCode: 'IspCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cityCode: 'string',
      ispCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}


export default class Client extends OpenApi {

  constructor(config: $OpenApi.Config) {
    super(config);
    this._endpointRule = "central";
    this.checkConfig(config);
    this._endpoint = this.getEndpoint("alidns", this._regionId, this._endpointRule, this._network, this._suffix, this._endpointMap, this._endpoint);
  }


  getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: {[key: string ]: string}, endpoint: string): string {
    if (!Util.empty(endpoint)) {
      return endpoint;
    }

    if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
      return endpointMap[regionId];
    }

    return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
  }

  /**
   * Adds a custom line.
   * 
   * @remarks
   * In each CIDR block, the end IP address must be greater than or equal to the start IP address.\\
   * The CIDR blocks that are specified for all custom lines of a domain name cannot be overlapped.
   * 
   * @param request - AddCustomLineRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddCustomLineResponse
   */
  async addCustomLineWithOptions(request: AddCustomLineRequest, runtime: $Util.RuntimeOptions): Promise<AddCustomLineResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ipSegment)) {
      query["IpSegment"] = request.ipSegment;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.lineName)) {
      query["LineName"] = request.lineName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddCustomLine",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddCustomLineResponse>(await this.callApi(params, req, runtime), new AddCustomLineResponse({}));
  }

  /**
   * Adds a custom line.
   * 
   * @remarks
   * In each CIDR block, the end IP address must be greater than or equal to the start IP address.\\
   * The CIDR blocks that are specified for all custom lines of a domain name cannot be overlapped.
   * 
   * @param request - AddCustomLineRequest
   * @returns AddCustomLineResponse
   */
  async addCustomLine(request: AddCustomLineRequest): Promise<AddCustomLineResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addCustomLineWithOptions(request, runtime);
  }

  /**
   * @param request - AddDnsCacheDomainRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddDnsCacheDomainResponse
   */
  async addDnsCacheDomainWithOptions(request: AddDnsCacheDomainRequest, runtime: $Util.RuntimeOptions): Promise<AddDnsCacheDomainResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.cacheTtlMax)) {
      query["CacheTtlMax"] = request.cacheTtlMax;
    }

    if (!Util.isUnset(request.cacheTtlMin)) {
      query["CacheTtlMin"] = request.cacheTtlMin;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.remark)) {
      query["Remark"] = request.remark;
    }

    if (!Util.isUnset(request.sourceDnsServer)) {
      query["SourceDnsServer"] = request.sourceDnsServer;
    }

    if (!Util.isUnset(request.sourceEdns)) {
      query["SourceEdns"] = request.sourceEdns;
    }

    if (!Util.isUnset(request.sourceProtocol)) {
      query["SourceProtocol"] = request.sourceProtocol;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddDnsCacheDomain",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddDnsCacheDomainResponse>(await this.callApi(params, req, runtime), new AddDnsCacheDomainResponse({}));
  }

  /**
   * @param request - AddDnsCacheDomainRequest
   * @returns AddDnsCacheDomainResponse
   */
  async addDnsCacheDomain(request: AddDnsCacheDomainRequest): Promise<AddDnsCacheDomainResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addDnsCacheDomainWithOptions(request, runtime);
  }

  /**
   * Creates an access policy.
   * 
   * @param request - AddDnsGtmAccessStrategyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddDnsGtmAccessStrategyResponse
   */
  async addDnsGtmAccessStrategyWithOptions(request: AddDnsGtmAccessStrategyRequest, runtime: $Util.RuntimeOptions): Promise<AddDnsGtmAccessStrategyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.defaultAddrPool)) {
      query["DefaultAddrPool"] = request.defaultAddrPool;
    }

    if (!Util.isUnset(request.defaultAddrPoolType)) {
      query["DefaultAddrPoolType"] = request.defaultAddrPoolType;
    }

    if (!Util.isUnset(request.defaultLatencyOptimization)) {
      query["DefaultLatencyOptimization"] = request.defaultLatencyOptimization;
    }

    if (!Util.isUnset(request.defaultLbaStrategy)) {
      query["DefaultLbaStrategy"] = request.defaultLbaStrategy;
    }

    if (!Util.isUnset(request.defaultMaxReturnAddrNum)) {
      query["DefaultMaxReturnAddrNum"] = request.defaultMaxReturnAddrNum;
    }

    if (!Util.isUnset(request.defaultMinAvailableAddrNum)) {
      query["DefaultMinAvailableAddrNum"] = request.defaultMinAvailableAddrNum;
    }

    if (!Util.isUnset(request.failoverAddrPool)) {
      query["FailoverAddrPool"] = request.failoverAddrPool;
    }

    if (!Util.isUnset(request.failoverAddrPoolType)) {
      query["FailoverAddrPoolType"] = request.failoverAddrPoolType;
    }

    if (!Util.isUnset(request.failoverLatencyOptimization)) {
      query["FailoverLatencyOptimization"] = request.failoverLatencyOptimization;
    }

    if (!Util.isUnset(request.failoverLbaStrategy)) {
      query["FailoverLbaStrategy"] = request.failoverLbaStrategy;
    }

    if (!Util.isUnset(request.failoverMaxReturnAddrNum)) {
      query["FailoverMaxReturnAddrNum"] = request.failoverMaxReturnAddrNum;
    }

    if (!Util.isUnset(request.failoverMinAvailableAddrNum)) {
      query["FailoverMinAvailableAddrNum"] = request.failoverMinAvailableAddrNum;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.lines)) {
      query["Lines"] = request.lines;
    }

    if (!Util.isUnset(request.strategyMode)) {
      query["StrategyMode"] = request.strategyMode;
    }

    if (!Util.isUnset(request.strategyName)) {
      query["StrategyName"] = request.strategyName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddDnsGtmAccessStrategy",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddDnsGtmAccessStrategyResponse>(await this.callApi(params, req, runtime), new AddDnsGtmAccessStrategyResponse({}));
  }

  /**
   * Creates an access policy.
   * 
   * @param request - AddDnsGtmAccessStrategyRequest
   * @returns AddDnsGtmAccessStrategyResponse
   */
  async addDnsGtmAccessStrategy(request: AddDnsGtmAccessStrategyRequest): Promise<AddDnsGtmAccessStrategyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addDnsGtmAccessStrategyWithOptions(request, runtime);
  }

  /**
   * Creates an address pool.
   * 
   * @param request - AddDnsGtmAddressPoolRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddDnsGtmAddressPoolResponse
   */
  async addDnsGtmAddressPoolWithOptions(request: AddDnsGtmAddressPoolRequest, runtime: $Util.RuntimeOptions): Promise<AddDnsGtmAddressPoolResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.addr)) {
      query["Addr"] = request.addr;
    }

    if (!Util.isUnset(request.evaluationCount)) {
      query["EvaluationCount"] = request.evaluationCount;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.interval)) {
      query["Interval"] = request.interval;
    }

    if (!Util.isUnset(request.ispCityNode)) {
      query["IspCityNode"] = request.ispCityNode;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.lbaStrategy)) {
      query["LbaStrategy"] = request.lbaStrategy;
    }

    if (!Util.isUnset(request.monitorExtendInfo)) {
      query["MonitorExtendInfo"] = request.monitorExtendInfo;
    }

    if (!Util.isUnset(request.monitorStatus)) {
      query["MonitorStatus"] = request.monitorStatus;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.protocolType)) {
      query["ProtocolType"] = request.protocolType;
    }

    if (!Util.isUnset(request.timeout)) {
      query["Timeout"] = request.timeout;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddDnsGtmAddressPool",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddDnsGtmAddressPoolResponse>(await this.callApi(params, req, runtime), new AddDnsGtmAddressPoolResponse({}));
  }

  /**
   * Creates an address pool.
   * 
   * @param request - AddDnsGtmAddressPoolRequest
   * @returns AddDnsGtmAddressPoolResponse
   */
  async addDnsGtmAddressPool(request: AddDnsGtmAddressPoolRequest): Promise<AddDnsGtmAddressPoolResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addDnsGtmAddressPoolWithOptions(request, runtime);
  }

  /**
   * Creates a health check task.
   * 
   * @remarks
   * **
   * 
   * @param request - AddDnsGtmMonitorRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddDnsGtmMonitorResponse
   */
  async addDnsGtmMonitorWithOptions(request: AddDnsGtmMonitorRequest, runtime: $Util.RuntimeOptions): Promise<AddDnsGtmMonitorResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.addrPoolId)) {
      query["AddrPoolId"] = request.addrPoolId;
    }

    if (!Util.isUnset(request.evaluationCount)) {
      query["EvaluationCount"] = request.evaluationCount;
    }

    if (!Util.isUnset(request.interval)) {
      query["Interval"] = request.interval;
    }

    if (!Util.isUnset(request.ispCityNode)) {
      query["IspCityNode"] = request.ispCityNode;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.monitorExtendInfo)) {
      query["MonitorExtendInfo"] = request.monitorExtendInfo;
    }

    if (!Util.isUnset(request.protocolType)) {
      query["ProtocolType"] = request.protocolType;
    }

    if (!Util.isUnset(request.timeout)) {
      query["Timeout"] = request.timeout;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddDnsGtmMonitor",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddDnsGtmMonitorResponse>(await this.callApi(params, req, runtime), new AddDnsGtmMonitorResponse({}));
  }

  /**
   * Creates a health check task.
   * 
   * @remarks
   * **
   * 
   * @param request - AddDnsGtmMonitorRequest
   * @returns AddDnsGtmMonitorResponse
   */
  async addDnsGtmMonitor(request: AddDnsGtmMonitorRequest): Promise<AddDnsGtmMonitorResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addDnsGtmMonitorWithOptions(request, runtime);
  }

  /**
   * Adds a domain name based on the specified parameters.
   * 
   * @remarks
   * For more information about how to check whether a domain name is valid, see
   * [Domain name validity](https://www.alibabacloud.com/help/zh/doc-detail/67788.htm).
   * 
   * @param request - AddDomainRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddDomainResponse
   */
  async addDomainWithOptions(request: AddDomainRequest, runtime: $Util.RuntimeOptions): Promise<AddDomainResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddDomain",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddDomainResponse>(await this.callApi(params, req, runtime), new AddDomainResponse({}));
  }

  /**
   * Adds a domain name based on the specified parameters.
   * 
   * @remarks
   * For more information about how to check whether a domain name is valid, see
   * [Domain name validity](https://www.alibabacloud.com/help/zh/doc-detail/67788.htm).
   * 
   * @param request - AddDomainRequest
   * @returns AddDomainResponse
   */
  async addDomain(request: AddDomainRequest): Promise<AddDomainResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addDomainWithOptions(request, runtime);
  }

  /**
   * Creates a backup task for a domain name.
   * 
   * @param request - AddDomainBackupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddDomainBackupResponse
   */
  async addDomainBackupWithOptions(request: AddDomainBackupRequest, runtime: $Util.RuntimeOptions): Promise<AddDomainBackupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.periodType)) {
      query["PeriodType"] = request.periodType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddDomainBackup",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddDomainBackupResponse>(await this.callApi(params, req, runtime), new AddDomainBackupResponse({}));
  }

  /**
   * Creates a backup task for a domain name.
   * 
   * @param request - AddDomainBackupRequest
   * @returns AddDomainBackupResponse
   */
  async addDomainBackup(request: AddDomainBackupRequest): Promise<AddDomainBackupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addDomainBackupWithOptions(request, runtime);
  }

  /**
   * Creates a domain name group based on the specified parameters.
   * 
   * @param request - AddDomainGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddDomainGroupResponse
   */
  async addDomainGroupWithOptions(request: AddDomainGroupRequest, runtime: $Util.RuntimeOptions): Promise<AddDomainGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupName)) {
      query["GroupName"] = request.groupName;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddDomainGroup",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddDomainGroupResponse>(await this.callApi(params, req, runtime), new AddDomainGroupResponse({}));
  }

  /**
   * Creates a domain name group based on the specified parameters.
   * 
   * @param request - AddDomainGroupRequest
   * @returns AddDomainGroupResponse
   */
  async addDomainGroup(request: AddDomainGroupRequest): Promise<AddDomainGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addDomainGroupWithOptions(request, runtime);
  }

  /**
   * Adds a Domain Name System (DNS) record based on the specified parameters.
   * 
   * @param request - AddDomainRecordRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddDomainRecordResponse
   */
  async addDomainRecordWithOptions(request: AddDomainRecordRequest, runtime: $Util.RuntimeOptions): Promise<AddDomainRecordResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.line)) {
      query["Line"] = request.line;
    }

    if (!Util.isUnset(request.priority)) {
      query["Priority"] = request.priority;
    }

    if (!Util.isUnset(request.RR)) {
      query["RR"] = request.RR;
    }

    if (!Util.isUnset(request.TTL)) {
      query["TTL"] = request.TTL;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    if (!Util.isUnset(request.userClientIp)) {
      query["UserClientIp"] = request.userClientIp;
    }

    if (!Util.isUnset(request.value)) {
      query["Value"] = request.value;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddDomainRecord",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddDomainRecordResponse>(await this.callApi(params, req, runtime), new AddDomainRecordResponse({}));
  }

  /**
   * Adds a Domain Name System (DNS) record based on the specified parameters.
   * 
   * @param request - AddDomainRecordRequest
   * @returns AddDomainRecordResponse
   */
  async addDomainRecord(request: AddDomainRecordRequest): Promise<AddDomainRecordResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addDomainRecordWithOptions(request, runtime);
  }

  /**
   * @param request - AddGtmAccessStrategyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddGtmAccessStrategyResponse
   */
  async addGtmAccessStrategyWithOptions(request: AddGtmAccessStrategyRequest, runtime: $Util.RuntimeOptions): Promise<AddGtmAccessStrategyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.accessLines)) {
      query["AccessLines"] = request.accessLines;
    }

    if (!Util.isUnset(request.defaultAddrPoolId)) {
      query["DefaultAddrPoolId"] = request.defaultAddrPoolId;
    }

    if (!Util.isUnset(request.failoverAddrPoolId)) {
      query["FailoverAddrPoolId"] = request.failoverAddrPoolId;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.strategyName)) {
      query["StrategyName"] = request.strategyName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddGtmAccessStrategy",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddGtmAccessStrategyResponse>(await this.callApi(params, req, runtime), new AddGtmAccessStrategyResponse({}));
  }

  /**
   * @param request - AddGtmAccessStrategyRequest
   * @returns AddGtmAccessStrategyResponse
   */
  async addGtmAccessStrategy(request: AddGtmAccessStrategyRequest): Promise<AddGtmAccessStrategyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addGtmAccessStrategyWithOptions(request, runtime);
  }

  /**
   * Creates an address pool.
   * 
   * @param request - AddGtmAddressPoolRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddGtmAddressPoolResponse
   */
  async addGtmAddressPoolWithOptions(request: AddGtmAddressPoolRequest, runtime: $Util.RuntimeOptions): Promise<AddGtmAddressPoolResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.addr)) {
      query["Addr"] = request.addr;
    }

    if (!Util.isUnset(request.evaluationCount)) {
      query["EvaluationCount"] = request.evaluationCount;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.interval)) {
      query["Interval"] = request.interval;
    }

    if (!Util.isUnset(request.ispCityNode)) {
      query["IspCityNode"] = request.ispCityNode;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.minAvailableAddrNum)) {
      query["MinAvailableAddrNum"] = request.minAvailableAddrNum;
    }

    if (!Util.isUnset(request.monitorExtendInfo)) {
      query["MonitorExtendInfo"] = request.monitorExtendInfo;
    }

    if (!Util.isUnset(request.monitorStatus)) {
      query["MonitorStatus"] = request.monitorStatus;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.protocolType)) {
      query["ProtocolType"] = request.protocolType;
    }

    if (!Util.isUnset(request.timeout)) {
      query["Timeout"] = request.timeout;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddGtmAddressPool",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddGtmAddressPoolResponse>(await this.callApi(params, req, runtime), new AddGtmAddressPoolResponse({}));
  }

  /**
   * Creates an address pool.
   * 
   * @param request - AddGtmAddressPoolRequest
   * @returns AddGtmAddressPoolResponse
   */
  async addGtmAddressPool(request: AddGtmAddressPoolRequest): Promise<AddGtmAddressPoolResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addGtmAddressPoolWithOptions(request, runtime);
  }

  /**
   * Creates a health check task.
   * 
   * @param request - AddGtmMonitorRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddGtmMonitorResponse
   */
  async addGtmMonitorWithOptions(request: AddGtmMonitorRequest, runtime: $Util.RuntimeOptions): Promise<AddGtmMonitorResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.addrPoolId)) {
      query["AddrPoolId"] = request.addrPoolId;
    }

    if (!Util.isUnset(request.evaluationCount)) {
      query["EvaluationCount"] = request.evaluationCount;
    }

    if (!Util.isUnset(request.interval)) {
      query["Interval"] = request.interval;
    }

    if (!Util.isUnset(request.ispCityNode)) {
      query["IspCityNode"] = request.ispCityNode;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.monitorExtendInfo)) {
      query["MonitorExtendInfo"] = request.monitorExtendInfo;
    }

    if (!Util.isUnset(request.protocolType)) {
      query["ProtocolType"] = request.protocolType;
    }

    if (!Util.isUnset(request.timeout)) {
      query["Timeout"] = request.timeout;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddGtmMonitor",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddGtmMonitorResponse>(await this.callApi(params, req, runtime), new AddGtmMonitorResponse({}));
  }

  /**
   * Creates a health check task.
   * 
   * @param request - AddGtmMonitorRequest
   * @returns AddGtmMonitorResponse
   */
  async addGtmMonitor(request: AddGtmMonitorRequest): Promise<AddGtmMonitorResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addGtmMonitorWithOptions(request, runtime);
  }

  /**
   * @param request - AddGtmRecoveryPlanRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddGtmRecoveryPlanResponse
   */
  async addGtmRecoveryPlanWithOptions(request: AddGtmRecoveryPlanRequest, runtime: $Util.RuntimeOptions): Promise<AddGtmRecoveryPlanResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.faultAddrPool)) {
      query["FaultAddrPool"] = request.faultAddrPool;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.remark)) {
      query["Remark"] = request.remark;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddGtmRecoveryPlan",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddGtmRecoveryPlanResponse>(await this.callApi(params, req, runtime), new AddGtmRecoveryPlanResponse({}));
  }

  /**
   * @param request - AddGtmRecoveryPlanRequest
   * @returns AddGtmRecoveryPlanResponse
   */
  async addGtmRecoveryPlan(request: AddGtmRecoveryPlanRequest): Promise<AddGtmRecoveryPlanResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addGtmRecoveryPlanWithOptions(request, runtime);
  }

  /**
   * Binds one or more domain names to a paid Alibaba Cloud DNS instance.
   * 
   * @remarks
   * A paid Alibaba Cloud DNS instance whose ID starts with dns is an instance of the new version. You can call this API operation to bind multiple domain names to the instance. If the upper limit is exceeded, an error message is returned.\\
   * A paid Alibaba Cloud DNS instance whose ID does not start with dns is an instance of the old version. You can call this API operation to bind only one domain name to the instance. However, if the instance is already bound to a domain name, you must unbind the original domain name from the instance and bind the desired domain name to the instance.
   * 
   * @param request - BindInstanceDomainsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns BindInstanceDomainsResponse
   */
  async bindInstanceDomainsWithOptions(request: BindInstanceDomainsRequest, runtime: $Util.RuntimeOptions): Promise<BindInstanceDomainsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainNames)) {
      query["DomainNames"] = request.domainNames;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BindInstanceDomains",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BindInstanceDomainsResponse>(await this.callApi(params, req, runtime), new BindInstanceDomainsResponse({}));
  }

  /**
   * Binds one or more domain names to a paid Alibaba Cloud DNS instance.
   * 
   * @remarks
   * A paid Alibaba Cloud DNS instance whose ID starts with dns is an instance of the new version. You can call this API operation to bind multiple domain names to the instance. If the upper limit is exceeded, an error message is returned.\\
   * A paid Alibaba Cloud DNS instance whose ID does not start with dns is an instance of the old version. You can call this API operation to bind only one domain name to the instance. However, if the instance is already bound to a domain name, you must unbind the original domain name from the instance and bind the desired domain name to the instance.
   * 
   * @param request - BindInstanceDomainsRequest
   * @returns BindInstanceDomainsResponse
   */
  async bindInstanceDomains(request: BindInstanceDomainsRequest): Promise<BindInstanceDomainsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.bindInstanceDomainsWithOptions(request, runtime);
  }

  /**
   * Moves a domain name from the original group to the new group based on the specified parameters.
   * 
   * @remarks
   * You can specify GroupId to move a domain name to a specific domain name group. You can move the domain name to the group that contains all domain names or the default group.
   * 
   * @param request - ChangeDomainGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ChangeDomainGroupResponse
   */
  async changeDomainGroupWithOptions(request: ChangeDomainGroupRequest, runtime: $Util.RuntimeOptions): Promise<ChangeDomainGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ChangeDomainGroup",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ChangeDomainGroupResponse>(await this.callApi(params, req, runtime), new ChangeDomainGroupResponse({}));
  }

  /**
   * Moves a domain name from the original group to the new group based on the specified parameters.
   * 
   * @remarks
   * You can specify GroupId to move a domain name to a specific domain name group. You can move the domain name to the group that contains all domain names or the default group.
   * 
   * @param request - ChangeDomainGroupRequest
   * @returns ChangeDomainGroupResponse
   */
  async changeDomainGroup(request: ChangeDomainGroupRequest): Promise<ChangeDomainGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.changeDomainGroupWithOptions(request, runtime);
  }

  /**
   * Changes the domain name bound to an Alibaba Cloud DNS instance.
   * 
   * @remarks
   * >  You can call this operation to change the domain name for an Alibaba Cloud DNS instance to which a domain name is bound. You can also call this operation to bind a domain name to an Alibaba Cloud DNS instance to which no domain name is bound. If you need to unbind a domain name from an Alibaba Cloud DNS instance, you can call this operation. In this case, the NewDomain parameter must not be specified.
   * 
   * @param request - ChangeDomainOfDnsProductRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ChangeDomainOfDnsProductResponse
   */
  async changeDomainOfDnsProductWithOptions(request: ChangeDomainOfDnsProductRequest, runtime: $Util.RuntimeOptions): Promise<ChangeDomainOfDnsProductResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.force)) {
      query["Force"] = request.force;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.newDomain)) {
      query["NewDomain"] = request.newDomain;
    }

    if (!Util.isUnset(request.userClientIp)) {
      query["UserClientIp"] = request.userClientIp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ChangeDomainOfDnsProduct",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ChangeDomainOfDnsProductResponse>(await this.callApi(params, req, runtime), new ChangeDomainOfDnsProductResponse({}));
  }

  /**
   * Changes the domain name bound to an Alibaba Cloud DNS instance.
   * 
   * @remarks
   * >  You can call this operation to change the domain name for an Alibaba Cloud DNS instance to which a domain name is bound. You can also call this operation to bind a domain name to an Alibaba Cloud DNS instance to which no domain name is bound. If you need to unbind a domain name from an Alibaba Cloud DNS instance, you can call this operation. In this case, the NewDomain parameter must not be specified.
   * 
   * @param request - ChangeDomainOfDnsProductRequest
   * @returns ChangeDomainOfDnsProductResponse
   */
  async changeDomainOfDnsProduct(request: ChangeDomainOfDnsProductRequest): Promise<ChangeDomainOfDnsProductResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.changeDomainOfDnsProductWithOptions(request, runtime);
  }

  /**
   * @param request - CopyGtmConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CopyGtmConfigResponse
   */
  async copyGtmConfigWithOptions(request: CopyGtmConfigRequest, runtime: $Util.RuntimeOptions): Promise<CopyGtmConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.copyType)) {
      query["CopyType"] = request.copyType;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.sourceId)) {
      query["SourceId"] = request.sourceId;
    }

    if (!Util.isUnset(request.targetId)) {
      query["TargetId"] = request.targetId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CopyGtmConfig",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CopyGtmConfigResponse>(await this.callApi(params, req, runtime), new CopyGtmConfigResponse({}));
  }

  /**
   * @param request - CopyGtmConfigRequest
   * @returns CopyGtmConfigResponse
   */
  async copyGtmConfig(request: CopyGtmConfigRequest): Promise<CopyGtmConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.copyGtmConfigWithOptions(request, runtime);
  }

  /**
   * @param tmpReq - CreateCloudGtmAddressRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateCloudGtmAddressResponse
   */
  async createCloudGtmAddressWithOptions(tmpReq: CreateCloudGtmAddressRequest, runtime: $Util.RuntimeOptions): Promise<CreateCloudGtmAddressResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateCloudGtmAddressShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.healthTasks)) {
      request.healthTasksShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.healthTasks, "HealthTasks", "json");
    }

    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.address)) {
      query["Address"] = request.address;
    }

    if (!Util.isUnset(request.attributeInfo)) {
      query["AttributeInfo"] = request.attributeInfo;
    }

    if (!Util.isUnset(request.availableMode)) {
      query["AvailableMode"] = request.availableMode;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.enableStatus)) {
      query["EnableStatus"] = request.enableStatus;
    }

    if (!Util.isUnset(request.healthJudgement)) {
      query["HealthJudgement"] = request.healthJudgement;
    }

    if (!Util.isUnset(request.healthTasksShrink)) {
      query["HealthTasks"] = request.healthTasksShrink;
    }

    if (!Util.isUnset(request.manualAvailableStatus)) {
      query["ManualAvailableStatus"] = request.manualAvailableStatus;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.remark)) {
      query["Remark"] = request.remark;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateCloudGtmAddress",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateCloudGtmAddressResponse>(await this.callApi(params, req, runtime), new CreateCloudGtmAddressResponse({}));
  }

  /**
   * @param request - CreateCloudGtmAddressRequest
   * @returns CreateCloudGtmAddressResponse
   */
  async createCloudGtmAddress(request: CreateCloudGtmAddressRequest): Promise<CreateCloudGtmAddressResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createCloudGtmAddressWithOptions(request, runtime);
  }

  /**
   * @param request - CreateCloudGtmAddressPoolRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateCloudGtmAddressPoolResponse
   */
  async createCloudGtmAddressPoolWithOptions(request: CreateCloudGtmAddressPoolRequest, runtime: $Util.RuntimeOptions): Promise<CreateCloudGtmAddressPoolResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.addressPoolName)) {
      query["AddressPoolName"] = request.addressPoolName;
    }

    if (!Util.isUnset(request.addressPoolType)) {
      query["AddressPoolType"] = request.addressPoolType;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.enableStatus)) {
      query["EnableStatus"] = request.enableStatus;
    }

    if (!Util.isUnset(request.healthJudgement)) {
      query["HealthJudgement"] = request.healthJudgement;
    }

    if (!Util.isUnset(request.remark)) {
      query["Remark"] = request.remark;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateCloudGtmAddressPool",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateCloudGtmAddressPoolResponse>(await this.callApi(params, req, runtime), new CreateCloudGtmAddressPoolResponse({}));
  }

  /**
   * @param request - CreateCloudGtmAddressPoolRequest
   * @returns CreateCloudGtmAddressPoolResponse
   */
  async createCloudGtmAddressPool(request: CreateCloudGtmAddressPoolRequest): Promise<CreateCloudGtmAddressPoolResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createCloudGtmAddressPoolWithOptions(request, runtime);
  }

  /**
   * @param request - CreateCloudGtmInstanceConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateCloudGtmInstanceConfigResponse
   */
  async createCloudGtmInstanceConfigWithOptions(request: CreateCloudGtmInstanceConfigRequest, runtime: $Util.RuntimeOptions): Promise<CreateCloudGtmInstanceConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.enableStatus)) {
      query["EnableStatus"] = request.enableStatus;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.remark)) {
      query["Remark"] = request.remark;
    }

    if (!Util.isUnset(request.scheduleHostname)) {
      query["ScheduleHostname"] = request.scheduleHostname;
    }

    if (!Util.isUnset(request.scheduleRrType)) {
      query["ScheduleRrType"] = request.scheduleRrType;
    }

    if (!Util.isUnset(request.scheduleZoneMode)) {
      query["ScheduleZoneMode"] = request.scheduleZoneMode;
    }

    if (!Util.isUnset(request.scheduleZoneName)) {
      query["ScheduleZoneName"] = request.scheduleZoneName;
    }

    if (!Util.isUnset(request.ttl)) {
      query["Ttl"] = request.ttl;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateCloudGtmInstanceConfig",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateCloudGtmInstanceConfigResponse>(await this.callApi(params, req, runtime), new CreateCloudGtmInstanceConfigResponse({}));
  }

  /**
   * @param request - CreateCloudGtmInstanceConfigRequest
   * @returns CreateCloudGtmInstanceConfigResponse
   */
  async createCloudGtmInstanceConfig(request: CreateCloudGtmInstanceConfigRequest): Promise<CreateCloudGtmInstanceConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createCloudGtmInstanceConfigWithOptions(request, runtime);
  }

  /**
   * @param tmpReq - CreateCloudGtmMonitorTemplateRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateCloudGtmMonitorTemplateResponse
   */
  async createCloudGtmMonitorTemplateWithOptions(tmpReq: CreateCloudGtmMonitorTemplateRequest, runtime: $Util.RuntimeOptions): Promise<CreateCloudGtmMonitorTemplateResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateCloudGtmMonitorTemplateShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.ispCityNodes)) {
      request.ispCityNodesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.ispCityNodes, "IspCityNodes", "json");
    }

    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.evaluationCount)) {
      query["EvaluationCount"] = request.evaluationCount;
    }

    if (!Util.isUnset(request.extendInfo)) {
      query["ExtendInfo"] = request.extendInfo;
    }

    if (!Util.isUnset(request.failureRate)) {
      query["FailureRate"] = request.failureRate;
    }

    if (!Util.isUnset(request.interval)) {
      query["Interval"] = request.interval;
    }

    if (!Util.isUnset(request.ipVersion)) {
      query["IpVersion"] = request.ipVersion;
    }

    if (!Util.isUnset(request.ispCityNodesShrink)) {
      query["IspCityNodes"] = request.ispCityNodesShrink;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.protocol)) {
      query["Protocol"] = request.protocol;
    }

    if (!Util.isUnset(request.timeout)) {
      query["Timeout"] = request.timeout;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateCloudGtmMonitorTemplate",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateCloudGtmMonitorTemplateResponse>(await this.callApi(params, req, runtime), new CreateCloudGtmMonitorTemplateResponse({}));
  }

  /**
   * @param request - CreateCloudGtmMonitorTemplateRequest
   * @returns CreateCloudGtmMonitorTemplateResponse
   */
  async createCloudGtmMonitorTemplate(request: CreateCloudGtmMonitorTemplateRequest): Promise<CreateCloudGtmMonitorTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createCloudGtmMonitorTemplateWithOptions(request, runtime);
  }

  /**
   * DNS AppKey
   * 
   * @param request - CreatePdnsAppKeyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreatePdnsAppKeyResponse
   */
  async createPdnsAppKeyWithOptions(request: CreatePdnsAppKeyRequest, runtime: $Util.RuntimeOptions): Promise<CreatePdnsAppKeyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreatePdnsAppKey",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreatePdnsAppKeyResponse>(await this.callApi(params, req, runtime), new CreatePdnsAppKeyResponse({}));
  }

  /**
   * DNS AppKey
   * 
   * @param request - CreatePdnsAppKeyRequest
   * @returns CreatePdnsAppKeyResponse
   */
  async createPdnsAppKey(request: CreatePdnsAppKeyRequest): Promise<CreatePdnsAppKeyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createPdnsAppKeyWithOptions(request, runtime);
  }

  /**
   * DNS Udp Ip
   * 
   * @param request - CreatePdnsUdpIpSegmentRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreatePdnsUdpIpSegmentResponse
   */
  async createPdnsUdpIpSegmentWithOptions(request: CreatePdnsUdpIpSegmentRequest, runtime: $Util.RuntimeOptions): Promise<CreatePdnsUdpIpSegmentResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ip)) {
      query["Ip"] = request.ip;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreatePdnsUdpIpSegment",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreatePdnsUdpIpSegmentResponse>(await this.callApi(params, req, runtime), new CreatePdnsUdpIpSegmentResponse({}));
  }

  /**
   * DNS Udp Ip
   * 
   * @param request - CreatePdnsUdpIpSegmentRequest
   * @returns CreatePdnsUdpIpSegmentResponse
   */
  async createPdnsUdpIpSegment(request: CreatePdnsUdpIpSegmentRequest): Promise<CreatePdnsUdpIpSegmentResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createPdnsUdpIpSegmentWithOptions(request, runtime);
  }

  /**
   * @param request - DeleteCloudGtmAddressRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteCloudGtmAddressResponse
   */
  async deleteCloudGtmAddressWithOptions(request: DeleteCloudGtmAddressRequest, runtime: $Util.RuntimeOptions): Promise<DeleteCloudGtmAddressResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.addressId)) {
      query["AddressId"] = request.addressId;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteCloudGtmAddress",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteCloudGtmAddressResponse>(await this.callApi(params, req, runtime), new DeleteCloudGtmAddressResponse({}));
  }

  /**
   * @param request - DeleteCloudGtmAddressRequest
   * @returns DeleteCloudGtmAddressResponse
   */
  async deleteCloudGtmAddress(request: DeleteCloudGtmAddressRequest): Promise<DeleteCloudGtmAddressResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteCloudGtmAddressWithOptions(request, runtime);
  }

  /**
   * @param request - DeleteCloudGtmAddressPoolRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteCloudGtmAddressPoolResponse
   */
  async deleteCloudGtmAddressPoolWithOptions(request: DeleteCloudGtmAddressPoolRequest, runtime: $Util.RuntimeOptions): Promise<DeleteCloudGtmAddressPoolResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.addressPoolId)) {
      query["AddressPoolId"] = request.addressPoolId;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteCloudGtmAddressPool",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteCloudGtmAddressPoolResponse>(await this.callApi(params, req, runtime), new DeleteCloudGtmAddressPoolResponse({}));
  }

  /**
   * @param request - DeleteCloudGtmAddressPoolRequest
   * @returns DeleteCloudGtmAddressPoolResponse
   */
  async deleteCloudGtmAddressPool(request: DeleteCloudGtmAddressPoolRequest): Promise<DeleteCloudGtmAddressPoolResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteCloudGtmAddressPoolWithOptions(request, runtime);
  }

  /**
   * @param request - DeleteCloudGtmInstanceConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteCloudGtmInstanceConfigResponse
   */
  async deleteCloudGtmInstanceConfigWithOptions(request: DeleteCloudGtmInstanceConfigRequest, runtime: $Util.RuntimeOptions): Promise<DeleteCloudGtmInstanceConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.configId)) {
      query["ConfigId"] = request.configId;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteCloudGtmInstanceConfig",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteCloudGtmInstanceConfigResponse>(await this.callApi(params, req, runtime), new DeleteCloudGtmInstanceConfigResponse({}));
  }

  /**
   * @param request - DeleteCloudGtmInstanceConfigRequest
   * @returns DeleteCloudGtmInstanceConfigResponse
   */
  async deleteCloudGtmInstanceConfig(request: DeleteCloudGtmInstanceConfigRequest): Promise<DeleteCloudGtmInstanceConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteCloudGtmInstanceConfigWithOptions(request, runtime);
  }

  /**
   * @param request - DeleteCloudGtmMonitorTemplateRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteCloudGtmMonitorTemplateResponse
   */
  async deleteCloudGtmMonitorTemplateWithOptions(request: DeleteCloudGtmMonitorTemplateRequest, runtime: $Util.RuntimeOptions): Promise<DeleteCloudGtmMonitorTemplateResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.templateId)) {
      query["TemplateId"] = request.templateId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteCloudGtmMonitorTemplate",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteCloudGtmMonitorTemplateResponse>(await this.callApi(params, req, runtime), new DeleteCloudGtmMonitorTemplateResponse({}));
  }

  /**
   * @param request - DeleteCloudGtmMonitorTemplateRequest
   * @returns DeleteCloudGtmMonitorTemplateResponse
   */
  async deleteCloudGtmMonitorTemplate(request: DeleteCloudGtmMonitorTemplateRequest): Promise<DeleteCloudGtmMonitorTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteCloudGtmMonitorTemplateWithOptions(request, runtime);
  }

  /**
   * Deletes multiple custom lines at a time.
   * 
   * @param request - DeleteCustomLinesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteCustomLinesResponse
   */
  async deleteCustomLinesWithOptions(request: DeleteCustomLinesRequest, runtime: $Util.RuntimeOptions): Promise<DeleteCustomLinesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.lineIds)) {
      query["LineIds"] = request.lineIds;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteCustomLines",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteCustomLinesResponse>(await this.callApi(params, req, runtime), new DeleteCustomLinesResponse({}));
  }

  /**
   * Deletes multiple custom lines at a time.
   * 
   * @param request - DeleteCustomLinesRequest
   * @returns DeleteCustomLinesResponse
   */
  async deleteCustomLines(request: DeleteCustomLinesRequest): Promise<DeleteCustomLinesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteCustomLinesWithOptions(request, runtime);
  }

  /**
   * @param request - DeleteDnsCacheDomainRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteDnsCacheDomainResponse
   */
  async deleteDnsCacheDomainWithOptions(request: DeleteDnsCacheDomainRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDnsCacheDomainResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteDnsCacheDomain",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteDnsCacheDomainResponse>(await this.callApi(params, req, runtime), new DeleteDnsCacheDomainResponse({}));
  }

  /**
   * @param request - DeleteDnsCacheDomainRequest
   * @returns DeleteDnsCacheDomainResponse
   */
  async deleteDnsCacheDomain(request: DeleteDnsCacheDomainRequest): Promise<DeleteDnsCacheDomainResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDnsCacheDomainWithOptions(request, runtime);
  }

  /**
   * @param request - DeleteDnsGtmAccessStrategyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteDnsGtmAccessStrategyResponse
   */
  async deleteDnsGtmAccessStrategyWithOptions(request: DeleteDnsGtmAccessStrategyRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDnsGtmAccessStrategyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.strategyId)) {
      query["StrategyId"] = request.strategyId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteDnsGtmAccessStrategy",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteDnsGtmAccessStrategyResponse>(await this.callApi(params, req, runtime), new DeleteDnsGtmAccessStrategyResponse({}));
  }

  /**
   * @param request - DeleteDnsGtmAccessStrategyRequest
   * @returns DeleteDnsGtmAccessStrategyResponse
   */
  async deleteDnsGtmAccessStrategy(request: DeleteDnsGtmAccessStrategyRequest): Promise<DeleteDnsGtmAccessStrategyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDnsGtmAccessStrategyWithOptions(request, runtime);
  }

  /**
   * @param request - DeleteDnsGtmAddressPoolRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteDnsGtmAddressPoolResponse
   */
  async deleteDnsGtmAddressPoolWithOptions(request: DeleteDnsGtmAddressPoolRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDnsGtmAddressPoolResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.addrPoolId)) {
      query["AddrPoolId"] = request.addrPoolId;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteDnsGtmAddressPool",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteDnsGtmAddressPoolResponse>(await this.callApi(params, req, runtime), new DeleteDnsGtmAddressPoolResponse({}));
  }

  /**
   * @param request - DeleteDnsGtmAddressPoolRequest
   * @returns DeleteDnsGtmAddressPoolResponse
   */
  async deleteDnsGtmAddressPool(request: DeleteDnsGtmAddressPoolRequest): Promise<DeleteDnsGtmAddressPoolResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDnsGtmAddressPoolWithOptions(request, runtime);
  }

  /**
   * Deletes a domain name based on the specified parameters.
   * 
   * @param request - DeleteDomainRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteDomainResponse
   */
  async deleteDomainWithOptions(request: DeleteDomainRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDomainResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteDomain",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteDomainResponse>(await this.callApi(params, req, runtime), new DeleteDomainResponse({}));
  }

  /**
   * Deletes a domain name based on the specified parameters.
   * 
   * @param request - DeleteDomainRequest
   * @returns DeleteDomainResponse
   */
  async deleteDomain(request: DeleteDomainRequest): Promise<DeleteDomainResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDomainWithOptions(request, runtime);
  }

  /**
   * Deletes a domain name group. After you delete the domain name group, the domain names in the group are moved to the default group.
   * 
   * @remarks
   * >  The default group cannot be deleted.
   * 
   * @param request - DeleteDomainGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteDomainGroupResponse
   */
  async deleteDomainGroupWithOptions(request: DeleteDomainGroupRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDomainGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteDomainGroup",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteDomainGroupResponse>(await this.callApi(params, req, runtime), new DeleteDomainGroupResponse({}));
  }

  /**
   * Deletes a domain name group. After you delete the domain name group, the domain names in the group are moved to the default group.
   * 
   * @remarks
   * >  The default group cannot be deleted.
   * 
   * @param request - DeleteDomainGroupRequest
   * @returns DeleteDomainGroupResponse
   */
  async deleteDomainGroup(request: DeleteDomainGroupRequest): Promise<DeleteDomainGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDomainGroupWithOptions(request, runtime);
  }

  /**
   * Deletes a Domain Name System (DNS) record based on the specified parameters.
   * 
   * @param request - DeleteDomainRecordRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteDomainRecordResponse
   */
  async deleteDomainRecordWithOptions(request: DeleteDomainRecordRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDomainRecordResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.recordId)) {
      query["RecordId"] = request.recordId;
    }

    if (!Util.isUnset(request.userClientIp)) {
      query["UserClientIp"] = request.userClientIp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteDomainRecord",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteDomainRecordResponse>(await this.callApi(params, req, runtime), new DeleteDomainRecordResponse({}));
  }

  /**
   * Deletes a Domain Name System (DNS) record based on the specified parameters.
   * 
   * @param request - DeleteDomainRecordRequest
   * @returns DeleteDomainRecordResponse
   */
  async deleteDomainRecord(request: DeleteDomainRecordRequest): Promise<DeleteDomainRecordResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDomainRecordWithOptions(request, runtime);
  }

  /**
   * @param request - DeleteGtmAccessStrategyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteGtmAccessStrategyResponse
   */
  async deleteGtmAccessStrategyWithOptions(request: DeleteGtmAccessStrategyRequest, runtime: $Util.RuntimeOptions): Promise<DeleteGtmAccessStrategyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.strategyId)) {
      query["StrategyId"] = request.strategyId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteGtmAccessStrategy",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteGtmAccessStrategyResponse>(await this.callApi(params, req, runtime), new DeleteGtmAccessStrategyResponse({}));
  }

  /**
   * @param request - DeleteGtmAccessStrategyRequest
   * @returns DeleteGtmAccessStrategyResponse
   */
  async deleteGtmAccessStrategy(request: DeleteGtmAccessStrategyRequest): Promise<DeleteGtmAccessStrategyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteGtmAccessStrategyWithOptions(request, runtime);
  }

  /**
   * @param request - DeleteGtmAddressPoolRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteGtmAddressPoolResponse
   */
  async deleteGtmAddressPoolWithOptions(request: DeleteGtmAddressPoolRequest, runtime: $Util.RuntimeOptions): Promise<DeleteGtmAddressPoolResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.addrPoolId)) {
      query["AddrPoolId"] = request.addrPoolId;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteGtmAddressPool",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteGtmAddressPoolResponse>(await this.callApi(params, req, runtime), new DeleteGtmAddressPoolResponse({}));
  }

  /**
   * @param request - DeleteGtmAddressPoolRequest
   * @returns DeleteGtmAddressPoolResponse
   */
  async deleteGtmAddressPool(request: DeleteGtmAddressPoolRequest): Promise<DeleteGtmAddressPoolResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteGtmAddressPoolWithOptions(request, runtime);
  }

  /**
   * @param request - DeleteGtmRecoveryPlanRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteGtmRecoveryPlanResponse
   */
  async deleteGtmRecoveryPlanWithOptions(request: DeleteGtmRecoveryPlanRequest, runtime: $Util.RuntimeOptions): Promise<DeleteGtmRecoveryPlanResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.recoveryPlanId)) {
      query["RecoveryPlanId"] = request.recoveryPlanId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteGtmRecoveryPlan",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteGtmRecoveryPlanResponse>(await this.callApi(params, req, runtime), new DeleteGtmRecoveryPlanResponse({}));
  }

  /**
   * @param request - DeleteGtmRecoveryPlanRequest
   * @returns DeleteGtmRecoveryPlanResponse
   */
  async deleteGtmRecoveryPlan(request: DeleteGtmRecoveryPlanRequest): Promise<DeleteGtmRecoveryPlanResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteGtmRecoveryPlanWithOptions(request, runtime);
  }

  /**
   * @remarks
   * If the DNS records to be deleted contain locked DNS records, locked DNS records will not be deleted.
   * 
   * @param request - DeleteSubDomainRecordsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteSubDomainRecordsResponse
   */
  async deleteSubDomainRecordsWithOptions(request: DeleteSubDomainRecordsRequest, runtime: $Util.RuntimeOptions): Promise<DeleteSubDomainRecordsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.RR)) {
      query["RR"] = request.RR;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    if (!Util.isUnset(request.userClientIp)) {
      query["UserClientIp"] = request.userClientIp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteSubDomainRecords",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteSubDomainRecordsResponse>(await this.callApi(params, req, runtime), new DeleteSubDomainRecordsResponse({}));
  }

  /**
   * @remarks
   * If the DNS records to be deleted contain locked DNS records, locked DNS records will not be deleted.
   * 
   * @param request - DeleteSubDomainRecordsRequest
   * @returns DeleteSubDomainRecordsResponse
   */
  async deleteSubDomainRecords(request: DeleteSubDomainRecordsRequest): Promise<DeleteSubDomainRecordsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteSubDomainRecordsWithOptions(request, runtime);
  }

  /**
   * @param request - DescribeBatchResultCountRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeBatchResultCountResponse
   */
  async describeBatchResultCountWithOptions(request: DescribeBatchResultCountRequest, runtime: $Util.RuntimeOptions): Promise<DescribeBatchResultCountResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.batchType)) {
      query["BatchType"] = request.batchType;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.taskId)) {
      query["TaskId"] = request.taskId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeBatchResultCount",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeBatchResultCountResponse>(await this.callApi(params, req, runtime), new DescribeBatchResultCountResponse({}));
  }

  /**
   * @param request - DescribeBatchResultCountRequest
   * @returns DescribeBatchResultCountResponse
   */
  async describeBatchResultCount(request: DescribeBatchResultCountRequest): Promise<DescribeBatchResultCountResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeBatchResultCountWithOptions(request, runtime);
  }

  /**
   * Queries the detailed results of a batch operation task.
   * 
   * @remarks
   * Before you call this operation, make sure that the batch operation task is complete.
   * 
   * @param request - DescribeBatchResultDetailRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeBatchResultDetailResponse
   */
  async describeBatchResultDetailWithOptions(request: DescribeBatchResultDetailRequest, runtime: $Util.RuntimeOptions): Promise<DescribeBatchResultDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.batchType)) {
      query["BatchType"] = request.batchType;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    if (!Util.isUnset(request.taskId)) {
      query["TaskId"] = request.taskId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeBatchResultDetail",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeBatchResultDetailResponse>(await this.callApi(params, req, runtime), new DescribeBatchResultDetailResponse({}));
  }

  /**
   * Queries the detailed results of a batch operation task.
   * 
   * @remarks
   * Before you call this operation, make sure that the batch operation task is complete.
   * 
   * @param request - DescribeBatchResultDetailRequest
   * @returns DescribeBatchResultDetailResponse
   */
  async describeBatchResultDetail(request: DescribeBatchResultDetailRequest): Promise<DescribeBatchResultDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeBatchResultDetailWithOptions(request, runtime);
  }

  /**
   * @param request - DescribeCloudGtmAddressRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeCloudGtmAddressResponse
   */
  async describeCloudGtmAddressWithOptions(request: DescribeCloudGtmAddressRequest, runtime: $Util.RuntimeOptions): Promise<DescribeCloudGtmAddressResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.addressId)) {
      query["AddressId"] = request.addressId;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeCloudGtmAddress",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeCloudGtmAddressResponse>(await this.callApi(params, req, runtime), new DescribeCloudGtmAddressResponse({}));
  }

  /**
   * @param request - DescribeCloudGtmAddressRequest
   * @returns DescribeCloudGtmAddressResponse
   */
  async describeCloudGtmAddress(request: DescribeCloudGtmAddressRequest): Promise<DescribeCloudGtmAddressResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeCloudGtmAddressWithOptions(request, runtime);
  }

  /**
   * @param request - DescribeCloudGtmAddressPoolRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeCloudGtmAddressPoolResponse
   */
  async describeCloudGtmAddressPoolWithOptions(request: DescribeCloudGtmAddressPoolRequest, runtime: $Util.RuntimeOptions): Promise<DescribeCloudGtmAddressPoolResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.addressPoolId)) {
      query["AddressPoolId"] = request.addressPoolId;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeCloudGtmAddressPool",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeCloudGtmAddressPoolResponse>(await this.callApi(params, req, runtime), new DescribeCloudGtmAddressPoolResponse({}));
  }

  /**
   * @param request - DescribeCloudGtmAddressPoolRequest
   * @returns DescribeCloudGtmAddressPoolResponse
   */
  async describeCloudGtmAddressPool(request: DescribeCloudGtmAddressPoolRequest): Promise<DescribeCloudGtmAddressPoolResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeCloudGtmAddressPoolWithOptions(request, runtime);
  }

  /**
   * @param request - DescribeCloudGtmAddressPoolReferenceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeCloudGtmAddressPoolReferenceResponse
   */
  async describeCloudGtmAddressPoolReferenceWithOptions(request: DescribeCloudGtmAddressPoolReferenceRequest, runtime: $Util.RuntimeOptions): Promise<DescribeCloudGtmAddressPoolReferenceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.addressPoolId)) {
      query["AddressPoolId"] = request.addressPoolId;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeCloudGtmAddressPoolReference",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeCloudGtmAddressPoolReferenceResponse>(await this.callApi(params, req, runtime), new DescribeCloudGtmAddressPoolReferenceResponse({}));
  }

  /**
   * @param request - DescribeCloudGtmAddressPoolReferenceRequest
   * @returns DescribeCloudGtmAddressPoolReferenceResponse
   */
  async describeCloudGtmAddressPoolReference(request: DescribeCloudGtmAddressPoolReferenceRequest): Promise<DescribeCloudGtmAddressPoolReferenceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeCloudGtmAddressPoolReferenceWithOptions(request, runtime);
  }

  /**
   * @param request - DescribeCloudGtmAddressReferenceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeCloudGtmAddressReferenceResponse
   */
  async describeCloudGtmAddressReferenceWithOptions(request: DescribeCloudGtmAddressReferenceRequest, runtime: $Util.RuntimeOptions): Promise<DescribeCloudGtmAddressReferenceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.addressId)) {
      query["AddressId"] = request.addressId;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeCloudGtmAddressReference",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeCloudGtmAddressReferenceResponse>(await this.callApi(params, req, runtime), new DescribeCloudGtmAddressReferenceResponse({}));
  }

  /**
   * @param request - DescribeCloudGtmAddressReferenceRequest
   * @returns DescribeCloudGtmAddressReferenceResponse
   */
  async describeCloudGtmAddressReference(request: DescribeCloudGtmAddressReferenceRequest): Promise<DescribeCloudGtmAddressReferenceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeCloudGtmAddressReferenceWithOptions(request, runtime);
  }

  /**
   * @param request - DescribeCloudGtmGlobalAlertRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeCloudGtmGlobalAlertResponse
   */
  async describeCloudGtmGlobalAlertWithOptions(request: DescribeCloudGtmGlobalAlertRequest, runtime: $Util.RuntimeOptions): Promise<DescribeCloudGtmGlobalAlertResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeCloudGtmGlobalAlert",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeCloudGtmGlobalAlertResponse>(await this.callApi(params, req, runtime), new DescribeCloudGtmGlobalAlertResponse({}));
  }

  /**
   * @param request - DescribeCloudGtmGlobalAlertRequest
   * @returns DescribeCloudGtmGlobalAlertResponse
   */
  async describeCloudGtmGlobalAlert(request: DescribeCloudGtmGlobalAlertRequest): Promise<DescribeCloudGtmGlobalAlertResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeCloudGtmGlobalAlertWithOptions(request, runtime);
  }

  /**
   * @param request - DescribeCloudGtmInstanceConfigAlertRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeCloudGtmInstanceConfigAlertResponse
   */
  async describeCloudGtmInstanceConfigAlertWithOptions(request: DescribeCloudGtmInstanceConfigAlertRequest, runtime: $Util.RuntimeOptions): Promise<DescribeCloudGtmInstanceConfigAlertResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.configId)) {
      query["ConfigId"] = request.configId;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeCloudGtmInstanceConfigAlert",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeCloudGtmInstanceConfigAlertResponse>(await this.callApi(params, req, runtime), new DescribeCloudGtmInstanceConfigAlertResponse({}));
  }

  /**
   * @param request - DescribeCloudGtmInstanceConfigAlertRequest
   * @returns DescribeCloudGtmInstanceConfigAlertResponse
   */
  async describeCloudGtmInstanceConfigAlert(request: DescribeCloudGtmInstanceConfigAlertRequest): Promise<DescribeCloudGtmInstanceConfigAlertResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeCloudGtmInstanceConfigAlertWithOptions(request, runtime);
  }

  /**
   * @param request - DescribeCloudGtmInstanceConfigFullInfoRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeCloudGtmInstanceConfigFullInfoResponse
   */
  async describeCloudGtmInstanceConfigFullInfoWithOptions(request: DescribeCloudGtmInstanceConfigFullInfoRequest, runtime: $Util.RuntimeOptions): Promise<DescribeCloudGtmInstanceConfigFullInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.configId)) {
      query["ConfigId"] = request.configId;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeCloudGtmInstanceConfigFullInfo",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeCloudGtmInstanceConfigFullInfoResponse>(await this.callApi(params, req, runtime), new DescribeCloudGtmInstanceConfigFullInfoResponse({}));
  }

  /**
   * @param request - DescribeCloudGtmInstanceConfigFullInfoRequest
   * @returns DescribeCloudGtmInstanceConfigFullInfoResponse
   */
  async describeCloudGtmInstanceConfigFullInfo(request: DescribeCloudGtmInstanceConfigFullInfoRequest): Promise<DescribeCloudGtmInstanceConfigFullInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeCloudGtmInstanceConfigFullInfoWithOptions(request, runtime);
  }

  /**
   * @param request - DescribeCloudGtmMonitorTemplateRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeCloudGtmMonitorTemplateResponse
   */
  async describeCloudGtmMonitorTemplateWithOptions(request: DescribeCloudGtmMonitorTemplateRequest, runtime: $Util.RuntimeOptions): Promise<DescribeCloudGtmMonitorTemplateResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.templateId)) {
      query["TemplateId"] = request.templateId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeCloudGtmMonitorTemplate",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeCloudGtmMonitorTemplateResponse>(await this.callApi(params, req, runtime), new DescribeCloudGtmMonitorTemplateResponse({}));
  }

  /**
   * @param request - DescribeCloudGtmMonitorTemplateRequest
   * @returns DescribeCloudGtmMonitorTemplateResponse
   */
  async describeCloudGtmMonitorTemplate(request: DescribeCloudGtmMonitorTemplateRequest): Promise<DescribeCloudGtmMonitorTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeCloudGtmMonitorTemplateWithOptions(request, runtime);
  }

  /**
   * @param request - DescribeCloudGtmSummaryRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeCloudGtmSummaryResponse
   */
  async describeCloudGtmSummaryWithOptions(request: DescribeCloudGtmSummaryRequest, runtime: $Util.RuntimeOptions): Promise<DescribeCloudGtmSummaryResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeCloudGtmSummary",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeCloudGtmSummaryResponse>(await this.callApi(params, req, runtime), new DescribeCloudGtmSummaryResponse({}));
  }

  /**
   * @param request - DescribeCloudGtmSummaryRequest
   * @returns DescribeCloudGtmSummaryResponse
   */
  async describeCloudGtmSummary(request: DescribeCloudGtmSummaryRequest): Promise<DescribeCloudGtmSummaryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeCloudGtmSummaryWithOptions(request, runtime);
  }

  /**
   * @param request - DescribeCloudGtmSystemLinesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeCloudGtmSystemLinesResponse
   */
  async describeCloudGtmSystemLinesWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeCloudGtmSystemLinesResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeCloudGtmSystemLines",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeCloudGtmSystemLinesResponse>(await this.callApi(params, req, runtime), new DescribeCloudGtmSystemLinesResponse({}));
  }

  /**
   * @returns DescribeCloudGtmSystemLinesResponse
   */
  async describeCloudGtmSystemLines(): Promise<DescribeCloudGtmSystemLinesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeCloudGtmSystemLinesWithOptions(runtime);
  }

  /**
   * Queries a custom line.
   * 
   * @param request - DescribeCustomLineRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeCustomLineResponse
   */
  async describeCustomLineWithOptions(request: DescribeCustomLineRequest, runtime: $Util.RuntimeOptions): Promise<DescribeCustomLineResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.lineId)) {
      query["LineId"] = request.lineId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeCustomLine",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeCustomLineResponse>(await this.callApi(params, req, runtime), new DescribeCustomLineResponse({}));
  }

  /**
   * Queries a custom line.
   * 
   * @param request - DescribeCustomLineRequest
   * @returns DescribeCustomLineResponse
   */
  async describeCustomLine(request: DescribeCustomLineRequest): Promise<DescribeCustomLineResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeCustomLineWithOptions(request, runtime);
  }

  /**
   * Queries custom lines.
   * 
   * @param request - DescribeCustomLinesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeCustomLinesResponse
   */
  async describeCustomLinesWithOptions(request: DescribeCustomLinesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeCustomLinesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeCustomLines",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeCustomLinesResponse>(await this.callApi(params, req, runtime), new DescribeCustomLinesResponse({}));
  }

  /**
   * Queries custom lines.
   * 
   * @param request - DescribeCustomLinesRequest
   * @returns DescribeCustomLinesResponse
   */
  async describeCustomLines(request: DescribeCustomLinesRequest): Promise<DescribeCustomLinesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeCustomLinesWithOptions(request, runtime);
  }

  /**
   * Queries the subdomains for which weighted round-robin is enabled based on the specified parameters.
   * 
   * @param request - DescribeDNSSLBSubDomainsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDNSSLBSubDomainsResponse
   */
  async describeDNSSLBSubDomainsWithOptions(request: DescribeDNSSLBSubDomainsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDNSSLBSubDomainsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.rr)) {
      query["Rr"] = request.rr;
    }

    if (!Util.isUnset(request.userClientIp)) {
      query["UserClientIp"] = request.userClientIp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDNSSLBSubDomains",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDNSSLBSubDomainsResponse>(await this.callApi(params, req, runtime), new DescribeDNSSLBSubDomainsResponse({}));
  }

  /**
   * Queries the subdomains for which weighted round-robin is enabled based on the specified parameters.
   * 
   * @param request - DescribeDNSSLBSubDomainsRequest
   * @returns DescribeDNSSLBSubDomainsResponse
   */
  async describeDNSSLBSubDomains(request: DescribeDNSSLBSubDomainsRequest): Promise<DescribeDNSSLBSubDomainsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDNSSLBSubDomainsWithOptions(request, runtime);
  }

  /**
   * @param request - DescribeDnsCacheDomainsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDnsCacheDomainsResponse
   */
  async describeDnsCacheDomainsWithOptions(request: DescribeDnsCacheDomainsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDnsCacheDomainsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.keyword)) {
      query["Keyword"] = request.keyword;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDnsCacheDomains",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDnsCacheDomainsResponse>(await this.callApi(params, req, runtime), new DescribeDnsCacheDomainsResponse({}));
  }

  /**
   * @param request - DescribeDnsCacheDomainsRequest
   * @returns DescribeDnsCacheDomainsResponse
   */
  async describeDnsCacheDomains(request: DescribeDnsCacheDomainsRequest): Promise<DescribeDnsCacheDomainsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDnsCacheDomainsWithOptions(request, runtime);
  }

  /**
   * Queries access policies of a Global Traffic Manager (GTM) instance.
   * 
   * @param request - DescribeDnsGtmAccessStrategiesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDnsGtmAccessStrategiesResponse
   */
  async describeDnsGtmAccessStrategiesWithOptions(request: DescribeDnsGtmAccessStrategiesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDnsGtmAccessStrategiesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.strategyMode)) {
      query["StrategyMode"] = request.strategyMode;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDnsGtmAccessStrategies",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDnsGtmAccessStrategiesResponse>(await this.callApi(params, req, runtime), new DescribeDnsGtmAccessStrategiesResponse({}));
  }

  /**
   * Queries access policies of a Global Traffic Manager (GTM) instance.
   * 
   * @param request - DescribeDnsGtmAccessStrategiesRequest
   * @returns DescribeDnsGtmAccessStrategiesResponse
   */
  async describeDnsGtmAccessStrategies(request: DescribeDnsGtmAccessStrategiesRequest): Promise<DescribeDnsGtmAccessStrategiesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDnsGtmAccessStrategiesWithOptions(request, runtime);
  }

  /**
   * Queries detailed information about an access policy of a Global Traffic Manager (GTM) instance.
   * 
   * @param request - DescribeDnsGtmAccessStrategyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDnsGtmAccessStrategyResponse
   */
  async describeDnsGtmAccessStrategyWithOptions(request: DescribeDnsGtmAccessStrategyRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDnsGtmAccessStrategyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.strategyId)) {
      query["StrategyId"] = request.strategyId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDnsGtmAccessStrategy",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDnsGtmAccessStrategyResponse>(await this.callApi(params, req, runtime), new DescribeDnsGtmAccessStrategyResponse({}));
  }

  /**
   * Queries detailed information about an access policy of a Global Traffic Manager (GTM) instance.
   * 
   * @param request - DescribeDnsGtmAccessStrategyRequest
   * @returns DescribeDnsGtmAccessStrategyResponse
   */
  async describeDnsGtmAccessStrategy(request: DescribeDnsGtmAccessStrategyRequest): Promise<DescribeDnsGtmAccessStrategyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDnsGtmAccessStrategyWithOptions(request, runtime);
  }

  /**
   * Queries the available configurations of an access policy of a Global Traffic Manager (GTM) instance.
   * 
   * @param request - DescribeDnsGtmAccessStrategyAvailableConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDnsGtmAccessStrategyAvailableConfigResponse
   */
  async describeDnsGtmAccessStrategyAvailableConfigWithOptions(request: DescribeDnsGtmAccessStrategyAvailableConfigRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDnsGtmAccessStrategyAvailableConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.strategyMode)) {
      query["StrategyMode"] = request.strategyMode;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDnsGtmAccessStrategyAvailableConfig",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDnsGtmAccessStrategyAvailableConfigResponse>(await this.callApi(params, req, runtime), new DescribeDnsGtmAccessStrategyAvailableConfigResponse({}));
  }

  /**
   * Queries the available configurations of an access policy of a Global Traffic Manager (GTM) instance.
   * 
   * @param request - DescribeDnsGtmAccessStrategyAvailableConfigRequest
   * @returns DescribeDnsGtmAccessStrategyAvailableConfigResponse
   */
  async describeDnsGtmAccessStrategyAvailableConfig(request: DescribeDnsGtmAccessStrategyAvailableConfigRequest): Promise<DescribeDnsGtmAccessStrategyAvailableConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDnsGtmAccessStrategyAvailableConfigWithOptions(request, runtime);
  }

  /**
   * @param request - DescribeDnsGtmAddrAttributeInfoRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDnsGtmAddrAttributeInfoResponse
   */
  async describeDnsGtmAddrAttributeInfoWithOptions(request: DescribeDnsGtmAddrAttributeInfoRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDnsGtmAddrAttributeInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.addrs)) {
      query["Addrs"] = request.addrs;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDnsGtmAddrAttributeInfo",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDnsGtmAddrAttributeInfoResponse>(await this.callApi(params, req, runtime), new DescribeDnsGtmAddrAttributeInfoResponse({}));
  }

  /**
   * @param request - DescribeDnsGtmAddrAttributeInfoRequest
   * @returns DescribeDnsGtmAddrAttributeInfoResponse
   */
  async describeDnsGtmAddrAttributeInfo(request: DescribeDnsGtmAddrAttributeInfoRequest): Promise<DescribeDnsGtmAddrAttributeInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDnsGtmAddrAttributeInfoWithOptions(request, runtime);
  }

  /**
   * Queries the available configurations of an address pool of a Global Traffic Manager (GTM) instance.
   * 
   * @param request - DescribeDnsGtmAddressPoolAvailableConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDnsGtmAddressPoolAvailableConfigResponse
   */
  async describeDnsGtmAddressPoolAvailableConfigWithOptions(request: DescribeDnsGtmAddressPoolAvailableConfigRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDnsGtmAddressPoolAvailableConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDnsGtmAddressPoolAvailableConfig",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDnsGtmAddressPoolAvailableConfigResponse>(await this.callApi(params, req, runtime), new DescribeDnsGtmAddressPoolAvailableConfigResponse({}));
  }

  /**
   * Queries the available configurations of an address pool of a Global Traffic Manager (GTM) instance.
   * 
   * @param request - DescribeDnsGtmAddressPoolAvailableConfigRequest
   * @returns DescribeDnsGtmAddressPoolAvailableConfigResponse
   */
  async describeDnsGtmAddressPoolAvailableConfig(request: DescribeDnsGtmAddressPoolAvailableConfigRequest): Promise<DescribeDnsGtmAddressPoolAvailableConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDnsGtmAddressPoolAvailableConfigWithOptions(request, runtime);
  }

  /**
   * @param request - DescribeDnsGtmAvailableAlertGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDnsGtmAvailableAlertGroupResponse
   */
  async describeDnsGtmAvailableAlertGroupWithOptions(request: DescribeDnsGtmAvailableAlertGroupRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDnsGtmAvailableAlertGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDnsGtmAvailableAlertGroup",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDnsGtmAvailableAlertGroupResponse>(await this.callApi(params, req, runtime), new DescribeDnsGtmAvailableAlertGroupResponse({}));
  }

  /**
   * @param request - DescribeDnsGtmAvailableAlertGroupRequest
   * @returns DescribeDnsGtmAvailableAlertGroupResponse
   */
  async describeDnsGtmAvailableAlertGroup(request: DescribeDnsGtmAvailableAlertGroupRequest): Promise<DescribeDnsGtmAvailableAlertGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDnsGtmAvailableAlertGroupWithOptions(request, runtime);
  }

  /**
   * Queries detailed information about a Global Traffic Manager (GTM) instance.
   * 
   * @param request - DescribeDnsGtmInstanceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDnsGtmInstanceResponse
   */
  async describeDnsGtmInstanceWithOptions(request: DescribeDnsGtmInstanceRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDnsGtmInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDnsGtmInstance",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDnsGtmInstanceResponse>(await this.callApi(params, req, runtime), new DescribeDnsGtmInstanceResponse({}));
  }

  /**
   * Queries detailed information about a Global Traffic Manager (GTM) instance.
   * 
   * @param request - DescribeDnsGtmInstanceRequest
   * @returns DescribeDnsGtmInstanceResponse
   */
  async describeDnsGtmInstance(request: DescribeDnsGtmInstanceRequest): Promise<DescribeDnsGtmInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDnsGtmInstanceWithOptions(request, runtime);
  }

  /**
   * Queries detailed information about an address pool of a Global Traffic Manager (GTM) instance.
   * 
   * @param request - DescribeDnsGtmInstanceAddressPoolRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDnsGtmInstanceAddressPoolResponse
   */
  async describeDnsGtmInstanceAddressPoolWithOptions(request: DescribeDnsGtmInstanceAddressPoolRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDnsGtmInstanceAddressPoolResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.addrPoolId)) {
      query["AddrPoolId"] = request.addrPoolId;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDnsGtmInstanceAddressPool",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDnsGtmInstanceAddressPoolResponse>(await this.callApi(params, req, runtime), new DescribeDnsGtmInstanceAddressPoolResponse({}));
  }

  /**
   * Queries detailed information about an address pool of a Global Traffic Manager (GTM) instance.
   * 
   * @param request - DescribeDnsGtmInstanceAddressPoolRequest
   * @returns DescribeDnsGtmInstanceAddressPoolResponse
   */
  async describeDnsGtmInstanceAddressPool(request: DescribeDnsGtmInstanceAddressPoolRequest): Promise<DescribeDnsGtmInstanceAddressPoolResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDnsGtmInstanceAddressPoolWithOptions(request, runtime);
  }

  /**
   * Queries the address pools of a Global Traffic Manager (GTM) instance.
   * 
   * @param request - DescribeDnsGtmInstanceAddressPoolsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDnsGtmInstanceAddressPoolsResponse
   */
  async describeDnsGtmInstanceAddressPoolsWithOptions(request: DescribeDnsGtmInstanceAddressPoolsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDnsGtmInstanceAddressPoolsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDnsGtmInstanceAddressPools",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDnsGtmInstanceAddressPoolsResponse>(await this.callApi(params, req, runtime), new DescribeDnsGtmInstanceAddressPoolsResponse({}));
  }

  /**
   * Queries the address pools of a Global Traffic Manager (GTM) instance.
   * 
   * @param request - DescribeDnsGtmInstanceAddressPoolsRequest
   * @returns DescribeDnsGtmInstanceAddressPoolsResponse
   */
  async describeDnsGtmInstanceAddressPools(request: DescribeDnsGtmInstanceAddressPoolsRequest): Promise<DescribeDnsGtmInstanceAddressPoolsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDnsGtmInstanceAddressPoolsWithOptions(request, runtime);
  }

  /**
   * Queries the status of a Global Traffic Manager (GTM) instance.
   * 
   * @param request - DescribeDnsGtmInstanceStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDnsGtmInstanceStatusResponse
   */
  async describeDnsGtmInstanceStatusWithOptions(request: DescribeDnsGtmInstanceStatusRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDnsGtmInstanceStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDnsGtmInstanceStatus",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDnsGtmInstanceStatusResponse>(await this.callApi(params, req, runtime), new DescribeDnsGtmInstanceStatusResponse({}));
  }

  /**
   * Queries the status of a Global Traffic Manager (GTM) instance.
   * 
   * @param request - DescribeDnsGtmInstanceStatusRequest
   * @returns DescribeDnsGtmInstanceStatusResponse
   */
  async describeDnsGtmInstanceStatus(request: DescribeDnsGtmInstanceStatusRequest): Promise<DescribeDnsGtmInstanceStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDnsGtmInstanceStatusWithOptions(request, runtime);
  }

  /**
   * Queries the CNAME domain name assigned by the system for a Global Traffic Manager (GTM) instance.
   * 
   * @param request - DescribeDnsGtmInstanceSystemCnameRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDnsGtmInstanceSystemCnameResponse
   */
  async describeDnsGtmInstanceSystemCnameWithOptions(request: DescribeDnsGtmInstanceSystemCnameRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDnsGtmInstanceSystemCnameResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDnsGtmInstanceSystemCname",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDnsGtmInstanceSystemCnameResponse>(await this.callApi(params, req, runtime), new DescribeDnsGtmInstanceSystemCnameResponse({}));
  }

  /**
   * Queries the CNAME domain name assigned by the system for a Global Traffic Manager (GTM) instance.
   * 
   * @param request - DescribeDnsGtmInstanceSystemCnameRequest
   * @returns DescribeDnsGtmInstanceSystemCnameResponse
   */
  async describeDnsGtmInstanceSystemCname(request: DescribeDnsGtmInstanceSystemCnameRequest): Promise<DescribeDnsGtmInstanceSystemCnameResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDnsGtmInstanceSystemCnameWithOptions(request, runtime);
  }

  /**
   * @param request - DescribeDnsGtmInstancesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDnsGtmInstancesResponse
   */
  async describeDnsGtmInstancesWithOptions(request: DescribeDnsGtmInstancesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDnsGtmInstancesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.keyword)) {
      query["Keyword"] = request.keyword;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDnsGtmInstances",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDnsGtmInstancesResponse>(await this.callApi(params, req, runtime), new DescribeDnsGtmInstancesResponse({}));
  }

  /**
   * @param request - DescribeDnsGtmInstancesRequest
   * @returns DescribeDnsGtmInstancesResponse
   */
  async describeDnsGtmInstances(request: DescribeDnsGtmInstancesRequest): Promise<DescribeDnsGtmInstancesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDnsGtmInstancesWithOptions(request, runtime);
  }

  /**
   * Queries operation logs of a Global Traffic Manager (GTM) instance.
   * 
   * @param request - DescribeDnsGtmLogsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDnsGtmLogsResponse
   */
  async describeDnsGtmLogsWithOptions(request: DescribeDnsGtmLogsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDnsGtmLogsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTimestamp)) {
      query["EndTimestamp"] = request.endTimestamp;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.keyword)) {
      query["Keyword"] = request.keyword;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.startTimestamp)) {
      query["StartTimestamp"] = request.startTimestamp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDnsGtmLogs",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDnsGtmLogsResponse>(await this.callApi(params, req, runtime), new DescribeDnsGtmLogsResponse({}));
  }

  /**
   * Queries operation logs of a Global Traffic Manager (GTM) instance.
   * 
   * @param request - DescribeDnsGtmLogsRequest
   * @returns DescribeDnsGtmLogsResponse
   */
  async describeDnsGtmLogs(request: DescribeDnsGtmLogsRequest): Promise<DescribeDnsGtmLogsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDnsGtmLogsWithOptions(request, runtime);
  }

  /**
   * Queries available monitored nodes.
   * 
   * @param request - DescribeDnsGtmMonitorAvailableConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDnsGtmMonitorAvailableConfigResponse
   */
  async describeDnsGtmMonitorAvailableConfigWithOptions(request: DescribeDnsGtmMonitorAvailableConfigRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDnsGtmMonitorAvailableConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDnsGtmMonitorAvailableConfig",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDnsGtmMonitorAvailableConfigResponse>(await this.callApi(params, req, runtime), new DescribeDnsGtmMonitorAvailableConfigResponse({}));
  }

  /**
   * Queries available monitored nodes.
   * 
   * @param request - DescribeDnsGtmMonitorAvailableConfigRequest
   * @returns DescribeDnsGtmMonitorAvailableConfigResponse
   */
  async describeDnsGtmMonitorAvailableConfig(request: DescribeDnsGtmMonitorAvailableConfigRequest): Promise<DescribeDnsGtmMonitorAvailableConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDnsGtmMonitorAvailableConfigWithOptions(request, runtime);
  }

  /**
   * Queries the health check configurations of an address pool of a Global Traffic Manager (GTM) instance.
   * 
   * @param request - DescribeDnsGtmMonitorConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDnsGtmMonitorConfigResponse
   */
  async describeDnsGtmMonitorConfigWithOptions(request: DescribeDnsGtmMonitorConfigRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDnsGtmMonitorConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.monitorConfigId)) {
      query["MonitorConfigId"] = request.monitorConfigId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDnsGtmMonitorConfig",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDnsGtmMonitorConfigResponse>(await this.callApi(params, req, runtime), new DescribeDnsGtmMonitorConfigResponse({}));
  }

  /**
   * Queries the health check configurations of an address pool of a Global Traffic Manager (GTM) instance.
   * 
   * @param request - DescribeDnsGtmMonitorConfigRequest
   * @returns DescribeDnsGtmMonitorConfigResponse
   */
  async describeDnsGtmMonitorConfig(request: DescribeDnsGtmMonitorConfigRequest): Promise<DescribeDnsGtmMonitorConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDnsGtmMonitorConfigWithOptions(request, runtime);
  }

  /**
   * Queries the details about a paid Alibaba Cloud DNS instance based on the instance ID.
   * 
   * @param request - DescribeDnsProductInstanceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDnsProductInstanceResponse
   */
  async describeDnsProductInstanceWithOptions(request: DescribeDnsProductInstanceRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDnsProductInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.userClientIp)) {
      query["UserClientIp"] = request.userClientIp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDnsProductInstance",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDnsProductInstanceResponse>(await this.callApi(params, req, runtime), new DescribeDnsProductInstanceResponse({}));
  }

  /**
   * Queries the details about a paid Alibaba Cloud DNS instance based on the instance ID.
   * 
   * @param request - DescribeDnsProductInstanceRequest
   * @returns DescribeDnsProductInstanceResponse
   */
  async describeDnsProductInstance(request: DescribeDnsProductInstanceRequest): Promise<DescribeDnsProductInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDnsProductInstanceWithOptions(request, runtime);
  }

  /**
   * Calls the DescribeDnsProductInstances operation to query the list of paid Alibaba Cloud DNS instances based on input parameters.
   * 
   * @remarks
   * >  If the response parameters of an Alibaba Cloud DNS instance do not contain domain names, no domain names are bound to the instance.
   * 
   * @param request - DescribeDnsProductInstancesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDnsProductInstancesResponse
   */
  async describeDnsProductInstancesWithOptions(request: DescribeDnsProductInstancesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDnsProductInstancesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.direction)) {
      query["Direction"] = request.direction;
    }

    if (!Util.isUnset(request.domainType)) {
      query["DomainType"] = request.domainType;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.orderBy)) {
      query["OrderBy"] = request.orderBy;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.userClientIp)) {
      query["UserClientIp"] = request.userClientIp;
    }

    if (!Util.isUnset(request.versionCode)) {
      query["VersionCode"] = request.versionCode;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDnsProductInstances",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDnsProductInstancesResponse>(await this.callApi(params, req, runtime), new DescribeDnsProductInstancesResponse({}));
  }

  /**
   * Calls the DescribeDnsProductInstances operation to query the list of paid Alibaba Cloud DNS instances based on input parameters.
   * 
   * @remarks
   * >  If the response parameters of an Alibaba Cloud DNS instance do not contain domain names, no domain names are bound to the instance.
   * 
   * @param request - DescribeDnsProductInstancesRequest
   * @returns DescribeDnsProductInstancesResponse
   */
  async describeDnsProductInstances(request: DescribeDnsProductInstancesRequest): Promise<DescribeDnsProductInstancesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDnsProductInstancesWithOptions(request, runtime);
  }

  /**
   * @param request - DescribeDohAccountStatisticsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDohAccountStatisticsResponse
   */
  async describeDohAccountStatisticsWithOptions(request: DescribeDohAccountStatisticsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDohAccountStatisticsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endDate)) {
      query["EndDate"] = request.endDate;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.startDate)) {
      query["StartDate"] = request.startDate;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDohAccountStatistics",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDohAccountStatisticsResponse>(await this.callApi(params, req, runtime), new DescribeDohAccountStatisticsResponse({}));
  }

  /**
   * @param request - DescribeDohAccountStatisticsRequest
   * @returns DescribeDohAccountStatisticsResponse
   */
  async describeDohAccountStatistics(request: DescribeDohAccountStatisticsRequest): Promise<DescribeDohAccountStatisticsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDohAccountStatisticsWithOptions(request, runtime);
  }

  /**
   * @param request - DescribeDohDomainStatisticsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDohDomainStatisticsResponse
   */
  async describeDohDomainStatisticsWithOptions(request: DescribeDohDomainStatisticsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDohDomainStatisticsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endDate)) {
      query["EndDate"] = request.endDate;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.startDate)) {
      query["StartDate"] = request.startDate;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDohDomainStatistics",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDohDomainStatisticsResponse>(await this.callApi(params, req, runtime), new DescribeDohDomainStatisticsResponse({}));
  }

  /**
   * @param request - DescribeDohDomainStatisticsRequest
   * @returns DescribeDohDomainStatisticsResponse
   */
  async describeDohDomainStatistics(request: DescribeDohDomainStatisticsRequest): Promise<DescribeDohDomainStatisticsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDohDomainStatisticsWithOptions(request, runtime);
  }

  /**
   * @param request - DescribeDohDomainStatisticsSummaryRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDohDomainStatisticsSummaryResponse
   */
  async describeDohDomainStatisticsSummaryWithOptions(request: DescribeDohDomainStatisticsSummaryRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDohDomainStatisticsSummaryResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endDate)) {
      query["EndDate"] = request.endDate;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.startDate)) {
      query["StartDate"] = request.startDate;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDohDomainStatisticsSummary",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDohDomainStatisticsSummaryResponse>(await this.callApi(params, req, runtime), new DescribeDohDomainStatisticsSummaryResponse({}));
  }

  /**
   * @param request - DescribeDohDomainStatisticsSummaryRequest
   * @returns DescribeDohDomainStatisticsSummaryResponse
   */
  async describeDohDomainStatisticsSummary(request: DescribeDohDomainStatisticsSummaryRequest): Promise<DescribeDohDomainStatisticsSummaryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDohDomainStatisticsSummaryWithOptions(request, runtime);
  }

  /**
   * @param request - DescribeDohSubDomainStatisticsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDohSubDomainStatisticsResponse
   */
  async describeDohSubDomainStatisticsWithOptions(request: DescribeDohSubDomainStatisticsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDohSubDomainStatisticsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endDate)) {
      query["EndDate"] = request.endDate;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.startDate)) {
      query["StartDate"] = request.startDate;
    }

    if (!Util.isUnset(request.subDomain)) {
      query["SubDomain"] = request.subDomain;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDohSubDomainStatistics",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDohSubDomainStatisticsResponse>(await this.callApi(params, req, runtime), new DescribeDohSubDomainStatisticsResponse({}));
  }

  /**
   * @param request - DescribeDohSubDomainStatisticsRequest
   * @returns DescribeDohSubDomainStatisticsResponse
   */
  async describeDohSubDomainStatistics(request: DescribeDohSubDomainStatisticsRequest): Promise<DescribeDohSubDomainStatisticsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDohSubDomainStatisticsWithOptions(request, runtime);
  }

  /**
   * @param request - DescribeDohSubDomainStatisticsSummaryRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDohSubDomainStatisticsSummaryResponse
   */
  async describeDohSubDomainStatisticsSummaryWithOptions(request: DescribeDohSubDomainStatisticsSummaryRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDohSubDomainStatisticsSummaryResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endDate)) {
      query["EndDate"] = request.endDate;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.startDate)) {
      query["StartDate"] = request.startDate;
    }

    if (!Util.isUnset(request.subDomain)) {
      query["SubDomain"] = request.subDomain;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDohSubDomainStatisticsSummary",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDohSubDomainStatisticsSummaryResponse>(await this.callApi(params, req, runtime), new DescribeDohSubDomainStatisticsSummaryResponse({}));
  }

  /**
   * @param request - DescribeDohSubDomainStatisticsSummaryRequest
   * @returns DescribeDohSubDomainStatisticsSummaryResponse
   */
  async describeDohSubDomainStatisticsSummary(request: DescribeDohSubDomainStatisticsSummaryRequest): Promise<DescribeDohSubDomainStatisticsSummaryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDohSubDomainStatisticsSummaryWithOptions(request, runtime);
  }

  /**
   * Queries the numbers of accessed domains and subdomains by using DNS over HTTPS (DoH).
   * 
   * @param request - DescribeDohUserInfoRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDohUserInfoResponse
   */
  async describeDohUserInfoWithOptions(request: DescribeDohUserInfoRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDohUserInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endDate)) {
      query["EndDate"] = request.endDate;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.startDate)) {
      query["StartDate"] = request.startDate;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDohUserInfo",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDohUserInfoResponse>(await this.callApi(params, req, runtime), new DescribeDohUserInfoResponse({}));
  }

  /**
   * Queries the numbers of accessed domains and subdomains by using DNS over HTTPS (DoH).
   * 
   * @param request - DescribeDohUserInfoRequest
   * @returns DescribeDohUserInfoResponse
   */
  async describeDohUserInfo(request: DescribeDohUserInfoRequest): Promise<DescribeDohUserInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDohUserInfoWithOptions(request, runtime);
  }

  /**
   * Queries the Domain Name System Security Extensions (DNSSEC) configurations of a domain name based on the specified parameters.
   * 
   * @param request - DescribeDomainDnssecInfoRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDomainDnssecInfoResponse
   */
  async describeDomainDnssecInfoWithOptions(request: DescribeDomainDnssecInfoRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDomainDnssecInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDomainDnssecInfo",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDomainDnssecInfoResponse>(await this.callApi(params, req, runtime), new DescribeDomainDnssecInfoResponse({}));
  }

  /**
   * Queries the Domain Name System Security Extensions (DNSSEC) configurations of a domain name based on the specified parameters.
   * 
   * @param request - DescribeDomainDnssecInfoRequest
   * @returns DescribeDomainDnssecInfoResponse
   */
  async describeDomainDnssecInfo(request: DescribeDomainDnssecInfoRequest): Promise<DescribeDomainDnssecInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDomainDnssecInfoWithOptions(request, runtime);
  }

  /**
   * Queries all domain name groups based on the specified parameters.
   * 
   * @param request - DescribeDomainGroupsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDomainGroupsResponse
   */
  async describeDomainGroupsWithOptions(request: DescribeDomainGroupsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDomainGroupsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.keyWord)) {
      query["KeyWord"] = request.keyWord;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDomainGroups",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDomainGroupsResponse>(await this.callApi(params, req, runtime), new DescribeDomainGroupsResponse({}));
  }

  /**
   * Queries all domain name groups based on the specified parameters.
   * 
   * @param request - DescribeDomainGroupsRequest
   * @returns DescribeDomainGroupsResponse
   */
  async describeDomainGroups(request: DescribeDomainGroupsRequest): Promise<DescribeDomainGroupsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDomainGroupsWithOptions(request, runtime);
  }

  /**
   * Queries the information about a domain name based on specified parameters.
   * 
   * @remarks
   * In this example, the domain name is bound to an instance of Alibaba Cloud DNS Enterprise Ultimate Edition. For more information about valid Domain Name System (DNS) request lines, see the return values of the RecordLines parameter.
   * 
   * @param request - DescribeDomainInfoRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDomainInfoResponse
   */
  async describeDomainInfoWithOptions(request: DescribeDomainInfoRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDomainInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.needDetailAttributes)) {
      query["NeedDetailAttributes"] = request.needDetailAttributes;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDomainInfo",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDomainInfoResponse>(await this.callApi(params, req, runtime), new DescribeDomainInfoResponse({}));
  }

  /**
   * Queries the information about a domain name based on specified parameters.
   * 
   * @remarks
   * In this example, the domain name is bound to an instance of Alibaba Cloud DNS Enterprise Ultimate Edition. For more information about valid Domain Name System (DNS) request lines, see the return values of the RecordLines parameter.
   * 
   * @param request - DescribeDomainInfoRequest
   * @returns DescribeDomainInfoResponse
   */
  async describeDomainInfo(request: DescribeDomainInfoRequest): Promise<DescribeDomainInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDomainInfoWithOptions(request, runtime);
  }

  /**
   * Queries the operation logs of domain names based on the specified parameters.
   * 
   * @param request - DescribeDomainLogsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDomainLogsResponse
   */
  async describeDomainLogsWithOptions(request: DescribeDomainLogsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDomainLogsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.keyWord)) {
      query["KeyWord"] = request.keyWord;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.startDate)) {
      query["StartDate"] = request.startDate;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    if (!Util.isUnset(request.endDate)) {
      query["endDate"] = request.endDate;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDomainLogs",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDomainLogsResponse>(await this.callApi(params, req, runtime), new DescribeDomainLogsResponse({}));
  }

  /**
   * Queries the operation logs of domain names based on the specified parameters.
   * 
   * @param request - DescribeDomainLogsRequest
   * @returns DescribeDomainLogsResponse
   */
  async describeDomainLogs(request: DescribeDomainLogsRequest): Promise<DescribeDomainLogsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDomainLogsWithOptions(request, runtime);
  }

  /**
   * Queries the name servers configured for a specified domain name and checks whether all the name servers are Alibaba Cloud Domain Name System (DNS) servers.
   * 
   * @remarks
   * >  You can call this operation to query the authoritative servers of a domain name registry to obtain the name servers for a domain name. If the domain name is in an invalid state, such as serverHold or clientHold, an error may be returned.
   * 
   * @param request - DescribeDomainNsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDomainNsResponse
   */
  async describeDomainNsWithOptions(request: DescribeDomainNsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDomainNsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDomainNs",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDomainNsResponse>(await this.callApi(params, req, runtime), new DescribeDomainNsResponse({}));
  }

  /**
   * Queries the name servers configured for a specified domain name and checks whether all the name servers are Alibaba Cloud Domain Name System (DNS) servers.
   * 
   * @remarks
   * >  You can call this operation to query the authoritative servers of a domain name registry to obtain the name servers for a domain name. If the domain name is in an invalid state, such as serverHold or clientHold, an error may be returned.
   * 
   * @param request - DescribeDomainNsRequest
   * @returns DescribeDomainNsResponse
   */
  async describeDomainNs(request: DescribeDomainNsRequest): Promise<DescribeDomainNsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDomainNsWithOptions(request, runtime);
  }

  /**
   * Queries the information about a Domain Name System (DNS) record.
   * 
   * @remarks
   * ## Debugging
   * [OpenAPI Explorer automatically calculates the signature value. For your convenience, we recommend that you call this operation in OpenAPI Explorer. OpenAPI Explorer dynamically generates the sample code of the operation for different SDKs.](https://api.aliyun.com/#product=Alidns\\&api=DescribeDomainRecordInfo\\&type=RPC\\&version=2015-01-09)
   * 
   * @param request - DescribeDomainRecordInfoRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDomainRecordInfoResponse
   */
  async describeDomainRecordInfoWithOptions(request: DescribeDomainRecordInfoRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDomainRecordInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.recordId)) {
      query["RecordId"] = request.recordId;
    }

    if (!Util.isUnset(request.userClientIp)) {
      query["UserClientIp"] = request.userClientIp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDomainRecordInfo",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDomainRecordInfoResponse>(await this.callApi(params, req, runtime), new DescribeDomainRecordInfoResponse({}));
  }

  /**
   * Queries the information about a Domain Name System (DNS) record.
   * 
   * @remarks
   * ## Debugging
   * [OpenAPI Explorer automatically calculates the signature value. For your convenience, we recommend that you call this operation in OpenAPI Explorer. OpenAPI Explorer dynamically generates the sample code of the operation for different SDKs.](https://api.aliyun.com/#product=Alidns\\&api=DescribeDomainRecordInfo\\&type=RPC\\&version=2015-01-09)
   * 
   * @param request - DescribeDomainRecordInfoRequest
   * @returns DescribeDomainRecordInfoResponse
   */
  async describeDomainRecordInfo(request: DescribeDomainRecordInfoRequest): Promise<DescribeDomainRecordInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDomainRecordInfoWithOptions(request, runtime);
  }

  /**
   * Queries all Domain Name System (DNS) records of the specified primary domain names based on the specified parameters.
   * 
   * @remarks
   *   You can specify DomainName, PageNumber, and PageSize to query the DNS records of the specified domain names.
   * *   You can also specify RRKeyWord, TypeKeyWord, or ValueKeyWord to query the DNS records that contain the specified keyword.
   * *   By default, the DNS records are sorted in reverse chronological order based on the time when they were added.
   * *   You can specify GroupId to query the DNS records of the specified domain names based on the group ID. You can query the DNS records of all domain names and the domain names in the default group.
   * 
   * @param request - DescribeDomainRecordsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDomainRecordsResponse
   */
  async describeDomainRecordsWithOptions(request: DescribeDomainRecordsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDomainRecordsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.direction)) {
      query["Direction"] = request.direction;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.keyWord)) {
      query["KeyWord"] = request.keyWord;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.line)) {
      query["Line"] = request.line;
    }

    if (!Util.isUnset(request.orderBy)) {
      query["OrderBy"] = request.orderBy;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.RRKeyWord)) {
      query["RRKeyWord"] = request.RRKeyWord;
    }

    if (!Util.isUnset(request.searchMode)) {
      query["SearchMode"] = request.searchMode;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    if (!Util.isUnset(request.typeKeyWord)) {
      query["TypeKeyWord"] = request.typeKeyWord;
    }

    if (!Util.isUnset(request.valueKeyWord)) {
      query["ValueKeyWord"] = request.valueKeyWord;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDomainRecords",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDomainRecordsResponse>(await this.callApi(params, req, runtime), new DescribeDomainRecordsResponse({}));
  }

  /**
   * Queries all Domain Name System (DNS) records of the specified primary domain names based on the specified parameters.
   * 
   * @remarks
   *   You can specify DomainName, PageNumber, and PageSize to query the DNS records of the specified domain names.
   * *   You can also specify RRKeyWord, TypeKeyWord, or ValueKeyWord to query the DNS records that contain the specified keyword.
   * *   By default, the DNS records are sorted in reverse chronological order based on the time when they were added.
   * *   You can specify GroupId to query the DNS records of the specified domain names based on the group ID. You can query the DNS records of all domain names and the domain names in the default group.
   * 
   * @param request - DescribeDomainRecordsRequest
   * @returns DescribeDomainRecordsResponse
   */
  async describeDomainRecords(request: DescribeDomainRecordsRequest): Promise<DescribeDomainRecordsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDomainRecordsWithOptions(request, runtime);
  }

  /**
   * Queries the resolution requests of all paid domain names within your account.
   * 
   * @param request - DescribeDomainResolveStatisticsSummaryRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDomainResolveStatisticsSummaryResponse
   */
  async describeDomainResolveStatisticsSummaryWithOptions(request: DescribeDomainResolveStatisticsSummaryRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDomainResolveStatisticsSummaryResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.direction)) {
      query["Direction"] = request.direction;
    }

    if (!Util.isUnset(request.endDate)) {
      query["EndDate"] = request.endDate;
    }

    if (!Util.isUnset(request.keyword)) {
      query["Keyword"] = request.keyword;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.searchMode)) {
      query["SearchMode"] = request.searchMode;
    }

    if (!Util.isUnset(request.startDate)) {
      query["StartDate"] = request.startDate;
    }

    if (!Util.isUnset(request.threshold)) {
      query["Threshold"] = request.threshold;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDomainResolveStatisticsSummary",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDomainResolveStatisticsSummaryResponse>(await this.callApi(params, req, runtime), new DescribeDomainResolveStatisticsSummaryResponse({}));
  }

  /**
   * Queries the resolution requests of all paid domain names within your account.
   * 
   * @param request - DescribeDomainResolveStatisticsSummaryRequest
   * @returns DescribeDomainResolveStatisticsSummaryResponse
   */
  async describeDomainResolveStatisticsSummary(request: DescribeDomainResolveStatisticsSummaryRequest): Promise<DescribeDomainResolveStatisticsSummaryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDomainResolveStatisticsSummaryWithOptions(request, runtime);
  }

  /**
   * Queries the real-time statistics on the Domain Name System (DNS) requests for a primary domain name.
   * 
   * @remarks
   * Real-time data is collected per hour.
   * 
   * @param request - DescribeDomainStatisticsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDomainStatisticsResponse
   */
  async describeDomainStatisticsWithOptions(request: DescribeDomainStatisticsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDomainStatisticsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.domainType)) {
      query["DomainType"] = request.domainType;
    }

    if (!Util.isUnset(request.endDate)) {
      query["EndDate"] = request.endDate;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.startDate)) {
      query["StartDate"] = request.startDate;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDomainStatistics",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDomainStatisticsResponse>(await this.callApi(params, req, runtime), new DescribeDomainStatisticsResponse({}));
  }

  /**
   * Queries the real-time statistics on the Domain Name System (DNS) requests for a primary domain name.
   * 
   * @remarks
   * Real-time data is collected per hour.
   * 
   * @param request - DescribeDomainStatisticsRequest
   * @returns DescribeDomainStatisticsResponse
   */
  async describeDomainStatistics(request: DescribeDomainStatisticsRequest): Promise<DescribeDomainStatisticsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDomainStatisticsWithOptions(request, runtime);
  }

  /**
   * Calls the DescribeDomainStatisticsSummary operation to obtain the query volume of all paid domain names under your account.
   * 
   * @param request - DescribeDomainStatisticsSummaryRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDomainStatisticsSummaryResponse
   */
  async describeDomainStatisticsSummaryWithOptions(request: DescribeDomainStatisticsSummaryRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDomainStatisticsSummaryResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endDate)) {
      query["EndDate"] = request.endDate;
    }

    if (!Util.isUnset(request.keyword)) {
      query["Keyword"] = request.keyword;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.searchMode)) {
      query["SearchMode"] = request.searchMode;
    }

    if (!Util.isUnset(request.startDate)) {
      query["StartDate"] = request.startDate;
    }

    if (!Util.isUnset(request.threshold)) {
      query["Threshold"] = request.threshold;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDomainStatisticsSummary",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDomainStatisticsSummaryResponse>(await this.callApi(params, req, runtime), new DescribeDomainStatisticsSummaryResponse({}));
  }

  /**
   * Calls the DescribeDomainStatisticsSummary operation to obtain the query volume of all paid domain names under your account.
   * 
   * @param request - DescribeDomainStatisticsSummaryRequest
   * @returns DescribeDomainStatisticsSummaryResponse
   */
  async describeDomainStatisticsSummary(request: DescribeDomainStatisticsSummaryRequest): Promise<DescribeDomainStatisticsSummaryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDomainStatisticsSummaryWithOptions(request, runtime);
  }

  /**
   * Calls the DescribeDomains operation to query domain names of a user based on input parameters.
   * 
   * @remarks
   *   You can specify the PageNumber and PageSize parameters to query domain names.
   * *   You can specify the KeyWord parameter to query domain names that contain the specified keyword.
   * *   By default, the domain names in a list are sorted in descending order of the time they were added.
   * *   You can specify the GroupId parameter. If you do not specify this parameter, all domain names are queried by default.
   * 
   * @param request - DescribeDomainsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDomainsResponse
   */
  async describeDomainsWithOptions(request: DescribeDomainsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDomainsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.keyWord)) {
      query["KeyWord"] = request.keyWord;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.searchMode)) {
      query["SearchMode"] = request.searchMode;
    }

    if (!Util.isUnset(request.starmark)) {
      query["Starmark"] = request.starmark;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDomains",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDomainsResponse>(await this.callApi(params, req, runtime), new DescribeDomainsResponse({}));
  }

  /**
   * Calls the DescribeDomains operation to query domain names of a user based on input parameters.
   * 
   * @remarks
   *   You can specify the PageNumber and PageSize parameters to query domain names.
   * *   You can specify the KeyWord parameter to query domain names that contain the specified keyword.
   * *   By default, the domain names in a list are sorted in descending order of the time they were added.
   * *   You can specify the GroupId parameter. If you do not specify this parameter, all domain names are queried by default.
   * 
   * @param request - DescribeDomainsRequest
   * @returns DescribeDomainsResponse
   */
  async describeDomains(request: DescribeDomainsRequest): Promise<DescribeDomainsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDomainsWithOptions(request, runtime);
  }

  /**
   * You can call this operation to query the access policies of a Global Traffic Manager (GTM) instance.
   * 
   * @param request - DescribeGtmAccessStrategiesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeGtmAccessStrategiesResponse
   */
  async describeGtmAccessStrategiesWithOptions(request: DescribeGtmAccessStrategiesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeGtmAccessStrategiesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeGtmAccessStrategies",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeGtmAccessStrategiesResponse>(await this.callApi(params, req, runtime), new DescribeGtmAccessStrategiesResponse({}));
  }

  /**
   * You can call this operation to query the access policies of a Global Traffic Manager (GTM) instance.
   * 
   * @param request - DescribeGtmAccessStrategiesRequest
   * @returns DescribeGtmAccessStrategiesResponse
   */
  async describeGtmAccessStrategies(request: DescribeGtmAccessStrategiesRequest): Promise<DescribeGtmAccessStrategiesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeGtmAccessStrategiesWithOptions(request, runtime);
  }

  /**
   * You can call this operation to query the details about an access policy of a Global Traffic Manager (GTM) instance based on the policy ID.
   * 
   * @param request - DescribeGtmAccessStrategyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeGtmAccessStrategyResponse
   */
  async describeGtmAccessStrategyWithOptions(request: DescribeGtmAccessStrategyRequest, runtime: $Util.RuntimeOptions): Promise<DescribeGtmAccessStrategyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.strategyId)) {
      query["StrategyId"] = request.strategyId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeGtmAccessStrategy",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeGtmAccessStrategyResponse>(await this.callApi(params, req, runtime), new DescribeGtmAccessStrategyResponse({}));
  }

  /**
   * You can call this operation to query the details about an access policy of a Global Traffic Manager (GTM) instance based on the policy ID.
   * 
   * @param request - DescribeGtmAccessStrategyRequest
   * @returns DescribeGtmAccessStrategyResponse
   */
  async describeGtmAccessStrategy(request: DescribeGtmAccessStrategyRequest): Promise<DescribeGtmAccessStrategyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeGtmAccessStrategyWithOptions(request, runtime);
  }

  /**
   * Queries the configuration items that can be set for an access policy.
   * 
   * @param request - DescribeGtmAccessStrategyAvailableConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeGtmAccessStrategyAvailableConfigResponse
   */
  async describeGtmAccessStrategyAvailableConfigWithOptions(request: DescribeGtmAccessStrategyAvailableConfigRequest, runtime: $Util.RuntimeOptions): Promise<DescribeGtmAccessStrategyAvailableConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeGtmAccessStrategyAvailableConfig",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeGtmAccessStrategyAvailableConfigResponse>(await this.callApi(params, req, runtime), new DescribeGtmAccessStrategyAvailableConfigResponse({}));
  }

  /**
   * Queries the configuration items that can be set for an access policy.
   * 
   * @param request - DescribeGtmAccessStrategyAvailableConfigRequest
   * @returns DescribeGtmAccessStrategyAvailableConfigResponse
   */
  async describeGtmAccessStrategyAvailableConfig(request: DescribeGtmAccessStrategyAvailableConfigRequest): Promise<DescribeGtmAccessStrategyAvailableConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeGtmAccessStrategyAvailableConfigWithOptions(request, runtime);
  }

  /**
   * @param request - DescribeGtmAvailableAlertGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeGtmAvailableAlertGroupResponse
   */
  async describeGtmAvailableAlertGroupWithOptions(request: DescribeGtmAvailableAlertGroupRequest, runtime: $Util.RuntimeOptions): Promise<DescribeGtmAvailableAlertGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeGtmAvailableAlertGroup",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeGtmAvailableAlertGroupResponse>(await this.callApi(params, req, runtime), new DescribeGtmAvailableAlertGroupResponse({}));
  }

  /**
   * @param request - DescribeGtmAvailableAlertGroupRequest
   * @returns DescribeGtmAvailableAlertGroupResponse
   */
  async describeGtmAvailableAlertGroup(request: DescribeGtmAvailableAlertGroupRequest): Promise<DescribeGtmAvailableAlertGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeGtmAvailableAlertGroupWithOptions(request, runtime);
  }

  /**
   * Queries the details about a Global Traffic Manager (GTM) instance.
   * 
   * @param request - DescribeGtmInstanceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeGtmInstanceResponse
   */
  async describeGtmInstanceWithOptions(request: DescribeGtmInstanceRequest, runtime: $Util.RuntimeOptions): Promise<DescribeGtmInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.needDetailAttributes)) {
      query["NeedDetailAttributes"] = request.needDetailAttributes;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeGtmInstance",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeGtmInstanceResponse>(await this.callApi(params, req, runtime), new DescribeGtmInstanceResponse({}));
  }

  /**
   * Queries the details about a Global Traffic Manager (GTM) instance.
   * 
   * @param request - DescribeGtmInstanceRequest
   * @returns DescribeGtmInstanceResponse
   */
  async describeGtmInstance(request: DescribeGtmInstanceRequest): Promise<DescribeGtmInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeGtmInstanceWithOptions(request, runtime);
  }

  /**
   * You can call this operation to query the details about an address pool of a Global Traffic Manager (GTM) instance.
   * 
   * @param request - DescribeGtmInstanceAddressPoolRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeGtmInstanceAddressPoolResponse
   */
  async describeGtmInstanceAddressPoolWithOptions(request: DescribeGtmInstanceAddressPoolRequest, runtime: $Util.RuntimeOptions): Promise<DescribeGtmInstanceAddressPoolResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.addrPoolId)) {
      query["AddrPoolId"] = request.addrPoolId;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeGtmInstanceAddressPool",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeGtmInstanceAddressPoolResponse>(await this.callApi(params, req, runtime), new DescribeGtmInstanceAddressPoolResponse({}));
  }

  /**
   * You can call this operation to query the details about an address pool of a Global Traffic Manager (GTM) instance.
   * 
   * @param request - DescribeGtmInstanceAddressPoolRequest
   * @returns DescribeGtmInstanceAddressPoolResponse
   */
  async describeGtmInstanceAddressPool(request: DescribeGtmInstanceAddressPoolRequest): Promise<DescribeGtmInstanceAddressPoolResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeGtmInstanceAddressPoolWithOptions(request, runtime);
  }

  /**
   * You can call this operation to query the address pools of a Global Traffic Manager (GTM) instance.
   * 
   * @param request - DescribeGtmInstanceAddressPoolsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeGtmInstanceAddressPoolsResponse
   */
  async describeGtmInstanceAddressPoolsWithOptions(request: DescribeGtmInstanceAddressPoolsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeGtmInstanceAddressPoolsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeGtmInstanceAddressPools",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeGtmInstanceAddressPoolsResponse>(await this.callApi(params, req, runtime), new DescribeGtmInstanceAddressPoolsResponse({}));
  }

  /**
   * You can call this operation to query the address pools of a Global Traffic Manager (GTM) instance.
   * 
   * @param request - DescribeGtmInstanceAddressPoolsRequest
   * @returns DescribeGtmInstanceAddressPoolsResponse
   */
  async describeGtmInstanceAddressPools(request: DescribeGtmInstanceAddressPoolsRequest): Promise<DescribeGtmInstanceAddressPoolsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeGtmInstanceAddressPoolsWithOptions(request, runtime);
  }

  /**
   * Queries the current status of a Global Traffic Manager (GTM) instance.
   * 
   * @param request - DescribeGtmInstanceStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeGtmInstanceStatusResponse
   */
  async describeGtmInstanceStatusWithOptions(request: DescribeGtmInstanceStatusRequest, runtime: $Util.RuntimeOptions): Promise<DescribeGtmInstanceStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeGtmInstanceStatus",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeGtmInstanceStatusResponse>(await this.callApi(params, req, runtime), new DescribeGtmInstanceStatusResponse({}));
  }

  /**
   * Queries the current status of a Global Traffic Manager (GTM) instance.
   * 
   * @param request - DescribeGtmInstanceStatusRequest
   * @returns DescribeGtmInstanceStatusResponse
   */
  async describeGtmInstanceStatus(request: DescribeGtmInstanceStatusRequest): Promise<DescribeGtmInstanceStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeGtmInstanceStatusWithOptions(request, runtime);
  }

  /**
   * @param request - DescribeGtmInstanceSystemCnameRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeGtmInstanceSystemCnameResponse
   */
  async describeGtmInstanceSystemCnameWithOptions(request: DescribeGtmInstanceSystemCnameRequest, runtime: $Util.RuntimeOptions): Promise<DescribeGtmInstanceSystemCnameResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeGtmInstanceSystemCname",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeGtmInstanceSystemCnameResponse>(await this.callApi(params, req, runtime), new DescribeGtmInstanceSystemCnameResponse({}));
  }

  /**
   * @param request - DescribeGtmInstanceSystemCnameRequest
   * @returns DescribeGtmInstanceSystemCnameResponse
   */
  async describeGtmInstanceSystemCname(request: DescribeGtmInstanceSystemCnameRequest): Promise<DescribeGtmInstanceSystemCnameResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeGtmInstanceSystemCnameWithOptions(request, runtime);
  }

  /**
   * Queries the Global Traffic Manager (GTM) instances under your account.
   * 
   * @param request - DescribeGtmInstancesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeGtmInstancesResponse
   */
  async describeGtmInstancesWithOptions(request: DescribeGtmInstancesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeGtmInstancesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.keyword)) {
      query["Keyword"] = request.keyword;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.needDetailAttributes)) {
      query["NeedDetailAttributes"] = request.needDetailAttributes;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeGtmInstances",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeGtmInstancesResponse>(await this.callApi(params, req, runtime), new DescribeGtmInstancesResponse({}));
  }

  /**
   * Queries the Global Traffic Manager (GTM) instances under your account.
   * 
   * @param request - DescribeGtmInstancesRequest
   * @returns DescribeGtmInstancesResponse
   */
  async describeGtmInstances(request: DescribeGtmInstancesRequest): Promise<DescribeGtmInstancesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeGtmInstancesWithOptions(request, runtime);
  }

  /**
   * You can call this operation to query logs of a Global Traffic Manager (GTM) instance.
   * 
   * @param request - DescribeGtmLogsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeGtmLogsResponse
   */
  async describeGtmLogsWithOptions(request: DescribeGtmLogsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeGtmLogsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTimestamp)) {
      query["EndTimestamp"] = request.endTimestamp;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.keyword)) {
      query["Keyword"] = request.keyword;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.startTimestamp)) {
      query["StartTimestamp"] = request.startTimestamp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeGtmLogs",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeGtmLogsResponse>(await this.callApi(params, req, runtime), new DescribeGtmLogsResponse({}));
  }

  /**
   * You can call this operation to query logs of a Global Traffic Manager (GTM) instance.
   * 
   * @param request - DescribeGtmLogsRequest
   * @returns DescribeGtmLogsResponse
   */
  async describeGtmLogs(request: DescribeGtmLogsRequest): Promise<DescribeGtmLogsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeGtmLogsWithOptions(request, runtime);
  }

  /**
   * Queries available monitored nodes.
   * 
   * @param request - DescribeGtmMonitorAvailableConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeGtmMonitorAvailableConfigResponse
   */
  async describeGtmMonitorAvailableConfigWithOptions(request: DescribeGtmMonitorAvailableConfigRequest, runtime: $Util.RuntimeOptions): Promise<DescribeGtmMonitorAvailableConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeGtmMonitorAvailableConfig",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeGtmMonitorAvailableConfigResponse>(await this.callApi(params, req, runtime), new DescribeGtmMonitorAvailableConfigResponse({}));
  }

  /**
   * Queries available monitored nodes.
   * 
   * @param request - DescribeGtmMonitorAvailableConfigRequest
   * @returns DescribeGtmMonitorAvailableConfigResponse
   */
  async describeGtmMonitorAvailableConfig(request: DescribeGtmMonitorAvailableConfigRequest): Promise<DescribeGtmMonitorAvailableConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeGtmMonitorAvailableConfigWithOptions(request, runtime);
  }

  /**
   * Queries the health check configuration of an address pool of a Global Traffic Manager (GTM) instance.
   * 
   * @param request - DescribeGtmMonitorConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeGtmMonitorConfigResponse
   */
  async describeGtmMonitorConfigWithOptions(request: DescribeGtmMonitorConfigRequest, runtime: $Util.RuntimeOptions): Promise<DescribeGtmMonitorConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.monitorConfigId)) {
      query["MonitorConfigId"] = request.monitorConfigId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeGtmMonitorConfig",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeGtmMonitorConfigResponse>(await this.callApi(params, req, runtime), new DescribeGtmMonitorConfigResponse({}));
  }

  /**
   * Queries the health check configuration of an address pool of a Global Traffic Manager (GTM) instance.
   * 
   * @param request - DescribeGtmMonitorConfigRequest
   * @returns DescribeGtmMonitorConfigResponse
   */
  async describeGtmMonitorConfig(request: DescribeGtmMonitorConfigRequest): Promise<DescribeGtmMonitorConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeGtmMonitorConfigWithOptions(request, runtime);
  }

  /**
   * You can call this operation to query the detailed information of a disaster recovery plan for a Global Traffic Manager (GTM) instance.
   * 
   * @param request - DescribeGtmRecoveryPlanRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeGtmRecoveryPlanResponse
   */
  async describeGtmRecoveryPlanWithOptions(request: DescribeGtmRecoveryPlanRequest, runtime: $Util.RuntimeOptions): Promise<DescribeGtmRecoveryPlanResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.recoveryPlanId)) {
      query["RecoveryPlanId"] = request.recoveryPlanId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeGtmRecoveryPlan",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeGtmRecoveryPlanResponse>(await this.callApi(params, req, runtime), new DescribeGtmRecoveryPlanResponse({}));
  }

  /**
   * You can call this operation to query the detailed information of a disaster recovery plan for a Global Traffic Manager (GTM) instance.
   * 
   * @param request - DescribeGtmRecoveryPlanRequest
   * @returns DescribeGtmRecoveryPlanResponse
   */
  async describeGtmRecoveryPlan(request: DescribeGtmRecoveryPlanRequest): Promise<DescribeGtmRecoveryPlanResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeGtmRecoveryPlanWithOptions(request, runtime);
  }

  /**
   * You can call this operation to query the available configurations of a disaster recovery plan of a Global Traffic Manager (GTM) instance.
   * 
   * @param request - DescribeGtmRecoveryPlanAvailableConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeGtmRecoveryPlanAvailableConfigResponse
   */
  async describeGtmRecoveryPlanAvailableConfigWithOptions(request: DescribeGtmRecoveryPlanAvailableConfigRequest, runtime: $Util.RuntimeOptions): Promise<DescribeGtmRecoveryPlanAvailableConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeGtmRecoveryPlanAvailableConfig",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeGtmRecoveryPlanAvailableConfigResponse>(await this.callApi(params, req, runtime), new DescribeGtmRecoveryPlanAvailableConfigResponse({}));
  }

  /**
   * You can call this operation to query the available configurations of a disaster recovery plan of a Global Traffic Manager (GTM) instance.
   * 
   * @param request - DescribeGtmRecoveryPlanAvailableConfigRequest
   * @returns DescribeGtmRecoveryPlanAvailableConfigResponse
   */
  async describeGtmRecoveryPlanAvailableConfig(request: DescribeGtmRecoveryPlanAvailableConfigRequest): Promise<DescribeGtmRecoveryPlanAvailableConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeGtmRecoveryPlanAvailableConfigWithOptions(request, runtime);
  }

  /**
   * Queries the disaster recovery plans for a Global Traffic Manager (GTM) instance.
   * 
   * @param request - DescribeGtmRecoveryPlansRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeGtmRecoveryPlansResponse
   */
  async describeGtmRecoveryPlansWithOptions(request: DescribeGtmRecoveryPlansRequest, runtime: $Util.RuntimeOptions): Promise<DescribeGtmRecoveryPlansResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.keyword)) {
      query["Keyword"] = request.keyword;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeGtmRecoveryPlans",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeGtmRecoveryPlansResponse>(await this.callApi(params, req, runtime), new DescribeGtmRecoveryPlansResponse({}));
  }

  /**
   * Queries the disaster recovery plans for a Global Traffic Manager (GTM) instance.
   * 
   * @param request - DescribeGtmRecoveryPlansRequest
   * @returns DescribeGtmRecoveryPlansResponse
   */
  async describeGtmRecoveryPlans(request: DescribeGtmRecoveryPlansRequest): Promise<DescribeGtmRecoveryPlansResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeGtmRecoveryPlansWithOptions(request, runtime);
  }

  /**
   * Queries the domain names that are bound to an Alibaba Cloud DNS instance.
   * 
   * @param request - DescribeInstanceDomainsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeInstanceDomainsResponse
   */
  async describeInstanceDomainsWithOptions(request: DescribeInstanceDomainsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeInstanceDomainsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeInstanceDomains",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeInstanceDomainsResponse>(await this.callApi(params, req, runtime), new DescribeInstanceDomainsResponse({}));
  }

  /**
   * Queries the domain names that are bound to an Alibaba Cloud DNS instance.
   * 
   * @param request - DescribeInstanceDomainsRequest
   * @returns DescribeInstanceDomainsResponse
   */
  async describeInstanceDomains(request: DescribeInstanceDomainsRequest): Promise<DescribeInstanceDomainsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeInstanceDomainsWithOptions(request, runtime);
  }

  /**
   * @param request - DescribeInternetDnsLogsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeInternetDnsLogsResponse
   */
  async describeInternetDnsLogsWithOptions(request: DescribeInternetDnsLogsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeInternetDnsLogsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.accountId)) {
      query["AccountId"] = request.accountId;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTimestamp)) {
      query["EndTimestamp"] = request.endTimestamp;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.module)) {
      query["Module"] = request.module;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.queryCondition)) {
      query["QueryCondition"] = request.queryCondition;
    }

    if (!Util.isUnset(request.startTimestamp)) {
      query["StartTimestamp"] = request.startTimestamp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeInternetDnsLogs",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeInternetDnsLogsResponse>(await this.callApi(params, req, runtime), new DescribeInternetDnsLogsResponse({}));
  }

  /**
   * @param request - DescribeInternetDnsLogsRequest
   * @returns DescribeInternetDnsLogsResponse
   */
  async describeInternetDnsLogs(request: DescribeInternetDnsLogsRequest): Promise<DescribeInternetDnsLogsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeInternetDnsLogsWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - DescribeIspFlushCacheInstancesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeIspFlushCacheInstancesResponse
   */
  async describeIspFlushCacheInstancesWithOptions(request: DescribeIspFlushCacheInstancesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeIspFlushCacheInstancesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.direction)) {
      query["Direction"] = request.direction;
    }

    if (!Util.isUnset(request.isp)) {
      query["Isp"] = request.isp;
    }

    if (!Util.isUnset(request.keyword)) {
      query["Keyword"] = request.keyword;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.orderBy)) {
      query["OrderBy"] = request.orderBy;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeIspFlushCacheInstances",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeIspFlushCacheInstancesResponse>(await this.callApi(params, req, runtime), new DescribeIspFlushCacheInstancesResponse({}));
  }

  /**
   * 
   * 
   * @param request - DescribeIspFlushCacheInstancesRequest
   * @returns DescribeIspFlushCacheInstancesResponse
   */
  async describeIspFlushCacheInstances(request: DescribeIspFlushCacheInstancesRequest): Promise<DescribeIspFlushCacheInstancesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeIspFlushCacheInstancesWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - DescribeIspFlushCacheRemainQuotaRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeIspFlushCacheRemainQuotaResponse
   */
  async describeIspFlushCacheRemainQuotaWithOptions(request: DescribeIspFlushCacheRemainQuotaRequest, runtime: $Util.RuntimeOptions): Promise<DescribeIspFlushCacheRemainQuotaResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeIspFlushCacheRemainQuota",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeIspFlushCacheRemainQuotaResponse>(await this.callApi(params, req, runtime), new DescribeIspFlushCacheRemainQuotaResponse({}));
  }

  /**
   * 
   * 
   * @param request - DescribeIspFlushCacheRemainQuotaRequest
   * @returns DescribeIspFlushCacheRemainQuotaResponse
   */
  async describeIspFlushCacheRemainQuota(request: DescribeIspFlushCacheRemainQuotaRequest): Promise<DescribeIspFlushCacheRemainQuotaResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeIspFlushCacheRemainQuotaWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - DescribeIspFlushCacheTaskRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeIspFlushCacheTaskResponse
   */
  async describeIspFlushCacheTaskWithOptions(request: DescribeIspFlushCacheTaskRequest, runtime: $Util.RuntimeOptions): Promise<DescribeIspFlushCacheTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.taskId)) {
      query["TaskId"] = request.taskId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeIspFlushCacheTask",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeIspFlushCacheTaskResponse>(await this.callApi(params, req, runtime), new DescribeIspFlushCacheTaskResponse({}));
  }

  /**
   * 
   * 
   * @param request - DescribeIspFlushCacheTaskRequest
   * @returns DescribeIspFlushCacheTaskResponse
   */
  async describeIspFlushCacheTask(request: DescribeIspFlushCacheTaskRequest): Promise<DescribeIspFlushCacheTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeIspFlushCacheTaskWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - DescribeIspFlushCacheTasksRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeIspFlushCacheTasksResponse
   */
  async describeIspFlushCacheTasksWithOptions(request: DescribeIspFlushCacheTasksRequest, runtime: $Util.RuntimeOptions): Promise<DescribeIspFlushCacheTasksResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.direction)) {
      query["Direction"] = request.direction;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.isp)) {
      query["Isp"] = request.isp;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.orderBy)) {
      query["OrderBy"] = request.orderBy;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeIspFlushCacheTasks",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeIspFlushCacheTasksResponse>(await this.callApi(params, req, runtime), new DescribeIspFlushCacheTasksResponse({}));
  }

  /**
   * 
   * 
   * @param request - DescribeIspFlushCacheTasksRequest
   * @returns DescribeIspFlushCacheTasksResponse
   */
  async describeIspFlushCacheTasks(request: DescribeIspFlushCacheTasksRequest): Promise<DescribeIspFlushCacheTasksResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeIspFlushCacheTasksWithOptions(request, runtime);
  }

  /**
   * DNS
   * 
   * @param request - DescribePdnsAccountSummaryRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribePdnsAccountSummaryResponse
   */
  async describePdnsAccountSummaryWithOptions(request: DescribePdnsAccountSummaryRequest, runtime: $Util.RuntimeOptions): Promise<DescribePdnsAccountSummaryResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endDate)) {
      query["EndDate"] = request.endDate;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.startDate)) {
      query["StartDate"] = request.startDate;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribePdnsAccountSummary",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribePdnsAccountSummaryResponse>(await this.callApi(params, req, runtime), new DescribePdnsAccountSummaryResponse({}));
  }

  /**
   * DNS
   * 
   * @param request - DescribePdnsAccountSummaryRequest
   * @returns DescribePdnsAccountSummaryResponse
   */
  async describePdnsAccountSummary(request: DescribePdnsAccountSummaryRequest): Promise<DescribePdnsAccountSummaryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describePdnsAccountSummaryWithOptions(request, runtime);
  }

  /**
   * DNS AppKey 
   * 
   * @param request - DescribePdnsAppKeyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribePdnsAppKeyResponse
   */
  async describePdnsAppKeyWithOptions(request: DescribePdnsAppKeyRequest, runtime: $Util.RuntimeOptions): Promise<DescribePdnsAppKeyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appKeyId)) {
      query["AppKeyId"] = request.appKeyId;
    }

    if (!Util.isUnset(request.authCode)) {
      query["AuthCode"] = request.authCode;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribePdnsAppKey",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribePdnsAppKeyResponse>(await this.callApi(params, req, runtime), new DescribePdnsAppKeyResponse({}));
  }

  /**
   * DNS AppKey 
   * 
   * @param request - DescribePdnsAppKeyRequest
   * @returns DescribePdnsAppKeyResponse
   */
  async describePdnsAppKey(request: DescribePdnsAppKeyRequest): Promise<DescribePdnsAppKeyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describePdnsAppKeyWithOptions(request, runtime);
  }

  /**
   * DNS AppKey 
   * 
   * @param request - DescribePdnsAppKeysRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribePdnsAppKeysResponse
   */
  async describePdnsAppKeysWithOptions(request: DescribePdnsAppKeysRequest, runtime: $Util.RuntimeOptions): Promise<DescribePdnsAppKeysResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribePdnsAppKeys",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribePdnsAppKeysResponse>(await this.callApi(params, req, runtime), new DescribePdnsAppKeysResponse({}));
  }

  /**
   * DNS AppKey 
   * 
   * @param request - DescribePdnsAppKeysRequest
   * @returns DescribePdnsAppKeysResponse
   */
  async describePdnsAppKeys(request: DescribePdnsAppKeysRequest): Promise<DescribePdnsAppKeysResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describePdnsAppKeysWithOptions(request, runtime);
  }

  /**
   * DNS 
   * 
   * @param request - DescribePdnsOperateLogsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribePdnsOperateLogsResponse
   */
  async describePdnsOperateLogsWithOptions(request: DescribePdnsOperateLogsRequest, runtime: $Util.RuntimeOptions): Promise<DescribePdnsOperateLogsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.actionType)) {
      query["ActionType"] = request.actionType;
    }

    if (!Util.isUnset(request.endDate)) {
      query["EndDate"] = request.endDate;
    }

    if (!Util.isUnset(request.keyword)) {
      query["Keyword"] = request.keyword;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.startDate)) {
      query["StartDate"] = request.startDate;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribePdnsOperateLogs",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribePdnsOperateLogsResponse>(await this.callApi(params, req, runtime), new DescribePdnsOperateLogsResponse({}));
  }

  /**
   * DNS 
   * 
   * @param request - DescribePdnsOperateLogsRequest
   * @returns DescribePdnsOperateLogsResponse
   */
  async describePdnsOperateLogs(request: DescribePdnsOperateLogsRequest): Promise<DescribePdnsOperateLogsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describePdnsOperateLogsWithOptions(request, runtime);
  }

  /**
   * DNS 
   * 
   * @param request - DescribePdnsRequestStatisticRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribePdnsRequestStatisticResponse
   */
  async describePdnsRequestStatisticWithOptions(request: DescribePdnsRequestStatisticRequest, runtime: $Util.RuntimeOptions): Promise<DescribePdnsRequestStatisticResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endDate)) {
      query["EndDate"] = request.endDate;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.startDate)) {
      query["StartDate"] = request.startDate;
    }

    if (!Util.isUnset(request.subDomain)) {
      query["SubDomain"] = request.subDomain;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribePdnsRequestStatistic",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribePdnsRequestStatisticResponse>(await this.callApi(params, req, runtime), new DescribePdnsRequestStatisticResponse({}));
  }

  /**
   * DNS 
   * 
   * @param request - DescribePdnsRequestStatisticRequest
   * @returns DescribePdnsRequestStatisticResponse
   */
  async describePdnsRequestStatistic(request: DescribePdnsRequestStatisticRequest): Promise<DescribePdnsRequestStatisticResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describePdnsRequestStatisticWithOptions(request, runtime);
  }

  /**
   * DNS 
   * 
   * @param request - DescribePdnsRequestStatisticsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribePdnsRequestStatisticsResponse
   */
  async describePdnsRequestStatisticsWithOptions(request: DescribePdnsRequestStatisticsRequest, runtime: $Util.RuntimeOptions): Promise<DescribePdnsRequestStatisticsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endDate)) {
      query["EndDate"] = request.endDate;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.startDate)) {
      query["StartDate"] = request.startDate;
    }

    if (!Util.isUnset(request.subDomain)) {
      query["SubDomain"] = request.subDomain;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribePdnsRequestStatistics",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribePdnsRequestStatisticsResponse>(await this.callApi(params, req, runtime), new DescribePdnsRequestStatisticsResponse({}));
  }

  /**
   * DNS 
   * 
   * @param request - DescribePdnsRequestStatisticsRequest
   * @returns DescribePdnsRequestStatisticsResponse
   */
  async describePdnsRequestStatistics(request: DescribePdnsRequestStatisticsRequest): Promise<DescribePdnsRequestStatisticsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describePdnsRequestStatisticsWithOptions(request, runtime);
  }

  /**
   * DNS 
   * 
   * @param request - DescribePdnsThreatLogsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribePdnsThreatLogsResponse
   */
  async describePdnsThreatLogsWithOptions(request: DescribePdnsThreatLogsRequest, runtime: $Util.RuntimeOptions): Promise<DescribePdnsThreatLogsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endDate)) {
      query["EndDate"] = request.endDate;
    }

    if (!Util.isUnset(request.keyword)) {
      query["Keyword"] = request.keyword;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.startDate)) {
      query["StartDate"] = request.startDate;
    }

    if (!Util.isUnset(request.threatLevel)) {
      query["ThreatLevel"] = request.threatLevel;
    }

    if (!Util.isUnset(request.threatSourceIp)) {
      query["ThreatSourceIp"] = request.threatSourceIp;
    }

    if (!Util.isUnset(request.threatType)) {
      query["ThreatType"] = request.threatType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribePdnsThreatLogs",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribePdnsThreatLogsResponse>(await this.callApi(params, req, runtime), new DescribePdnsThreatLogsResponse({}));
  }

  /**
   * DNS 
   * 
   * @param request - DescribePdnsThreatLogsRequest
   * @returns DescribePdnsThreatLogsResponse
   */
  async describePdnsThreatLogs(request: DescribePdnsThreatLogsRequest): Promise<DescribePdnsThreatLogsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describePdnsThreatLogsWithOptions(request, runtime);
  }

  /**
   * DNS 
   * 
   * @param request - DescribePdnsThreatStatisticRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribePdnsThreatStatisticResponse
   */
  async describePdnsThreatStatisticWithOptions(request: DescribePdnsThreatStatisticRequest, runtime: $Util.RuntimeOptions): Promise<DescribePdnsThreatStatisticResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endDate)) {
      query["EndDate"] = request.endDate;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.startDate)) {
      query["StartDate"] = request.startDate;
    }

    if (!Util.isUnset(request.threatSourceIp)) {
      query["ThreatSourceIp"] = request.threatSourceIp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribePdnsThreatStatistic",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribePdnsThreatStatisticResponse>(await this.callApi(params, req, runtime), new DescribePdnsThreatStatisticResponse({}));
  }

  /**
   * DNS 
   * 
   * @param request - DescribePdnsThreatStatisticRequest
   * @returns DescribePdnsThreatStatisticResponse
   */
  async describePdnsThreatStatistic(request: DescribePdnsThreatStatisticRequest): Promise<DescribePdnsThreatStatisticResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describePdnsThreatStatisticWithOptions(request, runtime);
  }

  /**
   * DNS 
   * 
   * @param request - DescribePdnsThreatStatisticsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribePdnsThreatStatisticsResponse
   */
  async describePdnsThreatStatisticsWithOptions(request: DescribePdnsThreatStatisticsRequest, runtime: $Util.RuntimeOptions): Promise<DescribePdnsThreatStatisticsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.direction)) {
      query["Direction"] = request.direction;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endDate)) {
      query["EndDate"] = request.endDate;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.orderBy)) {
      query["OrderBy"] = request.orderBy;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.startDate)) {
      query["StartDate"] = request.startDate;
    }

    if (!Util.isUnset(request.subDomain)) {
      query["SubDomain"] = request.subDomain;
    }

    if (!Util.isUnset(request.threatLevel)) {
      query["ThreatLevel"] = request.threatLevel;
    }

    if (!Util.isUnset(request.threatSourceIp)) {
      query["ThreatSourceIp"] = request.threatSourceIp;
    }

    if (!Util.isUnset(request.threatType)) {
      query["ThreatType"] = request.threatType;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribePdnsThreatStatistics",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribePdnsThreatStatisticsResponse>(await this.callApi(params, req, runtime), new DescribePdnsThreatStatisticsResponse({}));
  }

  /**
   * DNS 
   * 
   * @param request - DescribePdnsThreatStatisticsRequest
   * @returns DescribePdnsThreatStatisticsResponse
   */
  async describePdnsThreatStatistics(request: DescribePdnsThreatStatisticsRequest): Promise<DescribePdnsThreatStatisticsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describePdnsThreatStatisticsWithOptions(request, runtime);
  }

  /**
   * DNS Udp IP
   * 
   * @param request - DescribePdnsUdpIpSegmentsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribePdnsUdpIpSegmentsResponse
   */
  async describePdnsUdpIpSegmentsWithOptions(request: DescribePdnsUdpIpSegmentsRequest, runtime: $Util.RuntimeOptions): Promise<DescribePdnsUdpIpSegmentsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribePdnsUdpIpSegments",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribePdnsUdpIpSegmentsResponse>(await this.callApi(params, req, runtime), new DescribePdnsUdpIpSegmentsResponse({}));
  }

  /**
   * DNS Udp IP
   * 
   * @param request - DescribePdnsUdpIpSegmentsRequest
   * @returns DescribePdnsUdpIpSegmentsResponse
   */
  async describePdnsUdpIpSegments(request: DescribePdnsUdpIpSegmentsRequest): Promise<DescribePdnsUdpIpSegmentsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describePdnsUdpIpSegmentsWithOptions(request, runtime);
  }

  /**
   * DNS
   * 
   * @param request - DescribePdnsUserInfoRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribePdnsUserInfoResponse
   */
  async describePdnsUserInfoWithOptions(request: DescribePdnsUserInfoRequest, runtime: $Util.RuntimeOptions): Promise<DescribePdnsUserInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribePdnsUserInfo",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribePdnsUserInfoResponse>(await this.callApi(params, req, runtime), new DescribePdnsUserInfoResponse({}));
  }

  /**
   * DNS
   * 
   * @param request - DescribePdnsUserInfoRequest
   * @returns DescribePdnsUserInfoResponse
   */
  async describePdnsUserInfo(request: DescribePdnsUserInfoRequest): Promise<DescribePdnsUserInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describePdnsUserInfoWithOptions(request, runtime);
  }

  /**
   * Queries the operation logs of a domain name based on the specified parameters.
   * 
   * @param request - DescribeRecordLogsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeRecordLogsResponse
   */
  async describeRecordLogsWithOptions(request: DescribeRecordLogsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeRecordLogsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.keyWord)) {
      query["KeyWord"] = request.keyWord;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.startDate)) {
      query["StartDate"] = request.startDate;
    }

    if (!Util.isUnset(request.userClientIp)) {
      query["UserClientIp"] = request.userClientIp;
    }

    if (!Util.isUnset(request.endDate)) {
      query["endDate"] = request.endDate;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeRecordLogs",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeRecordLogsResponse>(await this.callApi(params, req, runtime), new DescribeRecordLogsResponse({}));
  }

  /**
   * Queries the operation logs of a domain name based on the specified parameters.
   * 
   * @param request - DescribeRecordLogsRequest
   * @returns DescribeRecordLogsResponse
   */
  async describeRecordLogs(request: DescribeRecordLogsRequest): Promise<DescribeRecordLogsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeRecordLogsWithOptions(request, runtime);
  }

  /**
   * Queries the number of resolution requests for all subdomain names of a specified domain name.
   * 
   * @param request - DescribeRecordResolveStatisticsSummaryRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeRecordResolveStatisticsSummaryResponse
   */
  async describeRecordResolveStatisticsSummaryWithOptions(request: DescribeRecordResolveStatisticsSummaryRequest, runtime: $Util.RuntimeOptions): Promise<DescribeRecordResolveStatisticsSummaryResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.direction)) {
      query["Direction"] = request.direction;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.domainType)) {
      query["DomainType"] = request.domainType;
    }

    if (!Util.isUnset(request.endDate)) {
      query["EndDate"] = request.endDate;
    }

    if (!Util.isUnset(request.keyword)) {
      query["Keyword"] = request.keyword;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.searchMode)) {
      query["SearchMode"] = request.searchMode;
    }

    if (!Util.isUnset(request.startDate)) {
      query["StartDate"] = request.startDate;
    }

    if (!Util.isUnset(request.threshold)) {
      query["Threshold"] = request.threshold;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeRecordResolveStatisticsSummary",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeRecordResolveStatisticsSummaryResponse>(await this.callApi(params, req, runtime), new DescribeRecordResolveStatisticsSummaryResponse({}));
  }

  /**
   * Queries the number of resolution requests for all subdomain names of a specified domain name.
   * 
   * @param request - DescribeRecordResolveStatisticsSummaryRequest
   * @returns DescribeRecordResolveStatisticsSummaryResponse
   */
  async describeRecordResolveStatisticsSummary(request: DescribeRecordResolveStatisticsSummaryRequest): Promise<DescribeRecordResolveStatisticsSummaryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeRecordResolveStatisticsSummaryWithOptions(request, runtime);
  }

  /**
   * Queries the real-time statistics on the Domain Name System (DNS) requests for a subdomain name.
   * 
   * @remarks
   * Real-time data is collected per hour.
   * 
   * @param request - DescribeRecordStatisticsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeRecordStatisticsResponse
   */
  async describeRecordStatisticsWithOptions(request: DescribeRecordStatisticsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeRecordStatisticsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.domainType)) {
      query["DomainType"] = request.domainType;
    }

    if (!Util.isUnset(request.endDate)) {
      query["EndDate"] = request.endDate;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.rr)) {
      query["Rr"] = request.rr;
    }

    if (!Util.isUnset(request.startDate)) {
      query["StartDate"] = request.startDate;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeRecordStatistics",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeRecordStatisticsResponse>(await this.callApi(params, req, runtime), new DescribeRecordStatisticsResponse({}));
  }

  /**
   * Queries the real-time statistics on the Domain Name System (DNS) requests for a subdomain name.
   * 
   * @remarks
   * Real-time data is collected per hour.
   * 
   * @param request - DescribeRecordStatisticsRequest
   * @returns DescribeRecordStatisticsResponse
   */
  async describeRecordStatistics(request: DescribeRecordStatisticsRequest): Promise<DescribeRecordStatisticsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeRecordStatisticsWithOptions(request, runtime);
  }

  /**
   * Queries the number of Domain Name System (DNS) requests for all subdomain names of a specified domain name.
   * 
   * @param request - DescribeRecordStatisticsSummaryRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeRecordStatisticsSummaryResponse
   */
  async describeRecordStatisticsSummaryWithOptions(request: DescribeRecordStatisticsSummaryRequest, runtime: $Util.RuntimeOptions): Promise<DescribeRecordStatisticsSummaryResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.domainType)) {
      query["DomainType"] = request.domainType;
    }

    if (!Util.isUnset(request.endDate)) {
      query["EndDate"] = request.endDate;
    }

    if (!Util.isUnset(request.keyword)) {
      query["Keyword"] = request.keyword;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.searchMode)) {
      query["SearchMode"] = request.searchMode;
    }

    if (!Util.isUnset(request.startDate)) {
      query["StartDate"] = request.startDate;
    }

    if (!Util.isUnset(request.threshold)) {
      query["Threshold"] = request.threshold;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeRecordStatisticsSummary",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeRecordStatisticsSummaryResponse>(await this.callApi(params, req, runtime), new DescribeRecordStatisticsSummaryResponse({}));
  }

  /**
   * Queries the number of Domain Name System (DNS) requests for all subdomain names of a specified domain name.
   * 
   * @param request - DescribeRecordStatisticsSummaryRequest
   * @returns DescribeRecordStatisticsSummaryResponse
   */
  async describeRecordStatisticsSummary(request: DescribeRecordStatisticsSummaryRequest): Promise<DescribeRecordStatisticsSummaryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeRecordStatisticsSummaryWithOptions(request, runtime);
  }

  /**
   * Queries all Domain Name System (DNS) records of a subdomain name based on the specified parameters.
   * 
   * @param request - DescribeSubDomainRecordsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeSubDomainRecordsResponse
   */
  async describeSubDomainRecordsWithOptions(request: DescribeSubDomainRecordsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSubDomainRecordsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.line)) {
      query["Line"] = request.line;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.subDomain)) {
      query["SubDomain"] = request.subDomain;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    if (!Util.isUnset(request.userClientIp)) {
      query["UserClientIp"] = request.userClientIp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeSubDomainRecords",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSubDomainRecordsResponse>(await this.callApi(params, req, runtime), new DescribeSubDomainRecordsResponse({}));
  }

  /**
   * Queries all Domain Name System (DNS) records of a subdomain name based on the specified parameters.
   * 
   * @param request - DescribeSubDomainRecordsRequest
   * @returns DescribeSubDomainRecordsResponse
   */
  async describeSubDomainRecords(request: DescribeSubDomainRecordsRequest): Promise<DescribeSubDomainRecordsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSubDomainRecordsWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - DescribeSupportLinesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeSupportLinesResponse
   */
  async describeSupportLinesWithOptions(request: DescribeSupportLinesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSupportLinesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.userClientIp)) {
      query["UserClientIp"] = request.userClientIp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeSupportLines",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSupportLinesResponse>(await this.callApi(params, req, runtime), new DescribeSupportLinesResponse({}));
  }

  /**
   * 
   * 
   * @param request - DescribeSupportLinesRequest
   * @returns DescribeSupportLinesResponse
   */
  async describeSupportLines(request: DescribeSupportLinesRequest): Promise<DescribeSupportLinesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSupportLinesWithOptions(request, runtime);
  }

  /**
   * Queries existing tags.
   * 
   * @param request - DescribeTagsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeTagsResponse
   */
  async describeTagsWithOptions(request: DescribeTagsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeTagsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeTags",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeTagsResponse>(await this.callApi(params, req, runtime), new DescribeTagsResponse({}));
  }

  /**
   * Queries existing tags.
   * 
   * @param request - DescribeTagsRequest
   * @returns DescribeTagsResponse
   */
  async describeTags(request: DescribeTagsRequest): Promise<DescribeTagsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeTagsWithOptions(request, runtime);
  }

  /**
   * Queries the domain names that were transferred between the current account and another account based on the specified parameters.
   * 
   * @param request - DescribeTransferDomainsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeTransferDomainsResponse
   */
  async describeTransferDomainsWithOptions(request: DescribeTransferDomainsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeTransferDomainsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.fromUserId)) {
      query["FromUserId"] = request.fromUserId;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.targetUserId)) {
      query["TargetUserId"] = request.targetUserId;
    }

    if (!Util.isUnset(request.transferType)) {
      query["TransferType"] = request.transferType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeTransferDomains",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeTransferDomainsResponse>(await this.callApi(params, req, runtime), new DescribeTransferDomainsResponse({}));
  }

  /**
   * Queries the domain names that were transferred between the current account and another account based on the specified parameters.
   * 
   * @param request - DescribeTransferDomainsRequest
   * @returns DescribeTransferDomainsResponse
   */
  async describeTransferDomains(request: DescribeTransferDomainsRequest): Promise<DescribeTransferDomainsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeTransferDomainsWithOptions(request, runtime);
  }

  /**
   * @param request - ExecuteGtmRecoveryPlanRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ExecuteGtmRecoveryPlanResponse
   */
  async executeGtmRecoveryPlanWithOptions(request: ExecuteGtmRecoveryPlanRequest, runtime: $Util.RuntimeOptions): Promise<ExecuteGtmRecoveryPlanResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.recoveryPlanId)) {
      query["RecoveryPlanId"] = request.recoveryPlanId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ExecuteGtmRecoveryPlan",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ExecuteGtmRecoveryPlanResponse>(await this.callApi(params, req, runtime), new ExecuteGtmRecoveryPlanResponse({}));
  }

  /**
   * @param request - ExecuteGtmRecoveryPlanRequest
   * @returns ExecuteGtmRecoveryPlanResponse
   */
  async executeGtmRecoveryPlan(request: ExecuteGtmRecoveryPlanRequest): Promise<ExecuteGtmRecoveryPlanResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.executeGtmRecoveryPlanWithOptions(request, runtime);
  }

  /**
   * Queries a primary domain name based on the specified parameters.
   * 
   * @remarks
   * For more information about the difference between primary domain names and subdomain names, see
   * [Subdomain levels](https://www.alibabacloud.com/help/zh/faq-detail/39803.htm). For example, if you enter `www.abc.com`, abc.com is obtained.
   * 
   * @param request - GetMainDomainNameRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetMainDomainNameResponse
   */
  async getMainDomainNameWithOptions(request: GetMainDomainNameRequest, runtime: $Util.RuntimeOptions): Promise<GetMainDomainNameResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.inputString)) {
      query["InputString"] = request.inputString;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetMainDomainName",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetMainDomainNameResponse>(await this.callApi(params, req, runtime), new GetMainDomainNameResponse({}));
  }

  /**
   * Queries a primary domain name based on the specified parameters.
   * 
   * @remarks
   * For more information about the difference between primary domain names and subdomain names, see
   * [Subdomain levels](https://www.alibabacloud.com/help/zh/faq-detail/39803.htm). For example, if you enter `www.abc.com`, abc.com is obtained.
   * 
   * @param request - GetMainDomainNameRequest
   * @returns GetMainDomainNameResponse
   */
  async getMainDomainName(request: GetMainDomainNameRequest): Promise<GetMainDomainNameResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getMainDomainNameWithOptions(request, runtime);
  }

  /**
   * Generates a text (TXT) record. TXT records are used to retrieve domain names and subdomain names, enable the subdomain name verification feature, and perform batch retrievals.
   * 
   * @param request - GetTxtRecordForVerifyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetTxtRecordForVerifyResponse
   */
  async getTxtRecordForVerifyWithOptions(request: GetTxtRecordForVerifyRequest, runtime: $Util.RuntimeOptions): Promise<GetTxtRecordForVerifyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetTxtRecordForVerify",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetTxtRecordForVerifyResponse>(await this.callApi(params, req, runtime), new GetTxtRecordForVerifyResponse({}));
  }

  /**
   * Generates a text (TXT) record. TXT records are used to retrieve domain names and subdomain names, enable the subdomain name verification feature, and perform batch retrievals.
   * 
   * @param request - GetTxtRecordForVerifyRequest
   * @returns GetTxtRecordForVerifyResponse
   */
  async getTxtRecordForVerify(request: GetTxtRecordForVerifyRequest): Promise<GetTxtRecordForVerifyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getTxtRecordForVerifyWithOptions(request, runtime);
  }

  /**
   * @param request - ListCloudGtmAddressPoolsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListCloudGtmAddressPoolsResponse
   */
  async listCloudGtmAddressPoolsWithOptions(request: ListCloudGtmAddressPoolsRequest, runtime: $Util.RuntimeOptions): Promise<ListCloudGtmAddressPoolsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.addressPoolName)) {
      query["AddressPoolName"] = request.addressPoolName;
    }

    if (!Util.isUnset(request.addressPoolType)) {
      query["AddressPoolType"] = request.addressPoolType;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.enableStatus)) {
      query["EnableStatus"] = request.enableStatus;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.remark)) {
      query["Remark"] = request.remark;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListCloudGtmAddressPools",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListCloudGtmAddressPoolsResponse>(await this.callApi(params, req, runtime), new ListCloudGtmAddressPoolsResponse({}));
  }

  /**
   * @param request - ListCloudGtmAddressPoolsRequest
   * @returns ListCloudGtmAddressPoolsResponse
   */
  async listCloudGtmAddressPools(request: ListCloudGtmAddressPoolsRequest): Promise<ListCloudGtmAddressPoolsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listCloudGtmAddressPoolsWithOptions(request, runtime);
  }

  /**
   * @param request - ListCloudGtmAddressesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListCloudGtmAddressesResponse
   */
  async listCloudGtmAddressesWithOptions(request: ListCloudGtmAddressesRequest, runtime: $Util.RuntimeOptions): Promise<ListCloudGtmAddressesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.address)) {
      query["Address"] = request.address;
    }

    if (!Util.isUnset(request.addressId)) {
      query["AddressId"] = request.addressId;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.enableStatus)) {
      query["EnableStatus"] = request.enableStatus;
    }

    if (!Util.isUnset(request.healthStatus)) {
      query["HealthStatus"] = request.healthStatus;
    }

    if (!Util.isUnset(request.monitorTemplateId)) {
      query["MonitorTemplateId"] = request.monitorTemplateId;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListCloudGtmAddresses",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListCloudGtmAddressesResponse>(await this.callApi(params, req, runtime), new ListCloudGtmAddressesResponse({}));
  }

  /**
   * @param request - ListCloudGtmAddressesRequest
   * @returns ListCloudGtmAddressesResponse
   */
  async listCloudGtmAddresses(request: ListCloudGtmAddressesRequest): Promise<ListCloudGtmAddressesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listCloudGtmAddressesWithOptions(request, runtime);
  }

  /**
   * @param request - ListCloudGtmAlertLogsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListCloudGtmAlertLogsResponse
   */
  async listCloudGtmAlertLogsWithOptions(request: ListCloudGtmAlertLogsRequest, runtime: $Util.RuntimeOptions): Promise<ListCloudGtmAlertLogsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.actionType)) {
      query["ActionType"] = request.actionType;
    }

    if (!Util.isUnset(request.endTimestamp)) {
      query["EndTimestamp"] = request.endTimestamp;
    }

    if (!Util.isUnset(request.entityType)) {
      query["EntityType"] = request.entityType;
    }

    if (!Util.isUnset(request.keyword)) {
      query["Keyword"] = request.keyword;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.startTimestamp)) {
      query["StartTimestamp"] = request.startTimestamp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListCloudGtmAlertLogs",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListCloudGtmAlertLogsResponse>(await this.callApi(params, req, runtime), new ListCloudGtmAlertLogsResponse({}));
  }

  /**
   * @param request - ListCloudGtmAlertLogsRequest
   * @returns ListCloudGtmAlertLogsResponse
   */
  async listCloudGtmAlertLogs(request: ListCloudGtmAlertLogsRequest): Promise<ListCloudGtmAlertLogsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listCloudGtmAlertLogsWithOptions(request, runtime);
  }

  /**
   * @param request - ListCloudGtmAvailableAlertGroupsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListCloudGtmAvailableAlertGroupsResponse
   */
  async listCloudGtmAvailableAlertGroupsWithOptions(request: ListCloudGtmAvailableAlertGroupsRequest, runtime: $Util.RuntimeOptions): Promise<ListCloudGtmAvailableAlertGroupsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListCloudGtmAvailableAlertGroups",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListCloudGtmAvailableAlertGroupsResponse>(await this.callApi(params, req, runtime), new ListCloudGtmAvailableAlertGroupsResponse({}));
  }

  /**
   * @param request - ListCloudGtmAvailableAlertGroupsRequest
   * @returns ListCloudGtmAvailableAlertGroupsResponse
   */
  async listCloudGtmAvailableAlertGroups(request: ListCloudGtmAvailableAlertGroupsRequest): Promise<ListCloudGtmAvailableAlertGroupsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listCloudGtmAvailableAlertGroupsWithOptions(request, runtime);
  }

  /**
   * @param request - ListCloudGtmInstanceConfigsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListCloudGtmInstanceConfigsResponse
   */
  async listCloudGtmInstanceConfigsWithOptions(request: ListCloudGtmInstanceConfigsRequest, runtime: $Util.RuntimeOptions): Promise<ListCloudGtmInstanceConfigsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.enableStatus)) {
      query["EnableStatus"] = request.enableStatus;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.remark)) {
      query["Remark"] = request.remark;
    }

    if (!Util.isUnset(request.scheduleDomainName)) {
      query["ScheduleDomainName"] = request.scheduleDomainName;
    }

    if (!Util.isUnset(request.scheduleZoneName)) {
      query["ScheduleZoneName"] = request.scheduleZoneName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListCloudGtmInstanceConfigs",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListCloudGtmInstanceConfigsResponse>(await this.callApi(params, req, runtime), new ListCloudGtmInstanceConfigsResponse({}));
  }

  /**
   * @param request - ListCloudGtmInstanceConfigsRequest
   * @returns ListCloudGtmInstanceConfigsResponse
   */
  async listCloudGtmInstanceConfigs(request: ListCloudGtmInstanceConfigsRequest): Promise<ListCloudGtmInstanceConfigsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listCloudGtmInstanceConfigsWithOptions(request, runtime);
  }

  /**
   * @param request - ListCloudGtmInstancesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListCloudGtmInstancesResponse
   */
  async listCloudGtmInstancesWithOptions(request: ListCloudGtmInstancesRequest, runtime: $Util.RuntimeOptions): Promise<ListCloudGtmInstancesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.instanceName)) {
      query["InstanceName"] = request.instanceName;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListCloudGtmInstances",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListCloudGtmInstancesResponse>(await this.callApi(params, req, runtime), new ListCloudGtmInstancesResponse({}));
  }

  /**
   * @param request - ListCloudGtmInstancesRequest
   * @returns ListCloudGtmInstancesResponse
   */
  async listCloudGtmInstances(request: ListCloudGtmInstancesRequest): Promise<ListCloudGtmInstancesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listCloudGtmInstancesWithOptions(request, runtime);
  }

  /**
   * @param request - ListCloudGtmMonitorNodesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListCloudGtmMonitorNodesResponse
   */
  async listCloudGtmMonitorNodesWithOptions(request: ListCloudGtmMonitorNodesRequest, runtime: $Util.RuntimeOptions): Promise<ListCloudGtmMonitorNodesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListCloudGtmMonitorNodes",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListCloudGtmMonitorNodesResponse>(await this.callApi(params, req, runtime), new ListCloudGtmMonitorNodesResponse({}));
  }

  /**
   * @param request - ListCloudGtmMonitorNodesRequest
   * @returns ListCloudGtmMonitorNodesResponse
   */
  async listCloudGtmMonitorNodes(request: ListCloudGtmMonitorNodesRequest): Promise<ListCloudGtmMonitorNodesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listCloudGtmMonitorNodesWithOptions(request, runtime);
  }

  /**
   * @param request - ListCloudGtmMonitorTemplatesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListCloudGtmMonitorTemplatesResponse
   */
  async listCloudGtmMonitorTemplatesWithOptions(request: ListCloudGtmMonitorTemplatesRequest, runtime: $Util.RuntimeOptions): Promise<ListCloudGtmMonitorTemplatesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.ipVersion)) {
      query["IpVersion"] = request.ipVersion;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.protocol)) {
      query["Protocol"] = request.protocol;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListCloudGtmMonitorTemplates",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListCloudGtmMonitorTemplatesResponse>(await this.callApi(params, req, runtime), new ListCloudGtmMonitorTemplatesResponse({}));
  }

  /**
   * @param request - ListCloudGtmMonitorTemplatesRequest
   * @returns ListCloudGtmMonitorTemplatesResponse
   */
  async listCloudGtmMonitorTemplates(request: ListCloudGtmMonitorTemplatesRequest): Promise<ListCloudGtmMonitorTemplatesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listCloudGtmMonitorTemplatesWithOptions(request, runtime);
  }

  /**
   * Queries the tags that are added to a specified resource.
   * 
   * @remarks
   *   Set ResourceId.N or Tag.N that consists of Tag.N.Key and Tag.N.Value in the request to specify the object to be queried.
   * *   Tag.N is a resource tag that consists of a key-value pair. If you set only Tag.N.Key, all tag values that are assigned to the specified key are returned. If you set only Tag.N.Value, an error message is returned.
   * *   If you set both Tag.N and ResourceId.N to filter tags, ResourceId.N must match all specified key-value pairs.
   * *   If you specify multiple key-value pairs, resources that contain these key-value pairs are returned.
   * 
   * @param request - ListTagResourcesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListTagResourcesResponse
   */
  async listTagResourcesWithOptions(request: ListTagResourcesRequest, runtime: $Util.RuntimeOptions): Promise<ListTagResourcesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!Util.isUnset(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListTagResources",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListTagResourcesResponse>(await this.callApi(params, req, runtime), new ListTagResourcesResponse({}));
  }

  /**
   * Queries the tags that are added to a specified resource.
   * 
   * @remarks
   *   Set ResourceId.N or Tag.N that consists of Tag.N.Key and Tag.N.Value in the request to specify the object to be queried.
   * *   Tag.N is a resource tag that consists of a key-value pair. If you set only Tag.N.Key, all tag values that are assigned to the specified key are returned. If you set only Tag.N.Value, an error message is returned.
   * *   If you set both Tag.N and ResourceId.N to filter tags, ResourceId.N must match all specified key-value pairs.
   * *   If you specify multiple key-value pairs, resources that contain these key-value pairs are returned.
   * 
   * @param request - ListTagResourcesRequest
   * @returns ListTagResourcesResponse
   */
  async listTagResources(request: ListTagResourcesRequest): Promise<ListTagResourcesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listTagResourcesWithOptions(request, runtime);
  }

  /**
   * Calls the ModifyHichinaDomainDNS operation to change the name of a DNS server based on input parameters.
   * 
   * @remarks
   * If the operation succeeds, the name of the DNS server changes to that of an Alibaba Cloud DNS server (ending with hichina.com).
   * >  Before you call this operation, make sure that your domain name has been registered with Alibaba Cloud and the DNS server in use is not an Alibaba Cloud DNS server.
   * 
   * @param request - ModifyHichinaDomainDNSRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyHichinaDomainDNSResponse
   */
  async modifyHichinaDomainDNSWithOptions(request: ModifyHichinaDomainDNSRequest, runtime: $Util.RuntimeOptions): Promise<ModifyHichinaDomainDNSResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.userClientIp)) {
      query["UserClientIp"] = request.userClientIp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyHichinaDomainDNS",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyHichinaDomainDNSResponse>(await this.callApi(params, req, runtime), new ModifyHichinaDomainDNSResponse({}));
  }

  /**
   * Calls the ModifyHichinaDomainDNS operation to change the name of a DNS server based on input parameters.
   * 
   * @remarks
   * If the operation succeeds, the name of the DNS server changes to that of an Alibaba Cloud DNS server (ending with hichina.com).
   * >  Before you call this operation, make sure that your domain name has been registered with Alibaba Cloud and the DNS server in use is not an Alibaba Cloud DNS server.
   * 
   * @param request - ModifyHichinaDomainDNSRequest
   * @returns ModifyHichinaDomainDNSResponse
   */
  async modifyHichinaDomainDNS(request: ModifyHichinaDomainDNSRequest): Promise<ModifyHichinaDomainDNSResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyHichinaDomainDNSWithOptions(request, runtime);
  }

  /**
   * Moves a domain name to another resource group.
   * 
   * @param request - MoveDomainResourceGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns MoveDomainResourceGroupResponse
   */
  async moveDomainResourceGroupWithOptions(request: MoveDomainResourceGroupRequest, runtime: $Util.RuntimeOptions): Promise<MoveDomainResourceGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.newResourceGroupId)) {
      query["NewResourceGroupId"] = request.newResourceGroupId;
    }

    if (!Util.isUnset(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "MoveDomainResourceGroup",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<MoveDomainResourceGroupResponse>(await this.callApi(params, req, runtime), new MoveDomainResourceGroupResponse({}));
  }

  /**
   * Moves a domain name to another resource group.
   * 
   * @param request - MoveDomainResourceGroupRequest
   * @returns MoveDomainResourceGroupResponse
   */
  async moveDomainResourceGroup(request: MoveDomainResourceGroupRequest): Promise<MoveDomainResourceGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.moveDomainResourceGroupWithOptions(request, runtime);
  }

  /**
   * @param request - MoveGtmResourceGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns MoveGtmResourceGroupResponse
   */
  async moveGtmResourceGroupWithOptions(request: MoveGtmResourceGroupRequest, runtime: $Util.RuntimeOptions): Promise<MoveGtmResourceGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.newResourceGroupId)) {
      query["NewResourceGroupId"] = request.newResourceGroupId;
    }

    if (!Util.isUnset(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "MoveGtmResourceGroup",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<MoveGtmResourceGroupResponse>(await this.callApi(params, req, runtime), new MoveGtmResourceGroupResponse({}));
  }

  /**
   * @param request - MoveGtmResourceGroupRequest
   * @returns MoveGtmResourceGroupResponse
   */
  async moveGtmResourceGroup(request: MoveGtmResourceGroupRequest): Promise<MoveGtmResourceGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.moveGtmResourceGroupWithOptions(request, runtime);
  }

  /**
   * Submits a batch operation task to add or delete multiple domain names or multiple Domain Name System (DNS) records at a time.
   * 
   * @remarks
   * Scenario: You need to execute a large number of tasks related to DNS resolution and you do not have high requirements for efficiency.
   * 
   * @param request - OperateBatchDomainRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns OperateBatchDomainResponse
   */
  async operateBatchDomainWithOptions(request: OperateBatchDomainRequest, runtime: $Util.RuntimeOptions): Promise<OperateBatchDomainResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainRecordInfo)) {
      query["DomainRecordInfo"] = request.domainRecordInfo;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "OperateBatchDomain",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<OperateBatchDomainResponse>(await this.callApi(params, req, runtime), new OperateBatchDomainResponse({}));
  }

  /**
   * Submits a batch operation task to add or delete multiple domain names or multiple Domain Name System (DNS) records at a time.
   * 
   * @remarks
   * Scenario: You need to execute a large number of tasks related to DNS resolution and you do not have high requirements for efficiency.
   * 
   * @param request - OperateBatchDomainRequest
   * @returns OperateBatchDomainResponse
   */
  async operateBatchDomain(request: OperateBatchDomainRequest): Promise<OperateBatchDomainResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.operateBatchDomainWithOptions(request, runtime);
  }

  /**
   * DNS
   * 
   * @param request - PausePdnsServiceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns PausePdnsServiceResponse
   */
  async pausePdnsServiceWithOptions(request: PausePdnsServiceRequest, runtime: $Util.RuntimeOptions): Promise<PausePdnsServiceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.serviceType)) {
      query["ServiceType"] = request.serviceType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "PausePdnsService",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PausePdnsServiceResponse>(await this.callApi(params, req, runtime), new PausePdnsServiceResponse({}));
  }

  /**
   * DNS
   * 
   * @param request - PausePdnsServiceRequest
   * @returns PausePdnsServiceResponse
   */
  async pausePdnsService(request: PausePdnsServiceRequest): Promise<PausePdnsServiceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.pausePdnsServiceWithOptions(request, runtime);
  }

  /**
   * You can call this operation to preview a disaster recovery plan of a Global Traffic Manager (GTM) instance.
   * 
   * @param request - PreviewGtmRecoveryPlanRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns PreviewGtmRecoveryPlanResponse
   */
  async previewGtmRecoveryPlanWithOptions(request: PreviewGtmRecoveryPlanRequest, runtime: $Util.RuntimeOptions): Promise<PreviewGtmRecoveryPlanResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.recoveryPlanId)) {
      query["RecoveryPlanId"] = request.recoveryPlanId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "PreviewGtmRecoveryPlan",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PreviewGtmRecoveryPlanResponse>(await this.callApi(params, req, runtime), new PreviewGtmRecoveryPlanResponse({}));
  }

  /**
   * You can call this operation to preview a disaster recovery plan of a Global Traffic Manager (GTM) instance.
   * 
   * @param request - PreviewGtmRecoveryPlanRequest
   * @returns PreviewGtmRecoveryPlanResponse
   */
  async previewGtmRecoveryPlan(request: PreviewGtmRecoveryPlanRequest): Promise<PreviewGtmRecoveryPlanResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.previewGtmRecoveryPlanWithOptions(request, runtime);
  }

  /**
   * DNS AppKey
   * 
   * @param request - RemovePdnsAppKeyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RemovePdnsAppKeyResponse
   */
  async removePdnsAppKeyWithOptions(request: RemovePdnsAppKeyRequest, runtime: $Util.RuntimeOptions): Promise<RemovePdnsAppKeyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appKeyId)) {
      query["AppKeyId"] = request.appKeyId;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RemovePdnsAppKey",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RemovePdnsAppKeyResponse>(await this.callApi(params, req, runtime), new RemovePdnsAppKeyResponse({}));
  }

  /**
   * DNS AppKey
   * 
   * @param request - RemovePdnsAppKeyRequest
   * @returns RemovePdnsAppKeyResponse
   */
  async removePdnsAppKey(request: RemovePdnsAppKeyRequest): Promise<RemovePdnsAppKeyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.removePdnsAppKeyWithOptions(request, runtime);
  }

  /**
   * DNS Udp Ip
   * 
   * @param request - RemovePdnsUdpIpSegmentRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RemovePdnsUdpIpSegmentResponse
   */
  async removePdnsUdpIpSegmentWithOptions(request: RemovePdnsUdpIpSegmentRequest, runtime: $Util.RuntimeOptions): Promise<RemovePdnsUdpIpSegmentResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ip)) {
      query["Ip"] = request.ip;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RemovePdnsUdpIpSegment",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RemovePdnsUdpIpSegmentResponse>(await this.callApi(params, req, runtime), new RemovePdnsUdpIpSegmentResponse({}));
  }

  /**
   * DNS Udp Ip
   * 
   * @param request - RemovePdnsUdpIpSegmentRequest
   * @returns RemovePdnsUdpIpSegmentResponse
   */
  async removePdnsUdpIpSegment(request: RemovePdnsUdpIpSegmentRequest): Promise<RemovePdnsUdpIpSegmentResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.removePdnsUdpIpSegmentWithOptions(request, runtime);
  }

  /**
   * @param tmpReq - ReplaceCloudGtmAddressPoolAddressRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ReplaceCloudGtmAddressPoolAddressResponse
   */
  async replaceCloudGtmAddressPoolAddressWithOptions(tmpReq: ReplaceCloudGtmAddressPoolAddressRequest, runtime: $Util.RuntimeOptions): Promise<ReplaceCloudGtmAddressPoolAddressResponse> {
    Util.validateModel(tmpReq);
    let request = new ReplaceCloudGtmAddressPoolAddressShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.addresses)) {
      request.addressesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.addresses, "Addresses", "json");
    }

    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.addressPoolId)) {
      query["AddressPoolId"] = request.addressPoolId;
    }

    if (!Util.isUnset(request.addressesShrink)) {
      query["Addresses"] = request.addressesShrink;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ReplaceCloudGtmAddressPoolAddress",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ReplaceCloudGtmAddressPoolAddressResponse>(await this.callApi(params, req, runtime), new ReplaceCloudGtmAddressPoolAddressResponse({}));
  }

  /**
   * @param request - ReplaceCloudGtmAddressPoolAddressRequest
   * @returns ReplaceCloudGtmAddressPoolAddressResponse
   */
  async replaceCloudGtmAddressPoolAddress(request: ReplaceCloudGtmAddressPoolAddressRequest): Promise<ReplaceCloudGtmAddressPoolAddressResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.replaceCloudGtmAddressPoolAddressWithOptions(request, runtime);
  }

  /**
   * @param tmpReq - ReplaceCloudGtmInstanceConfigAddressPoolRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ReplaceCloudGtmInstanceConfigAddressPoolResponse
   */
  async replaceCloudGtmInstanceConfigAddressPoolWithOptions(tmpReq: ReplaceCloudGtmInstanceConfigAddressPoolRequest, runtime: $Util.RuntimeOptions): Promise<ReplaceCloudGtmInstanceConfigAddressPoolResponse> {
    Util.validateModel(tmpReq);
    let request = new ReplaceCloudGtmInstanceConfigAddressPoolShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.addressPools)) {
      request.addressPoolsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.addressPools, "AddressPools", "json");
    }

    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.addressPoolsShrink)) {
      query["AddressPools"] = request.addressPoolsShrink;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.configId)) {
      query["ConfigId"] = request.configId;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ReplaceCloudGtmInstanceConfigAddressPool",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ReplaceCloudGtmInstanceConfigAddressPoolResponse>(await this.callApi(params, req, runtime), new ReplaceCloudGtmInstanceConfigAddressPoolResponse({}));
  }

  /**
   * @param request - ReplaceCloudGtmInstanceConfigAddressPoolRequest
   * @returns ReplaceCloudGtmInstanceConfigAddressPoolResponse
   */
  async replaceCloudGtmInstanceConfigAddressPool(request: ReplaceCloudGtmInstanceConfigAddressPoolRequest): Promise<ReplaceCloudGtmInstanceConfigAddressPoolResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.replaceCloudGtmInstanceConfigAddressPoolWithOptions(request, runtime);
  }

  /**
   * DNS
   * 
   * @param request - ResumePdnsServiceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ResumePdnsServiceResponse
   */
  async resumePdnsServiceWithOptions(request: ResumePdnsServiceRequest, runtime: $Util.RuntimeOptions): Promise<ResumePdnsServiceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.serviceType)) {
      query["ServiceType"] = request.serviceType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ResumePdnsService",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ResumePdnsServiceResponse>(await this.callApi(params, req, runtime), new ResumePdnsServiceResponse({}));
  }

  /**
   * DNS
   * 
   * @param request - ResumePdnsServiceRequest
   * @returns ResumePdnsServiceResponse
   */
  async resumePdnsService(request: ResumePdnsServiceRequest): Promise<ResumePdnsServiceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.resumePdnsServiceWithOptions(request, runtime);
  }

  /**
   * Retrieves a domain name.
   * 
   * @remarks
   * To retrieve a domain name, you must verify a text (TXT) record. Therefore, before you call this API operation to retrieve a domain name, call the [GetTxtRecordForVerify](https://www.alibabacloud.com/help/zh/alibaba-cloud-dns/latest/generating-a-txt-record) operation to generate a TXT record.
   * 
   * @param request - RetrieveDomainRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RetrieveDomainResponse
   */
  async retrieveDomainWithOptions(request: RetrieveDomainRequest, runtime: $Util.RuntimeOptions): Promise<RetrieveDomainResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RetrieveDomain",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RetrieveDomainResponse>(await this.callApi(params, req, runtime), new RetrieveDomainResponse({}));
  }

  /**
   * Retrieves a domain name.
   * 
   * @remarks
   * To retrieve a domain name, you must verify a text (TXT) record. Therefore, before you call this API operation to retrieve a domain name, call the [GetTxtRecordForVerify](https://www.alibabacloud.com/help/zh/alibaba-cloud-dns/latest/generating-a-txt-record) operation to generate a TXT record.
   * 
   * @param request - RetrieveDomainRequest
   * @returns RetrieveDomainResponse
   */
  async retrieveDomain(request: RetrieveDomainRequest): Promise<RetrieveDomainResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.retrieveDomainWithOptions(request, runtime);
  }

  /**
   * @param request - RollbackGtmRecoveryPlanRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RollbackGtmRecoveryPlanResponse
   */
  async rollbackGtmRecoveryPlanWithOptions(request: RollbackGtmRecoveryPlanRequest, runtime: $Util.RuntimeOptions): Promise<RollbackGtmRecoveryPlanResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.recoveryPlanId)) {
      query["RecoveryPlanId"] = request.recoveryPlanId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RollbackGtmRecoveryPlan",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RollbackGtmRecoveryPlanResponse>(await this.callApi(params, req, runtime), new RollbackGtmRecoveryPlanResponse({}));
  }

  /**
   * @param request - RollbackGtmRecoveryPlanRequest
   * @returns RollbackGtmRecoveryPlanResponse
   */
  async rollbackGtmRecoveryPlan(request: RollbackGtmRecoveryPlanRequest): Promise<RollbackGtmRecoveryPlanResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.rollbackGtmRecoveryPlanWithOptions(request, runtime);
  }

  /**
   * @param request - SearchCloudGtmAddressPoolsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SearchCloudGtmAddressPoolsResponse
   */
  async searchCloudGtmAddressPoolsWithOptions(request: SearchCloudGtmAddressPoolsRequest, runtime: $Util.RuntimeOptions): Promise<SearchCloudGtmAddressPoolsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.addressPoolName)) {
      query["AddressPoolName"] = request.addressPoolName;
    }

    if (!Util.isUnset(request.addressPoolType)) {
      query["AddressPoolType"] = request.addressPoolType;
    }

    if (!Util.isUnset(request.availableStatus)) {
      query["AvailableStatus"] = request.availableStatus;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.enableStatus)) {
      query["EnableStatus"] = request.enableStatus;
    }

    if (!Util.isUnset(request.healthStatus)) {
      query["HealthStatus"] = request.healthStatus;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.remark)) {
      query["Remark"] = request.remark;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SearchCloudGtmAddressPools",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SearchCloudGtmAddressPoolsResponse>(await this.callApi(params, req, runtime), new SearchCloudGtmAddressPoolsResponse({}));
  }

  /**
   * @param request - SearchCloudGtmAddressPoolsRequest
   * @returns SearchCloudGtmAddressPoolsResponse
   */
  async searchCloudGtmAddressPools(request: SearchCloudGtmAddressPoolsRequest): Promise<SearchCloudGtmAddressPoolsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.searchCloudGtmAddressPoolsWithOptions(request, runtime);
  }

  /**
   * @param request - SearchCloudGtmAddressesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SearchCloudGtmAddressesResponse
   */
  async searchCloudGtmAddressesWithOptions(request: SearchCloudGtmAddressesRequest, runtime: $Util.RuntimeOptions): Promise<SearchCloudGtmAddressesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.address)) {
      query["Address"] = request.address;
    }

    if (!Util.isUnset(request.addressId)) {
      query["AddressId"] = request.addressId;
    }

    if (!Util.isUnset(request.availableStatus)) {
      query["AvailableStatus"] = request.availableStatus;
    }

    if (!Util.isUnset(request.enableStatus)) {
      query["EnableStatus"] = request.enableStatus;
    }

    if (!Util.isUnset(request.healthStatus)) {
      query["HealthStatus"] = request.healthStatus;
    }

    if (!Util.isUnset(request.monitorTemplateName)) {
      query["MonitorTemplateName"] = request.monitorTemplateName;
    }

    if (!Util.isUnset(request.nameSearchCondition)) {
      query["NameSearchCondition"] = request.nameSearchCondition;
    }

    if (!Util.isUnset(request.names)) {
      query["Names"] = request.names;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.remarkSearchCondition)) {
      query["RemarkSearchCondition"] = request.remarkSearchCondition;
    }

    if (!Util.isUnset(request.remarks)) {
      query["Remarks"] = request.remarks;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SearchCloudGtmAddresses",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SearchCloudGtmAddressesResponse>(await this.callApi(params, req, runtime), new SearchCloudGtmAddressesResponse({}));
  }

  /**
   * @param request - SearchCloudGtmAddressesRequest
   * @returns SearchCloudGtmAddressesResponse
   */
  async searchCloudGtmAddresses(request: SearchCloudGtmAddressesRequest): Promise<SearchCloudGtmAddressesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.searchCloudGtmAddressesWithOptions(request, runtime);
  }

  /**
   * @param request - SearchCloudGtmInstanceConfigsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SearchCloudGtmInstanceConfigsResponse
   */
  async searchCloudGtmInstanceConfigsWithOptions(request: SearchCloudGtmInstanceConfigsRequest, runtime: $Util.RuntimeOptions): Promise<SearchCloudGtmInstanceConfigsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.availableStatus)) {
      query["AvailableStatus"] = request.availableStatus;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.enableStatus)) {
      query["EnableStatus"] = request.enableStatus;
    }

    if (!Util.isUnset(request.healthStatus)) {
      query["HealthStatus"] = request.healthStatus;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.remark)) {
      query["Remark"] = request.remark;
    }

    if (!Util.isUnset(request.scheduleDomainName)) {
      query["ScheduleDomainName"] = request.scheduleDomainName;
    }

    if (!Util.isUnset(request.scheduleZoneName)) {
      query["ScheduleZoneName"] = request.scheduleZoneName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SearchCloudGtmInstanceConfigs",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SearchCloudGtmInstanceConfigsResponse>(await this.callApi(params, req, runtime), new SearchCloudGtmInstanceConfigsResponse({}));
  }

  /**
   * @param request - SearchCloudGtmInstanceConfigsRequest
   * @returns SearchCloudGtmInstanceConfigsResponse
   */
  async searchCloudGtmInstanceConfigs(request: SearchCloudGtmInstanceConfigsRequest): Promise<SearchCloudGtmInstanceConfigsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.searchCloudGtmInstanceConfigsWithOptions(request, runtime);
  }

  /**
   * @param request - SearchCloudGtmInstancesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SearchCloudGtmInstancesResponse
   */
  async searchCloudGtmInstancesWithOptions(request: SearchCloudGtmInstancesRequest, runtime: $Util.RuntimeOptions): Promise<SearchCloudGtmInstancesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.instanceName)) {
      query["InstanceName"] = request.instanceName;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SearchCloudGtmInstances",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SearchCloudGtmInstancesResponse>(await this.callApi(params, req, runtime), new SearchCloudGtmInstancesResponse({}));
  }

  /**
   * @param request - SearchCloudGtmInstancesRequest
   * @returns SearchCloudGtmInstancesResponse
   */
  async searchCloudGtmInstances(request: SearchCloudGtmInstancesRequest): Promise<SearchCloudGtmInstancesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.searchCloudGtmInstancesWithOptions(request, runtime);
  }

  /**
   * @param request - SearchCloudGtmMonitorTemplatesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SearchCloudGtmMonitorTemplatesResponse
   */
  async searchCloudGtmMonitorTemplatesWithOptions(request: SearchCloudGtmMonitorTemplatesRequest, runtime: $Util.RuntimeOptions): Promise<SearchCloudGtmMonitorTemplatesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.ipVersion)) {
      query["IpVersion"] = request.ipVersion;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.protocol)) {
      query["Protocol"] = request.protocol;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SearchCloudGtmMonitorTemplates",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SearchCloudGtmMonitorTemplatesResponse>(await this.callApi(params, req, runtime), new SearchCloudGtmMonitorTemplatesResponse({}));
  }

  /**
   * @param request - SearchCloudGtmMonitorTemplatesRequest
   * @returns SearchCloudGtmMonitorTemplatesResponse
   */
  async searchCloudGtmMonitorTemplates(request: SearchCloudGtmMonitorTemplatesRequest): Promise<SearchCloudGtmMonitorTemplatesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.searchCloudGtmMonitorTemplatesWithOptions(request, runtime);
  }

  /**
   * Enables or disables weighted round-robin based on the specified parameters.
   * 
   * @param request - SetDNSSLBStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SetDNSSLBStatusResponse
   */
  async setDNSSLBStatusWithOptions(request: SetDNSSLBStatusRequest, runtime: $Util.RuntimeOptions): Promise<SetDNSSLBStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.line)) {
      query["Line"] = request.line;
    }

    if (!Util.isUnset(request.open)) {
      query["Open"] = request.open;
    }

    if (!Util.isUnset(request.subDomain)) {
      query["SubDomain"] = request.subDomain;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    if (!Util.isUnset(request.userClientIp)) {
      query["UserClientIp"] = request.userClientIp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetDNSSLBStatus",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetDNSSLBStatusResponse>(await this.callApi(params, req, runtime), new SetDNSSLBStatusResponse({}));
  }

  /**
   * Enables or disables weighted round-robin based on the specified parameters.
   * 
   * @param request - SetDNSSLBStatusRequest
   * @returns SetDNSSLBStatusResponse
   */
  async setDNSSLBStatus(request: SetDNSSLBStatusRequest): Promise<SetDNSSLBStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setDNSSLBStatusWithOptions(request, runtime);
  }

  /**
   * @remarks
   * ***
   * 
   * @param request - SetDnsGtmAccessModeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SetDnsGtmAccessModeResponse
   */
  async setDnsGtmAccessModeWithOptions(request: SetDnsGtmAccessModeRequest, runtime: $Util.RuntimeOptions): Promise<SetDnsGtmAccessModeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.accessMode)) {
      query["AccessMode"] = request.accessMode;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.strategyId)) {
      query["StrategyId"] = request.strategyId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetDnsGtmAccessMode",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetDnsGtmAccessModeResponse>(await this.callApi(params, req, runtime), new SetDnsGtmAccessModeResponse({}));
  }

  /**
   * @remarks
   * ***
   * 
   * @param request - SetDnsGtmAccessModeRequest
   * @returns SetDnsGtmAccessModeResponse
   */
  async setDnsGtmAccessMode(request: SetDnsGtmAccessModeRequest): Promise<SetDnsGtmAccessModeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setDnsGtmAccessModeWithOptions(request, runtime);
  }

  /**
   * Specifies the health check status of an address pool.
   * 
   * @param request - SetDnsGtmMonitorStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SetDnsGtmMonitorStatusResponse
   */
  async setDnsGtmMonitorStatusWithOptions(request: SetDnsGtmMonitorStatusRequest, runtime: $Util.RuntimeOptions): Promise<SetDnsGtmMonitorStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.monitorConfigId)) {
      query["MonitorConfigId"] = request.monitorConfigId;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetDnsGtmMonitorStatus",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetDnsGtmMonitorStatusResponse>(await this.callApi(params, req, runtime), new SetDnsGtmMonitorStatusResponse({}));
  }

  /**
   * Specifies the health check status of an address pool.
   * 
   * @param request - SetDnsGtmMonitorStatusRequest
   * @returns SetDnsGtmMonitorStatusResponse
   */
  async setDnsGtmMonitorStatus(request: SetDnsGtmMonitorStatusRequest): Promise<SetDnsGtmMonitorStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setDnsGtmMonitorStatusWithOptions(request, runtime);
  }

  /**
   * Sets the Domain Name System Security Extensions (DNSSEC) status of a domain name.
   * 
   * @param request - SetDomainDnssecStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SetDomainDnssecStatusResponse
   */
  async setDomainDnssecStatusWithOptions(request: SetDomainDnssecStatusRequest, runtime: $Util.RuntimeOptions): Promise<SetDomainDnssecStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetDomainDnssecStatus",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetDomainDnssecStatusResponse>(await this.callApi(params, req, runtime), new SetDomainDnssecStatusResponse({}));
  }

  /**
   * Sets the Domain Name System Security Extensions (DNSSEC) status of a domain name.
   * 
   * @param request - SetDomainDnssecStatusRequest
   * @returns SetDomainDnssecStatusResponse
   */
  async setDomainDnssecStatus(request: SetDomainDnssecStatusRequest): Promise<SetDomainDnssecStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setDomainDnssecStatusWithOptions(request, runtime);
  }

  /**
   * Specifies the status of a Domain Name System (DNS) record based on the specified parameters.
   * 
   * @param request - SetDomainRecordStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SetDomainRecordStatusResponse
   */
  async setDomainRecordStatusWithOptions(request: SetDomainRecordStatusRequest, runtime: $Util.RuntimeOptions): Promise<SetDomainRecordStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.recordId)) {
      query["RecordId"] = request.recordId;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    if (!Util.isUnset(request.userClientIp)) {
      query["UserClientIp"] = request.userClientIp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetDomainRecordStatus",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetDomainRecordStatusResponse>(await this.callApi(params, req, runtime), new SetDomainRecordStatusResponse({}));
  }

  /**
   * Specifies the status of a Domain Name System (DNS) record based on the specified parameters.
   * 
   * @param request - SetDomainRecordStatusRequest
   * @returns SetDomainRecordStatusResponse
   */
  async setDomainRecordStatus(request: SetDomainRecordStatusRequest): Promise<SetDomainRecordStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setDomainRecordStatusWithOptions(request, runtime);
  }

  /**
   * @param request - SetGtmAccessModeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SetGtmAccessModeResponse
   */
  async setGtmAccessModeWithOptions(request: SetGtmAccessModeRequest, runtime: $Util.RuntimeOptions): Promise<SetGtmAccessModeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.accessMode)) {
      query["AccessMode"] = request.accessMode;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.strategyId)) {
      query["StrategyId"] = request.strategyId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetGtmAccessMode",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetGtmAccessModeResponse>(await this.callApi(params, req, runtime), new SetGtmAccessModeResponse({}));
  }

  /**
   * @param request - SetGtmAccessModeRequest
   * @returns SetGtmAccessModeResponse
   */
  async setGtmAccessMode(request: SetGtmAccessModeRequest): Promise<SetGtmAccessModeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setGtmAccessModeWithOptions(request, runtime);
  }

  /**
   * @param request - SetGtmMonitorStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SetGtmMonitorStatusResponse
   */
  async setGtmMonitorStatusWithOptions(request: SetGtmMonitorStatusRequest, runtime: $Util.RuntimeOptions): Promise<SetGtmMonitorStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.monitorConfigId)) {
      query["MonitorConfigId"] = request.monitorConfigId;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetGtmMonitorStatus",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetGtmMonitorStatusResponse>(await this.callApi(params, req, runtime), new SetGtmMonitorStatusResponse({}));
  }

  /**
   * @param request - SetGtmMonitorStatusRequest
   * @returns SetGtmMonitorStatusResponse
   */
  async setGtmMonitorStatus(request: SetGtmMonitorStatusRequest): Promise<SetGtmMonitorStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setGtmMonitorStatusWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - SubmitIspFlushCacheTaskRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SubmitIspFlushCacheTaskResponse
   */
  async submitIspFlushCacheTaskWithOptions(request: SubmitIspFlushCacheTaskRequest, runtime: $Util.RuntimeOptions): Promise<SubmitIspFlushCacheTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.isp)) {
      query["Isp"] = request.isp;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SubmitIspFlushCacheTask",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SubmitIspFlushCacheTaskResponse>(await this.callApi(params, req, runtime), new SubmitIspFlushCacheTaskResponse({}));
  }

  /**
   * 
   * 
   * @param request - SubmitIspFlushCacheTaskRequest
   * @returns SubmitIspFlushCacheTaskResponse
   */
  async submitIspFlushCacheTask(request: SubmitIspFlushCacheTaskRequest): Promise<SubmitIspFlushCacheTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.submitIspFlushCacheTaskWithOptions(request, runtime);
  }

  /**
   * Changes the access policy type for a Global Traffic Manager (GTM) instance.
   * 
   * @param request - SwitchDnsGtmInstanceStrategyModeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SwitchDnsGtmInstanceStrategyModeResponse
   */
  async switchDnsGtmInstanceStrategyModeWithOptions(request: SwitchDnsGtmInstanceStrategyModeRequest, runtime: $Util.RuntimeOptions): Promise<SwitchDnsGtmInstanceStrategyModeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.strategyMode)) {
      query["StrategyMode"] = request.strategyMode;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SwitchDnsGtmInstanceStrategyMode",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SwitchDnsGtmInstanceStrategyModeResponse>(await this.callApi(params, req, runtime), new SwitchDnsGtmInstanceStrategyModeResponse({}));
  }

  /**
   * Changes the access policy type for a Global Traffic Manager (GTM) instance.
   * 
   * @param request - SwitchDnsGtmInstanceStrategyModeRequest
   * @returns SwitchDnsGtmInstanceStrategyModeResponse
   */
  async switchDnsGtmInstanceStrategyMode(request: SwitchDnsGtmInstanceStrategyModeRequest): Promise<SwitchDnsGtmInstanceStrategyModeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.switchDnsGtmInstanceStrategyModeWithOptions(request, runtime);
  }

  /**
   * Adds and modifies a tag for a resource.
   * 
   * @param request - TagResourcesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns TagResourcesResponse
   */
  async tagResourcesWithOptions(request: TagResourcesRequest, runtime: $Util.RuntimeOptions): Promise<TagResourcesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!Util.isUnset(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "TagResources",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<TagResourcesResponse>(await this.callApi(params, req, runtime), new TagResourcesResponse({}));
  }

  /**
   * Adds and modifies a tag for a resource.
   * 
   * @param request - TagResourcesRequest
   * @returns TagResourcesResponse
   */
  async tagResources(request: TagResourcesRequest): Promise<TagResourcesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.tagResourcesWithOptions(request, runtime);
  }

  /**
   * Transfers multiple domain names from the current account to another account at a time.
   * 
   * @param request - TransferDomainRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns TransferDomainResponse
   */
  async transferDomainWithOptions(request: TransferDomainRequest, runtime: $Util.RuntimeOptions): Promise<TransferDomainResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainNames)) {
      query["DomainNames"] = request.domainNames;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.remark)) {
      query["Remark"] = request.remark;
    }

    if (!Util.isUnset(request.targetUserId)) {
      query["TargetUserId"] = request.targetUserId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "TransferDomain",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<TransferDomainResponse>(await this.callApi(params, req, runtime), new TransferDomainResponse({}));
  }

  /**
   * Transfers multiple domain names from the current account to another account at a time.
   * 
   * @param request - TransferDomainRequest
   * @returns TransferDomainResponse
   */
  async transferDomain(request: TransferDomainRequest): Promise<TransferDomainResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.transferDomainWithOptions(request, runtime);
  }

  /**
   * Unbinds one or more domain names from a paid Alibaba Cloud DNS instance based on the instance ID.
   * 
   * @remarks
   * A paid Alibaba Cloud DNS instance whose ID starts with dns is an instance of the new version. You can call an API operation to bind multiple domain names to the instance. If the upper limit is exceeded, an error message is returned.\\
   * A paid Alibaba Cloud DNS instance whose ID does not start with dns is an instance of the old version. You can call an API operation to bind only one domain name to the instance. However, if the instance that you want to bind to the desired domain name is already bound to a domain name, you can call this operation to unbind the original domain name from the instance and then bind the desired domain name to the instance.
   * 
   * @param request - UnbindInstanceDomainsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UnbindInstanceDomainsResponse
   */
  async unbindInstanceDomainsWithOptions(request: UnbindInstanceDomainsRequest, runtime: $Util.RuntimeOptions): Promise<UnbindInstanceDomainsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainNames)) {
      query["DomainNames"] = request.domainNames;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UnbindInstanceDomains",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UnbindInstanceDomainsResponse>(await this.callApi(params, req, runtime), new UnbindInstanceDomainsResponse({}));
  }

  /**
   * Unbinds one or more domain names from a paid Alibaba Cloud DNS instance based on the instance ID.
   * 
   * @remarks
   * A paid Alibaba Cloud DNS instance whose ID starts with dns is an instance of the new version. You can call an API operation to bind multiple domain names to the instance. If the upper limit is exceeded, an error message is returned.\\
   * A paid Alibaba Cloud DNS instance whose ID does not start with dns is an instance of the old version. You can call an API operation to bind only one domain name to the instance. However, if the instance that you want to bind to the desired domain name is already bound to a domain name, you can call this operation to unbind the original domain name from the instance and then bind the desired domain name to the instance.
   * 
   * @param request - UnbindInstanceDomainsRequest
   * @returns UnbindInstanceDomainsResponse
   */
  async unbindInstanceDomains(request: UnbindInstanceDomainsRequest): Promise<UnbindInstanceDomainsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.unbindInstanceDomainsWithOptions(request, runtime);
  }

  /**
   * Removes tags from resources.
   * 
   * @param request - UntagResourcesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UntagResourcesResponse
   */
  async untagResourcesWithOptions(request: UntagResourcesRequest, runtime: $Util.RuntimeOptions): Promise<UntagResourcesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.all)) {
      query["All"] = request.all;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!Util.isUnset(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    if (!Util.isUnset(request.tagKey)) {
      query["TagKey"] = request.tagKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UntagResources",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UntagResourcesResponse>(await this.callApi(params, req, runtime), new UntagResourcesResponse({}));
  }

  /**
   * Removes tags from resources.
   * 
   * @param request - UntagResourcesRequest
   * @returns UntagResourcesResponse
   */
  async untagResources(request: UntagResourcesRequest): Promise<UntagResourcesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.untagResourcesWithOptions(request, runtime);
  }

  /**
   *  AppKey 
   * 
   * @param request - UpdateAppKeyStateRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateAppKeyStateResponse
   */
  async updateAppKeyStateWithOptions(request: UpdateAppKeyStateRequest, runtime: $Util.RuntimeOptions): Promise<UpdateAppKeyStateResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appKeyId)) {
      query["AppKeyId"] = request.appKeyId;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.state)) {
      query["State"] = request.state;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateAppKeyState",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateAppKeyStateResponse>(await this.callApi(params, req, runtime), new UpdateAppKeyStateResponse({}));
  }

  /**
   *  AppKey 
   * 
   * @param request - UpdateAppKeyStateRequest
   * @returns UpdateAppKeyStateResponse
   */
  async updateAppKeyState(request: UpdateAppKeyStateRequest): Promise<UpdateAppKeyStateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateAppKeyStateWithOptions(request, runtime);
  }

  /**
   * @param tmpReq - UpdateCloudGtmAddressRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateCloudGtmAddressResponse
   */
  async updateCloudGtmAddressWithOptions(tmpReq: UpdateCloudGtmAddressRequest, runtime: $Util.RuntimeOptions): Promise<UpdateCloudGtmAddressResponse> {
    Util.validateModel(tmpReq);
    let request = new UpdateCloudGtmAddressShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.healthTasks)) {
      request.healthTasksShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.healthTasks, "HealthTasks", "json");
    }

    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.address)) {
      query["Address"] = request.address;
    }

    if (!Util.isUnset(request.addressId)) {
      query["AddressId"] = request.addressId;
    }

    if (!Util.isUnset(request.attributeInfo)) {
      query["AttributeInfo"] = request.attributeInfo;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.healthJudgement)) {
      query["HealthJudgement"] = request.healthJudgement;
    }

    if (!Util.isUnset(request.healthTasksShrink)) {
      query["HealthTasks"] = request.healthTasksShrink;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateCloudGtmAddress",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateCloudGtmAddressResponse>(await this.callApi(params, req, runtime), new UpdateCloudGtmAddressResponse({}));
  }

  /**
   * @param request - UpdateCloudGtmAddressRequest
   * @returns UpdateCloudGtmAddressResponse
   */
  async updateCloudGtmAddress(request: UpdateCloudGtmAddressRequest): Promise<UpdateCloudGtmAddressResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateCloudGtmAddressWithOptions(request, runtime);
  }

  /**
   * @param request - UpdateCloudGtmAddressEnableStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateCloudGtmAddressEnableStatusResponse
   */
  async updateCloudGtmAddressEnableStatusWithOptions(request: UpdateCloudGtmAddressEnableStatusRequest, runtime: $Util.RuntimeOptions): Promise<UpdateCloudGtmAddressEnableStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.addressId)) {
      query["AddressId"] = request.addressId;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.enableStatus)) {
      query["EnableStatus"] = request.enableStatus;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateCloudGtmAddressEnableStatus",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateCloudGtmAddressEnableStatusResponse>(await this.callApi(params, req, runtime), new UpdateCloudGtmAddressEnableStatusResponse({}));
  }

  /**
   * @param request - UpdateCloudGtmAddressEnableStatusRequest
   * @returns UpdateCloudGtmAddressEnableStatusResponse
   */
  async updateCloudGtmAddressEnableStatus(request: UpdateCloudGtmAddressEnableStatusRequest): Promise<UpdateCloudGtmAddressEnableStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateCloudGtmAddressEnableStatusWithOptions(request, runtime);
  }

  /**
   * @param request - UpdateCloudGtmAddressManualAvailableStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateCloudGtmAddressManualAvailableStatusResponse
   */
  async updateCloudGtmAddressManualAvailableStatusWithOptions(request: UpdateCloudGtmAddressManualAvailableStatusRequest, runtime: $Util.RuntimeOptions): Promise<UpdateCloudGtmAddressManualAvailableStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.addressId)) {
      query["AddressId"] = request.addressId;
    }

    if (!Util.isUnset(request.availableMode)) {
      query["AvailableMode"] = request.availableMode;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.manualAvailableStatus)) {
      query["ManualAvailableStatus"] = request.manualAvailableStatus;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateCloudGtmAddressManualAvailableStatus",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateCloudGtmAddressManualAvailableStatusResponse>(await this.callApi(params, req, runtime), new UpdateCloudGtmAddressManualAvailableStatusResponse({}));
  }

  /**
   * @param request - UpdateCloudGtmAddressManualAvailableStatusRequest
   * @returns UpdateCloudGtmAddressManualAvailableStatusResponse
   */
  async updateCloudGtmAddressManualAvailableStatus(request: UpdateCloudGtmAddressManualAvailableStatusRequest): Promise<UpdateCloudGtmAddressManualAvailableStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateCloudGtmAddressManualAvailableStatusWithOptions(request, runtime);
  }

  /**
   * @param request - UpdateCloudGtmAddressPoolBasicConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateCloudGtmAddressPoolBasicConfigResponse
   */
  async updateCloudGtmAddressPoolBasicConfigWithOptions(request: UpdateCloudGtmAddressPoolBasicConfigRequest, runtime: $Util.RuntimeOptions): Promise<UpdateCloudGtmAddressPoolBasicConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.addressPoolId)) {
      query["AddressPoolId"] = request.addressPoolId;
    }

    if (!Util.isUnset(request.addressPoolName)) {
      query["AddressPoolName"] = request.addressPoolName;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.healthJudgement)) {
      query["HealthJudgement"] = request.healthJudgement;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateCloudGtmAddressPoolBasicConfig",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateCloudGtmAddressPoolBasicConfigResponse>(await this.callApi(params, req, runtime), new UpdateCloudGtmAddressPoolBasicConfigResponse({}));
  }

  /**
   * @param request - UpdateCloudGtmAddressPoolBasicConfigRequest
   * @returns UpdateCloudGtmAddressPoolBasicConfigResponse
   */
  async updateCloudGtmAddressPoolBasicConfig(request: UpdateCloudGtmAddressPoolBasicConfigRequest): Promise<UpdateCloudGtmAddressPoolBasicConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateCloudGtmAddressPoolBasicConfigWithOptions(request, runtime);
  }

  /**
   * @param request - UpdateCloudGtmAddressPoolEnableStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateCloudGtmAddressPoolEnableStatusResponse
   */
  async updateCloudGtmAddressPoolEnableStatusWithOptions(request: UpdateCloudGtmAddressPoolEnableStatusRequest, runtime: $Util.RuntimeOptions): Promise<UpdateCloudGtmAddressPoolEnableStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.addressPoolId)) {
      query["AddressPoolId"] = request.addressPoolId;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.enableStatus)) {
      query["EnableStatus"] = request.enableStatus;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateCloudGtmAddressPoolEnableStatus",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateCloudGtmAddressPoolEnableStatusResponse>(await this.callApi(params, req, runtime), new UpdateCloudGtmAddressPoolEnableStatusResponse({}));
  }

  /**
   * @param request - UpdateCloudGtmAddressPoolEnableStatusRequest
   * @returns UpdateCloudGtmAddressPoolEnableStatusResponse
   */
  async updateCloudGtmAddressPoolEnableStatus(request: UpdateCloudGtmAddressPoolEnableStatusRequest): Promise<UpdateCloudGtmAddressPoolEnableStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateCloudGtmAddressPoolEnableStatusWithOptions(request, runtime);
  }

  /**
   * @param request - UpdateCloudGtmAddressPoolLbStrategyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateCloudGtmAddressPoolLbStrategyResponse
   */
  async updateCloudGtmAddressPoolLbStrategyWithOptions(request: UpdateCloudGtmAddressPoolLbStrategyRequest, runtime: $Util.RuntimeOptions): Promise<UpdateCloudGtmAddressPoolLbStrategyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.addressLbStrategy)) {
      query["AddressLbStrategy"] = request.addressLbStrategy;
    }

    if (!Util.isUnset(request.addressPoolId)) {
      query["AddressPoolId"] = request.addressPoolId;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.sequenceLbStrategyMode)) {
      query["SequenceLbStrategyMode"] = request.sequenceLbStrategyMode;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateCloudGtmAddressPoolLbStrategy",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateCloudGtmAddressPoolLbStrategyResponse>(await this.callApi(params, req, runtime), new UpdateCloudGtmAddressPoolLbStrategyResponse({}));
  }

  /**
   * @param request - UpdateCloudGtmAddressPoolLbStrategyRequest
   * @returns UpdateCloudGtmAddressPoolLbStrategyResponse
   */
  async updateCloudGtmAddressPoolLbStrategy(request: UpdateCloudGtmAddressPoolLbStrategyRequest): Promise<UpdateCloudGtmAddressPoolLbStrategyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateCloudGtmAddressPoolLbStrategyWithOptions(request, runtime);
  }

  /**
   * @param request - UpdateCloudGtmAddressPoolRemarkRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateCloudGtmAddressPoolRemarkResponse
   */
  async updateCloudGtmAddressPoolRemarkWithOptions(request: UpdateCloudGtmAddressPoolRemarkRequest, runtime: $Util.RuntimeOptions): Promise<UpdateCloudGtmAddressPoolRemarkResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.addressPoolId)) {
      query["AddressPoolId"] = request.addressPoolId;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.remark)) {
      query["Remark"] = request.remark;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateCloudGtmAddressPoolRemark",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateCloudGtmAddressPoolRemarkResponse>(await this.callApi(params, req, runtime), new UpdateCloudGtmAddressPoolRemarkResponse({}));
  }

  /**
   * @param request - UpdateCloudGtmAddressPoolRemarkRequest
   * @returns UpdateCloudGtmAddressPoolRemarkResponse
   */
  async updateCloudGtmAddressPoolRemark(request: UpdateCloudGtmAddressPoolRemarkRequest): Promise<UpdateCloudGtmAddressPoolRemarkResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateCloudGtmAddressPoolRemarkWithOptions(request, runtime);
  }

  /**
   * @param request - UpdateCloudGtmAddressRemarkRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateCloudGtmAddressRemarkResponse
   */
  async updateCloudGtmAddressRemarkWithOptions(request: UpdateCloudGtmAddressRemarkRequest, runtime: $Util.RuntimeOptions): Promise<UpdateCloudGtmAddressRemarkResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.addressId)) {
      query["AddressId"] = request.addressId;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.remark)) {
      query["Remark"] = request.remark;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateCloudGtmAddressRemark",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateCloudGtmAddressRemarkResponse>(await this.callApi(params, req, runtime), new UpdateCloudGtmAddressRemarkResponse({}));
  }

  /**
   * @param request - UpdateCloudGtmAddressRemarkRequest
   * @returns UpdateCloudGtmAddressRemarkResponse
   */
  async updateCloudGtmAddressRemark(request: UpdateCloudGtmAddressRemarkRequest): Promise<UpdateCloudGtmAddressRemarkResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateCloudGtmAddressRemarkWithOptions(request, runtime);
  }

  /**
   * @param tmpReq - UpdateCloudGtmGlobalAlertRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateCloudGtmGlobalAlertResponse
   */
  async updateCloudGtmGlobalAlertWithOptions(tmpReq: UpdateCloudGtmGlobalAlertRequest, runtime: $Util.RuntimeOptions): Promise<UpdateCloudGtmGlobalAlertResponse> {
    Util.validateModel(tmpReq);
    let request = new UpdateCloudGtmGlobalAlertShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.alertConfig)) {
      request.alertConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.alertConfig, "AlertConfig", "json");
    }

    if (!Util.isUnset(tmpReq.alertGroup)) {
      request.alertGroupShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.alertGroup, "AlertGroup", "json");
    }

    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.alertConfigShrink)) {
      query["AlertConfig"] = request.alertConfigShrink;
    }

    if (!Util.isUnset(request.alertGroupShrink)) {
      query["AlertGroup"] = request.alertGroupShrink;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateCloudGtmGlobalAlert",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateCloudGtmGlobalAlertResponse>(await this.callApi(params, req, runtime), new UpdateCloudGtmGlobalAlertResponse({}));
  }

  /**
   * @param request - UpdateCloudGtmGlobalAlertRequest
   * @returns UpdateCloudGtmGlobalAlertResponse
   */
  async updateCloudGtmGlobalAlert(request: UpdateCloudGtmGlobalAlertRequest): Promise<UpdateCloudGtmGlobalAlertResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateCloudGtmGlobalAlertWithOptions(request, runtime);
  }

  /**
   * @param tmpReq - UpdateCloudGtmInstanceConfigAlertRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateCloudGtmInstanceConfigAlertResponse
   */
  async updateCloudGtmInstanceConfigAlertWithOptions(tmpReq: UpdateCloudGtmInstanceConfigAlertRequest, runtime: $Util.RuntimeOptions): Promise<UpdateCloudGtmInstanceConfigAlertResponse> {
    Util.validateModel(tmpReq);
    let request = new UpdateCloudGtmInstanceConfigAlertShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.alertConfig)) {
      request.alertConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.alertConfig, "AlertConfig", "json");
    }

    if (!Util.isUnset(tmpReq.alertGroup)) {
      request.alertGroupShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.alertGroup, "AlertGroup", "json");
    }

    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.alertConfigShrink)) {
      query["AlertConfig"] = request.alertConfigShrink;
    }

    if (!Util.isUnset(request.alertGroupShrink)) {
      query["AlertGroup"] = request.alertGroupShrink;
    }

    if (!Util.isUnset(request.alertMode)) {
      query["AlertMode"] = request.alertMode;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.configId)) {
      query["ConfigId"] = request.configId;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateCloudGtmInstanceConfigAlert",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateCloudGtmInstanceConfigAlertResponse>(await this.callApi(params, req, runtime), new UpdateCloudGtmInstanceConfigAlertResponse({}));
  }

  /**
   * @param request - UpdateCloudGtmInstanceConfigAlertRequest
   * @returns UpdateCloudGtmInstanceConfigAlertResponse
   */
  async updateCloudGtmInstanceConfigAlert(request: UpdateCloudGtmInstanceConfigAlertRequest): Promise<UpdateCloudGtmInstanceConfigAlertResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateCloudGtmInstanceConfigAlertWithOptions(request, runtime);
  }

  /**
   * @param request - UpdateCloudGtmInstanceConfigBasicRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateCloudGtmInstanceConfigBasicResponse
   */
  async updateCloudGtmInstanceConfigBasicWithOptions(request: UpdateCloudGtmInstanceConfigBasicRequest, runtime: $Util.RuntimeOptions): Promise<UpdateCloudGtmInstanceConfigBasicResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.configId)) {
      query["ConfigId"] = request.configId;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.scheduleHostname)) {
      query["ScheduleHostname"] = request.scheduleHostname;
    }

    if (!Util.isUnset(request.scheduleZoneName)) {
      query["ScheduleZoneName"] = request.scheduleZoneName;
    }

    if (!Util.isUnset(request.ttl)) {
      query["Ttl"] = request.ttl;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateCloudGtmInstanceConfigBasic",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateCloudGtmInstanceConfigBasicResponse>(await this.callApi(params, req, runtime), new UpdateCloudGtmInstanceConfigBasicResponse({}));
  }

  /**
   * @param request - UpdateCloudGtmInstanceConfigBasicRequest
   * @returns UpdateCloudGtmInstanceConfigBasicResponse
   */
  async updateCloudGtmInstanceConfigBasic(request: UpdateCloudGtmInstanceConfigBasicRequest): Promise<UpdateCloudGtmInstanceConfigBasicResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateCloudGtmInstanceConfigBasicWithOptions(request, runtime);
  }

  /**
   * @param request - UpdateCloudGtmInstanceConfigEnableStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateCloudGtmInstanceConfigEnableStatusResponse
   */
  async updateCloudGtmInstanceConfigEnableStatusWithOptions(request: UpdateCloudGtmInstanceConfigEnableStatusRequest, runtime: $Util.RuntimeOptions): Promise<UpdateCloudGtmInstanceConfigEnableStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.configId)) {
      query["ConfigId"] = request.configId;
    }

    if (!Util.isUnset(request.enableStatus)) {
      query["EnableStatus"] = request.enableStatus;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateCloudGtmInstanceConfigEnableStatus",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateCloudGtmInstanceConfigEnableStatusResponse>(await this.callApi(params, req, runtime), new UpdateCloudGtmInstanceConfigEnableStatusResponse({}));
  }

  /**
   * @param request - UpdateCloudGtmInstanceConfigEnableStatusRequest
   * @returns UpdateCloudGtmInstanceConfigEnableStatusResponse
   */
  async updateCloudGtmInstanceConfigEnableStatus(request: UpdateCloudGtmInstanceConfigEnableStatusRequest): Promise<UpdateCloudGtmInstanceConfigEnableStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateCloudGtmInstanceConfigEnableStatusWithOptions(request, runtime);
  }

  /**
   * @param request - UpdateCloudGtmInstanceConfigLbStrategyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateCloudGtmInstanceConfigLbStrategyResponse
   */
  async updateCloudGtmInstanceConfigLbStrategyWithOptions(request: UpdateCloudGtmInstanceConfigLbStrategyRequest, runtime: $Util.RuntimeOptions): Promise<UpdateCloudGtmInstanceConfigLbStrategyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.addressPoolLbStrategy)) {
      query["AddressPoolLbStrategy"] = request.addressPoolLbStrategy;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.configId)) {
      query["ConfigId"] = request.configId;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.sequenceLbStrategyMode)) {
      query["SequenceLbStrategyMode"] = request.sequenceLbStrategyMode;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateCloudGtmInstanceConfigLbStrategy",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateCloudGtmInstanceConfigLbStrategyResponse>(await this.callApi(params, req, runtime), new UpdateCloudGtmInstanceConfigLbStrategyResponse({}));
  }

  /**
   * @param request - UpdateCloudGtmInstanceConfigLbStrategyRequest
   * @returns UpdateCloudGtmInstanceConfigLbStrategyResponse
   */
  async updateCloudGtmInstanceConfigLbStrategy(request: UpdateCloudGtmInstanceConfigLbStrategyRequest): Promise<UpdateCloudGtmInstanceConfigLbStrategyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateCloudGtmInstanceConfigLbStrategyWithOptions(request, runtime);
  }

  /**
   * @param request - UpdateCloudGtmInstanceConfigRemarkRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateCloudGtmInstanceConfigRemarkResponse
   */
  async updateCloudGtmInstanceConfigRemarkWithOptions(request: UpdateCloudGtmInstanceConfigRemarkRequest, runtime: $Util.RuntimeOptions): Promise<UpdateCloudGtmInstanceConfigRemarkResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.configId)) {
      query["ConfigId"] = request.configId;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.remark)) {
      query["Remark"] = request.remark;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateCloudGtmInstanceConfigRemark",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateCloudGtmInstanceConfigRemarkResponse>(await this.callApi(params, req, runtime), new UpdateCloudGtmInstanceConfigRemarkResponse({}));
  }

  /**
   * @param request - UpdateCloudGtmInstanceConfigRemarkRequest
   * @returns UpdateCloudGtmInstanceConfigRemarkResponse
   */
  async updateCloudGtmInstanceConfigRemark(request: UpdateCloudGtmInstanceConfigRemarkRequest): Promise<UpdateCloudGtmInstanceConfigRemarkResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateCloudGtmInstanceConfigRemarkWithOptions(request, runtime);
  }

  /**
   * @param request - UpdateCloudGtmInstanceNameRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateCloudGtmInstanceNameResponse
   */
  async updateCloudGtmInstanceNameWithOptions(request: UpdateCloudGtmInstanceNameRequest, runtime: $Util.RuntimeOptions): Promise<UpdateCloudGtmInstanceNameResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.instanceName)) {
      query["InstanceName"] = request.instanceName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateCloudGtmInstanceName",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateCloudGtmInstanceNameResponse>(await this.callApi(params, req, runtime), new UpdateCloudGtmInstanceNameResponse({}));
  }

  /**
   * @param request - UpdateCloudGtmInstanceNameRequest
   * @returns UpdateCloudGtmInstanceNameResponse
   */
  async updateCloudGtmInstanceName(request: UpdateCloudGtmInstanceNameRequest): Promise<UpdateCloudGtmInstanceNameResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateCloudGtmInstanceNameWithOptions(request, runtime);
  }

  /**
   * @param tmpReq - UpdateCloudGtmMonitorTemplateRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateCloudGtmMonitorTemplateResponse
   */
  async updateCloudGtmMonitorTemplateWithOptions(tmpReq: UpdateCloudGtmMonitorTemplateRequest, runtime: $Util.RuntimeOptions): Promise<UpdateCloudGtmMonitorTemplateResponse> {
    Util.validateModel(tmpReq);
    let request = new UpdateCloudGtmMonitorTemplateShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.ispCityNodes)) {
      request.ispCityNodesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.ispCityNodes, "IspCityNodes", "json");
    }

    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.evaluationCount)) {
      query["EvaluationCount"] = request.evaluationCount;
    }

    if (!Util.isUnset(request.extendInfo)) {
      query["ExtendInfo"] = request.extendInfo;
    }

    if (!Util.isUnset(request.failureRate)) {
      query["FailureRate"] = request.failureRate;
    }

    if (!Util.isUnset(request.interval)) {
      query["Interval"] = request.interval;
    }

    if (!Util.isUnset(request.ispCityNodesShrink)) {
      query["IspCityNodes"] = request.ispCityNodesShrink;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.templateId)) {
      query["TemplateId"] = request.templateId;
    }

    if (!Util.isUnset(request.timeout)) {
      query["Timeout"] = request.timeout;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateCloudGtmMonitorTemplate",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateCloudGtmMonitorTemplateResponse>(await this.callApi(params, req, runtime), new UpdateCloudGtmMonitorTemplateResponse({}));
  }

  /**
   * @param request - UpdateCloudGtmMonitorTemplateRequest
   * @returns UpdateCloudGtmMonitorTemplateResponse
   */
  async updateCloudGtmMonitorTemplate(request: UpdateCloudGtmMonitorTemplateRequest): Promise<UpdateCloudGtmMonitorTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateCloudGtmMonitorTemplateWithOptions(request, runtime);
  }

  /**
   * @param request - UpdateCloudGtmMonitorTemplateRemarkRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateCloudGtmMonitorTemplateRemarkResponse
   */
  async updateCloudGtmMonitorTemplateRemarkWithOptions(request: UpdateCloudGtmMonitorTemplateRemarkRequest, runtime: $Util.RuntimeOptions): Promise<UpdateCloudGtmMonitorTemplateRemarkResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      query["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.remark)) {
      query["Remark"] = request.remark;
    }

    if (!Util.isUnset(request.templateId)) {
      query["TemplateId"] = request.templateId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateCloudGtmMonitorTemplateRemark",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateCloudGtmMonitorTemplateRemarkResponse>(await this.callApi(params, req, runtime), new UpdateCloudGtmMonitorTemplateRemarkResponse({}));
  }

  /**
   * @param request - UpdateCloudGtmMonitorTemplateRemarkRequest
   * @returns UpdateCloudGtmMonitorTemplateRemarkResponse
   */
  async updateCloudGtmMonitorTemplateRemark(request: UpdateCloudGtmMonitorTemplateRemarkRequest): Promise<UpdateCloudGtmMonitorTemplateRemarkResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateCloudGtmMonitorTemplateRemarkWithOptions(request, runtime);
  }

  /**
   * Modifies a custom line.
   * 
   * @remarks
   * In each CIDR block, the end IP address must be greater than or equal to the start IP address.\\
   * The CIDR blocks that are specified for all custom lines of a domain name cannot be overlapped.
   * 
   * @param request - UpdateCustomLineRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateCustomLineResponse
   */
  async updateCustomLineWithOptions(request: UpdateCustomLineRequest, runtime: $Util.RuntimeOptions): Promise<UpdateCustomLineResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ipSegment)) {
      query["IpSegment"] = request.ipSegment;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.lineId)) {
      query["LineId"] = request.lineId;
    }

    if (!Util.isUnset(request.lineName)) {
      query["LineName"] = request.lineName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateCustomLine",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateCustomLineResponse>(await this.callApi(params, req, runtime), new UpdateCustomLineResponse({}));
  }

  /**
   * Modifies a custom line.
   * 
   * @remarks
   * In each CIDR block, the end IP address must be greater than or equal to the start IP address.\\
   * The CIDR blocks that are specified for all custom lines of a domain name cannot be overlapped.
   * 
   * @param request - UpdateCustomLineRequest
   * @returns UpdateCustomLineResponse
   */
  async updateCustomLine(request: UpdateCustomLineRequest): Promise<UpdateCustomLineResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateCustomLineWithOptions(request, runtime);
  }

  /**
   * Modifies the weight of a Domain Name System (DNS) record based on the specified parameters.
   * 
   * @param request - UpdateDNSSLBWeightRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateDNSSLBWeightResponse
   */
  async updateDNSSLBWeightWithOptions(request: UpdateDNSSLBWeightRequest, runtime: $Util.RuntimeOptions): Promise<UpdateDNSSLBWeightResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.recordId)) {
      query["RecordId"] = request.recordId;
    }

    if (!Util.isUnset(request.userClientIp)) {
      query["UserClientIp"] = request.userClientIp;
    }

    if (!Util.isUnset(request.weight)) {
      query["Weight"] = request.weight;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateDNSSLBWeight",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateDNSSLBWeightResponse>(await this.callApi(params, req, runtime), new UpdateDNSSLBWeightResponse({}));
  }

  /**
   * Modifies the weight of a Domain Name System (DNS) record based on the specified parameters.
   * 
   * @param request - UpdateDNSSLBWeightRequest
   * @returns UpdateDNSSLBWeightResponse
   */
  async updateDNSSLBWeight(request: UpdateDNSSLBWeightRequest): Promise<UpdateDNSSLBWeightResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateDNSSLBWeightWithOptions(request, runtime);
  }

  /**
   * @param request - UpdateDnsCacheDomainRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateDnsCacheDomainResponse
   */
  async updateDnsCacheDomainWithOptions(request: UpdateDnsCacheDomainRequest, runtime: $Util.RuntimeOptions): Promise<UpdateDnsCacheDomainResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.cacheTtlMax)) {
      query["CacheTtlMax"] = request.cacheTtlMax;
    }

    if (!Util.isUnset(request.cacheTtlMin)) {
      query["CacheTtlMin"] = request.cacheTtlMin;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.sourceDnsServer)) {
      query["SourceDnsServer"] = request.sourceDnsServer;
    }

    if (!Util.isUnset(request.sourceEdns)) {
      query["SourceEdns"] = request.sourceEdns;
    }

    if (!Util.isUnset(request.sourceProtocol)) {
      query["SourceProtocol"] = request.sourceProtocol;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateDnsCacheDomain",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateDnsCacheDomainResponse>(await this.callApi(params, req, runtime), new UpdateDnsCacheDomainResponse({}));
  }

  /**
   * @param request - UpdateDnsCacheDomainRequest
   * @returns UpdateDnsCacheDomainResponse
   */
  async updateDnsCacheDomain(request: UpdateDnsCacheDomainRequest): Promise<UpdateDnsCacheDomainResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateDnsCacheDomainWithOptions(request, runtime);
  }

  /**
   * @param request - UpdateDnsCacheDomainRemarkRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateDnsCacheDomainRemarkResponse
   */
  async updateDnsCacheDomainRemarkWithOptions(request: UpdateDnsCacheDomainRemarkRequest, runtime: $Util.RuntimeOptions): Promise<UpdateDnsCacheDomainRemarkResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.remark)) {
      query["Remark"] = request.remark;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateDnsCacheDomainRemark",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateDnsCacheDomainRemarkResponse>(await this.callApi(params, req, runtime), new UpdateDnsCacheDomainRemarkResponse({}));
  }

  /**
   * @param request - UpdateDnsCacheDomainRemarkRequest
   * @returns UpdateDnsCacheDomainRemarkResponse
   */
  async updateDnsCacheDomainRemark(request: UpdateDnsCacheDomainRemarkRequest): Promise<UpdateDnsCacheDomainRemarkResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateDnsCacheDomainRemarkWithOptions(request, runtime);
  }

  /**
   * Modifies an access policy.
   * 
   * @param request - UpdateDnsGtmAccessStrategyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateDnsGtmAccessStrategyResponse
   */
  async updateDnsGtmAccessStrategyWithOptions(request: UpdateDnsGtmAccessStrategyRequest, runtime: $Util.RuntimeOptions): Promise<UpdateDnsGtmAccessStrategyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.accessMode)) {
      query["AccessMode"] = request.accessMode;
    }

    if (!Util.isUnset(request.defaultAddrPool)) {
      query["DefaultAddrPool"] = request.defaultAddrPool;
    }

    if (!Util.isUnset(request.defaultAddrPoolType)) {
      query["DefaultAddrPoolType"] = request.defaultAddrPoolType;
    }

    if (!Util.isUnset(request.defaultLatencyOptimization)) {
      query["DefaultLatencyOptimization"] = request.defaultLatencyOptimization;
    }

    if (!Util.isUnset(request.defaultLbaStrategy)) {
      query["DefaultLbaStrategy"] = request.defaultLbaStrategy;
    }

    if (!Util.isUnset(request.defaultMaxReturnAddrNum)) {
      query["DefaultMaxReturnAddrNum"] = request.defaultMaxReturnAddrNum;
    }

    if (!Util.isUnset(request.defaultMinAvailableAddrNum)) {
      query["DefaultMinAvailableAddrNum"] = request.defaultMinAvailableAddrNum;
    }

    if (!Util.isUnset(request.failoverAddrPool)) {
      query["FailoverAddrPool"] = request.failoverAddrPool;
    }

    if (!Util.isUnset(request.failoverAddrPoolType)) {
      query["FailoverAddrPoolType"] = request.failoverAddrPoolType;
    }

    if (!Util.isUnset(request.failoverLatencyOptimization)) {
      query["FailoverLatencyOptimization"] = request.failoverLatencyOptimization;
    }

    if (!Util.isUnset(request.failoverLbaStrategy)) {
      query["FailoverLbaStrategy"] = request.failoverLbaStrategy;
    }

    if (!Util.isUnset(request.failoverMaxReturnAddrNum)) {
      query["FailoverMaxReturnAddrNum"] = request.failoverMaxReturnAddrNum;
    }

    if (!Util.isUnset(request.failoverMinAvailableAddrNum)) {
      query["FailoverMinAvailableAddrNum"] = request.failoverMinAvailableAddrNum;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.lines)) {
      query["Lines"] = request.lines;
    }

    if (!Util.isUnset(request.strategyId)) {
      query["StrategyId"] = request.strategyId;
    }

    if (!Util.isUnset(request.strategyName)) {
      query["StrategyName"] = request.strategyName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateDnsGtmAccessStrategy",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateDnsGtmAccessStrategyResponse>(await this.callApi(params, req, runtime), new UpdateDnsGtmAccessStrategyResponse({}));
  }

  /**
   * Modifies an access policy.
   * 
   * @param request - UpdateDnsGtmAccessStrategyRequest
   * @returns UpdateDnsGtmAccessStrategyResponse
   */
  async updateDnsGtmAccessStrategy(request: UpdateDnsGtmAccessStrategyRequest): Promise<UpdateDnsGtmAccessStrategyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateDnsGtmAccessStrategyWithOptions(request, runtime);
  }

  /**
   * Modifies the configurations of address pools for a GTM instance.
   * 
   * @param request - UpdateDnsGtmAddressPoolRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateDnsGtmAddressPoolResponse
   */
  async updateDnsGtmAddressPoolWithOptions(request: UpdateDnsGtmAddressPoolRequest, runtime: $Util.RuntimeOptions): Promise<UpdateDnsGtmAddressPoolResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.addr)) {
      query["Addr"] = request.addr;
    }

    if (!Util.isUnset(request.addrPoolId)) {
      query["AddrPoolId"] = request.addrPoolId;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.lbaStrategy)) {
      query["LbaStrategy"] = request.lbaStrategy;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateDnsGtmAddressPool",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateDnsGtmAddressPoolResponse>(await this.callApi(params, req, runtime), new UpdateDnsGtmAddressPoolResponse({}));
  }

  /**
   * Modifies the configurations of address pools for a GTM instance.
   * 
   * @param request - UpdateDnsGtmAddressPoolRequest
   * @returns UpdateDnsGtmAddressPoolResponse
   */
  async updateDnsGtmAddressPool(request: UpdateDnsGtmAddressPoolRequest): Promise<UpdateDnsGtmAddressPoolResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateDnsGtmAddressPoolWithOptions(request, runtime);
  }

  /**
   * Modifies the configurations of a Global Traffic Manager (GTM) instance.
   * 
   * @param request - UpdateDnsGtmInstanceGlobalConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateDnsGtmInstanceGlobalConfigResponse
   */
  async updateDnsGtmInstanceGlobalConfigWithOptions(request: UpdateDnsGtmInstanceGlobalConfigRequest, runtime: $Util.RuntimeOptions): Promise<UpdateDnsGtmInstanceGlobalConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.alertConfig)) {
      query["AlertConfig"] = request.alertConfig;
    }

    if (!Util.isUnset(request.alertGroup)) {
      query["AlertGroup"] = request.alertGroup;
    }

    if (!Util.isUnset(request.cnameType)) {
      query["CnameType"] = request.cnameType;
    }

    if (!Util.isUnset(request.forceUpdate)) {
      query["ForceUpdate"] = request.forceUpdate;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.instanceName)) {
      query["InstanceName"] = request.instanceName;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.publicCnameMode)) {
      query["PublicCnameMode"] = request.publicCnameMode;
    }

    if (!Util.isUnset(request.publicRr)) {
      query["PublicRr"] = request.publicRr;
    }

    if (!Util.isUnset(request.publicUserDomainName)) {
      query["PublicUserDomainName"] = request.publicUserDomainName;
    }

    if (!Util.isUnset(request.publicZoneName)) {
      query["PublicZoneName"] = request.publicZoneName;
    }

    if (!Util.isUnset(request.ttl)) {
      query["Ttl"] = request.ttl;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateDnsGtmInstanceGlobalConfig",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateDnsGtmInstanceGlobalConfigResponse>(await this.callApi(params, req, runtime), new UpdateDnsGtmInstanceGlobalConfigResponse({}));
  }

  /**
   * Modifies the configurations of a Global Traffic Manager (GTM) instance.
   * 
   * @param request - UpdateDnsGtmInstanceGlobalConfigRequest
   * @returns UpdateDnsGtmInstanceGlobalConfigResponse
   */
  async updateDnsGtmInstanceGlobalConfig(request: UpdateDnsGtmInstanceGlobalConfigRequest): Promise<UpdateDnsGtmInstanceGlobalConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateDnsGtmInstanceGlobalConfigWithOptions(request, runtime);
  }

  /**
   * Modifies a health check task.
   * 
   * @param request - UpdateDnsGtmMonitorRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateDnsGtmMonitorResponse
   */
  async updateDnsGtmMonitorWithOptions(request: UpdateDnsGtmMonitorRequest, runtime: $Util.RuntimeOptions): Promise<UpdateDnsGtmMonitorResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.evaluationCount)) {
      query["EvaluationCount"] = request.evaluationCount;
    }

    if (!Util.isUnset(request.interval)) {
      query["Interval"] = request.interval;
    }

    if (!Util.isUnset(request.ispCityNode)) {
      query["IspCityNode"] = request.ispCityNode;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.monitorConfigId)) {
      query["MonitorConfigId"] = request.monitorConfigId;
    }

    if (!Util.isUnset(request.monitorExtendInfo)) {
      query["MonitorExtendInfo"] = request.monitorExtendInfo;
    }

    if (!Util.isUnset(request.protocolType)) {
      query["ProtocolType"] = request.protocolType;
    }

    if (!Util.isUnset(request.timeout)) {
      query["Timeout"] = request.timeout;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateDnsGtmMonitor",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateDnsGtmMonitorResponse>(await this.callApi(params, req, runtime), new UpdateDnsGtmMonitorResponse({}));
  }

  /**
   * Modifies a health check task.
   * 
   * @param request - UpdateDnsGtmMonitorRequest
   * @returns UpdateDnsGtmMonitorResponse
   */
  async updateDnsGtmMonitor(request: UpdateDnsGtmMonitorRequest): Promise<UpdateDnsGtmMonitorResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateDnsGtmMonitorWithOptions(request, runtime);
  }

  /**
   * Modifies the name of a domain name group based on the specified parameters.
   * 
   * @param request - UpdateDomainGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateDomainGroupResponse
   */
  async updateDomainGroupWithOptions(request: UpdateDomainGroupRequest, runtime: $Util.RuntimeOptions): Promise<UpdateDomainGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.groupName)) {
      query["GroupName"] = request.groupName;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateDomainGroup",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateDomainGroupResponse>(await this.callApi(params, req, runtime), new UpdateDomainGroupResponse({}));
  }

  /**
   * Modifies the name of a domain name group based on the specified parameters.
   * 
   * @param request - UpdateDomainGroupRequest
   * @returns UpdateDomainGroupResponse
   */
  async updateDomainGroup(request: UpdateDomainGroupRequest): Promise<UpdateDomainGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateDomainGroupWithOptions(request, runtime);
  }

  /**
   * Modifies a Domain Name System (DNS) record based on the specified parameters.
   * 
   * @param request - UpdateDomainRecordRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateDomainRecordResponse
   */
  async updateDomainRecordWithOptions(request: UpdateDomainRecordRequest, runtime: $Util.RuntimeOptions): Promise<UpdateDomainRecordResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.line)) {
      query["Line"] = request.line;
    }

    if (!Util.isUnset(request.priority)) {
      query["Priority"] = request.priority;
    }

    if (!Util.isUnset(request.RR)) {
      query["RR"] = request.RR;
    }

    if (!Util.isUnset(request.recordId)) {
      query["RecordId"] = request.recordId;
    }

    if (!Util.isUnset(request.TTL)) {
      query["TTL"] = request.TTL;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    if (!Util.isUnset(request.userClientIp)) {
      query["UserClientIp"] = request.userClientIp;
    }

    if (!Util.isUnset(request.value)) {
      query["Value"] = request.value;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateDomainRecord",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateDomainRecordResponse>(await this.callApi(params, req, runtime), new UpdateDomainRecordResponse({}));
  }

  /**
   * Modifies a Domain Name System (DNS) record based on the specified parameters.
   * 
   * @param request - UpdateDomainRecordRequest
   * @returns UpdateDomainRecordResponse
   */
  async updateDomainRecord(request: UpdateDomainRecordRequest): Promise<UpdateDomainRecordResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateDomainRecordWithOptions(request, runtime);
  }

  /**
   * Modifies the description of a Domain Name System (DNS) record based on the specified parameters.
   * 
   * @param request - UpdateDomainRecordRemarkRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateDomainRecordRemarkResponse
   */
  async updateDomainRecordRemarkWithOptions(request: UpdateDomainRecordRemarkRequest, runtime: $Util.RuntimeOptions): Promise<UpdateDomainRecordRemarkResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.recordId)) {
      query["RecordId"] = request.recordId;
    }

    if (!Util.isUnset(request.remark)) {
      query["Remark"] = request.remark;
    }

    if (!Util.isUnset(request.userClientIp)) {
      query["UserClientIp"] = request.userClientIp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateDomainRecordRemark",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateDomainRecordRemarkResponse>(await this.callApi(params, req, runtime), new UpdateDomainRecordRemarkResponse({}));
  }

  /**
   * Modifies the description of a Domain Name System (DNS) record based on the specified parameters.
   * 
   * @param request - UpdateDomainRecordRemarkRequest
   * @returns UpdateDomainRecordRemarkResponse
   */
  async updateDomainRecordRemark(request: UpdateDomainRecordRemarkRequest): Promise<UpdateDomainRecordRemarkResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateDomainRecordRemarkWithOptions(request, runtime);
  }

  /**
   * Modifies the description of a domain name based on the specified parameters.
   * 
   * @param request - UpdateDomainRemarkRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateDomainRemarkResponse
   */
  async updateDomainRemarkWithOptions(request: UpdateDomainRemarkRequest, runtime: $Util.RuntimeOptions): Promise<UpdateDomainRemarkResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.remark)) {
      query["Remark"] = request.remark;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateDomainRemark",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateDomainRemarkResponse>(await this.callApi(params, req, runtime), new UpdateDomainRemarkResponse({}));
  }

  /**
   * Modifies the description of a domain name based on the specified parameters.
   * 
   * @param request - UpdateDomainRemarkRequest
   * @returns UpdateDomainRemarkResponse
   */
  async updateDomainRemark(request: UpdateDomainRemarkRequest): Promise<UpdateDomainRemarkResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateDomainRemarkWithOptions(request, runtime);
  }

  /**
   * @param request - UpdateGtmAccessStrategyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateGtmAccessStrategyResponse
   */
  async updateGtmAccessStrategyWithOptions(request: UpdateGtmAccessStrategyRequest, runtime: $Util.RuntimeOptions): Promise<UpdateGtmAccessStrategyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.accessLines)) {
      query["AccessLines"] = request.accessLines;
    }

    if (!Util.isUnset(request.defaultAddrPoolId)) {
      query["DefaultAddrPoolId"] = request.defaultAddrPoolId;
    }

    if (!Util.isUnset(request.failoverAddrPoolId)) {
      query["FailoverAddrPoolId"] = request.failoverAddrPoolId;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.strategyId)) {
      query["StrategyId"] = request.strategyId;
    }

    if (!Util.isUnset(request.strategyName)) {
      query["StrategyName"] = request.strategyName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateGtmAccessStrategy",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateGtmAccessStrategyResponse>(await this.callApi(params, req, runtime), new UpdateGtmAccessStrategyResponse({}));
  }

  /**
   * @param request - UpdateGtmAccessStrategyRequest
   * @returns UpdateGtmAccessStrategyResponse
   */
  async updateGtmAccessStrategy(request: UpdateGtmAccessStrategyRequest): Promise<UpdateGtmAccessStrategyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateGtmAccessStrategyWithOptions(request, runtime);
  }

  /**
   * @param request - UpdateGtmAddressPoolRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateGtmAddressPoolResponse
   */
  async updateGtmAddressPoolWithOptions(request: UpdateGtmAddressPoolRequest, runtime: $Util.RuntimeOptions): Promise<UpdateGtmAddressPoolResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.addr)) {
      query["Addr"] = request.addr;
    }

    if (!Util.isUnset(request.addrPoolId)) {
      query["AddrPoolId"] = request.addrPoolId;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.minAvailableAddrNum)) {
      query["MinAvailableAddrNum"] = request.minAvailableAddrNum;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateGtmAddressPool",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateGtmAddressPoolResponse>(await this.callApi(params, req, runtime), new UpdateGtmAddressPoolResponse({}));
  }

  /**
   * @param request - UpdateGtmAddressPoolRequest
   * @returns UpdateGtmAddressPoolResponse
   */
  async updateGtmAddressPool(request: UpdateGtmAddressPoolRequest): Promise<UpdateGtmAddressPoolResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateGtmAddressPoolWithOptions(request, runtime);
  }

  /**
   * Modifies the configurations of a Global Traffic Manager (GTM) instance based on the specified parameters.
   * 
   * @param request - UpdateGtmInstanceGlobalConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateGtmInstanceGlobalConfigResponse
   */
  async updateGtmInstanceGlobalConfigWithOptions(request: UpdateGtmInstanceGlobalConfigRequest, runtime: $Util.RuntimeOptions): Promise<UpdateGtmInstanceGlobalConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.alertGroup)) {
      query["AlertGroup"] = request.alertGroup;
    }

    if (!Util.isUnset(request.cnameCustomDomainName)) {
      query["CnameCustomDomainName"] = request.cnameCustomDomainName;
    }

    if (!Util.isUnset(request.cnameMode)) {
      query["CnameMode"] = request.cnameMode;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.instanceName)) {
      query["InstanceName"] = request.instanceName;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.lbaStrategy)) {
      query["LbaStrategy"] = request.lbaStrategy;
    }

    if (!Util.isUnset(request.ttl)) {
      query["Ttl"] = request.ttl;
    }

    if (!Util.isUnset(request.userDomainName)) {
      query["UserDomainName"] = request.userDomainName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateGtmInstanceGlobalConfig",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateGtmInstanceGlobalConfigResponse>(await this.callApi(params, req, runtime), new UpdateGtmInstanceGlobalConfigResponse({}));
  }

  /**
   * Modifies the configurations of a Global Traffic Manager (GTM) instance based on the specified parameters.
   * 
   * @param request - UpdateGtmInstanceGlobalConfigRequest
   * @returns UpdateGtmInstanceGlobalConfigResponse
   */
  async updateGtmInstanceGlobalConfig(request: UpdateGtmInstanceGlobalConfigRequest): Promise<UpdateGtmInstanceGlobalConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateGtmInstanceGlobalConfigWithOptions(request, runtime);
  }

  /**
   * Modifies the health check configuration for an address pool of a Global Traffic Manager (GTM) instance.
   * 
   * @param request - UpdateGtmMonitorRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateGtmMonitorResponse
   */
  async updateGtmMonitorWithOptions(request: UpdateGtmMonitorRequest, runtime: $Util.RuntimeOptions): Promise<UpdateGtmMonitorResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.evaluationCount)) {
      query["EvaluationCount"] = request.evaluationCount;
    }

    if (!Util.isUnset(request.interval)) {
      query["Interval"] = request.interval;
    }

    if (!Util.isUnset(request.ispCityNode)) {
      query["IspCityNode"] = request.ispCityNode;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.monitorConfigId)) {
      query["MonitorConfigId"] = request.monitorConfigId;
    }

    if (!Util.isUnset(request.monitorExtendInfo)) {
      query["MonitorExtendInfo"] = request.monitorExtendInfo;
    }

    if (!Util.isUnset(request.protocolType)) {
      query["ProtocolType"] = request.protocolType;
    }

    if (!Util.isUnset(request.timeout)) {
      query["Timeout"] = request.timeout;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateGtmMonitor",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateGtmMonitorResponse>(await this.callApi(params, req, runtime), new UpdateGtmMonitorResponse({}));
  }

  /**
   * Modifies the health check configuration for an address pool of a Global Traffic Manager (GTM) instance.
   * 
   * @param request - UpdateGtmMonitorRequest
   * @returns UpdateGtmMonitorResponse
   */
  async updateGtmMonitor(request: UpdateGtmMonitorRequest): Promise<UpdateGtmMonitorResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateGtmMonitorWithOptions(request, runtime);
  }

  /**
   * Modifies a disaster recovery plan for a Global Traffic Manager (GTM) instance.
   * 
   * @param request - UpdateGtmRecoveryPlanRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateGtmRecoveryPlanResponse
   */
  async updateGtmRecoveryPlanWithOptions(request: UpdateGtmRecoveryPlanRequest, runtime: $Util.RuntimeOptions): Promise<UpdateGtmRecoveryPlanResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.faultAddrPool)) {
      query["FaultAddrPool"] = request.faultAddrPool;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.recoveryPlanId)) {
      query["RecoveryPlanId"] = request.recoveryPlanId;
    }

    if (!Util.isUnset(request.remark)) {
      query["Remark"] = request.remark;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateGtmRecoveryPlan",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateGtmRecoveryPlanResponse>(await this.callApi(params, req, runtime), new UpdateGtmRecoveryPlanResponse({}));
  }

  /**
   * Modifies a disaster recovery plan for a Global Traffic Manager (GTM) instance.
   * 
   * @param request - UpdateGtmRecoveryPlanRequest
   * @returns UpdateGtmRecoveryPlanResponse
   */
  async updateGtmRecoveryPlan(request: UpdateGtmRecoveryPlanRequest): Promise<UpdateGtmRecoveryPlanResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateGtmRecoveryPlanWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - UpdateIspFlushCacheInstanceConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateIspFlushCacheInstanceConfigResponse
   */
  async updateIspFlushCacheInstanceConfigWithOptions(request: UpdateIspFlushCacheInstanceConfigRequest, runtime: $Util.RuntimeOptions): Promise<UpdateIspFlushCacheInstanceConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.instanceName)) {
      query["InstanceName"] = request.instanceName;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateIspFlushCacheInstanceConfig",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateIspFlushCacheInstanceConfigResponse>(await this.callApi(params, req, runtime), new UpdateIspFlushCacheInstanceConfigResponse({}));
  }

  /**
   * 
   * 
   * @param request - UpdateIspFlushCacheInstanceConfigRequest
   * @returns UpdateIspFlushCacheInstanceConfigResponse
   */
  async updateIspFlushCacheInstanceConfig(request: UpdateIspFlushCacheInstanceConfigRequest): Promise<UpdateIspFlushCacheInstanceConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateIspFlushCacheInstanceConfigWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - ValidateDnsGtmCnameRrCanUseRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ValidateDnsGtmCnameRrCanUseResponse
   */
  async validateDnsGtmCnameRrCanUseWithOptions(request: ValidateDnsGtmCnameRrCanUseRequest, runtime: $Util.RuntimeOptions): Promise<ValidateDnsGtmCnameRrCanUseResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.cnameMode)) {
      query["CnameMode"] = request.cnameMode;
    }

    if (!Util.isUnset(request.cnameRr)) {
      query["CnameRr"] = request.cnameRr;
    }

    if (!Util.isUnset(request.cnameType)) {
      query["CnameType"] = request.cnameType;
    }

    if (!Util.isUnset(request.cnameZone)) {
      query["CnameZone"] = request.cnameZone;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ValidateDnsGtmCnameRrCanUse",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ValidateDnsGtmCnameRrCanUseResponse>(await this.callApi(params, req, runtime), new ValidateDnsGtmCnameRrCanUseResponse({}));
  }

  /**
   * 
   * 
   * @param request - ValidateDnsGtmCnameRrCanUseRequest
   * @returns ValidateDnsGtmCnameRrCanUseResponse
   */
  async validateDnsGtmCnameRrCanUse(request: ValidateDnsGtmCnameRrCanUseRequest): Promise<ValidateDnsGtmCnameRrCanUseResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.validateDnsGtmCnameRrCanUseWithOptions(request, runtime);
  }

  /**
   * DNS Udp Ip
   * 
   * @param request - ValidatePdnsUdpIpSegmentRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ValidatePdnsUdpIpSegmentResponse
   */
  async validatePdnsUdpIpSegmentWithOptions(request: ValidatePdnsUdpIpSegmentRequest, runtime: $Util.RuntimeOptions): Promise<ValidatePdnsUdpIpSegmentResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ip)) {
      query["Ip"] = request.ip;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ValidatePdnsUdpIpSegment",
      version: "2015-01-09",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ValidatePdnsUdpIpSegmentResponse>(await this.callApi(params, req, runtime), new ValidatePdnsUdpIpSegmentResponse({}));
  }

  /**
   * DNS Udp Ip
   * 
   * @param request - ValidatePdnsUdpIpSegmentRequest
   * @returns ValidatePdnsUdpIpSegmentResponse
   */
  async validatePdnsUdpIpSegment(request: ValidatePdnsUdpIpSegmentRequest): Promise<ValidatePdnsUdpIpSegmentResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.validatePdnsUdpIpSegmentWithOptions(request, runtime);
  }

}
