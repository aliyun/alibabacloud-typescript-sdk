// This file is auto-generated, don't edit it
/**
 */
import Util, * as $Util from '@alicloud/tea-util';
import OpenApi, * as $OpenApi from '@alicloud/openapi-client';
import OpenApiUtil from '@alicloud/openapi-util';
import EndpointUtil from '@alicloud/endpoint-util';
import * as $tea from '@alicloud/tea-typescript';

export class AlertEvent extends $tea.Model {
  alertName?: string;
  alertStatus?: string;
  arn?: string;
  content?: string;
  customLabels?: { [key: string]: any };
  deDupId?: string;
  details?: string;
  eventName?: string;
  eventType?: string;
  expression?: string;
  metrics?: AlertEventMetrics[];
  product?: string;
  resourceInfo?: { [key: string]: any };
  ruleName?: string;
  severity?: string;
  source?: string;
  summary?: string;
  timestamp?: number;
  traceId?: string;
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      alertName: 'AlertName',
      alertStatus: 'AlertStatus',
      arn: 'Arn',
      content: 'Content',
      customLabels: 'CustomLabels',
      deDupId: 'DeDupId',
      details: 'Details',
      eventName: 'EventName',
      eventType: 'EventType',
      expression: 'Expression',
      metrics: 'Metrics',
      product: 'Product',
      resourceInfo: 'ResourceInfo',
      ruleName: 'RuleName',
      severity: 'Severity',
      source: 'Source',
      summary: 'Summary',
      timestamp: 'Timestamp',
      traceId: 'TraceId',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertName: 'string',
      alertStatus: 'string',
      arn: 'string',
      content: 'string',
      customLabels: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      deDupId: 'string',
      details: 'string',
      eventName: 'string',
      eventType: 'string',
      expression: 'string',
      metrics: { 'type': 'array', 'itemType': AlertEventMetrics },
      product: 'string',
      resourceInfo: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      ruleName: 'string',
      severity: 'string',
      source: 'string',
      summary: 'string',
      timestamp: 'number',
      traceId: 'string',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AlertStrategyRelation extends $tea.Model {
  alertName?: string;
  strategyUuid?: string;
  static names(): { [key: string]: string } {
    return {
      alertName: 'AlertName',
      strategyUuid: 'StrategyUuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertName: 'string',
      strategyUuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class Dimension extends $tea.Model {
  label?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      label: 'Label',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      label: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EscalationRule extends $tea.Model {
  createTime?: string;
  description?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  escalations?: EscalationRuleEscalations[];
  /**
   * @remarks
   * This parameter is required.
   */
  name?: string;
  updateTime?: string;
  userId?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      description: 'Description',
      escalations: 'Escalations',
      name: 'Name',
      updateTime: 'UpdateTime',
      userId: 'UserId',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'string',
      description: 'string',
      escalations: { 'type': 'array', 'itemType': EscalationRuleEscalations },
      name: 'string',
      updateTime: 'string',
      userId: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class Incident extends $tea.Model {
  actionTime?: number;
  alertCount?: number;
  endTime?: number;
  groupingData?: { [key: string]: any };
  groupingId?: string;
  groupingKey?: string;
  incidentId?: string;
  incidentStatus?: string;
  severity?: string;
  startTime?: number;
  strategyUuid?: string;
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      actionTime: 'ActionTime',
      alertCount: 'AlertCount',
      endTime: 'EndTime',
      groupingData: 'GroupingData',
      groupingId: 'GroupingId',
      groupingKey: 'GroupingKey',
      incidentId: 'IncidentId',
      incidentStatus: 'IncidentStatus',
      severity: 'Severity',
      startTime: 'StartTime',
      strategyUuid: 'StrategyUuid',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actionTime: 'number',
      alertCount: 'number',
      endTime: 'number',
      groupingData: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      groupingId: 'string',
      groupingKey: 'string',
      incidentId: 'string',
      incidentStatus: 'string',
      severity: 'string',
      startTime: 'number',
      strategyUuid: 'string',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class Matcher extends $tea.Model {
  label?: string;
  operator?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      label: 'Label',
      operator: 'Operator',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      label: 'string',
      operator: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class MetricStat extends $tea.Model {
  associated?: { [key: string]: string };
  dimensions?: Dimension[];
  logTime?: number;
  measurements?: { [key: string]: any };
  metric?: string;
  namespace?: string;
  period?: number;
  timestamp?: number;
  static names(): { [key: string]: string } {
    return {
      associated: 'Associated',
      dimensions: 'Dimensions',
      logTime: 'LogTime',
      measurements: 'Measurements',
      metric: 'Metric',
      namespace: 'Namespace',
      period: 'Period',
      timestamp: 'Timestamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      associated: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      dimensions: { 'type': 'array', 'itemType': Dimension },
      logTime: 'number',
      measurements: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      metric: 'string',
      namespace: 'string',
      period: 'number',
      timestamp: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class MigrationJob extends $tea.Model {
  createTime?: string;
  detail?: string;
  jobStatus?: string;
  plan?: MigrationJobPlan;
  ruleNames?: string[];
  source?: MigrationJobSource[];
  updateTime?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      detail: 'Detail',
      jobStatus: 'JobStatus',
      plan: 'Plan',
      ruleNames: 'RuleNames',
      source: 'Source',
      updateTime: 'UpdateTime',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'string',
      detail: 'string',
      jobStatus: 'string',
      plan: MigrationJobPlan,
      ruleNames: { 'type': 'array', 'itemType': 'string' },
      source: { 'type': 'array', 'itemType': MigrationJobSource },
      updateTime: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class NotificationStrategy extends $tea.Model {
  createTime?: string;
  description?: string;
  escalationSetting?: NotificationStrategyEscalationSetting;
  filterSetting?: NotificationStrategyFilterSetting;
  groupingSetting?: NotificationStrategyGroupingSetting;
  /**
   * @remarks
   * This parameter is required.
   */
  name?: string;
  product?: string;
  pushingSetting?: NotificationStrategyPushingSetting;
  routeSetting?: NotificationStrategyRouteSetting;
  updateTime?: string;
  userId?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      description: 'Description',
      escalationSetting: 'EscalationSetting',
      filterSetting: 'FilterSetting',
      groupingSetting: 'GroupingSetting',
      name: 'Name',
      product: 'Product',
      pushingSetting: 'PushingSetting',
      routeSetting: 'RouteSetting',
      updateTime: 'UpdateTime',
      userId: 'UserId',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'string',
      description: 'string',
      escalationSetting: NotificationStrategyEscalationSetting,
      filterSetting: NotificationStrategyFilterSetting,
      groupingSetting: NotificationStrategyGroupingSetting,
      name: 'string',
      product: 'string',
      pushingSetting: NotificationStrategyPushingSetting,
      routeSetting: NotificationStrategyRouteSetting,
      updateTime: 'string',
      userId: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class NotificationTemplate extends $tea.Model {
  createTime?: string;
  description?: string;
  /**
   * @example
   * Alarm $.alertName
   */
  enContent?: string;
  /**
   * @example
   * Alarm $.alertName
   */
  enItemContent?: string;
  /**
   * @example
   * Alarm $.alertName
   */
  enTitle?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  name?: string;
  /**
   * @example
   * DATA,  SMS,  ONCALL,  MAIL,  DING,  WEIXIN,  FEISHU,  SLACK
   */
  type?: string;
  updateTime?: string;
  userId?: string;
  uuid?: string;
  /**
   * @example
   * TEXT, MARKDOWN,CARD
   */
  wraperType?: string;
  /**
   * @example
   * 报警 $.alertName
   */
  zhContent?: string;
  /**
   * @example
   * 报警 $.alertName
   */
  zhItemContent?: string;
  /**
   * @example
   * 报警通知 $.alertName
   */
  zhTitle?: string;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      description: 'Description',
      enContent: 'EnContent',
      enItemContent: 'EnItemContent',
      enTitle: 'EnTitle',
      name: 'Name',
      type: 'Type',
      updateTime: 'UpdateTime',
      userId: 'UserId',
      uuid: 'Uuid',
      wraperType: 'WraperType',
      zhContent: 'ZhContent',
      zhItemContent: 'ZhItemContent',
      zhTitle: 'ZhTitle',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'string',
      description: 'string',
      enContent: 'string',
      enItemContent: 'string',
      enTitle: 'string',
      name: 'string',
      type: 'string',
      updateTime: 'string',
      userId: 'string',
      uuid: 'string',
      wraperType: 'string',
      zhContent: 'string',
      zhItemContent: 'string',
      zhTitle: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PushingTarget extends $tea.Model {
  arn?: string;
  createTime?: string;
  description?: string;
  httpRequestTarget?: PushingTargetHttpRequestTarget;
  /**
   * @remarks
   * This parameter is required.
   */
  name?: string;
  range?: string;
  templateUuid?: string;
  type?: string;
  updateTime?: string;
  userId?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      arn: 'Arn',
      createTime: 'CreateTime',
      description: 'Description',
      httpRequestTarget: 'HttpRequestTarget',
      name: 'Name',
      range: 'Range',
      templateUuid: 'TemplateUuid',
      type: 'Type',
      updateTime: 'UpdateTime',
      userId: 'UserId',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      arn: 'string',
      createTime: 'string',
      description: 'string',
      httpRequestTarget: PushingTargetHttpRequestTarget,
      name: 'string',
      range: 'string',
      templateUuid: 'string',
      type: 'string',
      updateTime: 'string',
      userId: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class Subscription extends $tea.Model {
  conditions?: SubscriptionConditions[];
  createTime?: string;
  description?: string;
  enabled?: boolean;
  /**
   * @remarks
   * This parameter is required.
   */
  name?: string;
  product?: string;
  relation?: string;
  strategyUuid?: string;
  updateTime?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      conditions: 'Conditions',
      createTime: 'CreateTime',
      description: 'Description',
      enabled: 'Enabled',
      name: 'Name',
      product: 'Product',
      relation: 'Relation',
      strategyUuid: 'StrategyUuid',
      updateTime: 'UpdateTime',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      conditions: { 'type': 'array', 'itemType': SubscriptionConditions },
      createTime: 'string',
      description: 'string',
      enabled: 'boolean',
      name: 'string',
      product: 'string',
      relation: 'string',
      strategyUuid: 'string',
      updateTime: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddTagsRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the application group.
   * 
   * Valid values of N: 1 to 20.
   * 
   * For more information about how to obtain the ID of an application group, see [DescribeMonitorGroups](https://help.aliyun.com/document_detail/115032.html).
   * 
   * This parameter is required.
   * 
   * @example
   * 7301****
   */
  groupIds?: string[];
  regionId?: string;
  /**
   * @remarks
   * The tags.
   * 
   * This parameter is required.
   */
  tag?: AddTagsRequestTag[];
  static names(): { [key: string]: string } {
    return {
      groupIds: 'GroupIds',
      regionId: 'RegionId',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupIds: { 'type': 'array', 'itemType': 'string' },
      regionId: 'string',
      tag: { 'type': 'array', 'itemType': AddTagsRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddTagsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code.
   * 
   * > The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The specified resource is not found.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * DAE4B115-3847-5438-8709-423627F0A3A3
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddTagsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddTagsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddTagsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApplyMetricRuleTemplateRequest extends $tea.Model {
  /**
   * @remarks
   * The template application policy. Valid values:
   * 
   * *   all (default): deletes all the rules that are created by using the alert template from the selected application group, and then creates alert rules based on the template.
   * *   append: deletes the rules that are created by using the alert template from the selected application group, and then creates alert rules based on the existing template.
   * 
   * @example
   * all
   */
  appendMode?: string;
  /**
   * @remarks
   * The mode in which the alert template is applied. Valid values:
   * 
   * *   GROUP_INSTANCE_FIRST: The metrics in the application group take precedence. If a metric specified in the alert template does not exist in the application group, the system does not generate an alert rule for the metric based on the alert template.
   * *   ALARM_TEMPLATE_FIRST: The metrics specified in the alert template take precedence. If a metric specified in the alert template does not exist in the application group, the system still generates an alert rule for the metric based on the alert template.
   * 
   * @example
   * GROUP_INSTANCE_FIRST
   */
  applyMode?: string;
  /**
   * @remarks
   * The end of the time period during which the alert rule is effective. Valid values: 00 to 23. A value of 00 indicates 00:59 and a value of 23 indicates 23:59.
   * 
   * @example
   * 23
   */
  enableEndTime?: number;
  /**
   * @remarks
   * The beginning of the time period during which the alert rule is effective. Valid values: 00 to 23. A value of 00 indicates 00:00 and a value of 23 indicates 23:00.
   * 
   * @example
   * 00
   */
  enableStartTime?: number;
  /**
   * @remarks
   * The ID of the application group to which the alert template is applied.
   * 
   * For more information about how to query the ID of an application group, see [DescribeMonitorGroups](https://help.aliyun.com/document_detail/115032.html).
   * 
   * This parameter is required.
   * 
   * @example
   * 123456
   */
  groupId?: number;
  /**
   * @remarks
   * The alert notification method. Valid values:
   * 
   * Set the value to 4. A value of 4 indicates that alert notifications are sent by using TradeManager and DingTalk chatbots.
   * 
   * @example
   * 4
   */
  notifyLevel?: number;
  /**
   * @remarks
   * The mute period during which notifications are not repeatedly sent for an alert. Unit: seconds. Default value: 86400.
   * 
   * >  Only one alert notification is sent during each mute period even if the metric value exceeds the alert threshold several times.
   * 
   * @example
   * 86400
   */
  silenceTime?: number;
  /**
   * @remarks
   * The ID of the alert template.
   * 
   * For more information about how to query the IDs of alert templates, see [DescribeMetricRuleTemplateList](https://help.aliyun.com/document_detail/114982.html).
   * 
   * This parameter is required.
   * 
   * @example
   * 700****
   */
  templateIds?: string;
  /**
   * @remarks
   * The callback URL to which a POST request is sent when an alert is triggered based on the alert rule.
   * 
   * @example
   * https://www.aliyun.com
   */
  webhook?: string;
  static names(): { [key: string]: string } {
    return {
      appendMode: 'AppendMode',
      applyMode: 'ApplyMode',
      enableEndTime: 'EnableEndTime',
      enableStartTime: 'EnableStartTime',
      groupId: 'GroupId',
      notifyLevel: 'NotifyLevel',
      silenceTime: 'SilenceTime',
      templateIds: 'TemplateIds',
      webhook: 'Webhook',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appendMode: 'string',
      applyMode: 'string',
      enableEndTime: 'number',
      enableStartTime: 'number',
      groupId: 'number',
      notifyLevel: 'number',
      silenceTime: 'number',
      templateIds: 'string',
      webhook: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApplyMetricRuleTemplateResponseBody extends $tea.Model {
  /**
   * @remarks
   * The responses code.
   * 
   * >  The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * The specified resource is not found.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 3F897F3C-020A-4993-95B4-63ABB84F83E6
   */
  requestId?: string;
  /**
   * @remarks
   * The resources that are affected by the alert rule.
   */
  resource?: ApplyMetricRuleTemplateResponseBodyResource;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      resource: 'Resource',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      message: 'string',
      requestId: 'string',
      resource: ApplyMetricRuleTemplateResponseBodyResource,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApplyMetricRuleTemplateResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ApplyMetricRuleTemplateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ApplyMetricRuleTemplateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCreateInstantSiteMonitorRequest extends $tea.Model {
  regionId?: string;
  /**
   * @remarks
   * The site monitoring tasks.
   * 
   * >  You must create at least one site monitoring task. You must specify all of the `Address`, `TaskName`, and `TaskType` parameters in each request.
   * 
   * This parameter is required.
   */
  taskList?: BatchCreateInstantSiteMonitorRequestTaskList[];
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      taskList: 'TaskList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      taskList: { 'type': 'array', 'itemType': BatchCreateInstantSiteMonitorRequestTaskList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCreateInstantSiteMonitorResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The information about the site monitoring task.
   * 
   * @example
   * [{"taskName": "HangZhou_ECS1", "taskId": "679fbe4f-b80b-4706-91b2-5427b43e****"}]
   */
  data?: BatchCreateInstantSiteMonitorResponseBodyData[];
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * successful
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 7AE72720-2C96-5446-9F2B-308C7CEDFF1A
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: { 'type': 'array', 'itemType': BatchCreateInstantSiteMonitorResponseBodyData },
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCreateInstantSiteMonitorResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: BatchCreateInstantSiteMonitorResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchCreateInstantSiteMonitorResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchExportRequest extends $tea.Model {
  /**
   * @remarks
   * When you call this operation to export data, you must specify the `Cursor` parameter. You can obtain the value of the `Cursor` parameter by using one of the following methods:
   * 
   * *   When you call this operation for the first time, you must call the Cursor operation to obtain the `Cursor` value. For more information, see [Cursor](https://help.aliyun.com/document_detail/2330730.html).
   * *   When you call this operation again, you can obtain the `Cursor` value from the returned data of the last call.
   * 
   * This parameter is required.
   * 
   * @example
   * eyJidWNrZXRzIjo0LCJjdXJzb3IiOiIxNjQxNDU0MzIwMDAwMWUxY2YxNWY0NTU0MTliZjllYTY4OWQ2ODI1OTU1Yzc1NmZjMDQ2OTMxMzczMzM2MzUzMTMxMzEzMzM0MzMzODM5MzEzMTMwMjQyYzY5MmQ3NTY2MzYzMjY3NmI2ZjM5MzU2YjY4MzAzMTYyNzg3MTcwNjkzMTM3MjQyYyIsImN1cnNvclZlcnNpb24iOiJxdWVyeSIsImVuZFRpbWUiOjE2NDE0NTQ3OTU4MjMsImV4cG9ydEVuZFRpbWUiOjE2NDE0NTQ3OTU4MjMsImV4cG9ydFN0YXJ0VGltZSI6MTY0MTQ1NDE5NTgyMywiZXhwcmVzc1JhbmdlIjpmYWxzZSwiaGFzTmV4dCI6dHJ1ZSwiaW5wdXRNZXRyaWMiOiJDUFVVdGlsaXphdGlvbiIsImlucHV0TmFtZXNwYWNlIjoiYWNzX2Vjc19kYXNoYm9hcmQiLCJsaW1pdCI6MTAwMCwibG9nVGltZU1vZGUiOnRydWUsIm1hdGNoZXJzIjp7ImNoYWluIjpbeyJsYWJlbCI6InVzZXJJZCIsIm9wZXJhdG9yIjoiRVFVQUxTIiwidmFsdWUiOiIxNzM2NTExMTM0Mzg5MTEwIn1dfSwibWV0cmljIjoiQ1BVVXRpbGl6YXRpb24iLCJtZXRyaWNUeXBlIjoiTUVUUklDIiwibmFtZXNwYWNlIjoiYWNzX2Vjc19kYXNoYm9hcmQiLCJuZXh0UGtBZGFwdGVyIjp7fSwib2Zmc2V0IjowLCJwYXJlbnRVaWQiOjEyNzA2NzY2Nzk1NDY3MDQsInN0YXJ0VGltZSI6MTY0MTQ1NDE5NTgyMywic3RlcCI6LTEsInRpbWVvdXQiOjEyMCwid2luZG93Ijo2****
   */
  cursor?: string;
  /**
   * @remarks
   * The maximum number of data entries that can be returned in each response.
   * 
   * Valid values: 1 to 10000.
   * 
   * This parameter is required.
   * 
   * @example
   * 1000
   */
  length?: number;
  /**
   * @remarks
   * The statistical methods used to customize the returned data. By default, the measurements based on all statistical methods are returned.
   * 
   * For example, the `cpu_idle` metric of ECS (`acs_ecs_dashboard`) has three statistical methods: `Average`, `Maximum`, and `Minimum`. If you want to return only the measurements based on the `Average` and `Maximum` statistical methods, set this parameter to `["Average", "Maximum"]`.
   * 
   * The statistical methods of metrics are displayed in the `Statistics` column on the Metrics page of each cloud service. For more information, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   */
  measurements?: string[];
  /**
   * @remarks
   * The metric that is used to monitor the cloud service.
   * 
   * For more information about the metrics of cloud services, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * >  The value of this parameter must be the same as the value of the request parameter `Metric` in the Cursor operation.
   * 
   * This parameter is required.
   * 
   * @example
   * cpu_idle
   */
  metric?: string;
  /**
   * @remarks
   * The namespace of the cloud service.
   * 
   * For more information about the namespaces of cloud services, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * >  The value of this parameter must be the same as the value of the request parameter `Namespace` in the Cursor operation.
   * 
   * This parameter is required.
   * 
   * @example
   * acs_ecs_dashboard
   */
  namespace?: string;
  static names(): { [key: string]: string } {
    return {
      cursor: 'Cursor',
      length: 'Length',
      measurements: 'Measurements',
      metric: 'Metric',
      namespace: 'Namespace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cursor: 'string',
      length: 'number',
      measurements: { 'type': 'array', 'itemType': 'string' },
      metric: 'string',
      namespace: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchExportShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * When you call this operation to export data, you must specify the `Cursor` parameter. You can obtain the value of the `Cursor` parameter by using one of the following methods:
   * 
   * *   When you call this operation for the first time, you must call the Cursor operation to obtain the `Cursor` value. For more information, see [Cursor](https://help.aliyun.com/document_detail/2330730.html).
   * *   When you call this operation again, you can obtain the `Cursor` value from the returned data of the last call.
   * 
   * This parameter is required.
   * 
   * @example
   * eyJidWNrZXRzIjo0LCJjdXJzb3IiOiIxNjQxNDU0MzIwMDAwMWUxY2YxNWY0NTU0MTliZjllYTY4OWQ2ODI1OTU1Yzc1NmZjMDQ2OTMxMzczMzM2MzUzMTMxMzEzMzM0MzMzODM5MzEzMTMwMjQyYzY5MmQ3NTY2MzYzMjY3NmI2ZjM5MzU2YjY4MzAzMTYyNzg3MTcwNjkzMTM3MjQyYyIsImN1cnNvclZlcnNpb24iOiJxdWVyeSIsImVuZFRpbWUiOjE2NDE0NTQ3OTU4MjMsImV4cG9ydEVuZFRpbWUiOjE2NDE0NTQ3OTU4MjMsImV4cG9ydFN0YXJ0VGltZSI6MTY0MTQ1NDE5NTgyMywiZXhwcmVzc1JhbmdlIjpmYWxzZSwiaGFzTmV4dCI6dHJ1ZSwiaW5wdXRNZXRyaWMiOiJDUFVVdGlsaXphdGlvbiIsImlucHV0TmFtZXNwYWNlIjoiYWNzX2Vjc19kYXNoYm9hcmQiLCJsaW1pdCI6MTAwMCwibG9nVGltZU1vZGUiOnRydWUsIm1hdGNoZXJzIjp7ImNoYWluIjpbeyJsYWJlbCI6InVzZXJJZCIsIm9wZXJhdG9yIjoiRVFVQUxTIiwidmFsdWUiOiIxNzM2NTExMTM0Mzg5MTEwIn1dfSwibWV0cmljIjoiQ1BVVXRpbGl6YXRpb24iLCJtZXRyaWNUeXBlIjoiTUVUUklDIiwibmFtZXNwYWNlIjoiYWNzX2Vjc19kYXNoYm9hcmQiLCJuZXh0UGtBZGFwdGVyIjp7fSwib2Zmc2V0IjowLCJwYXJlbnRVaWQiOjEyNzA2NzY2Nzk1NDY3MDQsInN0YXJ0VGltZSI6MTY0MTQ1NDE5NTgyMywic3RlcCI6LTEsInRpbWVvdXQiOjEyMCwid2luZG93Ijo2****
   */
  cursor?: string;
  /**
   * @remarks
   * The maximum number of data entries that can be returned in each response.
   * 
   * Valid values: 1 to 10000.
   * 
   * This parameter is required.
   * 
   * @example
   * 1000
   */
  length?: number;
  /**
   * @remarks
   * The statistical methods used to customize the returned data. By default, the measurements based on all statistical methods are returned.
   * 
   * For example, the `cpu_idle` metric of ECS (`acs_ecs_dashboard`) has three statistical methods: `Average`, `Maximum`, and `Minimum`. If you want to return only the measurements based on the `Average` and `Maximum` statistical methods, set this parameter to `["Average", "Maximum"]`.
   * 
   * The statistical methods of metrics are displayed in the `Statistics` column on the Metrics page of each cloud service. For more information, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   */
  measurementsShrink?: string;
  /**
   * @remarks
   * The metric that is used to monitor the cloud service.
   * 
   * For more information about the metrics of cloud services, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * >  The value of this parameter must be the same as the value of the request parameter `Metric` in the Cursor operation.
   * 
   * This parameter is required.
   * 
   * @example
   * cpu_idle
   */
  metric?: string;
  /**
   * @remarks
   * The namespace of the cloud service.
   * 
   * For more information about the namespaces of cloud services, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * >  The value of this parameter must be the same as the value of the request parameter `Namespace` in the Cursor operation.
   * 
   * This parameter is required.
   * 
   * @example
   * acs_ecs_dashboard
   */
  namespace?: string;
  static names(): { [key: string]: string } {
    return {
      cursor: 'Cursor',
      length: 'Length',
      measurementsShrink: 'Measurements',
      metric: 'Metric',
      namespace: 'Namespace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cursor: 'string',
      length: 'number',
      measurementsShrink: 'string',
      metric: 'string',
      namespace: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchExportResponseBody extends $tea.Model {
  /**
   * @remarks
   * The timestamp of the data requested by the backend. A larger timestamp indicates that the data export time is closer to the current time.
   * 
   * @example
   * 1678781819000
   */
  anchor?: number;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The Cursor information that is used to call this operation again.
   * 
   * >  If `null` is returned, the monitoring data is exported.
   * 
   * @example
   * v2.5eyJidWNrZXRzIjo0LCJjdXJzb3IiOiIxNjQxNDU0ODAwMDAwMWUxY2YxNWY0NTU0MTliZjllYTY4OWQ2ODI1OTU1Yzc1NmZjMDQ2OTMxMzczMzM2MzUzMTMxMzEzMzM0MzMzODM5MzEzMTMwMjQyYzY5MmQzMjdhNjU2MjY3N2E2NjZhNzczOTY2NmM3Mjc0NjM3MzY5Njg3NDcyMjQyYyIsImN1cnNvclZlcnNpb24iOiJxdWVyeSIsImVuZFRpbWUiOjE2NDE0NTUyMzYxMTIsImV4cG9ydEVuZFRpbWUiOjE2NDE0NTUyMzYxMTIsImV4cG9ydFN0YXJ0VGltZSI6MTY0MTQ1NDYzNjExMiwiZXhwcmVzc1JhbmdlIjpmYWxzZSwiaGFzTmV4dCI6dHJ1ZSwiaW5wdXRNZXRyaWMiOiJDUFVVdGlsaXphdGlvbiIsImlucHV0TmFtZXNwYWNlIjoiYWNzX2Vjc19kYXNoYm9hcmQiLCJsaW1pdCI6MTAwMCwibG9nVGltZU1vZGUiOnRydWUsIm1hdGNoZXJzIjp7ImNoYWluIjpbeyJsYWJlbCI6InVzZXJJZCIsIm9wZXJhdG9yIjoiRVFVQUxTIiwidmFsdWUiOiIxNzM2NTExMTM0Mzg5MTEwIn1dfSwibWV0cmljIjoiQ1BVVXRpbGl6YXRpb24iLCJtZXRyaWNUeXBlIjoiTUVUUklDIiwibmFtZXNwYWNlIjoiYWNzX2Vjc19kYXNoYm9hcmQiLCJuZXh0UGtBZGFwdGVyIjp7fSwib2Zmc2V0IjowLCJwYXJlbnRVaWQiOjEyNzA2NzY2Nzk1NDY3MDQsInN0YXJ0VGltZSI6MTY0MTQ1NDYzNjExMiwic3RlcCI6LTEsInRpbWVvdXQiOjEyMCwid2luZG93Ijo2MH0***
   */
  cursor?: string;
  /**
   * @remarks
   * The data returned in this call.
   */
  dataResults?: MetricStat[];
  /**
   * @remarks
   * Indicates whether the data has been exported. Valid values:
   * 
   * *   true: Some data is not exported.
   * *   false: All the data is exported.
   * 
   * @example
   * true
   */
  hasNext?: boolean;
  /**
   * @remarks
   * The number of data entries returned in this call.
   * 
   * @example
   * 1000
   */
  length?: number;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 251402CD-305C-1617-808E-D8C11FC8138D
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      anchor: 'Anchor',
      code: 'Code',
      cursor: 'Cursor',
      dataResults: 'DataResults',
      hasNext: 'HasNext',
      length: 'Length',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      anchor: 'number',
      code: 'number',
      cursor: 'string',
      dataResults: { 'type': 'array', 'itemType': MetricStat },
      hasNext: 'boolean',
      length: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchExportResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: BatchExportResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchExportResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDynamicTagGroupRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * ECS_Group
   */
  contactGroupList?: string[];
  /**
   * @remarks
   * Specifies whether the CloudMonitor agent is automatically installed for the application group. CloudMonitor determines whether to automatically install the CloudMonitor agent for the hosts in an application group based on the value of this parameter. Valid values:
   * 
   * *   true: The CloudMonitor agent is automatically installed.
   * *   false (default value): The CloudMonitor agent is not automatically installed.
   * 
   * @example
   * true
   */
  enableInstallAgent?: boolean;
  /**
   * @remarks
   * Specifies whether the application group automatically subscribes to event notifications. If events whose severity level is critical or warning occur on resources in an application group, CloudMonitor sends alert notifications. Valid values:
   * 
   * *   true: The application group automatically subscribes to event notifications.
   * *   false (default value): The application group does not automatically subscribe to event notifications.
   * 
   * @example
   * true
   */
  enableSubscribeEvent?: boolean;
  /**
   * @remarks
   * This parameter is required.
   */
  matchExpress?: CreateDynamicTagGroupRequestMatchExpress[];
  /**
   * @remarks
   * The relationship between the conditional expressions for the tag values of the cloud resources. Valid values:
   * 
   * *   and (default value)
   * *   or
   * 
   * @example
   * and
   */
  matchExpressFilterRelation?: string;
  regionId?: string;
  /**
   * @remarks
   * The tag keys of the cloud resources.
   * 
   * For more information about how to obtain tag keys, see [DescribeTagKeyList](https://help.aliyun.com/document_detail/145558.html).
   * 
   * This parameter is required.
   * 
   * @example
   * ecs_instance
   */
  tagKey?: string;
  /**
   * @remarks
   * The ID of the region to which the tags belong.
   * 
   * @example
   * cn-hangzhou
   */
  tagRegionId?: string;
  /**
   * @example
   * 85****
   */
  templateIdList?: string[];
  static names(): { [key: string]: string } {
    return {
      contactGroupList: 'ContactGroupList',
      enableInstallAgent: 'EnableInstallAgent',
      enableSubscribeEvent: 'EnableSubscribeEvent',
      matchExpress: 'MatchExpress',
      matchExpressFilterRelation: 'MatchExpressFilterRelation',
      regionId: 'RegionId',
      tagKey: 'TagKey',
      tagRegionId: 'TagRegionId',
      templateIdList: 'TemplateIdList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contactGroupList: { 'type': 'array', 'itemType': 'string' },
      enableInstallAgent: 'boolean',
      enableSubscribeEvent: 'boolean',
      matchExpress: { 'type': 'array', 'itemType': CreateDynamicTagGroupRequestMatchExpress },
      matchExpressFilterRelation: 'string',
      regionId: 'string',
      tagKey: 'string',
      tagRegionId: 'string',
      templateIdList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDynamicTagGroupResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the call is successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The ID of the tag matching rule.
   * 
   * @example
   * 2534dc0a-e3e5-4ae1-a2fc-75ef166c****
   */
  id?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The specified resource is not found.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 84AC6F0B-7945-466A-AA44-99BB5A561F86
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call is successful. Valid values:
   * 
   * *   true: The call is successful.
   * *   false: The call fails.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      id: 'Id',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      id: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDynamicTagGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateDynamicTagGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateDynamicTagGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateGroupMetricRulesRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the application group.
   * 
   * For information about how to obtain the ID of an application group, see [DescribeMonitorGroups](https://help.aliyun.com/document_detail/115032.html).
   * 
   * This parameter is required.
   * 
   * @example
   * 123456
   */
  groupId?: number;
  groupMetricRules?: CreateGroupMetricRulesRequestGroupMetricRules[];
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      groupMetricRules: 'GroupMetricRules',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'number',
      groupMetricRules: { 'type': 'array', 'itemType': CreateGroupMetricRulesRequestGroupMetricRules },
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateGroupMetricRulesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the call is successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The Request is not authorization.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 461CF2CD-2FC3-4B26-8645-7BD27E7D0F1D
   */
  requestId?: string;
  /**
   * @remarks
   * The details of the alert rules.
   */
  resources?: CreateGroupMetricRulesResponseBodyResources;
  /**
   * @remarks
   * Indicates whether the call is successful. Valid value:
   * 
   * - true: The call is successful.
   * - false: The call fails.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      resources: 'Resources',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      message: 'string',
      requestId: 'string',
      resources: CreateGroupMetricRulesResponseBodyResources,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateGroupMetricRulesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateGroupMetricRulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateGroupMetricRulesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateGroupMonitoringAgentProcessRequest extends $tea.Model {
  /**
   * @remarks
   * The alert rule configurations.
   * 
   * Valid values of N: 1 to 3.
   * 
   * This parameter is required.
   */
  alertConfig?: CreateGroupMonitoringAgentProcessRequestAlertConfig[];
  /**
   * @remarks
   * The ID of the application group.
   * 
   * For more information about how to obtain the ID of an application group, see [DescribeMonitorGroups](https://help.aliyun.com/document_detail/115032.html).
   * 
   * This parameter is required.
   * 
   * @example
   * 123456
   */
  groupId?: string;
  /**
   * @remarks
   * The expressions used to match instances.
   * 
   * Valid values of N: 1 to 3.
   */
  matchExpress?: CreateGroupMonitoringAgentProcessRequestMatchExpress[];
  /**
   * @remarks
   * The logical operator used between conditional expressions that are used to match instances. Valid values:
   * 
   * *   all
   * *   and
   * *   or
   * 
   * @example
   * and
   */
  matchExpressFilterRelation?: string;
  /**
   * @remarks
   * The process name.
   * 
   * This parameter is required.
   * 
   * @example
   * test1
   */
  processName?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      alertConfig: 'AlertConfig',
      groupId: 'GroupId',
      matchExpress: 'MatchExpress',
      matchExpressFilterRelation: 'MatchExpressFilterRelation',
      processName: 'ProcessName',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertConfig: { 'type': 'array', 'itemType': CreateGroupMonitoringAgentProcessRequestAlertConfig },
      groupId: 'string',
      matchExpress: { 'type': 'array', 'itemType': CreateGroupMonitoringAgentProcessRequestMatchExpress },
      matchExpressFilterRelation: 'string',
      processName: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateGroupMonitoringAgentProcessResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code.
   * 
   * > The status code 200 indicates that the call is successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The Request is not authorization.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 3F6150F9-45C7-43F9-9578-A58B2E726C90
   */
  requestId?: string;
  /**
   * @remarks
   * The group process information.
   */
  resource?: CreateGroupMonitoringAgentProcessResponseBodyResource;
  /**
   * @remarks
   * Indicates whether the call is successful. Valid values:
   * 
   * *   true: The call is successful.
   * *   false: The call fails.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      resource: 'Resource',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      resource: CreateGroupMonitoringAgentProcessResponseBodyResource,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateGroupMonitoringAgentProcessResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateGroupMonitoringAgentProcessResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateGroupMonitoringAgentProcessResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHostAvailabilityRequest extends $tea.Model {
  alertConfig?: CreateHostAvailabilityRequestAlertConfig;
  taskOption?: CreateHostAvailabilityRequestTaskOption;
  /**
   * @remarks
   * None
   * 
   * This parameter is required.
   */
  alertConfigEscalationList?: CreateHostAvailabilityRequestAlertConfigEscalationList[];
  /**
   * @remarks
   * The information about the resources for which alerts are triggered.
   */
  alertConfigTargetList?: CreateHostAvailabilityRequestAlertConfigTargetList[];
  /**
   * @remarks
   * The ID of the application group.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456
   */
  groupId?: number;
  /**
   * @remarks
   * The ECS instances that are monitored. Valid values of N: 1 to 21.
   * 
   * > This parameter must be specified when `TaskScope` is set to `GROUP_SPEC_INSTANCE`.
   * 
   * @example
   * i-absdfkwl321****
   */
  instanceList?: string[];
  regionId?: string;
  /**
   * @remarks
   * The name of the availability monitoring task. The name must be 4 to 100 characters in length, and can contain letters, digits, and underscores (_).
   * 
   * This parameter is required.
   * 
   * @example
   * task1
   */
  taskName?: string;
  /**
   * @remarks
   * The range of instances that are monitored by the availability monitoring task. Valid values:
   * 
   * *   GROUP: All Elastic Compute Service (ECS) instances in the application group are monitored.
   * *   GROUP_SPEC_INSTANCE: Specified ECS instances in the application group are monitored. The TaskScope parameter must be used in combination with the InstanceList.N parameter. The InstanceList.N parameter specifies the ECS instances to be monitored.
   * 
   * @example
   * GROUP
   */
  taskScope?: string;
  /**
   * @remarks
   * The monitoring type of the availability monitoring task. Valid values:
   * 
   * *   PING
   * *   TELNET
   * *   HTTP
   * 
   * This parameter is required.
   * 
   * @example
   * HTTP
   */
  taskType?: string;
  static names(): { [key: string]: string } {
    return {
      alertConfig: 'AlertConfig',
      taskOption: 'TaskOption',
      alertConfigEscalationList: 'AlertConfigEscalationList',
      alertConfigTargetList: 'AlertConfigTargetList',
      groupId: 'GroupId',
      instanceList: 'InstanceList',
      regionId: 'RegionId',
      taskName: 'TaskName',
      taskScope: 'TaskScope',
      taskType: 'TaskType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertConfig: CreateHostAvailabilityRequestAlertConfig,
      taskOption: CreateHostAvailabilityRequestTaskOption,
      alertConfigEscalationList: { 'type': 'array', 'itemType': CreateHostAvailabilityRequestAlertConfigEscalationList },
      alertConfigTargetList: { 'type': 'array', 'itemType': CreateHostAvailabilityRequestAlertConfigTargetList },
      groupId: 'number',
      instanceList: { 'type': 'array', 'itemType': 'string' },
      regionId: 'string',
      taskName: 'string',
      taskScope: 'string',
      taskType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHostAvailabilityResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code.
   * 
   * > The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The specified resource is not found.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * ACBDBB40-DFB6-4F4C-8957-51FFB233969C
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The ID of the availability monitoring task.
   * 
   * @example
   * 12345
   */
  taskId?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
      taskId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHostAvailabilityResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateHostAvailabilityResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateHostAvailabilityResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHybridMonitorNamespaceRequest extends $tea.Model {
  /**
   * @remarks
   * The description of the namespace.
   */
  description?: string;
  /**
   * @remarks
   * The name of the namespace.
   * 
   * The name can contain lowercase letters, digits, and hyphens (-).
   * 
   * This parameter is required.
   * 
   * @example
   * aliyun
   */
  namespace?: string;
  /**
   * @remarks
   * The region where the metric data is stored.
   * 
   * @example
   * cn-hangzhou
   */
  namespaceRegion?: string;
  /**
   * @remarks
   * The storage scheme of metric data. Valid values:
   * 
   * *   m_prom_user: The metric data is stored in Simple Log Service.
   * *   m_prom_pool: The metric data is stored in the private storage space provided by CloudMonitor.
   * 
   * >  For more information about the storage schemes of metric data, see [Data storage schemes for Hybrid Cloud Monitoring](https://help.aliyun.com/document_detail/2594921.html).
   * 
   * @example
   * m_prometheus
   */
  namespaceType?: string;
  regionId?: string;
  /**
   * @remarks
   * The data retention period. Valid values:
   * 
   * *   cms.s1.large (Retention Period 15 Days)
   * *   cms.s1.xlarge (Retention Period 32 Days)
   * *   cms.s1.2xlarge (Retention Period 63 Days)
   * *   cms.s1.3xlarge (Retention Period 93 Days) (default)
   * *   cms.s1.6xlarge (Retention Period 185 Days)
   * *   cms.s1.12xlarge (Retention Period 367 Days)
   * 
   * For information about the pricing for different retention periods, see the **Pricing** section in [Billing of the dashboard feature](https://help.aliyun.com/document_detail/223532.html).
   * 
   * @example
   * cms.s1.3xlarge
   */
  spec?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      namespace: 'Namespace',
      namespaceRegion: 'NamespaceRegion',
      namespaceType: 'NamespaceType',
      regionId: 'RegionId',
      spec: 'Spec',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      namespace: 'string',
      namespaceRegion: 'string',
      namespaceType: 'string',
      regionId: 'string',
      spec: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHybridMonitorNamespaceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response code.
   * 
   * @example
   * Success
   */
  code?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * Namespace.Existed
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 3843D23A-FB9E-5DC8-BCCC-458768B79296
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHybridMonitorNamespaceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateHybridMonitorNamespaceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateHybridMonitorNamespaceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHybridMonitorSLSGroupRequest extends $tea.Model {
  regionId?: string;
  /**
   * @remarks
   * The configurations of the Logstore group.
   * 
   * Valid values of N: 1 to 25.
   * 
   * This parameter is required.
   */
  SLSGroupConfig?: CreateHybridMonitorSLSGroupRequestSLSGroupConfig[];
  /**
   * @remarks
   * The description of the Logstore group.
   */
  SLSGroupDescription?: string;
  /**
   * @remarks
   * The name of the Logstore group.
   * 
   * The name must be 2 to 32 characters in length and can contain uppercase letters, lowercase letters, digits, and underscores (_). The name must start with a letter.
   * 
   * This parameter is required.
   * 
   * @example
   * Logstore_test
   */
  SLSGroupName?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      SLSGroupConfig: 'SLSGroupConfig',
      SLSGroupDescription: 'SLSGroupDescription',
      SLSGroupName: 'SLSGroupName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      SLSGroupConfig: { 'type': 'array', 'itemType': CreateHybridMonitorSLSGroupRequestSLSGroupConfig },
      SLSGroupDescription: 'string',
      SLSGroupName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHybridMonitorSLSGroupResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * > The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * Duplicate.SLSGroup
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 66683237-7126-50F8-BBF8-D67ACC919A17
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHybridMonitorSLSGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateHybridMonitorSLSGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateHybridMonitorSLSGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHybridMonitorTaskRequest extends $tea.Model {
  /**
   * @remarks
   * The tags of the metric.
   * 
   * >  This parameter is required only if the `TaskType` parameter is set to `aliyun_sls`.
   */
  attachLabels?: CreateHybridMonitorTaskRequestAttachLabels[];
  cloudAccessId?: string[];
  /**
   * @remarks
   * The collection period of the metric. Valid values:
   * 
   * *   15
   * *   60 (default)
   * 
   * Unit: seconds.
   * 
   * >  This parameter is required only if the `TaskType` parameter is set to `aliyun_sls`.
   * 
   * @example
   * 60
   */
  collectInterval?: string;
  /**
   * @remarks
   * The type of the collection target.
   * 
   * *   If the `TaskType` parameter is set to `aliyun_fc`, enter `aliyun_fc`.
   * *   If the `TaskType` parameter is set to `aliyun_sls`, enter the name of the Logstore group.
   * 
   * This parameter is required.
   * 
   * @example
   * aliyun_fc
   */
  collectTargetType?: string;
  /**
   * @remarks
   * The description of the metric import task.
   */
  description?: string;
  /**
   * @remarks
   * The ID of the application group.
   * 
   * For information about how to obtain the ID of an application group, see [DescribeMonitorGroups](https://help.aliyun.com/document_detail/115032.html).
   * 
   * >  This parameter is required only if the `TaskType` parameter is set to `aliyun_sls`.
   * 
   * @example
   * 3607****
   */
  groupId?: string;
  /**
   * @remarks
   * The name of the namespace.
   * 
   * For information about how to obtain the name of a namespace, see [DescribeHybridMonitorNamespaceList](https://help.aliyun.com/document_detail/428880.html).
   * 
   * This parameter is required.
   * 
   * @example
   * aliyun
   */
  namespace?: string;
  regionId?: string;
  /**
   * @remarks
   * The configurations of the logs that are imported from Simple Log Service.
   * 
   * >  This parameter is required only if the `TaskType` parameter is set to `aliyun_sls`.
   */
  SLSProcessConfig?: CreateHybridMonitorTaskRequestSLSProcessConfig;
  /**
   * @remarks
   * The ID of the member account.
   * 
   * If you call this operation by using the management account of a resource directory, you can connect the Alibaba Cloud services that are activated for all members in the resource directory to Hybrid Cloud Monitoring. You can use the resource directory to monitor Alibaba Cloud services across enterprise accounts.
   * 
   * >  This parameter is required only if the `TaskType` parameter is set to `aliyun_fc`.
   * 
   * @example
   * 120886317861****
   */
  targetUserId?: string;
  /**
   * @remarks
   * The IDs of the member accounts. Separate multiple member account IDs with commas (,).
   * 
   * >  This parameter is required only if you call this operation by using the management account.
   * 
   * @example
   * 120886317861****
   */
  targetUserIdList?: string;
  /**
   * @remarks
   * The name of the metric import task.
   * 
   * *   If the `TaskType` parameter is set to `aliyun_fc`, enter the name of the metric import task.
   * *   If the `TaskType` parameter is set to `aliyun_sls`, enter the name of the metric for logs imported from Simple Log Service.
   * 
   * @example
   * aliyun_task
   */
  taskName?: string;
  /**
   * @remarks
   * The type of the metric import task. Valid values:
   * 
   * *   aliyun_fc: metric import tasks for Alibaba Cloud services.
   * *   aliyun_sls: metrics for logs imported from Simple Log Service.
   * 
   * This parameter is required.
   * 
   * @example
   * aliyun_fc
   */
  taskType?: string;
  /**
   * @remarks
   * The configuration file of the Alibaba Cloud service that you want to monitor by using Hybrid Cloud Monitoring.
   * 
   * *   namespace: the namespace of the Alibaba Cloud service. For information about how to query the namespace of an Alibaba Cloud service, see [DescribeMetricMetaList](https://help.aliyun.com/document_detail/98846.html).
   * *   metric_list: the metrics of the Alibaba Cloud service. For information about how to query the metrics of an Alibaba Cloud service, see [DescribeMetricMetaList](https://help.aliyun.com/document_detail/98846.html).
   * 
   * The following code shows a sample configuration file:
   * 
   *     products:
   *     - namespace: acs_ecs_dashboard
   *       metric_info:
   *       - metric_list:
   *         - cpu_total
   *         - cpu_idle
   *         - diskusage_utilization
   *         - CPUUtilization
   *         - DiskReadBPS
   *         - InternetOut
   *         - IntranetOut
   *         - cpu_system
   *     - namespace: acs_rds_dashboard
   *       metric_info:
   *       - metric_list:
   *         - MySQL_QPS
   *         - MySQL_TPS
   * 
   * >  This parameter is required only if the `TaskType` parameter is set to `aliyun_fc`.
   * 
   * @example
   * products:- namespace: acs_ecs_dashboard  metric_info:  - metric_list:    - cpu_total
   */
  YARMConfig?: string;
  static names(): { [key: string]: string } {
    return {
      attachLabels: 'AttachLabels',
      cloudAccessId: 'CloudAccessId',
      collectInterval: 'CollectInterval',
      collectTargetType: 'CollectTargetType',
      description: 'Description',
      groupId: 'GroupId',
      namespace: 'Namespace',
      regionId: 'RegionId',
      SLSProcessConfig: 'SLSProcessConfig',
      targetUserId: 'TargetUserId',
      targetUserIdList: 'TargetUserIdList',
      taskName: 'TaskName',
      taskType: 'TaskType',
      YARMConfig: 'YARMConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attachLabels: { 'type': 'array', 'itemType': CreateHybridMonitorTaskRequestAttachLabels },
      cloudAccessId: { 'type': 'array', 'itemType': 'string' },
      collectInterval: 'string',
      collectTargetType: 'string',
      description: 'string',
      groupId: 'string',
      namespace: 'string',
      regionId: 'string',
      SLSProcessConfig: CreateHybridMonitorTaskRequestSLSProcessConfig,
      targetUserId: 'string',
      targetUserIdList: 'string',
      taskName: 'string',
      taskType: 'string',
      YARMConfig: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHybridMonitorTaskResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response code.
   * 
   * >  The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * yamlConfigFail
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 28CEA2E0-3E90-51B2-A7E8-B1ED75534E49
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: string;
  /**
   * @remarks
   * The ID of the monitoring task.
   * 
   * @example
   * 36****
   */
  taskId?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'string',
      taskId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHybridMonitorTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateHybridMonitorTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateHybridMonitorTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateInstantSiteMonitorRequest extends $tea.Model {
  /**
   * @remarks
   * The URL or IP address that you want to test.
   * 
   * This parameter is required.
   * 
   * @example
   * http://www.aliyun.com
   */
  address?: string;
  /**
   * @remarks
   * The detection points. If you leave this parameter empty, the system randomly selects three detection points.
   * 
   * The value is a `JSON array`. Example: {"city":"546","isp":"465"},{"city":"572","isp":"465"},{"city":"738","isp":"465"}. The values of the city field indicate Beijing, Hangzhou, and Qingdao.
   * 
   * For information about how to obtain detection points, see [DescribeSiteMonitorISPCityList](https://help.aliyun.com/document_detail/115045.html).
   * 
   * > You must specify one of the `IspCities` and `RandomIspCity` parameters.
   * 
   * @example
   * [{"city":"546","isp":"465"},{"city":"572","isp":"465"},{"city":"738","isp":"465"}]
   */
  ispCities?: string;
  /**
   * @remarks
   * The extended options of the protocol that is used by the instant test task. The options vary based on the protocol.
   * 
   * @example
   * {"time_out":5000}
   */
  optionsJson?: string;
  /**
   * @remarks
   * The number of detection points.
   * 
   * > 
   * 
   * *   You must specify one of the `IspCities` and `RandomIspCity` parameters. If you specify the `RandomIspCity` parameter, the `IspCities` parameter automatically becomes invalid.
   * 
   * @example
   * 1
   */
  randomIspCity?: number;
  regionId?: string;
  /**
   * @remarks
   * The name of the instant test task.
   * 
   * The name must be 4 to 100 characters in length, and can contain letters, digits, and underscores (_).
   * 
   * This parameter is required.
   * 
   * @example
   * task1
   */
  taskName?: string;
  /**
   * @remarks
   * The type of the instant test task. Valid values: HTTP, PING, TCP, UDP, and DNS.
   * 
   * This parameter is required.
   * 
   * @example
   * HTTP
   */
  taskType?: string;
  static names(): { [key: string]: string } {
    return {
      address: 'Address',
      ispCities: 'IspCities',
      optionsJson: 'OptionsJson',
      randomIspCity: 'RandomIspCity',
      regionId: 'RegionId',
      taskName: 'TaskName',
      taskType: 'TaskType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      address: 'string',
      ispCities: 'string',
      optionsJson: 'string',
      randomIspCity: 'number',
      regionId: 'string',
      taskName: 'string',
      taskType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateInstantSiteMonitorResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * > The status code 200 indicates that the call was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The results for creating the instant test task.
   */
  createResultList?: CreateInstantSiteMonitorResponseBodyCreateResultList[];
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * successful
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 68192f5d-0d45-4b98-9724-892813f86c71
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call was successful. Valid values:
   * 
   * *   true: The call was successful.
   * *   false: The call failed.
   * 
   * @example
   * true
   */
  success?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      createResultList: 'CreateResultList',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      createResultList: { 'type': 'array', 'itemType': CreateInstantSiteMonitorResponseBodyCreateResultList },
      message: 'string',
      requestId: 'string',
      success: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateInstantSiteMonitorResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateInstantSiteMonitorResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateInstantSiteMonitorResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMetricRuleBlackListRequest extends $tea.Model {
  /**
   * @remarks
   * The category of the cloud service. For example, ApsaraDB for Redis includes the following categories: ApsaraDB for Redis (standard architecture), ApsaraDB for Redis (cluster architecture), and ApsaraDB for Redis (read/write splitting architecture). In this case, the valid values of this parameter for ApsaraDB for Redis include `kvstore_standard`, `kvstore_sharding`, and `kvstore_splitrw`.
   * 
   * This parameter is required.
   * 
   * @example
   * ecs
   */
  category?: string;
  /**
   * @remarks
   * The time range within which the blacklist policy is effective.
   * 
   * *   If you do not configure this parameter, the blacklist policy is permanently effective.
   * 
   * *   If you configure this parameter, the blacklist policy is effective only within the specified time range. Examples:
   * 
   *     *   `03:00-04:59`: The blacklist policy is effective from 03:00 to 05:00 local time. 05:00 local time is excluded.
   *     *   `03:00-04:59 UTC+0700`: The blacklist policy is effective from 03:00 to 05:00 (UTC+7). 05:00 (UTC+7) is excluded.
   * 
   * @example
   * 03:00-04:59
   */
  effectiveTime?: string;
  /**
   * @remarks
   * The timestamp when the blacklist policy expires.
   * 
   * Unit: milliseconds.
   * 
   * @example
   * 1640608200000
   */
  enableEndTime?: string;
  /**
   * @remarks
   * The timestamp when the blacklist policy starts to take effect.
   * 
   * Unit: milliseconds.
   * 
   * @example
   * 1640237400000
   */
  enableStartTime?: string;
  /**
   * @remarks
   * The IDs of the instances that belong to the specified cloud service.
   * 
   * This parameter is required.
   */
  instances?: string[];
  /**
   * @remarks
   * The metrics of the instance.
   * 
   * *   If you do not configure this parameter, the blacklist policy applies to all metrics of the specified cloud service.
   * *   If you configure this parameter, the blacklist policy applies only to the current metric.
   */
  metrics?: CreateMetricRuleBlackListRequestMetrics[];
  /**
   * @remarks
   * The name of the blacklist policy.
   * 
   * This parameter is required.
   * 
   * @example
   * Blacklist-01
   */
  name?: string;
  /**
   * @remarks
   * The namespace of the cloud service.
   * 
   * For more information about the namespaces of different cloud services, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * This parameter is required.
   * 
   * @example
   * acs_ecs_dashboard
   */
  namespace?: string;
  regionId?: string;
  /**
   * @remarks
   * The effective scope of the blacklist policy. Valid values:
   * 
   * *   USER (default): The blacklist policy takes effect only for the current Alibaba Cloud account.
   * *   GROUP: The blacklist policy takes effect only for the specified application group. For information about how to query the IDs of application groups, see [DescribeMonitorGroups](https://help.aliyun.com/document_detail/115032.html).
   * 
   * @example
   * USER
   */
  scopeType?: string;
  /**
   * @remarks
   * The ID of the application group. The value of this parameter is a JSON array.
   * 
   * > This parameter must be specified when `ScopeType` is set to `GROUP`.
   * 
   * @example
   * ["67****","78****"]
   */
  scopeValue?: string;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      effectiveTime: 'EffectiveTime',
      enableEndTime: 'EnableEndTime',
      enableStartTime: 'EnableStartTime',
      instances: 'Instances',
      metrics: 'Metrics',
      name: 'Name',
      namespace: 'Namespace',
      regionId: 'RegionId',
      scopeType: 'ScopeType',
      scopeValue: 'ScopeValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      effectiveTime: 'string',
      enableEndTime: 'string',
      enableStartTime: 'string',
      instances: { 'type': 'array', 'itemType': 'string' },
      metrics: { 'type': 'array', 'itemType': CreateMetricRuleBlackListRequestMetrics },
      name: 'string',
      namespace: 'string',
      regionId: 'string',
      scopeType: 'string',
      scopeValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMetricRuleBlackListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code.
   * 
   * > The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The ID of the blacklist policy.
   * 
   * @example
   * 93514c96-ceb8-47d8-8ee3-93b6d98b****
   */
  id?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The request has failed due to a temporary failure of the server.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 5C637FA3-3959-3352-8BE6-78CE2ED2D33D
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      id: 'Id',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      id: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMetricRuleBlackListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateMetricRuleBlackListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateMetricRuleBlackListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMetricRuleResourcesRequest extends $tea.Model {
  /**
   * @remarks
   * Specifies whether to overwrite the existing data. Valid values:
   * 
   * *   true: The resources submitted this time will overwrite the previous associated resources.
   * *   false: The resources submitted this time will not overwrite the previous associated resources. The associated resources after submission include the previous associated resources and the resources submitted this time.
   * 
   * @example
   * false
   */
  overwrite?: string;
  /**
   * @remarks
   * The resources to be associated with the alert rule. The value is a JSON array.
   * 
   * >  You can add up to 100 resources each time. An alert rule can be associated with up to 3,000 resources.
   * 
   * This parameter is required.
   * 
   * @example
   * [{"instanceId":"i-a2d5q7pm3f9yr29e****"}]
   */
  resources?: string;
  /**
   * @remarks
   * The ID of the alert rule.
   * 
   * @example
   * i-2ze3w55tr2rcpejpcfap_59c96b85-0339-4f35-ba66-ae4e34d3****
   */
  ruleId?: string;
  static names(): { [key: string]: string } {
    return {
      overwrite: 'Overwrite',
      resources: 'Resources',
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      overwrite: 'string',
      resources: 'string',
      ruleId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMetricRuleResourcesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the call was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0671A721-0D7A-4F11-BB77-2416325D65AB
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call was successful. The value true indicates a success. The value false indicates a failure.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMetricRuleResourcesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateMetricRuleResourcesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateMetricRuleResourcesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMetricRuleTemplateRequest extends $tea.Model {
  alertTemplates?: CreateMetricRuleTemplateRequestAlertTemplates[];
  /**
   * @remarks
   * The description of the alert template.
   * 
   * @example
   * ECS_Template1
   */
  description?: string;
  /**
   * @remarks
   * The name of the alert template.
   * 
   * This parameter is required.
   * 
   * @example
   * Template1
   */
  name?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      alertTemplates: 'AlertTemplates',
      description: 'Description',
      name: 'Name',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertTemplates: { 'type': 'array', 'itemType': CreateMetricRuleTemplateRequestAlertTemplates },
      description: 'string',
      name: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMetricRuleTemplateResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the call was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The ID of the alert template.
   * 
   * @example
   * 12345
   */
  id?: number;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The Request is not authorization.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 9763ED1A-4D09-41BF-851E-310421750204
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call was successful. Valid values:
   * 
   * *   true: The call was successful.
   * *   false: The call failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      id: 'Id',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      id: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMetricRuleTemplateResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateMetricRuleTemplateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateMetricRuleTemplateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMonitorAgentProcessRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * i-2ze2d6j5uhg20x47****
   */
  instanceId?: string;
  /**
   * @remarks
   * The name of the process.
   * 
   * This parameter is required.
   * 
   * @example
   * AliYunDun
   */
  processName?: string;
  /**
   * @remarks
   * The user who launches the process.
   * 
   * @example
   * admin
   */
  processUser?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      processName: 'ProcessName',
      processUser: 'ProcessUser',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      processName: 'string',
      processUser: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMonitorAgentProcessResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the call was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The ID of the process.
   * 
   * @example
   * 123456
   */
  id?: number;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * User not authorized to operate on the specified resource.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 971CC023-5A96-452A-BB7C-2483F948BCFD
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call was successful. Valid values:
   * 
   * *   true: The call was successful.
   * *   false: The call failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      id: 'Id',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      id: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMonitorAgentProcessResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateMonitorAgentProcessResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateMonitorAgentProcessResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMonitorGroupRequest extends $tea.Model {
  /**
   * @remarks
   * The alert contact group. The alert notifications of the application group are sent to the alert contacts that belong to the alert contact group.
   * 
   * >  An alert contact group can contain one or more alert contacts. For information about how to create alert contacts and alert contact groups, see [PutContact](~~PutContact~~) and [PutContactGroup](~~PutContactGroup~~).
   * 
   * @example
   * ECS_Alert_Group
   */
  contactGroups?: string;
  /**
   * @remarks
   * The name of the application group.
   * 
   * This parameter is required.
   * 
   * @example
   * ECS_Group
   */
  groupName?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      contactGroups: 'ContactGroups',
      groupName: 'GroupName',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contactGroups: 'string',
      groupName: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMonitorGroupResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The ID of the application group.
   * 
   * @example
   * 1234567
   */
  groupId?: number;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * The specified resource is not found.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 83C89BA6-ABD4-4398-A175-83E86C47A001
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      groupId: 'GroupId',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      groupId: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMonitorGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateMonitorGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateMonitorGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMonitorGroupByResourceGroupIdRequest extends $tea.Model {
  /**
   * @remarks
   * The alert contact groups. The alert notifications of the application group are sent to the alert contacts that belong to the specified alert contact groups.
   * 
   * An alert contact group can contain one or more alert contacts. For information about how to create alert contacts and alert contact groups, see [PutContact](https://help.aliyun.com/document_detail/114923.html) and [PutContactGroup](https://help.aliyun.com/document_detail/114929.html). For information about how to obtain alert contact groups, see [DescribeContactGroupList](https://help.aliyun.com/document_detail/114922.html).
   * 
   * This parameter is required.
   * 
   * @example
   * ECS_Group
   */
  contactGroupList?: string[];
  /**
   * @remarks
   * Specifies whether the CloudMonitor agent is automatically installed for the application group. CloudMonitor determines whether to automatically install the CloudMonitor agent for the hosts in an application group based on the value of this parameter. Valid values:
   * 
   * *   true: The CloudMonitor agent is automatically installed.
   * *   false (default): The CloudMonitor agent is not automatically installed.
   * 
   * @example
   * true
   */
  enableInstallAgent?: boolean;
  /**
   * @remarks
   * Specifies whether the application group automatically subscribes to event notifications. If events whose severity level is critical or warning occur on resources in an application group, CloudMonitor sends alert notifications. Valid values:
   * 
   * *   true: The application group automatically subscribes to event notifications.
   * *   false (default): The application group does not automatically subscribe to event notifications.
   * 
   * @example
   * true
   */
  enableSubscribeEvent?: boolean;
  /**
   * @remarks
   * The ID of the region where the resource group resides.
   * 
   * For information about how to obtain the ID of the region where a resource group resides, see [GetResourceGroup](https://help.aliyun.com/document_detail/158866.html).
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The ID of the resource group.
   * 
   * For information about how to obtain the ID of a resource group, see [ListResourceGroups](https://help.aliyun.com/document_detail/158855.html).
   * 
   * This parameter is required.
   * 
   * @example
   * rg-acfmw3ty5y7****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The name of the resource group.
   * 
   * For information about how to obtain the name of a resource group, see [ListResourceGroups](https://help.aliyun.com/document_detail/158855.html).
   * 
   * This parameter is required.
   * 
   * @example
   * CloudMonitor
   */
  resourceGroupName?: string;
  static names(): { [key: string]: string } {
    return {
      contactGroupList: 'ContactGroupList',
      enableInstallAgent: 'EnableInstallAgent',
      enableSubscribeEvent: 'EnableSubscribeEvent',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      resourceGroupName: 'ResourceGroupName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contactGroupList: { 'type': 'array', 'itemType': 'string' },
      enableInstallAgent: 'boolean',
      enableSubscribeEvent: 'boolean',
      regionId: 'string',
      resourceGroupId: 'string',
      resourceGroupName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMonitorGroupByResourceGroupIdResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code.
   * 
   * > The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The ID of the application group.
   * 
   * @example
   * 3607****
   */
  id?: number;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The specified resource is not found.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 784CAB3C-F613-5BCE-8469-6DCB29B18A20
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      id: 'Id',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      id: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMonitorGroupByResourceGroupIdResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateMonitorGroupByResourceGroupIdResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateMonitorGroupByResourceGroupIdResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMonitorGroupInstancesRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the application group.
   * 
   * This parameter is required.
   * 
   * @example
   * 3607****
   */
  groupId?: string;
  /**
   * @remarks
   * The instances that you want to add to the application group.
   * 
   * This parameter is required.
   */
  instances?: CreateMonitorGroupInstancesRequestInstances[];
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      instances: 'Instances',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      instances: { 'type': 'array', 'itemType': CreateMonitorGroupInstancesRequestInstances },
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMonitorGroupInstancesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code.
   * 
   * > The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The Request is not authorization.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 1BC69FEB-56CD-4555-A0E2-02536A24A946
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMonitorGroupInstancesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateMonitorGroupInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateMonitorGroupInstancesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMonitorGroupNotifyPolicyRequest extends $tea.Model {
  /**
   * @remarks
   * The timestamp that indicates the end time of the validity period for the policy.
   * 
   * This value is a UNIX timestamp that represents the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
   * 
   * This parameter is required.
   * 
   * @example
   * 1623208500000
   */
  endTime?: number;
  /**
   * @remarks
   * The ID of the application group.
   * 
   * This parameter is required.
   * 
   * @example
   * 7301****
   */
  groupId?: string;
  /**
   * @remarks
   * The type of the policy. Valid value: PauseNotify.
   * 
   * This parameter is required.
   * 
   * @example
   * PauseNotify
   */
  policyType?: string;
  regionId?: string;
  /**
   * @remarks
   * The timestamp that indicates the start time of the validity period for the policy.
   * 
   * This value is a UNIX timestamp that represents the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
   * 
   * This parameter is required.
   * 
   * @example
   * 1622949300000
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      groupId: 'GroupId',
      policyType: 'PolicyType',
      regionId: 'RegionId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      groupId: 'string',
      policyType: 'string',
      regionId: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMonitorGroupNotifyPolicyResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The HTTP status code 200 indicates that the call succeeds.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The Request is not authorization.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 13356BCA-3EC3-4748-A771-2064DA69AEF1
   */
  requestId?: string;
  /**
   * @remarks
   * The number of entries that are returned.
   * 
   * @example
   * 1
   */
  result?: number;
  /**
   * @remarks
   * Indicates whether the call succeeds. Valid values:
   * 
   * *   true: The call succeeds.
   * *   false: The call fails.
   * 
   * @example
   * true
   */
  success?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      result: 'number',
      success: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMonitorGroupNotifyPolicyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateMonitorGroupNotifyPolicyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateMonitorGroupNotifyPolicyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMonitoringAgentProcessRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * i-2ze51wjtwox01r8g****
   */
  instanceId?: string;
  /**
   * @remarks
   * The name of the process.
   * 
   * @example
   * java
   */
  processName?: string;
  /**
   * @remarks
   * The user who launches the process.
   * 
   * @example
   * admin
   */
  processUser?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      processName: 'ProcessName',
      processUser: 'ProcessUser',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      processName: 'string',
      processUser: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMonitoringAgentProcessResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the call was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The ID of the process.
   * 
   * @example
   * 12345
   */
  id?: number;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * User not authorized to operate on the specified resource.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0DFCB47D-E7E1-4CBE-A381-8339F7B300EF
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call was successful. Valid values:
   * 
   * *   true: The call was successful.
   * *   false: The call failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      id: 'Id',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      id: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMonitoringAgentProcessResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateMonitoringAgentProcessResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateMonitoringAgentProcessResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteMonitorRequest extends $tea.Model {
  /**
   * @remarks
   * The URL or IP address that is monitored by the task.
   * 
   * This parameter is required.
   * 
   * @example
   * https://www.aliyun.com
   */
  address?: string;
  /**
   * @remarks
   * The ID of the alert rule.
   * 
   * For more information about how to obtain the ID of an alert rule, see [DescribeMetricRuleList](https://help.aliyun.com/document_detail/114941.html).
   * 
   * @example
   * SystemDefault_acs_ecs_dashboard_InternetOutRate_Percent
   */
  alertIds?: string;
  /**
   * @remarks
   * The custom detection period. You can only select a time period from Monday to Sunday for detection.
   * 
   * @example
   * {"start_hour":0,"end_hour":24, "days":[0], "time_zone":"Local"}
   */
  customSchedule?: string;
  /**
   * @remarks
   * The interval at which detection requests are sent.
   * 
   * Valid values: 1, 5, 15, 30, and 60. Unit: minutes.
   * 
   * Default value: 1.
   * 
   * @example
   * 1
   */
  interval?: string;
  /**
   * @remarks
   * The information of the detection points. If you leave this parameter empty, the system randomly selects three detection points.
   * 
   * The value is a JSON array. Example: `[{"city":"546","isp":"465"},{"city":"572","isp":"465"},{"city":"738","isp":"465"}]`. The values of the city field indicate Beijing, Hangzhou, and Qingdao.
   * 
   * For information about how to obtain detection points, see [DescribeSiteMonitorISPCityList](https://help.aliyun.com/document_detail/115045.html).
   * 
   * @example
   * [{"city":"546","isp":"465"},{"city":"572","isp":"465"},{"city":"738","isp":"465"}]
   */
  ispCities?: string;
  /**
   * @remarks
   * The extended options of the protocol that is used by the site monitoring task. The options vary based on the protocol.
   * 
   * @example
   * {"time_out":5000}
   */
  optionsJson?: string;
  regionId?: string;
  /**
   * @remarks
   * The name of the site monitoring task.
   * 
   * The name must be 4 to 100 characters in length, and can contain letters, digits, and underscores (_).
   * 
   * This parameter is required.
   * 
   * @example
   * HanZhou_ECS1
   */
  taskName?: string;
  /**
   * @remarks
   * The type of the site monitoring task.
   * 
   * Valid values: HTTP, HTTPS, PING, TCP, UDP, DNS, SMTP, POP3, and FTP.
   * 
   * This parameter is required.
   * 
   * @example
   * HTTPS
   */
  taskType?: string;
  vpcConfig?: string;
  static names(): { [key: string]: string } {
    return {
      address: 'Address',
      alertIds: 'AlertIds',
      customSchedule: 'CustomSchedule',
      interval: 'Interval',
      ispCities: 'IspCities',
      optionsJson: 'OptionsJson',
      regionId: 'RegionId',
      taskName: 'TaskName',
      taskType: 'TaskType',
      vpcConfig: 'VpcConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      address: 'string',
      alertIds: 'string',
      customSchedule: 'string',
      interval: 'string',
      ispCities: 'string',
      optionsJson: 'string',
      regionId: 'string',
      taskName: 'string',
      taskType: 'string',
      vpcConfig: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteMonitorResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * > The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The returned result.
   * 
   * If a site monitoring task is created, the result is returned. If a site monitoring task fails to be created, no result is returned.
   */
  createResultList?: CreateSiteMonitorResponseBodyCreateResultList;
  /**
   * @remarks
   * The result of the site monitoring task.
   */
  data?: CreateSiteMonitorResponseBodyData;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * Successful
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 68192f5d-0d45-4b98-9724-892813f86c71
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      createResultList: 'CreateResultList',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      createResultList: CreateSiteMonitorResponseBodyCreateResultList,
      data: CreateSiteMonitorResponseBodyData,
      message: 'string',
      requestId: 'string',
      success: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteMonitorResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateSiteMonitorResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateSiteMonitorResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CursorRequest extends $tea.Model {
  /**
   * @remarks
   * The end of the time range to query.
   * 
   * Unit: milliseconds.
   * 
   * > 
   * 
   * *   This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. For example, 2023-01-01T00:00:00Z indicates January 1, 2023, 00:00:00 UTC.
   * 
   * *   If you do not set the end time, the end time is infinite. You can leave this parameter empty in real-time export scenarios.
   * *   In CloudMonitor, the TTL of monitoring data varies with the time granularity. Specify a proper time interval based on the TTL corresponding to the value of the `Period` parameter.
   * 
   * @example
   * 1641645000000
   */
  endTime?: string;
  /**
   * @remarks
   * The dimension information of the metric.
   */
  matchers?: Matcher[];
  /**
   * @remarks
   * The metric that is used to monitor the cloud service.
   * 
   * For more information about the metrics of cloud services, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * This parameter is required.
   * 
   * @example
   * cpu_idle
   */
  metric?: string;
  /**
   * @remarks
   * The namespace of the cloud service.
   * 
   * For more information about the namespaces of cloud services, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * This parameter is required.
   * 
   * @example
   * acs_ecs_dashboard
   */
  namespace?: string;
  /**
   * @remarks
   * The time interval based on which the metric value is measured.
   * 
   * Unit: seconds.
   * 
   * >  Generally, the time interval is 60 seconds. For more information about specific values, see the `Period` parameter in [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * This parameter is required.
   * 
   * @example
   * 60
   */
  period?: number;
  /**
   * @remarks
   * The beginning of the time range to query.
   * 
   * Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. For example, 2023-01-01T00:00:00Z indicates January 1, 2023, 00:00:00 UTC.
   * 
   * >  In CloudMonitor, the TTL of monitoring data varies with the time granularity. Specify a proper time interval based on the TTL corresponding to the value of the `Period` parameter.
   * 
   * This parameter is required.
   * 
   * @example
   * 1641627000000
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      matchers: 'Matchers',
      metric: 'Metric',
      namespace: 'Namespace',
      period: 'Period',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      matchers: { 'type': 'array', 'itemType': Matcher },
      metric: 'string',
      namespace: 'string',
      period: 'number',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CursorShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The end of the time range to query.
   * 
   * Unit: milliseconds.
   * 
   * > 
   * 
   * *   This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. For example, 2023-01-01T00:00:00Z indicates January 1, 2023, 00:00:00 UTC.
   * 
   * *   If you do not set the end time, the end time is infinite. You can leave this parameter empty in real-time export scenarios.
   * *   In CloudMonitor, the TTL of monitoring data varies with the time granularity. Specify a proper time interval based on the TTL corresponding to the value of the `Period` parameter.
   * 
   * @example
   * 1641645000000
   */
  endTime?: string;
  /**
   * @remarks
   * The dimension information of the metric.
   */
  matchersShrink?: string;
  /**
   * @remarks
   * The metric that is used to monitor the cloud service.
   * 
   * For more information about the metrics of cloud services, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * This parameter is required.
   * 
   * @example
   * cpu_idle
   */
  metric?: string;
  /**
   * @remarks
   * The namespace of the cloud service.
   * 
   * For more information about the namespaces of cloud services, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * This parameter is required.
   * 
   * @example
   * acs_ecs_dashboard
   */
  namespace?: string;
  /**
   * @remarks
   * The time interval based on which the metric value is measured.
   * 
   * Unit: seconds.
   * 
   * >  Generally, the time interval is 60 seconds. For more information about specific values, see the `Period` parameter in [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * This parameter is required.
   * 
   * @example
   * 60
   */
  period?: number;
  /**
   * @remarks
   * The beginning of the time range to query.
   * 
   * Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. For example, 2023-01-01T00:00:00Z indicates January 1, 2023, 00:00:00 UTC.
   * 
   * >  In CloudMonitor, the TTL of monitoring data varies with the time granularity. Specify a proper time interval based on the TTL corresponding to the value of the `Period` parameter.
   * 
   * This parameter is required.
   * 
   * @example
   * 1641627000000
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      matchersShrink: 'Matchers',
      metric: 'Metric',
      namespace: 'Namespace',
      period: 'Period',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      matchersShrink: 'string',
      metric: 'string',
      namespace: 'string',
      period: 'number',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CursorResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * Cursor is used as an input parameter for data export in the [BatchExport](https://help.aliyun.com/document_detail/2329847.html) operation.
   * 
   * @example
   * v2.5eyJiYXRjaGVzIjoxLCJidWNrZXRCeXRlcyI6IndBPT0iLCJidWNrZXRzIjo0LCJjdXJyZW50QnVja2V0IjotNjQsImN1cnJlbnRUYXJnZXRUaW1lU2xvdCI6MTY3ODc1MjAwMCwiZW5kVGltZSI6MTY3ODc4MjQxOTAwMCwiZXhwb3J0RW5kVGltZSI6MTY3ODc4MjQxOTAwMCwiZXhwb3J0U3RhcnRUaW1lIjoxNjc4NzgxODE5MDAwLCJleHByZXNzUmFuZ2UiOmZhbHNlLCJoYXNOZXh0Ijp0cnVlLCJpbmRleCI6MCwibGF0ZXN0TG9nVGltZSI6MCwibWF0Y2hlcnMiOnsiY2hhaW4iOlt7ImxhYmVsIjoidXNlcklkIiwib3BlcmF0b3IiOiJFUVVBTFMiLCJ2YWx1ZSI6IjEyNzA2NzY2Nzk1NDY3MDQifV0sImxvY2tlZCI6dHJ1ZX0sIm1ldHJpYyI6IlNwbGl0cndQcm94eU1heFJlc3BvbnNlU2l6ZSIsIm1ldHJpY1R5cGUiOiJNRVRSSUMiLCJuYW1lc3BhY2UiOiJhY3Nfa3ZzdG9yZV9leCIsIm5leHRQa0FkYXB0ZXIiOnsiZGltIjoiVjowXG5EOmB1c2VySWRgPTEyNzA2NzY2Nzk1NDY3MDQsYGluc3RhbmNlSWRgPXItcmo5ZjlzMTlsc3V1MXd1bnVyLGBub2RlSWRgPXItcmo5ZjlzMTlsc3V1MXd1bnVyLXByb3h5LTIsXG4iLCJtZXRhIjoiXG5WOjBcbk06YWNzX2t2c3RvcmVfZXgvU3BsaXRyd1Byb3h5TWF4UmVzcG9uc2VTaXplXG5XOjYwXG5COjRcbkk6LTFcblQ6MFxuQzpgQXZlcmFnZWAsYE1heGltdW1gLGBfX2NvdW50X19gLGBfX3RzX19gXG4iLCJyZCI6InN1YkFMU0RwWXY2K0t6aENQQUFBWkErNUFKMEpjbGErRGd2V0hFNWxDSHMvbGtqR2FXYTFJTkVwdFE9PSIsInRhZyI6IiJ9LCJvZmZzZXQiOjAsIm9mZnNldERpZ2l0Ijo0NTU0NTczNDQyMTc4NDIxMjIsInN0YXJ0VGltZSI6MTY3ODc4MTgxOTAwMCwic3RlcCI6LTEsInRhZ01hdGNoZXJzIjp7ImNoYWluIjpbXSwibG9ja2VkIjp0cnVlfSwidGFyZ2V0VGltZVNsb3RzIjpbMTY3ODY2NTYwMCwxNjc4NzUyMDAwXSwidXVpZCI6ImQwMmFhZmY1LWU3ZGQtNDUyYy0***********
   */
  cursor?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 915C2D7A-E6A4-17C3-8E13-4DBDD61E7919
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      cursor: 'Cursor',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      cursor: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CursorResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CursorResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CursorResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteContactRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the alert contact.
   * 
   * This parameter is required.
   * 
   * @example
   * test-01
   */
  contactName?: string;
  static names(): { [key: string]: string } {
    return {
      contactName: 'ContactName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contactName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteContactResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the call was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 50D4CFE1-01E5-4543-939C-18BC01E3EC1C
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call was successful. The value true indicates a success. The value false indicates a failure.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteContactResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteContactResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteContactResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteContactGroupRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the alert group.
   * 
   * This parameter is required.
   * 
   * @example
   * contact_group_2019_templatedfkXQ
   */
  contactGroupName?: string;
  static names(): { [key: string]: string } {
    return {
      contactGroupName: 'ContactGroupName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contactGroupName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteContactGroupResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the call was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * F722BE59-2400-4A64-9C1A-AD886AED9A69
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call was successful. The value true indicates a success. The value false indicates a failure.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteContactGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteContactGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteContactGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCustomMetricRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the application group.
   * 
   * This parameter is required.
   * 
   * @example
   * 3607****
   */
  groupId?: string;
  /**
   * @remarks
   * The MD5 value of the HTTP request body. The MD5 value is a 128-bit hash value used to verify the uniqueness of the reported monitoring data.
   * 
   * >  `Md5` is returned when you query the reported monitoring data of a metric.
   * 
   * @example
   * 38796C8CFFEB8F89BB2A626C7BD7****
   */
  md5?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * This parameter is required.
   * 
   * @example
   * AdvanceCredit
   */
  metricName?: string;
  regionId?: string;
  /**
   * @remarks
   * The ID of the request for reporting monitoring data.
   * 
   * >  `UUID` is returned when you query the reported monitoring data of a metric. We recommend that you specify the `Md5` parameter.
   * 
   * @example
   * 5497633c-66c5-4eae-abaa-89db5adb****
   */
  UUID?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      md5: 'Md5',
      metricName: 'MetricName',
      regionId: 'RegionId',
      UUID: 'UUID',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      md5: 'string',
      metricName: 'string',
      regionId: 'string',
      UUID: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCustomMetricResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the call is successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 05B36C2C-5F6E-48D5-8B41-CE36DD7EE8E0
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCustomMetricResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteCustomMetricResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteCustomMetricResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDynamicTagGroupRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the tag rule.
   * 
   * For information about how to obtain the ID of a tag rule, see [DescribeDynamicTagRuleList](https://help.aliyun.com/document_detail/150126.html).
   * 
   * This parameter is required.
   * 
   * @example
   * 6b882d9a-5117-42e2-9d0c-4749a0c6****
   */
  dynamicTagRuleId?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      dynamicTagRuleId: 'DynamicTagRuleId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dynamicTagRuleId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDynamicTagGroupResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code.
   * 
   * > The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The Request is not authorization.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 08AAE67E-77B5-485B-9C79-D7C8C059150A
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDynamicTagGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteDynamicTagGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteDynamicTagGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEventRuleTargetsRequest extends $tea.Model {
  /**
   * @remarks
   * The IDs of event-triggered alert rules.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  ids?: string[];
  regionId?: string;
  /**
   * @remarks
   * The name of the event-triggered alert rule.
   * 
   * For information about how to obtain the name of an event-triggered alert rule, see [DescribeEventRuleList](https://help.aliyun.com/document_detail/114996.html).
   * 
   * This parameter is required.
   * 
   * @example
   * testRule
   */
  ruleName?: string;
  static names(): { [key: string]: string } {
    return {
      ids: 'Ids',
      regionId: 'RegionId',
      ruleName: 'RuleName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ids: { 'type': 'array', 'itemType': 'string' },
      regionId: 'string',
      ruleName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEventRuleTargetsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response code.
   * 
   * >  The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * Success
   */
  message?: string;
  /**
   * @remarks
   * The request ID. You can use the request ID to query logs and troubleshoot issues.
   * 
   * @example
   * 7ADD7EFB-7555-4EC1-A3D9-F9955C189CCF
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`
   * *   `false`
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEventRuleTargetsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteEventRuleTargetsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteEventRuleTargetsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEventRulesRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * rule1
   */
  ruleNames?: string[];
  static names(): { [key: string]: string } {
    return {
      ruleNames: 'RuleNames',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ruleNames: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEventRulesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the call was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * E5A72B5B-4F44-438C-B68A-147FD5DC53A8
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call was successful. The value true indicates a success. The value false indicates a failure.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEventRulesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteEventRulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteEventRulesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteExporterOutputRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the configuration set.
   * 
   * This parameter is required.
   * 
   * @example
   * testName
   */
  destName?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      destName: 'DestName',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      destName: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteExporterOutputResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * > The status code 200 indicates that the request was successful. Other status codes indicate that the request failed.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * Success
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 2DECF751-7AFA-43BB-8C63-2B6B07E51AE1
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`
   * *   `false`
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteExporterOutputResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteExporterOutputResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteExporterOutputResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteExporterRuleRequest extends $tea.Model {
  regionId?: string;
  /**
   * @remarks
   * The name of the data export rule.
   * 
   * This parameter is required.
   * 
   * @example
   * myRuleName
   */
  ruleName?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      ruleName: 'RuleName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      ruleName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteExporterRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * > The status code 200 indicates that the request was successful. Other status codes indicate that the request failed.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 6A5F022D-AC7C-460E-94AE-B9E75083D023
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`
   * *   `false`
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteExporterRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteExporterRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteExporterRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGroupMonitoringAgentProcessRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the application group.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456
   */
  groupId?: string;
  /**
   * @remarks
   * The ID of the process monitoring task.
   * 
   * This parameter is required.
   * 
   * @example
   * 48F83746-C817-478C-9B06-7158F56B****
   */
  id?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      id: 'Id',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      id: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGroupMonitoringAgentProcessResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the call was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * The Request is not authorization.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 3F6150F9-45C7-43F9-9578-A58B2E726C90
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call was successful. Valid values:
   * 
   * *   true: The call was successful.
   * *   false: The call failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGroupMonitoringAgentProcessResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteGroupMonitoringAgentProcessResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteGroupMonitoringAgentProcessResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteHostAvailabilityRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 12456
   */
  id?: number[];
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: { 'type': 'array', 'itemType': 'number' },
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteHostAvailabilityResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the call was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 57C782E6-B235-4842-AD2B-DB94961761EB
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call was successful. The value true indicates a success. The value false indicates a failure.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteHostAvailabilityResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteHostAvailabilityResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteHostAvailabilityResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteHybridMonitorNamespaceRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the namespace.
   * 
   * For information about how to obtain the name of a namespace, see [DescribeHybridMonitorNamespaceList](https://help.aliyun.com/document_detail/428880.html).
   * 
   * This parameter is required.
   * 
   * @example
   * aliyun
   */
  namespace?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      namespace: 'Namespace',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      namespace: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteHybridMonitorNamespaceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * Success
   */
  code?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * Namespace.NotFound
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 3843D23A-FB9E-5DC8-BCCC-458768B79296
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteHybridMonitorNamespaceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteHybridMonitorNamespaceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteHybridMonitorNamespaceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteHybridMonitorSLSGroupRequest extends $tea.Model {
  regionId?: string;
  /**
   * @remarks
   * The name of the Logstore group.
   * 
   * For information about how to obtain the name of a Logstore group, see [DescribeHybridMonitorSLSGroup](https://help.aliyun.com/document_detail/429526.html).
   * 
   * This parameter is required.
   * 
   * @example
   * Logstore_test
   */
  SLSGroupName?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      SLSGroupName: 'SLSGroupName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      SLSGroupName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteHybridMonitorSLSGroupResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code.
   * 
   * > The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * RESOURCE_NOT_FOUND
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 85198BFF-1DE6-556E-B6A4-C77C51C62B8D
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteHybridMonitorSLSGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteHybridMonitorSLSGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteHybridMonitorSLSGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteHybridMonitorTaskRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the namespace.
   * 
   * The name can contain uppercase letters, lowercase letters, digits, and hyphens (-).
   * 
   * > This parameter is required only if you call this operation to delete metric import tasks for Alibaba Cloud services. In this case, the `TaskType` parameter is set to `aliyun_fc`.
   * 
   * @example
   * aliyun
   */
  namespace?: string;
  regionId?: string;
  /**
   * @remarks
   * The ID of the member account.
   * 
   * > This parameter is required only if you use a management account to call this operation to query metric import tasks that belong to a member in a resource directory. In this case, the `TaskType` parameter is set to `aliyun_fc`.
   * 
   * @example
   * 120886317861****
   */
  targetUserId?: string;
  /**
   * @remarks
   * The ID of the metric import task.
   * 
   * For information about how to obtain the ID of a metric import task, see [DescribeHybridMonitorTaskList](https://help.aliyun.com/document_detail/428624.html).
   * 
   * > This parameter is required only if you call this operation to delete metrics for the logs that are imported from Log Service. In this case, the `TaskType` parameter is set to `aliyun_sls`.
   * 
   * @example
   * 36****
   */
  taskId?: string;
  static names(): { [key: string]: string } {
    return {
      namespace: 'Namespace',
      regionId: 'RegionId',
      targetUserId: 'TargetUserId',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      namespace: 'string',
      regionId: 'string',
      targetUserId: 'string',
      taskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteHybridMonitorTaskResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code.
   * 
   * > The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * null
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * D6B8103F-7BAD-5FEB-945F-71D991AB8834
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteHybridMonitorTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteHybridMonitorTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteHybridMonitorTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLogMonitorRequest extends $tea.Model {
  /**
   * @remarks
   * The ID returned by Log Service.
   * 
   * This parameter is required.
   * 
   * @example
   * 12345
   */
  logId?: number;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      logId: 'LogId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logId: 'number',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLogMonitorResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the call was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * metric not exist.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 42BFFC2B-5E4D-4FDE-BCC6-E91EE33C5967
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call was successful. Valid values:
   * 
   * *   true: The call was successful.
   * *   false: The call failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLogMonitorResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteLogMonitorResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteLogMonitorResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMetricRuleBlackListRequest extends $tea.Model {
  /**
   * @remarks
   * The IDs of the blacklist policies. Separate multiple IDs with commas (,). You can specify up to 50 IDs.
   * 
   * For more information about how to obtain the ID of a blacklist policy, see [DescribeMetricRuleBlackList](https://help.aliyun.com/document_detail/457257.html).
   * 
   * >  You can also set this parameter to a JSON array. Example: `["a9ad2ac2-3ed9-11ed-b878-0242ac12****","5cb8a9a4-198f-4651-a353-f8b28788****"]`.
   * 
   * This parameter is required.
   * 
   * @example
   * a9ad2ac2-3ed9-11ed-b878-0242ac12****
   */
  id?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMetricRuleBlackListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The number of blacklist policies that are deleted.
   * 
   * @example
   * 1
   */
  count?: number;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The specified resource is not found.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * B88D233C-A004-3AB8-AD9C-30CBDD4440C5
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      count: 'Count',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      count: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMetricRuleBlackListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteMetricRuleBlackListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteMetricRuleBlackListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMetricRuleResourcesRequest extends $tea.Model {
  /**
   * @remarks
   * The resources to be disassociated from the alert rule.
   * 
   * This parameter is required.
   * 
   * @example
   * [{"instanceId":"i-uf6hm9lnlzsarrc7****"}]
   */
  resources?: string;
  /**
   * @remarks
   * The ID of the alert rule.
   * 
   * This parameter is required.
   * 
   * @example
   * rr-bp18017n6iolv****
   */
  ruleId?: string;
  static names(): { [key: string]: string } {
    return {
      resources: 'Resources',
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resources: 'string',
      ruleId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMetricRuleResourcesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the call was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * The alert does not exist.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * D8A35882-90C6-4F03-BBEB-153C180398EA
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call was successful. Valid values:
   * 
   * *   true: The call was successful.
   * *   false: The call failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMetricRuleResourcesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteMetricRuleResourcesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteMetricRuleResourcesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMetricRuleTargetsRequest extends $tea.Model {
  regionId?: string;
  /**
   * @remarks
   * The ID of the alert rule.
   * 
   * This parameter is required.
   * 
   * @example
   * ruleId-xxxxxx
   */
  ruleId?: string;
  /**
   * @remarks
   * The resource IDs.
   * 
   * This parameter is required.
   * 
   * @example
   * 12345
   */
  targetIds?: string[];
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      ruleId: 'RuleId',
      targetIds: 'TargetIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      ruleId: 'string',
      targetIds: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMetricRuleTargetsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * **
   * 
   * **Description** The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The IDs of the resources that failed to be deleted.
   */
  failIds?: DeleteMetricRuleTargetsResponseBodyFailIds;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The Request is not authorization.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 786E92D2-AC66-4250-B76F-F1E2FCDDBA1C
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      failIds: 'FailIds',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      failIds: DeleteMetricRuleTargetsResponseBodyFailIds,
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMetricRuleTargetsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteMetricRuleTargetsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteMetricRuleTargetsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMetricRuleTemplateRequest extends $tea.Model {
  regionId?: string;
  /**
   * @remarks
   * The ID of the alert template.
   * 
   * This parameter is required.
   * 
   * @example
   * 123****
   */
  templateId?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      templateId: 'TemplateId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      templateId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMetricRuleTemplateResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the call was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 7B63F8CF-D48D-4608-A402-04FB5B2B4B6A
   */
  requestId?: string;
  /**
   * @remarks
   * The information about the alert template.
   */
  resource?: DeleteMetricRuleTemplateResponseBodyResource;
  /**
   * @remarks
   * Indicates whether the call was successful. The value true indicates a success. The value false indicates a failure.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      resource: 'Resource',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      message: 'string',
      requestId: 'string',
      resource: DeleteMetricRuleTemplateResponseBodyResource,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMetricRuleTemplateResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteMetricRuleTemplateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteMetricRuleTemplateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMetricRulesRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * ab05733c97b7ce239fb1b53393dc1697c7e12****
   */
  id?: string[];
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: { 'type': 'array', 'itemType': 'string' },
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMetricRulesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code.
   * 
   * >  The status code 200 indicates a success.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * The specified resource is not found.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * E5599964-8D0D-40DC-8E90-27A619384B81
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the operation was successful. Valid values:
   * 
   * *   true: successful.
   * *   false: failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMetricRulesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteMetricRulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteMetricRulesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMonitorGroupRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the application group.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456
   */
  groupId?: number;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'number',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMonitorGroupResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the call was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The deleted application group.
   */
  group?: DeleteMonitorGroupResponseBodyGroup;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * The Request is not authorization.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CA35B3AE-4FFD-4A33-AE67-67EF68711EFA
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call was successful. The value true indicates a success. The value false indicates a failure.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      group: 'Group',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      group: DeleteMonitorGroupResponseBodyGroup,
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMonitorGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteMonitorGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteMonitorGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMonitorGroupDynamicRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The service to which the rule applies. Valid values: ecs, rds, and slb.
   * 
   * This parameter is required.
   * 
   * @example
   * ecs
   */
  category?: string;
  /**
   * @remarks
   * The ID of the application group.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456
   */
  groupId?: number;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      groupId: 'GroupId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      groupId: 'number',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMonitorGroupDynamicRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the call was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 56B4516A-EB44-4C66-8854-0393B35F636B
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call was successful. The value true indicates a success. The value false indicates a failure.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMonitorGroupDynamicRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteMonitorGroupDynamicRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteMonitorGroupDynamicRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMonitorGroupInstancesRequest extends $tea.Model {
  /**
   * @remarks
   * The abbreviation of the cloud service name.
   * 
   * >  For more information about how to obtain the abbreviation of a cloud service name, see `metricCategory` in the response parameter `Labels` of the [DescribeProjectMeta](https://help.aliyun.com/document_detail/114916.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * ecs
   */
  category?: string;
  /**
   * @remarks
   * The ID of the application group.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456
   */
  groupId?: number;
  /**
   * @remarks
   * The instances to be removed from the application group. Separate multiple instances with commas (,). You can remove a maximum of 20 instances from an application group at a time.
   * 
   * This parameter is required.
   * 
   * @example
   * i-a2d5q7pm3f912****,i-a2d5q7pm3f222****
   */
  instanceIdList?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      groupId: 'GroupId',
      instanceIdList: 'InstanceIdList',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      groupId: 'number',
      instanceIdList: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMonitorGroupInstancesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 5351B0F2-26A9-4BC9-87FF-1B74034D12C3
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMonitorGroupInstancesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteMonitorGroupInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteMonitorGroupInstancesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMonitorGroupNotifyPolicyRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the application group.
   * 
   * @example
   * 6780****
   */
  groupId?: string;
  /**
   * @remarks
   * The policy type.
   * 
   * Valid value: PauseNotify.
   * 
   * This parameter is required.
   * 
   * @example
   * PauseNotify
   */
  policyType?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      policyType: 'PolicyType',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      policyType: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMonitorGroupNotifyPolicyResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code.
   * 
   * > The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The Request is not authorization.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * B7AF834D-D38B-4A46-920B-FE974EB7E135
   */
  requestId?: string;
  /**
   * @remarks
   * The number of affected rows.
   * 
   * @example
   * 1
   */
  result?: number;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      result: 'number',
      success: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMonitorGroupNotifyPolicyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteMonitorGroupNotifyPolicyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteMonitorGroupNotifyPolicyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMonitoringAgentProcessRequest extends $tea.Model {
  /**
   * @remarks
   * The instance ID.
   * 
   * This parameter is required.
   * 
   * @example
   * i-KpVny6l****
   */
  instanceId?: string;
  /**
   * @remarks
   * The process ID.
   * 
   * > You must configure either `ProcessId` or `ProcessName`.
   * 
   * @example
   * 123****
   */
  processId?: string;
  /**
   * @remarks
   * The process name.
   * 
   * > You must configure either `ProcessId` or `ProcessName`.
   * 
   * @example
   * http
   */
  processName?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      processId: 'ProcessId',
      processName: 'ProcessName',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      processId: 'string',
      processName: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMonitoringAgentProcessResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code.
   * 
   * > The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The specified resource is not found.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 971CC023-5A96-452A-BB7C-2483F948BCFD
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMonitoringAgentProcessResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteMonitoringAgentProcessResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteMonitoringAgentProcessResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSiteMonitorsRequest extends $tea.Model {
  /**
   * @remarks
   * Specifies whether to delete the alert rules configured for the site monitoring tasks. Valid values:
   * 
   * *   true (default value)
   * *   false
   * 
   * @example
   * true
   */
  isDeleteAlarms?: boolean;
  regionId?: string;
  /**
   * @remarks
   * The IDs of the site monitoring tasks that you want to delete. Separate multiple task IDs with commas (,).
   * 
   * This parameter is required.
   * 
   * @example
   * 01adacc2-ece5-41b6-afa2-3143ab5d****,43bd1ead-514f-4524-813e-228ce091****
   */
  taskIds?: string;
  static names(): { [key: string]: string } {
    return {
      isDeleteAlarms: 'IsDeleteAlarms',
      regionId: 'RegionId',
      taskIds: 'TaskIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isDeleteAlarms: 'boolean',
      regionId: 'string',
      taskIds: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSiteMonitorsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the call was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The information about the site monitoring tasks that were deleted.
   */
  data?: DeleteSiteMonitorsResponseBodyData;
  /**
   * @remarks
   * The returned message. If the call was successful, the value success is returned. If the call failed, an error message such as `TaskId not found` is returned.
   * 
   * @example
   * successful
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 123BCC5D-8B63-48EA-B747-9A8995BE7AA6
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call was successful. The value true indicates success. The value false indicates failure.
   * 
   * @example
   * true
   */
  success?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: DeleteSiteMonitorsResponseBodyData,
      message: 'string',
      requestId: 'string',
      success: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSiteMonitorsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteSiteMonitorsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteSiteMonitorsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeActiveMetricRuleListRequest extends $tea.Model {
  /**
   * @remarks
   * The abbreviation of the cloud service that supports initiative alert rules.
   * 
   * For more information about how to obtain the name of a cloud service, see [DescribeProductsOfActiveMetricRule](https://help.aliyun.com/document_detail/114930.html).
   * 
   * This parameter is required.
   * 
   * @example
   * ecs
   */
  product?: string;
  static names(): { [key: string]: string } {
    return {
      product: 'Product',
    };
  }

  static types(): { [key: string]: any } {
    return {
      product: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeActiveMetricRuleListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the alert rules. The result is in the same structure as that returned by the DescribeMetricRuleList operation.
   */
  alertList?: DescribeActiveMetricRuleListResponseBodyAlertList;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The details of the alert rules.
   */
  datapoints?: DescribeActiveMetricRuleListResponseBodyDatapoints;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * The Request is not authorization.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * F82E6667-7811-4BA0-842F-5B2DC42BBAAD
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      alertList: 'AlertList',
      code: 'Code',
      datapoints: 'Datapoints',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertList: DescribeActiveMetricRuleListResponseBodyAlertList,
      code: 'string',
      datapoints: DescribeActiveMetricRuleListResponseBodyDatapoints,
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeActiveMetricRuleListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeActiveMetricRuleListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeActiveMetricRuleListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAlertHistoryListRequest extends $tea.Model {
  /**
   * @remarks
   * The order of alerts. Valid values:
   * 
   * *   true (default value): reverse chronological order
   * *   false: chronological order
   * 
   * @example
   * true
   */
  ascending?: boolean;
  /**
   * @remarks
   * The end timestamp of the historical alerts that you want to query.
   * 
   * Unit: milliseconds.
   * 
   * @example
   * 1640608200000
   */
  endTime?: string;
  /**
   * @remarks
   * The ID of the application group.
   * 
   * For information about how to obtain the ID of an application group, see [DescribeMonitorGroups](https://help.aliyun.com/document_detail/115032.html).
   * 
   * @example
   * 7671****
   */
  groupId?: string;
  /**
   * @remarks
   * The metric that is used to monitor the cloud service.
   * 
   * For information about how to query the name of a metric, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * @example
   * cpu_total
   */
  metricName?: string;
  /**
   * @remarks
   * The namespace of the cloud service.
   * 
   * For information about how to query the namespace of a cloud service, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * @example
   * acs_ecs_dashboard
   */
  namespace?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * Default value: 1.
   * 
   * @example
   * 1
   */
  page?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  regionId?: string;
  /**
   * @remarks
   * The ID of the alert rule.
   * 
   * For information about how to obtain the ID of an alert rule, see [DescribeMetricRuleList](https://help.aliyun.com/document_detail/114941.html).
   * 
   * @example
   * applyTemplate61dc81b5-d357-4cf6-a9b7-9f83c1d5****
   */
  ruleId?: string;
  /**
   * @remarks
   * The name of the alert rule.
   * 
   * For information about how to query the name of an alert rule, see [DescribeMetricRuleList](https://help.aliyun.com/document_detail/114941.html).
   * 
   * @example
   * ECS_Rule
   */
  ruleName?: string;
  /**
   * @remarks
   * The start timestamp of the historical alerts that you want to query.
   * 
   * Unit: milliseconds.
   * 
   * @example
   * 1640237400000
   */
  startTime?: string;
  /**
   * @remarks
   * The status of the alert. Valid values:
   * 
   * *   ALARM (default value): Alerts are triggered.
   * *   OK: No alerts are triggered.
   * 
   * @example
   * ALARM
   */
  state?: string;
  /**
   * @remarks
   * Specifies whether alerts are muted. Valid values:
   * 
   * *   2 (default value): Alerts are muted and are not triggered within the mute period, even if the condition specified in the alert rule is met.
   * *   0: Alerts are triggered or cleared.
   * *   1: The alert rule is ineffective.
   * 
   * @example
   * 2
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      ascending: 'Ascending',
      endTime: 'EndTime',
      groupId: 'GroupId',
      metricName: 'MetricName',
      namespace: 'Namespace',
      page: 'Page',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      ruleId: 'RuleId',
      ruleName: 'RuleName',
      startTime: 'StartTime',
      state: 'State',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ascending: 'boolean',
      endTime: 'string',
      groupId: 'string',
      metricName: 'string',
      namespace: 'string',
      page: 'number',
      pageSize: 'number',
      regionId: 'string',
      ruleId: 'string',
      ruleName: 'string',
      startTime: 'string',
      state: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAlertHistoryListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of historical alerts.
   */
  alarmHistoryList?: DescribeAlertHistoryListResponseBodyAlarmHistoryList;
  /**
   * @remarks
   * The status code.
   * 
   * > The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The Request is not authorization.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * C3C69FBE-2262-541F-A409-C52F380BAE63
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 2
   */
  total?: string;
  static names(): { [key: string]: string } {
    return {
      alarmHistoryList: 'AlarmHistoryList',
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alarmHistoryList: DescribeAlertHistoryListResponseBodyAlarmHistoryList,
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
      total: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAlertHistoryListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAlertHistoryListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAlertHistoryListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAlertLogCountRequest extends $tea.Model {
  /**
   * @remarks
   * The alert group.
   * 
   * @example
   * ECS_Group
   */
  contactGroup?: string;
  /**
   * @remarks
   * The end timestamp of the alert logs to be queried.
   * 
   * Unit: milliseconds.
   * 
   * You can query only the alert logs within the last year. If the query time is longer than one year, the return value of the `AlertLogCount` parameter is empty.
   * 
   * >  The interval between the start time (StartTime) and end time (EndTime) must be less than or equal to 15 days. The start time and end time must be specified or left empty at the same time. If you do not specify the start time and end time, the alert logs within the last 15 minutes are queried by default.
   * 
   * @example
   * 1610074409694
   */
  endTime?: number;
  /**
   * @remarks
   * The type of the alert event. Valid values:
   * 
   * *   TRIGGERED: The alert is triggered.
   * *   RESOLVED: The alert is resolved.
   * 
   * @example
   * TRIGGERED
   */
  eventType?: string;
  /**
   * @remarks
   * The dimension based on which data is aggregated. This parameter is similar to the Group By clause of SQL statements. Valid values:
   * 
   * *   `product`: aggregates data by cloud service.
   * *   `level`: aggregates data by alert level.
   * *   `groupId`: aggregates data by application group.
   * *   `contactGroup`: aggregates data by alert group.
   * *   `product,metricName`: aggregates data both by cloud service and by metric.
   * 
   * This parameter is required.
   * 
   * @example
   * product
   */
  groupBy?: string;
  /**
   * @remarks
   * The ID of the application group.
   * 
   * @example
   * 7301****
   */
  groupId?: string;
  /**
   * @remarks
   * The statistical period of alert logs. Unit: minutes.
   * 
   * @example
   * 360
   */
  lastMin?: string;
  /**
   * @remarks
   * The level and notification method of the alert. Valid values:
   * 
   * *   P4: Alert notifications are sent by using emails and DingTalk chatbots.
   * *   OK: No alert is generated.
   * 
   * @example
   * P4
   */
  level?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * >  For more information about the metrics of different cloud services, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * @example
   * cpu_total
   */
  metricName?: string;
  /**
   * @remarks
   * The namespace of the cloud service.
   * 
   * >  For more information about the namespaces of cloud services, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * @example
   * acs_ecs_dashboard
   */
  namespace?: string;
  /**
   * @remarks
   * The dimension based on which data is aggregated. This parameter is equivalent to the GROUP BY clause in SQL. Valid values:
   * 
   * *   `product`: aggregates data by cloud service.
   * *   `level`: aggregates data by alert level.
   * *   `groupId`: aggregates data by application group.
   * *   `contactGroup`: aggregates data by alert contact group.
   * *   `product,metricName`: aggregates data both by cloud service and by metric.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The abbreviation of the service name.
   * 
   * @example
   * ECS
   */
  product?: string;
  regionId?: string;
  /**
   * @remarks
   * The ID of the alert rule.
   * 
   * For more information about how to obtain the ID of an alert rule, see [DescribeMetricRuleList](https://help.aliyun.com/document_detail/114941.html).
   * 
   * @example
   * bfae2ca5b4e07d2c7278772e***********
   */
  ruleId?: string;
  /**
   * @remarks
   * The name of the alert rule.
   * 
   * @example
   * test123
   */
  ruleName?: string;
  /**
   * @remarks
   * The keyword based on which the alert logs to be counted are searched.
   * 
   * @example
   * test
   */
  searchKey?: string;
  /**
   * @remarks
   * The status of the alert. Valid values:
   * 
   * *   0: The alert is triggered or cleared.
   * *   1: The alert is generated not during the effective period.
   * *   2: The alert is muted and not triggered in a specified period.
   * *   3: The host is restarting.
   * *   4: Notifications are not sent for the alert.
   * 
   * When the value of the SendStatus parameter is 0, the value P4 of the Level parameter indicates a triggered alert and the value OK indicates a cleared alert.
   * 
   * @example
   * 0
   */
  sendStatus?: string;
  /**
   * @remarks
   * This parameter is deprecated.
   * 
   * @example
   * None
   */
  sourceType?: string;
  /**
   * @remarks
   * The start timestamp of the alert logs to be queried.
   * 
   * Unit: milliseconds.
   * 
   * You can query only the alert logs within the last year. If the query time is longer than one year, the return value of the `AlertLogCount` parameter is empty.
   * 
   * >  The interval between the start time (StartTime) and end time (EndTime) must be less than or equal to 15 days. The start time and end time must be specified or left empty at the same time. If you do not specify the start time and end time, the alert logs within the last 15 minutes are queried by default.
   * 
   * @example
   * 1609988009694
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      contactGroup: 'ContactGroup',
      endTime: 'EndTime',
      eventType: 'EventType',
      groupBy: 'GroupBy',
      groupId: 'GroupId',
      lastMin: 'LastMin',
      level: 'Level',
      metricName: 'MetricName',
      namespace: 'Namespace',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      product: 'Product',
      regionId: 'RegionId',
      ruleId: 'RuleId',
      ruleName: 'RuleName',
      searchKey: 'SearchKey',
      sendStatus: 'SendStatus',
      sourceType: 'SourceType',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contactGroup: 'string',
      endTime: 'number',
      eventType: 'string',
      groupBy: 'string',
      groupId: 'string',
      lastMin: 'string',
      level: 'string',
      metricName: 'string',
      namespace: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      product: 'string',
      regionId: 'string',
      ruleId: 'string',
      ruleName: 'string',
      searchKey: 'string',
      sendStatus: 'string',
      sourceType: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAlertLogCountResponseBody extends $tea.Model {
  /**
   * @remarks
   * The statistics of alert logs.
   */
  alertLogCount?: DescribeAlertLogCountResponseBodyAlertLogCount[];
  /**
   * @remarks
   * The HTTP status code.
   * 
   * > The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The specified resource is not found.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 1C4A3709-BF52-42EE-87B5-7435F0929585
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      alertLogCount: 'AlertLogCount',
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertLogCount: { 'type': 'array', 'itemType': DescribeAlertLogCountResponseBodyAlertLogCount },
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAlertLogCountResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAlertLogCountResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAlertLogCountResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAlertLogHistogramRequest extends $tea.Model {
  /**
   * @remarks
   * The alert contact group.
   * 
   * @example
   * ECS_Group
   */
  contactGroup?: string;
  /**
   * @remarks
   * The end timestamp of the alert logs to be queried.
   * 
   * Unit: milliseconds.
   * 
   * > 
   * 
   * *   You can query only the alert logs within the last year.
   * 
   * *   The interval between the start time (`StartTime`) and end time (`EndTime`) must be less than or equal to 15 days.
   * 
   * @example
   * 1609989009694
   */
  endTime?: number;
  /**
   * @remarks
   * The type of the alert event. Valid values:
   * 
   * *   TRIGGERED: The alert is triggered.
   * *   RESOLVED: The alert is resolved.
   * 
   * @example
   * RESOLVED
   */
  eventType?: string;
  /**
   * @remarks
   * The dimensions based on which data is aggregated. This parameter is equivalent to the GROUP BY clause in SQL. Valid values:
   * 
   * *   `product`: aggregates data by cloud service.
   * *   `level`: aggregates data by alert level.
   * *   `groupId`: aggregates data by application group.
   * *   `contactGroup`: aggregates data by alert contact group.
   * *   `product,metricName`: aggregates data both by cloud service and by metric.
   * 
   * @example
   * product
   */
  groupBy?: string;
  /**
   * @remarks
   * The ID of the application group.
   * 
   * @example
   * 7301****
   */
  groupId?: string;
  /**
   * @remarks
   * The statistical period of alert logs. Unit: minutes.
   * 
   * @example
   * 360
   */
  lastMin?: string;
  /**
   * @remarks
   * The severity level and notification methods of the alert. Valid values:
   * 
   * *   P4: Alert notifications are sent by using emails and DingTalk chatbots.
   * *   OK: No alert is generated.
   * 
   * @example
   * P4
   */
  level?: string;
  /**
   * @remarks
   * The metric name.
   * 
   * >  For more information about the metrics of different cloud services, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * @example
   * cpu_total
   */
  metricName?: string;
  /**
   * @remarks
   * The namespace of the Alibaba Cloud service.
   * 
   * >  For more information about the namespaces of different cloud services, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * @example
   * acs_ecs_dashboard
   */
  namespace?: string;
  /**
   * @remarks
   * The page number.
   * 
   * Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The abbreviation of the Alibaba Cloud service name.
   * 
   * @example
   * ECS
   */
  product?: string;
  regionId?: string;
  /**
   * @remarks
   * The ID of the alert rule.
   * 
   * For more information about how to obtain the ID of an alert rule, see [DescribeMetricRuleList](https://help.aliyun.com/document_detail/114941.html).
   * 
   * @example
   * ae06917_75a8c43178ab66****
   */
  ruleId?: string;
  /**
   * @remarks
   * The name of the alert rule.
   * 
   * @example
   * test123
   */
  ruleName?: string;
  /**
   * @remarks
   * The keyword that is used to query alert logs.
   * 
   * @example
   * alert
   */
  searchKey?: string;
  /**
   * @remarks
   * The alert status. Valid values:
   * 
   * *   0: The alert is triggered or cleared.
   * *   1: The alert is ineffective.
   * *   2: The alert is muted and not triggered in a specified period.
   * *   3: The host is restarting.
   * *   4: No alert notification is sent.
   * 
   * If the value of the SendStatus parameter is 0, the value P4 of the Level parameter indicates a triggered alert and the value OK indicates a cleared alert.
   * 
   * @example
   * 0
   */
  sendStatus?: string;
  /**
   * @remarks
   * This parameter is deprecated.
   * 
   * @example
   * None
   */
  sourceType?: string;
  /**
   * @remarks
   * The start timestamp of the alert logs to be queried.
   * 
   * Unit: milliseconds.
   * 
   * > 
   * 
   * *   You can query only the alert logs within the last year.
   * 
   * *   The interval between the start time (`StartTime`) and end time (`EndTime`) must be less than or equal to 15 days.
   * 
   * @example
   * 1609988009694
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      contactGroup: 'ContactGroup',
      endTime: 'EndTime',
      eventType: 'EventType',
      groupBy: 'GroupBy',
      groupId: 'GroupId',
      lastMin: 'LastMin',
      level: 'Level',
      metricName: 'MetricName',
      namespace: 'Namespace',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      product: 'Product',
      regionId: 'RegionId',
      ruleId: 'RuleId',
      ruleName: 'RuleName',
      searchKey: 'SearchKey',
      sendStatus: 'SendStatus',
      sourceType: 'SourceType',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contactGroup: 'string',
      endTime: 'number',
      eventType: 'string',
      groupBy: 'string',
      groupId: 'string',
      lastMin: 'string',
      level: 'string',
      metricName: 'string',
      namespace: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      product: 'string',
      regionId: 'string',
      ruleId: 'string',
      ruleName: 'string',
      searchKey: 'string',
      sendStatus: 'string',
      sourceType: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAlertLogHistogramResponseBody extends $tea.Model {
  /**
   * @remarks
   * The number of alert logs that were generated during each interval of a time period.
   */
  alertLogHistogramList?: DescribeAlertLogHistogramResponseBodyAlertLogHistogramList[];
  /**
   * @remarks
   * The response code.
   * 
   * >  The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The specified resource is not found.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 1C4A3709-BF52-42EE-87B5-7435F0929585
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      alertLogHistogramList: 'AlertLogHistogramList',
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertLogHistogramList: { 'type': 'array', 'itemType': DescribeAlertLogHistogramResponseBodyAlertLogHistogramList },
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAlertLogHistogramResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAlertLogHistogramResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAlertLogHistogramResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAlertLogListRequest extends $tea.Model {
  /**
   * @remarks
   * The alert contact group.
   * 
   * @example
   * ECS_Group
   */
  contactGroup?: string;
  /**
   * @remarks
   * The end timestamp of the alert logs to be queried.
   * 
   * Unit: milliseconds.
   * 
   * You can query only the alert logs within the last year. If the query time is longer than one year, the return value of the `AlertLogList` parameter is empty.
   * 
   * >  The time period between the start time specified by `StartTime` and end time specified by `EndTime` must be less than or equal to 15 days. You must specify StartTime and EndTime at the same time, or leave StartTime and EndTime empty at the same time. If you do not specify this parameter, the alert logs within the last 15 minutes are queried by default.
   * 
   * @example
   * 1610074409694
   */
  endTime?: number;
  /**
   * @remarks
   * The type of the alert event. Valid values:
   * 
   * *   TRIGGERED: The alert is triggered.
   * *   RESOLVED: The alert is resolved.
   * 
   * @example
   * TRIGGERED
   */
  eventType?: string;
  /**
   * @remarks
   * The dimensions based on which data is aggregated. This parameter is equivalent to the GROUP BY clause in SQL. Valid values:
   * 
   * *   `product`: aggregates data by cloud service.
   * *   `level`: aggregates data by alert level.
   * *   `groupId`: aggregates data by application group.
   * *   `contactGroup`: aggregates data by alert contact group.
   * *   `product,metricName`: aggregates data both by cloud service and by metric.
   * 
   * @example
   * product
   */
  groupBy?: string;
  /**
   * @remarks
   * The ID of the application group.
   * 
   * @example
   * 7301****
   */
  groupId?: string;
  /**
   * @remarks
   * The statistical period of alert logs. Unit: minutes.
   * 
   * @example
   * 360
   */
  lastMin?: string;
  /**
   * @remarks
   * The severity level and notification methods of the alert. Valid values:
   * 
   * *   P4: Alert notifications are sent by using emails and DingTalk chatbots.
   * *   OK: No alert is generated.
   * 
   * @example
   * P4
   */
  level?: string;
  /**
   * @remarks
   * The metric name.
   * 
   * > For more information about the metrics of different cloud services, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * @example
   * IntranetInRate
   */
  metricName?: string;
  /**
   * @remarks
   * The namespace of the cloud service.
   * 
   * >  For information about how to query the namespace of a cloud service, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * @example
   * acs_ecs_dashboard
   */
  namespace?: string;
  /**
   * @remarks
   * The page number.
   * 
   * Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The abbreviation of the service name.
   * 
   * For information about how to obtain the abbreviation of a cloud service name, see [DescribeProductsOfActiveMetricRule](https://help.aliyun.com/document_detail/114930.html).
   * 
   * @example
   * ECS
   */
  product?: string;
  regionId?: string;
  /**
   * @remarks
   * The ID of the alert rule.
   * 
   * For information about how to obtain the ID of an alert rule, see [DescribeMetricRuleList](https://help.aliyun.com/document_detail/114941.html).
   * 
   * @example
   * bc369e8_30f87e517ed2fc****
   */
  ruleId?: string;
  /**
   * @remarks
   * The name of the alert rule.
   * 
   * @example
   * test123
   */
  ruleName?: string;
  /**
   * @remarks
   * The search keyword that is used to query alert logs.
   * 
   * @example
   * alert
   */
  searchKey?: string;
  /**
   * @remarks
   * The status of the alert. Valid values:
   * 
   * *   0: The alert is triggered or cleared.
   * *   1: The alert is ineffective.
   * *   2: The alert is muted.
   * *   3: The host is restarting.
   * *   4: No alert notification is sent.
   * 
   * If the value of the SendStatus parameter is 0, the value P4 of the Level parameter indicates a triggered alert and the value OK indicates a cleared alert.
   * 
   * @example
   * 0
   */
  sendStatus?: string;
  /**
   * @remarks
   * The type of the alert rule. Valid value: METRIC. This value indicates an alert rule for time series metrics.
   * 
   * @example
   * METRIC
   */
  sourceType?: string;
  /**
   * @remarks
   * The start timestamp of the alert logs to be queried.
   * 
   * Unit: milliseconds.
   * 
   * You can query only the alert logs within the last year. If the query time is longer than one year, the return value of the `AlertLogList` parameter is empty.
   * 
   * >  The time period between the start time specified by `StartTime` and the end time specified by `EndTime` must be less than or equal to 15 days. You must specify StartTime and EndTime at the same time, or leave StartTime and EndTime empty at the same time. If you do not specify this parameter, the alert logs within the last 15 minutes are queried by default.
   * 
   * @example
   * 1609988009694
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      contactGroup: 'ContactGroup',
      endTime: 'EndTime',
      eventType: 'EventType',
      groupBy: 'GroupBy',
      groupId: 'GroupId',
      lastMin: 'LastMin',
      level: 'Level',
      metricName: 'MetricName',
      namespace: 'Namespace',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      product: 'Product',
      regionId: 'RegionId',
      ruleId: 'RuleId',
      ruleName: 'RuleName',
      searchKey: 'SearchKey',
      sendStatus: 'SendStatus',
      sourceType: 'SourceType',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contactGroup: 'string',
      endTime: 'number',
      eventType: 'string',
      groupBy: 'string',
      groupId: 'string',
      lastMin: 'string',
      level: 'string',
      metricName: 'string',
      namespace: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      product: 'string',
      regionId: 'string',
      ruleId: 'string',
      ruleName: 'string',
      searchKey: 'string',
      sendStatus: 'string',
      sourceType: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAlertLogListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The queried alert logs.
   */
  alertLogList?: DescribeAlertLogListResponseBodyAlertLogList[];
  /**
   * @remarks
   * The HTTP status code.
   * 
   * > The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The specified resource is not found.
   */
  message?: string;
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 1C4A3709-BF52-42EE-87B5-7435F0929585
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      alertLogList: 'AlertLogList',
      code: 'Code',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertLogList: { 'type': 'array', 'itemType': DescribeAlertLogListResponseBodyAlertLogList },
      code: 'string',
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAlertLogListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAlertLogListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAlertLogListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAlertingMetricRuleResourcesRequest extends $tea.Model {
  /**
   * @remarks
   * Queries the alerts that were triggered before the specified time. Timestamps in milliseconds are supported.
   * 
   * @example
   * 1698827400000
   */
  alertBeforeTime?: string;
  /**
   * @remarks
   * The dimensions that specify the resources whose monitoring data you want to query.
   * 
   * @example
   * {\\"userId\\":\\"120886317861****\\",\\"region\\":\\"cn-huhehaote\\",\\"queue\\":\\"test-0128\\"}
   */
  dimensions?: string;
  /**
   * @remarks
   * The ID of the application group. For information about how to obtain the ID of an application group, see [DescribeMonitorGroups](https://help.aliyun.com/document_detail/115032.html).
   * 
   * @example
   * 7671****
   */
  groupId?: string;
  /**
   * @remarks
   * The namespace of the cloud service.
   * 
   * For more information about the namespaces of cloud services, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * @example
   * acs_mns_new
   */
  namespace?: string;
  /**
   * @remarks
   * The page number.
   * 
   * Default value: 1.
   * 
   * @example
   * 1
   */
  page?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  regionId?: string;
  /**
   * @remarks
   * The ID of the alert rule. For information about how to obtain the ID of an alert rule, see [DescribeMetricRuleList](https://help.aliyun.com/document_detail/114941.html).
   * 
   * @example
   * putNewAlarm_user_7e78d765-0e3e-4671-ba6d-7ce39108****
   */
  ruleId?: string;
  static names(): { [key: string]: string } {
    return {
      alertBeforeTime: 'AlertBeforeTime',
      dimensions: 'Dimensions',
      groupId: 'GroupId',
      namespace: 'Namespace',
      page: 'Page',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertBeforeTime: 'string',
      dimensions: 'string',
      groupId: 'string',
      namespace: 'string',
      page: 'number',
      pageSize: 'number',
      regionId: 'string',
      ruleId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAlertingMetricRuleResourcesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code.
   * 
   * > The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The request processing has failed due to some unknown error.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0724011B-D9E0-4B2F-8C51-F17A894CC42C
   */
  requestId?: string;
  /**
   * @remarks
   * The resources that are associated with the alert rule.
   */
  resources?: DescribeAlertingMetricRuleResourcesResponseBodyResources;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 2
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      resources: 'Resources',
      success: 'Success',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      message: 'string',
      requestId: 'string',
      resources: DescribeAlertingMetricRuleResourcesResponseBodyResources,
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAlertingMetricRuleResourcesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAlertingMetricRuleResourcesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAlertingMetricRuleResourcesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeContactGroupListRequest extends $tea.Model {
  /**
   * @remarks
   * The number of the page to return.
   * 
   * @example
   * 10
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * @example
   * 1
   */
  pageSize?: number;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeContactGroupListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the call was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The information about alert groups that were queried.
   */
  contactGroupList?: DescribeContactGroupListResponseBodyContactGroupList;
  /**
   * @remarks
   * The names of alert groups.
   */
  contactGroups?: DescribeContactGroupListResponseBodyContactGroups;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * The Request is not authorization.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 916EE694-03C2-47B6-85EE-5054E3C168D3
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call was successful. Valid values:
   * 
   * *   true: The call was successful.
   * *   false: The call failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The total number of the returned entries.
   * 
   * @example
   * 22
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      contactGroupList: 'ContactGroupList',
      contactGroups: 'ContactGroups',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      contactGroupList: DescribeContactGroupListResponseBodyContactGroupList,
      contactGroups: DescribeContactGroupListResponseBodyContactGroups,
      message: 'string',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeContactGroupListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeContactGroupListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeContactGroupListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeContactListRequest extends $tea.Model {
  /**
   * @remarks
   * The alert notification method. Valid values:
   * 
   * *   Mail: emails
   * *   DingWebHook: DingTalk chatbots
   * 
   * @example
   * Mail
   */
  chanelType?: string;
  /**
   * @remarks
   * The value specified for the alert notification method.
   * 
   * >  This parameter is required only if you set the `ChanelType` parameter to `Mail`.
   * 
   * @example
   * Alice@example.com
   */
  chanelValue?: string;
  /**
   * @remarks
   * The name of the alert contact.
   * 
   * @example
   * Alice
   */
  contactName?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * Default value: 100.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      chanelType: 'ChanelType',
      chanelValue: 'ChanelValue',
      contactName: 'ContactName',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      chanelType: 'string',
      chanelValue: 'string',
      contactName: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeContactListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the call was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The alert contacts.
   */
  contacts?: DescribeContactListResponseBodyContacts;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The Request is not authorization.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 06D5ECC2-B9BE-42A4-8FA3-1A610FB08B83
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call was successful. Valid values:
   * 
   * *   true: The call was successful.
   * *   false: The call failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The total number of returned entries.
   * 
   * @example
   * 15
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      contacts: 'Contacts',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      contacts: DescribeContactListResponseBodyContacts,
      message: 'string',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeContactListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeContactListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeContactListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeContactListByContactGroupRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the alert contact group.
   * 
   * This parameter is required.
   * 
   * @example
   * CloudMonitor
   */
  contactGroupName?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      contactGroupName: 'ContactGroupName',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contactGroupName: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeContactListByContactGroupResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The alert contacts that receive alert notifications.
   */
  contacts?: DescribeContactListByContactGroupResponseBodyContacts;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * The group is not exists.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 06D5ECC2-B9BE-42A4-8FA3-1A610FB08B83
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      contacts: 'Contacts',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      contacts: DescribeContactListByContactGroupResponseBodyContacts,
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeContactListByContactGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeContactListByContactGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeContactListByContactGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCustomEventAttributeRequest extends $tea.Model {
  /**
   * @remarks
   * The end of the time range to query.
   * 
   * This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
   * 
   * @example
   * 1552227965971
   */
  endTime?: string;
  /**
   * @remarks
   * The ID of the custom event.
   * 
   * @example
   * 123****
   */
  eventId?: string;
  /**
   * @remarks
   * The ID of the application group.
   * 
   * @example
   * 123****
   */
  groupId?: string;
  /**
   * @remarks
   * The name of the custom event.
   * 
   * @example
   * test123
   */
  name?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * @example
   * 50
   */
  pageSize?: number;
  regionId?: string;
  /**
   * @remarks
   * The keywords that are contained in the content of the custom event to query. You can use a logical operator between keywords.
   * 
   * *   If you need to query the custom event whose content contains a and b, set the value to a and b.
   * *   If you need to query the custom event whose content contains a or b, set the value to a or b.
   * 
   * @example
   * cms
   */
  searchKeywords?: string;
  /**
   * @remarks
   * The beginning of the time range to query.
   * 
   * This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
   * 
   * @example
   * 1552224365971
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      eventId: 'EventId',
      groupId: 'GroupId',
      name: 'Name',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      searchKeywords: 'SearchKeywords',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      eventId: 'string',
      groupId: 'string',
      name: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      searchKeywords: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCustomEventAttributeResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the call was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The details of the custom event.
   */
  customEvents?: DescribeCustomEventAttributeResponseBodyCustomEvents;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * userId:173651113438**** and name:"BABEL_CHECK"
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 60912C8D-B340-4253-ADE7-61ACDFD25CFC
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call was successful. Valid values:
   * 
   * *   true: The call was successful.
   * *   false: The call failed.
   * 
   * @example
   * true
   */
  success?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      customEvents: 'CustomEvents',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      customEvents: DescribeCustomEventAttributeResponseBodyCustomEvents,
      message: 'string',
      requestId: 'string',
      success: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCustomEventAttributeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeCustomEventAttributeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeCustomEventAttributeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCustomEventCountRequest extends $tea.Model {
  /**
   * @remarks
   * The end of the time range to query.
   * 
   * This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
   * 
   * @example
   * 1552220485596
   */
  endTime?: string;
  /**
   * @remarks
   * The ID of the custom event.
   * 
   * @example
   * 123
   */
  eventId?: string;
  /**
   * @remarks
   * The ID of the application group.
   * 
   * @example
   * 12345
   */
  groupId?: string;
  /**
   * @remarks
   * The name of the custom event.
   * 
   * @example
   * BABEL_BUY
   */
  name?: string;
  regionId?: string;
  /**
   * @remarks
   * The keywords that are contained in the content of the custom event to query. You can use a logical operator between keywords.
   * 
   * *   If you need to query the custom event whose content contains a and b, set the value to a and b.
   * *   If you need to query the custom event whose content contains a or b, set the value to a or b.
   * 
   * @example
   * cms
   */
  searchKeywords?: string;
  /**
   * @remarks
   * The beginning of the time range to query.
   * 
   * This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
   * 
   * @example
   * 1552209685596
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      eventId: 'EventId',
      groupId: 'GroupId',
      name: 'Name',
      regionId: 'RegionId',
      searchKeywords: 'SearchKeywords',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      eventId: 'string',
      groupId: 'string',
      name: 'string',
      regionId: 'string',
      searchKeywords: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCustomEventCountResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the call was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The details of the custom event.
   */
  customEventCounts?: DescribeCustomEventCountResponseBodyCustomEventCounts;
  /**
   * @remarks
   * The returned message. If the call was successful, the value success is returned. If the call failed, an error message is returned.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 60912C8D-B340-4253-ADE7-61ACDFD25CFC
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call was successful. The value true indicates a success. The value false indicates a failure.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      customEventCounts: 'CustomEventCounts',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      customEventCounts: DescribeCustomEventCountResponseBodyCustomEventCounts,
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCustomEventCountResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeCustomEventCountResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeCustomEventCountResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCustomEventHistogramRequest extends $tea.Model {
  /**
   * @remarks
   * The end of the time range to query.
   * 
   * This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
   * 
   * @example
   * 1552220485596
   */
  endTime?: string;
  /**
   * @remarks
   * The ID of the custom event.
   * 
   * @example
   * 123
   */
  eventId?: string;
  /**
   * @remarks
   * The ID of the application group.
   * 
   * @example
   * 12345
   */
  groupId?: string;
  /**
   * @remarks
   * The level of the custom event. Valid values:
   * 
   * *   CRITICAL
   * *   WARN
   * *   INFO
   * 
   * @example
   * CRITICAL
   */
  level?: string;
  /**
   * @remarks
   * The name of the custom event.
   * 
   * @example
   * BucketIngressBandwidth
   */
  name?: string;
  regionId?: string;
  /**
   * @remarks
   * The keywords that are contained in the content of the custom event to query. You can use a logical operator between keywords.
   * 
   * *   If you need to query the custom event whose content contains a and b, set the value to a and b.
   * *   If you need to query the custom event whose content contains a or b, set the value to a or b.
   * 
   * @example
   * cms
   */
  searchKeywords?: string;
  /**
   * @remarks
   * The beginning of the time range to query.
   * 
   * This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
   * 
   * @example
   * 1552209685596
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      eventId: 'EventId',
      groupId: 'GroupId',
      level: 'Level',
      name: 'Name',
      regionId: 'RegionId',
      searchKeywords: 'SearchKeywords',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      eventId: 'string',
      groupId: 'string',
      level: 'string',
      name: 'string',
      regionId: 'string',
      searchKeywords: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCustomEventHistogramResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the call was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The information about the number of times that the custom event occurred during each interval of a time period.
   */
  eventHistograms?: DescribeCustomEventHistogramResponseBodyEventHistograms;
  /**
   * @remarks
   * The returned message. If the call was successful, the value success is returned. If the call failed, an error message is returned.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 486029C9-53E1-44B4-85A8-16A571A043FD
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call was successful. The value true indicates a success. The value false indicates a failure.
   * 
   * @example
   * true
   */
  success?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      eventHistograms: 'EventHistograms',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      eventHistograms: DescribeCustomEventHistogramResponseBodyEventHistograms,
      message: 'string',
      requestId: 'string',
      success: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCustomEventHistogramResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeCustomEventHistogramResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeCustomEventHistogramResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCustomMetricListRequest extends $tea.Model {
  /**
   * @remarks
   * The dimensions that specify the resources for which you want to query custom metrics.
   * 
   * @example
   * {sampleName1=value1&amp;sampleName2=value2}
   */
  dimension?: string;
  /**
   * @remarks
   * The ID of the application group.
   * 
   * For more information, see [DescribeMonitorGroups](https://help.aliyun.com/document_detail/115032.html).
   * 
   * @example
   * 7378****
   */
  groupId?: string;
  /**
   * @remarks
   * The MD5 value of the HTTP request body. The MD5 value is a 128-bit hash value used to verify the uniqueness of the reported custom metrics.
   * 
   * @example
   * 97c25982d9745a231276bff27469****
   */
  md5?: string;
  /**
   * @remarks
   * The name of the custom metric.
   * 
   * @example
   * cpu_total
   */
  metricName?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * Pages start from page 1. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: string;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * Pages start from page 1. Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      dimension: 'Dimension',
      groupId: 'GroupId',
      md5: 'Md5',
      metricName: 'MetricName',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dimension: 'string',
      groupId: 'string',
      md5: 'string',
      metricName: 'string',
      pageNumber: 'string',
      pageSize: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCustomMetricListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The value 200 indicates that the call is successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 1AF425E4-1DEA-54F2-910A-8117C9686140
   */
  requestId?: string;
  /**
   * @remarks
   * The reported custom metrics that are found in the query.
   * 
   * @example
   * {\\"all\\":0,\\"size\\":10,\\"param\\":{\\"metric\\":\\"{\\\\\\"metricName\\\\\\":\\\\\\"cpu_total\\\\\\",\\\\\\"groupId\\\\\\":7378****,\\\\\\"project\\\\\\":\\\\\\"acs_customMetric_120886317861****\\\\\\",\\\\\\"dimension\\\\\\":\\\\\\"sampleName1=value1&sampleName2=value2\\\\\\",\\\\\\"status\\\\\\":1}\\",\\"service\\":\\"metric-center.aliyun-inc.com\\"},\\"page\\":1,\\"list\\":[]}
   */
  result?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      result: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCustomMetricListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeCustomMetricListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeCustomMetricListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDynamicTagRuleListRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the tag rule.
   * 
   * @example
   * 004155fa-15ba-466d-b61a-***********
   */
  dynamicTagRuleId?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * Pages start from page 1. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: string;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * Minimum value: 1. Default value: 30.
   * 
   * @example
   * 30
   */
  pageSize?: string;
  /**
   * @remarks
   * The tag key.
   * 
   * For more information about how to obtain a tag key, see [DescribeTagKeyList](https://help.aliyun.com/document_detail/145558.html).
   * 
   * @example
   * tagkey1
   */
  tagKey?: string;
  /**
   * @remarks
   * The ID of the region to which the tags belong.
   * 
   * @example
   * cn-hangzhou
   */
  tagRegionId?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * For more information about how to obtain a tag value, see [DescribeTagKeyList](https://help.aliyun.com/document_detail/145557.html).
   * 
   * @example
   * *
   */
  tagValue?: string;
  static names(): { [key: string]: string } {
    return {
      dynamicTagRuleId: 'DynamicTagRuleId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      tagKey: 'TagKey',
      tagRegionId: 'TagRegionId',
      tagValue: 'TagValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dynamicTagRuleId: 'string',
      pageNumber: 'string',
      pageSize: 'string',
      tagKey: 'string',
      tagRegionId: 'string',
      tagValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDynamicTagRuleListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the call was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The specified resource is not found.
   */
  message?: string;
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: string;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 30
   */
  pageSize?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0D50523D-8D59-4A61-B58E-E2286ECFB3A9
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call was successful. Valid values:
   * 
   * *   true: The call was successful.
   * *   false: The call failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The tag rules of application groups.
   */
  tagGroupList?: DescribeDynamicTagRuleListResponseBodyTagGroupList;
  /**
   * @remarks
   * The total number of returned entries.
   * 
   * @example
   * 2
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      tagGroupList: 'TagGroupList',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      pageNumber: 'string',
      pageSize: 'string',
      requestId: 'string',
      success: 'boolean',
      tagGroupList: DescribeDynamicTagRuleListResponseBodyTagGroupList,
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDynamicTagRuleListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDynamicTagRuleListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDynamicTagRuleListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEventRuleAttributeRequest extends $tea.Model {
  regionId?: string;
  /**
   * @remarks
   * The name of the event-triggered alert rule.
   * 
   * For information about how to obtain the name of an event-triggered alert rule, see [DescribeEventRuleList](https://help.aliyun.com/document_detail/114996.html).
   * 
   * This parameter is required.
   * 
   * @example
   * testRule
   */
  ruleName?: string;
  /**
   * @remarks
   * The mute period during which new alert notifications are not sent even if the trigger conditions are met.
   * 
   * Unit: seconds. Default value: 86400, which indicates one day.
   * 
   * >  Only one alert notification is sent during each mute period even if the metric value exceeds the alert threshold several times.
   * 
   * @example
   * 86400
   */
  silenceTime?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      ruleName: 'RuleName',
      silenceTime: 'SilenceTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      ruleName: 'string',
      silenceTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEventRuleAttributeResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The alert does not exist.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 9AA3F210-C03D-4C86-8DB6-21C84FF692A1
   */
  requestId?: string;
  /**
   * @remarks
   * The details of the event-triggered alert rule.
   */
  result?: DescribeEventRuleAttributeResponseBodyResult;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      result: DescribeEventRuleAttributeResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEventRuleAttributeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeEventRuleAttributeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeEventRuleAttributeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEventRuleListRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the application group.
   * 
   * @example
   * 7378****
   */
  groupId?: string;
  /**
   * @remarks
   * Specifies whether to enable the event-triggered alert rule. Valid values:
   * 
   * - true (default)
   * - false
   * 
   * @example
   * true
   */
  isEnable?: boolean;
  /**
   * @remarks
   * The prefix in the name of the event-triggered alert rule.
   * 
   * @example
   * test
   */
  namePrefix?: string;
  /**
   * @remarks
   * The page number.
   * 
   * Pages start from page 1. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: string;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * Pages start from page 1. Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      isEnable: 'IsEnable',
      namePrefix: 'NamePrefix',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      isEnable: 'boolean',
      namePrefix: 'string',
      pageNumber: 'string',
      pageSize: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEventRuleListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The event-triggered alert rule.
   */
  eventRules?: DescribeEventRuleListResponseBodyEventRules;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * User not authorized to operate on the specified resource.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * D0E6D82B-16B5-422A-8136-EE5BDC01E415
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 21
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      eventRules: 'EventRules',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      eventRules: DescribeEventRuleListResponseBodyEventRules,
      message: 'string',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEventRuleListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeEventRuleListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeEventRuleListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEventRuleTargetListRequest extends $tea.Model {
  regionId?: string;
  /**
   * @remarks
   * The name of the event-triggered alert rule.
   * 
   * This parameter is required.
   * 
   * @example
   * testRule
   */
  ruleName?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      ruleName: 'RuleName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      ruleName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEventRuleTargetListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the call was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The information about the recipients if alert notifications are sent to the alert contacts of an alert contact group.
   */
  contactParameters?: DescribeEventRuleTargetListResponseBodyContactParameters;
  /**
   * @remarks
   * The information about the recipients in Function Compute.
   */
  fcParameters?: DescribeEventRuleTargetListResponseBodyFcParameters;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The Request is not authorization.
   */
  message?: string;
  /**
   * @remarks
   * The information about the recipients in Message Service (MNS).
   */
  mnsParameters?: DescribeEventRuleTargetListResponseBodyMnsParameters;
  /**
   * @remarks
   * The information about the recipients in OpenAPI Explorer.
   */
  openApiParameters?: DescribeEventRuleTargetListResponseBodyOpenApiParameters;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 87170bc7-e28a-4c93-b9bf-90a1dbe84736
   */
  requestId?: string;
  /**
   * @remarks
   * The information about the recipients in Log Service.
   */
  slsParameters?: DescribeEventRuleTargetListResponseBodySlsParameters;
  /**
   * @remarks
   * The information about the recipients if alert notifications are sent by sending a request to a callback URL.
   */
  webhookParameters?: DescribeEventRuleTargetListResponseBodyWebhookParameters;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      contactParameters: 'ContactParameters',
      fcParameters: 'FcParameters',
      message: 'Message',
      mnsParameters: 'MnsParameters',
      openApiParameters: 'OpenApiParameters',
      requestId: 'RequestId',
      slsParameters: 'SlsParameters',
      webhookParameters: 'WebhookParameters',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      contactParameters: DescribeEventRuleTargetListResponseBodyContactParameters,
      fcParameters: DescribeEventRuleTargetListResponseBodyFcParameters,
      message: 'string',
      mnsParameters: DescribeEventRuleTargetListResponseBodyMnsParameters,
      openApiParameters: DescribeEventRuleTargetListResponseBodyOpenApiParameters,
      requestId: 'string',
      slsParameters: DescribeEventRuleTargetListResponseBodySlsParameters,
      webhookParameters: DescribeEventRuleTargetListResponseBodyWebhookParameters,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEventRuleTargetListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeEventRuleTargetListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeEventRuleTargetListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExporterOutputListRequest extends $tea.Model {
  /**
   * @remarks
   * The number of the page to return. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExporterOutputListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * > The status code 200 indicates that the request was successful. Other status codes indicate that the request failed.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The configuration sets for exporting monitoring data.
   */
  datapoints?: DescribeExporterOutputListResponseBodyDatapoints;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * sucess
   */
  message?: string;
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0E657631-CD6C-4C24-9637-98D000B9272C
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`
   * *   `false`
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The total number of returned entries.
   * 
   * @example
   * 25
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      datapoints: 'Datapoints',
      message: 'Message',
      pageNumber: 'PageNumber',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      datapoints: DescribeExporterOutputListResponseBodyDatapoints,
      message: 'string',
      pageNumber: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExporterOutputListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeExporterOutputListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeExporterOutputListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExporterRuleListRequest extends $tea.Model {
  /**
   * @remarks
   * The page number. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 1000.
   * 
   * @example
   * 1000
   */
  pageSize?: number;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExporterRuleListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * > The status code 200 indicates that the request was successful. Other status codes indicate that the request failed.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The details of the data export rules.
   */
  datapoints?: DescribeExporterRuleListResponseBodyDatapoints;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * susscess
   */
  message?: string;
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 6BA047CA-8BC6-40BC-BC8F-FBECF35F1993
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`
   * *   `false`
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The total number of returned entries.
   * 
   * @example
   * 1000
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      datapoints: 'Datapoints',
      message: 'Message',
      pageNumber: 'PageNumber',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      datapoints: DescribeExporterRuleListResponseBodyDatapoints,
      message: 'string',
      pageNumber: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExporterRuleListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeExporterRuleListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeExporterRuleListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGroupMonitoringAgentProcessRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the application group.
   * 
   * This parameter is required.
   * 
   * @example
   * 12345
   */
  groupId?: string;
  /**
   * @remarks
   * The page number. Default value: 1
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The process name.
   * 
   * @example
   * sshd
   */
  processName?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      processName: 'ProcessName',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      processName: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGroupMonitoringAgentProcessResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status codes.
   * 
   * >  The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The Request is not authorization.
   */
  message?: string;
  /**
   * @remarks
   * The page number. Default value: 1
   * 
   * @example
   * 1
   */
  pageNumber?: string;
  /**
   * @remarks
   * The number of entries per page. Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: string;
  /**
   * @remarks
   * The process monitoring tasks.
   */
  processes?: DescribeGroupMonitoringAgentProcessResponseBodyProcesses;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 7985D471-3FA8-4EE9-8F4B-45C19DF3D36F
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values: Valid values: true and false.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The total number of returned entries.
   * 
   * @example
   * 28
   */
  total?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      processes: 'Processes',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      pageNumber: 'string',
      pageSize: 'string',
      processes: DescribeGroupMonitoringAgentProcessResponseBodyProcesses,
      requestId: 'string',
      success: 'boolean',
      total: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGroupMonitoringAgentProcessResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeGroupMonitoringAgentProcessResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeGroupMonitoringAgentProcessResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHostAvailabilityListRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the application group.
   * 
   * @example
   * 12345
   */
  groupId?: number;
  /**
   * @remarks
   * The ID of the availability monitoring task.
   * 
   * @example
   * 123456
   */
  id?: number;
  /**
   * @remarks
   * The IDs of the availability monitoring tasks. Separate multiple IDs with commas (,).
   * 
   * @example
   * 123456,345678
   */
  ids?: string;
  /**
   * @remarks
   * The page number.
   * 
   * Pages start from page 1. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * Minimum value: 1. Default value: 10
   * 
   * @example
   * 10
   */
  pageSize?: number;
  regionId?: string;
  /**
   * @remarks
   * The name of the availability monitoring task.
   * 
   * @example
   * ecs_instance
   */
  taskName?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      id: 'Id',
      ids: 'Ids',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      taskName: 'TaskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'number',
      id: 'number',
      ids: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      taskName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHostAvailabilityListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The specified resource is not found.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 4A288E86-45C3-4858-9DB0-6D85B10BD92A
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The details of the availability monitoring tasks.
   */
  taskList?: DescribeHostAvailabilityListResponseBodyTaskList;
  /**
   * @remarks
   * The total number of returned entries.
   * 
   * @example
   * 1
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
      taskList: 'TaskList',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
      taskList: DescribeHostAvailabilityListResponseBodyTaskList,
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHostAvailabilityListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeHostAvailabilityListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeHostAvailabilityListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHybridMonitorDataListRequest extends $tea.Model {
  /**
   * @remarks
   * The end of the time range to query.
   * 
   * Unit: seconds.
   * 
   * This parameter is required.
   * 
   * @example
   * 1653805225
   */
  end?: number;
  /**
   * @remarks
   * The name of the namespace.
   * 
   * For more information about how to query the names of namespaces, see [DescribeHybridMonitorNamespaceList](https://help.aliyun.com/document_detail/428880.html).
   * 
   * This parameter is required.
   * 
   * @example
   * default-aliyun
   */
  namespace?: string;
  /**
   * @remarks
   * The statistical period of the monitoring data.
   * 
   * Unit: seconds.
   * 
   * @example
   * 60
   */
  period?: string;
  /**
   * @remarks
   * The metric name.
   * 
   * >  PromQL statements are supported.
   * 
   * This parameter is required.
   * 
   * @example
   * AliyunEcs_cpu_total
   */
  promSQL?: string;
  regionId?: string;
  /**
   * @remarks
   * The start of the time range to query.
   * 
   * Unit: seconds.
   * 
   * This parameter is required.
   * 
   * @example
   * 1653804865
   */
  start?: number;
  static names(): { [key: string]: string } {
    return {
      end: 'End',
      namespace: 'Namespace',
      period: 'Period',
      promSQL: 'PromSQL',
      regionId: 'RegionId',
      start: 'Start',
    };
  }

  static types(): { [key: string]: any } {
    return {
      end: 'number',
      namespace: 'string',
      period: 'string',
      promSQL: 'string',
      regionId: 'string',
      start: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHybridMonitorDataListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response code.
   * 
   * >  The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * end timestamp must not be before start time.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * C240412F-3F5F-50E2-ACEC-DE808EF9C4BE
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: string;
  /**
   * @remarks
   * The returned monitoring data.
   */
  timeSeries?: DescribeHybridMonitorDataListResponseBodyTimeSeries[];
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
      timeSeries: 'TimeSeries',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'string',
      timeSeries: { 'type': 'array', 'itemType': DescribeHybridMonitorDataListResponseBodyTimeSeries },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHybridMonitorDataListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeHybridMonitorDataListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeHybridMonitorDataListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHybridMonitorNamespaceListRequest extends $tea.Model {
  /**
   * @remarks
   * The search keyword.
   * 
   * @example
   * aliyun
   */
  keyword?: string;
  /**
   * @remarks
   * The name of the namespace.
   * 
   * The name can contain letters, digits, and hyphens (-).
   * 
   * @example
   * aliyun-test
   */
  namespace?: string;
  /**
   * @remarks
   * The page number.
   * 
   * Page numbers start from 1. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * Page numbers start from 1. Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  regionId?: string;
  /**
   * @remarks
   * Specifies whether to return the configuration details of metric import tasks for Alibaba Cloud services and the number of metric import tasks for third-party services. Valid values:
   * 
   * *   true
   * *   false (default)
   * 
   * @example
   * false
   */
  showTaskStatistic?: boolean;
  static names(): { [key: string]: string } {
    return {
      keyword: 'Keyword',
      namespace: 'Namespace',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      showTaskStatistic: 'ShowTaskStatistic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      keyword: 'string',
      namespace: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      showTaskStatistic: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHybridMonitorNamespaceListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response code.
   * 
   * @example
   * Success
   */
  code?: string;
  /**
   * @remarks
   * The details of the namespaces.
   */
  describeHybridMonitorNamespace?: DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespace[];
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * Specified parameter PageSize is not valid.
   */
  message?: string;
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 1EC450A4-3221-5148-B77E-2827576CFE48
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: string;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 1
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      describeHybridMonitorNamespace: 'DescribeHybridMonitorNamespace',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      describeHybridMonitorNamespace: { 'type': 'array', 'itemType': DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespace },
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'string',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHybridMonitorNamespaceListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeHybridMonitorNamespaceListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeHybridMonitorNamespaceListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHybridMonitorSLSGroupRequest extends $tea.Model {
  /**
   * @remarks
   * The keyword that is used to search for Logstore groups.
   * 
   * @example
   * Logstore
   */
  keyword?: string;
  /**
   * @remarks
   * The page number.
   * 
   * Pages start from page 1. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: string;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * Minimum value: 1. Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: string;
  regionId?: string;
  /**
   * @remarks
   * The name of the Logstore group.
   * 
   * @example
   * Logstore_test
   */
  SLSGroupName?: string;
  static names(): { [key: string]: string } {
    return {
      keyword: 'Keyword',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      SLSGroupName: 'SLSGroupName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      keyword: 'string',
      pageNumber: 'string',
      pageSize: 'string',
      regionId: 'string',
      SLSGroupName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHybridMonitorSLSGroupResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * > The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The queried Logstore groups.
   */
  list?: DescribeHybridMonitorSLSGroupResponseBodyList[];
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * NotFound.SLSGroup
   */
  message?: string;
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 66683237-7126-50F8-BBF8-D67ACC919A17
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   */
  success?: string;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 2
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      list: 'List',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      list: { 'type': 'array', 'itemType': DescribeHybridMonitorSLSGroupResponseBodyList },
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'string',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHybridMonitorSLSGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeHybridMonitorSLSGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeHybridMonitorSLSGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHybridMonitorTaskListRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the application group.
   * 
   * For information about how to obtain the ID of an application group, see [DescribeMonitorGroups](https://help.aliyun.com/document_detail/115032.html).
   * 
   * @example
   * 3607****
   */
  groupId?: string;
  /**
   * @remarks
   * Specifies whether the returned result includes metric import tasks for Alibaba Cloud services. Valid values:
   * 
   * *   true (default): The returned result includes metric import tasks for Alibaba Cloud services.
   * *   false: The returned result excludes metric import tasks for Alibaba Cloud services.
   * 
   * @example
   * true
   */
  includeAliyunTask?: boolean;
  /**
   * @remarks
   * The keyword that is used for the search.
   * 
   * @example
   * task
   */
  keyword?: string;
  /**
   * @remarks
   * The name of the namespace.
   * 
   * For information about how to obtain the name of a namespace, see [DescribeHybridMonitorNamespaceList](https://help.aliyun.com/document_detail/428880.html).
   * 
   * @example
   * aliyun
   */
  namespace?: string;
  /**
   * @remarks
   * The page number.
   * 
   * Pages start from page 1. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * Pages start from page 1. Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  regionId?: string;
  /**
   * @remarks
   * The ID of the member account.
   * 
   * > This parameter is required only if you use a management account to call this operation to delete the metric import tasks that belong to a member in a resource directory. In this case, the `TaskType` parameter is set to `aliyun_fc`.
   * 
   * @example
   * 120886317861****
   */
  targetUserId?: number;
  /**
   * @remarks
   * The ID of the metric import task.
   * 
   * @example
   * 36****
   */
  taskId?: string;
  /**
   * @remarks
   * The type of the metric import task. Valid values:
   * 
   * *   aliyun_fc: metric import tasks for Alibaba Cloud services
   * *   aliyun_sls: metrics for logs imported from Log Service
   * 
   * @example
   * aliyun_fc
   */
  taskType?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      includeAliyunTask: 'IncludeAliyunTask',
      keyword: 'Keyword',
      namespace: 'Namespace',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      targetUserId: 'TargetUserId',
      taskId: 'TaskId',
      taskType: 'TaskType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      includeAliyunTask: 'boolean',
      keyword: 'string',
      namespace: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      targetUserId: 'number',
      taskId: 'string',
      taskType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHybridMonitorTaskListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code.
   * 
   * > The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * *   If the request was successful, the value `successful` is returned.
   * *   If the request failed, an error message is returned.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 11145B76-566A-5D80-A8A3-FAD98D310079
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: string;
  /**
   * @remarks
   * The metric import tasks.
   */
  taskList?: DescribeHybridMonitorTaskListResponseBodyTaskList[];
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 1
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      taskList: 'TaskList',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'string',
      taskList: { 'type': 'array', 'itemType': DescribeHybridMonitorTaskListResponseBodyTaskList },
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHybridMonitorTaskListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeHybridMonitorTaskListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeHybridMonitorTaskListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLogMonitorAttributeRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the log monitoring metric. Exact match is supported.
   * 
   * For more information, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * This parameter is required.
   * 
   * @example
   * cpu_total
   */
  metricName?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      metricName: 'MetricName',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      metricName: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLogMonitorAttributeResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the call was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The details of the log monitoring metric.
   */
  logMonitor?: DescribeLogMonitorAttributeResponseBodyLogMonitor;
  /**
   * @remarks
   * The returned message. If the call was successful, the value success is returned. If the call failed, an error message is returned.
   * 
   * @example
   * successful
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * C6718537-E673-4A58-8EE1-24B8B38C7AAE
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call was successful. Valid values:
   * 
   * *   true: The call was successful.
   * *   false: The call failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      logMonitor: 'LogMonitor',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      logMonitor: DescribeLogMonitorAttributeResponseBodyLogMonitor,
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLogMonitorAttributeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeLogMonitorAttributeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLogMonitorAttributeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLogMonitorListRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the application group.
   * 
   * @example
   * 123456
   */
  groupId?: number;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Default value: 10
   * 
   * @example
   * 10
   */
  pageSize?: number;
  regionId?: string;
  /**
   * @remarks
   * The keyword that is used to search for log monitoring metrics. Fuzzy match is supported.
   * 
   * @example
   * test
   */
  searchValue?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      searchValue: 'SearchValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      searchValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLogMonitorListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the call was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The log monitoring metrics.
   */
  logMonitorList?: DescribeLogMonitorListResponseBodyLogMonitorList[];
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * successful
   */
  message?: string;
  /**
   * @remarks
   * The number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned on each page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 01E90080-4300-4FAA-B9AE-161956BC350D
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call was successful. Valid values:
   * 
   * *   true: The call was successful.
   * *   false: The call failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The total number of the returned entries.
   * 
   * @example
   * 15
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      logMonitorList: 'LogMonitorList',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      logMonitorList: { 'type': 'array', 'itemType': DescribeLogMonitorListResponseBodyLogMonitorList },
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLogMonitorListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeLogMonitorListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLogMonitorListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricDataRequest extends $tea.Model {
  /**
   * @remarks
   * The dimensions based on which the resources are queried.
   * 
   * Set the value to a collection of key-value pairs. A typical key-value pair is `instanceId:i-2ze2d6j5uhg20x47****`.
   * 
   * >  You can query a maximum of 50 instances in a single request.
   * 
   * @example
   * [{"instanceId": "i-abcdefgh12****"}]
   */
  dimensions?: string;
  /**
   * @remarks
   * The end of the time range to query monitoring data.
   * 
   * *   If the `StartTime` and `EndTime` parameters are not specified, the monitoring data of the last statistical period is queried.``
   * 
   * *   If the `StartTime` and `EndTime` parameters are specified, the monitoring data of the last statistical period in the specified time range is queried.```` The following examples demonstrate how to determine the period in which monitoring data is queried:
   * 
   *     *   If you set the `Period` parameter to 15, the specified time range must be less than or equal to 20 minutes. For example, if you set the StartTime parameter to 2021-05-08 08:10:00 and the EndTime parameter to 2021-05-08 08:30:00, the monitoring data of the last 15 seconds in the time range is queried.
   *     *   If you set the `Period` to 60 or 900, the specified time range must be less than or equal to 2 hours. For example, if you set the Period parameter to 60, the StartTime parameter to 2021-05-08 08:00:00, and the EndTime parameter to 2021-05-08 10:00:00, the monitoring data of the last 60 seconds in the time range is queried.
   *     *   If you set the `Period` parameter to 3600, the specified time range must be less than or equal to 2 days. For example, if you set the StartTime parameter to 2021-05-08 08:00:00 and the EndTime parameter to 2021-05-10 08:00:00, the monitoring data of the last 3,600 seconds in the time range is queried.
   * 
   * The following formats are supported:
   * 
   * *   UNIX timestamp: the number of milliseconds that have elapsed since 00:00:00 UTC on Thursday, January 1, 1970.
   * *   UTC time: the UTC time that follows the YYYY-MM-DDThh:mm:ssZ format.
   * 
   * >  We recommend that you use UNIX timestamps to prevent time zone-related issues.
   * 
   * @example
   * 1618368960000
   */
  endTime?: string;
  /**
   * @remarks
   * The expression that is used to compute the query results in real time.
   * 
   * >  Only the `groupby` expression is supported. This expression is similar to the `GROUP BY` statement that is used in databases.
   * 
   * @example
   * {"groupby":["userId","instanceId"]}
   */
  express?: string;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * Default value: 1000.
   * 
   * >  The maximum value of the Length parameter in a request is 1440.
   * 
   * @example
   * 1000
   */
  length?: string;
  /**
   * @remarks
   * The metric that is used to monitor the cloud service.
   * 
   * For more information about the metrics of cloud services, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * This parameter is required.
   * 
   * @example
   * cpu_idle
   */
  metricName?: string;
  /**
   * @remarks
   * The namespace of the cloud service.
   * 
   * For more information about the namespaces of cloud services, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * This parameter is required.
   * 
   * @example
   * acs_ecs_dashboard
   */
  namespace?: string;
  /**
   * @remarks
   * The statistical period of the metric.
   * 
   * Valid values: 15, 60, 900, and 3600.
   * 
   * Unit: seconds.
   * 
   * > 
   * 
   * *   If this parameter is not specified, monitoring data is queried based on the period in which metric values are reported.
   * 
   * *   For more information about the statistical period of a metric that is specified by the `MetricName` parameter, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * @example
   * 60
   */
  period?: string;
  regionId?: string;
  /**
   * @remarks
   * The start of the time range to query monitoring data.
   * 
   * *   If the `StartTime` and `EndTime` parameters are not specified, the monitoring data of the last statistical period is queried.``
   * 
   * *   If the `StartTime` and `EndTime` parameters are specified, the monitoring data of the last statistical period in the specified time range is queried.```` The following examples demonstrate how to determine the period in which monitoring data is queried:
   * 
   *     *   If you set the `Period` parameter to 15, the specified time range must be less than or equal to 20 minutes. For example, if you set the StartTime parameter to 2021-05-08 08:10:00 and the EndTime parameter to 2021-05-08 08:30:00, the monitoring data of the last 15 seconds in the time range is queried.
   *     *   If you set the `Period` to 60 or 900, the specified time range must be less than or equal to 2 hours. For example, if you set the Period parameter to 60, the StartTime parameter to 2021-05-08 08:00:00, and the EndTime parameter to 2021-05-08 10:00:00, the monitoring data of the last 60 seconds in the time range is queried.
   *     *   If you set the `Period` parameter to 3600, the specified time range must be less than or equal to 2 days. For example, if you set the StartTime parameter to 2021-05-08 08:00:00 and the EndTime parameter to 2021-05-10 08:00:00, the monitoring data of the last 3,600 seconds in the time range is queried.
   * 
   * The following formats are supported:
   * 
   * *   UNIX timestamp: the number of milliseconds that have elapsed since 00:00:00 UTC on Thursday, January 1, 1970.
   * *   UTC time: the UTC time that follows the YYYY-MM-DDThh:mm:ssZ format.
   * 
   * > 
   * 
   * *   You must set the `StartTime` parameter to a point in time that is later than 00:00:00 UTC on Thursday, January 1, 1970. Otherwise, this parameter is invalid.
   * 
   * *   We recommend that you use UNIX timestamps to prevent time zone-related issues.
   * 
   * @example
   * 1618368900000
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      dimensions: 'Dimensions',
      endTime: 'EndTime',
      express: 'Express',
      length: 'Length',
      metricName: 'MetricName',
      namespace: 'Namespace',
      period: 'Period',
      regionId: 'RegionId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dimensions: 'string',
      endTime: 'string',
      express: 'string',
      length: 'string',
      metricName: 'string',
      namespace: 'string',
      period: 'string',
      regionId: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricDataResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The monitoring data. The value includes the following fields:
   * 
   * *   `timestamp`: the time when the alert was triggered.
   * *   `userId`: the ID of the user for which the alert was triggered.
   * *   `instanceId`: the ID of the instance for which the alert was triggered.
   * *   `Minimum`, `Average`, and `Maximum`: the aggregation methods.
   * 
   * @example
   * [{\\"timestamp\\":1618368900000,\\"Average\\":95.8291666666667,\\"Minimum\\":65.48,\\"Maximum\\":100.0},{\\"timestamp\\":1618368960000,\\"Average\\":95.8683333333333,\\"Minimum\\":67.84,\\"Maximum\\":100.0}]
   */
  datapoints?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * The specified resource is not found.
   */
  message?: string;
  /**
   * @remarks
   * The statistical period of the monitoring data.
   * 
   * Valid values: 15, 60, 900, and 3600.
   * 
   * Unit: seconds.
   * 
   * @example
   * 60
   */
  period?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 6A5F022D-AC7C-460E-94AE-B9E75083D027
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      datapoints: 'Datapoints',
      message: 'Message',
      period: 'Period',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      datapoints: 'string',
      message: 'string',
      period: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricDataResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeMetricDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeMetricDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricLastRequest extends $tea.Model {
  /**
   * @remarks
   * The monitoring dimensions of the specified resource.
   * 
   * Set the value to a collection of `key:value` pairs. Example: `{"userId":"120886317861****"}` or `{"instanceId":"i-2ze2d6j5uhg20x47****"}`.
   * 
   * >  You can query a maximum of 50 instances in each request.
   * 
   * @example
   * [{"instanceId":"i-abcdefgh12****"}]
   */
  dimensions?: string;
  /**
   * @remarks
   * The end of the time range to query monitoring data.
   * 
   * *   For second-level data, the start time is obtained by comparing the time that is specified by the StartTime parameter and 20 minutes earlier of the time that is specified by the EndTime parameter. The earlier one of the compared points in time is used as the start time.
   * *   For minute-level data, the start time is obtained by comparing the time that is specified by the StartTime parameter and 2 hours earlier of the time that is specified by the EndTime parameter. The earlier one of the compared points in time is used as the start time.
   * *   For hour-level data, the start time is obtained by comparing the time that is specified by the StartTime parameter and two days earlier of the time that is specified by the EndTime parameter. The earlier one of the compared points in time is used as the start time.
   * 
   * @example
   * 2019-01-31 10:10:00
   */
  endTime?: string;
  /**
   * @remarks
   * The expression that is used to calculate the query results in real time.
   * 
   * @example
   * {"groupby":["userId","instanceId"]}
   */
  express?: string;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * Default value: 1000. This value indicates that a maximum of 1,000 entries of monitoring data can be returned on each page.
   * 
   * >  The maximum value of the Length parameter for each request is 1440.
   * 
   * @example
   * 1000
   */
  length?: string;
  /**
   * @remarks
   * The metric that is used to monitor the cloud service.
   * 
   * For more information about metric names, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * This parameter is required.
   * 
   * @example
   * CPUUtilization
   */
  metricName?: string;
  /**
   * @remarks
   * The namespace of the cloud service.
   * 
   * For more information about the namespaces of cloud services, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * This parameter is required.
   * 
   * @example
   * acs_ecs_dashboard
   */
  namespace?: string;
  /**
   * @remarks
   * The pagination token.
   * 
   * *   If the number of results exceeds the maximum number of entries allowed on a single page, a pagination token is returned.
   * *   This token can be used as an input parameter to obtain the next page of results. If all results are obtained, no token is returned.
   * 
   * @example
   * 15761432850009dd70bb64cff1f0fff6c0b08ffff073be5fb1e785e2b020f7fed9b5e137bd810a6d6cff5ae****
   */
  nextToken?: string;
  /**
   * @remarks
   * The statistical period of the monitoring data.
   * 
   * Valid values: 15, 60, 900, and 3600.
   * 
   * Unit: seconds.
   * 
   * > 
   * 
   * *   If this parameter is not specified, monitoring data is queried based on the period in which metric values are reported. The statistical period of metrics (`MetricName`) varies for each cloud service. The statistical period of metrics is displayed in the `MinPeriods` column on the **Metrics** page for each cloud service. For more information, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * @example
   * 60
   */
  period?: string;
  regionId?: string;
  /**
   * @remarks
   * The start of the time range to query monitoring data.
   * 
   * @example
   * 2019-01-31 10:00:00
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      dimensions: 'Dimensions',
      endTime: 'EndTime',
      express: 'Express',
      length: 'Length',
      metricName: 'MetricName',
      namespace: 'Namespace',
      nextToken: 'NextToken',
      period: 'Period',
      regionId: 'RegionId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dimensions: 'string',
      endTime: 'string',
      express: 'string',
      length: 'string',
      metricName: 'string',
      namespace: 'string',
      nextToken: 'string',
      period: 'string',
      regionId: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricLastResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The monitoring data.
   * 
   * @example
   * [{"timestamp":1548777660000,"userId":"123456789876****","instanceId":"i-abcdefgh12****","Minimum":93.1,"Average":99.52,"Maximum":100}]
   */
  datapoints?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The specified resource is not found.
   */
  message?: string;
  /**
   * @remarks
   * The pagination token.
   * 
   * @example
   * xxxxxx
   */
  nextToken?: string;
  /**
   * @remarks
   * The time interval.
   * 
   * Unit: seconds.
   * 
   * @example
   * 60
   */
  period?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 021472A6-25E3-4094-8D00-BA4B6A5486C3
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      datapoints: 'Datapoints',
      message: 'Message',
      nextToken: 'NextToken',
      period: 'Period',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      datapoints: 'string',
      message: 'string',
      nextToken: 'string',
      period: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricLastResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeMetricLastResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeMetricLastResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricListRequest extends $tea.Model {
  /**
   * @remarks
   * The dimensions that specify the resources whose monitoring data you want to query.
   * 
   * Set the value to a collection of key-value pairs. A typical key-value pair is `instanceId:i-2ze2d6j5uhg20x47****`.
   * 
   * >  You can query a maximum of 50 instances in a single request.
   * 
   * @example
   * [{"instanceId": "i-abcdefgh12****"}]
   */
  dimensions?: string;
  /**
   * @remarks
   * The end of the time range to query. The following formats are supported:
   * 
   * *   UNIX timestamp: the number of milliseconds that have elapsed since 00:00:00 Thursday, January 1, 1970
   * *   UTC time: the UTC time that follows the YYYY-MM-DDThh:mm:ssZ format
   * 
   * @example
   * 2019-01-30 00:10:00
   */
  endTime?: string;
  /**
   * @remarks
   * The expression that is used to compute the query results in real time.
   * 
   * >  Only the groupby expression is supported. This expression is similar to the GROUP BY statement that is used in databases.
   * 
   * @example
   * {"groupby":["userId","instanceId"]}
   */
  express?: string;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * >  The maximum value of the Length parameter in a request is 1440.
   * 
   * @example
   * 1000
   */
  length?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * For more information about metric names, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * This parameter is required.
   * 
   * @example
   * cpu_idle
   */
  metricName?: string;
  /**
   * @remarks
   * The namespace of the cloud service. Format: acs_service name.
   * 
   * For more information about the namespaces of cloud services, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * This parameter is required.
   * 
   * @example
   * acs_ecs_dashboard
   */
  namespace?: string;
  /**
   * @remarks
   * The paging token.
   * 
   * >  If this parameter is not specified, the data on the first page is returned. A return value other than Null of this parameter indicates that not all entries have been returned. You can use this value as an input parameter to obtain entries on the next page. The value Null indicates that all query results have been returned.
   * 
   * @example
   * 15761485350009dd70bb64cff1f0fff750b08ffff073be5fb1e785e2b020f1a949d5ea14aea7fed82f01dd8****
   */
  nextToken?: string;
  /**
   * @remarks
   * The interval at which the monitoring data is queried.
   * 
   * Valid values: 60, 300, and 900.
   * 
   * Unit: seconds.
   * 
   * >  Configure this parameter based on your business scenario.
   * 
   * @example
   * 60
   */
  period?: string;
  regionId?: string;
  /**
   * @remarks
   * The beginning of the time range to query. The following formats are supported:
   * 
   * *   UNIX timestamp: the number of milliseconds that have elapsed since 00:00:00 Thursday, January 1, 1970
   * *   UTC time: the UTC time that follows the YYYY-MM-DDThh:mm:ssZ format
   * 
   * >  The specified period includes the end time and excludes the start time. The start time must be earlier than the end time.
   * 
   * @example
   * 2019-01-30 00:00:00
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      dimensions: 'Dimensions',
      endTime: 'EndTime',
      express: 'Express',
      length: 'Length',
      metricName: 'MetricName',
      namespace: 'Namespace',
      nextToken: 'NextToken',
      period: 'Period',
      regionId: 'RegionId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dimensions: 'string',
      endTime: 'string',
      express: 'string',
      length: 'string',
      metricName: 'string',
      namespace: 'string',
      nextToken: 'string',
      period: 'string',
      regionId: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the call was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The monitoring data.
   * 
   * @example
   * [{"timestamp":1548777660000,"userId":"120886317861****","instanceId":"i-abc","Minimum":9.92,"Average":9.92,"Maximum":9.92}]
   */
  datapoints?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The specified resource is not found.
   */
  message?: string;
  /**
   * @remarks
   * The paging token.
   * 
   * @example
   * 15761441850009dd70bb64cff1f0fff6d0b08ffff073be5fb1e785e2b020f7fed9b5e137bd810a6d6cff5ae****
   */
  nextToken?: string;
  /**
   * @remarks
   * The interval at which the monitoring data is queried. Unit: seconds. Valid values: 60, 300, and 900.
   * 
   * @example
   * 60
   */
  period?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 3121AE7D-4AFF-4C25-8F1D-C8226EBB1F42
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call was successful. Valid values:
   * 
   * *   true: The call was successful.
   * *   false: The call failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      datapoints: 'Datapoints',
      message: 'Message',
      nextToken: 'NextToken',
      period: 'Period',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      datapoints: 'string',
      message: 'string',
      nextToken: 'string',
      period: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeMetricListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeMetricListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricMetaListRequest extends $tea.Model {
  /**
   * @remarks
   * The tags for filtering metrics. Specify a JSON string.
   * 
   * Format: ` [{"name":"tag key","value":"tag value"},{"name":"tag key","value":"tag value"}]  `. The following tags are available:
   * 
   * *   metricCategory: the category of the metric.
   * *   alertEnable: specifies whether to report alerts for the metric.
   * *   alertUnit: the unit of the metric in the alerts.
   * *   unitFactor: the factor for metric unit conversion.
   * *   minAlertPeriod: the minimum interval at which the alert is reported.
   * *   productCategory: the category of the service.
   * 
   * @example
   * [{"name":"productCategory","value":"kvstore_old"}]
   */
  labels?: string;
  /**
   * @remarks
   * The metric name. For more information, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * @example
   * CPUUtilization
   */
  metricName?: string;
  /**
   * @remarks
   * The namespace of the cloud service.
   * 
   * For more information about the namespaces of cloud services, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * @example
   * acs_kvstore
   */
  namespace?: string;
  /**
   * @remarks
   * The page number. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 30.
   * 
   * @example
   * 30
   */
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      labels: 'Labels',
      metricName: 'MetricName',
      namespace: 'Namespace',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      labels: 'string',
      metricName: 'string',
      namespace: 'string',
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricMetaListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response code.
   * 
   * >  The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * The Request is not authorization.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0CCE0AF0-053C-4B13-A583-DC9A85785D49
   */
  requestId?: string;
  /**
   * @remarks
   * The configuration of the metrics in the resources.
   */
  resources?: DescribeMetricMetaListResponseBodyResources;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 12
   */
  totalCount?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      resources: 'Resources',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      resources: DescribeMetricMetaListResponseBodyResources,
      success: 'boolean',
      totalCount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricMetaListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeMetricMetaListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeMetricMetaListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricRuleBlackListRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the blacklist policy.
   * 
   * @example
   * ecs
   */
  category?: string;
  ids?: string[];
  /**
   * @remarks
   * The IDs of the instances in the blacklist policy.
   * 
   * Valid values of N: 0 to 10.
   */
  instanceIds?: string[];
  /**
   * @remarks
   * The status of the blacklist policy. Valid values:
   * 
   * *   true: The blacklist policy is enabled.
   * *   false: The blacklist policy is disabled.
   * 
   * @example
   * true
   */
  isEnable?: boolean;
  /**
   * @remarks
   * The name of the blacklist policy.
   * 
   * This parameter supports fuzzy match.
   * 
   * @example
   * Blacklist-01
   */
  name?: string;
  /**
   * @remarks
   * The timestamp when the blacklist policy expired.
   * 
   * Unit: milliseconds.
   * 
   * @example
   * acs_ecs_dashboard
   */
  namespace?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the call was successful.
   * 
   * @example
   * DESC
   */
  order?: number;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The categories of the Alibaba Cloud service. For example, ApsaraDB for Redis includes the following categories: ApsaraDB for Redis (standard architecture), ApsaraDB for Redis (cluster architecture), and ApsaraDB for Redis (read/write splitting architecture). In this case, the valid values of this parameter for ApsaraDB for Redis include `kvstore_standard`, `kvstore_sharding`, and `kvstore_splitrw`.
   * 
   * @example
   * 100
   */
  pageSize?: number;
  regionId?: string;
  /**
   * @remarks
   * The effective scope of the blacklist policy. Valid values:
   * 
   * *   USER: The blacklist policy takes effect only within the current Alibaba Cloud account.
   * *   GROUP: The blacklist policy takes effect only within the specified application group.
   * 
   * @example
   * USER
   */
  scopeType?: string;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      ids: 'Ids',
      instanceIds: 'InstanceIds',
      isEnable: 'IsEnable',
      name: 'Name',
      namespace: 'Namespace',
      order: 'Order',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      scopeType: 'ScopeType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      ids: { 'type': 'array', 'itemType': 'string' },
      instanceIds: { 'type': 'array', 'itemType': 'string' },
      isEnable: 'boolean',
      name: 'string',
      namespace: 'string',
      order: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      scopeType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricRuleBlackListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The categories of the Alibaba Cloud service. For example, ApsaraDB for Redis includes the following categories: ApsaraDB for Redis (standard architecture), ApsaraDB for Redis (cluster architecture), and ApsaraDB for Redis (read/write splitting architecture). In this case, the valid values of this parameter for ApsaraDB for Redis include `kvstore_standard`, `kvstore_sharding`, and `kvstore_splitrw`.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The queried blacklist policies.
   */
  describeMetricRuleBlackList?: DescribeMetricRuleBlackListResponseBodyDescribeMetricRuleBlackList[];
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The Request is not authorization.
   */
  message?: string;
  /**
   * @remarks
   * The namespace of the cloud service.
   * 
   * @example
   * D63E76CB-29AA-5B9F-88CE-400A6F28D428
   */
  requestId?: string;
  /**
   * @remarks
   * The namespace of the cloud service.
   * 
   * For more information about the namespaces of different cloud services, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The timestamp when the blacklist policy was created.
   * 
   * Unit: milliseconds.
   * 
   * @example
   * 1
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      describeMetricRuleBlackList: 'DescribeMetricRuleBlackList',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      describeMetricRuleBlackList: { 'type': 'array', 'itemType': DescribeMetricRuleBlackListResponseBodyDescribeMetricRuleBlackList },
      message: 'string',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricRuleBlackListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeMetricRuleBlackListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeMetricRuleBlackListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricRuleCountRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the metric. For more information, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * @example
   * cpu_total
   */
  metricName?: string;
  /**
   * @remarks
   * The namespace of the service. For more information, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * @example
   * acs_ecs_dashboard
   */
  namespace?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      metricName: 'MetricName',
      namespace: 'Namespace',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      metricName: 'string',
      namespace: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricRuleCountResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the call was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * The Request is not authorization.
   */
  message?: string;
  /**
   * @remarks
   * The number of alert rules in each state.
   */
  metricRuleCount?: DescribeMetricRuleCountResponseBodyMetricRuleCount;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * FF38D33A-67C1-40EB-AB65-FAEE51EDB644
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call was successful. Valid values:
   * 
   * *   true: The call was successful.
   * *   false: The call failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      metricRuleCount: 'MetricRuleCount',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      metricRuleCount: DescribeMetricRuleCountResponseBodyMetricRuleCount,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricRuleCountResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeMetricRuleCountResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeMetricRuleCountResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricRuleListRequest extends $tea.Model {
  /**
   * @remarks
   * The status of the alert rule. Valid values:
   * 
   * *   OK: The alert rule has no active alerts.
   * *   ALARM: The alert rule has active alerts.
   * *   INSUFFICIENT_DATA: No data is available.
   * 
   * @example
   * OK
   */
  alertState?: string;
  /**
   * @remarks
   * The monitoring dimensions of the specified resource.
   * 
   * Set the value to a collection of `key:value` pairs. Example: `{"userId":"120886317861****"}` or `{"instanceId":"i-2ze2d6j5uhg20x47****"}`.
   * 
   * @example
   * {"instanceId":"i-2ze2d6j5uhg20x47****"}
   */
  dimensions?: string;
  /**
   * @remarks
   * Specifies whether to query enabled or disabled alert rules. Valid values:
   * 
   * *   true: queries enabled alert rules.
   * *   false: queries disabled alert rules.
   * 
   * @example
   * true
   */
  enableState?: boolean;
  /**
   * @remarks
   * The ID of the application group.
   * 
   * For information about how to obtain the ID of an application group, see [DescribeMonitorGroups](https://help.aliyun.com/document_detail/115032.html).
   * 
   * @example
   * 7301****
   */
  groupId?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * For information about how to obtain the name of a metric, see [DescribeMetricMetaList](https://help.aliyun.com/document_detail/98846.html) or [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * @example
   * cpu_total
   */
  metricName?: string;
  /**
   * @remarks
   * The namespace of the cloud service.
   * 
   * For information about how to obtain the namespace of a cloud service, see [DescribeMetricMetaList](https://help.aliyun.com/document_detail/98846.html) or [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * @example
   * acs_ecs_dashboard
   */
  namespace?: string;
  /**
   * @remarks
   * The page number of the page to return.
   * 
   * Minimum value: 1. Default value: 1.
   * 
   * @example
   * 1
   */
  page?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * Minimum value: 1. Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  regionId?: string;
  /**
   * @remarks
   * The ID of the alert rule. You can specify up to 20 IDs at a time. Separate multiple IDs with commas (,).
   * 
   * @example
   * applyTemplate344cfd42-0f32-4fd6-805a-88d7908a****
   */
  ruleIds?: string;
  /**
   * @remarks
   * The name of the alert rule.
   * 
   * This parameter supports fuzzy match.
   * 
   * @example
   * Rule_01
   */
  ruleName?: string;
  static names(): { [key: string]: string } {
    return {
      alertState: 'AlertState',
      dimensions: 'Dimensions',
      enableState: 'EnableState',
      groupId: 'GroupId',
      metricName: 'MetricName',
      namespace: 'Namespace',
      page: 'Page',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      ruleIds: 'RuleIds',
      ruleName: 'RuleName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertState: 'string',
      dimensions: 'string',
      enableState: 'boolean',
      groupId: 'string',
      metricName: 'string',
      namespace: 'string',
      page: 'number',
      pageSize: 'number',
      regionId: 'string',
      ruleIds: 'string',
      ruleName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricRuleListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the alert rules.
   */
  alarms?: DescribeMetricRuleListResponseBodyAlarms;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the call is successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The specified resource is not found.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 386C6712-335F-5054-930A-CC92B851ECBA
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call is successful. Valid values:
   * 
   * *   true: The call is successful.
   * *   false: The call fails.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The total number of returned entries.
   * 
   * @example
   * 1
   */
  total?: string;
  static names(): { [key: string]: string } {
    return {
      alarms: 'Alarms',
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alarms: DescribeMetricRuleListResponseBodyAlarms,
      code: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
      total: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricRuleListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeMetricRuleListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeMetricRuleListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricRuleTargetsRequest extends $tea.Model {
  regionId?: string;
  /**
   * @remarks
   * The ID of the alert rule.
   * 
   * For information about how to obtain the ID of an alert rule, see [DescribeMetricRuleList](https://help.aliyun.com/document_detail/114941.html).
   * 
   * This parameter is required.
   * 
   * @example
   * ae06917_75a8c43178ab66****
   */
  ruleId?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      ruleId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricRuleTargetsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the call was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * User not authorized to operate on the specified resource.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 786E92D2-AC66-4250-B76F-F1E2FCDDBA1C
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call was successful. Valid values:
   * 
   * *   true: The call was successful.
   * *   false: The call failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The information about the resource for which alerts are triggered.
   */
  targets?: DescribeMetricRuleTargetsResponseBodyTargets;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
      targets: 'Targets',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
      targets: DescribeMetricRuleTargetsResponseBodyTargets,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricRuleTargetsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeMetricRuleTargetsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeMetricRuleTargetsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricRuleTemplateAttributeRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the alert template. You must specify at least one of the `Name` and `TemplateId` parameters.
   * 
   * For information about how to obtain the name of an alert template, see [DescribeMetricRuleTemplateList](https://help.aliyun.com/document_detail/114982.html).
   * 
   * @example
   * ECS_Template1
   */
  name?: string;
  regionId?: string;
  /**
   * @remarks
   * The ID of the alert template. You must specify at least one of the `Name` and `TemplateId` parameters.
   * 
   * For information about how to obtain the ID of an alert template, see [DescribeMetricRuleTemplateList](https://help.aliyun.com/document_detail/114982.html).
   * 
   * @example
   * 70****
   */
  templateId?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      regionId: 'RegionId',
      templateId: 'TemplateId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      regionId: 'string',
      templateId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricRuleTemplateAttributeResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * The specified resource is not found.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 8F3A82AD-DA92-52B0-8EC6-C059D1C3839F
   */
  requestId?: string;
  /**
   * @remarks
   * The details of the alert template.
   */
  resource?: DescribeMetricRuleTemplateAttributeResponseBodyResource;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      resource: 'Resource',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      message: 'string',
      requestId: 'string',
      resource: DescribeMetricRuleTemplateAttributeResponseBodyResource,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricRuleTemplateAttributeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeMetricRuleTemplateAttributeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeMetricRuleTemplateAttributeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricRuleTemplateListRequest extends $tea.Model {
  /**
   * @remarks
   * Specifies whether to display the history of applying the alert templates to application groups. Valid values:
   * 
   * *   true
   * *   false (default)
   * 
   * @example
   * false
   */
  history?: boolean;
  /**
   * @remarks
   * The keyword of the alert template name.
   * 
   * @example
   * ECS
   */
  keyword?: string;
  /**
   * @remarks
   * The name of the alert template.
   * 
   * @example
   * ECS_Template1
   */
  name?: string;
  /**
   * @remarks
   * The sorting order. Valid values:
   * 
   * *   true (default): ascending order
   * *   false: descending order
   * 
   * @example
   * true
   */
  order?: boolean;
  /**
   * @remarks
   * The sorting basis. Valid values:
   * 
   * *   gmtMotified: sorts alert templates by modification time
   * *   gmtCreate (default): sorts alert templates by creation time
   * 
   * @example
   * gmtCreate
   */
  orderBy?: string;
  /**
   * @remarks
   * The page number.
   * 
   * Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  regionId?: string;
  /**
   * @remarks
   * The ID of the alert template.
   * 
   * @example
   * 70****
   */
  templateId?: number;
  static names(): { [key: string]: string } {
    return {
      history: 'History',
      keyword: 'Keyword',
      name: 'Name',
      order: 'Order',
      orderBy: 'OrderBy',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      templateId: 'TemplateId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      history: 'boolean',
      keyword: 'string',
      name: 'string',
      order: 'boolean',
      orderBy: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      templateId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricRuleTemplateListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code.
   * 
   * > The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The Request is not authorization.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 659401C0-6214-5C02-972A-CFA929D717B7
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The queried alert templates.
   */
  templates?: DescribeMetricRuleTemplateListResponseBodyTemplates;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 2
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
      templates: 'Templates',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
      templates: DescribeMetricRuleTemplateListResponseBodyTemplates,
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricRuleTemplateListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeMetricRuleTemplateListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeMetricRuleTemplateListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricTopRequest extends $tea.Model {
  /**
   * @remarks
   * The monitoring dimensions of the specified resource.
   * 
   * Set the value to a collection of `key:value` pairs. Example: `{"userId":"120886317861****"}` or `{"instanceId":"i-2ze2d6j5uhg20x47****"}`.
   * 
   * >  You can query a maximum of 50 instances in each request.
   * 
   * @example
   * [{"instanceId": "i-abcdefgh12****"}]
   */
  dimensions?: string;
  /**
   * @remarks
   * The end of the time range to query monitoring data.
   * 
   * *   If the `StartTime` and `EndTime` parameters are not specified, the monitoring data of the last statistical period is queried.``
   * 
   * *   If the `StartTime` and `EndTime` parameters are specified, the monitoring data of the last statistical period in the specified time range is queried.````
   * 
   *     *   If you set the `Period` parameter to 15, the specified time range must be less than or equal to 20 minutes. For example, if you set the StartTime parameter to 2021-05-08 08:10:00 and the EndTime parameter to 2021-05-08 08:30:00, the monitoring data of the last 15 seconds in the time range is queried.
   *     *   If you set the `Period` parameter to 60 or 900, the specified time range must be less than or equal to 2 hours. For example, if you set the Period parameter to 60, the StartTime parameter to 2021-05-08 08:00:00, and the EndTime parameter to 2021-05-08 10:00:00, the monitoring data of the last 60 seconds in the time range is queried.
   *     *   If you set the `Period` parameter to 3600, the specified time range must be less than or equal to two days. For example, if you set the StartTime parameter to 2021-05-08 08:00:00 and the EndTime parameter to 2021-05-10 08:00:00, the monitoring data of the last 3,600 seconds in the time range is queried.
   * 
   * The following formats are supported:
   * 
   * *   UNIX timestamp: the number of milliseconds that have elapsed since 00:00:00 Thursday, January 1, 1970
   * *   Time format: YYYY-MM-DDThh:mm:ssZ
   * 
   * >  We recommend that you use UNIX timestamps to prevent time zone-related issues.
   * 
   * @example
   * 2021-05-08 10:00:00
   */
  endTime?: string;
  /**
   * @remarks
   * The expression that is used to compute the query results in real time.
   * 
   * >  Only the `groupby` expression is supported. This expression is similar to the GROUP BY statement used in databases.
   * 
   * @example
   * {"groupby":["userId","instanceId"]}
   */
  express?: string;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * Default value: 10.
   * 
   * >  The maximum value of the Length parameter in a request is 1440.
   * 
   * @example
   * 10
   */
  length?: string;
  /**
   * @remarks
   * The metric that is used to monitor the cloud service.
   * 
   * For more information about metric names, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * This parameter is required.
   * 
   * @example
   * cpu_idle
   */
  metricName?: string;
  /**
   * @remarks
   * The namespace of the cloud service.
   * 
   * For more information about the namespaces of cloud services, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * This parameter is required.
   * 
   * @example
   * acs_ecs_dashboard
   */
  namespace?: string;
  /**
   * @remarks
   * The order in which data is sorted. Valid values:
   * 
   * *   True: sorts data in ascending order.
   * *   False (default): sorts data in descending order.
   * 
   * @example
   * False
   */
  orderDesc?: string;
  /**
   * @remarks
   * The field based on which data is sorted. Valid values:
   * 
   * *   Average
   * *   Minimum
   * *   Maximum
   * 
   * This parameter is required.
   * 
   * @example
   * Average
   */
  orderby?: string;
  /**
   * @remarks
   * The statistical period of the monitoring data.
   * 
   * Valid values: 15, 60, 900, and 3600.
   * 
   * Unit: seconds.
   * 
   * > 
   * 
   * *   If this parameter is not specified, monitoring data is queried based on the period in which metric values are reported.
   * 
   * *   Statistical periods vary based on the metrics that are specified by `MetricName`. For more information, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * @example
   * 60
   */
  period?: string;
  regionId?: string;
  /**
   * @remarks
   * The start of the time range to query monitoring data.
   * 
   * *   If the `StartTime` and `EndTime` parameters are not specified, the monitoring data of the last statistical period is queried.``
   * 
   * *   If the `StartTime` and `EndTime` parameters are specified, the monitoring data of the last statistical period in the specified time range is queried.````
   * 
   *     *   If you set the `Period` parameter to 15, the specified time range must be less than or equal to 20 minutes. For example, if you set the StartTime parameter to 2021-05-08 08:10:00 and the EndTime parameter to 2021-05-08 08:30:00, the monitoring data of the last 15 seconds in the time range is queried.
   *     *   If you set the `Period` parameter to 60 or 900, the specified time range must be less than or equal to 2 hours. For example, if you set the Period parameter to 60, the StartTime parameter to 2021-05-08 08:00:00, and the EndTime parameter to 2021-05-08 10:00:00, the monitoring data of the last 60 seconds in the time range is queried.
   *     *   If you set the `Period` parameter to 3600, the specified time range must be less than or equal to two days. For example, if you set the StartTime parameter to 2021-05-08 08:00:00 and the EndTime parameter to 2021-05-10 08:00:00, the monitoring data of the last 3,600 seconds in the time range is queried.
   * 
   * The following formats are supported:
   * 
   * *   UNIX timestamp: the number of milliseconds that have elapsed since 00:00:00 Thursday, January 1, 1970
   * *   Time format: YYYY-MM-DDThh:mm:ssZ
   * 
   * > 
   * 
   * *   You must set the `StartTime` parameter to a point in time that is later than 00:00:00 Thursday, January 1, 1970. Otherwise, this parameter is invalid.
   * 
   * *   We recommend that you use UNIX timestamps to prevent time zone-related issues.
   * 
   * @example
   * 2021-05-08 08:00:00
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      dimensions: 'Dimensions',
      endTime: 'EndTime',
      express: 'Express',
      length: 'Length',
      metricName: 'MetricName',
      namespace: 'Namespace',
      orderDesc: 'OrderDesc',
      orderby: 'Orderby',
      period: 'Period',
      regionId: 'RegionId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dimensions: 'string',
      endTime: 'string',
      express: 'string',
      length: 'string',
      metricName: 'string',
      namespace: 'string',
      orderDesc: 'string',
      orderby: 'string',
      period: 'string',
      regionId: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricTopResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The monitoring data.
   * 
   * @example
   * [{\\"order\\":1,\\"timestamp\\":1620287520000,\\"userId\\":\\"120886317861****\\",\\"instanceId\\":\\"i-j6ccf7d5fn335qpo****\\",\\"Average\\":99.92,\\"Minimum\\":99.5,\\"Maximum\\":100.0,\\"_count\\":1.0},{\\"order\\":2,\\"timestamp\\":1620287520000,\\"userId\\":\\"120886317861****\\",\\"instanceId\\":\\"i-0xii2bvf42iqvxbp****\\",\\"Average\\":99.91,\\"Minimum\\":99.0,\\"Maximum\\":100.0,\\"_count\\":1.0}]
   */
  datapoints?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The specified resource is not found.
   */
  message?: string;
  /**
   * @remarks
   * The statistical period of the monitoring data. Unit: seconds. Valid values: 15, 60, 900, and 3600.
   * 
   * @example
   * 60
   */
  period?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 3121AE7D-4AFF-4C25-8F1D-C8226EBB1F42
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      datapoints: 'Datapoints',
      message: 'Message',
      period: 'Period',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      datapoints: 'string',
      message: 'string',
      period: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricTopResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeMetricTopResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeMetricTopResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitorGroupCategoriesRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the application group.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456
   */
  groupId?: number;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'number',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitorGroupCategoriesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * The specified resource is not found.
   */
  message?: string;
  /**
   * @remarks
   * The cloud services to which the resources in the application group belong and the number of resources that belong to the cloud service.
   */
  monitorGroupCategories?: DescribeMonitorGroupCategoriesResponseBodyMonitorGroupCategories;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 9E0347B0-EBC3-4769-A78D-D96F21C6BB52
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true: The request was successful.
   * *   false: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      monitorGroupCategories: 'MonitorGroupCategories',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      message: 'string',
      monitorGroupCategories: DescribeMonitorGroupCategoriesResponseBodyMonitorGroupCategories,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitorGroupCategoriesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeMonitorGroupCategoriesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeMonitorGroupCategoriesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitorGroupDynamicRulesRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the application group.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456
   */
  groupId?: number;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'number',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitorGroupDynamicRulesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The responses code.
   * 
   * >  The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * The specified resource is not found.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 2170B94A-1576-4D65-900E-2093037CDAF3
   */
  requestId?: string;
  /**
   * @remarks
   * The resources that are associated with the application group.
   */
  resource?: DescribeMonitorGroupDynamicRulesResponseBodyResource;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      resource: 'Resource',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      message: 'string',
      requestId: 'string',
      resource: DescribeMonitorGroupDynamicRulesResponseBodyResource,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitorGroupDynamicRulesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeMonitorGroupDynamicRulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeMonitorGroupDynamicRulesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitorGroupInstanceAttributeRequest extends $tea.Model {
  /**
   * @remarks
   * The abbreviation of the cloud service name.
   * 
   * For more information about how to obtain the abbreviation of a cloud service name, see `metricCategory` in the response parameter `Labels` of the [DescribeProjectMeta](https://help.aliyun.com/document_detail/114916.html) operation.
   * 
   * @example
   * ecs
   */
  category?: string;
  /**
   * @remarks
   * The ID of the application group.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456
   */
  groupId?: number;
  /**
   * @remarks
   * The resource ID. Separate multiple resource IDs with commas (,). You can query the details about a maximum of 20 resources at a time.
   * 
   * @example
   * i-m5e0k0bexac8tykr****
   */
  instanceIds?: string;
  /**
   * @remarks
   * The keyword that is used to search for resources.
   * 
   * @example
   * portal
   */
  keyword?: string;
  /**
   * @remarks
   * The page number.
   * 
   * Valid values: 1 to 1000000000.
   * 
   * Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * Valid values: 1 to 1000000000.
   * 
   * Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  regionId?: string;
  /**
   * @remarks
   * Specifies whether to return the total number of resources in the specified application group. Valid values:
   * 
   * *   true (default)
   * *   false
   * 
   * @example
   * true
   */
  total?: boolean;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      groupId: 'GroupId',
      instanceIds: 'InstanceIds',
      keyword: 'Keyword',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      groupId: 'number',
      instanceIds: 'string',
      keyword: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      total: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitorGroupInstanceAttributeResponseBody extends $tea.Model {
  /**
   * @remarks
   * The responses code.
   * 
   * >  The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * The specified resource is not found.
   */
  message?: string;
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 2
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 9FB8EA79-7279-4482-8D6D-3D28EEDD871A
   */
  requestId?: string;
  /**
   * @remarks
   * The resources that are associated with the application group.
   */
  resources?: DescribeMonitorGroupInstanceAttributeResponseBodyResources;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 12
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      resources: 'Resources',
      success: 'Success',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      resources: DescribeMonitorGroupInstanceAttributeResponseBodyResources,
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitorGroupInstanceAttributeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeMonitorGroupInstanceAttributeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeMonitorGroupInstanceAttributeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitorGroupInstancesRequest extends $tea.Model {
  /**
   * @remarks
   * The abbreviation of the cloud service name. Valid values of N: 1 to 200.
   * 
   * >  For more information about how to obtain the abbreviation of a cloud service name, see `metricCategory` in the response parameter `Labels` of the [DescribeProjectMeta](https://help.aliyun.com/document_detail/114916.html) operation.
   * 
   * @example
   * ecs
   */
  category?: string;
  /**
   * @remarks
   * The ID of the application group.
   * 
   * This parameter is required.
   * 
   * @example
   * 12345
   */
  groupId?: number;
  /**
   * @remarks
   * The instance ID. You can query multiple instances by specifying multiple IDs.
   * 
   * @example
   * i-x1234568
   */
  instanceIds?: string;
  /**
   * @remarks
   * The keyword used to search for instances. Fuzzy search based on instance names is supported.
   * 
   * @example
   * s1
   */
  keyword?: string;
  /**
   * @remarks
   * The page number. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      groupId: 'GroupId',
      instanceIds: 'InstanceIds',
      keyword: 'Keyword',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      groupId: 'number',
      instanceIds: 'string',
      keyword: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitorGroupInstancesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The responses code.
   * 
   * >  The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 97F2A410-9412-499C-9AD1-76EF7EC02DF2
   */
  requestId?: string;
  /**
   * @remarks
   * The information about the resources in the application group.
   */
  resources?: DescribeMonitorGroupInstancesResponseBodyResources;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 12
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      resources: 'Resources',
      success: 'Success',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      resources: DescribeMonitorGroupInstancesResponseBodyResources,
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitorGroupInstancesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeMonitorGroupInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeMonitorGroupInstancesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitorGroupNotifyPolicyListRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the application group.
   * 
   * @example
   * 6780****
   */
  groupId?: string;
  /**
   * @remarks
   * The page number. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 10.
   * 
   * @example
   * 100
   */
  pageSize?: number;
  /**
   * @remarks
   * The policy type.
   * 
   * Valid value: PauseNotify.
   * 
   * This parameter is required.
   * 
   * @example
   * PauseNotify
   */
  policyType?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      policyType: 'PolicyType',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      policyType: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitorGroupNotifyPolicyListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code.
   * 
   * > The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The Request is not authorization.
   */
  message?: string;
  /**
   * @remarks
   * The returned policies.
   */
  notifyPolicyList?: DescribeMonitorGroupNotifyPolicyListResponseBodyNotifyPolicyList;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 6072F026-C441-41A6-B114-35A1E8F8FDD3
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: string;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 11
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      notifyPolicyList: 'NotifyPolicyList',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      notifyPolicyList: DescribeMonitorGroupNotifyPolicyListResponseBodyNotifyPolicyList,
      requestId: 'string',
      success: 'string',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitorGroupNotifyPolicyListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeMonitorGroupNotifyPolicyListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeMonitorGroupNotifyPolicyListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitorGroupsRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the tag rule.
   * 
   * @example
   * 6b882d9a-5117-42e2-9d0c-4749a0c6****
   */
  dynamicTagRuleId?: string;
  /**
   * @remarks
   * The tag key that is created for the application group by using the tag rule.
   * 
   * @example
   * GroupKey1
   */
  groupFounderTagKey?: string;
  /**
   * @remarks
   * The tag value that is created for the application group by using the tag rule.
   * 
   * @example
   * GroupValue1
   */
  groupFounderTagValue?: string;
  /**
   * @remarks
   * The ID of the application group. Separate multiple application group IDs with commas (,).
   * 
   * @example
   * 92****
   */
  groupId?: string;
  /**
   * @remarks
   * The name of the application group.
   * 
   * @example
   * testGroup124
   */
  groupName?: string;
  /**
   * @remarks
   * Specifies whether to include the historical alert templates that are applied to the application group in the response. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  includeTemplateHistory?: boolean;
  /**
   * @remarks
   * The instance ID. This parameter is used to query the application group to which the specified instance belongs.
   * 
   * @example
   * i-abcdefgh12****
   */
  instanceId?: string;
  /**
   * @remarks
   * The keyword that is used for the search.
   * 
   * @example
   * test
   */
  keyword?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * Pages start from page 1. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * Pages start from page 1. Default value: 30.
   * 
   * @example
   * 30
   */
  pageSize?: number;
  regionId?: string;
  /**
   * @remarks
   * Specifies whether to include the alert contact groups in the response. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  selectContactGroups?: boolean;
  /**
   * @remarks
   * The tags of the application group.
   */
  tag?: DescribeMonitorGroupsRequestTag[];
  /**
   * @remarks
   * The type of the application group. Valid values:
   * 
   * *   custom: a self-managed application group
   * *   ehpc_cluster: an application group that is synchronized from an Elastic High Performance Computing (E-HPC) cluster
   * *   kubernetes: an application group that is synchronized from a Container Service for Kubernetes (ACK) cluster
   * 
   * @example
   * custom
   */
  type?: string;
  /**
   * @remarks
   * The type of the application group. Valid values:
   * 
   * *   custom: a self-managed application group
   * *   ehpc_cluster: an application group that is synchronized from an Elastic High Performance Computing (E-HPC) cluster
   * *   kubernetes: an application group that is synchronized from a Container Service for Kubernetes (ACK) cluster
   * *   tag: an application group that is automatically created by using tags
   * *   resMgr: an application group that is created by using resource groups
   * *   ess: an application group that is synchronized from Auto Scaling (ESS)
   * 
   * @example
   * custom
   */
  types?: string;
  static names(): { [key: string]: string } {
    return {
      dynamicTagRuleId: 'DynamicTagRuleId',
      groupFounderTagKey: 'GroupFounderTagKey',
      groupFounderTagValue: 'GroupFounderTagValue',
      groupId: 'GroupId',
      groupName: 'GroupName',
      includeTemplateHistory: 'IncludeTemplateHistory',
      instanceId: 'InstanceId',
      keyword: 'Keyword',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      selectContactGroups: 'SelectContactGroups',
      tag: 'Tag',
      type: 'Type',
      types: 'Types',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dynamicTagRuleId: 'string',
      groupFounderTagKey: 'string',
      groupFounderTagValue: 'string',
      groupId: 'string',
      groupName: 'string',
      includeTemplateHistory: 'boolean',
      instanceId: 'string',
      keyword: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      selectContactGroups: 'boolean',
      tag: { 'type': 'array', 'itemType': DescribeMonitorGroupsRequestTag },
      type: 'string',
      types: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitorGroupsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * > The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * The specified resource is not found.
   */
  message?: string;
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 30
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * F02B299A-D374-4595-9F55-7534D604F132
   */
  requestId?: string;
  /**
   * @remarks
   * The resources that are associated with the application group.
   */
  resources?: DescribeMonitorGroupsResponseBodyResources;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The total number of returned entries.
   * 
   * @example
   * 10
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      resources: 'Resources',
      success: 'Success',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      resources: DescribeMonitorGroupsResponseBodyResources,
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitorGroupsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeMonitorGroupsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeMonitorGroupsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitorResourceQuotaAttributeRequest extends $tea.Model {
  regionId?: string;
  /**
   * @remarks
   * Specifies whether to return information about used quotas. Valid values:
   * 
   * *   true (default): yes
   * *   false: no
   * 
   * @example
   * true
   */
  showUsed?: boolean;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      showUsed: 'ShowUsed',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      showUsed: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitorResourceQuotaAttributeResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code.
   * 
   * > The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The specified resource is not found.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 31BC7201-00F2-47B2-B7B9-6A173076ACE
   */
  requestId?: string;
  /**
   * @remarks
   * The details about the resource quotas of CloudMonitor.
   */
  resourceQuota?: DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuota;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      resourceQuota: 'ResourceQuota',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      resourceQuota: DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuota,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitorResourceQuotaAttributeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeMonitorResourceQuotaAttributeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeMonitorResourceQuotaAttributeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitoringAgentAccessKeyRequest extends $tea.Model {
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitoringAgentAccessKeyResponseBody extends $tea.Model {
  /**
   * @remarks
   * The AccessKey ID that is required to install the agent.
   * 
   * @example
   * E7A27f9****
   */
  accessKey?: string;
  /**
   * @remarks
   * The status code.
   * 
   * > The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The specified resource is not found.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * C0F655E9-D793-51E6-BD78-CABBCCFC1047
   */
  requestId?: string;
  /**
   * @remarks
   * The AccessKey secret that is required to install the agent.
   * 
   * @example
   * sBjNOUhLylrxMX-Xv1****
   */
  secretKey?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      accessKey: 'AccessKey',
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      secretKey: 'SecretKey',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessKey: 'string',
      code: 'number',
      message: 'string',
      requestId: 'string',
      secretKey: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitoringAgentAccessKeyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeMonitoringAgentAccessKeyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeMonitoringAgentAccessKeyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitoringAgentConfigRequest extends $tea.Model {
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitoringAgentConfigResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the Cloud Monitor agent is automatically installed on existing Elastic Compute Service (ECS) instances. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  autoInstall?: boolean;
  /**
   * @remarks
   * The status code.
   * 
   * >  The status code 200 indicates a success.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The service for which one-click alert is enabled.
   * 
   * @example
   * redis,rds,ecs
   */
  enableActiveAlert?: string;
  /**
   * @remarks
   * Indicates whether the Cloud Monitor agent is automatically installed on new ECS instances. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  enableInstallAgentNewECS?: boolean;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The Request is not authorization.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * E9F4FA2A-54BE-4EF9-9D1D-1A0B1DC86B8D
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the operation was successful. Valid values:
   * 
   * *   true: successful.
   * *   false: failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      autoInstall: 'AutoInstall',
      code: 'Code',
      enableActiveAlert: 'EnableActiveAlert',
      enableInstallAgentNewECS: 'EnableInstallAgentNewECS',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoInstall: 'boolean',
      code: 'string',
      enableActiveAlert: 'string',
      enableInstallAgentNewECS: 'boolean',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitoringAgentConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeMonitoringAgentConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeMonitoringAgentConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitoringAgentHostsRequest extends $tea.Model {
  /**
   * @remarks
   * Specifies whether to query Elastic Compute Service (ECS) instances that are provided by Alibaba Cloud or to query hosts that are not provided by Alibaba Cloud. Valid values:
   * 
   * *   true (default value): queries all the ECS instances that are provided by Alibaba Cloud.
   * *   false: queries all the hosts that are not provided by Alibaba Cloud.
   * 
   * @example
   * true
   */
  aliyunHost?: boolean;
  /**
   * @remarks
   * The name of the host.
   * 
   * @example
   * hostNam1
   */
  hostName?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * i-a3d1q1pm2f9yr29e****
   */
  instanceIds?: string;
  /**
   * @remarks
   * The region ID of the instance.
   * 
   * @example
   * cn-hangzhou
   */
  instanceRegionId?: string;
  /**
   * @remarks
   * The keyword that is used in fuzzy match.
   * 
   * @example
   * host1
   */
  keyWord?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Valid values:
   * 
   * *   10
   * *   20
   * *   50
   * *   100
   * 
   * > Although Alibaba Cloud does not limit the maximum value of this parameter, we recommend that you do not set it to an excessively large value. If you set it to an excessively large value, a timeout error may occur.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  regionId?: string;
  /**
   * @remarks
   * The serial number of the host.
   * 
   * After the CloudMonitor agent is installed on a host, a globally unique serial number is generated. A host that is not provided by Alibaba Cloud has a serial number instead of an instance ID.
   * 
   * > This parameter can be used to accurately search for a monitored host.
   * 
   * @example
   * a1ab31a3-1234-40f2-9e95-c8caa8f0****
   */
  serialNumbers?: string;
  /**
   * @remarks
   * The status of the hosts that you want to query. Valid values:
   * 
   * *   Running: queries the hosts that are running.
   * *   Stopped: queries the hosts that are stopped, are not installed, or fail to be installed.
   * 
   * @example
   * Running
   */
  status?: string;
  /**
   * @remarks
   * The status of SysOM. Valid values:
   * 
   * *   installing: SysOM is being installed.
   * *   running: SysOM is running.
   * *   stopped: SysOM is stopped.
   * *   uninstalling: SysOM is being uninstalled.
   * 
   * @example
   * running
   */
  sysomStatus?: string;
  static names(): { [key: string]: string } {
    return {
      aliyunHost: 'AliyunHost',
      hostName: 'HostName',
      instanceIds: 'InstanceIds',
      instanceRegionId: 'InstanceRegionId',
      keyWord: 'KeyWord',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      serialNumbers: 'SerialNumbers',
      status: 'Status',
      sysomStatus: 'SysomStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunHost: 'boolean',
      hostName: 'string',
      instanceIds: 'string',
      instanceRegionId: 'string',
      keyWord: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      serialNumbers: 'string',
      status: 'string',
      sysomStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitoringAgentHostsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * > The status code 200 indicates that the call is successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The information about the hosts.
   */
  hosts?: DescribeMonitoringAgentHostsResponseBodyHosts;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The Request is not authorization.
   */
  message?: string;
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The total number of returned pages.
   * 
   * @example
   * 50
   */
  pageTotal?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 63EEBB2A-9E51-41E4-9E83-5DE7F3B292E0
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call is successful. Valid values:
   * 
   * *   true: The call is successful.
   * *   false: The call fails.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The total number of returned entries.
   * 
   * @example
   * 10
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      hosts: 'Hosts',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      pageTotal: 'PageTotal',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      hosts: DescribeMonitoringAgentHostsResponseBodyHosts,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      pageTotal: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitoringAgentHostsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeMonitoringAgentHostsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeMonitoringAgentHostsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitoringAgentProcessesRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * i-hp3hl3cx1pbahzy8****
   */
  instanceId?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitoringAgentProcessesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The value 200 indicates that the call was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * The specified resource is not found.
   */
  message?: string;
  /**
   * @remarks
   * The information about the processes.
   */
  nodeProcesses?: DescribeMonitoringAgentProcessesResponseBodyNodeProcesses;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * C11C0E85-6862-4F25-8D66-D6A5E0882984
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call was successful. Valid values:
   * 
   * *   true: The call was successful.
   * *   false: The call failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      nodeProcesses: 'NodeProcesses',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      nodeProcesses: DescribeMonitoringAgentProcessesResponseBodyNodeProcesses,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitoringAgentProcessesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeMonitoringAgentProcessesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeMonitoringAgentProcessesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitoringAgentStatusesRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the availability monitoring task.
   * 
   * @example
   * 126****
   */
  hostAvailabilityTaskId?: string;
  /**
   * @remarks
   * The instance IDs. Separate multiple instance IDs with commas (,).
   * 
   * @example
   * i-hp3dunahluwajv6f****
   */
  instanceIds?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      hostAvailabilityTaskId: 'HostAvailabilityTaskId',
      instanceIds: 'InstanceIds',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      hostAvailabilityTaskId: 'string',
      instanceIds: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitoringAgentStatusesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * > The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The specified resource is not found.
   */
  message?: string;
  /**
   * @remarks
   * The host status information.
   */
  nodeStatusList?: DescribeMonitoringAgentStatusesResponseBodyNodeStatusList;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 6F8371DF-AB81-41B8-9E1B-5493B3FF0E4F
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      nodeStatusList: 'NodeStatusList',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      nodeStatusList: DescribeMonitoringAgentStatusesResponseBodyNodeStatusList,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitoringAgentStatusesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeMonitoringAgentStatusesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeMonitoringAgentStatusesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitoringConfigRequest extends $tea.Model {
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitoringConfigResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the Cloud Monitor agent is automatically installed on existing ECS instances. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * false
   */
  autoInstall?: boolean;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the call was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * Indicates whether the Cloud Monitor agent is automatically installed on new Elastic Compute Service (ECS) instances. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  enableInstallAgentNewECS?: boolean;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The Request is not authorization.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * F35654DB-0C9D-4FB3-903F-479BA7663061
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call was successful. Valid values:
   * 
   * *   true: The call was successful.
   * *   false: The call failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      autoInstall: 'AutoInstall',
      code: 'Code',
      enableInstallAgentNewECS: 'EnableInstallAgentNewECS',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoInstall: 'boolean',
      code: 'string',
      enableInstallAgentNewECS: 'boolean',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitoringConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeMonitoringConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeMonitoringConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProductResourceTagKeyListRequest extends $tea.Model {
  /**
   * @remarks
   * The pagination cursor.
   * 
   * @example
   * dbc2826f237e****
   */
  nextToken?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      nextToken: 'NextToken',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nextToken: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProductResourceTagKeyListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the call was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The request processing has failed due to some unknown error.
   */
  message?: string;
  /**
   * @remarks
   * The pagination cursor. If more entries are to be returned on the next page, a pagination cursor is returned.
   * 
   * >  If the value of this parameter is not null, more entries are to be returned on the next page. You can use the returned pagination cursor as a request parameter to obtain entries on the next page. If the value of this parameter is null, all the entries have been returned.
   * 
   * @example
   * dbc2826f237e****
   */
  nextToken?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 945ACAA9-89F2-4A62-8913-076FDEDAA8DB
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call was successful. The value true indicates a success. The value false indicates a failure.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The keys of tags.
   */
  tagKeys?: DescribeProductResourceTagKeyListResponseBodyTagKeys;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      nextToken: 'NextToken',
      requestId: 'RequestId',
      success: 'Success',
      tagKeys: 'TagKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      nextToken: 'string',
      requestId: 'string',
      success: 'boolean',
      tagKeys: DescribeProductResourceTagKeyListResponseBodyTagKeys,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProductResourceTagKeyListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeProductResourceTagKeyListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeProductResourceTagKeyListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProductsOfActiveMetricRuleRequest extends $tea.Model {
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProductsOfActiveMetricRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the services for which one-click alert is enabled.
   */
  allProductInitMetricRuleList?: DescribeProductsOfActiveMetricRuleResponseBodyAllProductInitMetricRuleList;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The information about the services for which one-click alert is enabled. Services are separated with commas (,). Valid values:
   * 
   * *   ecs: Elastic Compute Service (ECS)
   * *   rds: ApsaraDB RDS
   * *   slb: Server Load Balancer (SLB)
   * *   redis_standard: ApsaraDB for Redis of the standard architecture
   * *   redis_sharding: ApsaraDB for Redis of the cluster architecture
   * *   redis_splitrw: ApsaraDB for Redis of the read/write splitting architecture
   * *   mongodb: ApsaraDB for MongoDB of the replica set architecture
   * *   mongodb_sharding: ApsaraDB for MongoDB of the sharded cluster architecture
   * *   hbase: ApsaraDB for HBase
   * *   elasticsearch: Elasticsearch
   * *   opensearch: OpenSearch
   * 
   * @example
   * ecs,rds
   */
  datapoints?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The Request is not authorization.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * F82E6667-7811-4BA0-842F-5B2DC42BBAAD
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true: The request was successful.
   * *   false: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      allProductInitMetricRuleList: 'AllProductInitMetricRuleList',
      code: 'Code',
      datapoints: 'Datapoints',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allProductInitMetricRuleList: DescribeProductsOfActiveMetricRuleResponseBodyAllProductInitMetricRuleList,
      code: 'number',
      datapoints: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProductsOfActiveMetricRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeProductsOfActiveMetricRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeProductsOfActiveMetricRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectMetaRequest extends $tea.Model {
  /**
   * @remarks
   * The tags. Tags are used to filter services.
   * 
   * You can filter services only by the tag whose `name` is `product`. Example: {"name":"product","value":"ECS"}.
   * 
   * > We recommend that you do not use the special tags in the CloudMonitor console.
   * 
   * @example
   * [{"name":"product","value":"ECS"}]
   */
  labels?: string;
  /**
   * @remarks
   * The page number.
   * 
   * Valid values: 1 to 100.
   * 
   * Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * Valid values: 1 to 10000.
   * 
   * Default value: 30.
   * 
   * > The value of this parameter is not limited. You can view a large number of entries per page.
   * 
   * @example
   * 30
   */
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      labels: 'Labels',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      labels: 'string',
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectMetaResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code.
   * 
   * > The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The Request is not authorization.
   */
  message?: string;
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: string;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 5
   */
  pageSize?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 4C2061B2-3B1B-43BF-A4A4-C53426F479C0
   */
  requestId?: string;
  /**
   * @remarks
   * The details of the cloud service.
   */
  resources?: DescribeProjectMetaResponseBodyResources;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values: true: The request was successful. false: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 12
   */
  total?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      resources: 'Resources',
      success: 'Success',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      pageNumber: 'string',
      pageSize: 'string',
      requestId: 'string',
      resources: DescribeProjectMetaResponseBodyResources,
      success: 'boolean',
      total: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectMetaResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeProjectMetaResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeProjectMetaResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSiteMonitorAttributeRequest extends $tea.Model {
  /**
   * @remarks
   * Specifies whether to return the information of the alert rules that are configured for the site monitoring task. Valid values:
   * 
   * *   true: The system returns the information of the alert rules that are configured for the site monitoring task.
   * *   false (default): The system does not return the information of the alert rules that are configured for the site monitoring task.
   * 
   * @example
   * false
   */
  includeAlert?: boolean;
  regionId?: string;
  /**
   * @remarks
   * The ID of the site monitoring task.
   * 
   * This parameter is required.
   * 
   * @example
   * cc641dff-c19d-45f3-ad0a-818a0c4f****
   */
  taskId?: string;
  static names(): { [key: string]: string } {
    return {
      includeAlert: 'IncludeAlert',
      regionId: 'RegionId',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      includeAlert: 'boolean',
      regionId: 'string',
      taskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSiteMonitorAttributeResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response code.
   * 
   * >  The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * successful
   */
  message?: string;
  /**
   * @remarks
   * The information of the alert rules that are configured for the site monitoring task.
   */
  metricRules?: DescribeSiteMonitorAttributeResponseBodyMetricRules;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * D17DF650-7EBD-54D0-903A-1D4E624D7402
   */
  requestId?: string;
  /**
   * @remarks
   * The details of the site monitoring task.
   */
  siteMonitors?: DescribeSiteMonitorAttributeResponseBodySiteMonitors;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      metricRules: 'MetricRules',
      requestId: 'RequestId',
      siteMonitors: 'SiteMonitors',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      metricRules: DescribeSiteMonitorAttributeResponseBodyMetricRules,
      requestId: 'string',
      siteMonitors: DescribeSiteMonitorAttributeResponseBodySiteMonitors,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSiteMonitorAttributeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeSiteMonitorAttributeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSiteMonitorAttributeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSiteMonitorDataRequest extends $tea.Model {
  /**
   * @remarks
   * The end of the time range for the query. Supported formats:
   * 
   * *   UNIX timestamp: The value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
   * *   Time format: The value is in the YYYY-MM-DDThh:mm:ssZ format.
   * 
   * @example
   * 1551581437000
   */
  endTime?: string;
  /**
   * @remarks
   * The number of data points to return.
   * 
   * @example
   * 1000
   */
  length?: number;
  /**
   * @remarks
   * The name of the metric. Valid values:
   * 
   * *   Availability
   * *   ResponseTime
   * 
   * This parameter is required.
   * 
   * @example
   * Availability
   */
  metricName?: string;
  /**
   * @remarks
   * The pagination cursor.
   * 
   * @example
   * 49f7b317-7645-4cc9-94fd-ea42e5220930ea42e5220930ea42e522****
   */
  nextToken?: string;
  /**
   * @remarks
   * The interval at which monitoring data is returned. The value is an integral multiple of 60. Unit: seconds.
   * 
   * >  The default value equals the minimum interval at which detection requests are sent to the monitored address.
   * 
   * @example
   * 60
   */
  period?: string;
  regionId?: string;
  /**
   * @remarks
   * The beginning of the time range for the query. Supported formats:
   * 
   * *   UNIX timestamp: The value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
   * *   Time format: The value is in the YYYY-MM-DDThh:mm:ssZ format.
   * 
   * @example
   * 1551579637000
   */
  startTime?: string;
  /**
   * @remarks
   * The ID of the site monitoring task.
   * 
   * This parameter is required.
   * 
   * @example
   * 49f7b317-7645-4cc9-94fd-ea42e522****
   */
  taskId?: string;
  /**
   * @remarks
   * The type of the monitored object whose monitoring data is to be queried. Valid values:
   * 
   * *   metric
   * *   event
   * 
   * @example
   * metric
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      length: 'Length',
      metricName: 'MetricName',
      nextToken: 'NextToken',
      period: 'Period',
      regionId: 'RegionId',
      startTime: 'StartTime',
      taskId: 'TaskId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      length: 'number',
      metricName: 'string',
      nextToken: 'string',
      period: 'string',
      regionId: 'string',
      startTime: 'string',
      taskId: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSiteMonitorDataResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the call was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The returned monitoring data.
   * 
   * @example
   * [{"Maximum":247,"Mimimum":61,"Average":154,"userId":"127067667954****","taskId":"49f7b317-7645-4cc9-94fd-ea42e522****","timestamp":1551581760000}]
   */
  data?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * Successful
   */
  message?: string;
  /**
   * @remarks
   * The pagination cursor.
   * 
   * @example
   * ea42e5220930ea42e522****
   */
  nextToken?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 3febb181-0d98-4af9-8b04-7faf36b048b9
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call was successful. The value true indicates a success. The value false indicates a failure.
   * 
   * @example
   * true
   */
  success?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      nextToken: 'NextToken',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'string',
      message: 'string',
      nextToken: 'string',
      requestId: 'string',
      success: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSiteMonitorDataResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeSiteMonitorDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSiteMonitorDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSiteMonitorISPCityListRequest extends $tea.Model {
  /**
   * @remarks
   * The name or ID of the city.
   * 
   * > City names support fuzzy match.
   */
  city?: string;
  /**
   * @remarks
   * Specifies whether to query IPv4 probes. Valid values:
   * 
   * *   true (default): IPv4 probes are queried.
   * *   false: IPv4 probes are not queried.
   * 
   * @example
   * true
   */
  IPV4?: boolean;
  /**
   * @remarks
   * Specifies whether to query IPv6 probes. Valid values:
   * 
   * *   true (default): IPv6 probes are queried.
   * *   false: IPv6 probes are not queried.
   * 
   * @example
   * true
   */
  IPV6?: boolean;
  /**
   * @remarks
   * The name or ID of the carrier.
   * 
   * > Carrier names support fuzzy match.
   */
  isp?: string;
  regionId?: string;
  /**
   * @remarks
   * Specifies whether to return all detection points. Valid values:
   * 
   * *   true (default): returns all detection points.
   * *   false: returns only available detection points.
   * 
   * @example
   * true
   */
  viewAll?: boolean;
  static names(): { [key: string]: string } {
    return {
      city: 'City',
      IPV4: 'IPV4',
      IPV6: 'IPV6',
      isp: 'Isp',
      regionId: 'RegionId',
      viewAll: 'ViewAll',
    };
  }

  static types(): { [key: string]: any } {
    return {
      city: 'string',
      IPV4: 'boolean',
      IPV6: 'boolean',
      isp: 'string',
      regionId: 'string',
      viewAll: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSiteMonitorISPCityListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code.
   * 
   * > The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The queried detection points.
   */
  ispCityList?: DescribeSiteMonitorISPCityListResponseBodyIspCityList;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * successful
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * B35D7D84-547B-4E61-B909-48A1F8A0C756
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      ispCityList: 'IspCityList',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      ispCityList: DescribeSiteMonitorISPCityListResponseBodyIspCityList,
      message: 'string',
      requestId: 'string',
      success: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSiteMonitorISPCityListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeSiteMonitorISPCityListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSiteMonitorISPCityListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSiteMonitorListRequest extends $tea.Model {
  /**
   * @remarks
   * The keyword to be matched.
   * 
   * >  You can search for tasks by name or address. Fuzzy search is supported.
   * 
   * @example
   * site
   */
  keyword?: string;
  /**
   * @remarks
   * The page number. Default value: 1.
   * 
   * @example
   * 1
   */
  page?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  regionId?: string;
  /**
   * @remarks
   * The ID of the site monitoring task.
   * 
   * @example
   * a1ecd34a-8157-44d9-b060-14950837****
   */
  taskId?: string;
  /**
   * @remarks
   * The task status. Valid values:
   * 
   * *   1: The task is enabled.
   * *   2: The task is disabled.
   * 
   * @example
   * 1
   */
  taskState?: string;
  /**
   * @remarks
   * The protocol that is used by the site monitoring task. Valid values: HTTP, PING, TCP, UDP, DNS, SMTP, POP3, and FTP.
   * 
   * @example
   * HTTP
   */
  taskType?: string;
  static names(): { [key: string]: string } {
    return {
      keyword: 'Keyword',
      page: 'Page',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      taskId: 'TaskId',
      taskState: 'TaskState',
      taskType: 'TaskType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      keyword: 'string',
      page: 'number',
      pageSize: 'number',
      regionId: 'string',
      taskId: 'string',
      taskState: 'string',
      taskType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSiteMonitorListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code.
   * 
   * >  The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * successful
   */
  message?: string;
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * A80DB41C-AF6C-50E1-ADB5-66DCBA3D266B
   */
  requestId?: string;
  /**
   * @remarks
   * The site monitoring tasks that are returned.
   */
  siteMonitors?: DescribeSiteMonitorListResponseBodySiteMonitors;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: string;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      siteMonitors: 'SiteMonitors',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      siteMonitors: DescribeSiteMonitorListResponseBodySiteMonitors,
      success: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSiteMonitorListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeSiteMonitorListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSiteMonitorListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSiteMonitorLogRequest extends $tea.Model {
  /**
   * @remarks
   * 浏览器类型。
   * 
   * @example
   * Chrome
   */
  browser?: string;
  /**
   * @remarks
   * 该参数已废弃，无需关注。
   * 
   * @example
   * 无
   */
  browserInfo?: string;
  /**
   * @remarks
   * The city identification code.
   * 
   * @example
   * 546
   */
  city?: string;
  /**
   * @remarks
   * 设备类型（模拟屏幕大小类型）。
   * 
   * @example
   * laptop
   */
  device?: string;
  /**
   * @remarks
   * The end of the time range to query. Valid values:
   * 
   * *   UNIX timestamp: the number of milliseconds that have elapsed since 00:00:00 Thursday, January 1, 1970
   * *   UTC time: the UTC time that follows the YYYY-MM-DDThh:mm:ssZ format
   * 
   * >  We recommend that you use UNIX timestamps to prevent time zone-related issues.
   * 
   * @example
   * 1638422475687
   */
  endTime?: string;
  /**
   * @remarks
   * The filter condition.
   * 
   * You can specify a simple expression, for example, `TotalTime>100`. In this case, the operation returns only the data for instant test tasks whose total response time exceeds 100 milliseconds.
   * 
   * @example
   * TotalTime>100
   */
  filter?: string;
  /**
   * @remarks
   * The carrier identification code.
   * 
   * @example
   * 465
   */
  isp?: string;
  /**
   * @remarks
   * The number of entries to return on each page. Valid values: 1 to 1440.
   * 
   * @example
   * 1000
   */
  length?: number;
  /**
   * @remarks
   * The name of the metric.
   * 
   * Only the `ProbeLog` metric is supported.
   * 
   * @example
   * ProbeLog
   */
  metricName?: string;
  /**
   * @remarks
   * The token that is used to initiate the next request if the response of the current request is truncated. You can use the token to initiate another request and obtain the remaining records.``
   * 
   * @example
   * IWBjqMYSy0is7zSMGu16****
   */
  nextToken?: string;
  regionId?: string;
  /**
   * @remarks
   * The start of the time range to query. The following formats are supported:
   * 
   * *   UNIX timestamp: the number of milliseconds that have elapsed since 00:00:00 Thursday, January 1, 1970
   * *   UTC time: the UTC time that follows the YYYY-MM-DDThh:mm:ssZ format
   * 
   * > 
   * 
   * *   The specified time range includes the end time and excludes the start time. The start time must be earlier than the end time.\\
   *     We recommend that you use UNIX timestamps to prevent time zone-related issues.
   * 
   * @example
   * 1638422474389
   */
  startTime?: string;
  /**
   * @remarks
   * The IDs of the instant test tasks. Separate multiple task IDs with commas (,).
   * 
   * This parameter is required.
   * 
   * @example
   * afa5c3ce-f944-4363-9edb-ce919a29****
   */
  taskIds?: string;
  static names(): { [key: string]: string } {
    return {
      browser: 'Browser',
      browserInfo: 'BrowserInfo',
      city: 'City',
      device: 'Device',
      endTime: 'EndTime',
      filter: 'Filter',
      isp: 'Isp',
      length: 'Length',
      metricName: 'MetricName',
      nextToken: 'NextToken',
      regionId: 'RegionId',
      startTime: 'StartTime',
      taskIds: 'TaskIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      browser: 'string',
      browserInfo: 'string',
      city: 'string',
      device: 'string',
      endTime: 'string',
      filter: 'string',
      isp: 'string',
      length: 'number',
      metricName: 'string',
      nextToken: 'string',
      regionId: 'string',
      startTime: 'string',
      taskIds: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSiteMonitorLogResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * **
   * 
   * **Description** The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The logs of the instant test tasks.
   * 
   * @example
   * [{\\\\"redirectCount\\\\":0.0,\\\\"SSLConnectTime\\\\":0.0,\\\\"pingDetail\\\\":\\\\"\\\\",\\\\"HTTPConnectTime\\\\":0.0,\\\\"isp\\\\":\\\\"465\\\\",\\\\"errorCode\\\\":611,\\\\"ispCN\\\\":\\\\"Alibaba\\\\",\\\\"resolution\\\\":\\\\"\\\\",\\\\"areaEN\\\\":\\\\"HuaBei\\\\",\\\\"taskEndTimestamp\\\\":1638422475687,\\\\"targetIspEN\\\\":\\\\"\\\\",\\\\"TotalTime\\\\":1.0,\\\\"taskStartTimestamp\\\\":1638422474389,\\\\"countryCN\\\\":\\\\"China\\\\",\\\\"provinceEN\\\\":\\\\"Beijing\\\\",\\\\"countryEN\\\\":\\\\"China\\\\",\\\\"targetCityEN\\\\":\\\\"\\\\",\\\\"curlConnectTime\\\\":0.0,\\\\"ips\\\\":\\\\"\\\\",\\\\"route\\\\":\\\\"\\\\",\\\\"tcpConnectTime\\\\":0.0,\\\\"cityEN\\\\":\\\\"Beijing\\\\",\\\\"HTTPDownloadSpeed\\\\":0.0,\\\\"HTTPDownloadTime\\\\":0.0,\\\\"HTTPResponseCode\\\\":0.0,\\\\"areaCN\\\\":\\\\"North China\\\\",\\\\"city\\\\":\\\\"546\\\\",\\\\"expection\\\\":\\\\"\\\\",\\\\"suorceIp\\\\":\\\\"192.168.XX.XX \\\\",\\\\"ispEN\\\\":\\\\"Alibaba\\\\",\\\\"HTTPDNSTime\\\\":1.0,\\\\"targetIsp\\\\":\\\\"\\\\",\\\\"curlStarttransferTime\\\\":0.0,\\\\"provinceCN\\\\":\\\\"Beijing\\\\",\\\\"timestamp\\\\":1638422474000,\\\\"redirectTime\\\\":0.0,\\\\"targetCity\\\\":\\\\"\\\\", \\\\"expect\\\\":\\\\"\\\\",\\\\"HTTPDownloadSize\\\\":0.0,\\\\"localDns\\\\":\\\\"192.168.XX.XX\\\\",\\\\"cityCN\\\\":\\\\"Beijing\\\\",\\\\"taskId\\\\":\\\\"afa5c3ce-f944-4363-9edb-ce919a29\\*\\*\\*\\*\\\\"}]
   */
  data?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * successful
   */
  message?: string;
  /**
   * @remarks
   * A pagination token. It can be used in the next request to retrieve a new page of results.
   * 
   * @example
   * IWBjqMYSy0is7zSMGu16****
   */
  nextToken?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 67F646FA-ED8A-58C2-B461-451DB52C8B14
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      nextToken: 'NextToken',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'string',
      message: 'string',
      nextToken: 'string',
      requestId: 'string',
      success: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSiteMonitorLogResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeSiteMonitorLogResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSiteMonitorLogResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSiteMonitorQuotaRequest extends $tea.Model {
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSiteMonitorQuotaResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the call was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The quotas and version of site monitoring.
   */
  data?: DescribeSiteMonitorQuotaResponseBodyData;
  /**
   * @remarks
   * The returned message.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 26860260-76C6-404E-AB7A-EB98D36A6885
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call was successful. Valid values:
   * 
   * *   true: The call was successful.
   * *   false: The call failed.
   * 
   * @example
   * true
   */
  success?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: DescribeSiteMonitorQuotaResponseBodyData,
      message: 'string',
      requestId: 'string',
      success: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSiteMonitorQuotaResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeSiteMonitorQuotaResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSiteMonitorQuotaResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSiteMonitorStatisticsRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the metric. Valid values:
   * 
   * *   Availability
   * *   ErrorRate
   * *   ResponseTime
   * 
   * This parameter is required.
   * 
   * @example
   * Availability
   */
  metricName?: string;
  regionId?: string;
  /**
   * @remarks
   * The timestamp that specifies the beginning of the time range to query.
   * 
   * Unit: milliseconds. The default value is 1 hour ahead of the current time.
   * 
   * @example
   * 1576142850527
   */
  startTime?: string;
  /**
   * @remarks
   * The ID of the site monitoring task.
   * 
   * For more information about how to obtain the ID of a site monitoring task, see [DescribeSiteMonitorList](https://help.aliyun.com/document_detail/115052.html).
   * 
   * This parameter is required.
   * 
   * @example
   * ef4cdc8b-9dc7-43e7-810e-f950e56c****
   */
  taskId?: string;
  /**
   * @remarks
   * The statistical period.
   * 
   * Unit: minutes. Default value: 1440 (1 day). Maximum value: 43200 (30 days).
   * 
   * @example
   * 1440
   */
  timeRange?: string;
  static names(): { [key: string]: string } {
    return {
      metricName: 'MetricName',
      regionId: 'RegionId',
      startTime: 'StartTime',
      taskId: 'TaskId',
      timeRange: 'TimeRange',
    };
  }

  static types(): { [key: string]: any } {
    return {
      metricName: 'string',
      regionId: 'string',
      startTime: 'string',
      taskId: 'string',
      timeRange: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSiteMonitorStatisticsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the call is successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The statistics of the specified metric.
   * 
   * @example
   * 100
   */
  data?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * Succcessful
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 3AD2724D-E317-4BFB-B422-D6691D071BE1
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call is successful. Valid values:
   * 
   * *   true: The call is successful.
   * *   false: The call fails.
   * 
   * @example
   * true
   */
  success?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'string',
      message: 'string',
      requestId: 'string',
      success: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSiteMonitorStatisticsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeSiteMonitorStatisticsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSiteMonitorStatisticsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSystemEventAttributeRequest extends $tea.Model {
  /**
   * @remarks
   * The end of the time range to query.
   * 
   * The value must be a UNIX timestamp. It is the number of seconds that have elapsed since 00:00:00 UTC, January 1, 1970.
   * 
   * @example
   * 1552221584949
   */
  endTime?: string;
  /**
   * @remarks
   * The type of the system event.
   * 
   * >  You can call the [DescribeSystemEventMetaList](https://help.aliyun.com/document_detail/114972.html) operation to query the types of system events.
   * 
   * @example
   * Exception
   */
  eventType?: string;
  /**
   * @remarks
   * The ID of the application group.
   * 
   * @example
   * 12346
   */
  groupId?: string;
  /**
   * @remarks
   * The level of the system event. Valid values:
   * 
   * *   CRITICAL: critical
   * *   WARN: warning
   * *   INFO: information
   * 
   * @example
   * CRITICAL
   */
  level?: string;
  /**
   * @remarks
   * The name of the system event.
   * 
   * >  You can call the [DescribeSystemEventMetaList](https://help.aliyun.com/document_detail/114972.html) operation to query the names of system events.
   * 
   * @example
   * BucketIngressBandwidth
   */
  name?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * Valid values: 1 to 100000000.
   * 
   * Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * Valid values: 1 to 100.
   * 
   * Default value: 10
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The abbreviation of the service name.
   * 
   * >  You can call the [DescribeSystemEventMetaList](https://help.aliyun.com/document_detail/114972.html) operation to query the abbreviations of service names.
   * 
   * @example
   * oss
   */
  product?: string;
  regionId?: string;
  /**
   * @remarks
   * The keywords that are used to search for the system event. Valid values:
   * 
   * *   If you want to search for the system event whose content contains a and b, set the value to `a and b`.
   * *   If you want to search for the system event whose content contains a or b, set the value to `a or b`.
   * 
   * @example
   * cms
   */
  searchKeywords?: string;
  /**
   * @remarks
   * The beginning of the time range to query.
   * 
   * The value must be a UNIX timestamp. It is the number of seconds that have elapsed since 00:00:00 UTC, January 1, 1970.
   * 
   * @example
   * 1552199984949
   */
  startTime?: string;
  /**
   * @remarks
   * The status of the system event.
   * 
   * >  You can call the [DescribeSystemEventMetaList](https://help.aliyun.com/document_detail/114972.html) operation to query the statuses of system events.
   * 
   * @example
   * normal
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      eventType: 'EventType',
      groupId: 'GroupId',
      level: 'Level',
      name: 'Name',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      product: 'Product',
      regionId: 'RegionId',
      searchKeywords: 'SearchKeywords',
      startTime: 'StartTime',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      eventType: 'string',
      groupId: 'string',
      level: 'string',
      name: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      product: 'string',
      regionId: 'string',
      searchKeywords: 'string',
      startTime: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSystemEventAttributeResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the call is successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The message that is returned. If the call is successful, `success` is returned. If the call fails, an error message is returned.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 60912C8D-B340-4253-ADE7-61ACDFD25CFC
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call is successful. Valid values: True: The call is successful. false: The call fails.
   * 
   * @example
   * true
   */
  success?: string;
  /**
   * @remarks
   * The details of the event.
   */
  systemEvents?: DescribeSystemEventAttributeResponseBodySystemEvents;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
      systemEvents: 'SystemEvents',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'string',
      systemEvents: DescribeSystemEventAttributeResponseBodySystemEvents,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSystemEventAttributeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeSystemEventAttributeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSystemEventAttributeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSystemEventCountRequest extends $tea.Model {
  /**
   * @remarks
   * The end of the time range to query. Unit: milliseconds.
   * 
   * @example
   * 1635993921000
   */
  endTime?: string;
  /**
   * @remarks
   * The type of the system event.
   * 
   * You can call the DescribeSystemEventMetaList operation to obtain the value of the response parameter `EventType`. The value of the EventType parameter indicates the types of system events that occurred for all cloud services in your Alibaba Cloud account. For more information, see [DescribeSystemEventMetaList](https://help.aliyun.com/document_detail/114972.html).
   * 
   * @example
   * StatusNotification
   */
  eventType?: string;
  /**
   * @remarks
   * The ID of the application group.
   * 
   * @example
   * 17285****
   */
  groupId?: string;
  /**
   * @remarks
   * The level of the system event. Valid values:
   * 
   * *   Critical
   * *   Warn
   * *   Info
   * 
   * You can call the DescribeSystemEventMetaList operation to obtain the value of the response parameter `Level`. The value of the Level parameter indicates the levels of system events that occurred for all cloud services in your Alibaba Cloud account. For more information, see [DescribeSystemEventMetaList](https://help.aliyun.com/document_detail/114972.html).
   * 
   * @example
   * Info
   */
  level?: string;
  /**
   * @remarks
   * The name of the system event.
   * 
   * You can call the DescribeSystemEventMetaList operation to obtain the value of the response parameter `Name`. The value of the Name parameter indicates the names of system events that occurred for all cloud services in your Alibaba Cloud account. For more information, see [DescribeSystemEventMetaList](https://help.aliyun.com/document_detail/114972.html).
   * 
   * @example
   * Instance:StateChange
   */
  name?: string;
  /**
   * @remarks
   * The name of the cloud service.
   * 
   * You can call the DescribeSystemEventMetaList operation to obtain the value of the response parameter `Product`. The value of the Product parameter indicates the names of all cloud services in which the system events of your Alibaba Cloud account occurred. For more information, see [DescribeSystemEventMetaList](https://help.aliyun.com/document_detail/114972.html).
   * 
   * @example
   * ECS
   */
  product?: string;
  regionId?: string;
  /**
   * @remarks
   * The keywords that are used to search for the system event. Valid values:
   * 
   * *   If you want to search for the system event whose content contains a and b, set the value to `a and b`.
   * *   If you want to search for the system event whose content contains a or b, set the value to `a or b`.
   * 
   * @example
   * ECS
   */
  searchKeywords?: string;
  /**
   * @remarks
   * The beginning of the time range to query. Unit: milliseconds.
   * 
   * @example
   * 1635993541000
   */
  startTime?: string;
  /**
   * @remarks
   * The status of the system event.
   * 
   * You can call the DescribeSystemEventMetaList operation to obtain the value of the response parameter `Status`. The value of the Status parameter indicates the status of system events that occurred for all cloud services in your Alibaba Cloud account. For more information, see [DescribeSystemEventMetaList](https://help.aliyun.com/document_detail/114972.html).
   * 
   * @example
   * Normal
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      eventType: 'EventType',
      groupId: 'GroupId',
      level: 'Level',
      name: 'Name',
      product: 'Product',
      regionId: 'RegionId',
      searchKeywords: 'SearchKeywords',
      startTime: 'StartTime',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      eventType: 'string',
      groupId: 'string',
      level: 'string',
      name: 'string',
      product: 'string',
      regionId: 'string',
      searchKeywords: 'string',
      startTime: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSystemEventCountResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status codes.
   * 
   * >  The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * If the request was successful, a success message is returned. If the request failed, an error message is returned.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * C7A7B776-0ACE-5A93-9B07-DE8008D9CCDF
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: string;
  /**
   * @remarks
   * The details of the system event.
   */
  systemEventCounts?: DescribeSystemEventCountResponseBodySystemEventCounts;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
      systemEventCounts: 'SystemEventCounts',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'string',
      systemEventCounts: DescribeSystemEventCountResponseBodySystemEventCounts,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSystemEventCountResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeSystemEventCountResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSystemEventCountResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSystemEventHistogramRequest extends $tea.Model {
  /**
   * @remarks
   * The end time.
   * 
   * This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
   * 
   * @example
   * 1552220485596
   */
  endTime?: string;
  /**
   * @remarks
   * The event type.
   * 
   * >  You can call the [DescribeSystemEventMetaList](https://help.aliyun.com/document_detail/114972.html) operation to query the types of system events.
   * 
   * @example
   * Exception
   */
  eventType?: string;
  /**
   * @remarks
   * The ID of the application group.
   * 
   * @example
   * 12345
   */
  groupId?: string;
  /**
   * @remarks
   * The level of the event. Valid values:
   * 
   * *   CRITICAL
   * *   WARN
   * *   INFO
   * 
   * @example
   * CRITICAL
   */
  level?: string;
  /**
   * @remarks
   * The event name.
   * 
   * >  You can call the [DescribeSystemEventMetaList](https://help.aliyun.com/document_detail/114972.html) operation to query the names of system events.
   * 
   * @example
   * BucketIngressBandwidth
   */
  name?: string;
  /**
   * @remarks
   * The abbreviation of the service name.
   * 
   * >  You can call the [DescribeSystemEventMetaList](https://help.aliyun.com/document_detail/114972.html) operation to query the abbreviations of service names.
   * 
   * @example
   * OSS
   */
  product?: string;
  regionId?: string;
  /**
   * @remarks
   * The keywords that are used to search for the system event. Valid values:
   * 
   * *   If you want to search for the system event whose content contains a and b, set the value to `a and b`.
   * *   If you want to search for the system event whose content contains a or b, set the value to `a or b`.
   * 
   * @example
   * cms
   */
  searchKeywords?: string;
  /**
   * @remarks
   * The start time.
   * 
   * This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
   * 
   * @example
   * 1552209685596
   */
  startTime?: string;
  /**
   * @remarks
   * The event status.
   * 
   * >  You can call the [DescribeSystemEventMetaList](https://help.aliyun.com/document_detail/114972.html) operation to query the status of system events.
   * 
   * @example
   * normal
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      eventType: 'EventType',
      groupId: 'GroupId',
      level: 'Level',
      name: 'Name',
      product: 'Product',
      regionId: 'RegionId',
      searchKeywords: 'SearchKeywords',
      startTime: 'StartTime',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      eventType: 'string',
      groupId: 'string',
      level: 'string',
      name: 'string',
      product: 'string',
      regionId: 'string',
      searchKeywords: 'string',
      startTime: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSystemEventHistogramResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response code.
   * 
   * >  The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * The Request is not authorization.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 486029C9-53E1-44B4-85A8-16A571A043FD
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values: true: The request was successful. false: The request failed.
   * 
   * @example
   * true
   */
  success?: string;
  /**
   * @remarks
   * The information about the number of times the system event occurred during each interval of a time period.
   */
  systemEventHistograms?: DescribeSystemEventHistogramResponseBodySystemEventHistograms;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
      systemEventHistograms: 'SystemEventHistograms',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'string',
      systemEventHistograms: DescribeSystemEventHistogramResponseBodySystemEventHistograms,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSystemEventHistogramResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeSystemEventHistogramResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSystemEventHistogramResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSystemEventMetaListRequest extends $tea.Model {
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSystemEventMetaListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the call was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The detailed meta information.
   */
  data?: DescribeSystemEventMetaListResponseBodyData;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * A6582C8B-E67C-4A19-BC15-EAEFEBDC7995
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call was successful. Valid values:
   * 
   * *   true: The call was successful.
   * *   false: The call failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: DescribeSystemEventMetaListResponseBodyData,
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSystemEventMetaListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeSystemEventMetaListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSystemEventMetaListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTagKeyListRequest extends $tea.Model {
  /**
   * @remarks
   * The number of the page to return.
   * 
   * Pages start from page 1. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * Maximum value: 100. Default value: 50.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTagKeyListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the call was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * Specified parameter PageSize is not valid.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * B04B8CF3-4489-432D-83BA-6F128E5F2293
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call was successful. Valid values:
   * 
   * *   true: The call was successful.
   * *   false: The call failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The tag keys returned.
   */
  tagKeys?: DescribeTagKeyListResponseBodyTagKeys;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
      tagKeys: 'TagKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
      tagKeys: DescribeTagKeyListResponseBodyTagKeys,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTagKeyListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeTagKeyListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeTagKeyListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTagValueListRequest extends $tea.Model {
  /**
   * @remarks
   * The number of the page to return.
   * 
   * Pages start from page 1. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * Valid values: 1 to 100. Pages start from page 1. Default value: 50.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  regionId?: string;
  /**
   * @remarks
   * The key of the tag whose values you want to query.
   * 
   * For more information about how to obtain a tag key, see [DescribeTagKeyList](https://help.aliyun.com/document_detail/145558.html).
   * 
   * This parameter is required.
   * 
   * @example
   * tagKey1
   */
  tagKey?: string;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      tagKey: 'TagKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      tagKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTagValueListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The value 200 indicates that the call was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The specified resource is not found.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * B04B8CF3-4489-432D-83BA-6F128E4F2295
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call was successful. Valid values:
   * 
   * *   true: The call was successful.
   * *   false: The call failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The tag values returned.
   */
  tagValues?: DescribeTagValueListResponseBodyTagValues;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
      tagValues: 'TagValues',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
      tagValues: DescribeTagValueListResponseBodyTagValues,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTagValueListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeTagValueListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeTagValueListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUnhealthyHostAvailabilityRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 123456
   */
  id?: number[];
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: { 'type': 'array', 'itemType': 'number' },
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUnhealthyHostAvailabilityResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the call was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * User not authorized to operate on the specified resource.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * ACBDBB40-DFB6-4F4C-8957-51FFB233969C
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call was successful. Valid values:
   * 
   * *   true: The call was successful.
   * *   false: The call failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The unhealthy instances that are detected by the specified availability monitoring tasks.
   */
  unhealthyList?: DescribeUnhealthyHostAvailabilityResponseBodyUnhealthyList;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
      unhealthyList: 'UnhealthyList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
      unhealthyList: DescribeUnhealthyHostAvailabilityResponseBodyUnhealthyList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUnhealthyHostAvailabilityResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeUnhealthyHostAvailabilityResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeUnhealthyHostAvailabilityResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableActiveMetricRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The service for which you want to disable one-click alert. Valid values:
   * 
   * *   ecs: Elastic Compute Service (ECS)
   * *   rds: ApsaraDB RDS
   * *   slb: Server Load Balancer (SLB)
   * *   redis_standard: ApsaraDB for Redis of the standard architecture
   * *   redis_sharding: ApsaraDB for Redis of the cluster architecture
   * *   redis_splitrw: ApsaraDB for Redis of the read/write splitting architecture
   * *   mongodb: ApsaraDB for MongoDB of the replica set architecture
   * *   mongodb_sharding: ApsaraDB for MongoDB of the sharded cluster architecture
   * *   hbase: ApsaraDB for HBase
   * *   elasticsearch: Elasticsearch
   * *   opensearch: Open Search
   * 
   * This parameter is required.
   * 
   * @example
   * ecs
   */
  product?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      product: 'Product',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      product: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableActiveMetricRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the call was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * The Request is not authorization.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * F82E6667-7811-4BA0-842F-5B2DC42BBAAD
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call was successful. Valid values:
   * 
   * *   true: The call was successful.
   * *   false: The call failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableActiveMetricRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DisableActiveMetricRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DisableActiveMetricRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableEventRulesRequest extends $tea.Model {
  regionId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * ruleName1
   */
  ruleNames?: string[];
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      ruleNames: 'RuleNames',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      ruleNames: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableEventRulesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the call was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 3FD0E8B5-F132-4F4E-A081-2878AF378B12
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call was successful. The value true indicates a success. The value false indicates a failure.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableEventRulesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DisableEventRulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DisableEventRulesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableHostAvailabilityRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 12345
   */
  id?: number[];
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: { 'type': 'array', 'itemType': 'number' },
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableHostAvailabilityResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code.
   * 
   * >  The status code 200 indicates a success.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * User not authorized to operate on the specified resource.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * ACBDBB40-DFB6-4F4C-8957-51FFB233969C
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the operation was successful. Valid values:
   * 
   * *   true: successful.
   * *   false: failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableHostAvailabilityResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DisableHostAvailabilityResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DisableHostAvailabilityResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableMetricRulesRequest extends $tea.Model {
  regionId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * detect_87****_HTTP_HttpLatency
   */
  ruleId?: string[];
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      ruleId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableMetricRulesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the call was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * RuleId is mandatory for this action.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * FF38D33A-67C1-40EB-AB65-FAEE51EDB644
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call was successful. Valid values:
   * 
   * *   true: The call was successful.
   * *   false: The call failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableMetricRulesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DisableMetricRulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DisableMetricRulesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableSiteMonitorsRequest extends $tea.Model {
  regionId?: string;
  /**
   * @remarks
   * The IDs of the site monitoring tasks. Separate multiple IDs with commas (,).
   * 
   * This parameter is required.
   * 
   * @example
   * 49f7b317-7645-4cc9-94fd-ea42e522****,49f7b317-7645-4cc9-94fd-ea42e522****
   */
  taskIds?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      taskIds: 'TaskIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      taskIds: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableSiteMonitorsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code.
   * 
   * >  The status code 200 indicates a success.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The number of detection points that were monitored by the site monitoring tasks.
   */
  data?: DisableSiteMonitorsResponseBodyData;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * successful
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 3fcd12e7-d387-42ee-b77e-661c775bb17f
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the operation was successful. Valid values:
   * 
   * *   true: successful.
   * *   false: failed.
   * 
   * @example
   * true
   */
  success?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: DisableSiteMonitorsResponseBodyData,
      message: 'string',
      requestId: 'string',
      success: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableSiteMonitorsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DisableSiteMonitorsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DisableSiteMonitorsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableActiveMetricRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The cloud service for which you want to enable initiative alert. Valid values:
   * 
   * *   ecs: Elastic Compute Service (ECS)
   * *   rds: ApsaraDB RDS
   * *   slb: Server Load Balancer (SLB)
   * *   redis_standard: ApsaraDB for Redis of the standard architecture
   * *   redis_sharding: ApsaraDB for Redis of the cluster architecture
   * *   redis_splitrw: ApsaraDB for Redis of the read/write splitting architecture
   * *   mongodb: ApsaraDB for MongoDB of the replica set architecture
   * *   mongodb_sharding: ApsaraDB for MongoDB of the sharded cluster architecture
   * *   hbase: ApsaraDB for HBase
   * *   elasticsearch: Elasticsearch
   * *   opensearch: OpenSearch
   * 
   * This parameter is required.
   * 
   * @example
   * ecs
   */
  product?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      product: 'Product',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      product: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableActiveMetricRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the call was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The Request is not authorization.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * F82E6667-7811-4BA0-842F-5B2DC42BBAAD
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call was successful. Valid values:
   * 
   * *   true: The call was successful.
   * *   false: The call failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableActiveMetricRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: EnableActiveMetricRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: EnableActiveMetricRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableEventRulesRequest extends $tea.Model {
  regionId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * ruleName1
   */
  ruleNames?: string[];
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      ruleNames: 'RuleNames',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      ruleNames: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableEventRulesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the call was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 20F2896A-6684-4A04-8255-4155B1593C70
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call was successful. The value true indicates a success. The value false indicates a failure.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableEventRulesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: EnableEventRulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: EnableEventRulesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableHostAvailabilityRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 123456
   */
  id?: number[];
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: { 'type': 'array', 'itemType': 'number' },
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableHostAvailabilityResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code.
   * 
   * >  The HTTP status code 200 indicates a success.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * User not authorized to operate on the specified resource.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * ACBDBB40-DFB6-4F4C-8957-51FFB233969C
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the operation was successful. Valid values:
   * 
   * *   true: successful.
   * *   false: failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableHostAvailabilityResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: EnableHostAvailabilityResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: EnableHostAvailabilityResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableMetricRuleBlackListRequest extends $tea.Model {
  /**
   * @remarks
   * The IDs of the blacklist policies. Separate multiple IDs with commas (,). You can specify up to 50 IDs.
   * 
   * For information about how to obtain the ID of a blacklist policy, see [DescribeMetricRuleBlackList](https://help.aliyun.com/document_detail/457257.html).
   * 
   * > You can also set this parameter to a JSON array. Example: `["a9ad2ac2-3ed9-11ed-b878-0242ac12****","5cb8a9a4-198f-4651-a353-f8b28788****"]`.
   * 
   * This parameter is required.
   * 
   * @example
   * a9ad2ac2-3ed9-11ed-b878-0242ac12****
   */
  id?: string;
  /**
   * @remarks
   * Specifies whether to enable the blacklist policy. Valid values:
   * 
   * *   true: The blacklist policy is enabled.
   * *   false (default): The blacklist policy is disabled.
   * 
   * This parameter is required.
   * 
   * @example
   * true
   */
  isEnable?: boolean;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      isEnable: 'IsEnable',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      isEnable: 'boolean',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableMetricRuleBlackListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code.
   * 
   * > The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The number of blacklist policies that are enabled or disabled.
   * 
   * @example
   * 1
   */
  count?: number;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The specified resource is not found.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 94869866-1621-3652-BBC9-72A47B2AC2F5
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      count: 'Count',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      count: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableMetricRuleBlackListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: EnableMetricRuleBlackListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: EnableMetricRuleBlackListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableMetricRulesRequest extends $tea.Model {
  regionId?: string;
  /**
   * @remarks
   * The IDs of the alert rules.
   * 
   * Valid values of N: 1 to 100.
   * 
   * For information about how to obtain the ID of an alert rule, see [DescribeMetricRuleList](https://help.aliyun.com/document_detail/114941.html).
   * 
   * This parameter is required.
   * 
   * @example
   * ab05733c97b7ce239fb1b53393dc1697c123****
   */
  ruleId?: string[];
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      ruleId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableMetricRulesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * > The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * FF38D33A-67C1-40EB-AB65-FAEE51EDB644
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableMetricRulesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: EnableMetricRulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: EnableMetricRulesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableSiteMonitorsRequest extends $tea.Model {
  regionId?: string;
  /**
   * @remarks
   * The IDs of the site monitoring tasks. Separate multiple instance IDs with commas (,).
   * 
   * This parameter is required.
   * 
   * @example
   * 49f7b317-7645-4cc9-94fd-ea42e522****,49f7b317-7645-4cc9-94fd-ea42e522****
   */
  taskIds?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      taskIds: 'TaskIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      taskIds: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableSiteMonitorsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code.
   * 
   * >  The status code 200 indicates a success.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The number of detection points that are affected by the site monitoring tasks.
   */
  data?: EnableSiteMonitorsResponseBodyData;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * successful
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 3fcd12e7-d387-42ee-b77e-661c775bb17f
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the operation was successful. Valid values:
   * 
   * *   true: successful.
   * *   false: failed.
   * 
   * @example
   * true
   */
  success?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: EnableSiteMonitorsResponseBodyData,
      message: 'string',
      requestId: 'string',
      success: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableSiteMonitorsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: EnableSiteMonitorsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: EnableSiteMonitorsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InstallMonitoringAgentRequest extends $tea.Model {
  /**
   * @remarks
   * Specifies whether to install the CloudMonitor agent. Valid values:
   * 
   * *   true (default value): yes
   * *   false: no
   * 
   * @example
   * true
   */
  force?: boolean;
  /**
   * @remarks
   * Specifies whether to install the CloudMonitor agent on all ECS instances that belong to the current Alibaba Cloud account. Valid values:
   * 
   * *   `onlyInstallNotHasAgent`: installs the latest version of the CloudMonitor agent only on ECS instances on which the agent is not installed.
   * *   `onlyUpgradeAgent`: upgrades the CloudMonitor agent to the latest version only for ECS instances on which an earlier version of the agent is installed.
   * *   `installAndUpgrade`: installs the latest version of the CloudMonitor agent on ECS instances on which the agent is not installed, and upgrades the CloudMonitor agent to the latest version for ECS instances on which an earlier version of the agent is installed.
   * 
   * >  If you set the InstallCommand parameter, the `InstanceIds` parameter does not take effect.
   * 
   * @example
   * onlyInstallNotHasAgent
   */
  installCommand?: string;
  /**
   * @example
   * i-m5e0k0bexac8tykr****
   */
  instanceIds?: string[];
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      force: 'Force',
      installCommand: 'InstallCommand',
      instanceIds: 'InstanceIds',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      force: 'boolean',
      installCommand: 'string',
      instanceIds: { 'type': 'array', 'itemType': 'string' },
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InstallMonitoringAgentResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the call was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The specified resource is not found.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0BDAF8A8-04DC-5F0C-90E4-724D42C41945
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call was successful. Valid values:
   * 
   * *   true: The call was successful.
   * *   false: The call failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InstallMonitoringAgentResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: InstallMonitoringAgentResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: InstallMonitoringAgentResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyGroupMonitoringAgentProcessRequest extends $tea.Model {
  /**
   * @remarks
   * The alert rule configurations.
   * 
   * This parameter is required.
   */
  alertConfig?: ModifyGroupMonitoringAgentProcessRequestAlertConfig[];
  /**
   * @remarks
   * The ID of the application group.
   * 
   * This parameter is required.
   * 
   * @example
   * 6780****
   */
  groupId?: string;
  /**
   * @remarks
   * The ID of the process monitoring task.
   * 
   * This parameter is required.
   * 
   * @example
   * 92E3065F-0980-4E31-9AA0-BA6****
   */
  id?: string;
  /**
   * @remarks
   * The logical operator used between conditional expressions that are used to match instances. Valid values:
   * 
   * *   all
   * *   and
   * *   or
   * 
   * @example
   * and
   */
  matchExpressFilterRelation?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      alertConfig: 'AlertConfig',
      groupId: 'GroupId',
      id: 'Id',
      matchExpressFilterRelation: 'MatchExpressFilterRelation',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertConfig: { 'type': 'array', 'itemType': ModifyGroupMonitoringAgentProcessRequestAlertConfig },
      groupId: 'string',
      id: 'string',
      matchExpressFilterRelation: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyGroupMonitoringAgentProcessResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the call was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The Request is not authorization.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 7985D471-3FA8-4EE9-8F4B-45C19DF3D36F
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call was successful. Valid values:
   * 
   * *   true: The call was successful.
   * *   false: The call failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyGroupMonitoringAgentProcessResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyGroupMonitoringAgentProcessResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyGroupMonitoringAgentProcessResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyHostAvailabilityRequest extends $tea.Model {
  alertConfig?: ModifyHostAvailabilityRequestAlertConfig;
  taskOption?: ModifyHostAvailabilityRequestTaskOption;
  /**
   * @remarks
   * The alert configurations.
   * 
   * This parameter is required.
   */
  alertConfigEscalationList?: ModifyHostAvailabilityRequestAlertConfigEscalationList[];
  /**
   * @remarks
   * The information about the resources for which alerts are triggered.
   */
  alertConfigTargetList?: ModifyHostAvailabilityRequestAlertConfigTargetList[];
  /**
   * @remarks
   * The ID of the application group.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456
   */
  groupId?: number;
  /**
   * @remarks
   * The ID of the availability monitoring task.
   * 
   * This parameter is required.
   * 
   * @example
   * 12345
   */
  id?: number;
  /**
   * @remarks
   * The ECS instances that are monitored. Valid values of N: 1 to 21.
   * 
   * > This parameter must be specified when `TaskScope` is set to `GROUP_SPEC_INSTANCE`.
   * 
   * @example
   * i-absdfkwl321****
   */
  instanceList?: string[];
  regionId?: string;
  /**
   * @remarks
   * The name of the availability monitoring task.
   * 
   * This parameter is required.
   * 
   * @example
   * task2
   */
  taskName?: string;
  /**
   * @remarks
   * The range of instances that are monitored by the availability monitoring task. Valid values:
   * 
   * *   GROUP: All Elastic Compute Service (ECS) instances in the application group are monitored.
   * *   GROUP_SPEC_INSTANCE: Specified ECS instances in the application group are monitored. The TaskScope parameter must be used in combination with the InstanceList.N parameter. The InstanceList.N parameter specifies the ECS instances to be monitored.
   * 
   * @example
   * GROUP
   */
  taskScope?: string;
  static names(): { [key: string]: string } {
    return {
      alertConfig: 'AlertConfig',
      taskOption: 'TaskOption',
      alertConfigEscalationList: 'AlertConfigEscalationList',
      alertConfigTargetList: 'AlertConfigTargetList',
      groupId: 'GroupId',
      id: 'Id',
      instanceList: 'InstanceList',
      regionId: 'RegionId',
      taskName: 'TaskName',
      taskScope: 'TaskScope',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertConfig: ModifyHostAvailabilityRequestAlertConfig,
      taskOption: ModifyHostAvailabilityRequestTaskOption,
      alertConfigEscalationList: { 'type': 'array', 'itemType': ModifyHostAvailabilityRequestAlertConfigEscalationList },
      alertConfigTargetList: { 'type': 'array', 'itemType': ModifyHostAvailabilityRequestAlertConfigTargetList },
      groupId: 'number',
      id: 'number',
      instanceList: { 'type': 'array', 'itemType': 'string' },
      regionId: 'string',
      taskName: 'string',
      taskScope: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyHostAvailabilityResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code.
   * 
   * > The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The specified resource is not found.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 16E815A3-47E1-4290-87F9-D5C99471FF45
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyHostAvailabilityResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyHostAvailabilityResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyHostAvailabilityResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyHostInfoRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the host.
   * 
   * @example
   * portalHost
   */
  hostName?: string;
  /**
   * @remarks
   * The ID of the instance. Only hosts not on Alibaba Cloud are supported.
   * 
   * This parameter is required.
   * 
   * @example
   * host-R_NSWNV****
   */
  instanceId?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      hostName: 'HostName',
      instanceId: 'InstanceId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      hostName: 'string',
      instanceId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyHostInfoResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the call was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The specified resource is not found.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * EBB5215C-44AB-4000-A2D7-48634FDC4F04
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call was successful. The value true indicates a success. The value false indicates a failure.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyHostInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyHostInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyHostInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyHybridMonitorNamespaceRequest extends $tea.Model {
  /**
   * @remarks
   * The description of the namespace.
   */
  description?: string;
  /**
   * @remarks
   * The name of the namespace.
   * 
   * The name can contain letters, digits, and hyphens (-).
   * 
   * For information about how to obtain the name of a namespace, see [DescribeHybridMonitorNamespaceList](https://help.aliyun.com/document_detail/428880.html).
   * 
   * This parameter is required.
   * 
   * @example
   * aliyun
   */
  namespace?: string;
  regionId?: string;
  /**
   * @remarks
   * The data retention period. Valid values:
   * 
   * *   cms.s1.large: Data is stored for 15 days.
   * *   cms.s1.xlarge: Data is stored for 32 days.
   * *   cms.s1.2xlarge: Data is stored for 63 days.
   * *   cms.s1.3xlarge: Data is stored for 93 days.
   * *   cms.s1.6xlarge: Data is stored for 185 days.
   * *   cms.s1.12xlarge: Data is stored for 376 days.
   * 
   * For information about the pricing for different retention periods, see the **Pricing** section in [Billing of the dashboard feature](https://help.aliyun.com/document_detail/223532.html).
   * 
   * @example
   * cms.s1.2xlarge
   */
  spec?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      namespace: 'Namespace',
      regionId: 'RegionId',
      spec: 'Spec',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      namespace: 'string',
      regionId: 'string',
      spec: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyHybridMonitorNamespaceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * Success
   */
  code?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * %s
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * E190AB2E-7BF9-59B7-9DDC-7CB1782C5ECD
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyHybridMonitorNamespaceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyHybridMonitorNamespaceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyHybridMonitorNamespaceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyHybridMonitorSLSGroupRequest extends $tea.Model {
  regionId?: string;
  /**
   * @remarks
   * The configurations of the Logstore group.
   * 
   * Valid values of N: 1 to 25.
   * 
   * This parameter is required.
   */
  SLSGroupConfig?: ModifyHybridMonitorSLSGroupRequestSLSGroupConfig[];
  /**
   * @remarks
   * The description of the Logstore group.
   */
  SLSGroupDescription?: string;
  /**
   * @remarks
   * The name of the Logstore group.
   * 
   * For information about how to obtain the name of a Logstore group, see [DescribeHybridMonitorSLSGroup](https://help.aliyun.com/document_detail/429526.html).
   * 
   * This parameter is required.
   * 
   * @example
   * Logstore_test
   */
  SLSGroupName?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      SLSGroupConfig: 'SLSGroupConfig',
      SLSGroupDescription: 'SLSGroupDescription',
      SLSGroupName: 'SLSGroupName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      SLSGroupConfig: { 'type': 'array', 'itemType': ModifyHybridMonitorSLSGroupRequestSLSGroupConfig },
      SLSGroupDescription: 'string',
      SLSGroupName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyHybridMonitorSLSGroupResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * > The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * NotFound.SLSGroup
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 66683237-7126-50F8-BBF8-D67ACC919A17
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyHybridMonitorSLSGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyHybridMonitorSLSGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyHybridMonitorSLSGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyHybridMonitorTaskRequest extends $tea.Model {
  /**
   * @remarks
   * The tags of the metric.
   */
  attachLabels?: ModifyHybridMonitorTaskRequestAttachLabels[];
  /**
   * @remarks
   * The collection period of the metric. Valid values:
   * 
   * *   15
   * *   60
   * 
   * Unit: seconds.
   * 
   * @example
   * 15
   */
  collectInterval?: string;
  /**
   * @remarks
   * The description of the metric import task.
   */
  description?: string;
  regionId?: string;
  /**
   * @remarks
   * The configurations of the logs that are imported from Log Service.
   */
  SLSProcessConfig?: ModifyHybridMonitorTaskRequestSLSProcessConfig;
  /**
   * @remarks
   * The ID of the metric import task.
   * 
   * For information about how to obtain the ID of a metric import task, see [DescribeHybridMonitorTaskList](https://help.aliyun.com/document_detail/428624.html).
   * 
   * This parameter is required.
   * 
   * @example
   * 36****
   */
  taskId?: string;
  /**
   * @remarks
   * The name of the metric import task.
   * 
   * For information about how to obtain the ID of a metric import task, see [DescribeHybridMonitorTaskList](https://help.aliyun.com/document_detail/428624.html).
   * 
   * @example
   * SLS_task
   */
  taskName?: string;
  static names(): { [key: string]: string } {
    return {
      attachLabels: 'AttachLabels',
      collectInterval: 'CollectInterval',
      description: 'Description',
      regionId: 'RegionId',
      SLSProcessConfig: 'SLSProcessConfig',
      taskId: 'TaskId',
      taskName: 'TaskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attachLabels: { 'type': 'array', 'itemType': ModifyHybridMonitorTaskRequestAttachLabels },
      collectInterval: 'string',
      description: 'string',
      regionId: 'string',
      SLSProcessConfig: ModifyHybridMonitorTaskRequestSLSProcessConfig,
      taskId: 'string',
      taskName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyHybridMonitorTaskResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code.
   * 
   * > The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * Invalid.SLSConfig
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 11145B76-566A-5D80-A8A3-FAD98D310079
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyHybridMonitorTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyHybridMonitorTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyHybridMonitorTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyMetricRuleBlackListRequest extends $tea.Model {
  /**
   * @remarks
   * The category of the cloud service. For example, ApsaraDB for Redis supports the standard architecture, the cluster architecture, and the read/write splitting architecture. In this case, the valid values of this parameter for ApsaraDB for Redis include `kvstore_standard`, `kvstore_sharding`, and `kvstore_splitrw`.
   * 
   * This parameter is required.
   * 
   * @example
   * ecs
   */
  category?: string;
  /**
   * @remarks
   * The time range within which the blacklist policy is effective. Take note of the following information:
   * 
   * *   If you do not configure this parameter, the blacklist policy is permanently effective.
   * 
   * *   If you configure this parameter, the blacklist policy is effective only within the specified time range. Examples:
   * 
   *     *   `03:00-04:59`: The blacklist policy is effective from 03:00 to 05:00 local time. 05:00 local time is excluded.
   *     *   `03:00-04:59 UTC+0700`: The blacklist policy is effective from 03:00 to 05:00 (UTC+7). 05:00 (UTC+7) is excluded.
   * 
   * @example
   * 03:00-04:59
   */
  effectiveTime?: string;
  /**
   * @remarks
   * The timestamp when the blacklist policy expires.
   * 
   * Unit: milliseconds.
   * 
   * @example
   * 1640608200000
   */
  enableEndTime?: string;
  /**
   * @remarks
   * The timestamp when the blacklist policy starts to take effect.
   * 
   * Unit: milliseconds.
   * 
   * @example
   * 1640237400000
   */
  enableStartTime?: string;
  /**
   * @remarks
   * The ID of the blacklist policy.
   * 
   * For information about how to obtain the ID of a blacklist policy, see [DescribeMetricRuleBlackList](https://help.aliyun.com/document_detail/457257.html).
   * 
   * This parameter is required.
   * 
   * @example
   * 93514c96-ceb8-47d8-8ee3-93b6d98b****
   */
  id?: string;
  /**
   * @remarks
   * The IDs of the instances that belong to the specified cloud service.
   * 
   * This parameter is required.
   */
  instances?: string[];
  /**
   * @remarks
   * The metrics of the instance.
   * 
   * *   If you do not configure this parameter, the blacklist policy applies to all metrics of the specified cloud service.
   * *   If you configure this parameter, the blacklist policy applies only to the current metric.
   */
  metrics?: ModifyMetricRuleBlackListRequestMetrics[];
  /**
   * @remarks
   * The name of the blacklist policy.
   * 
   * This parameter is required.
   * 
   * @example
   * Blacklist-02
   */
  name?: string;
  /**
   * @remarks
   * The namespace of the cloud service.
   * 
   * For more information about the namespaces of cloud services, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * This parameter is required.
   * 
   * @example
   * acs_ecs_dashboard
   */
  namespace?: string;
  regionId?: string;
  /**
   * @remarks
   * The effective scope of the blacklist policy. Valid values:
   * 
   * *   USER: The blacklist policy takes effect only within the current Alibaba Cloud account.
   * *   GROUP (default): The blacklist policy takes effect only within the specified application group. For information about how to obtain the ID of an application group, see [DescribeMonitorGroups](https://help.aliyun.com/document_detail/115032.html).
   * 
   * @example
   * USER
   */
  scopeType?: string;
  /**
   * @remarks
   * The IDs of the application groups.
   * 
   * >  This parameter is required only when `ScopeType` is set to `GROUP`.
   * 
   * @example
   * ["67****","78****"]
   */
  scopeValue?: string;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      effectiveTime: 'EffectiveTime',
      enableEndTime: 'EnableEndTime',
      enableStartTime: 'EnableStartTime',
      id: 'Id',
      instances: 'Instances',
      metrics: 'Metrics',
      name: 'Name',
      namespace: 'Namespace',
      regionId: 'RegionId',
      scopeType: 'ScopeType',
      scopeValue: 'ScopeValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      effectiveTime: 'string',
      enableEndTime: 'string',
      enableStartTime: 'string',
      id: 'string',
      instances: { 'type': 'array', 'itemType': 'string' },
      metrics: { 'type': 'array', 'itemType': ModifyMetricRuleBlackListRequestMetrics },
      name: 'string',
      namespace: 'string',
      regionId: 'string',
      scopeType: 'string',
      scopeValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyMetricRuleBlackListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * > The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The number of blacklist policies that are modified.
   * 
   * @example
   * 1
   */
  count?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The specified resource is not found.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 008773AE-1D86-3231-90F9-1AF7F808F9CE
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      count: 'Count',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      count: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyMetricRuleBlackListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyMetricRuleBlackListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyMetricRuleBlackListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyMetricRuleTemplateRequest extends $tea.Model {
  /**
   * @remarks
   * The details of the alert template.
   */
  alertTemplates?: ModifyMetricRuleTemplateRequestAlertTemplates[];
  /**
   * @remarks
   * The description of the alert template.
   * 
   * @example
   * ECS_template1
   */
  description?: string;
  /**
   * @remarks
   * The name of the alert template.
   * 
   * For information about how to obtain the name of an alert template, see [DescribeMetricRuleTemplateList](https://help.aliyun.com/document_detail/114982.html).
   * 
   * @example
   * test123
   */
  name?: string;
  regionId?: string;
  /**
   * @remarks
   * The version of the alert template. The version changes with the number of times that the alert template is modified.
   * 
   * For information about how to obtain the version of an alert template, see [DescribeMetricRuleTemplateList](https://help.aliyun.com/document_detail/114982.html).
   * 
   * This parameter is required.
   * 
   * @example
   * 0
   */
  restVersion?: number;
  /**
   * @remarks
   * The ID of the alert template.
   * 
   * For information about how to obtain the ID of an alert template, see [DescribeMetricRuleTemplateList](https://help.aliyun.com/document_detail/114982.html).
   * 
   * This parameter is required.
   * 
   * @example
   * 123456
   */
  templateId?: number;
  static names(): { [key: string]: string } {
    return {
      alertTemplates: 'AlertTemplates',
      description: 'Description',
      name: 'Name',
      regionId: 'RegionId',
      restVersion: 'RestVersion',
      templateId: 'TemplateId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertTemplates: { 'type': 'array', 'itemType': ModifyMetricRuleTemplateRequestAlertTemplates },
      description: 'string',
      name: 'string',
      regionId: 'string',
      restVersion: 'number',
      templateId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyMetricRuleTemplateResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * > The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The Request is not authorization.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 9E07117F-F6AE-4F1C-81E8-36FBB4892235
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyMetricRuleTemplateResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyMetricRuleTemplateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyMetricRuleTemplateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyMonitorGroupRequest extends $tea.Model {
  /**
   * @remarks
   * The alert groups that can receive alert notifications for the application group.
   * 
   * @example
   * alarm_ecs_group
   */
  contactGroups?: string;
  /**
   * @remarks
   * The ID of the application group.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456
   */
  groupId?: string;
  /**
   * @remarks
   * The name of the application group.
   * 
   * @example
   * ecs_group
   */
  groupName?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      contactGroups: 'ContactGroups',
      groupId: 'GroupId',
      groupName: 'GroupName',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contactGroups: 'string',
      groupId: 'string',
      groupName: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyMonitorGroupResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the call was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The specified resource is not found.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * C85A2870-5DF4-4269-BC50-ECB5E4591A80
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call was successful. Valid values:
   * 
   * *   true: The call was successful.
   * *   false: The call failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyMonitorGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyMonitorGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyMonitorGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyMonitorGroupInstancesRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the application group.
   * 
   * This parameter is required.
   * 
   * @example
   * 12345
   */
  groupId?: number;
  /**
   * @remarks
   * This parameter is required.
   */
  instances?: ModifyMonitorGroupInstancesRequestInstances[];
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      instances: 'Instances',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'number',
      instances: { 'type': 'array', 'itemType': ModifyMonitorGroupInstancesRequestInstances },
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyMonitorGroupInstancesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the call was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * FEC7EDB3-9B08-4AC0-A42A-329F5D14B95A
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call was successful. The value true indicates a success. The value false indicates a failure.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyMonitorGroupInstancesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyMonitorGroupInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyMonitorGroupInstancesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifySiteMonitorRequest extends $tea.Model {
  /**
   * @remarks
   * The URL or IP address that is monitored by the task.
   * 
   * @example
   * http://www.aliyun.com
   */
  address?: string;
  /**
   * @remarks
   * The ID of the alert rule. You can call the DescribeMetricRuleList operation to query the IDs of existing alert rules in CloudMonitor. For more information, see [DescribeMetricRuleList](https://help.aliyun.com/document_detail/114941.html).
   * 
   * @example
   * 49f7c317-7645-4cc9-94fd-ea42e122****
   */
  alertIds?: string;
  /**
   * @remarks
   * The custom detection period. You can only select a time period from Monday to Sunday for detection.
   * 
   * @example
   * {"start_hour":0,"end_hour":24, "days":[0], "time_zone":"Local"}
   */
  customSchedule?: string;
  /**
   * @remarks
   * The interval at which detection requests are sent. Valid values: 1, 5, and 15. Unit: minutes. Default value: 1.
   * 
   * @example
   * 1
   */
  interval?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * Unit: milliseconds.
   * 
   * @example
   * ms
   */
  intervalUnit?: string;
  /**
   * @remarks
   * The information of the detection points. The value is a JSON array. Example: `[{"city":"546","isp":"465"},{"city":"572","isp":"465"},{"city":"738","isp":"465"}]`. The values of the `city` field indicate Beijing, Hangzhou, and Qingdao.
   * 
   * > You can call the DescribeSiteMonitorISPCityList operation to query the detection points. For more information, see [DescribeSiteMonitorISPCityList](https://help.aliyun.com/document_detail/115045.html). If you leave this parameter empty, the system randomly selects three detection points.
   * 
   * @example
   * [{"city":"546","isp":"465"},{"city":"572","isp":"465"},{"city":"738","isp":"465"}]
   */
  ispCities?: string;
  /**
   * @remarks
   * The extended options of the protocol that is used by the site monitoring task. The options vary based on the protocol.
   * 
   * @example
   * {"time_out":5000}
   */
  optionsJson?: string;
  regionId?: string;
  /**
   * @remarks
   * The ID of the site monitoring task.
   * 
   * This parameter is required.
   * 
   * @example
   * 2c8dbdf9-a3ab-46a1-85a4-f094965e****
   */
  taskId?: string;
  /**
   * @remarks
   * The name of the site monitoring task. The name must be 4 to 100 characters in length, and can contain letters, digits, and underscores (_).
   * 
   * @example
   * HanZhou_ECS2
   */
  taskName?: string;
  static names(): { [key: string]: string } {
    return {
      address: 'Address',
      alertIds: 'AlertIds',
      customSchedule: 'CustomSchedule',
      interval: 'Interval',
      intervalUnit: 'IntervalUnit',
      ispCities: 'IspCities',
      optionsJson: 'OptionsJson',
      regionId: 'RegionId',
      taskId: 'TaskId',
      taskName: 'TaskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      address: 'string',
      alertIds: 'string',
      customSchedule: 'string',
      interval: 'string',
      intervalUnit: 'string',
      ispCities: 'string',
      optionsJson: 'string',
      regionId: 'string',
      taskId: 'string',
      taskName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifySiteMonitorResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * > The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The result of modifying the task.
   */
  data?: ModifySiteMonitorResponseBodyData;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * successful
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 68192f5d-0d45-4b98-9724-892813f86c71
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: ModifySiteMonitorResponseBodyData,
      message: 'string',
      requestId: 'string',
      success: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifySiteMonitorResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifySiteMonitorResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifySiteMonitorResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OpenCmsServiceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the order.
   * 
   * @example
   * 211206750270***
   */
  orderId?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * E5A72B5B-4F44-438C-B68A-147FD5DC53A8
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OpenCmsServiceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: OpenCmsServiceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: OpenCmsServiceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutContactRequest extends $tea.Model {
  channels?: PutContactRequestChannels;
  /**
   * @remarks
   * The name of the alert contact.
   * 
   * This parameter is required.
   * 
   * @example
   * Alice
   */
  contactName?: string;
  /**
   * @remarks
   * The description of the alert contact.
   * 
   * This parameter is required.
   * 
   * @example
   * ECS_Instance
   */
  describe?: string;
  /**
   * @remarks
   * The language in which the alert information is displayed. Valid values:
   * 
   * *   zh-cn: simplified Chinese
   * *   en: English
   * 
   * >  If you do not specify a value for this parameter, Cloud Monitor identifies the language of the alert information based on the region of your Alibaba Cloud account.
   * 
   * @example
   * zh-cn
   */
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      channels: 'Channels',
      contactName: 'ContactName',
      describe: 'Describe',
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channels: PutContactRequestChannels,
      contactName: 'string',
      describe: 'string',
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutContactResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the call was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * The Request is not authorization.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 181C406E-9DE4-484C-9C61-37AE9A1A12EE
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call was successful. Valid values:
   * 
   * *   true: The call was successful.
   * *   false: The call failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutContactResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: PutContactResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PutContactResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutContactGroupRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the alert contact group.
   * 
   * For information about how to obtain the name of an alert contact group, see [DescribeContactGroupList](https://help.aliyun.com/document_detail/114922.html).
   * 
   * This parameter is required.
   * 
   * @example
   * ECS_Group
   */
  contactGroupName?: string;
  /**
   * @example
   * Alice
   */
  contactNames?: string[];
  /**
   * @remarks
   * The description of the alert contact group.
   * 
   * @example
   * ECS_Alert_Group
   */
  describe?: string;
  /**
   * @remarks
   * Specifies whether to enable the weekly report subscription feature. Valid values:
   * 
   * *   true: The weekly report subscription feature is enabled.
   * *   false: The weekly report subscription feature is disabled.
   * 
   * >  You can enable the weekly report subscription only for an Alibaba Cloud account that has at least five Elastic Compute Service (ECS) instances.
   * 
   * @example
   * true
   */
  enableSubscribed?: boolean;
  static names(): { [key: string]: string } {
    return {
      contactGroupName: 'ContactGroupName',
      contactNames: 'ContactNames',
      describe: 'Describe',
      enableSubscribed: 'EnableSubscribed',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contactGroupName: 'string',
      contactNames: { 'type': 'array', 'itemType': 'string' },
      describe: 'string',
      enableSubscribed: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutContactGroupResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the call was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * Illegal parameters.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * B4E30DB6-F069-5D0B-A589-2A89F7D62A57
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call was successful. Valid values:
   * 
   * *   true: The call was successful.
   * *   false: The call failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutContactGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: PutContactGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PutContactGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutCustomEventRequest extends $tea.Model {
  /**
   * @remarks
   * The event details.
   * 
   * This parameter is required.
   */
  eventInfo?: PutCustomEventRequestEventInfo[];
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      eventInfo: 'EventInfo',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventInfo: { 'type': 'array', 'itemType': PutCustomEventRequestEventInfo },
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutCustomEventResponseBody extends $tea.Model {
  /**
   * @remarks
   * The responses code.
   * 
   * >  The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 131DD9C8-9A32-4428-AD2E-4E3013B6E3A7
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutCustomEventResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: PutCustomEventResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PutCustomEventResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutCustomEventRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The alert contact group that receives alert notifications. Separate multiple contact groups with commas (,).
   * 
   * This parameter is required.
   * 
   * @example
   * ECS_Group
   */
  contactGroups?: string;
  /**
   * @remarks
   * The time period during which the alert rule is effective. Valid values: 00:00 to 23:59.
   * 
   * @example
   * 00:00-23:59
   */
  effectiveInterval?: string;
  /**
   * @remarks
   * The subject of the alert notification email.
   */
  emailSubject?: string;
  /**
   * @remarks
   * The name of the custom event. For more information about how to obtain the event name, see [DescribeCustomEventAttribute](https://help.aliyun.com/document_detail/115262.html).
   * 
   * This parameter is required.
   * 
   * @example
   * HostDown
   */
  eventName?: string;
  /**
   * @remarks
   * The ID of the application group. For more information about how to obtain the group ID, see [DescribeCustomEventAttribute](https://help.aliyun.com/document_detail/115262.html).
   * 
   * >  The value 0 indicates that the reported custom event does not belong to any application Group.
   * 
   * This parameter is required.
   * 
   * @example
   * 7378****
   */
  groupId?: string;
  /**
   * @remarks
   * The level of the alert. Valid values:
   * 
   * *   CRITICAL: critical issue
   * *   WARN: warning
   * *   INFO: information
   * 
   * This parameter is required.
   * 
   * @example
   * CRITICAL
   */
  level?: string;
  /**
   * @remarks
   * The cycle that is used to aggregate monitoring data of the custom event. Unit: seconds. Set the value to an integral multiple of 60. Default value: 300.
   * 
   * @example
   * 60
   */
  period?: string;
  /**
   * @remarks
   * The ID of the alert rule.
   * 
   * >  You can specify an existing ID to modify the corresponding alert rule or specify a new ID to create an alert rule.
   * 
   * This parameter is required.
   * 
   * @example
   * CustomRuleId1
   */
  ruleId?: string;
  /**
   * @remarks
   * The name of the alert rule.
   * 
   * This parameter is required.
   * 
   * @example
   * CustomeRule
   */
  ruleName?: string;
  /**
   * @remarks
   * The alert threshold.
   * 
   * This parameter is required.
   * 
   * @example
   * 99
   */
  threshold?: string;
  /**
   * @remarks
   * The callback URL to which a POST request is sent when an alert is triggered based on the alert rule.
   * 
   * @example
   * https://www.aliyun.com
   */
  webhook?: string;
  static names(): { [key: string]: string } {
    return {
      contactGroups: 'ContactGroups',
      effectiveInterval: 'EffectiveInterval',
      emailSubject: 'EmailSubject',
      eventName: 'EventName',
      groupId: 'GroupId',
      level: 'Level',
      period: 'Period',
      ruleId: 'RuleId',
      ruleName: 'RuleName',
      threshold: 'Threshold',
      webhook: 'Webhook',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contactGroups: 'string',
      effectiveInterval: 'string',
      emailSubject: 'string',
      eventName: 'string',
      groupId: 'string',
      level: 'string',
      period: 'string',
      ruleId: 'string',
      ruleName: 'string',
      threshold: 'string',
      webhook: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutCustomEventRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The value 200 indicates that the call was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The request has failed due to a temporary failure of the server.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * AD5DCD82-BD1C-405F-BAED-32302DE9F498
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call was successful. Valid values:
   * 
   * *   true: The call was successful.
   * *   false: The call failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutCustomEventRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: PutCustomEventRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PutCustomEventRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutCustomMetricRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   */
  metricList?: PutCustomMetricRequestMetricList[];
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      metricList: 'MetricList',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      metricList: { 'type': 'array', 'itemType': PutCustomMetricRequestMetricList },
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutCustomMetricResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the call was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The request has failed due to a temporary failure of the server.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 05B36C2C-5F6E-48D5-8B41-CE36DD7EE8E0
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutCustomMetricResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: PutCustomMetricResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PutCustomMetricResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutCustomMetricRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The comparison operator before the threshold. Valid values:
   * 
   * *   `>=`
   * *   `=`
   * *   `<=`
   * *   `>`
   * *   `<`
   * *   `!=`
   * 
   * This parameter is required.
   * 
   * @example
   * >=
   */
  comparisonOperator?: string;
  /**
   * @remarks
   * The alert group that receives alert notifications. Separate multiple alert groups with commas (,).
   * 
   * This parameter is required.
   * 
   * @example
   * ECS_Group
   */
  contactGroups?: string;
  /**
   * @remarks
   * The time period during which the alert rule is effective. Valid values: 00:00 to 23:59.
   * 
   * @example
   * 00:00-23:59
   */
  effectiveInterval?: string;
  /**
   * @remarks
   * The subject of the alert notification email.
   */
  emailSubject?: string;
  /**
   * @remarks
   * The consecutive number of times for which the metric value is measured before an alert is triggered.
   * 
   * This parameter is required.
   * 
   * @example
   * 3
   */
  evaluationCount?: number;
  /**
   * @remarks
   * The ID of the application group to which the custom monitoring data belongs.
   * 
   * >  The value 0 indicates that the reported custom monitoring data does not belong to an application group.
   * 
   * @example
   * 7378****
   */
  groupId?: string;
  /**
   * @remarks
   * The level of the alert. Valid values:
   * 
   * *   CRITICAL
   * *   WARN
   * *   INFO
   * 
   * This parameter is required.
   * 
   * @example
   * CRITICAL
   */
  level?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * >  For more information about how to obtain the metric name, see [DescribeCustomMetricList](https://help.aliyun.com/document_detail/115005.html).
   * 
   * This parameter is required.
   * 
   * @example
   * cpu_total
   */
  metricName?: string;
  /**
   * @remarks
   * The cycle that is used to aggregate custom monitoring data. Unit: seconds. Set the value to an integral multiple of 60. The original reporting cycle of custom monitoring data is used by default.
   * 
   * @example
   * 300
   */
  period?: string;
  /**
   * @remarks
   * The custom monitoring data to which the alert rule applies. The value includes the application group ID to which the custom monitoring data belongs and the dimension to which the metric belongs.
   * 
   * This parameter is required.
   * 
   * @example
   * [{"groupId":7378****,"dimension":"instanceId=i-hp3543t5e4sudb3s****"}]
   */
  resources?: string;
  /**
   * @remarks
   * The ID of the alert rule.
   * 
   * >  You can specify an existing ID to modify the corresponding alert rule or specify a new ID to create an alert rule.
   * 
   * This parameter is required.
   * 
   * @example
   * MyRuleId1
   */
  ruleId?: string;
  /**
   * @remarks
   * The name of the alert rule.
   * 
   * @example
   * CpuUsage
   */
  ruleName?: string;
  /**
   * @remarks
   * The mute period during which notifications are not repeatedly sent for an alert. Unit: seconds. Default value: 86400. The default value indicates one day.
   * 
   * >  Only one alert notification is sent during each mute period even if the metric value consecutively exceeds the alert threshold several times.
   * 
   * @example
   * 86400
   */
  silenceTime?: number;
  /**
   * @remarks
   * The method that is used to calculate the metric values that trigger alerts.
   * 
   * This parameter is required.
   * 
   * @example
   * Average
   */
  statistics?: string;
  /**
   * @remarks
   * The threshold of the metric value.
   * 
   * This parameter is required.
   * 
   * @example
   * 90
   */
  threshold?: string;
  /**
   * @remarks
   * The callback URL to which a POST request is sent when an alert is triggered based on the alert rule.
   * 
   * @example
   * https://www.aliyun.com
   */
  webhook?: string;
  static names(): { [key: string]: string } {
    return {
      comparisonOperator: 'ComparisonOperator',
      contactGroups: 'ContactGroups',
      effectiveInterval: 'EffectiveInterval',
      emailSubject: 'EmailSubject',
      evaluationCount: 'EvaluationCount',
      groupId: 'GroupId',
      level: 'Level',
      metricName: 'MetricName',
      period: 'Period',
      resources: 'Resources',
      ruleId: 'RuleId',
      ruleName: 'RuleName',
      silenceTime: 'SilenceTime',
      statistics: 'Statistics',
      threshold: 'Threshold',
      webhook: 'Webhook',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comparisonOperator: 'string',
      contactGroups: 'string',
      effectiveInterval: 'string',
      emailSubject: 'string',
      evaluationCount: 'number',
      groupId: 'string',
      level: 'string',
      metricName: 'string',
      period: 'string',
      resources: 'string',
      ruleId: 'string',
      ruleName: 'string',
      silenceTime: 'number',
      statistics: 'string',
      threshold: 'string',
      webhook: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutCustomMetricRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The value 200 indicates that the call was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The returned message. If the call was successful, the return value is null. If the call failed, an error message is returned.
   * 
   * @example
   * ComparisonOperator is mandatory for this action.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 65D50468-ECEF-48F1-A6E1-D952E89D9432
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call was successful. Valid values:
   * 
   * *   true: The call was successful.
   * *   false: The call failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutCustomMetricRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: PutCustomMetricRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PutCustomMetricRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutEventRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The description of the event-triggered alert rule.
   */
  description?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  eventPattern?: PutEventRuleRequestEventPattern[];
  /**
   * @remarks
   * The type of the event-triggered alert rule. Valid values:
   * 
   * *   SYSTEM: system event-triggered alert rule
   * *   CUSTOM: custom event-triggered alert rule
   * 
   * @example
   * SYSTEM
   */
  eventType?: string;
  /**
   * @remarks
   * The ID of the application group to which the event-triggered alert rule belongs.
   * 
   * @example
   * 7378****
   */
  groupId?: string;
  regionId?: string;
  /**
   * @remarks
   * The name of the event-triggered alert rule.
   * 
   * This parameter is required.
   * 
   * @example
   * myRuleName
   */
  ruleName?: string;
  /**
   * @remarks
   * The mute period during which new alerts are not sent even if the trigger conditions are met. Unit: seconds.
   * 
   * @example
   * 86400
   */
  silenceTime?: number;
  /**
   * @remarks
   * The status of the event-triggered alert rule. Valid values:
   * 
   * *   ENABLED: enabled
   * *   DISABLED: disabled
   * 
   * @example
   * ENABLED
   */
  state?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      eventPattern: 'EventPattern',
      eventType: 'EventType',
      groupId: 'GroupId',
      regionId: 'RegionId',
      ruleName: 'RuleName',
      silenceTime: 'SilenceTime',
      state: 'State',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      eventPattern: { 'type': 'array', 'itemType': PutEventRuleRequestEventPattern },
      eventType: 'string',
      groupId: 'string',
      regionId: 'string',
      ruleName: 'string',
      silenceTime: 'number',
      state: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutEventRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the call was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The number of event-triggered alert rules that were created or modified.
   * 
   * @example
   * 1
   */
  data?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The Request is not authorization.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0B47C47B-E68A-4429-BB23-370E91889C7D
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call was successful. Valid values:
   * 
   * *   true: The call was successful.
   * *   false: The call failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutEventRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: PutEventRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PutEventRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutEventRuleTargetsRequest extends $tea.Model {
  /**
   * @remarks
   * The information about the alert contact groups that receive alert notifications.
   */
  contactParameters?: PutEventRuleTargetsRequestContactParameters[];
  /**
   * @remarks
   * The information about the recipients in Function Compute.
   */
  fcParameters?: PutEventRuleTargetsRequestFcParameters[];
  /**
   * @remarks
   * The information about the recipients in Message Service (MNS).
   */
  mnsParameters?: PutEventRuleTargetsRequestMnsParameters[];
  /**
   * @remarks
   * The parameters of API callback notification.
   */
  openApiParameters?: PutEventRuleTargetsRequestOpenApiParameters[];
  regionId?: string;
  /**
   * @remarks
   * The name of the alert rule.
   * 
   * This parameter is required.
   * 
   * @example
   * testEventRule
   */
  ruleName?: string;
  /**
   * @remarks
   * The information about the recipients in Simple Log Service.
   */
  slsParameters?: PutEventRuleTargetsRequestSlsParameters[];
  /**
   * @remarks
   * The information about the callback URLs that are used to receive alert notifications.
   */
  webhookParameters?: PutEventRuleTargetsRequestWebhookParameters[];
  static names(): { [key: string]: string } {
    return {
      contactParameters: 'ContactParameters',
      fcParameters: 'FcParameters',
      mnsParameters: 'MnsParameters',
      openApiParameters: 'OpenApiParameters',
      regionId: 'RegionId',
      ruleName: 'RuleName',
      slsParameters: 'SlsParameters',
      webhookParameters: 'WebhookParameters',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contactParameters: { 'type': 'array', 'itemType': PutEventRuleTargetsRequestContactParameters },
      fcParameters: { 'type': 'array', 'itemType': PutEventRuleTargetsRequestFcParameters },
      mnsParameters: { 'type': 'array', 'itemType': PutEventRuleTargetsRequestMnsParameters },
      openApiParameters: { 'type': 'array', 'itemType': PutEventRuleTargetsRequestOpenApiParameters },
      regionId: 'string',
      ruleName: 'string',
      slsParameters: { 'type': 'array', 'itemType': PutEventRuleTargetsRequestSlsParameters },
      webhookParameters: { 'type': 'array', 'itemType': PutEventRuleTargetsRequestWebhookParameters },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutEventRuleTargetsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * This parameter is returned if the specified alert contact groups in the request failed to be created or modified.
   */
  failedContactParameters?: PutEventRuleTargetsResponseBodyFailedContactParameters;
  /**
   * @remarks
   * This parameter is returned if the specified functions in the request failed to be created or modified in Function Compute.
   */
  failedFcParameters?: PutEventRuleTargetsResponseBodyFailedFcParameters;
  /**
   * @remarks
   * This parameter is returned if the specified queues in the request failed to be created or modified in MNS.
   */
  failedMnsParameters?: PutEventRuleTargetsResponseBodyFailedMnsParameters;
  /**
   * @remarks
   * The number of resources that failed to be created or modified.
   * 
   * @example
   * 2
   */
  failedParameterCount?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The Request is not authorization.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 409C64DA-CF14-45DF-B463-471C790DD15A
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values: true and false.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      failedContactParameters: 'FailedContactParameters',
      failedFcParameters: 'FailedFcParameters',
      failedMnsParameters: 'FailedMnsParameters',
      failedParameterCount: 'FailedParameterCount',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      failedContactParameters: PutEventRuleTargetsResponseBodyFailedContactParameters,
      failedFcParameters: PutEventRuleTargetsResponseBodyFailedFcParameters,
      failedMnsParameters: PutEventRuleTargetsResponseBodyFailedMnsParameters,
      failedParameterCount: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutEventRuleTargetsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: PutEventRuleTargetsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PutEventRuleTargetsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutExporterOutputRequest extends $tea.Model {
  /**
   * @remarks
   * The configuration set for exporting monitoring data. It is a JSON object string. The string must include the following fields:
   * 
   * *   endpoint: the endpoint of Log Service.
   * *   project: the Log Service project to which monitoring data is exported.
   * *   logstore: the Log Service Logstore to which the monitoring data is exported.
   * *   ak: the AccessKey ID.
   * *   as: the AccessKey secret.
   * 
   * This parameter is required.
   * 
   * @example
   * { "endpoint": "http://cn-qingdao-share.log.aliyuncs.com", "project": "exporter", "logstore": "exporter","ak": "LTAIp*******", "userId": "17754********", "as": "TxHwuJ8yAb3AU******"}
   */
  configJson?: string;
  /**
   * @remarks
   * The description of the configuration set.
   * 
   * @example
   * Export CPU metrics
   */
  desc?: string;
  /**
   * @remarks
   * The name of the configuration set.
   * 
   * This parameter is required.
   * 
   * @example
   * exporterConfig
   */
  destName?: string;
  /**
   * @remarks
   * The service to which the monitoring data is exported.
   * 
   * @example
   * sls
   */
  destType?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      configJson: 'ConfigJson',
      desc: 'Desc',
      destName: 'DestName',
      destType: 'DestType',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configJson: 'string',
      desc: 'string',
      destName: 'string',
      destType: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutExporterOutputResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * > The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * The Request is not authorization.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 6A5F022D-AC7C-460E-94AE-B9E75083D027
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. true: The request was successful. false: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutExporterOutputResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: PutExporterOutputResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PutExporterOutputResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutExporterRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The description of the data export rule.
   * 
   * @example
   * Export CPU metrics
   */
  describe?: string;
  /**
   * @remarks
   * The destination to which the data is exported. Valid values of N: 1 to 20.
   * 
   * This parameter is required.
   * 
   * @example
   * distName1
   */
  dstNames?: string[];
  /**
   * @remarks
   * The name of the metric.
   * 
   * > 
   * 
   * For more information, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * @example
   * cpu_total
   */
  metricName?: string;
  /**
   * @remarks
   * The namespace of the cloud service.
   * 
   * > For more information, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * @example
   * acs_ecs_dashboard
   */
  namespace?: string;
  regionId?: string;
  /**
   * @remarks
   * The name of the rule.
   * 
   * > If the specified rule exists, the existing rule is modified. Otherwise, a rule is created.
   * 
   * @example
   * MyRuleName
   */
  ruleName?: string;
  /**
   * @remarks
   * The time window of the exported data. Unit: seconds.
   * 
   * > 
   * 
   * *   Separate multiple time windows with commas (,).
   * 
   * *   Data in a time window of less than 60 seconds cannot be exported.
   * 
   * @example
   * 60,300
   */
  targetWindows?: string;
  static names(): { [key: string]: string } {
    return {
      describe: 'Describe',
      dstNames: 'DstNames',
      metricName: 'MetricName',
      namespace: 'Namespace',
      regionId: 'RegionId',
      ruleName: 'RuleName',
      targetWindows: 'TargetWindows',
    };
  }

  static types(): { [key: string]: any } {
    return {
      describe: 'string',
      dstNames: { 'type': 'array', 'itemType': 'string' },
      metricName: 'string',
      namespace: 'string',
      regionId: 'string',
      ruleName: 'string',
      targetWindows: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutExporterRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * > The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The returned message. If the request was successful, "successful" is returned. If the request failed, an error message is returned.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 461CF2CD-2FC3-4B26-8645-7BD27E7D0F1D
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutExporterRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: PutExporterRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PutExporterRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutGroupMetricRuleRequest extends $tea.Model {
  escalations?: PutGroupMetricRuleRequestEscalations;
  /**
   * @remarks
   * The abbreviation of the cloud service name.
   * 
   * For more information about how to obtain the abbreviation of a cloud service name, see `metricCategory` in the response parameter `Labels` of the [DescribeProjectMeta](https://help.aliyun.com/document_detail/114916.html) operation.
   * 
   * @example
   * ECS
   */
  category?: string;
  /**
   * @remarks
   * The alert contact group.
   * 
   * @example
   * ECS_Group
   */
  contactGroups?: string;
  /**
   * @remarks
   * The first-level dimension of the alert rule in the application group.
   * 
   * Set the value to a set of key-value pairs, for example, `userId:120886317861****` or `instanceId:i-m5e1qg6uo38rztr4****`.
   * 
   * @example
   * [{"instanceId":"i-m5e1qg6uo38rztr4****"}]
   */
  dimensions?: string;
  /**
   * @remarks
   * The time period during which the alert rule is effective.
   * 
   * @example
   * 05:31-23:59
   */
  effectiveInterval?: string;
  /**
   * @remarks
   * The subject of the alert notification email.
   */
  emailSubject?: string;
  /**
   * @remarks
   * The second-level or third-level dimension of the alert rule in the application group.
   * 
   * Set the value to a set of key-value pairs, for example, `port:80` or `/dev/xvda:d-m5e6yphgzn3aprwu****`.
   * 
   * If the first-level dimension of the alert rule is `instanceId:i-m5e1qg6uo38rztr4****`, its second-level dimension is the `/dev/xvda:d-m5e6yphgzn3aprwu****` disk in the instance.
   * 
   * @example
   * {"/dev/xvda":"d-m5e6yphgzn3aprwu****"}
   */
  extraDimensionJson?: string;
  /**
   * @remarks
   * The application group ID.
   * 
   * For more information about how to obtain the ID of an application group, see [DescribeMonitorGroups](https://help.aliyun.com/document_detail/115032.html).
   * 
   * This parameter is required.
   * 
   * @example
   * 17285****
   */
  groupId?: string;
  /**
   * @remarks
   * The interval at which CloudMonitor checks whether the alert rule is triggered. Unit: seconds.
   * 
   * >  We recommend that you set the interval to the data aggregation period. If the interval is shorter than the data aggregation period, alerts cannot be triggered due to insufficient data.
   * 
   * @example
   * 60
   */
  interval?: string;
  /**
   * @remarks
   * The tags of the alert rule.
   * 
   * The specified tag is contained in alert notifications.
   */
  labels?: PutGroupMetricRuleRequestLabels[];
  /**
   * @remarks
   * The metric name.
   * 
   * For more information about how to obtain the name of a metric, see [DescribeMetricMetaList](https://help.aliyun.com/document_detail/98846.html) or [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * This parameter is required.
   * 
   * @example
   * cpu_total
   */
  metricName?: string;
  /**
   * @remarks
   * The namespace of the cloud service.
   * 
   * For more information about how to obtain the namespace of a cloud service, see [DescribeMetricMetaList](https://help.aliyun.com/document_detail/98846.html) or [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * This parameter is required.
   * 
   * @example
   * acs_ecs_dashboard
   */
  namespace?: string;
  /**
   * @remarks
   * The method that is used to handle alerts when no monitoring data is found. Valid values:
   * 
   * *   KEEP_LAST_STATE (default): No operation is performed.
   * *   INSUFFICIENT_DATA: An alert whose content is "Insufficient data" is triggered.
   * *   OK: The status is considered normal.
   * 
   * @example
   * KEEP_LAST_STATE
   */
  noDataPolicy?: string;
  /**
   * @remarks
   * The time period during which the alert rule is ineffective.
   * 
   * @example
   * 00:00-05:30
   */
  noEffectiveInterval?: string;
  options?: string;
  /**
   * @remarks
   * The aggregation period of the metric data.
   * 
   * Set the `Period` parameter to an integral multiple of 60. Unit: seconds. Default value: 300.
   * 
   * @example
   * 60
   */
  period?: string;
  /**
   * @remarks
   * The ID of the alert rule.
   * 
   * *   When you create an alert rule for the application group, enter the ID of the alert rule.
   * *   When you modify a specified alert rule in the application group, you must obtain the ID of the alert rule. For information about how to obtain the ID of an alert rule, see [DescribeMetricRuleList](https://help.aliyun.com/document_detail/114941.html).
   * 
   * This parameter is required.
   * 
   * @example
   * 123456
   */
  ruleId?: string;
  /**
   * @remarks
   * The name of the alert rule.
   * 
   * *   When you create an alert rule for the application group, enter the name of the alert rule.
   * *   When you modify a specified alert rule in the application group, you must obtain the name of the alert rule. For more information about how to obtain the name of an alert rule, see [DescribeMetricRuleList](https://help.aliyun.com/document_detail/114941.html).
   * 
   * This parameter is required.
   * 
   * @example
   * Rule_01
   */
  ruleName?: string;
  /**
   * @remarks
   * The mute period during which new alerts are not sent even if the trigger conditions are met.
   * 
   * Unit: seconds. Default value: 86400.
   * 
   * @example
   * 86400
   */
  silenceTime?: number;
  /**
   * @remarks
   * The callback URL.
   * 
   * The callback URL must be accessible over the Internet. CloudMonitor sends a POST request to push an alert notification to the callback URL that you specify. Only HTTP requests are supported.
   * 
   * @example
   * https://www.aliyun.com
   */
  webhook?: string;
  static names(): { [key: string]: string } {
    return {
      escalations: 'Escalations',
      category: 'Category',
      contactGroups: 'ContactGroups',
      dimensions: 'Dimensions',
      effectiveInterval: 'EffectiveInterval',
      emailSubject: 'EmailSubject',
      extraDimensionJson: 'ExtraDimensionJson',
      groupId: 'GroupId',
      interval: 'Interval',
      labels: 'Labels',
      metricName: 'MetricName',
      namespace: 'Namespace',
      noDataPolicy: 'NoDataPolicy',
      noEffectiveInterval: 'NoEffectiveInterval',
      options: 'Options',
      period: 'Period',
      ruleId: 'RuleId',
      ruleName: 'RuleName',
      silenceTime: 'SilenceTime',
      webhook: 'Webhook',
    };
  }

  static types(): { [key: string]: any } {
    return {
      escalations: PutGroupMetricRuleRequestEscalations,
      category: 'string',
      contactGroups: 'string',
      dimensions: 'string',
      effectiveInterval: 'string',
      emailSubject: 'string',
      extraDimensionJson: 'string',
      groupId: 'string',
      interval: 'string',
      labels: { 'type': 'array', 'itemType': PutGroupMetricRuleRequestLabels },
      metricName: 'string',
      namespace: 'string',
      noDataPolicy: 'string',
      noEffectiveInterval: 'string',
      options: 'string',
      period: 'string',
      ruleId: 'string',
      ruleName: 'string',
      silenceTime: 'number',
      webhook: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutGroupMetricRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The Request is not authorization.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 461CF2CD-2FC3-4B26-8645-7BD27E7D0F1D
   */
  requestId?: string;
  /**
   * @remarks
   * The result of the request.
   */
  result?: PutGroupMetricRuleResponseBodyResult;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      result: PutGroupMetricRuleResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutGroupMetricRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: PutGroupMetricRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PutGroupMetricRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutHybridMonitorMetricDataRequest extends $tea.Model {
  /**
   * @remarks
   * The monitoring data.
   * 
   * Valid values of N: 1 to 100.
   * 
   * This parameter is required.
   */
  metricList?: PutHybridMonitorMetricDataRequestMetricList[];
  /**
   * @remarks
   * The name of the namespace.
   * 
   * For information about how to obtain the name of a namespace, see [DescribeHybridMonitorNamespaceList](https://help.aliyun.com/document_detail/428880.html).
   * 
   * This parameter is required.
   * 
   * @example
   * default-aliyun
   */
  namespace?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      metricList: 'MetricList',
      namespace: 'Namespace',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      metricList: { 'type': 'array', 'itemType': PutHybridMonitorMetricDataRequestMetricList },
      namespace: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutHybridMonitorMetricDataResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The details of invalid parameters.
   * 
   * If a request parameter is invalid, the details of the invalid parameter are returned.
   */
  errorDetail?: PutHybridMonitorMetricDataResponseBodyErrorDetail[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 5DB1CBCA-D14A-55FA-814F-B4DBD9735F68
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      errorDetail: 'ErrorDetail',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      errorDetail: { 'type': 'array', 'itemType': PutHybridMonitorMetricDataResponseBodyErrorDetail },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutHybridMonitorMetricDataResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: PutHybridMonitorMetricDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PutHybridMonitorMetricDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutLogMonitorRequest extends $tea.Model {
  /**
   * @remarks
   * The aggregation logic.
   * 
   * This parameter is required.
   */
  aggregates?: PutLogMonitorRequestAggregates[];
  /**
   * @remarks
   * The ID of the application group.
   * 
   * @example
   * 7301****
   */
  groupId?: string;
  /**
   * @remarks
   * The dimension based on which the data is grouped. This parameter is equivalent to the GROUP BY clause in SQL statements. If no dimension is specified, all data is aggregated based on the aggregate function.
   */
  groupbys?: PutLogMonitorRequestGroupbys[];
  /**
   * @remarks
   * The ID of the log monitoring metric.
   * 
   * @example
   * 16****
   */
  logId?: string;
  /**
   * @remarks
   * The extended field. The extended field allows you to perform basic operations on the aggregation results.
   * 
   * For example, you have calculated TotalNumber and 5XXNumber by aggregating the data. TotalNumber indicates the total number of HTTP requests, and 5XXNumber indicates the number of HTTP requests whose status code is greater than 499. You can calculate the server error rate by adding the following formula to the extended field: 5XXNumber/TotalNumber\\*100.
   * 
   * JSON format: {"extend":{"errorPercent":"5XXNumber/TotalNumber\\*100"}}. Description:
   * 
   * *   extend: required.
   * *   errorPercent: the alias of the field generated in the calculation result. You can specify the alias as needed.
   * *   5XXNumber/TotalNumber\\*100: the calculation expression.
   * 
   * @example
   * {"extend":{"errorPercent":"5XXNumber/TotalNumber*100"}}
   */
  metricExpress?: string;
  /**
   * @remarks
   * The metric name. For more information about the metrics for cloud services, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * This parameter is required.
   * 
   * @example
   * cpu_total
   */
  metricName?: string;
  regionId?: string;
  /**
   * @remarks
   * The name of the Simple Log Service Logstore.
   * 
   * This parameter is required.
   * 
   * @example
   * test-logstore
   */
  slsLogstore?: string;
  /**
   * @remarks
   * The name of the Simple Log Service project.
   * 
   * This parameter is required.
   * 
   * @example
   * test-project
   */
  slsProject?: string;
  /**
   * @remarks
   * The region in which the Simple Log Service project resides.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  slsRegionId?: string;
  /**
   * @remarks
   * The size of the tumbling window for calculation. Unit: seconds. CloudMonitor performs aggregation for each tumbling window.
   * 
   * @example
   * 60,300
   */
  tumblingwindows?: string;
  /**
   * @remarks
   * The unit.
   * 
   * @example
   * Percent
   */
  unit?: string;
  /**
   * @remarks
   * The condition that is used to filter logs. The ValueFilter and ValueFilterRelation parameters are used in pair. The filter condition is equivalent to the WHERE clause in SQL statements. If no filter condition is specified, all logs are processed. For example, logs contain the Level and Error fields. If you need to calculate the number of times that logs of the Error level appear every minute, you can set the filter condition to Level=Error and count the number of logs that meet this condition.
   */
  valueFilter?: PutLogMonitorRequestValueFilter[];
  /**
   * @remarks
   * The logical operator that is used between log filter conditions. Valid values:
   * 
   * *   and
   * *   or
   * 
   * >  The ValueFilterRelation and `ValueFilter.N.Key` parameters must be used in pair.
   * 
   * This parameter is required.
   * 
   * @example
   * and
   */
  valueFilterRelation?: string;
  static names(): { [key: string]: string } {
    return {
      aggregates: 'Aggregates',
      groupId: 'GroupId',
      groupbys: 'Groupbys',
      logId: 'LogId',
      metricExpress: 'MetricExpress',
      metricName: 'MetricName',
      regionId: 'RegionId',
      slsLogstore: 'SlsLogstore',
      slsProject: 'SlsProject',
      slsRegionId: 'SlsRegionId',
      tumblingwindows: 'Tumblingwindows',
      unit: 'Unit',
      valueFilter: 'ValueFilter',
      valueFilterRelation: 'ValueFilterRelation',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aggregates: { 'type': 'array', 'itemType': PutLogMonitorRequestAggregates },
      groupId: 'string',
      groupbys: { 'type': 'array', 'itemType': PutLogMonitorRequestGroupbys },
      logId: 'string',
      metricExpress: 'string',
      metricName: 'string',
      regionId: 'string',
      slsLogstore: 'string',
      slsProject: 'string',
      slsRegionId: 'string',
      tumblingwindows: 'string',
      unit: 'string',
      valueFilter: { 'type': 'array', 'itemType': PutLogMonitorRequestValueFilter },
      valueFilterRelation: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutLogMonitorResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The ID of the log monitoring metric.
   * 
   * @example
   * 16****
   */
  logId?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * *   If the request was successful, `successful` is returned.
   * *   If the request failed, an error message is returned. Example: `alias of aggreate must be set value.`
   * 
   * @example
   * successful
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 91561287-0802-5F9C-9BDE-404C50D41B06
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      logId: 'LogId',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      logId: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutLogMonitorResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: PutLogMonitorResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PutLogMonitorResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutMetricRuleTargetsRequest extends $tea.Model {
  regionId?: string;
  /**
   * @remarks
   * The ID of the alert rule.
   * 
   * For information about how to obtain the ID of an alert rule, see [DescribeMetricRuleList](https://help.aliyun.com/document_detail/114941.html).
   * 
   * This parameter is required.
   * 
   * @example
   * ae06917_75a8c43178ab66****
   */
  ruleId?: string;
  /**
   * @remarks
   * N/A.
   * 
   * This parameter is required.
   */
  targets?: PutMetricRuleTargetsRequestTargets[];
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      ruleId: 'RuleId',
      targets: 'Targets',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      ruleId: 'string',
      targets: { 'type': 'array', 'itemType': PutMetricRuleTargetsRequestTargets },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutMetricRuleTargetsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The failed data.
   */
  failData?: PutMetricRuleTargetsResponseBodyFailData;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * The request processing has failed due to some unknown error.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 6A569B0D-9055-58AF-9E82-BAEAF95C0FD5
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true: The request was successful.
   * *   false: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      failData: 'FailData',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      failData: PutMetricRuleTargetsResponseBodyFailData,
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutMetricRuleTargetsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: PutMetricRuleTargetsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PutMetricRuleTargetsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutMonitorGroupDynamicRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the application group.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456
   */
  groupId?: number;
  /**
   * @remarks
   * None.
   * 
   * This parameter is required.
   */
  groupRules?: PutMonitorGroupDynamicRuleRequestGroupRules[];
  /**
   * @remarks
   * The mode for creating the alert rule. Valid values:
   * 
   * *   true: creates asynchronously
   * *   false (default): creates synchronously
   * 
   * @example
   * false
   */
  isAsync?: boolean;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      groupRules: 'GroupRules',
      isAsync: 'IsAsync',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'number',
      groupRules: { 'type': 'array', 'itemType': PutMonitorGroupDynamicRuleRequestGroupRules },
      isAsync: 'boolean',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutMonitorGroupDynamicRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code.
   * 
   * > The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The specified resource is not found.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 3E73F1AB-D195-438A-BCA7-2F4355789C58
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutMonitorGroupDynamicRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: PutMonitorGroupDynamicRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PutMonitorGroupDynamicRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutMonitoringConfigRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is deprecated.
   * 
   * @example
   * true
   */
  autoInstall?: boolean;
  /**
   * @remarks
   * Specifies whether to automatically install the CloudMonitor agent on new ECS instances. Valid values:
   * 
   * *   true (default): The CloudMonitor agent is automatically installed on new ECS instances.
   * *   false: The CloudMonitor agent is not automatically installed on new ECS instances.
   * 
   * @example
   * true
   */
  enableInstallAgentNewECS?: boolean;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      autoInstall: 'AutoInstall',
      enableInstallAgentNewECS: 'EnableInstallAgentNewECS',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoInstall: 'boolean',
      enableInstallAgentNewECS: 'boolean',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutMonitoringConfigResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * Specified parameter EnableInstallAgentNewECS is not valid.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 109C8095-6FAD-4DBB-B013-6ED18CE4C0B1
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutMonitoringConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: PutMonitoringConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PutMonitoringConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutResourceMetricRuleRequest extends $tea.Model {
  escalations?: PutResourceMetricRuleRequestEscalations;
  /**
   * @remarks
   * The trigger conditions for multiple metrics.
   * 
   * >  The trigger conditions for a single metric and multiple metrics are mutually exclusive. You cannot specify trigger conditions for a single metric and multiple metrics at the same time.
   */
  compositeExpression?: PutResourceMetricRuleRequestCompositeExpression;
  /**
   * @remarks
   * The alert contact groups. Alert notifications are sent to the alert contacts in the alert contact group.
   * 
   * >  An alert contact group can contain one or more alert contacts. For information about how to create alert contacts and alert contact groups, see [PutContact](https://help.aliyun.com/document_detail/114923.html) and [PutContactGroup](https://help.aliyun.com/document_detail/114929.html).
   * 
   * This parameter is required.
   * 
   * @example
   * ECS_Group
   */
  contactGroups?: string;
  /**
   * @remarks
   * The period of time during which the alert rule is effective.
   * 
   * @example
   * 00:00-23:59
   */
  effectiveInterval?: string;
  /**
   * @remarks
   * The subject of the alert notification email.
   */
  emailSubject?: string;
  /**
   * @remarks
   * The interval at which alerts are triggered based on the alert rule. Unit: seconds.
   * 
   * >  For more information about how to query the statistical periods of metrics, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * @example
   * 60
   */
  interval?: string;
  /**
   * @remarks
   * If the metric meets the specified condition in the alert rule and CloudMonitor sends an alert notification, the tag is also written to the metric and displayed in the alert notification.
   * 
   * >  This parameter is equivalent to the Label parameter of Prometheus alerts.
   */
  labels?: PutResourceMetricRuleRequestLabels[];
  /**
   * @remarks
   * The metric name. For more information about how to query metric names, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * >  If you create a Prometheus alert rule for Hybrid Cloud Monitoring, you must set this parameter to the name of the namespace. For more information about how to query the names of namespaces, see [DescribeHybridMonitorNamespaceList](https://help.aliyun.com/document_detail/428880.html).
   * 
   * This parameter is required.
   * 
   * @example
   * cpu_total
   */
  metricName?: string;
  /**
   * @remarks
   * The namespace of the cloud service. For more information about how to query the namespaces of cloud services, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * >  If you create a Prometheus alert rule for Hybrid Cloud Monitoring, you must set this parameter to `acs_prometheus`.
   * 
   * This parameter is required.
   * 
   * @example
   * acs_ecs_dashboard
   */
  namespace?: string;
  /**
   * @remarks
   * The method that is used to handle alerts when no monitoring data is found. Valid value:
   * 
   * *   KEEP_LAST_STATE (default): No operation is performed.
   * *   INSUFFICIENT_DATA: An alert whose content is "Insufficient data" is triggered.
   * *   OK: The status is considered normal.
   * 
   * @example
   * KEEP_LAST_STATE
   */
  noDataPolicy?: string;
  /**
   * @remarks
   * The period of time during which the alert rule is ineffective.
   * 
   * @example
   * 00:00-06:00
   */
  noEffectiveInterval?: string;
  /**
   * @remarks
   * The statistical period of the metric. Unit: seconds. The default value is the interval at which the monitoring data of the metric is collected.
   * 
   * >  For more information about how to query the statistical periods of metrics, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * @example
   * 60
   */
  period?: string;
  /**
   * @remarks
   * Prometheus alerts.
   * 
   * >  This parameter is required only if you create a Prometheus alert rule for Hybrid Cloud Monitoring.
   */
  prometheus?: PutResourceMetricRuleRequestPrometheus;
  /**
   * @remarks
   * The resource information. Examples: `[{"instanceId":"i-uf6j91r34rnwawoo****"}]` and `[{"userId":"100931896542****"}]`.
   * 
   * For more information about the supported dimensions that are used to query resources, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * @example
   * [{"instanceId":"i-uf6j91r34rnwawoo****"}]
   */
  resources?: string;
  /**
   * @remarks
   * The ID of the alert rule.
   * 
   * You can specify a new ID or the ID of an existing alert rule. For more information about how to query the IDs of alert rules, see [DescribeMetricRuleList](https://help.aliyun.com/document_detail/114941.html).
   * 
   * >  If you specify a new ID, a threshold-triggered alert rule is created.
   * 
   * This parameter is required.
   * 
   * @example
   * a151cd6023eacee2f0978e03863cc1697c89508****
   */
  ruleId?: string;
  /**
   * @remarks
   * The name of the alert rule.
   * 
   * You can specify a new name or the name of an existing alert rule. For more information about how to query the names of alert rules, see [DescribeMetricRuleList](https://help.aliyun.com/document_detail/114941.html).
   * 
   * >  If you specify a new name, a threshold-triggered alert rule is created.
   * 
   * This parameter is required.
   * 
   * @example
   * test123
   */
  ruleName?: string;
  /**
   * @remarks
   * The mute period during which new alert notifications are not sent even if the trigger conditions are met. Unit: seconds. Default value: 86400.
   * 
   * >  If an alert is not cleared after the mute period ends, CloudMonitor resends an alert notification.
   * 
   * @example
   * 86400
   */
  silenceTime?: number;
  /**
   * @remarks
   * The callback URL to which a POST request is sent when an alert is triggered based on the alert rule.
   * 
   * @example
   * https://alert.aliyun.com.com:8080/callback
   */
  webhook?: string;
  static names(): { [key: string]: string } {
    return {
      escalations: 'Escalations',
      compositeExpression: 'CompositeExpression',
      contactGroups: 'ContactGroups',
      effectiveInterval: 'EffectiveInterval',
      emailSubject: 'EmailSubject',
      interval: 'Interval',
      labels: 'Labels',
      metricName: 'MetricName',
      namespace: 'Namespace',
      noDataPolicy: 'NoDataPolicy',
      noEffectiveInterval: 'NoEffectiveInterval',
      period: 'Period',
      prometheus: 'Prometheus',
      resources: 'Resources',
      ruleId: 'RuleId',
      ruleName: 'RuleName',
      silenceTime: 'SilenceTime',
      webhook: 'Webhook',
    };
  }

  static types(): { [key: string]: any } {
    return {
      escalations: PutResourceMetricRuleRequestEscalations,
      compositeExpression: PutResourceMetricRuleRequestCompositeExpression,
      contactGroups: 'string',
      effectiveInterval: 'string',
      emailSubject: 'string',
      interval: 'string',
      labels: { 'type': 'array', 'itemType': PutResourceMetricRuleRequestLabels },
      metricName: 'string',
      namespace: 'string',
      noDataPolicy: 'string',
      noEffectiveInterval: 'string',
      period: 'string',
      prometheus: PutResourceMetricRuleRequestPrometheus,
      resources: 'string',
      ruleId: 'string',
      ruleName: 'string',
      silenceTime: 'number',
      webhook: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutResourceMetricRuleShrinkRequest extends $tea.Model {
  escalations?: PutResourceMetricRuleShrinkRequestEscalations;
  /**
   * @remarks
   * The trigger conditions for multiple metrics.
   * 
   * >  The trigger conditions for a single metric and multiple metrics are mutually exclusive. You cannot specify trigger conditions for a single metric and multiple metrics at the same time.
   */
  compositeExpressionShrink?: string;
  /**
   * @remarks
   * The alert contact groups. Alert notifications are sent to the alert contacts in the alert contact group.
   * 
   * >  An alert contact group can contain one or more alert contacts. For information about how to create alert contacts and alert contact groups, see [PutContact](https://help.aliyun.com/document_detail/114923.html) and [PutContactGroup](https://help.aliyun.com/document_detail/114929.html).
   * 
   * This parameter is required.
   * 
   * @example
   * ECS_Group
   */
  contactGroups?: string;
  /**
   * @remarks
   * The period of time during which the alert rule is effective.
   * 
   * @example
   * 00:00-23:59
   */
  effectiveInterval?: string;
  /**
   * @remarks
   * The subject of the alert notification email.
   */
  emailSubject?: string;
  /**
   * @remarks
   * The interval at which alerts are triggered based on the alert rule. Unit: seconds.
   * 
   * >  For more information about how to query the statistical periods of metrics, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * @example
   * 60
   */
  interval?: string;
  /**
   * @remarks
   * If the metric meets the specified condition in the alert rule and CloudMonitor sends an alert notification, the tag is also written to the metric and displayed in the alert notification.
   * 
   * >  This parameter is equivalent to the Label parameter of Prometheus alerts.
   */
  labels?: PutResourceMetricRuleShrinkRequestLabels[];
  /**
   * @remarks
   * The metric name. For more information about how to query metric names, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * >  If you create a Prometheus alert rule for Hybrid Cloud Monitoring, you must set this parameter to the name of the namespace. For more information about how to query the names of namespaces, see [DescribeHybridMonitorNamespaceList](https://help.aliyun.com/document_detail/428880.html).
   * 
   * This parameter is required.
   * 
   * @example
   * cpu_total
   */
  metricName?: string;
  /**
   * @remarks
   * The namespace of the cloud service. For more information about how to query the namespaces of cloud services, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * >  If you create a Prometheus alert rule for Hybrid Cloud Monitoring, you must set this parameter to `acs_prometheus`.
   * 
   * This parameter is required.
   * 
   * @example
   * acs_ecs_dashboard
   */
  namespace?: string;
  /**
   * @remarks
   * The method that is used to handle alerts when no monitoring data is found. Valid value:
   * 
   * *   KEEP_LAST_STATE (default): No operation is performed.
   * *   INSUFFICIENT_DATA: An alert whose content is "Insufficient data" is triggered.
   * *   OK: The status is considered normal.
   * 
   * @example
   * KEEP_LAST_STATE
   */
  noDataPolicy?: string;
  /**
   * @remarks
   * The period of time during which the alert rule is ineffective.
   * 
   * @example
   * 00:00-06:00
   */
  noEffectiveInterval?: string;
  /**
   * @remarks
   * The statistical period of the metric. Unit: seconds. The default value is the interval at which the monitoring data of the metric is collected.
   * 
   * >  For more information about how to query the statistical periods of metrics, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * @example
   * 60
   */
  period?: string;
  /**
   * @remarks
   * Prometheus alerts.
   * 
   * >  This parameter is required only if you create a Prometheus alert rule for Hybrid Cloud Monitoring.
   */
  prometheusShrink?: string;
  /**
   * @remarks
   * The resource information. Examples: `[{"instanceId":"i-uf6j91r34rnwawoo****"}]` and `[{"userId":"100931896542****"}]`.
   * 
   * For more information about the supported dimensions that are used to query resources, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * @example
   * [{"instanceId":"i-uf6j91r34rnwawoo****"}]
   */
  resources?: string;
  /**
   * @remarks
   * The ID of the alert rule.
   * 
   * You can specify a new ID or the ID of an existing alert rule. For more information about how to query the IDs of alert rules, see [DescribeMetricRuleList](https://help.aliyun.com/document_detail/114941.html).
   * 
   * >  If you specify a new ID, a threshold-triggered alert rule is created.
   * 
   * This parameter is required.
   * 
   * @example
   * a151cd6023eacee2f0978e03863cc1697c89508****
   */
  ruleId?: string;
  /**
   * @remarks
   * The name of the alert rule.
   * 
   * You can specify a new name or the name of an existing alert rule. For more information about how to query the names of alert rules, see [DescribeMetricRuleList](https://help.aliyun.com/document_detail/114941.html).
   * 
   * >  If you specify a new name, a threshold-triggered alert rule is created.
   * 
   * This parameter is required.
   * 
   * @example
   * test123
   */
  ruleName?: string;
  /**
   * @remarks
   * The mute period during which new alert notifications are not sent even if the trigger conditions are met. Unit: seconds. Default value: 86400.
   * 
   * >  If an alert is not cleared after the mute period ends, CloudMonitor resends an alert notification.
   * 
   * @example
   * 86400
   */
  silenceTime?: number;
  /**
   * @remarks
   * The callback URL to which a POST request is sent when an alert is triggered based on the alert rule.
   * 
   * @example
   * https://alert.aliyun.com.com:8080/callback
   */
  webhook?: string;
  static names(): { [key: string]: string } {
    return {
      escalations: 'Escalations',
      compositeExpressionShrink: 'CompositeExpression',
      contactGroups: 'ContactGroups',
      effectiveInterval: 'EffectiveInterval',
      emailSubject: 'EmailSubject',
      interval: 'Interval',
      labels: 'Labels',
      metricName: 'MetricName',
      namespace: 'Namespace',
      noDataPolicy: 'NoDataPolicy',
      noEffectiveInterval: 'NoEffectiveInterval',
      period: 'Period',
      prometheusShrink: 'Prometheus',
      resources: 'Resources',
      ruleId: 'RuleId',
      ruleName: 'RuleName',
      silenceTime: 'SilenceTime',
      webhook: 'Webhook',
    };
  }

  static types(): { [key: string]: any } {
    return {
      escalations: PutResourceMetricRuleShrinkRequestEscalations,
      compositeExpressionShrink: 'string',
      contactGroups: 'string',
      effectiveInterval: 'string',
      emailSubject: 'string',
      interval: 'string',
      labels: { 'type': 'array', 'itemType': PutResourceMetricRuleShrinkRequestLabels },
      metricName: 'string',
      namespace: 'string',
      noDataPolicy: 'string',
      noEffectiveInterval: 'string',
      period: 'string',
      prometheusShrink: 'string',
      resources: 'string',
      ruleId: 'string',
      ruleName: 'string',
      silenceTime: 'number',
      webhook: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutResourceMetricRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The responses code.
   * 
   * >  The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * The request processing has failed due to some unknown error.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 65D50468-ECEF-48F1-A6E1-D952E89D9436
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutResourceMetricRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: PutResourceMetricRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PutResourceMetricRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutResourceMetricRulesRequest extends $tea.Model {
  /**
   * @remarks
   * The threshold-triggered alert rules.
   * 
   * Valid values of N: 1 to 500.
   * 
   * This parameter is required.
   */
  rules?: PutResourceMetricRulesRequestRules[];
  static names(): { [key: string]: string } {
    return {
      rules: 'Rules',
    };
  }

  static types(): { [key: string]: any } {
    return {
      rules: { 'type': 'array', 'itemType': PutResourceMetricRulesRequestRules },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutResourceMetricRulesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response code.
   * 
   * >  The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The alert rules that failed to be created for the resource.
   */
  failedListResult?: PutResourceMetricRulesResponseBodyFailedListResult;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * The request processing has failed due to some unknown error.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 15D1440E-BF24-5A41-93E4-36864635179E
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      failedListResult: 'FailedListResult',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      failedListResult: PutResourceMetricRulesResponseBodyFailedListResult,
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutResourceMetricRulesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: PutResourceMetricRulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PutResourceMetricRulesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveTagsRequest extends $tea.Model {
  /**
   * @remarks
   * The IDs of the application groups.
   * 
   * This parameter is required.
   * 
   * @example
   * 12345
   */
  groupIds?: string[];
  regionId?: string;
  /**
   * @remarks
   * The tags.
   * 
   * This parameter is required.
   */
  tag?: RemoveTagsRequestTag[];
  static names(): { [key: string]: string } {
    return {
      groupIds: 'GroupIds',
      regionId: 'RegionId',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupIds: { 'type': 'array', 'itemType': 'string' },
      regionId: 'string',
      tag: { 'type': 'array', 'itemType': RemoveTagsRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveTagsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code.
   * 
   * > The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * Illegal parameters.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 195390D2-69D0-4D9E-81AA-A7F5BC1B91EB
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The deleted tags.
   */
  tag?: RemoveTagsResponseBodyTag;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
      tag: RemoveTagsResponseBodyTag,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveTagsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RemoveTagsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RemoveTagsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SendDryRunSystemEventRequest extends $tea.Model {
  /**
   * @remarks
   * The content of the system event.
   * 
   * >  The value of this parameter is a JSON object. We recommend that you include the `product`, `resourceId`, and `regionId` fields in the JSON object.
   * 
   * @example
   * {"product":"CloudMonitor","resourceId":"acs:ecs:cn-hongkong:173651113438****:instance/{instanceId}","level":"CRITICAL","instanceName":"instanceName","regionId":"cn-hangzhou","name":"Agent_Status_Stopped","content":{"ipGroup":"0.0.0.0,0.0.0.1","tianjimonVersion":"1.2.11"},"status":"stopped"}
   */
  eventContent?: string;
  /**
   * @remarks
   * The name of the system event.
   * 
   * >  For more information, see [DescribeSystemEventMetaList](https://help.aliyun.com/document_detail/114972.html).
   * 
   * This parameter is required.
   * 
   * @example
   * Agent_Status_Stopped
   */
  eventName?: string;
  /**
   * @remarks
   * The ID of the application group.
   * 
   * @example
   * 123456
   */
  groupId?: string;
  /**
   * @remarks
   * The name of the cloud service.
   * 
   * >  For information about the system events supported by Cloud Monitor for Alibaba Cloud services, see [System events](https://help.aliyun.com/document_detail/167388.html).
   * 
   * This parameter is required.
   * 
   * @example
   * ecs
   */
  product?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      eventContent: 'EventContent',
      eventName: 'EventName',
      groupId: 'GroupId',
      product: 'Product',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventContent: 'string',
      eventName: 'string',
      groupId: 'string',
      product: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SendDryRunSystemEventResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The status code 200 indicates that the call was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 486029C9-53E1-44B4-85A8-16A571A043FD
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call was successful. Valid values:
   * 
   * *   true: The call was successful.
   * *   false: The call failed.
   * 
   * @example
   * true
   */
  success?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SendDryRunSystemEventResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SendDryRunSystemEventResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SendDryRunSystemEventResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UninstallMonitoringAgentRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the host.
   * 
   * This parameter is required.
   * 
   * @example
   * host-****
   */
  instanceId?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UninstallMonitoringAgentResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * >  The HTTP status code 200 indicates that the call was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * Successfully
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 466902B9-2842-40B0-B796-00FE772B6EF3
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call was successful. Valid values:
   * 
   * *   true: The call was successful.
   * *   false: The call failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UninstallMonitoringAgentResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UninstallMonitoringAgentResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UninstallMonitoringAgentResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AlertEventMetrics extends $tea.Model {
  curValue?: string;
  metricName?: string;
  metricNameEn?: string;
  metricNameZh?: string;
  operator?: string;
  statistics?: string;
  threshold?: string;
  unit?: string;
  unitFactor?: number;
  static names(): { [key: string]: string } {
    return {
      curValue: 'CurValue',
      metricName: 'MetricName',
      metricNameEn: 'MetricNameEn',
      metricNameZh: 'MetricNameZh',
      operator: 'Operator',
      statistics: 'Statistics',
      threshold: 'Threshold',
      unit: 'Unit',
      unitFactor: 'UnitFactor',
    };
  }

  static types(): { [key: string]: any } {
    return {
      curValue: 'string',
      metricName: 'string',
      metricNameEn: 'string',
      metricNameZh: 'string',
      operator: 'string',
      statistics: 'string',
      threshold: 'string',
      unit: 'string',
      unitFactor: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EscalationRuleEscalationsContactGroupsByLevel extends $tea.Model {
  critical?: string[];
  error?: string[];
  info?: string[];
  resolve?: string[];
  warning?: string[];
  static names(): { [key: string]: string } {
    return {
      critical: 'Critical',
      error: 'Error',
      info: 'Info',
      resolve: 'Resolve',
      warning: 'Warning',
    };
  }

  static types(): { [key: string]: any } {
    return {
      critical: { 'type': 'array', 'itemType': 'string' },
      error: { 'type': 'array', 'itemType': 'string' },
      info: { 'type': 'array', 'itemType': 'string' },
      resolve: { 'type': 'array', 'itemType': 'string' },
      warning: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EscalationRuleEscalations extends $tea.Model {
  backupContactGroups?: string[];
  contactGroups?: string[];
  contactGroupsByLevel?: EscalationRuleEscalationsContactGroupsByLevel;
  escalateMin?: number;
  static names(): { [key: string]: string } {
    return {
      backupContactGroups: 'BackupContactGroups',
      contactGroups: 'ContactGroups',
      contactGroupsByLevel: 'ContactGroupsByLevel',
      escalateMin: 'EscalateMin',
    };
  }

  static types(): { [key: string]: any } {
    return {
      backupContactGroups: { 'type': 'array', 'itemType': 'string' },
      contactGroups: { 'type': 'array', 'itemType': 'string' },
      contactGroupsByLevel: EscalationRuleEscalationsContactGroupsByLevel,
      escalateMin: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class MigrationJobPlanContactsChannels extends $tea.Model {
  level?: number;
  type?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      level: 'Level',
      type: 'Type',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      level: 'number',
      type: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class MigrationJobPlanContacts extends $tea.Model {
  channels?: MigrationJobPlanContactsChannels[];
  name?: string;
  static names(): { [key: string]: string } {
    return {
      channels: 'Channels',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channels: { 'type': 'array', 'itemType': MigrationJobPlanContactsChannels },
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class MigrationJobPlanEscalationsEscalationsLevelGroups extends $tea.Model {
  critical?: string[];
  info?: string[];
  resolved?: string[];
  warning?: string[];
  static names(): { [key: string]: string } {
    return {
      critical: 'Critical',
      info: 'Info',
      resolved: 'Resolved',
      warning: 'Warning',
    };
  }

  static types(): { [key: string]: any } {
    return {
      critical: { 'type': 'array', 'itemType': 'string' },
      info: { 'type': 'array', 'itemType': 'string' },
      resolved: { 'type': 'array', 'itemType': 'string' },
      warning: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class MigrationJobPlanEscalationsEscalations extends $tea.Model {
  groups?: string[];
  levelGroups?: MigrationJobPlanEscalationsEscalationsLevelGroups;
  static names(): { [key: string]: string } {
    return {
      groups: 'Groups',
      levelGroups: 'LevelGroups',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groups: { 'type': 'array', 'itemType': 'string' },
      levelGroups: MigrationJobPlanEscalationsEscalationsLevelGroups,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class MigrationJobPlanEscalations extends $tea.Model {
  escalations?: MigrationJobPlanEscalationsEscalations[];
  name?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      escalations: 'Escalations',
      name: 'Name',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      escalations: { 'type': 'array', 'itemType': MigrationJobPlanEscalationsEscalations },
      name: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class MigrationJobPlanGroups extends $tea.Model {
  contacts?: string[];
  name?: string;
  static names(): { [key: string]: string } {
    return {
      contacts: 'Contacts',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contacts: { 'type': 'array', 'itemType': 'string' },
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class MigrationJobPlanStrategiesEscalationSetting extends $tea.Model {
  escalationUuid?: string;
  static names(): { [key: string]: string } {
    return {
      escalationUuid: 'escalationUuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      escalationUuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class MigrationJobPlanStrategiesPushingSetting extends $tea.Model {
  targetUuids?: string[];
  static names(): { [key: string]: string } {
    return {
      targetUuids: 'TargetUuids',
    };
  }

  static types(): { [key: string]: any } {
    return {
      targetUuids: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class MigrationJobPlanStrategies extends $tea.Model {
  escalationSetting?: MigrationJobPlanStrategiesEscalationSetting;
  name?: string;
  pushingSetting?: MigrationJobPlanStrategiesPushingSetting;
  static names(): { [key: string]: string } {
    return {
      escalationSetting: 'EscalationSetting',
      name: 'Name',
      pushingSetting: 'PushingSetting',
    };
  }

  static types(): { [key: string]: any } {
    return {
      escalationSetting: MigrationJobPlanStrategiesEscalationSetting,
      name: 'string',
      pushingSetting: MigrationJobPlanStrategiesPushingSetting,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class MigrationJobPlanSubscriptionsConditions extends $tea.Model {
  field?: string;
  op?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      field: 'Field',
      op: 'Op',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      field: 'string',
      op: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class MigrationJobPlanSubscriptions extends $tea.Model {
  conditions?: MigrationJobPlanSubscriptionsConditions[];
  name?: string;
  strategyUuid?: string;
  static names(): { [key: string]: string } {
    return {
      conditions: 'Conditions',
      name: 'Name',
      strategyUuid: 'StrategyUuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      conditions: { 'type': 'array', 'itemType': MigrationJobPlanSubscriptionsConditions },
      name: 'string',
      strategyUuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class MigrationJobPlanTargetsHttpRequestTarget extends $tea.Model {
  contentType?: string;
  method?: string;
  url?: string;
  static names(): { [key: string]: string } {
    return {
      contentType: 'ContentType',
      method: 'Method',
      url: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contentType: 'string',
      method: 'string',
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class MigrationJobPlanTargets extends $tea.Model {
  arn?: string;
  httpRequestTarget?: MigrationJobPlanTargetsHttpRequestTarget;
  name?: string;
  type?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      arn: 'Arn',
      httpRequestTarget: 'HttpRequestTarget',
      name: 'Name',
      type: 'Type',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      arn: 'string',
      httpRequestTarget: MigrationJobPlanTargetsHttpRequestTarget,
      name: 'string',
      type: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class MigrationJobPlan extends $tea.Model {
  contacts?: MigrationJobPlanContacts[];
  escalations?: MigrationJobPlanEscalations[];
  groups?: MigrationJobPlanGroups[];
  ruleNames?: string[];
  strategies?: MigrationJobPlanStrategies[];
  subscriptions?: MigrationJobPlanSubscriptions[];
  targets?: MigrationJobPlanTargets[];
  static names(): { [key: string]: string } {
    return {
      contacts: 'Contacts',
      escalations: 'Escalations',
      groups: 'Groups',
      ruleNames: 'RuleNames',
      strategies: 'Strategies',
      subscriptions: 'Subscriptions',
      targets: 'Targets',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contacts: { 'type': 'array', 'itemType': MigrationJobPlanContacts },
      escalations: { 'type': 'array', 'itemType': MigrationJobPlanEscalations },
      groups: { 'type': 'array', 'itemType': MigrationJobPlanGroups },
      ruleNames: { 'type': 'array', 'itemType': 'string' },
      strategies: { 'type': 'array', 'itemType': MigrationJobPlanStrategies },
      subscriptions: { 'type': 'array', 'itemType': MigrationJobPlanSubscriptions },
      targets: { 'type': 'array', 'itemType': MigrationJobPlanTargets },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class MigrationJobSourceRuleKeywordFilter extends $tea.Model {
  keywords?: string[];
  relation?: string;
  static names(): { [key: string]: string } {
    return {
      keywords: 'Keywords',
      relation: 'Relation',
    };
  }

  static types(): { [key: string]: any } {
    return {
      keywords: { 'type': 'array', 'itemType': 'string' },
      relation: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class MigrationJobSourceRulePrimaryFilters extends $tea.Model {
  field?: string;
  opType?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      field: 'Field',
      opType: 'OpType',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      field: 'string',
      opType: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class MigrationJobSourceRule extends $tea.Model {
  keywordFilter?: MigrationJobSourceRuleKeywordFilter;
  name?: string;
  primaryFilters?: MigrationJobSourceRulePrimaryFilters[];
  static names(): { [key: string]: string } {
    return {
      keywordFilter: 'KeywordFilter',
      name: 'Name',
      primaryFilters: 'PrimaryFilters',
    };
  }

  static types(): { [key: string]: any } {
    return {
      keywordFilter: MigrationJobSourceRuleKeywordFilter,
      name: 'string',
      primaryFilters: { 'type': 'array', 'itemType': MigrationJobSourceRulePrimaryFilters },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class MigrationJobSourceTargetsContent extends $tea.Model {
  group?: string;
  level?: string;
  method?: string;
  region?: string;
  resourcePath?: string;
  url?: string;
  static names(): { [key: string]: string } {
    return {
      group: 'Group',
      level: 'Level',
      method: 'Method',
      region: 'Region',
      resourcePath: 'ResourcePath',
      url: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      group: 'string',
      level: 'string',
      method: 'string',
      region: 'string',
      resourcePath: 'string',
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class MigrationJobSourceTargets extends $tea.Model {
  content?: MigrationJobSourceTargetsContent;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: MigrationJobSourceTargetsContent,
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class MigrationJobSource extends $tea.Model {
  rule?: MigrationJobSourceRule;
  targets?: MigrationJobSourceTargets[];
  static names(): { [key: string]: string } {
    return {
      rule: 'Rule',
      targets: 'Targets',
    };
  }

  static types(): { [key: string]: any } {
    return {
      rule: MigrationJobSourceRule,
      targets: { 'type': 'array', 'itemType': MigrationJobSourceTargets },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class NotificationStrategyEscalationSettingCustomChannels extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   */
  channelType?: string;
  severities?: string[];
  templateUuid?: string;
  static names(): { [key: string]: string } {
    return {
      channelType: 'ChannelType',
      severities: 'Severities',
      templateUuid: 'TemplateUuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelType: 'string',
      severities: { 'type': 'array', 'itemType': 'string' },
      templateUuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class NotificationStrategyEscalationSetting extends $tea.Model {
  autoResolveMin?: number;
  customChannels?: NotificationStrategyEscalationSettingCustomChannels[];
  escalationLevel?: string;
  escalationUuid?: string;
  range?: string;
  retriggerMin?: number;
  static names(): { [key: string]: string } {
    return {
      autoResolveMin: 'AutoResolveMin',
      customChannels: 'CustomChannels',
      escalationLevel: 'EscalationLevel',
      escalationUuid: 'EscalationUuid',
      range: 'Range',
      retriggerMin: 'RetriggerMin',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoResolveMin: 'number',
      customChannels: { 'type': 'array', 'itemType': NotificationStrategyEscalationSettingCustomChannels },
      escalationLevel: 'string',
      escalationUuid: 'string',
      range: 'string',
      retriggerMin: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class NotificationStrategyFilterSettingBlackList extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   */
  field?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  op?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      field: 'Field',
      op: 'Op',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      field: 'string',
      op: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class NotificationStrategyFilterSettingWhiteList extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   */
  field?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  op?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      field: 'Field',
      op: 'Op',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      field: 'string',
      op: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class NotificationStrategyFilterSetting extends $tea.Model {
  blackList?: NotificationStrategyFilterSettingBlackList[][];
  whiteList?: NotificationStrategyFilterSettingWhiteList[][];
  static names(): { [key: string]: string } {
    return {
      blackList: 'BlackList',
      whiteList: 'WhiteList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      blackList: { 'type': 'array', 'itemType': { 'type': 'array', 'itemType': NotificationStrategyFilterSettingBlackList } },
      whiteList: { 'type': 'array', 'itemType': { 'type': 'array', 'itemType': NotificationStrategyFilterSettingWhiteList } },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class NotificationStrategyGroupingSettingGroupingItems extends $tea.Model {
  keys?: string[];
  type?: string;
  static names(): { [key: string]: string } {
    return {
      keys: 'Keys',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      keys: { 'type': 'array', 'itemType': 'string' },
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class NotificationStrategyGroupingSetting extends $tea.Model {
  enableRawAlertDispatching?: boolean;
  groupingItems?: NotificationStrategyGroupingSettingGroupingItems[];
  periodMin?: number;
  silenceSec?: number;
  times?: number;
  static names(): { [key: string]: string } {
    return {
      enableRawAlertDispatching: 'EnableRawAlertDispatching',
      groupingItems: 'GroupingItems',
      periodMin: 'PeriodMin',
      silenceSec: 'SilenceSec',
      times: 'Times',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enableRawAlertDispatching: 'boolean',
      groupingItems: { 'type': 'array', 'itemType': NotificationStrategyGroupingSettingGroupingItems },
      periodMin: 'number',
      silenceSec: 'number',
      times: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class NotificationStrategyPushingSetting extends $tea.Model {
  pushingDataFormat?: string;
  range?: string;
  targetUuids?: string[];
  templateUuid?: string;
  static names(): { [key: string]: string } {
    return {
      pushingDataFormat: 'PushingDataFormat',
      range: 'Range',
      targetUuids: 'TargetUuids',
      templateUuid: 'TemplateUuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pushingDataFormat: 'string',
      range: 'string',
      targetUuids: { 'type': 'array', 'itemType': 'string' },
      templateUuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class NotificationStrategyRouteSettingRoutesConditions extends $tea.Model {
  field?: string;
  op?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      field: 'Field',
      op: 'Op',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      field: 'string',
      op: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class NotificationStrategyRouteSettingRoutes extends $tea.Model {
  conditions?: NotificationStrategyRouteSettingRoutesConditions[];
  escalationUuid?: string;
  static names(): { [key: string]: string } {
    return {
      conditions: 'Conditions',
      escalationUuid: 'EscalationUuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      conditions: { 'type': 'array', 'itemType': NotificationStrategyRouteSettingRoutesConditions },
      escalationUuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class NotificationStrategyRouteSetting extends $tea.Model {
  routes?: NotificationStrategyRouteSettingRoutes[];
  static names(): { [key: string]: string } {
    return {
      routes: 'Routes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      routes: { 'type': 'array', 'itemType': NotificationStrategyRouteSettingRoutes },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PushingTargetHttpRequestTargetHeaders extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PushingTargetHttpRequestTarget extends $tea.Model {
  contentType?: string;
  encryptString?: string;
  headers?: PushingTargetHttpRequestTargetHeaders[];
  method?: string;
  url?: string;
  static names(): { [key: string]: string } {
    return {
      contentType: 'ContentType',
      encryptString: 'EncryptString',
      headers: 'Headers',
      method: 'Method',
      url: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contentType: 'string',
      encryptString: 'string',
      headers: { 'type': 'array', 'itemType': PushingTargetHttpRequestTargetHeaders },
      method: 'string',
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubscriptionConditions extends $tea.Model {
  field?: string;
  operator?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      field: 'Field',
      operator: 'Operator',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      field: 'string',
      operator: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddTagsRequestTag extends $tea.Model {
  /**
   * @remarks
   * The key of tag N.
   * 
   * Valid values of N: 1 to 3. A tag key can be 1 to 64 characters in length.
   * 
   * You can create a tag key or specify an existing tag key. For more information about how to obtain a tag key, see [DescribeTagKeyList](https://help.aliyun.com/document_detail/145558.html).
   * 
   * > The tag key cannot start with `aliyun` or `acs:`. The tag key (`Tag.N.Key`) and tag value (`Tag.N.Value`) must be specified at the same time.
   * 
   * This parameter is required.
   * 
   * @example
   * key1
   */
  key?: string;
  /**
   * @remarks
   * The value of tag N.
   * 
   * Valid values of N: 1 to 3. A tag value can be 1 to 64 characters in length.
   * 
   * You can create a tag value or specify an existing tag value. For more information about how to obtain a tag value, see [DescribeTagKeyList](https://help.aliyun.com/document_detail/145557.html).
   * 
   * > The tag value cannot start with `aliyun` or `acs:`. The tag key (`Tag.N.Key`) and tag value (`Tag.N.Value`) must be specified at the same time.
   * 
   * This parameter is required.
   * 
   * @example
   * value1
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApplyMetricRuleTemplateResponseBodyResourceAlertResults extends $tea.Model {
  /**
   * @remarks
   * The responses code.
   * 
   * >  The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * alert rule is creating, please wait a few minutes.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the alert rule.
   * 
   * @example
   * applyTemplate8ab74c6b-9f27-47ab-8841-de01dc08****
   */
  ruleId?: string;
  /**
   * @remarks
   * The name of the alert rule.
   * 
   * @example
   * test123
   */
  ruleName?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      ruleId: 'RuleId',
      ruleName: 'RuleName',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      ruleId: 'string',
      ruleName: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApplyMetricRuleTemplateResponseBodyResource extends $tea.Model {
  /**
   * @remarks
   * The details of the generated alert rule.
   */
  alertResults?: ApplyMetricRuleTemplateResponseBodyResourceAlertResults[];
  /**
   * @remarks
   * The ID of the application group.
   * 
   * @example
   * 123456
   */
  groupId?: number;
  static names(): { [key: string]: string } {
    return {
      alertResults: 'AlertResults',
      groupId: 'GroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertResults: { 'type': 'array', 'itemType': ApplyMetricRuleTemplateResponseBodyResourceAlertResults },
      groupId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCreateInstantSiteMonitorRequestTaskList extends $tea.Model {
  /**
   * @remarks
   * The URL or IP address that is monitored by the task.
   * 
   * >  You must create at least one site monitoring task. You must specify all of the `Address`, `TaskName`, and `TaskType` parameters in each request.
   * 
   * @example
   * https://www.aliyun.com
   */
  address?: string;
  /**
   * @remarks
   * The detection points. If you leave this parameter empty, the system randomly selects three detection points.
   * 
   * The value is a `JSON array`. Example: `{"city":"546","isp":"465"},{"city":"572","isp":"465"},{"city":"738","isp":"465"}`. The values of the city field indicate Beijing, Hangzhou, and Qingdao.
   * 
   * For information about how to obtain detection points, see [DescribeSiteMonitorISPCityList](https://help.aliyun.com/document_detail/115045.html).
   * 
   * @example
   * [{"city":"546","isp":"465"},{"city":"572","isp":"465"},{"city":"738","isp":"465"}]
   */
  ispCities?: string;
  /**
   * @remarks
   * The extended options of the protocol that is used by the site monitoring task. The options vary based on the protocol.
   * 
   * @example
   * {"time_out":5000}
   */
  optionsJson?: string;
  /**
   * @remarks
   * The name of the site monitoring task.
   * 
   * The name must be 4 to 100 characters in length, and can contain letters, digits, and underscores (_).
   * 
   * >  You must create at least one site monitoring task. You must specify all of the `Address`, `TaskName`, and `TaskType` parameters in each request.
   * 
   * @example
   * HangZhou_ECS1
   */
  taskName?: string;
  /**
   * @remarks
   * The type of the site monitoring task.
   * 
   * Valid values: HTTP, PING, TCP, UDP, DNS, SMTP, POP3, and FTP.
   * 
   * >  You must create at least one site monitoring task. You must specify all of the `Address`, `TaskName`, and `TaskType` parameters in each request.
   * 
   * @example
   * HTTP
   */
  taskType?: string;
  static names(): { [key: string]: string } {
    return {
      address: 'Address',
      ispCities: 'IspCities',
      optionsJson: 'OptionsJson',
      taskName: 'TaskName',
      taskType: 'TaskType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      address: 'string',
      ispCities: 'string',
      optionsJson: 'string',
      taskName: 'string',
      taskType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCreateInstantSiteMonitorResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The ID of the site monitoring task.
   * 
   * @example
   * 679fbe4f-b80b-4706-91b2-5427b43e****
   */
  taskId?: string;
  /**
   * @remarks
   * The name of the site monitoring task.
   * 
   * @example
   * HangZhou_ECS1
   */
  taskName?: string;
  static names(): { [key: string]: string } {
    return {
      taskId: 'TaskId',
      taskName: 'TaskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      taskId: 'string',
      taskName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDynamicTagGroupRequestMatchExpress extends $tea.Model {
  /**
   * @remarks
   * The keys of the tags that are used to create the application group. If a specified key is attached to multiple resources, the resources that have the same key-value pair are added to the same group.
   * 
   * @example
   * appname
   */
  tagName?: string;
  /**
   * @remarks
   * The tag values of the cloud resources. In this example, set the value of N to 1.
   * 
   * >  If you set the `MatchExpress.N.TagValueMatchFunction` parameter, you must also set the `MatchExpress.N.TagValue` parameter.
   * 
   * @example
   * instance
   */
  tagValue?: string;
  /**
   * @remarks
   * The method that is used to match the tag values of the cloud resources. In this example, set the value of N to 1. Valid values:
   * 
   * *   contains: contains
   * *   startWith: starts with a prefix
   * *   endWith: ends with a suffix
   * *   notContains: does not contain
   * *   equals: equals
   * *   all: matches all
   * 
   * >  If you set the `MatchExpress.N.TagValueMatchFunction` parameter, you must also set the `MatchExpress.N.TagValue` parameter.
   * 
   * @example
   * contains
   */
  tagValueMatchFunction?: string;
  static names(): { [key: string]: string } {
    return {
      tagName: 'TagName',
      tagValue: 'TagValue',
      tagValueMatchFunction: 'TagValueMatchFunction',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagName: 'string',
      tagValue: 'string',
      tagValueMatchFunction: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateGroupMetricRulesRequestGroupMetricRulesEscalationsCritical extends $tea.Model {
  comparisonOperator?: string;
  n?: string;
  preCondition?: string;
  statistics?: string;
  threshold?: string;
  times?: number;
  static names(): { [key: string]: string } {
    return {
      comparisonOperator: 'ComparisonOperator',
      n: 'N',
      preCondition: 'PreCondition',
      statistics: 'Statistics',
      threshold: 'Threshold',
      times: 'Times',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comparisonOperator: 'string',
      n: 'string',
      preCondition: 'string',
      statistics: 'string',
      threshold: 'string',
      times: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateGroupMetricRulesRequestGroupMetricRulesEscalationsInfo extends $tea.Model {
  comparisonOperator?: string;
  n?: string;
  preCondition?: string;
  statistics?: string;
  threshold?: string;
  times?: number;
  static names(): { [key: string]: string } {
    return {
      comparisonOperator: 'ComparisonOperator',
      n: 'N',
      preCondition: 'PreCondition',
      statistics: 'Statistics',
      threshold: 'Threshold',
      times: 'Times',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comparisonOperator: 'string',
      n: 'string',
      preCondition: 'string',
      statistics: 'string',
      threshold: 'string',
      times: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateGroupMetricRulesRequestGroupMetricRulesEscalationsWarn extends $tea.Model {
  comparisonOperator?: string;
  n?: string;
  preCondition?: string;
  statistics?: string;
  threshold?: string;
  times?: number;
  static names(): { [key: string]: string } {
    return {
      comparisonOperator: 'ComparisonOperator',
      n: 'N',
      preCondition: 'PreCondition',
      statistics: 'Statistics',
      threshold: 'Threshold',
      times: 'Times',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comparisonOperator: 'string',
      n: 'string',
      preCondition: 'string',
      statistics: 'string',
      threshold: 'string',
      times: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateGroupMetricRulesRequestGroupMetricRulesEscalations extends $tea.Model {
  critical?: CreateGroupMetricRulesRequestGroupMetricRulesEscalationsCritical;
  info?: CreateGroupMetricRulesRequestGroupMetricRulesEscalationsInfo;
  warn?: CreateGroupMetricRulesRequestGroupMetricRulesEscalationsWarn;
  static names(): { [key: string]: string } {
    return {
      critical: 'Critical',
      info: 'Info',
      warn: 'Warn',
    };
  }

  static types(): { [key: string]: any } {
    return {
      critical: CreateGroupMetricRulesRequestGroupMetricRulesEscalationsCritical,
      info: CreateGroupMetricRulesRequestGroupMetricRulesEscalationsInfo,
      warn: CreateGroupMetricRulesRequestGroupMetricRulesEscalationsWarn,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateGroupMetricRulesRequestGroupMetricRulesLabels extends $tea.Model {
  /**
   * @remarks
   * The tag key of the alert rule. The specified tag is contained in alert notifications.
   * 
   * Valid values of N: 1 to 200.
   * 
   * @example
   * key1
   */
  key?: string;
  /**
   * @remarks
   * The tag value of the alert rule. The specified tag is contained in alert notifications.
   * 
   * Valid values of N: 1 to 200.
   * 
   * @example
   * value1
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateGroupMetricRulesRequestGroupMetricRules extends $tea.Model {
  escalations?: CreateGroupMetricRulesRequestGroupMetricRulesEscalations;
  /**
   * @remarks
   * The name of the cloud service. Valid values of N: 1 to 200. Valid value:
   * 
   * *   PolarDB: PolarDB
   * *   NewBGPDDoS: Anti-DDoS Pro
   * *   IoTDevice: IoT Platform
   * *   DRDS: Distributed Relational Database Service (DRDS)
   * *   VS: Video Surveillance System
   * *   AMQP: Alibaba Cloud Message Queue for AMQP
   * *   ADS: AnalyticDB
   * *   APIGateway: API Gateway
   * *   InternetSharedBandwidth: EIP Bandwidth Plan
   * *   CDN: Alibaba Cloud Content Delivery Network (CDN)
   * *   CEN: Cloud Enterprise Network (CEN)
   * *   DCDN: Dynamic Route for CDN (DCDN)
   * *   DDoS: Anti-DDoS
   * *   ECS: Elastic Compute Service (ECS)
   * *   DirectMail: Direct Mail
   * *   Elasticsearch: Elasticsearch
   * *   EMR: E-MapReduce (EMR)
   * *   ESS: Auto Scaling
   * *   FunctionCompute: Function Compute
   * *   RealtimeCompute: Realtime Compute for Apache Flink
   * *   GlobalAcceleration: Global Accelerator (GA)
   * *   Hbase: ApsaraDB for HBase
   * *   TSDB: Time Series Database (TSDB)
   * *   IPv6trans: IPv6 Translation Service
   * *   Kafka: Message Queue for Apache Kafka
   * *   Kubernetes: Container Service for Kubernetes (ACK)
   * *   KVstore: ApsaraDB for Redis
   * *   MNS: Message Service (MNS)
   * *   MongoDB: ApsaraDB for MongoDB
   * *   MQ: Message Queue
   * *   NAT: NAT Gateway
   * *   OpenAd: Open Ad
   * *   OpenSearch: Open Search
   * *   OSS: Object Storage Service (OSS)
   * *   PCDN: P2P CDN
   * *   petadata: HybridDB for MySQL
   * *   RDS: ApsaraDB RDS
   * *   SCDN: Secure CDN
   * *   SLB: Server Load Balancer (SLB)
   * *   SLS: Log Service
   * *   VideoLive: ApsaraVideo Live
   * *   VOD: ApsaraVideo VOD
   * *   EIP: Elastic IP Address (EIP)
   * *   VPN: VPN Gateway
   * *   AIRec: Artificial Intelligence Recommendation
   * *   GPDB: AnalyticDB for PostgreSQL
   * *   DBS: Database Backup (DBS)
   * *   SAG: Smart Access Gateway (SAG)
   * *   Memcache: ApsaraDB for Memcache
   * *   IOT_EDGE: Link IoT Edge
   * *   OCS: ApsaraDB for Memcache (previous version)
   * *   VPC: Express Connect
   * *   EHPC: Elastic High Performance Computing (E-HPC)
   * *   MPS: ApsaraVideo Media Processing
   * *   ENS: Edge Node Service (ENS)
   * *   MaxCompute_Prepay: MaxCompute
   * *   IoT_Kubernetes: Edge Application Hosting
   * *   CMS: CloudMonitor
   * *   batchcomputenew: Batch Compute
   * *   HBaseUE: ApsaraDB for HBase Performance-enhanced Edition
   * *   UIS: Ultimate Internet Service (UIS)
   * *   nls: Intelligent Speech Interaction
   * *   ots: Tablestore
   * *   NAS: Apsara File Storage NAS
   * *   ECI: Elastic Container Instance (ECI)
   * *   OpenAPI: OpenAPI Explorer
   * *   pvtzpost: Alibaba Cloud DNS PrivateZone
   * *   blinkonk8s: Flink on Kubernetes
   * *   FunctionFlow: Serverless Workflow (SWF)
   * *   SMC: Server Migration Center (SMC)
   * *   ddosbgp: Anti-DDoS Origin
   * *   baas: Blockchain as a Service
   * *   privatelink: PrivateLink
   * *   cds: ApsaraDB for Cassandra
   * *   DDH: Dedicated Host
   * *   RocketMQ: Message Queue for Apache RocketMQ
   * *   ECC: Express Cloud Connect
   * *   hbaseserverless: ApsaraDB for HBase Serverless Edition
   * *   mns_tmp: Message Service
   * *   hdr: Hybrid Disaster Recovery (HDR)
   * *   hbr: Hybrid Backup Recovery (HBR)
   * *   ADB: AnalyticDB for MySQL V3.0
   * *   tag: Tag Service
   * *   GDB: Graph Database
   * *   WAF: Web Application Firewall (WAF)
   * *   hcs_sgw: Cloud Storage Gateway (CSG)
   * *   ipv6gateway: IPv6 Gateway
   * *   RDS_SAR: ApsaraDB Exclusive Host Group
   * *   learn: Machine Learning Platform for AI
   * *   ROS: Resource Orchestration Service (ROS)
   * *   OOS: Operation Orchestration Service (OOS)
   * *   bds: Data Synchronization for HBase
   * *   cfw: Cloud Firewall
   * *   ddosDip: Anti-DDoS Premium
   * *   datahub: DataHub
   * *   hologres: Hologres
   * *   ExpressConnect: Express Connect
   * *   dbfs: Database File System (DBFS)
   * *   clickhouse: ApsaraDB for ClickHouse
   * *   k8s: Container Service for Kubernetes (ACK)
   * *   DTS: Data Transmission Service (DTS)
   * *   AnycastEIP: Anycast Elastic IP Address
   * *   Lindorm: ApsaraDB for Lindorm
   * *   config: Cloud Config
   * *   spark: Databricks DataInsight (DDI)
   * *   serverless: Serverless App Engine (SAE)
   * *   alb: Application Load Balancer (ALB)
   * *   oceanbase: ApsaraDB for OceanBase
   * *   KMS: Key Management Service (KMS)
   * *   lvwang: Content Moderation
   * *   LinkVisual: LinkVisual
   * *   tair: ApsaraDB for Redis Enhanced Edition (Tair)
   * *   dlf: Data Lake Formation (DLF)
   * *   networkmonitor: Site Monitoring
   * *   pnc: Physical Network Change
   * *   AIS: Alibaba Cloud Infrastructure
   * *   cloudgame: Cloud Gaming Platform
   * *   RTC: Real-Time Communication
   * *   cloudbox: CloudBox
   * *   actiontrail: ActionTrail
   * *   cc: Cloud Connector
   * *   disk: Elastic Block Storage (EBS)
   * *   easygene: Genomics Computing Platform
   * *   cloudphone: Elastic Cloud Phone
   * *   BMS: Bare Metal Management Service
   * *   swas: Simple Application Server
   * *   AvailabilityMonitoring: Availability Monitoring of CloudMonitor
   * 
   * This parameter is required.
   * 
   * @example
   * ECS
   */
  category?: string;
  /**
   * @remarks
   * The alert contact groups. Valid values of N: 1 to 200.
   * 
   * For information about how to obtain alert contact groups, see [DescribeContactGroupList](https://help.aliyun.com/document_detail/114922.html).
   * 
   * @example
   * ECS_Group
   */
  contactGroups?: string;
  /**
   * @remarks
   * The dimension of the alert rule. Valid values of N: 1 to 200.
   * 
   * Set the value to a set of key-value pairs, for example, `userId:120886317861****` or `instanceId:i-m5e1qg6uo38rztr4****`.
   * 
   * @example
   * [{"instanceId":"i-m5e1qg6uo38rztr4****"}]
   */
  dimensions?: string;
  /**
   * @remarks
   * The time period during which the alert rule is effective. Valid values of N: 1 to 200.
   * 
   * @example
   * 05:31-23:59
   */
  effectiveInterval?: string;
  /**
   * @remarks
   * The subject of the alert notification email. Valid values of N: 1 to 200.
   */
  emailSubject?: string;
  /**
   * @remarks
   * The interval at which CloudMonitor checks whether the alert rule is triggered. Valid values of N: 1 to 200.
   * 
   * Unit: seconds. The default value is the lowest frequency at which the metric is polled.
   * 
   * >  We recommend that you set the interval to the data aggregation period. If the interval is shorter than the data aggregation period, alerts cannot be triggered due to insufficient data.
   * 
   * @example
   * 60
   */
  interval?: string;
  labels?: CreateGroupMetricRulesRequestGroupMetricRulesLabels[];
  /**
   * @remarks
   * The name of the metric. Valid values of N: 1 to 200.
   * 
   * For information about how to obtain the name of a metric, see [DescribeMetricMetaList](https://help.aliyun.com/document_detail/98846.html) or [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * This parameter is required.
   * 
   * @example
   * cpu_total
   */
  metricName?: string;
  /**
   * @remarks
   * The namespace of the cloud service. Valid values of N: 1 to 200.
   * 
   * For information about how to obtain the namespace of a cloud service, see [DescribeMetricMetaList](https://help.aliyun.com/document_detail/98846.html) or [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * This parameter is required.
   * 
   * @example
   * acs_ecs_dashboard
   */
  namespace?: string;
  /**
   * @remarks
   * The method that is used to handle alerts when no monitoring data is found. Valid values of N: 1 to 200. Valid value:
   * 
   * *   KEEP_LAST_STATE (default value): No operation is performed.
   * *   INSUFFICIENT_DATA: An alert whose content is "Insufficient data" is triggered.
   * *   OK: The alert rule has no active alerts.
   * 
   * @example
   * KEEP_LAST_STATE
   */
  noDataPolicy?: string;
  /**
   * @remarks
   * The time period during which the alert rule is ineffective. Valid values of N: 1 to 200.
   * 
   * @example
   * 00:00-05:30
   */
  noEffectiveInterval?: string;
  options?: string;
  /**
   * @remarks
   * The aggregation period of the metric data. Valid values of N: 1 to 200.
   * 
   * Set the `Period` parameter to an integral multiple of 60. Unit: seconds. Default value: 300.
   * 
   * @example
   * 60
   */
  period?: string;
  /**
   * @remarks
   * The ID of the alert rule. Valid values of N: 1 to 200.
   * 
   * This parameter is required.
   * 
   * @example
   * 456789
   */
  ruleId?: string;
  /**
   * @remarks
   * The name of the alert rule. Valid values of N: 1 to 200.
   * 
   * This parameter is required.
   * 
   * @example
   * ECS_Rule1
   */
  ruleName?: string;
  /**
   * @remarks
   * The mute period during which new alerts are not sent even if the trigger conditions are met. Valid values of N: 1 to 200.
   * 
   * Unit: seconds. Default value: 86400. Minimum value: 3600.
   * 
   * @example
   * 86400
   */
  silenceTime?: number;
  /**
   * @remarks
   * The callback URL. Valid values of N: 1 to 200.
   * 
   * The callback URL must be accessible over the Internet. CloudMonitor pushes an alert notification to the specified callback URL by sending an HTTP POST request. Only the HTTP protocol is supported.
   * 
   * @example
   * https://www.aliyun.com
   */
  webhook?: string;
  static names(): { [key: string]: string } {
    return {
      escalations: 'Escalations',
      category: 'Category',
      contactGroups: 'ContactGroups',
      dimensions: 'Dimensions',
      effectiveInterval: 'EffectiveInterval',
      emailSubject: 'EmailSubject',
      interval: 'Interval',
      labels: 'Labels',
      metricName: 'MetricName',
      namespace: 'Namespace',
      noDataPolicy: 'NoDataPolicy',
      noEffectiveInterval: 'NoEffectiveInterval',
      options: 'Options',
      period: 'Period',
      ruleId: 'RuleId',
      ruleName: 'RuleName',
      silenceTime: 'SilenceTime',
      webhook: 'Webhook',
    };
  }

  static types(): { [key: string]: any } {
    return {
      escalations: CreateGroupMetricRulesRequestGroupMetricRulesEscalations,
      category: 'string',
      contactGroups: 'string',
      dimensions: 'string',
      effectiveInterval: 'string',
      emailSubject: 'string',
      interval: 'string',
      labels: { 'type': 'array', 'itemType': CreateGroupMetricRulesRequestGroupMetricRulesLabels },
      metricName: 'string',
      namespace: 'string',
      noDataPolicy: 'string',
      noEffectiveInterval: 'string',
      options: 'string',
      period: 'string',
      ruleId: 'string',
      ruleName: 'string',
      silenceTime: 'number',
      webhook: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateGroupMetricRulesResponseBodyResourcesAlertResult extends $tea.Model {
  /**
   * @remarks
   * The status code that is returned for the alert rule.
   * 
   * >  The status code 200 indicates that the call is successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The error message that is returned for the alert rule.
   * 
   * @example
   * Metric not found.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the alert rule.
   * 
   * @example
   * 456789
   */
  ruleId?: string;
  /**
   * @remarks
   * The name of the alert rule.
   * 
   * @example
   * ECS_Rule1
   */
  ruleName?: string;
  /**
   * @remarks
   * Indicates whether the alert rule was created. Valid value:
   * 
   * - true: The alert rule was created.
   * - false: The alert rule failed to be created.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      ruleId: 'RuleId',
      ruleName: 'RuleName',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      message: 'string',
      ruleId: 'string',
      ruleName: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateGroupMetricRulesResponseBodyResources extends $tea.Model {
  alertResult?: CreateGroupMetricRulesResponseBodyResourcesAlertResult[];
  static names(): { [key: string]: string } {
    return {
      alertResult: 'AlertResult',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertResult: { 'type': 'array', 'itemType': CreateGroupMetricRulesResponseBodyResourcesAlertResult },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateGroupMonitoringAgentProcessRequestAlertConfigTargetList extends $tea.Model {
  /**
   * @remarks
   * The Alibaba Cloud Resource Name (ARN) of the resource.
   * 
   * For information about how to obtain the ARN of a resource, see [DescribeMetricRuleTargets](https://help.aliyun.com/document_detail/121592.html).
   * 
   * Format: `acs:{Service name abbreviation}:{regionId}:{userId}:/{Resource type}/{Resource name}/message`. Example: `acs:mns:cn-hangzhou:120886317861****:/queues/test123/message`. Fields:
   * 
   * *   {Service name abbreviation}: the abbreviation of the service name. Valid value: mns.
   * 
   * *   {userId}: the ID of the Alibaba Cloud account.
   * 
   * *   {regionId}: the region ID of the message queue or topic.
   * 
   * *   {Resource type}: the type of the resource that triggers the alert. Valid values:
   * 
   *     *   **queues**
   *     *   **topics**
   * 
   * *   {Resource name}: the resource name.
   * 
   *     *   If the resource type is **queues**, the resource name is the queue name.
   *     *   If the resource type is **topics**, the resource name is the topic name.
   * 
   * @example
   * acs:mns:cn-hangzhou:120886317861****:/queues/test/message
   */
  arn?: string;
  /**
   * @remarks
   * The ID of the resource for which alerts are triggered.
   * 
   * For information about how to obtain the ID of a resource for which alerts are triggered, see [DescribeMetricRuleTargets](https://help.aliyun.com/document_detail/121592.html).
   * 
   * @example
   * 1
   */
  id?: string;
  /**
   * @remarks
   * The parameters of the alert callback. Specify the parameters in the JSON format.
   * 
   * @example
   * {"customField1":"value1","customField2":"$.name"}
   */
  jsonParams?: string;
  /**
   * @remarks
   * The alert level. Valid values:
   * 
   * *   INFO
   * *   WARN
   * *   CRITICAL
   * 
   * @example
   * ["INFO", "WARN", "CRITICAL"]
   */
  level?: string;
  static names(): { [key: string]: string } {
    return {
      arn: 'Arn',
      id: 'Id',
      jsonParams: 'JsonParams',
      level: 'Level',
    };
  }

  static types(): { [key: string]: any } {
    return {
      arn: 'string',
      id: 'string',
      jsonParams: 'string',
      level: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateGroupMonitoringAgentProcessRequestAlertConfig extends $tea.Model {
  /**
   * @remarks
   * The operator that is used to compare the metric value with the threshold. Valid values:
   * 
   * *   GreaterThanOrEqualToThreshold: greater than or equal to the threshold
   * *   GreaterThanThreshold: greater than the threshold
   * *   LessThanOrEqualToThreshold: less than or equal to the threshold
   * *   LessThanThreshold: less than the threshold
   * *   NotEqualToThreshold: not equal to the threshold
   * *   GreaterThanYesterday: greater than the metric value at the same time yesterday
   * *   LessThanYesterday: less than the metric value at the same time yesterday
   * *   GreaterThanLastWeek: greater than the metric value at the same time last week
   * *   LessThanLastWeek: less than the metric value at the same time last week
   * *   GreaterThanLastPeriod: greater than the metric value in the last monitoring cycle
   * *   LessThanLastPeriod: less than the metric value in the last monitoring cycle
   * 
   * Valid values of N: 1 to 3.
   * 
   * This parameter is required.
   * 
   * @example
   * GreaterThanOrEqualToThreshold
   */
  comparisonOperator?: string;
  /**
   * @remarks
   * The time period during which the alert rule is effective.
   * 
   * Valid values of N: 1 to 3.
   * 
   * @example
   * 00:00-23:59
   */
  effectiveInterval?: string;
  /**
   * @remarks
   * The alert level. Valid values:
   * 
   * *   critical (default): critical
   * *   warn: warning
   * *   info: information
   * 
   * Valid values of N: 1 to 3.
   * 
   * This parameter is required.
   * 
   * @example
   * warn
   */
  escalationsLevel?: string;
  /**
   * @remarks
   * This parameter is deprecated.
   * 
   * @example
   * 00:00-23:59
   */
  noEffectiveInterval?: string;
  /**
   * @remarks
   * The mute period during which new alert notifications are not sent even if the trigger conditions are met. Unit: seconds. Minimum value: 3600, which is equivalent to one hour. Default value: 86400, which is equivalent to one day.
   * 
   * Valid values of N: 1 to 3.
   * 
   * >  Only one alert notification is sent during each mute period even if the metric value exceeds the alert threshold several times.
   * 
   * @example
   * 86400
   */
  silenceTime?: string;
  /**
   * @remarks
   * The statistical method for alerts.
   * 
   * Valid values of N: 1 to 3.
   * 
   * >  Set the value to Average.
   * 
   * This parameter is required.
   * 
   * @example
   * Average
   */
  statistics?: string;
  /**
   * @remarks
   * The alert triggers.
   */
  targetList?: CreateGroupMonitoringAgentProcessRequestAlertConfigTargetList[];
  /**
   * @remarks
   * The alert threshold.
   * 
   * Valid values of N: 1 to 3.
   * 
   * Unit: cores.
   * 
   * This parameter is required.
   * 
   * @example
   * 5
   */
  threshold?: string;
  /**
   * @remarks
   * The number of times for which the threshold can be consecutively exceeded. Default value: 3.
   * 
   * Valid values of N: 1 to 3.
   * 
   * >  An alert is triggered only if the number of times for which the threshold can be consecutively exceeded is reached.
   * 
   * This parameter is required.
   * 
   * @example
   * 3
   */
  times?: string;
  /**
   * @remarks
   * The callback URL.
   * 
   * Valid values of N: 1 to 3.
   * 
   * @example
   * http://www.aliyun.com
   */
  webhook?: string;
  static names(): { [key: string]: string } {
    return {
      comparisonOperator: 'ComparisonOperator',
      effectiveInterval: 'EffectiveInterval',
      escalationsLevel: 'EscalationsLevel',
      noEffectiveInterval: 'NoEffectiveInterval',
      silenceTime: 'SilenceTime',
      statistics: 'Statistics',
      targetList: 'TargetList',
      threshold: 'Threshold',
      times: 'Times',
      webhook: 'Webhook',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comparisonOperator: 'string',
      effectiveInterval: 'string',
      escalationsLevel: 'string',
      noEffectiveInterval: 'string',
      silenceTime: 'string',
      statistics: 'string',
      targetList: { 'type': 'array', 'itemType': CreateGroupMonitoringAgentProcessRequestAlertConfigTargetList },
      threshold: 'string',
      times: 'string',
      webhook: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateGroupMonitoringAgentProcessRequestMatchExpress extends $tea.Model {
  /**
   * @remarks
   * The matching condition. Valid values:
   * 
   * *   all (default value): matches all
   * *   startWith: starts with a prefix
   * *   endWith: ends with a suffix
   * *   contains: contains
   * *   notContains: does not contain
   * *   equals: equals
   * 
   * Valid values of N: 1 to 3.
   * 
   * @example
   * startWith
   */
  function?: string;
  /**
   * @remarks
   * The criteria based on which the instances are matched.
   * 
   * Valid values of N: 1 to 3.
   * 
   * > Set the value to name. The value name indicates that the instances are matched based on the instance name.
   * 
   * @example
   * name1
   */
  name?: string;
  /**
   * @remarks
   * The keyword used to match the instance name.
   * 
   * Valid values of N: 1 to 3.
   * 
   * @example
   * portalHost
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      function: 'Function',
      name: 'Name',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      function: 'string',
      name: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateGroupMonitoringAgentProcessResponseBodyResource extends $tea.Model {
  /**
   * @remarks
   * The ID of the group process.
   * 
   * @example
   * 7F2B0024-4F21-48B9-A764-211CEC48****
   */
  groupProcessId?: string;
  static names(): { [key: string]: string } {
    return {
      groupProcessId: 'GroupProcessId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupProcessId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHostAvailabilityRequestAlertConfig extends $tea.Model {
  /**
   * @remarks
   * The end of the time range during which the alert rule is effective. Valid values: 0 to 23.
   * 
   * For example, if the `AlertConfig.StartTime` parameter is set to 0 and the `AlertConfig.EndTime` parameter is set to 22, the alert rule is effective from 00:00:00 to 22:00:00.
   * 
   * > Alert notifications are sent based on the specified threshold only if the alert rule is effective.
   * 
   * @example
   * 22
   */
  endTime?: number;
  /**
   * @remarks
   * The alert notification methods. Valid values:
   * 
   * 0: Alert notifications are sent by using emails and DingTalk chatbots.
   * 
   * This parameter is required.
   * 
   * @example
   * 0
   */
  notifyType?: number;
  /**
   * @remarks
   * The mute period during which new alerts are not sent even if the trigger conditions are met. Unit: seconds. Default value: 86400. The default value indicates one day.
   * 
   * @example
   * 86400
   */
  silenceTime?: number;
  /**
   * @remarks
   * The beginning of the time range during which the alert rule is effective. Valid values: 0 to 23.
   * 
   * For example, if the `AlertConfig.StartTime` parameter is set to 0 and the `AlertConfig.EndTime` parameter is set to 22, the alert rule is effective from 00:00:00 to 22:00:00.
   * 
   * > Alert notifications are sent based on the specified threshold only if the alert rule is effective.
   * 
   * @example
   * 0
   */
  startTime?: number;
  /**
   * @remarks
   * The callback URL.
   * 
   * @example
   * https://www.aliyun.com/webhook.json
   */
  webHook?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      notifyType: 'NotifyType',
      silenceTime: 'SilenceTime',
      startTime: 'StartTime',
      webHook: 'WebHook',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      notifyType: 'number',
      silenceTime: 'number',
      startTime: 'number',
      webHook: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHostAvailabilityRequestTaskOption extends $tea.Model {
  /**
   * @remarks
   * The header of the HTTP request. Format: `Parameter name:Parameter value`. Separate multiple parameters with carriage return characters. Example:
   * 
   *     params1:value1
   *     params2:value2
   * 
   * @example
   * token:testTokenValue
   */
  httpHeader?: string;
  /**
   * @remarks
   * The HTTP request method. Valid values:
   * 
   * *   GET
   * *   POST
   * *   HEAD
   * 
   * > This parameter must be specified when TaskType is set to HTTP.
   * 
   * @example
   * GET
   */
  httpMethod?: string;
  /**
   * @remarks
   * The method to trigger an alert. The alert can be triggered based on whether the specified alert rule is included in the response body. Valid values:
   * 
   * *   true: If the HTTP response body includes the alert rule, an alert is triggered.
   * *   false: If the HTTP response does not include the alert rule, an alert is triggered.
   * 
   * > This parameter must be specified when TaskType is set to HTTP.
   * 
   * @example
   * true
   */
  httpNegative?: boolean;
  /**
   * @remarks
   * The content of the HTTP POST request.
   * 
   * @example
   * params1=paramsValue1
   */
  httpPostContent?: string;
  /**
   * @remarks
   * The character set that is used in the HTTP response.
   * 
   * > Only UTF-8 is supported.
   * 
   * @example
   * UTF-8
   */
  httpResponseCharset?: string;
  /**
   * @remarks
   * The response to the HTTP request.
   * 
   * @example
   * ok
   */
  httpResponseMatchContent?: string;
  /**
   * @remarks
   * The URI that you want to monitor. This parameter must be specified when TaskType is set to HTTP.
   * 
   * @example
   * https://www.aliyun.com
   */
  httpURI?: string;
  /**
   * @remarks
   * The interval at which detection requests are sent. Unit: seconds. Valid values: 15, 30, 60, 120, 300, 900, 1800, and 3600.
   * 
   * > This parameter is available only for the CloudMonitor agent V3.5.1 or later.
   * 
   * @example
   * 60
   */
  interval?: number;
  /**
   * @remarks
   * The domain name or IP address that you want to monitor.
   * 
   * > This parameter must be specified when TaskType is set to PING or TELNET.
   * 
   * @example
   * www.aliyun.com
   */
  telnetOrPingHost?: string;
  static names(): { [key: string]: string } {
    return {
      httpHeader: 'HttpHeader',
      httpMethod: 'HttpMethod',
      httpNegative: 'HttpNegative',
      httpPostContent: 'HttpPostContent',
      httpResponseCharset: 'HttpResponseCharset',
      httpResponseMatchContent: 'HttpResponseMatchContent',
      httpURI: 'HttpURI',
      interval: 'Interval',
      telnetOrPingHost: 'TelnetOrPingHost',
    };
  }

  static types(): { [key: string]: any } {
    return {
      httpHeader: 'string',
      httpMethod: 'string',
      httpNegative: 'boolean',
      httpPostContent: 'string',
      httpResponseCharset: 'string',
      httpResponseMatchContent: 'string',
      httpURI: 'string',
      interval: 'number',
      telnetOrPingHost: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHostAvailabilityRequestAlertConfigEscalationList extends $tea.Model {
  /**
   * @remarks
   * The method used to calculate the metric values that trigger alerts. Valid values of N: 1 to 21. Valid values:
   * 
   * *   HttpStatus: Value
   * *   HttpLatency: Average
   * *   TelnetStatus: Value
   * *   TelnetLatency: Average
   * *   PingLostRate: Average
   * 
   * > The value Value indicates the original value and is used for metrics such as status codes. The value Average indicates the average value and is used for metrics such as the latency and packet loss rate.
   * 
   * @example
   * Value
   */
  aggregate?: string;
  /**
   * @remarks
   * The metric for which the alert feature is enabled. Valid values of N: 1 to 21. Valid values:
   * 
   * *   HttpStatus: HTTP status code
   * *   HttpLatency: HTTP response time
   * *   TelnetStatus: Telnet status code
   * *   TelnetLatency: Telnet response time
   * *   PingLostRate: Ping packet loss rate
   * 
   * This parameter is required.
   * 
   * @example
   * HttpStatus
   */
  metricName?: string;
  /**
   * @remarks
   * The comparison operator that is used in the alert rule. Valid values of N: 1 to 21. Valid values:
   * 
   * *   `>`
   * *   `>=`
   * *   `<`
   * *   `<=`
   * *   `=`
   * 
   * @example
   * >
   */
  operator?: string;
  /**
   * @remarks
   * The consecutive number of times for which the metric value meets the alert condition before an alert is triggered. Valid values of N: 1 to 21.
   * 
   * @example
   * 3
   */
  times?: number;
  /**
   * @remarks
   * The alert threshold. Valid values of N: 1 to 21.
   * 
   * @example
   * 90
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      aggregate: 'Aggregate',
      metricName: 'MetricName',
      operator: 'Operator',
      times: 'Times',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aggregate: 'string',
      metricName: 'string',
      operator: 'string',
      times: 'number',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHostAvailabilityRequestAlertConfigTargetList extends $tea.Model {
  /**
   * @remarks
   * The Alibaba Cloud Resource Name (ARN) of the resource. Format: `acs:{Service name abbreviation}:{regionId}:{userId}:/{Resource type}/{Resource name}/message`. Example: `acs:mns:cn-hangzhou:120886317861****:/queues/test123/message`. Fields:
   * 
   * *   {Service name abbreviation}: the abbreviation of the service name. Valid value: mns.
   * 
   * *   {userId}: the ID of the Alibaba Cloud account.
   * 
   * *   {regionId}: the region ID of the message queue or topic.
   * 
   * *   {Resource type}: the type of the resource that triggers the alert. Valid values:
   * 
   *     *   **queues**
   *     *   **topics**
   * 
   * *   {Resource name}: the resource name.
   * 
   *     *   If the resource type is **queues**, the resource name is the queue name.
   *     *   If the resource type is **topics**, the resource name is the topic name.
   * 
   * @example
   * acs:mns:cn-hangzhou:120886317861****:/queues/test/message
   */
  arn?: string;
  /**
   * @remarks
   * The ID of the resource for which alerts are triggered.
   * 
   * @example
   * 1
   */
  id?: string;
  /**
   * @remarks
   * The parameters of the alert callback. The parameters are in the JSON format.
   * 
   * @example
   * {"customField1":"value1","customField2":"$.name"}
   */
  jsonParams?: string;
  /**
   * @remarks
   * The alert level. Valid values:
   * 
   * *   INFO
   * *   WARN
   * *   CRITICAL
   * 
   * @example
   * ["INFO", "WARN", "CRITICAL"]
   */
  level?: string;
  static names(): { [key: string]: string } {
    return {
      arn: 'Arn',
      id: 'Id',
      jsonParams: 'JsonParams',
      level: 'Level',
    };
  }

  static types(): { [key: string]: any } {
    return {
      arn: 'string',
      id: 'string',
      jsonParams: 'string',
      level: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHybridMonitorSLSGroupRequestSLSGroupConfig extends $tea.Model {
  /**
   * @remarks
   * The Logstore.
   * 
   * Valid values of N: 1 to 25.
   * 
   * This parameter is required.
   * 
   * @example
   * Logstore-ECS
   */
  SLSLogstore?: string;
  /**
   * @remarks
   * The Simple Log Service project.
   * 
   * Valid values of N: 1 to 25.
   * 
   * This parameter is required.
   * 
   * @example
   * aliyun-project
   */
  SLSProject?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * Valid values of N: 1 to 25.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  SLSRegion?: string;
  /**
   * @remarks
   * The member ID.
   * 
   * Valid values of N: 1 to 25.
   * 
   * If you call this operation by using the management account of a resource directory, you can connect the Alibaba Cloud services that are activated for all members in the resource directory to Hybrid Cloud Monitoring. You can use the resource directory to monitor Alibaba Cloud services across enterprise accounts.
   * 
   * > If a member uses CloudMonitor for the first time, you must make sure that the service-linked role AliyunServiceRoleForCloudMonitor is attached to the member. For more information, see [Manage the service-linked role for CloudMonitor](https://help.aliyun.com/document_detail/170423.html).
   * 
   * @example
   * 120886317861****
   */
  SLSUserId?: string;
  static names(): { [key: string]: string } {
    return {
      SLSLogstore: 'SLSLogstore',
      SLSProject: 'SLSProject',
      SLSRegion: 'SLSRegion',
      SLSUserId: 'SLSUserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      SLSLogstore: 'string',
      SLSProject: 'string',
      SLSRegion: 'string',
      SLSUserId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHybridMonitorTaskRequestAttachLabels extends $tea.Model {
  /**
   * @remarks
   * The tag key of the metric.
   * 
   * @example
   * app_service
   */
  name?: string;
  /**
   * @remarks
   * The tag value of the metric.
   * 
   * @example
   * testValue
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHybridMonitorTaskRequestSLSProcessConfigExpress extends $tea.Model {
  /**
   * @remarks
   * The alias of the extended field that specifies the result of basic operations performed on aggregation results.
   * 
   * @example
   * SuccRate
   */
  alias?: string;
  /**
   * @remarks
   * The extended field that specifies the result of basic operations performed on aggregation results.
   * 
   * @example
   * success_count
   */
  express?: string;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      express: 'Express',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      express: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHybridMonitorTaskRequestSLSProcessConfigFilterFilters extends $tea.Model {
  /**
   * @remarks
   * The method that is used to filter logs imported from Simple Log Service. Valid values:
   * 
   * *   `contain`: contains
   * *   `notContain`: does not contain
   * *   `>`: greater than
   * *   `<`: less than
   * *   `=`: equal to
   * *   `! =`: not equal to
   * *   `>=`: greater than or equal to
   * *   `<=`: less than or equal to
   * 
   * @example
   * =
   */
  operator?: string;
  /**
   * @remarks
   * The name of the key that is used to filter logs imported from Simple Log Service.
   * 
   * @example
   * code
   */
  SLSKeyName?: string;
  /**
   * @remarks
   * The value of the key that is used to filter logs imported from Simple Log Service.
   * 
   * @example
   * 200
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      operator: 'Operator',
      SLSKeyName: 'SLSKeyName',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      operator: 'string',
      SLSKeyName: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHybridMonitorTaskRequestSLSProcessConfigFilter extends $tea.Model {
  /**
   * @remarks
   * The conditions that are used to filter logs imported from Simple Log Service.
   */
  filters?: CreateHybridMonitorTaskRequestSLSProcessConfigFilterFilters[];
  /**
   * @remarks
   * The relationship between multiple filter conditions. Valid values:
   * 
   * *   and (default): Logs are processed only if all filter conditions are met.
   * *   or: Logs are processed if one of the filter conditions is met.
   * 
   * @example
   * and
   */
  relation?: string;
  static names(): { [key: string]: string } {
    return {
      filters: 'Filters',
      relation: 'Relation',
    };
  }

  static types(): { [key: string]: any } {
    return {
      filters: { 'type': 'array', 'itemType': CreateHybridMonitorTaskRequestSLSProcessConfigFilterFilters },
      relation: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHybridMonitorTaskRequestSLSProcessConfigGroupBy extends $tea.Model {
  /**
   * @remarks
   * The alias of the aggregation result.
   * 
   * @example
   * ApiResult
   */
  alias?: string;
  /**
   * @remarks
   * The name of the key that is used to aggregate logs imported from Simple Log Service.
   * 
   * @example
   * code
   */
  SLSKeyName?: string;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      SLSKeyName: 'SLSKeyName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      SLSKeyName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHybridMonitorTaskRequestSLSProcessConfigStatistics extends $tea.Model {
  /**
   * @remarks
   * The alias of the aggregation result.
   * 
   * @example
   * level_count
   */
  alias?: string;
  /**
   * @remarks
   * The function that is used to aggregate the log data of a statistical period. Valid values:
   * 
   * *   count: counts the number.
   * *   sum: calculates the total value.
   * *   avg: calculates the average value.
   * *   max: calculates the maximum value.
   * *   min: calculates the minimum value.
   * *   value: collects samples within the statistical period.
   * *   countps: calculates the number of values of the specified field divided by the total number of seconds within a statistical period.
   * *   sumps: calculates the sum of the values of the specified field divided by the total number of seconds within a statistical period.
   * *   distinct: calculates the number of unique values of the specified field within a statistical period.
   * *   distribution: calculates the number of logs that meet a specified condition within the statistical period.
   * *   percentile: sorts the values of the specified field in ascending order, and then returns the value that is at the specified percentile within the statistical period. Example: P50.
   * 
   * @example
   * count
   */
  function?: string;
  /**
   * @remarks
   * The value of the function that is used to aggregate logs imported from Simple Log Service.
   * 
   * *   If the `Function` parameter is set to `distribution`, this parameter specifies the lower limit of the statistical interval. For example, if you want to calculate the number of HTTP requests whose status code is 2XX, set this parameter to 200.
   * *   If the `Function` parameter is set to `percentile`, this parameter specifies the percentile at which the expected value is. For example, 0.5 specifies P50.
   * 
   * @example
   * 200
   */
  parameter1?: string;
  /**
   * @remarks
   * The value of the function that is used to aggregate logs imported from Simple Log Service.
   * 
   * >  This parameter is required only if the `Function` parameter is set to `distribution`. This parameter specifies the upper limit of the statistical interval. For example, if you want to calculate the number of HTTP requests whose status code is 2XX, set this parameter to 299.
   * 
   * @example
   * 299
   */
  parameter2?: string;
  /**
   * @remarks
   * The name of the key that is used to aggregate logs imported from Simple Log Service.
   * 
   * @example
   * name
   */
  SLSKeyName?: string;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      function: 'Function',
      parameter1: 'Parameter1',
      parameter2: 'Parameter2',
      SLSKeyName: 'SLSKeyName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      function: 'string',
      parameter1: 'string',
      parameter2: 'string',
      SLSKeyName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHybridMonitorTaskRequestSLSProcessConfig extends $tea.Model {
  /**
   * @remarks
   * The extended fields that specify the results of basic operations performed on aggregation results.
   */
  express?: CreateHybridMonitorTaskRequestSLSProcessConfigExpress[];
  /**
   * @remarks
   * The conditions that are used to filter logs imported from Simple Log Service.
   */
  filter?: CreateHybridMonitorTaskRequestSLSProcessConfigFilter;
  /**
   * @remarks
   * The dimension based on which data is aggregated. This parameter is equivalent to the GROUP BY clause in SQL.
   */
  groupBy?: CreateHybridMonitorTaskRequestSLSProcessConfigGroupBy[];
  /**
   * @remarks
   * The method that is used to aggregate logs imported from Simple Log Service.
   */
  statistics?: CreateHybridMonitorTaskRequestSLSProcessConfigStatistics[];
  static names(): { [key: string]: string } {
    return {
      express: 'Express',
      filter: 'Filter',
      groupBy: 'GroupBy',
      statistics: 'Statistics',
    };
  }

  static types(): { [key: string]: any } {
    return {
      express: { 'type': 'array', 'itemType': CreateHybridMonitorTaskRequestSLSProcessConfigExpress },
      filter: CreateHybridMonitorTaskRequestSLSProcessConfigFilter,
      groupBy: { 'type': 'array', 'itemType': CreateHybridMonitorTaskRequestSLSProcessConfigGroupBy },
      statistics: { 'type': 'array', 'itemType': CreateHybridMonitorTaskRequestSLSProcessConfigStatistics },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateInstantSiteMonitorResponseBodyCreateResultList extends $tea.Model {
  /**
   * @remarks
   * The ID of the instant test task.
   * 
   * @example
   * 2c8dbdf9-a3ab-46a1-85a4-f094965e****
   */
  taskId?: string;
  /**
   * @remarks
   * The name of the instant test task.
   * 
   * @example
   * task1
   */
  taskName?: string;
  static names(): { [key: string]: string } {
    return {
      taskId: 'TaskId',
      taskName: 'TaskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      taskId: 'string',
      taskName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMetricRuleBlackListRequestMetrics extends $tea.Model {
  /**
   * @remarks
   * The metric name.
   * 
   * Valid values of N: 1 to 10.
   * 
   * This parameter is required.
   * 
   * @example
   * disk_utilization
   */
  metricName?: string;
  /**
   * @remarks
   * The extended dimension of the instance. For example, `{"device":"C:"}` specifies that the blacklist policy is applied to all C disks of the specified Elastic Compute Service (ECS) instance.
   * 
   * Valid values of N: 1 to 10.
   * 
   * @example
   * {"device":"C:"}
   */
  resource?: string;
  static names(): { [key: string]: string } {
    return {
      metricName: 'MetricName',
      resource: 'Resource',
    };
  }

  static types(): { [key: string]: any } {
    return {
      metricName: 'string',
      resource: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMetricRuleTemplateRequestAlertTemplatesEscalationsCritical extends $tea.Model {
  comparisonOperator?: string;
  n?: number;
  statistics?: string;
  threshold?: string;
  times?: number;
  static names(): { [key: string]: string } {
    return {
      comparisonOperator: 'ComparisonOperator',
      n: 'N',
      statistics: 'Statistics',
      threshold: 'Threshold',
      times: 'Times',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comparisonOperator: 'string',
      n: 'number',
      statistics: 'string',
      threshold: 'string',
      times: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMetricRuleTemplateRequestAlertTemplatesEscalationsInfo extends $tea.Model {
  comparisonOperator?: string;
  n?: number;
  statistics?: string;
  threshold?: string;
  times?: number;
  static names(): { [key: string]: string } {
    return {
      comparisonOperator: 'ComparisonOperator',
      n: 'N',
      statistics: 'Statistics',
      threshold: 'Threshold',
      times: 'Times',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comparisonOperator: 'string',
      n: 'number',
      statistics: 'string',
      threshold: 'string',
      times: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMetricRuleTemplateRequestAlertTemplatesEscalationsWarn extends $tea.Model {
  comparisonOperator?: string;
  n?: number;
  statistics?: string;
  threshold?: string;
  times?: number;
  static names(): { [key: string]: string } {
    return {
      comparisonOperator: 'ComparisonOperator',
      n: 'N',
      statistics: 'Statistics',
      threshold: 'Threshold',
      times: 'Times',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comparisonOperator: 'string',
      n: 'number',
      statistics: 'string',
      threshold: 'string',
      times: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMetricRuleTemplateRequestAlertTemplatesEscalations extends $tea.Model {
  critical?: CreateMetricRuleTemplateRequestAlertTemplatesEscalationsCritical;
  info?: CreateMetricRuleTemplateRequestAlertTemplatesEscalationsInfo;
  warn?: CreateMetricRuleTemplateRequestAlertTemplatesEscalationsWarn;
  static names(): { [key: string]: string } {
    return {
      critical: 'Critical',
      info: 'Info',
      warn: 'Warn',
    };
  }

  static types(): { [key: string]: any } {
    return {
      critical: CreateMetricRuleTemplateRequestAlertTemplatesEscalationsCritical,
      info: CreateMetricRuleTemplateRequestAlertTemplatesEscalationsInfo,
      warn: CreateMetricRuleTemplateRequestAlertTemplatesEscalationsWarn,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMetricRuleTemplateRequestAlertTemplates extends $tea.Model {
  escalations?: CreateMetricRuleTemplateRequestAlertTemplatesEscalations;
  /**
   * @remarks
   * The abbreviation of the Alibaba Cloud service name.
   * 
   * To obtain the abbreviation of an Alibaba Cloud service name, call the [DescribeProjectMeta](https://help.aliyun.com/document_detail/114916.html) operation. The `metricCategory` tag in the `Labels` response parameter indicates the abbreviation of the Alibaba Cloud service name.
   * 
   * This parameter is required.
   * 
   * @example
   * ecs
   */
  category?: string;
  /**
   * @remarks
   * The name of the metric. Valid values of N: 1 to 200.
   * 
   * >  For more information, see [DescribeMetricMetaList](https://help.aliyun.com/document_detail/98846.html) or [Appendix 1: Metrics](https://help.aliyun.com/document_detail/28619.html).
   * 
   * This parameter is required.
   * 
   * @example
   * cpu_total
   */
  metricName?: string;
  /**
   * @remarks
   * The namespace of the cloud service. Valid values of N: 1 to 200.
   * 
   * >  For more information, see [DescribeMetricMetaList](https://help.aliyun.com/document_detail/98846.html) or [Appendix 1: Metrics](https://help.aliyun.com/document_detail/28619.html).
   * 
   * This parameter is required.
   * 
   * @example
   * acs_ecs_dashboard
   */
  namespace?: string;
  /**
   * @remarks
   * The aggregation period of monitoring data. Unit: seconds.
   * 
   * The default value is the minimum aggregation period. Generally, you do not need to specify the minimum aggregation period.
   * 
   * Valid values of N: 1 to 200.
   * 
   * @example
   * 60
   */
  period?: number;
  /**
   * @remarks
   * The name of the alert rule. Valid values of N: 1 to 200.
   * 
   * This parameter is required.
   */
  ruleName?: string;
  /**
   * @remarks
   * The extended field selectors. Valid values of N: 1 to 200.
   * 
   * @example
   * {"disk":"/"}
   */
  selector?: string;
  /**
   * @remarks
   * The callback URL to which a POST request is sent when an alert is triggered based on the alert rule.
   * 
   * @example
   * http://ww.aliyun.com
   */
  webhook?: string;
  static names(): { [key: string]: string } {
    return {
      escalations: 'Escalations',
      category: 'Category',
      metricName: 'MetricName',
      namespace: 'Namespace',
      period: 'Period',
      ruleName: 'RuleName',
      selector: 'Selector',
      webhook: 'Webhook',
    };
  }

  static types(): { [key: string]: any } {
    return {
      escalations: CreateMetricRuleTemplateRequestAlertTemplatesEscalations,
      category: 'string',
      metricName: 'string',
      namespace: 'string',
      period: 'number',
      ruleName: 'string',
      selector: 'string',
      webhook: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMonitorGroupInstancesRequestInstances extends $tea.Model {
  /**
   * @remarks
   * The abbreviation of the Alibaba Cloud service name.
   * 
   * To obtain the abbreviation of an Alibaba Cloud service name, call the [DescribeProjectMeta](https://help.aliyun.com/document_detail/114916.html) operation. The `metricCategory` tag in the `Labels` response parameter indicates the abbreviation of the Alibaba Cloud service name.
   * 
   * This parameter is required.
   * 
   * @example
   * ecs
   */
  category?: string;
  /**
   * @remarks
   * The instance ID.
   * 
   * This parameter is required.
   * 
   * @example
   * i-2ze26xj5wwy12****
   */
  instanceId?: string;
  /**
   * @remarks
   * The instance name.
   * 
   * This parameter is required.
   * 
   * @example
   * test-instance-ecs
   */
  instanceName?: string;
  /**
   * @remarks
   * The region ID of the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      instanceId: 'string',
      instanceName: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteMonitorResponseBodyCreateResultListCreateResultList extends $tea.Model {
  /**
   * @remarks
   * The ID of the site monitoring task.
   * 
   * @example
   * 2c8dbdf9-a3ab-46a1-85a4-f094965e****
   */
  taskId?: string;
  /**
   * @remarks
   * The name of the site monitoring task.
   * 
   * @example
   * HanZhou_ECS1
   */
  taskName?: string;
  static names(): { [key: string]: string } {
    return {
      taskId: 'TaskId',
      taskName: 'TaskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      taskId: 'string',
      taskName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteMonitorResponseBodyCreateResultList extends $tea.Model {
  createResultList?: CreateSiteMonitorResponseBodyCreateResultListCreateResultList[];
  static names(): { [key: string]: string } {
    return {
      createResultList: 'CreateResultList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createResultList: { 'type': 'array', 'itemType': CreateSiteMonitorResponseBodyCreateResultListCreateResultList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteMonitorResponseBodyDataAttachAlertResultContact extends $tea.Model {
  /**
   * @remarks
   * The status code that is returned after you associate the existing alert rule with the site monitoring task.
   * 
   * >  The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The message that is returned after you associate the existing alert rule with the site monitoring task.
   * 
   * @example
   * successful
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request that was sent to associate the existing alert rule with the site monitoring task.
   * 
   * @example
   * 5dd33455-4f65-4b0c-9200-33d66f3f340b
   */
  requestId?: string;
  /**
   * @remarks
   * The ID of the alert rule.
   * 
   * @example
   * SystemDefault_acs_ecs_dashboard_InternetOutRate_Percent
   */
  ruleId?: string;
  /**
   * @remarks
   * Indicates whether the existing alert rule was associated with the site monitoring task. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      ruleId: 'RuleId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      ruleId: 'string',
      success: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteMonitorResponseBodyDataAttachAlertResult extends $tea.Model {
  contact?: CreateSiteMonitorResponseBodyDataAttachAlertResultContact[];
  static names(): { [key: string]: string } {
    return {
      contact: 'Contact',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contact: { 'type': 'array', 'itemType': CreateSiteMonitorResponseBodyDataAttachAlertResultContact },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteMonitorResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The result that is returned after you associate the existing alert rule with the site monitoring task.
   */
  attachAlertResult?: CreateSiteMonitorResponseBodyDataAttachAlertResult;
  static names(): { [key: string]: string } {
    return {
      attachAlertResult: 'AttachAlertResult',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attachAlertResult: CreateSiteMonitorResponseBodyDataAttachAlertResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMetricRuleTargetsResponseBodyFailIdsTargetIds extends $tea.Model {
  targetId?: string[];
  static names(): { [key: string]: string } {
    return {
      targetId: 'TargetId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      targetId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMetricRuleTargetsResponseBodyFailIds extends $tea.Model {
  /**
   * @remarks
   * The IDs of the resources that failed to be deleted.
   */
  targetIds?: DeleteMetricRuleTargetsResponseBodyFailIdsTargetIds;
  static names(): { [key: string]: string } {
    return {
      targetIds: 'TargetIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      targetIds: DeleteMetricRuleTargetsResponseBodyFailIdsTargetIds,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMetricRuleTemplateResponseBodyResource extends $tea.Model {
  /**
   * @remarks
   * The ID of the template.
   * 
   * @example
   * 123****
   */
  templateId?: string;
  static names(): { [key: string]: string } {
    return {
      templateId: 'TemplateId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      templateId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMonitorGroupResponseBodyGroupContactGroupsContactGroup extends $tea.Model {
  /**
   * @remarks
   * The name of the alert group.
   * 
   * @example
   * ECS_Group
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMonitorGroupResponseBodyGroupContactGroups extends $tea.Model {
  contactGroup?: DeleteMonitorGroupResponseBodyGroupContactGroupsContactGroup[];
  static names(): { [key: string]: string } {
    return {
      contactGroup: 'ContactGroup',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contactGroup: { 'type': 'array', 'itemType': DeleteMonitorGroupResponseBodyGroupContactGroupsContactGroup },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMonitorGroupResponseBodyGroup extends $tea.Model {
  /**
   * @remarks
   * The alert groups that receive alert notifications for the application group.
   */
  contactGroups?: DeleteMonitorGroupResponseBodyGroupContactGroups;
  /**
   * @remarks
   * The name of the application group.
   * 
   * @example
   * ECS_test
   */
  groupName?: string;
  static names(): { [key: string]: string } {
    return {
      contactGroups: 'ContactGroups',
      groupName: 'GroupName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contactGroups: DeleteMonitorGroupResponseBodyGroupContactGroups,
      groupName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSiteMonitorsResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The number of the site monitoring tasks that were deleted.
   * 
   * @example
   * 0
   */
  count?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'count',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeActiveMetricRuleListResponseBodyAlertListAlertEscalationsCritical extends $tea.Model {
  /**
   * @remarks
   * The operator that is used to compare the metric value with the threshold for Critical-level alerts. Valid values:
   * 
   * *   GreaterThanOrEqualToThreshold: greater than or equal to the threshold
   * *   GreaterThanThreshold: greater than the threshold
   * *   LessThanOrEqualToThreshold: less than or equal to the threshold
   * *   LessThanThreshold: less than the threshold
   * *   NotEqualToThreshold: not equal to the threshold
   * *   GreaterThanYesterday: greater than the metric value at the same time yesterday
   * *   LessThanYesterday: less than the metric value at the same time yesterday
   * *   GreaterThanLastWeek: greater than the metric value at the same time last week
   * *   LessThanLastWeek: less than the metric value at the same time last week
   * *   GreaterThanLastPeriod: greater than the metric value in the last monitoring cycle
   * *   LessThanLastPeriod: less than the metric value in the last monitoring cycle
   * 
   * @example
   * GreaterThanThreshold
   */
  comparisonOperator?: string;
  /**
   * @remarks
   * The statistical methods for Critical-level alerts.
   * 
   * @example
   * Average
   */
  statistics?: string;
  /**
   * @remarks
   * The threshold for Critical-level alerts.
   * 
   * @example
   * 99
   */
  threshold?: string;
  /**
   * @remarks
   * The consecutive number of times for which the metric value meets the alert condition before a Critical-level alert is triggered.
   * 
   * @example
   * 3
   */
  times?: string;
  static names(): { [key: string]: string } {
    return {
      comparisonOperator: 'ComparisonOperator',
      statistics: 'Statistics',
      threshold: 'Threshold',
      times: 'Times',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comparisonOperator: 'string',
      statistics: 'string',
      threshold: 'string',
      times: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeActiveMetricRuleListResponseBodyAlertListAlertEscalationsInfo extends $tea.Model {
  /**
   * @remarks
   * The operator that is used to compare the metric value with the threshold for Info-level alerts. Valid values:
   * 
   * *   GreaterThanOrEqualToThreshold: greater than or equal to the threshold
   * *   GreaterThanThreshold: greater than the threshold
   * *   LessThanOrEqualToThreshold: less than or equal to the threshold
   * *   LessThanThreshold: less than the threshold
   * *   NotEqualToThreshold: not equal to the threshold
   * *   GreaterThanYesterday: greater than the metric value at the same time yesterday
   * *   LessThanYesterday: less than the metric value at the same time yesterday
   * *   GreaterThanLastWeek: greater than the metric value at the same time last week
   * *   LessThanLastWeek: less than the metric value at the same time last week
   * *   GreaterThanLastPeriod: greater than the metric value in the last monitoring cycle
   * *   LessThanLastPeriod: less than the metric value in the last monitoring cycle
   * 
   * @example
   * GreaterThanThreshold
   */
  comparisonOperator?: string;
  /**
   * @remarks
   * The statistical methods for Info-level alerts.
   * 
   * @example
   * Average
   */
  statistics?: string;
  /**
   * @remarks
   * The threshold for Info-level alerts.
   * 
   * @example
   * 95
   */
  threshold?: string;
  /**
   * @remarks
   * The consecutive number of times
   * 
   * for which the metric value meets the alert condition before an Info-level alert is triggered.
   * 
   * @example
   * 3
   */
  times?: string;
  static names(): { [key: string]: string } {
    return {
      comparisonOperator: 'ComparisonOperator',
      statistics: 'Statistics',
      threshold: 'Threshold',
      times: 'Times',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comparisonOperator: 'string',
      statistics: 'string',
      threshold: 'string',
      times: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeActiveMetricRuleListResponseBodyAlertListAlertEscalationsWarn extends $tea.Model {
  /**
   * @remarks
   * The operator that is used to compare the metric value with the threshold for Warn-level alerts. Valid values:
   * 
   * *   GreaterThanOrEqualToThreshold: greater than or equal to the threshold
   * *   GreaterThanThreshold: greater than the threshold
   * *   LessThanOrEqualToThreshold: less than or equal to the threshold
   * *   LessThanThreshold: less than the threshold
   * *   NotEqualToThreshold: not equal to the threshold
   * *   GreaterThanYesterday: greater than the metric value at the same time yesterday
   * *   LessThanYesterday: less than the metric value at the same time yesterday
   * *   GreaterThanLastWeek: greater than the metric value at the same time last week
   * *   LessThanLastWeek: less than the metric value at the same time last week
   * *   GreaterThanLastPeriod: greater than the metric value in the last monitoring cycle
   * *   LessThanLastPeriod: less than the metric value in the last monitoring cycle
   * 
   * @example
   * GreaterThanThreshold
   */
  comparisonOperator?: string;
  /**
   * @remarks
   * The statistical methods for Warn-level alerts.
   * 
   * @example
   * Average
   */
  statistics?: string;
  /**
   * @remarks
   * The threshold for Warn-level alerts.
   * 
   * @example
   * 80
   */
  threshold?: string;
  /**
   * @remarks
   * The consecutive number of times
   * 
   * for which the metric value meets the alert condition before a Warn-level alert is triggered.
   * 
   * @example
   * 3
   */
  times?: string;
  static names(): { [key: string]: string } {
    return {
      comparisonOperator: 'ComparisonOperator',
      statistics: 'Statistics',
      threshold: 'Threshold',
      times: 'Times',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comparisonOperator: 'string',
      statistics: 'string',
      threshold: 'string',
      times: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeActiveMetricRuleListResponseBodyAlertListAlertEscalations extends $tea.Model {
  /**
   * @remarks
   * The trigger condition for Critical-level alerts.
   */
  critical?: DescribeActiveMetricRuleListResponseBodyAlertListAlertEscalationsCritical;
  /**
   * @remarks
   * The conditions for triggering Info-level alerts.
   */
  info?: DescribeActiveMetricRuleListResponseBodyAlertListAlertEscalationsInfo;
  /**
   * @remarks
   * The conditions for triggering Warn-level alerts.
   */
  warn?: DescribeActiveMetricRuleListResponseBodyAlertListAlertEscalationsWarn;
  static names(): { [key: string]: string } {
    return {
      critical: 'Critical',
      info: 'Info',
      warn: 'Warn',
    };
  }

  static types(): { [key: string]: any } {
    return {
      critical: DescribeActiveMetricRuleListResponseBodyAlertListAlertEscalationsCritical,
      info: DescribeActiveMetricRuleListResponseBodyAlertListAlertEscalationsInfo,
      warn: DescribeActiveMetricRuleListResponseBodyAlertListAlertEscalationsWarn,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeActiveMetricRuleListResponseBodyAlertListAlert extends $tea.Model {
  /**
   * @remarks
   * The status of the alert rule. Valid values:
   * 
   * *   OK: The alert rule has no active alerts.
   * *   ALARM: The alert rule has active alerts.
   * *   INSUFFICIENT_DATA: No data is found.
   * 
   * @example
   * OK
   */
  alertState?: string;
  /**
   * @remarks
   * The alert contact group.
   * 
   * @example
   * ECS_Group
   */
  contactGroups?: string;
  /**
   * @remarks
   * The monitoring data of the specified resource.
   * 
   * @example
   * ""
   */
  dimensions?: string;
  /**
   * @remarks
   * The time period during which the alert rule is effective.
   * 
   * @example
   * 00:00-23:59
   */
  effectiveInterval?: string;
  /**
   * @remarks
   * Indicates whether the alert rule is enabled. Valid values:
   * 
   * *   true: The alert rule is enabled.
   * *   false: The alert rule is disabled.
   * 
   * @example
   * true
   */
  enableState?: boolean;
  /**
   * @remarks
   * The conditions for triggering different levels of alerts.
   */
  escalations?: DescribeActiveMetricRuleListResponseBodyAlertListAlertEscalations;
  /**
   * @remarks
   * The subject of the alert notification email.
   * 
   * @example
   * ECS_Bucket
   */
  mailSubject?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * cpu_total
   */
  metricName?: string;
  /**
   * @remarks
   * The namespace of the Alibaba Cloud service.
   * 
   * @example
   * acs_ecs_dashboard
   */
  namespace?: string;
  /**
   * @remarks
   * The time period during which the alert rule is ineffective.
   * 
   * @example
   * 00:00-06:00
   */
  noEffectiveInterval?: string;
  /**
   * @remarks
   * The aggregation period of monitoring data.
   * 
   * Unit: seconds.
   * 
   * @example
   * 60
   */
  period?: string;
  /**
   * @remarks
   * The resources that are associated with the alert rule.
   * 
   * @example
   * [{"resource":"_ALL"}]
   */
  resources?: string;
  /**
   * @remarks
   * The ID of the alert rule.
   * 
   * @example
   * ruleIdxxxx
   */
  ruleId?: string;
  /**
   * @remarks
   * The name of the alert rule.
   * 
   * @example
   * myAlert
   */
  ruleName?: string;
  /**
   * @remarks
   * The mute period during which new alerts are not sent even if the trigger conditions are met.
   * 
   * Unit: seconds.
   * 
   * @example
   * 86400
   */
  silenceTime?: string;
  /**
   * @remarks
   * The callback URL.
   * 
   * @example
   * http://www.aliyun.com
   */
  webhook?: string;
  static names(): { [key: string]: string } {
    return {
      alertState: 'AlertState',
      contactGroups: 'ContactGroups',
      dimensions: 'Dimensions',
      effectiveInterval: 'EffectiveInterval',
      enableState: 'EnableState',
      escalations: 'Escalations',
      mailSubject: 'MailSubject',
      metricName: 'MetricName',
      namespace: 'Namespace',
      noEffectiveInterval: 'NoEffectiveInterval',
      period: 'Period',
      resources: 'Resources',
      ruleId: 'RuleId',
      ruleName: 'RuleName',
      silenceTime: 'SilenceTime',
      webhook: 'Webhook',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertState: 'string',
      contactGroups: 'string',
      dimensions: 'string',
      effectiveInterval: 'string',
      enableState: 'boolean',
      escalations: DescribeActiveMetricRuleListResponseBodyAlertListAlertEscalations,
      mailSubject: 'string',
      metricName: 'string',
      namespace: 'string',
      noEffectiveInterval: 'string',
      period: 'string',
      resources: 'string',
      ruleId: 'string',
      ruleName: 'string',
      silenceTime: 'string',
      webhook: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeActiveMetricRuleListResponseBodyAlertList extends $tea.Model {
  alert?: DescribeActiveMetricRuleListResponseBodyAlertListAlert[];
  static names(): { [key: string]: string } {
    return {
      alert: 'Alert',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alert: { 'type': 'array', 'itemType': DescribeActiveMetricRuleListResponseBodyAlertListAlert },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeActiveMetricRuleListResponseBodyDatapointsAlarm extends $tea.Model {
  /**
   * @remarks
   * The comparison operator that is used in the alert rule. Valid values:
   * 
   * *   `>`
   * *   `<`
   * *   `>=`
   * *   `<=`
   * *   `=`
   * *   `=`
   * 
   * @example
   * >
   */
  comparisonOperator?: string;
  /**
   * @remarks
   * The alert contact group.
   * 
   * @example
   * ECS_Group
   */
  contactGroups?: string;
  /**
   * @remarks
   * Indicates whether the alert rule is enabled. Valid values:
   * 
   * *   true: The alert rule is enabled.
   * *   false: The alert rule is disabled.
   * 
   * @example
   * true
   */
  enable?: string;
  /**
   * @remarks
   * The end of the time period during which the alert rule is effective.
   * 
   * Unit: hours. For example, the value 23 indicates `23:59:59`.
   * 
   * @example
   * 24
   */
  endTime?: string;
  /**
   * @remarks
   * The consecutive number of times for which the metric value meets the alert condition before an alert is triggered.
   * 
   * @example
   * 3
   */
  evaluationCount?: string;
  /**
   * @remarks
   * The metric name.
   * 
   * @example
   * cpu_total
   */
  metricName?: string;
  /**
   * @remarks
   * The namespace of the cloud service.
   * 
   * @example
   * acs_ecs_dashboard
   */
  namespace?: string;
  /**
   * @remarks
   * The aggregation period of monitoring data.
   * 
   * Unit: seconds.
   * 
   * @example
   * 60
   */
  period?: string;
  /**
   * @remarks
   * The ID of the alert rule.
   * 
   * @example
   * a151cd6023eacee2f0978e03863cc1697c89508****
   */
  ruleId?: string;
  /**
   * @remarks
   * The name of the alert rule.
   * 
   * @example
   * SystemDefault_acs_rds_dashboard_CpuUsage
   */
  ruleName?: string;
  /**
   * @remarks
   * The mute period during which new alerts are not sent even if the trigger conditions are met.
   * 
   * Unit: seconds.
   * 
   * @example
   * 86400
   */
  silenceTime?: string;
  /**
   * @remarks
   * The beginning of the time period during which the alert rule is effective.
   * 
   * Unit: hours. For example, the value 00 indicates `00:00:00`.
   * 
   * @example
   * 00
   */
  startTime?: string;
  /**
   * @remarks
   * Indicates whether the alert rule is enabled.
   * 
   * @example
   * Enable
   */
  state?: string;
  /**
   * @remarks
   * The statistical method.
   * 
   * @example
   * Average
   */
  statistics?: string;
  /**
   * @remarks
   * The alert threshold.
   * 
   * @example
   * 90
   */
  threshold?: string;
  /**
   * @remarks
   * The callback URL.
   * 
   * @example
   * http://www.aliyun.com
   */
  webhook?: string;
  static names(): { [key: string]: string } {
    return {
      comparisonOperator: 'ComparisonOperator',
      contactGroups: 'ContactGroups',
      enable: 'Enable',
      endTime: 'EndTime',
      evaluationCount: 'EvaluationCount',
      metricName: 'MetricName',
      namespace: 'Namespace',
      period: 'Period',
      ruleId: 'RuleId',
      ruleName: 'RuleName',
      silenceTime: 'SilenceTime',
      startTime: 'StartTime',
      state: 'State',
      statistics: 'Statistics',
      threshold: 'Threshold',
      webhook: 'Webhook',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comparisonOperator: 'string',
      contactGroups: 'string',
      enable: 'string',
      endTime: 'string',
      evaluationCount: 'string',
      metricName: 'string',
      namespace: 'string',
      period: 'string',
      ruleId: 'string',
      ruleName: 'string',
      silenceTime: 'string',
      startTime: 'string',
      state: 'string',
      statistics: 'string',
      threshold: 'string',
      webhook: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeActiveMetricRuleListResponseBodyDatapoints extends $tea.Model {
  alarm?: DescribeActiveMetricRuleListResponseBodyDatapointsAlarm[];
  static names(): { [key: string]: string } {
    return {
      alarm: 'Alarm',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alarm: { 'type': 'array', 'itemType': DescribeActiveMetricRuleListResponseBodyDatapointsAlarm },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContactALIIMs extends $tea.Model {
  contactALIIM?: string[];
  static names(): { [key: string]: string } {
    return {
      contactALIIM: 'ContactALIIM',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contactALIIM: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContactGroups extends $tea.Model {
  contactGroup?: string[];
  static names(): { [key: string]: string } {
    return {
      contactGroup: 'ContactGroup',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contactGroup: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContactMails extends $tea.Model {
  contactMail?: string[];
  static names(): { [key: string]: string } {
    return {
      contactMail: 'ContactMail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contactMail: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContactSmses extends $tea.Model {
  contactSms?: string[];
  static names(): { [key: string]: string } {
    return {
      contactSms: 'ContactSms',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contactSms: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContacts extends $tea.Model {
  contact?: string[];
  static names(): { [key: string]: string } {
    return {
      contact: 'Contact',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contact: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistory extends $tea.Model {
  /**
   * @remarks
   * The timestamp when the alert was triggered. Unit: milliseconds.
   * 
   * @example
   * 1640586600000
   */
  alertTime?: number;
  /**
   * @remarks
   * The TradeManager IDs of the alert contacts.
   * 
   * > This parameter is valid only on the China site (aliyun.com).
   */
  contactALIIMs?: DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContactALIIMs;
  /**
   * @remarks
   * The alert contact groups.
   */
  contactGroups?: DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContactGroups;
  /**
   * @remarks
   * The email addresses of the alert contacts.
   */
  contactMails?: DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContactMails;
  /**
   * @remarks
   * The mobile numbers of the alert contacts.
   * 
   * > This parameter is valid only on the China site (aliyun.com).
   */
  contactSmses?: DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContactSmses;
  /**
   * @remarks
   * The alert contacts that receive alert notifications.
   */
  contacts?: DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContacts;
  /**
   * @remarks
   * The resources that are monitored.
   * 
   * @example
   * {\\"instanceId\\":\\"i-bp1cqhiw1za2****\\"}
   */
  dimensions?: string;
  /**
   * @remarks
   * The consecutive number of times for which the metric value meets the alert condition before an alert is triggered.
   * 
   * @example
   * 3
   */
  evaluationCount?: number;
  /**
   * @remarks
   * The expression that is used to trigger alerts.
   * 
   * @example
   * $Average>=10
   */
  expression?: string;
  /**
   * @remarks
   * The ID of the application group.
   * 
   * @example
   * 7671****
   */
  groupId?: string;
  /**
   * @remarks
   * The instance name.
   * 
   * @example
   * i-bp1cqhiw1za2****
   */
  instanceName?: string;
  /**
   * @remarks
   * The duration of the alert. Unit: milliseconds.
   * 
   * @example
   * 360133
   */
  lastTime?: number;
  /**
   * @remarks
   * The severity level and notification methods of the alert. Valid values:
   * 
   * *   P4: Alert notifications are sent by using emails and DingTalk chatbots.
   * *   OK: No alert is generated.
   * 
   * @example
   * P4
   */
  level?: string;
  /**
   * @remarks
   * The metric name.
   * 
   * @example
   * cpu_total
   */
  metricName?: string;
  /**
   * @remarks
   * The namespace of the cloud service.
   * 
   * @example
   * acs_ecs_dashboard
   */
  namespace?: string;
  /**
   * @remarks
   * The ID of the alert rule.
   * 
   * @example
   * applyTemplate61dc81b5-d357-4cf6-a9b7-9f83c1d5****
   */
  ruleId?: string;
  /**
   * @remarks
   * The name of the alert rule.
   * 
   * @example
   * ECS_Rule
   */
  ruleName?: string;
  /**
   * @remarks
   * The alert status. Valid values:
   * 
   * *   ALARM: Alerts are triggered.
   * *   OK: No alerts are triggered.
   * 
   * @example
   * ALARM
   */
  state?: string;
  /**
   * @remarks
   * Indicates whether alerts are muted. Valid values:
   * 
   * *   2 (default): Alerts are muted and are not triggered within the mute period, even if the condition specified in the alert rule is met.
   * *   0: Alerts are triggered or cleared.
   * *   1: The alert rule is ineffective.
   * 
   * @example
   * 2
   */
  status?: number;
  /**
   * @remarks
   * The threshold of the metric value to trigger or clear an alert.
   * 
   * @example
   * 10.58
   */
  value?: string;
  /**
   * @remarks
   * The callback URL.
   * 
   * @example
   * https://www.aliyun.com
   */
  webhooks?: string;
  static names(): { [key: string]: string } {
    return {
      alertTime: 'AlertTime',
      contactALIIMs: 'ContactALIIMs',
      contactGroups: 'ContactGroups',
      contactMails: 'ContactMails',
      contactSmses: 'ContactSmses',
      contacts: 'Contacts',
      dimensions: 'Dimensions',
      evaluationCount: 'EvaluationCount',
      expression: 'Expression',
      groupId: 'GroupId',
      instanceName: 'InstanceName',
      lastTime: 'LastTime',
      level: 'Level',
      metricName: 'MetricName',
      namespace: 'Namespace',
      ruleId: 'RuleId',
      ruleName: 'RuleName',
      state: 'State',
      status: 'Status',
      value: 'Value',
      webhooks: 'Webhooks',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertTime: 'number',
      contactALIIMs: DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContactALIIMs,
      contactGroups: DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContactGroups,
      contactMails: DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContactMails,
      contactSmses: DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContactSmses,
      contacts: DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContacts,
      dimensions: 'string',
      evaluationCount: 'number',
      expression: 'string',
      groupId: 'string',
      instanceName: 'string',
      lastTime: 'number',
      level: 'string',
      metricName: 'string',
      namespace: 'string',
      ruleId: 'string',
      ruleName: 'string',
      state: 'string',
      status: 'number',
      value: 'string',
      webhooks: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAlertHistoryListResponseBodyAlarmHistoryList extends $tea.Model {
  alarmHistory?: DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistory[];
  static names(): { [key: string]: string } {
    return {
      alarmHistory: 'AlarmHistory',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alarmHistory: { 'type': 'array', 'itemType': DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistory },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAlertLogCountResponseBodyAlertLogCountLogs extends $tea.Model {
  /**
   * @remarks
   * The name of the dimension field based on which alert logs are aggregated.
   * 
   * @example
   * product
   */
  name?: string;
  /**
   * @remarks
   * The value of the dimension field based on which alert logs are aggregated.
   * 
   * @example
   * ECS
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAlertLogCountResponseBodyAlertLogCount extends $tea.Model {
  /**
   * @remarks
   * The number of alert logs.
   * 
   * @example
   * 1
   */
  count?: number;
  /**
   * @remarks
   * The details about alert logs.
   */
  logs?: DescribeAlertLogCountResponseBodyAlertLogCountLogs[];
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      logs: 'Logs',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      logs: { 'type': 'array', 'itemType': DescribeAlertLogCountResponseBodyAlertLogCountLogs },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAlertLogHistogramResponseBodyAlertLogHistogramList extends $tea.Model {
  /**
   * @remarks
   * The number of alert logs.
   * 
   * @example
   * 20
   */
  count?: number;
  /**
   * @remarks
   * The start timestamp of the queried alert logs.
   * 
   * Unit: seconds.
   * 
   * @example
   * 1610074791
   */
  from?: number;
  /**
   * @remarks
   * The end timestamp of the queried alert logs.
   * 
   * Unit: seconds.
   * 
   * @example
   * 1610074800
   */
  to?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      from: 'From',
      to: 'To',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      from: 'number',
      to: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAlertLogListResponseBodyAlertLogListDimensions extends $tea.Model {
  /**
   * @remarks
   * The key of the dimension.
   * 
   * @example
   * instanceId
   */
  key?: string;
  /**
   * @remarks
   * The value of the dimension.
   * 
   * @example
   * i-m5e1qg6uo38rztr4****
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAlertLogListResponseBodyAlertLogListEscalation extends $tea.Model {
  /**
   * @remarks
   * The description of the alert rule.
   * 
   * >  The content of the alert rule. This parameter indicates the conditions that trigger an alert.
   * 
   * @example
   * $Average<90
   */
  expression?: string;
  /**
   * @remarks
   * The alert level and the methods that are used to send alert notifications. Valid values:
   * 
   * *   P4: Alert notifications are sent by using emails and DingTalk chatbots.
   * *   OK: No alert is generated.
   * 
   * @example
   * P4
   */
  level?: string;
  /**
   * @remarks
   * The consecutive number of times for which the metric value meets the alert condition before an alert is triggered.
   * 
   * @example
   * 1
   */
  times?: number;
  static names(): { [key: string]: string } {
    return {
      expression: 'Expression',
      level: 'Level',
      times: 'Times',
    };
  }

  static types(): { [key: string]: any } {
    return {
      expression: 'string',
      level: 'string',
      times: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAlertLogListResponseBodyAlertLogListExtendedInfo extends $tea.Model {
  /**
   * @remarks
   * The name of the extended field.
   * 
   * @example
   * userId
   */
  name?: string;
  /**
   * @remarks
   * The value of the extended field.
   * 
   * @example
   * 120886317861****
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAlertLogListResponseBodyAlertLogListSendDetailChannelResultListResultList extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * *   If the value of the `Channel` parameter is `WEBHOOK`, the status code is 200 or 500.
   * *   If the value of the `Channel` parameter is `MAIL`, `SMS`, `SLS`, `ONCALL`, `FC`, or `MNS`, this parameter is empty or not returned.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The details of the returned results.
   * 
   * @example
   * { }
   */
  detail?: string;
  /**
   * @remarks
   * The request ID returned when CloudMonitor calls another cloud service.
   * 
   * @example
   * 0BDAF8A8-04DC-5F0C-90E4-724D42C4****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  notifyTargetList?: string[];
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      detail: 'Detail',
      requestId: 'RequestId',
      success: 'Success',
      notifyTargetList: 'notifyTargetList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      detail: 'string',
      requestId: 'string',
      success: 'boolean',
      notifyTargetList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAlertLogListResponseBodyAlertLogListSendDetailChannelResultList extends $tea.Model {
  /**
   * @remarks
   * The method that is used to send alert notifications. Valid values:
   * 
   * *   MAIL: email
   * *   SMS: text message
   * *   WEBHOOK: alert callback
   * *   SLS: Simple Log Service
   * *   ONCALL: phone call
   * *   FC: Function Compute
   * *   MNS: Message Service queue
   * 
   * @example
   * MAIL
   */
  channel?: string;
  /**
   * @remarks
   * The sending results of alert notifications.
   */
  resultList?: DescribeAlertLogListResponseBodyAlertLogListSendDetailChannelResultListResultList[];
  static names(): { [key: string]: string } {
    return {
      channel: 'Channel',
      resultList: 'ResultList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channel: 'string',
      resultList: { 'type': 'array', 'itemType': DescribeAlertLogListResponseBodyAlertLogListSendDetailChannelResultListResultList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAlertLogListResponseBodyAlertLogListSendDetail extends $tea.Model {
  /**
   * @remarks
   * The list of sending results that are categorized by notification method.
   */
  channelResultList?: DescribeAlertLogListResponseBodyAlertLogListSendDetailChannelResultList[];
  /**
   * @remarks
   * Indicates whether the alert notifications are sent.
   * 
   * *   If the alert notifications are sent, the value "success" is returned.
   * *   If the configuration is invalid, no alert notification is sent and an error code is returned.
   * 
   * @example
   * success
   */
  resultCode?: string;
  static names(): { [key: string]: string } {
    return {
      channelResultList: 'ChannelResultList',
      resultCode: 'ResultCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelResultList: { 'type': 'array', 'itemType': DescribeAlertLogListResponseBodyAlertLogListSendDetailChannelResultList },
      resultCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAlertLogListResponseBodyAlertLogListSendResultList extends $tea.Model {
  /**
   * @remarks
   * The category of the alert notification method. Valid values:
   * 
   * *   MAIL: email
   * *   ALIIM: TradeManager
   * *   SMS: text message
   * *   CALL: phone call
   * *   DING: DingTalk chatbot
   * *   Merged: alert merging
   * 
   * @example
   * Mail
   */
  key?: string;
  /**
   * @remarks
   * The notification object corresponding to the alert notification method.
   */
  value?: string[];
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAlertLogListResponseBodyAlertLogListWebhookList extends $tea.Model {
  /**
   * @remarks
   * The status code of the alert callback.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The message returned for the alert callback.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The callback URL.
   * 
   * @example
   * https://www.aliyun.com/webhook.html
   */
  url?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'code',
      message: 'message',
      url: 'url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAlertLogListResponseBodyAlertLogList extends $tea.Model {
  /**
   * @remarks
   * The timestamp that was generated when the alert was triggered.
   * 
   * Unit: milliseconds.
   * 
   * @example
   * 1610043776621
   */
  alertTime?: string;
  /**
   * @remarks
   * The details of the blacklist policy.
   * 
   * @example
   * BlackListDetail
   */
  blackListDetail?: string;
  /**
   * @remarks
   * The name of the blacklist policy.
   * 
   * @example
   * {"id":123,"metricProject":"acs_ecs_dashboard","userId":1736511134389110,"uuid":"8410dbbd-7d30-41c5-94cb-***","name":"alert-***","productCategory":"ecs","instances":[{"instanceId":"host-***"}],"metrics":null,"scopeType":"USER","scopeValue":"","startTime":"0001-01-01T00:00:00Z","endTime":"9999-12-31T23:59:59.999999999+08:00","effectiveTime":null,"isEnable":true,"status":1,"gmtCreate":"2021-11-02T16:35:59+08:00","gmtModified":"2021-11-02T16:35:59+08:00","loadTime":"2021-11-02T16:36:15.213072177+08:00"}
   */
  blackListName?: string;
  /**
   * @remarks
   * The ID of the blacklist policy.
   * 
   * @example
   * 8410dbbd-7d30-41c5-94cb-*****
   */
  blackListUUID?: string;
  contactALIIWWList?: string[];
  contactDingList?: string[];
  contactGroups?: string[];
  contactMailList?: string[];
  contactOnCallList?: string[];
  contactSMSList?: string[];
  /**
   * @remarks
   * The dimensions of the resource that triggered alerts.
   */
  dimensions?: DescribeAlertLogListResponseBodyAlertLogListDimensions[];
  dingdingWebhookList?: string[];
  /**
   * @remarks
   * The alert rule based on which the alert is triggered.
   */
  escalation?: DescribeAlertLogListResponseBodyAlertLogListEscalation;
  /**
   * @remarks
   * The event name.
   * 
   * @example
   * IOHang
   */
  eventName?: string;
  /**
   * @remarks
   * The extended fields.
   */
  extendedInfo?: DescribeAlertLogListResponseBodyAlertLogListExtendedInfo[];
  /**
   * @remarks
   * The ID of the application group.
   * 
   * @example
   * 7301****
   */
  groupId?: string;
  /**
   * @remarks
   * The name of the application group.
   * 
   * @example
   * ECS_Instances
   */
  groupName?: string;
  /**
   * @remarks
   * The resource ID.
   * 
   * @example
   * i-m5e1qg6uo38rztr4****
   */
  instanceId?: string;
  /**
   * @remarks
   * The resource name.
   * 
   * @example
   * portalHost
   */
  instanceName?: string;
  /**
   * @remarks
   * The alert level and the methods that are used to send alert notifications. Valid values:
   * 
   * *   P4: Alert notifications are sent by using emails and DingTalk chatbots.
   * *   OK: No alert is generated.
   * 
   * @example
   * P4
   */
  level?: string;
  /**
   * @remarks
   * Indicates whether the alert level was changed. Valid values:
   * 
   * *   `P4->OK`: The alert level was changed from P4 to OK.
   * *   `P4->P4`: The alert level was still P4.
   * 
   * @example
   * P4->OK
   */
  levelChange?: string;
  /**
   * @remarks
   * The log ID.
   * 
   * @example
   * 7818361[1523]@1671593992[1]
   */
  logId?: string;
  /**
   * @remarks
   * The alert information in a JSON string.
   * 
   * @example
   * {"alertName":"e47aa0ac-4076-44db-a47d-d1083968****_Availability"}
   */
  message?: string;
  /**
   * @remarks
   * The metric name.
   * 
   * @example
   * cpu_total
   */
  metricName?: string;
  /**
   * @remarks
   * The namespace of the cloud service.
   * 
   * @example
   * acs_ecs_dashboard
   */
  namespace?: string;
  /**
   * @remarks
   * The identifier of the cloud service. Valid values:
   * 
   * *   If the cloud service is provided by Alibaba Cloud, the abbreviation of the service name is returned. Example: ECS.
   * *   If the cloud service is not provided by Alibaba Cloud, a value in the `acs_Service keyword` format is returned. Example: acs_networkmonitor.
   * 
   * @example
   * ECS
   */
  product?: string;
  /**
   * @remarks
   * The ID of the alert rule.
   * 
   * @example
   * d582b9e9-b1c1-4f17-9279-0fe7333a****_ResponseTime
   */
  ruleId?: string;
  /**
   * @remarks
   * The name of the alert rule.
   */
  ruleName?: string;
  /**
   * @remarks
   * The details about the sending results of alert notifications.
   */
  sendDetail?: DescribeAlertLogListResponseBodyAlertLogListSendDetail;
  /**
   * @remarks
   * The sending results of alert notifications.
   */
  sendResultList?: DescribeAlertLogListResponseBodyAlertLogListSendResultList[];
  /**
   * @remarks
   * The status of the alert. Valid values:
   * 
   * *   0: The alert is triggered or cleared.
   * *   1: The alert is ineffective.
   * *   2: The alert is muted.
   * *   3: The host is restarting.
   * *   4: No alert notification is sent.
   * 
   * If the value of the SendStatus parameter is 0, the value P4 of the Level parameter indicates a triggered alert and the value OK indicates a cleared alert.
   * 
   * @example
   * 0
   */
  sendStatus?: string;
  /**
   * @remarks
   * The callback URLs.
   */
  webhookList?: DescribeAlertLogListResponseBodyAlertLogListWebhookList[];
  static names(): { [key: string]: string } {
    return {
      alertTime: 'AlertTime',
      blackListDetail: 'BlackListDetail',
      blackListName: 'BlackListName',
      blackListUUID: 'BlackListUUID',
      contactALIIWWList: 'ContactALIIWWList',
      contactDingList: 'ContactDingList',
      contactGroups: 'ContactGroups',
      contactMailList: 'ContactMailList',
      contactOnCallList: 'ContactOnCallList',
      contactSMSList: 'ContactSMSList',
      dimensions: 'Dimensions',
      dingdingWebhookList: 'DingdingWebhookList',
      escalation: 'Escalation',
      eventName: 'EventName',
      extendedInfo: 'ExtendedInfo',
      groupId: 'GroupId',
      groupName: 'GroupName',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      level: 'Level',
      levelChange: 'LevelChange',
      logId: 'LogId',
      message: 'Message',
      metricName: 'MetricName',
      namespace: 'Namespace',
      product: 'Product',
      ruleId: 'RuleId',
      ruleName: 'RuleName',
      sendDetail: 'SendDetail',
      sendResultList: 'SendResultList',
      sendStatus: 'SendStatus',
      webhookList: 'WebhookList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertTime: 'string',
      blackListDetail: 'string',
      blackListName: 'string',
      blackListUUID: 'string',
      contactALIIWWList: { 'type': 'array', 'itemType': 'string' },
      contactDingList: { 'type': 'array', 'itemType': 'string' },
      contactGroups: { 'type': 'array', 'itemType': 'string' },
      contactMailList: { 'type': 'array', 'itemType': 'string' },
      contactOnCallList: { 'type': 'array', 'itemType': 'string' },
      contactSMSList: { 'type': 'array', 'itemType': 'string' },
      dimensions: { 'type': 'array', 'itemType': DescribeAlertLogListResponseBodyAlertLogListDimensions },
      dingdingWebhookList: { 'type': 'array', 'itemType': 'string' },
      escalation: DescribeAlertLogListResponseBodyAlertLogListEscalation,
      eventName: 'string',
      extendedInfo: { 'type': 'array', 'itemType': DescribeAlertLogListResponseBodyAlertLogListExtendedInfo },
      groupId: 'string',
      groupName: 'string',
      instanceId: 'string',
      instanceName: 'string',
      level: 'string',
      levelChange: 'string',
      logId: 'string',
      message: 'string',
      metricName: 'string',
      namespace: 'string',
      product: 'string',
      ruleId: 'string',
      ruleName: 'string',
      sendDetail: DescribeAlertLogListResponseBodyAlertLogListSendDetail,
      sendResultList: { 'type': 'array', 'itemType': DescribeAlertLogListResponseBodyAlertLogListSendResultList },
      sendStatus: 'string',
      webhookList: { 'type': 'array', 'itemType': DescribeAlertLogListResponseBodyAlertLogListWebhookList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAlertingMetricRuleResourcesResponseBodyResourcesResourceEscalationResourceExpressionListExpressionList extends $tea.Model {
  /**
   * @remarks
   * The operator that is used to compare the metric value with the threshold. Valid values:
   * 
   * *   GreaterThanOrEqualToThreshold: greater than or equal to the threshold
   * *   GreaterThanThreshold: greater than the threshold
   * *   LessThanOrEqualToThreshold: less than or equal to the threshold
   * *   LessThanThreshold: less than the threshold
   * *   NotEqualToThreshold: not equal to the threshold
   * *   GreaterThanYesterday: greater than the metric value at the same time yesterday
   * *   LessThanYesterday: less than the metric value at the same time yesterday
   * *   GreaterThanLastWeek: greater than the metric value at the same time last week
   * *   LessThanLastWeek: less than the metric value at the same time last week
   * *   GreaterThanLastPeriod: greater than the metric value in the last monitoring cycle
   * *   LessThanLastPeriod: less than the metric value in the last monitoring cycle
   * 
   * @example
   * GreaterThanOrEqualToThreshold
   */
  comparisonOperator?: string;
  /**
   * @remarks
   * The metric name.
   * 
   * @example
   * cpu_total
   */
  metricName?: string;
  /**
   * @remarks
   * The statistical period of the metric. Unit: seconds. The default value is the interval at which the monitoring data of the metric is collected.
   * 
   * @example
   * 60
   */
  period?: string;
  /**
   * @remarks
   * The statistical method of the alert level. Valid values:
   * 
   * *   Maximum
   * *   Minimum
   * *   Average
   * 
   * @example
   * Average
   */
  statistics?: string;
  /**
   * @remarks
   * The alert threshold.
   * 
   * @example
   * 90
   */
  threshold?: string;
  static names(): { [key: string]: string } {
    return {
      comparisonOperator: 'ComparisonOperator',
      metricName: 'MetricName',
      period: 'Period',
      statistics: 'Statistics',
      threshold: 'Threshold',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comparisonOperator: 'string',
      metricName: 'string',
      period: 'string',
      statistics: 'string',
      threshold: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAlertingMetricRuleResourcesResponseBodyResourcesResourceEscalationResourceExpressionList extends $tea.Model {
  expressionList?: DescribeAlertingMetricRuleResourcesResponseBodyResourcesResourceEscalationResourceExpressionListExpressionList[];
  static names(): { [key: string]: string } {
    return {
      expressionList: 'ExpressionList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      expressionList: { 'type': 'array', 'itemType': DescribeAlertingMetricRuleResourcesResponseBodyResourcesResourceEscalationResourceExpressionListExpressionList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAlertingMetricRuleResourcesResponseBodyResourcesResourceEscalationResource extends $tea.Model {
  /**
   * @remarks
   * The operator that is used to compare the metric value with the threshold. Valid values:
   * 
   * *   GreaterThanOrEqualToThreshold: greater than or equal to the threshold
   * *   GreaterThanThreshold: greater than the threshold
   * *   LessThanOrEqualToThreshold: less than or equal to the threshold
   * *   LessThanThreshold: less than the threshold
   * *   NotEqualToThreshold: not equal to the threshold
   * *   GreaterThanYesterday: greater than the metric value at the same time yesterday
   * *   LessThanYesterday: less than the metric value at the same time yesterday
   * *   GreaterThanLastWeek: greater than the metric value at the same time last week
   * *   LessThanLastWeek: less than the metric value at the same time last week
   * *   GreaterThanLastPeriod: greater than the metric value in the last monitoring cycle
   * *   LessThanLastPeriod: less than the metric value in the last monitoring cycle
   * 
   * @example
   * GreaterThanOrEqualToThreshold
   */
  comparisonOperator?: string;
  /**
   * @remarks
   * The description of the alert rule.
   * 
   * >  This parameter indicates the content of the alert rule. If the metric value meets the alert condition, an alert is triggered.
   * 
   * @example
   * $Average>=10
   */
  expression?: string;
  /**
   * @remarks
   * The description of the multi-metric alert rule.
   */
  expressionList?: DescribeAlertingMetricRuleResourcesResponseBodyResourcesResourceEscalationResourceExpressionList;
  /**
   * @remarks
   * The relationship between multiple metrics. Valid values:
   * 
   * *   &&: If all metrics meet the alert conditions, CloudMonitor sends alert notifications.
   * *   ||: If one of the metrics meets the alert conditions, CloudMonitor sends alert notifications.
   * 
   * @example
   * &&
   */
  expressionListJoin?: string;
  /**
   * @remarks
   * The trigger conditions that are created by using expressions. You can use expressions to create trigger conditions in the following scenarios:
   * 
   * *   Set an alert blacklist for specific resources. For example, if you specify `$instanceId != \\"i-io8kfvcpp7x5****\\" ``&&`` $Average > 50`, no alert is triggered when the `average metric value` of the `i-io8kfvcpp7x5****` instance exceeds 50.
   * *   Set a special alert threshold for a specified instance in the rule. For example, if you specify `$Average > ($instanceId == \\"i-io8kfvcpp7x5****\\"? 80: 50)`, an alert is triggered when the `average metric value` of the `i-io8kfvcpp7x5****` instance exceeds 80 or the `average metric value` of other instances exceeds 50.
   * *   Limit the number of instances whose metric values exceed the threshold. For example, if you specify `count($Average > 20) > 3`, an alert is triggered only when the `average metric value` of more than three instances exceeds 20.
   * 
   * @example
   * $Average > ($instanceId == \\"i-io8kfvcpp7x5****\\"? 80: 50)
   */
  expressionRaw?: string;
  /**
   * @remarks
   * The severity level and notification methods of the alert. Valid values:
   * 
   * *   4: Alert notifications are sent by using emails and DingTalk chatbots.
   * *   OK: No alert is generated.
   * 
   * @example
   * 3
   */
  level?: number;
  /**
   * @remarks
   * The operator that is used to compare the metric value with the threshold. Valid values:
   * 
   * *   `>=`
   * *   `=`
   * *   `<=`
   * *   `>`
   * *   `<`
   * *   `!=`
   * 
   * @example
   * >=
   */
  preCondition?: string;
  /**
   * @remarks
   * This parameter is deprecated.
   * 
   * @example
   * mns
   */
  tag?: string;
  /**
   * @remarks
   * The alert threshold.
   * 
   * @example
   * 10
   */
  threshold?: string;
  /**
   * @remarks
   * The consecutive number of times for which the metric value meets the alert condition before an alert is triggered.
   * 
   * @example
   * 1
   */
  times?: number;
  static names(): { [key: string]: string } {
    return {
      comparisonOperator: 'ComparisonOperator',
      expression: 'Expression',
      expressionList: 'ExpressionList',
      expressionListJoin: 'ExpressionListJoin',
      expressionRaw: 'ExpressionRaw',
      level: 'Level',
      preCondition: 'PreCondition',
      tag: 'Tag',
      threshold: 'Threshold',
      times: 'Times',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comparisonOperator: 'string',
      expression: 'string',
      expressionList: DescribeAlertingMetricRuleResourcesResponseBodyResourcesResourceEscalationResourceExpressionList,
      expressionListJoin: 'string',
      expressionRaw: 'string',
      level: 'number',
      preCondition: 'string',
      tag: 'string',
      threshold: 'string',
      times: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAlertingMetricRuleResourcesResponseBodyResourcesResourceEscalation extends $tea.Model {
  resource?: DescribeAlertingMetricRuleResourcesResponseBodyResourcesResourceEscalationResource[];
  static names(): { [key: string]: string } {
    return {
      resource: 'Resource',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resource: { 'type': 'array', 'itemType': DescribeAlertingMetricRuleResourcesResponseBodyResourcesResourceEscalationResource },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAlertingMetricRuleResourcesResponseBodyResourcesResource extends $tea.Model {
  /**
   * @remarks
   * The dimensions based on which the resources are queried.
   * 
   * @example
   * {\\"region\\":\\"cn-huhehaote\\",\\"queue\\":\\"test-0128\\",\\"userId\\":\\"120886317861****\\"}
   */
  dimensions?: string;
  /**
   * @remarks
   * Indicates whether the alert rule is enabled. Valid values:
   * 
   * *   true: The alert rule is enabled.
   * *   false: The alert rule is disabled.
   * 
   * @example
   * true
   */
  enable?: string;
  /**
   * @remarks
   * The alert rule based on which the alert is triggered.
   */
  escalation?: DescribeAlertingMetricRuleResourcesResponseBodyResourcesResourceEscalation;
  /**
   * @remarks
   * The ID of the application group.
   * 
   * >  If the alert rule is associated with an application group, the ID of the application group is returned in this parameter.
   * 
   * @example
   * 7671****
   */
  groupId?: string;
  /**
   * @remarks
   * The time when the last alert was triggered for the resource based on the alert rule. The value is a timestamp.
   * 
   * Unit: milliseconds.
   * 
   * @example
   * 1622427900000
   */
  lastAlertTime?: string;
  /**
   * @remarks
   * The time when the alert rule was last modified. The value is a timestamp.
   * 
   * Unit: milliseconds.
   * 
   * @example
   * 1622827900000
   */
  lastModifyTime?: string;
  /**
   * @remarks
   * The severity level and notification methods of the alert. Valid values:
   * 
   * *   4: Alert notifications are sent by using emails and DingTalk chatbots.
   * *   OK: No alert is generated.
   * 
   * @example
   * 3
   */
  level?: number;
  /**
   * @remarks
   * The metric name.
   * 
   * @example
   * ActiveMessages
   */
  metricName?: string;
  /**
   * @remarks
   * The metric value that triggered the alert based on the alert rule. The value is a JSON string.
   * 
   * @example
   * {\\"timestamp\\":1623727500000,\\"Sum\\":926,\\"value\\":463,\\"Maximum\\":463,\\"Minimum\\":463,\\"Average\\":463,\\"SampleCount\\":2,\\"userId\\":\\"120886317861****\\",\\"region\\":\\"cn-huhehaote\\",\\"queue\\":\\"test-0128\\"}
   */
  metricValues?: string;
  /**
   * @remarks
   * The namespace of the cloud service.
   * 
   * @example
   * acs_mns_new
   */
  namespace?: string;
  /**
   * @remarks
   * The type of the cloud service.
   * 
   * @example
   * mns
   */
  productCategory?: string;
  /**
   * @remarks
   * The resources that are monitored.
   * 
   * @example
   * userId=120886317861****,region=cn-huhehaote,queue=test-0128
   */
  resource?: string;
  /**
   * @remarks
   * The consecutive number of times for which the metric value meets the alert condition before an alert is triggered.
   * 
   * @example
   * 3
   */
  retryTimes?: string;
  /**
   * @remarks
   * The ID of the alert rule.
   * 
   * @example
   * putNewAlarm_user_7e78d765-0e3e-4671-ba6d-7ce39108****
   */
  ruleId?: string;
  /**
   * @remarks
   * The name of the alert rule.
   * 
   * @example
   * test123456789
   */
  ruleName?: string;
  /**
   * @remarks
   * The time when the resource was associated with the alert rule. The value is a timestamp.
   * 
   * Unit: milliseconds.
   * 
   * @example
   * 1622427900000
   */
  startTime?: string;
  /**
   * @remarks
   * The method used to calculate the metric values that trigger alerts.
   * 
   * @example
   * Average
   */
  statistics?: string;
  /**
   * @remarks
   * The alert threshold.
   * 
   * @example
   * 10
   */
  threshold?: string;
  static names(): { [key: string]: string } {
    return {
      dimensions: 'Dimensions',
      enable: 'Enable',
      escalation: 'Escalation',
      groupId: 'GroupId',
      lastAlertTime: 'LastAlertTime',
      lastModifyTime: 'LastModifyTime',
      level: 'Level',
      metricName: 'MetricName',
      metricValues: 'MetricValues',
      namespace: 'Namespace',
      productCategory: 'ProductCategory',
      resource: 'Resource',
      retryTimes: 'RetryTimes',
      ruleId: 'RuleId',
      ruleName: 'RuleName',
      startTime: 'StartTime',
      statistics: 'Statistics',
      threshold: 'Threshold',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dimensions: 'string',
      enable: 'string',
      escalation: DescribeAlertingMetricRuleResourcesResponseBodyResourcesResourceEscalation,
      groupId: 'string',
      lastAlertTime: 'string',
      lastModifyTime: 'string',
      level: 'number',
      metricName: 'string',
      metricValues: 'string',
      namespace: 'string',
      productCategory: 'string',
      resource: 'string',
      retryTimes: 'string',
      ruleId: 'string',
      ruleName: 'string',
      startTime: 'string',
      statistics: 'string',
      threshold: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAlertingMetricRuleResourcesResponseBodyResources extends $tea.Model {
  resource?: DescribeAlertingMetricRuleResourcesResponseBodyResourcesResource[];
  static names(): { [key: string]: string } {
    return {
      resource: 'Resource',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resource: { 'type': 'array', 'itemType': DescribeAlertingMetricRuleResourcesResponseBodyResourcesResource },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeContactGroupListResponseBodyContactGroupListContactGroupContacts extends $tea.Model {
  contact?: string[];
  static names(): { [key: string]: string } {
    return {
      contact: 'Contact',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contact: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeContactGroupListResponseBodyContactGroupListContactGroup extends $tea.Model {
  /**
   * @remarks
   * The alert contacts in the alert group.
   */
  contacts?: DescribeContactGroupListResponseBodyContactGroupListContactGroupContacts;
  /**
   * @remarks
   * The time when the alert group was created. This value is a UNIX timestamp that represents the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
   * 
   * @example
   * 1507070598000
   */
  createTime?: number;
  /**
   * @remarks
   * The description of the alert group.
   */
  describe?: string;
  /**
   * @remarks
   * Indicates whether the alert group subscribes to weekly reports. Valid values:
   * 
   * *   true: The alert group subscribes to weekly reports.
   * *   false: The alert group does not subscribe to weekly reports.
   * 
   * @example
   * true
   */
  enableSubscribed?: boolean;
  /**
   * @remarks
   * Indicates whether the alert group can subscribe to weekly reports. Valid values:
   * 
   * *   true: The alert group can subscribe to weekly reports.
   * *   false: The alert group cannot subscribe to weekly reports.
   * 
   * >  The weekly report subscription feature is only available for Alibaba Cloud accounts with more than five Elastic Compute Service (ECS) instances.
   * 
   * @example
   * true
   */
  enabledWeeklyReport?: boolean;
  /**
   * @remarks
   * The name of the alert group.
   * 
   * @example
   * Contact1
   */
  name?: string;
  /**
   * @remarks
   * The time when the alert group was modified. This value is a UNIX timestamp that represents the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
   * 
   * @example
   * 1589447759000
   */
  updateTime?: number;
  static names(): { [key: string]: string } {
    return {
      contacts: 'Contacts',
      createTime: 'CreateTime',
      describe: 'Describe',
      enableSubscribed: 'EnableSubscribed',
      enabledWeeklyReport: 'EnabledWeeklyReport',
      name: 'Name',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contacts: DescribeContactGroupListResponseBodyContactGroupListContactGroupContacts,
      createTime: 'number',
      describe: 'string',
      enableSubscribed: 'boolean',
      enabledWeeklyReport: 'boolean',
      name: 'string',
      updateTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeContactGroupListResponseBodyContactGroupList extends $tea.Model {
  contactGroup?: DescribeContactGroupListResponseBodyContactGroupListContactGroup[];
  static names(): { [key: string]: string } {
    return {
      contactGroup: 'ContactGroup',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contactGroup: { 'type': 'array', 'itemType': DescribeContactGroupListResponseBodyContactGroupListContactGroup },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeContactGroupListResponseBodyContactGroups extends $tea.Model {
  contactGroup?: string[];
  static names(): { [key: string]: string } {
    return {
      contactGroup: 'ContactGroup',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contactGroup: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeContactListResponseBodyContactsContactChannels extends $tea.Model {
  /**
   * @remarks
   * The TradeManager ID of the alert contact.
   * 
   * @example
   * Alice
   */
  aliIM?: string;
  /**
   * @remarks
   * The webhook URL of the DingTalk chatbot.
   * 
   * @example
   * https://oapi.dingtalk.com/robot/send?access_token=9bf44f8189597d07dfdd7a123455ffc112****
   */
  dingWebHook?: string;
  /**
   * @remarks
   * The email address of the alert contact.
   * 
   * @example
   * Alice@example.com
   */
  mail?: string;
  /**
   * @remarks
   * The phone number of the alert contact.
   * 
   * @example
   * 1333333****
   */
  SMS?: string;
  static names(): { [key: string]: string } {
    return {
      aliIM: 'AliIM',
      dingWebHook: 'DingWebHook',
      mail: 'Mail',
      SMS: 'SMS',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliIM: 'string',
      dingWebHook: 'string',
      mail: 'string',
      SMS: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeContactListResponseBodyContactsContactChannelsState extends $tea.Model {
  /**
   * @remarks
   * The status of the TradeManager ID.
   * 
   * Valid value: OK. The value OK indicates that the TradeManager ID is valid and can receive alert notifications.
   * 
   * >  This parameter can be returned only on the China site (aliyun.com).
   * 
   * @example
   * OK
   */
  aliIM?: string;
  /**
   * @remarks
   * The status of the DingTalk chatbot.
   * 
   * Valid value: OK. The value OK indicates that the DingTalk chatbot is normal and alert notifications can be received in a DingTalk group.
   * 
   * @example
   * OK
   */
  dingWebHook?: string;
  /**
   * @remarks
   * The status of the email address. Valid values:
   * 
   * *   PENDING: The email address is not activated. Alert notifications can be sent to the email address only after the email address is activated.
   * *   OK: The email address is activated and can receive alert notifications.
   * 
   * @example
   * PENDING
   */
  mail?: string;
  /**
   * @remarks
   * The status of the phone number. Valid values:
   * 
   * *   PENDING: The phone number is not activated. Alert notifications can be sent to the phone number by using text messages only after the phone number is activated.
   * *   OK: The phone number is activated and can receive alert notifications.
   * 
   * >  This parameter can be returned only on the China site (aliyun.com).
   * 
   * @example
   * OK
   */
  SMS?: string;
  static names(): { [key: string]: string } {
    return {
      aliIM: 'AliIM',
      dingWebHook: 'DingWebHook',
      mail: 'Mail',
      SMS: 'SMS',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliIM: 'string',
      dingWebHook: 'string',
      mail: 'string',
      SMS: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeContactListResponseBodyContactsContactContactGroups extends $tea.Model {
  contactGroup?: string[];
  static names(): { [key: string]: string } {
    return {
      contactGroup: 'ContactGroup',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contactGroup: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeContactListResponseBodyContactsContact extends $tea.Model {
  /**
   * @remarks
   * The alert notification method.
   */
  channels?: DescribeContactListResponseBodyContactsContactChannels;
  /**
   * @remarks
   * The status of the alert notification method. Valid values: PENDING and OK.
   * 
   * The email address must be activated after it is added as the value specified for the alert notification method. The value PENDING indicates that the email address is not activated. The value OK indicates that the email address is activated.
   */
  channelsState?: DescribeContactListResponseBodyContactsContactChannelsState;
  /**
   * @remarks
   * The alert contact groups.
   */
  contactGroups?: DescribeContactListResponseBodyContactsContactContactGroups;
  /**
   * @remarks
   * The timestamp when the alert contact was created.
   * 
   * Unit: milliseconds.
   * 
   * @example
   * 1552356159000
   */
  createTime?: number;
  /**
   * @remarks
   * The description of the alert contact.
   */
  desc?: string;
  /**
   * @remarks
   * The language in which the alert information is displayed. Valid values:
   * 
   * *   zh-cn: simplified Chinese
   * *   en: English
   * 
   * @example
   * zh-cn
   */
  lang?: string;
  /**
   * @remarks
   * The name of the alert contact.
   * 
   * @example
   * Alice
   */
  name?: string;
  /**
   * @remarks
   * The timestamp when the alert contact was updated.
   * 
   * Unit: milliseconds.
   * 
   * @example
   * 1552356159000
   */
  updateTime?: number;
  static names(): { [key: string]: string } {
    return {
      channels: 'Channels',
      channelsState: 'ChannelsState',
      contactGroups: 'ContactGroups',
      createTime: 'CreateTime',
      desc: 'Desc',
      lang: 'Lang',
      name: 'Name',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channels: DescribeContactListResponseBodyContactsContactChannels,
      channelsState: DescribeContactListResponseBodyContactsContactChannelsState,
      contactGroups: DescribeContactListResponseBodyContactsContactContactGroups,
      createTime: 'number',
      desc: 'string',
      lang: 'string',
      name: 'string',
      updateTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeContactListResponseBodyContacts extends $tea.Model {
  contact?: DescribeContactListResponseBodyContactsContact[];
  static names(): { [key: string]: string } {
    return {
      contact: 'Contact',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contact: { 'type': 'array', 'itemType': DescribeContactListResponseBodyContactsContact },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeContactListByContactGroupResponseBodyContactsContactChannels extends $tea.Model {
  /**
   * @remarks
   * The TradeManager ID of the alert contact.
   * 
   * >  This parameter can be returned only on the China site (aliyun.com).
   * 
   * @example
   * Alice
   */
  aliIM?: string;
  /**
   * @remarks
   * The webhook URL of the DingTalk chatbot.
   * 
   * @example
   * https://oapi.dingtalk.com/robot/send?access_token=9bf44f8189597d07dfdd7a123455ffc112****
   */
  dingWebHook?: string;
  /**
   * @remarks
   * The email address of the alert contact.
   * 
   * @example
   * alice@example.com
   */
  mail?: string;
  /**
   * @remarks
   * The mobile number of the alert contact.
   * 
   * >  This parameter can be returned only on the China site (aliyun.com).
   * 
   * @example
   * 1333333****
   */
  SMS?: string;
  static names(): { [key: string]: string } {
    return {
      aliIM: 'AliIM',
      dingWebHook: 'DingWebHook',
      mail: 'Mail',
      SMS: 'SMS',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliIM: 'string',
      dingWebHook: 'string',
      mail: 'string',
      SMS: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeContactListByContactGroupResponseBodyContactsContact extends $tea.Model {
  /**
   * @remarks
   * The alert notification methods.
   */
  channels?: DescribeContactListByContactGroupResponseBodyContactsContactChannels;
  /**
   * @remarks
   * The time when the alert contact was created.
   * 
   * Unit: milliseconds.
   * 
   * @example
   * 1552314252000
   */
  createTime?: number;
  /**
   * @remarks
   * The description of the alert contact.
   * 
   * @example
   * ECS
   */
  desc?: string;
  /**
   * @remarks
   * The name of the alert contact.
   * 
   * @example
   * Alice
   */
  name?: string;
  /**
   * @remarks
   * The time when the alert contact was modified.
   * 
   * Unit: milliseconds.
   * 
   * @example
   * 1552314252000
   */
  updateTime?: number;
  static names(): { [key: string]: string } {
    return {
      channels: 'Channels',
      createTime: 'CreateTime',
      desc: 'Desc',
      name: 'Name',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channels: DescribeContactListByContactGroupResponseBodyContactsContactChannels,
      createTime: 'number',
      desc: 'string',
      name: 'string',
      updateTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeContactListByContactGroupResponseBodyContacts extends $tea.Model {
  contact?: DescribeContactListByContactGroupResponseBodyContactsContact[];
  static names(): { [key: string]: string } {
    return {
      contact: 'Contact',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contact: { 'type': 'array', 'itemType': DescribeContactListByContactGroupResponseBodyContactsContact },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCustomEventAttributeResponseBodyCustomEventsCustomEvent extends $tea.Model {
  /**
   * @remarks
   * The content of the custom event.
   * 
   * @example
   * requestId:4975A6F3-19AC-4C01-BAD2-034DA07FEBB5, info:{"autoPay":false,"autoUseCoupon":false,"bid":"26842","buyerId":118935342242****,"commodities":[{"aliyunProduceCode":"cms","chargeType":"PREPAY","commodityCode":"cms_call_num","components":[{"componentCode":"phone_count","instanceProperty":[{"code":"phone_count","value":"500"}],"moduleAttrStatus":1}],"duration":6,"free":false,"orderParams":{"aliyunProduceCode":"cms"},"orderType":"BUY","prePayPostCharge":false,"pricingCycle":"Month","quantity":1,"refundSpecCode":"","renewChange":false,"specCode":"cms_call_num","specUpdate":false,"syncToSubscription":false,"upgradeInquireFinancialValue":true}],"fromApp":"commonbuy","orderParams":{"priceCheck":"true"},"payerId":118935342242****,"requestId":"ade3ad32-f58b-45d7-add4-ac542be3d8ec","skipChannel":false,"userId":118935342242****}
   */
  content?: string;
  /**
   * @remarks
   * The ID of the application group.
   * 
   * @example
   * 12345
   */
  groupId?: string;
  /**
   * @remarks
   * The ID of the custom event.
   * 
   * @example
   * 123
   */
  id?: string;
  /**
   * @remarks
   * The name of the custom event.
   * 
   * @example
   * BABEL_CHECK
   */
  name?: string;
  /**
   * @remarks
   * The time when the custom event occurred.
   * 
   * This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
   * 
   * @example
   * 1552199984000
   */
  time?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      groupId: 'GroupId',
      id: 'Id',
      name: 'Name',
      time: 'Time',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      groupId: 'string',
      id: 'string',
      name: 'string',
      time: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCustomEventAttributeResponseBodyCustomEvents extends $tea.Model {
  customEvent?: DescribeCustomEventAttributeResponseBodyCustomEventsCustomEvent[];
  static names(): { [key: string]: string } {
    return {
      customEvent: 'CustomEvent',
    };
  }

  static types(): { [key: string]: any } {
    return {
      customEvent: { 'type': 'array', 'itemType': DescribeCustomEventAttributeResponseBodyCustomEventsCustomEvent },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCustomEventCountResponseBodyCustomEventCountsCustomEventCount extends $tea.Model {
  /**
   * @remarks
   * The name of the custom event.
   * 
   * @example
   * BABEL_BUY
   */
  name?: string;
  /**
   * @remarks
   * The number of times that the custom event occurred in the specified time period.
   * 
   * @example
   * 20
   */
  num?: number;
  /**
   * @remarks
   * The time when the custom event occurred.
   * 
   * This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
   * 
   * @example
   * 1552267615000
   */
  time?: number;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      num: 'Num',
      time: 'Time',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      num: 'number',
      time: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCustomEventCountResponseBodyCustomEventCounts extends $tea.Model {
  customEventCount?: DescribeCustomEventCountResponseBodyCustomEventCountsCustomEventCount[];
  static names(): { [key: string]: string } {
    return {
      customEventCount: 'CustomEventCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      customEventCount: { 'type': 'array', 'itemType': DescribeCustomEventCountResponseBodyCustomEventCountsCustomEventCount },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCustomEventHistogramResponseBodyEventHistogramsEventHistogram extends $tea.Model {
  /**
   * @remarks
   * The information about the number of times that the custom event occurred during an interval of a time period.
   * 
   * @example
   * 3
   */
  count?: number;
  /**
   * @remarks
   * The end of an interval.
   * 
   * This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
   * 
   * @example
   * 1552226750000
   */
  endTime?: number;
  /**
   * @remarks
   * The beginning of an interval.
   * 
   * This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
   * 
   * @example
   * 1552226740000
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      endTime: 'EndTime',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      endTime: 'number',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCustomEventHistogramResponseBodyEventHistograms extends $tea.Model {
  eventHistogram?: DescribeCustomEventHistogramResponseBodyEventHistogramsEventHistogram[];
  static names(): { [key: string]: string } {
    return {
      eventHistogram: 'EventHistogram',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventHistogram: { 'type': 'array', 'itemType': DescribeCustomEventHistogramResponseBodyEventHistogramsEventHistogram },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupContactGroupList extends $tea.Model {
  contactGroupList?: string[];
  static names(): { [key: string]: string } {
    return {
      contactGroupList: 'ContactGroupList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contactGroupList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupMatchExpressMatchExpress extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * azone-version
   */
  tagKey?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * The `TagValue` and `TagValueMatchFunction` parameters must be used in pairs.
   * 
   * @example
   * *
   */
  tagValue?: string;
  /**
   * @remarks
   * The method that is used to match tag values. Valid values:
   * 
   * *   all: includes all
   * *   startWith: starts with a prefix
   * *   endWith: ends with a suffix
   * *   contains: contains
   * *   notContains: does not contain
   * *   equals: equals
   * 
   * @example
   * all
   */
  tagValueMatchFunction?: string;
  static names(): { [key: string]: string } {
    return {
      tagKey: 'TagKey',
      tagValue: 'TagValue',
      tagValueMatchFunction: 'TagValueMatchFunction',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagKey: 'string',
      tagValue: 'string',
      tagValueMatchFunction: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupMatchExpress extends $tea.Model {
  matchExpress?: DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupMatchExpressMatchExpress[];
  static names(): { [key: string]: string } {
    return {
      matchExpress: 'MatchExpress',
    };
  }

  static types(): { [key: string]: any } {
    return {
      matchExpress: { 'type': 'array', 'itemType': DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupMatchExpressMatchExpress },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupTagValueBlacklist extends $tea.Model {
  tagValueBlacklist?: string[];
  static names(): { [key: string]: string } {
    return {
      tagValueBlacklist: 'TagValueBlacklist',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagValueBlacklist: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupTemplateIdList extends $tea.Model {
  templateIdList?: string[];
  static names(): { [key: string]: string } {
    return {
      templateIdList: 'TemplateIdList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      templateIdList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroup extends $tea.Model {
  /**
   * @remarks
   * The alert contact group.
   */
  contactGroupList?: DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupContactGroupList;
  /**
   * @remarks
   * The ID of the tag rule.
   * 
   * @example
   * 1536df65-a719-429d-8813-73cc40d7****
   */
  dynamicTagRuleId?: string;
  /**
   * @remarks
   * The conditional expressions used to create an application group based on the tag.
   */
  matchExpress?: DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupMatchExpress;
  /**
   * @remarks
   * The logical operator that is used between conditional expressions. Valid values:
   * 
   * *   `and`
   * *   `or`
   * 
   * >  Only one logical operator can be used in a request.
   * 
   * @example
   * or
   */
  matchExpressFilterRelation?: string;
  /**
   * @remarks
   * The ID of the region to which the tags belong.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The status of adding instances that meet the tag rule to the application group. Valid values:
   * 
   * *   `RUNNING`
   * *   `FINISH`
   * 
   * @example
   * FINISH
   */
  status?: string;
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * tagkey1
   */
  tagKey?: string;
  tagValueBlacklist?: DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupTagValueBlacklist;
  /**
   * @remarks
   * The IDs of the alert templates.
   */
  templateIdList?: DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupTemplateIdList;
  static names(): { [key: string]: string } {
    return {
      contactGroupList: 'ContactGroupList',
      dynamicTagRuleId: 'DynamicTagRuleId',
      matchExpress: 'MatchExpress',
      matchExpressFilterRelation: 'MatchExpressFilterRelation',
      regionId: 'RegionId',
      status: 'Status',
      tagKey: 'TagKey',
      tagValueBlacklist: 'TagValueBlacklist',
      templateIdList: 'TemplateIdList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contactGroupList: DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupContactGroupList,
      dynamicTagRuleId: 'string',
      matchExpress: DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupMatchExpress,
      matchExpressFilterRelation: 'string',
      regionId: 'string',
      status: 'string',
      tagKey: 'string',
      tagValueBlacklist: DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupTagValueBlacklist,
      templateIdList: DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupTemplateIdList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDynamicTagRuleListResponseBodyTagGroupList extends $tea.Model {
  tagGroup?: DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroup[];
  static names(): { [key: string]: string } {
    return {
      tagGroup: 'TagGroup',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagGroup: { 'type': 'array', 'itemType': DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroup },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEventRuleAttributeResponseBodyResultEventPatternEventTypeList extends $tea.Model {
  eventTypeList?: string[];
  static names(): { [key: string]: string } {
    return {
      eventTypeList: 'EventTypeList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventTypeList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEventRuleAttributeResponseBodyResultEventPatternKeywordFilterObjKeywords extends $tea.Model {
  keyword?: string[];
  static names(): { [key: string]: string } {
    return {
      keyword: 'keyword',
    };
  }

  static types(): { [key: string]: any } {
    return {
      keyword: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEventRuleAttributeResponseBodyResultEventPatternKeywordFilterObj extends $tea.Model {
  /**
   * @remarks
   * The keywords that are used to match events.
   */
  keywords?: DescribeEventRuleAttributeResponseBodyResultEventPatternKeywordFilterObjKeywords;
  /**
   * @remarks
   * The relationship between multiple keywords in a condition. Valid values:
   * 
   * *   OR: The relationship between keywords is OR.
   * *   NOT: The keyword is excluded. The value NOT indicates that all events that do not contain the keywords are matched.
   * 
   * @example
   * OR
   */
  relation?: string;
  static names(): { [key: string]: string } {
    return {
      keywords: 'Keywords',
      relation: 'Relation',
    };
  }

  static types(): { [key: string]: any } {
    return {
      keywords: DescribeEventRuleAttributeResponseBodyResultEventPatternKeywordFilterObjKeywords,
      relation: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEventRuleAttributeResponseBodyResultEventPatternLevelList extends $tea.Model {
  levelList?: string[];
  static names(): { [key: string]: string } {
    return {
      levelList: 'LevelList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      levelList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEventRuleAttributeResponseBodyResultEventPatternNameList extends $tea.Model {
  nameList?: string[];
  static names(): { [key: string]: string } {
    return {
      nameList: 'NameList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nameList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEventRuleAttributeResponseBodyResultEventPatternStatusList extends $tea.Model {
  statusList?: string[];
  static names(): { [key: string]: string } {
    return {
      statusList: 'StatusList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      statusList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEventRuleAttributeResponseBodyResultEventPattern extends $tea.Model {
  /**
   * @remarks
   * The types of the event-triggered alert rules.
   */
  eventTypeList?: DescribeEventRuleAttributeResponseBodyResultEventPatternEventTypeList;
  /**
   * @remarks
   * The keyword for filtering.
   */
  keywordFilterObj?: DescribeEventRuleAttributeResponseBodyResultEventPatternKeywordFilterObj;
  levelList?: DescribeEventRuleAttributeResponseBodyResultEventPatternLevelList;
  nameList?: DescribeEventRuleAttributeResponseBodyResultEventPatternNameList;
  /**
   * @remarks
   * The name of the cloud service.
   * 
   * @example
   * CloudMonitor
   */
  product?: string;
  /**
   * @remarks
   * Indicates that logs are filtered based on the specified SQL statement. If the specified conditions are met, an alert is triggered.
   * 
   * @example
   * ycccluster1 and (i-23ij0o82612 or Executed1) or Asimulated not 222
   */
  SQLFilter?: string;
  statusList?: DescribeEventRuleAttributeResponseBodyResultEventPatternStatusList;
  static names(): { [key: string]: string } {
    return {
      eventTypeList: 'EventTypeList',
      keywordFilterObj: 'KeywordFilterObj',
      levelList: 'LevelList',
      nameList: 'NameList',
      product: 'Product',
      SQLFilter: 'SQLFilter',
      statusList: 'StatusList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventTypeList: DescribeEventRuleAttributeResponseBodyResultEventPatternEventTypeList,
      keywordFilterObj: DescribeEventRuleAttributeResponseBodyResultEventPatternKeywordFilterObj,
      levelList: DescribeEventRuleAttributeResponseBodyResultEventPatternLevelList,
      nameList: DescribeEventRuleAttributeResponseBodyResultEventPatternNameList,
      product: 'string',
      SQLFilter: 'string',
      statusList: DescribeEventRuleAttributeResponseBodyResultEventPatternStatusList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEventRuleAttributeResponseBodyResult extends $tea.Model {
  /**
   * @remarks
   * The description of the event-triggered alert rule.
   * 
   * @example
   * Default group event rule.
   */
  description?: string;
  /**
   * @remarks
   * The event pattern. This parameter describes the trigger conditions of an event.
   */
  eventPattern?: DescribeEventRuleAttributeResponseBodyResultEventPattern;
  /**
   * @remarks
   * The event type. Valid values:
   * 
   * *   SYSTEM: system event
   * *   CUSTOM: custom event
   * 
   * @example
   * SYSTEM
   */
  eventType?: string;
  /**
   * @remarks
   * The ID of the application group.
   * 
   * @example
   * 3607****
   */
  groupId?: string;
  /**
   * @remarks
   * The name of the event-triggered alert rule.
   * 
   * @example
   * test_DefaultEventRule_7378****
   */
  name?: string;
  /**
   * @remarks
   * The status of the event-triggered alert rule. Valid values:
   * 
   * *   ENABLED
   * *   DISABLED
   * 
   * @example
   * ENABLED
   */
  state?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      eventPattern: 'EventPattern',
      eventType: 'EventType',
      groupId: 'GroupId',
      name: 'Name',
      state: 'State',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      eventPattern: DescribeEventRuleAttributeResponseBodyResultEventPattern,
      eventType: 'string',
      groupId: 'string',
      name: 'string',
      state: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternEventTypeList extends $tea.Model {
  eventTypeList?: string[];
  static names(): { [key: string]: string } {
    return {
      eventTypeList: 'EventTypeList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventTypeList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternKeywordFilterKeywords extends $tea.Model {
  keywords?: string[];
  static names(): { [key: string]: string } {
    return {
      keywords: 'Keywords',
    };
  }

  static types(): { [key: string]: any } {
    return {
      keywords: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternKeywordFilter extends $tea.Model {
  /**
   * @remarks
   * The keywords that are used to match events.
   */
  keywords?: DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternKeywordFilterKeywords;
  /**
   * @remarks
   * The relationship between multiple keywords in a condition. Valid values:
   * 
   * *   OR: The relationship between keywords is OR.
   * *   NOT: The keyword is excluded. The value NOT indicates that all events that do not contain the keywords are matched.
   * 
   * @example
   * OR
   */
  relation?: string;
  static names(): { [key: string]: string } {
    return {
      keywords: 'Keywords',
      relation: 'Relation',
    };
  }

  static types(): { [key: string]: any } {
    return {
      keywords: DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternKeywordFilterKeywords,
      relation: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternLevelList extends $tea.Model {
  levelList?: string[];
  static names(): { [key: string]: string } {
    return {
      levelList: 'LevelList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      levelList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternNameList extends $tea.Model {
  nameList?: string[];
  static names(): { [key: string]: string } {
    return {
      nameList: 'NameList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nameList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPattern extends $tea.Model {
  /**
   * @remarks
   * The custom filter conditions.
   * 
   * @example
   * ECS123
   */
  customFilters?: string;
  /**
   * @remarks
   * The types of the event-triggered alert rules.
   */
  eventTypeList?: DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternEventTypeList;
  /**
   * @remarks
   * The keyword for filtering.
   */
  keywordFilter?: DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternKeywordFilter;
  /**
   * @remarks
   * The levels of the event-triggered alerts.
   */
  levelList?: DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternLevelList;
  /**
   * @remarks
   * The event names.
   */
  nameList?: DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternNameList;
  /**
   * @remarks
   * The abbreviation of the Alibaba Cloud service name.
   * 
   * @example
   * CloudMonitor
   */
  product?: string;
  /**
   * @remarks
   * Indicates that logs are filtered based on the specified SQL statement. If the specified conditions are met, an alert is triggered.
   * 
   * @example
   * ycccluster1 and (i-23ij0o82612 or Executed1) or Asimulated not 222
   */
  SQLFilter?: string;
  static names(): { [key: string]: string } {
    return {
      customFilters: 'CustomFilters',
      eventTypeList: 'EventTypeList',
      keywordFilter: 'KeywordFilter',
      levelList: 'LevelList',
      nameList: 'NameList',
      product: 'Product',
      SQLFilter: 'SQLFilter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      customFilters: 'string',
      eventTypeList: DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternEventTypeList,
      keywordFilter: DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternKeywordFilter,
      levelList: DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternLevelList,
      nameList: DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternNameList,
      product: 'string',
      SQLFilter: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEventRuleListResponseBodyEventRulesEventRuleEventPattern extends $tea.Model {
  eventPattern?: DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPattern[];
  static names(): { [key: string]: string } {
    return {
      eventPattern: 'EventPattern',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventPattern: { 'type': 'array', 'itemType': DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPattern },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEventRuleListResponseBodyEventRulesEventRule extends $tea.Model {
  /**
   * @remarks
   * The description of the event-triggered alert rule.
   * 
   * @example
   * Default group event rule.
   */
  description?: string;
  /**
   * @remarks
   * The mode of the event-triggered alert rule.
   */
  eventPattern?: DescribeEventRuleListResponseBodyEventRulesEventRuleEventPattern;
  /**
   * @remarks
   * The type of the event-triggered alert rule. Valid values:
   * 
   * *   SYSTEM: system event-triggered alert rule
   * *   CUSTOM: custom event-triggered alert rule
   * 
   * @example
   * SYSTEM
   */
  eventType?: string;
  /**
   * @remarks
   * The ID of the application group.
   * 
   * @example
   * 7378****
   */
  groupId?: string;
  /**
   * @remarks
   * The name of the event-triggered alert rule.
   * 
   * @example
   * test_DefaultEventRule_7378****
   */
  name?: string;
  /**
   * @remarks
   * The mute period during which new alert notifications are not sent even if the trigger conditions are met.
   * 
   * @example
   * 86400
   */
  silenceTime?: number;
  /**
   * @remarks
   * The status of the event-triggered alert rule. Valid values:
   * 
   * *   ENABLED
   * *   DISABLED
   * 
   * @example
   * ENABLED
   */
  state?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      eventPattern: 'EventPattern',
      eventType: 'EventType',
      groupId: 'GroupId',
      name: 'Name',
      silenceTime: 'SilenceTime',
      state: 'State',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      eventPattern: DescribeEventRuleListResponseBodyEventRulesEventRuleEventPattern,
      eventType: 'string',
      groupId: 'string',
      name: 'string',
      silenceTime: 'number',
      state: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEventRuleListResponseBodyEventRules extends $tea.Model {
  eventRule?: DescribeEventRuleListResponseBodyEventRulesEventRule[];
  static names(): { [key: string]: string } {
    return {
      eventRule: 'EventRule',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventRule: { 'type': 'array', 'itemType': DescribeEventRuleListResponseBodyEventRulesEventRule },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEventRuleTargetListResponseBodyContactParametersContactParameter extends $tea.Model {
  /**
   * @remarks
   * The name of the alert group.
   */
  contactGroupName?: string;
  /**
   * @remarks
   * The ID of the recipient.
   * 
   * @example
   * 1
   */
  id?: string;
  /**
   * @remarks
   * The alert notification methods. Valid values:
   * 
   * 4: Alert notifications are sent by using DingTalk chatbots and emails.
   * 
   * @example
   * 3
   */
  level?: string;
  static names(): { [key: string]: string } {
    return {
      contactGroupName: 'ContactGroupName',
      id: 'Id',
      level: 'Level',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contactGroupName: 'string',
      id: 'string',
      level: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEventRuleTargetListResponseBodyContactParameters extends $tea.Model {
  contactParameter?: DescribeEventRuleTargetListResponseBodyContactParametersContactParameter[];
  static names(): { [key: string]: string } {
    return {
      contactParameter: 'ContactParameter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contactParameter: { 'type': 'array', 'itemType': DescribeEventRuleTargetListResponseBodyContactParametersContactParameter },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEventRuleTargetListResponseBodyFcParametersFCParameter extends $tea.Model {
  /**
   * @remarks
   * The Alibaba Cloud Resource Name (ARN) of the function. 
   * 
   * Format: `arn:acs:${Service}:${Region}:${Account}:${ResourceType}/${ResourceId}`. Fields: 
   * 
   * - Service: the code of an Alibaba Cloud service
   * - Region: the region ID
   * - Account: the ID of an Alibaba Cloud account
   * - ResourceType: the resource type
   * - ResourceId: the resource ID
   */
  arn?: string;
  /**
   * @remarks
   * The name of the function.
   * 
   * @example
   * fcTest1
   */
  functionName?: string;
  /**
   * @remarks
   * The ID of the recipient.
   * 
   * @example
   * 3
   */
  id?: string;
  /**
   * @remarks
   * The region where Function Compute is deployed.
   * 
   * @example
   * cn-qingdao
   */
  region?: string;
  /**
   * @remarks
   * The name of the Function Compute service.
   * 
   * @example
   * service1
   */
  serviceName?: string;
  static names(): { [key: string]: string } {
    return {
      arn: 'Arn',
      functionName: 'FunctionName',
      id: 'Id',
      region: 'Region',
      serviceName: 'ServiceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      arn: 'string',
      functionName: 'string',
      id: 'string',
      region: 'string',
      serviceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEventRuleTargetListResponseBodyFcParameters extends $tea.Model {
  FCParameter?: DescribeEventRuleTargetListResponseBodyFcParametersFCParameter[];
  static names(): { [key: string]: string } {
    return {
      FCParameter: 'FCParameter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      FCParameter: { 'type': 'array', 'itemType': DescribeEventRuleTargetListResponseBodyFcParametersFCParameter },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEventRuleTargetListResponseBodyMnsParametersMnsParameter extends $tea.Model {
  /**
   * @remarks
   * The ARN of the MNS queue. 
   * 
   * Format: `arn:acs:${Service}:${Region}:${Account}:${ResourceType}/${ResourceId}`. Fields: 
   * 
   * - Service: the code of an Alibaba Cloud service
   * - Region: the region ID
   * - Account: the ID of an Alibaba Cloud account
   * - ResourceType: the resource type
   * - ResourceId: the resource ID
   */
  arn?: string;
  /**
   * @remarks
   * The ID of the recipient.
   * 
   * @example
   * 2
   */
  id?: string;
  /**
   * @remarks
   * The name of the MNS queue.
   * 
   * @example
   * testQueue
   */
  queue?: string;
  /**
   * @remarks
   * The region where MNS is deployed.
   * 
   * @example
   * cn-hangzhou
   */
  region?: string;
  /**
   * @remarks
   * The MNS topic.
   * 
   * @example
   * topic_sample
   */
  topic?: string;
  static names(): { [key: string]: string } {
    return {
      arn: 'Arn',
      id: 'Id',
      queue: 'Queue',
      region: 'Region',
      topic: 'Topic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      arn: 'string',
      id: 'string',
      queue: 'string',
      region: 'string',
      topic: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEventRuleTargetListResponseBodyMnsParameters extends $tea.Model {
  mnsParameter?: DescribeEventRuleTargetListResponseBodyMnsParametersMnsParameter[];
  static names(): { [key: string]: string } {
    return {
      mnsParameter: 'MnsParameter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      mnsParameter: { 'type': 'array', 'itemType': DescribeEventRuleTargetListResponseBodyMnsParametersMnsParameter },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEventRuleTargetListResponseBodyOpenApiParametersOpenApiParameters extends $tea.Model {
  /**
   * @remarks
   * The name of the API operation.
   * 
   * @example
   * PutLogs
   */
  action?: string;
  /**
   * @remarks
   * The ARN of the API operation. 
   * 
   * Format: `arn:acs:${Service}:${Region}:${Account}:${ResourceType}/${ResourceId}`. Fields: 
   * 
   * - Service: the code of an Alibaba Cloud service
   * - Region: the region ID
   * - Account: the ID of an Alibaba Cloud account
   * - ResourceType: the resource type
   * - ResourceId: the resource ID The ARN of the Log Service Logstore. 
   * 
   * Format: `arn:acs:${Service}:${Region}:${Account}:${ResourceType}/${ResourceId}`. Fields:
   * - Service: the code of an Alibaba Cloud service
   * - Region: the region ID
   * - Account: the ID of an Alibaba Cloud account
   * - ResourceType: the resource type
   * - ResourceId: the resource ID
   */
  arn?: string;
  /**
   * @remarks
   * The ID of the recipient.
   * 
   * @example
   * 3
   */
  id?: string;
  /**
   * @remarks
   * The ID of the cloud service to which the API operation belongs.
   * 
   * @example
   * log
   */
  product?: string;
  /**
   * @remarks
   * The region where the resource resides.
   * 
   * @example
   * cn-hangzhou
   */
  region?: string;
  /**
   * @remarks
   * The name of the role.
   * 
   * @example
   * MyRole
   */
  role?: string;
  /**
   * @remarks
   * The version of the API.
   * 
   * @example
   * 2019-01-01
   */
  version?: string;
  static names(): { [key: string]: string } {
    return {
      action: 'Action',
      arn: 'Arn',
      id: 'Id',
      product: 'Product',
      region: 'Region',
      role: 'Role',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      action: 'string',
      arn: 'string',
      id: 'string',
      product: 'string',
      region: 'string',
      role: 'string',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEventRuleTargetListResponseBodyOpenApiParameters extends $tea.Model {
  openApiParameters?: DescribeEventRuleTargetListResponseBodyOpenApiParametersOpenApiParameters[];
  static names(): { [key: string]: string } {
    return {
      openApiParameters: 'OpenApiParameters',
    };
  }

  static types(): { [key: string]: any } {
    return {
      openApiParameters: { 'type': 'array', 'itemType': DescribeEventRuleTargetListResponseBodyOpenApiParametersOpenApiParameters },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEventRuleTargetListResponseBodySlsParametersSlsParameter extends $tea.Model {
  /**
   * @remarks
   * The ARN of the Log Service Logstore. 
   * 
   * Format: `arn:acs:${Service}:${Region}:${Account}:${ResourceType}/${ResourceId}`. Fields: 
   * 
   * - Service: the code of an Alibaba Cloud service
   * - Region: the region ID
   * - Account: the ID of an Alibaba Cloud account
   * - ResourceType: the resource type
   * - ResourceId: the resource ID
   */
  arn?: string;
  /**
   * @remarks
   * The ID of the recipient.
   * 
   * @example
   * 4
   */
  id?: string;
  /**
   * @remarks
   * The name of the Logstore.
   * 
   * @example
   * logstore_test
   */
  logStore?: string;
  /**
   * @remarks
   * The name of the project.
   * 
   * @example
   * project_test
   */
  project?: string;
  /**
   * @remarks
   * The ID of the region where the Log Service project resides.
   * 
   * @example
   * cn-hangzhou
   */
  region?: string;
  static names(): { [key: string]: string } {
    return {
      arn: 'Arn',
      id: 'Id',
      logStore: 'LogStore',
      project: 'Project',
      region: 'Region',
    };
  }

  static types(): { [key: string]: any } {
    return {
      arn: 'string',
      id: 'string',
      logStore: 'string',
      project: 'string',
      region: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEventRuleTargetListResponseBodySlsParameters extends $tea.Model {
  slsParameter?: DescribeEventRuleTargetListResponseBodySlsParametersSlsParameter[];
  static names(): { [key: string]: string } {
    return {
      slsParameter: 'SlsParameter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      slsParameter: { 'type': 'array', 'itemType': DescribeEventRuleTargetListResponseBodySlsParametersSlsParameter },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEventRuleTargetListResponseBodyWebhookParametersWebhookParameter extends $tea.Model {
  /**
   * @remarks
   * The ID of the recipient.
   * 
   * @example
   * 5
   */
  id?: string;
  /**
   * @remarks
   * The HTTP request method. Valid values: GET and POST.
   * 
   * @example
   * GET
   */
  method?: string;
  /**
   * @remarks
   * The protocol type.
   * 
   * @example
   * HTTP
   */
  protocol?: string;
  /**
   * @remarks
   * The callback URL.
   * 
   * @example
   * http://www.aliyun.com
   */
  url?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      method: 'Method',
      protocol: 'Protocol',
      url: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      method: 'string',
      protocol: 'string',
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEventRuleTargetListResponseBodyWebhookParameters extends $tea.Model {
  webhookParameter?: DescribeEventRuleTargetListResponseBodyWebhookParametersWebhookParameter[];
  static names(): { [key: string]: string } {
    return {
      webhookParameter: 'WebhookParameter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      webhookParameter: { 'type': 'array', 'itemType': DescribeEventRuleTargetListResponseBodyWebhookParametersWebhookParameter },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExporterOutputListResponseBodyDatapointsDatapointConfigJson extends $tea.Model {
  /**
   * @remarks
   * The AccessKey ID.
   * 
   * @example
   * LTAIpY33********
   */
  ak?: string;
  /**
   * @remarks
   * The Log Service endpoint to which the monitoring data is exported.
   * 
   * @example
   * http://cn-qingdao-share.log.aliyuncs.com
   */
  endpoint?: string;
  /**
   * @remarks
   * The Logstore.
   * 
   * @example
   * monitorlogstore
   */
  logstore?: string;
  /**
   * @remarks
   * The Log Service project to which the monitoring data is exported.
   * 
   * @example
   * exporter
   */
  project?: string;
  static names(): { [key: string]: string } {
    return {
      ak: 'ak',
      endpoint: 'endpoint',
      logstore: 'logstore',
      project: 'project',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ak: 'string',
      endpoint: 'string',
      logstore: 'string',
      project: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExporterOutputListResponseBodyDatapointsDatapoint extends $tea.Model {
  /**
   * @remarks
   * The JSON object that contains the details about the destination to which the monitoring data is exported.
   */
  configJson?: DescribeExporterOutputListResponseBodyDatapointsDatapointConfigJson;
  /**
   * @remarks
   * The time when the configuration set was created. The value is a UNIX timestamp.
   * 
   * @example
   * 1584016495498
   */
  createTime?: number;
  /**
   * @remarks
   * The name of the configuration set.
   * 
   * @example
   * exporterOut
   */
  destName?: string;
  /**
   * @remarks
   * The service to which the monitoring data is exported.
   * 
   * > Only Log Service is supported. More services will be supported in the future.
   * 
   * @example
   * SLS
   */
  destType?: string;
  static names(): { [key: string]: string } {
    return {
      configJson: 'ConfigJson',
      createTime: 'CreateTime',
      destName: 'DestName',
      destType: 'DestType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configJson: DescribeExporterOutputListResponseBodyDatapointsDatapointConfigJson,
      createTime: 'number',
      destName: 'string',
      destType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExporterOutputListResponseBodyDatapoints extends $tea.Model {
  datapoint?: DescribeExporterOutputListResponseBodyDatapointsDatapoint[];
  static names(): { [key: string]: string } {
    return {
      datapoint: 'Datapoint',
    };
  }

  static types(): { [key: string]: any } {
    return {
      datapoint: { 'type': 'array', 'itemType': DescribeExporterOutputListResponseBodyDatapointsDatapoint },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExporterRuleListResponseBodyDatapointsDatapointDstName extends $tea.Model {
  dstName?: string[];
  static names(): { [key: string]: string } {
    return {
      dstName: 'DstName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dstName: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExporterRuleListResponseBodyDatapointsDatapoint extends $tea.Model {
  /**
   * @remarks
   * The time when the rule was created. The value is a UNIX timestamp.
   * 
   * @example
   * 1584024616228
   */
  createTime?: number;
  /**
   * @remarks
   * The description of the rule.
   * 
   * @example
   * Export monitoring data
   */
  describe?: string;
  /**
   * @remarks
   * The associated dimensions.
   * 
   * @example
   * {"instanceId":"xxxxx"}
   */
  dimension?: string;
  dstName?: DescribeExporterRuleListResponseBodyDatapointsDatapointDstName;
  /**
   * @remarks
   * Indicates whether the rule is enabled.
   * 
   * @example
   * true
   */
  enabled?: boolean;
  /**
   * @remarks
   * The name of the metric.
   * 
   * > For more information, see [DescribeMetricMetaList](https://help.aliyun.com/document_detail/98846.html) or [Appendix 1: Metrics](https://help.aliyun.com/document_detail/28619.html).
   * 
   * @example
   * cpu_total
   */
  metricName?: string;
  /**
   * @remarks
   * The namespace of the service.
   * 
   * > For more information, see [DescribeMetricMetaList](https://help.aliyun.com/document_detail/98846.html) or [Appendix 1: Metrics](https://help.aliyun.com/document_detail/28619.html).
   * 
   * @example
   * acs_ecs_dashboard
   */
  namespace?: string;
  /**
   * @remarks
   * The name of the data export rule.
   * 
   * @example
   * myRuleName
   */
  ruleName?: string;
  /**
   * @remarks
   * The time window of the exported data.\\
   * Multiple windows are separated with commas (,).
   * 
   * > Data in a time window of less than 60 seconds cannot be exported.
   * 
   * @example
   * 60,300
   */
  targetWindows?: string;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      describe: 'Describe',
      dimension: 'Dimension',
      dstName: 'DstName',
      enabled: 'Enabled',
      metricName: 'MetricName',
      namespace: 'Namespace',
      ruleName: 'RuleName',
      targetWindows: 'TargetWindows',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'number',
      describe: 'string',
      dimension: 'string',
      dstName: DescribeExporterRuleListResponseBodyDatapointsDatapointDstName,
      enabled: 'boolean',
      metricName: 'string',
      namespace: 'string',
      ruleName: 'string',
      targetWindows: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExporterRuleListResponseBodyDatapoints extends $tea.Model {
  datapoint?: DescribeExporterRuleListResponseBodyDatapointsDatapoint[];
  static names(): { [key: string]: string } {
    return {
      datapoint: 'Datapoint',
    };
  }

  static types(): { [key: string]: any } {
    return {
      datapoint: { 'type': 'array', 'itemType': DescribeExporterRuleListResponseBodyDatapointsDatapoint },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessAlertConfigAlertConfigTargetListTarget extends $tea.Model {
  /**
   * @remarks
   * The Alibaba Cloud Resource Name (ARN) of the resource. Format: acs:{Service name abbreviation}:{regionId}:{userId}:/{Resource type}/{Resource name}/message. Example: acs:mns:cn-hangzhou:120886317861\\*\\*\\*\\*:/queues/test123/message. Fields:
   * 
   * {Service name abbreviation}: the abbreviation of the service name. Valid value: mns. {userId}: the ID of the Alibaba Cloud account. {regionId}: the region ID of the message queue or topic. {Resource type}: the type of the resource that triggers the alert. Valid values: - **queues** - **topics** - {Resource name}: the resource name. - If the resource type is set to **queues**, the resource name is the name of the message queue. - If the resource type is set to **topics**, the resource name is the name of the topic.
   * 
   * @example
   * acs:mns:cn-hangzhou:120886317861****:/queues/test/message
   */
  arn?: string;
  /**
   * @remarks
   * The ID of the resource for which alerts are triggered.
   * 
   * @example
   * 123
   */
  id?: string;
  /**
   * @remarks
   * The parameters of the alert callback. The parameters are in the JSON format.
   * 
   * @example
   * {"customField1":"value1","customField2":"$.name"}
   */
  jsonParmas?: string;
  /**
   * @remarks
   * The level of the alert. Valid values:
   * 
   * INFO WARN CRITICAL
   * 
   * @example
   * CRITICAL
   */
  level?: string;
  static names(): { [key: string]: string } {
    return {
      arn: 'Arn',
      id: 'Id',
      jsonParmas: 'JsonParmas',
      level: 'Level',
    };
  }

  static types(): { [key: string]: any } {
    return {
      arn: 'string',
      id: 'string',
      jsonParmas: 'string',
      level: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessAlertConfigAlertConfigTargetList extends $tea.Model {
  target?: DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessAlertConfigAlertConfigTargetListTarget[];
  static names(): { [key: string]: string } {
    return {
      target: 'Target',
    };
  }

  static types(): { [key: string]: any } {
    return {
      target: { 'type': 'array', 'itemType': DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessAlertConfigAlertConfigTargetListTarget },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessAlertConfigAlertConfig extends $tea.Model {
  /**
   * @remarks
   * The comparison operator that is used to compare the metric value with the threshold. Valid values:
   * 
   * *   GreaterThanOrEqualToThreshold: greater than or equal to the threshold
   * *   GreaterThanThreshold: greater than the threshold
   * *   LessThanOrEqualToThreshold: less than or equal to the threshold
   * *   LessThanThreshold: less than the threshold
   * *   NotEqualToThreshold: not equal to the threshold
   * *   GreaterThanYesterday: greater than the metric value at the same time yesterday.
   * *   LessThanYesterday: less than the metric value at the same time yesterday
   * *   GreaterThanLastWeek: greater than the metric value at the same time last week
   * *   LessThanLastWeek: less than the metric value at the same time last week
   * *   GreaterThanLastPeriod: greater than the metric value in the last monitoring cycle
   * *   LessThanLastPeriod: less than the metric value in the last monitoring cycle
   * 
   * @example
   * GreaterThanOrEqualToThreshold
   */
  comparisonOperator?: string;
  /**
   * @remarks
   * The time period during which the alert rule is effective.
   * 
   * @example
   * 00:00-23:59
   */
  effectiveInterval?: string;
  /**
   * @remarks
   * The level of the alert. Valid values:
   * 
   * *   critical
   * *   warn
   * *   Info
   * 
   * @example
   * warn
   */
  escalationsLevel?: string;
  /**
   * @remarks
   * The time period during which the alert rule is ineffective.
   * 
   * @example
   * 00:00-23:59
   */
  noEffectiveInterval?: string;
  /**
   * @remarks
   * The mute period during which new alert notifications are not sent even if the trigger conditions are met. Unit: seconds. Minimum value: 3600, which is equivalent to one hour. Default value: 86400, which is equivalent to one day.
   * 
   * >  Only one alert notification is sent during each mute period even if the metric value exceeds the alert threshold several times.
   * 
   * @example
   * 86400
   */
  silenceTime?: string;
  /**
   * @remarks
   * The method used to calculate metric values that trigger alerts.
   * 
   * @example
   * Average
   */
  statistics?: string;
  /**
   * @remarks
   * The resource for which alerts are triggered.
   */
  targetList?: DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessAlertConfigAlertConfigTargetList;
  /**
   * @remarks
   * The alert threshold.
   * 
   * @example
   * 5
   */
  threshold?: string;
  /**
   * @remarks
   * The number of times for which the threshold can be consecutively exceeded.
   * 
   * >  A metric triggers an alert only after the metric value reaches the threshold consecutively for the specified times.
   * 
   * @example
   * 3
   */
  times?: string;
  /**
   * @remarks
   * The callback URL to which a POST request is sent when an alert is triggered based on the alert rule.
   * 
   * @example
   * http://www.aliyun.com
   */
  webhook?: string;
  static names(): { [key: string]: string } {
    return {
      comparisonOperator: 'ComparisonOperator',
      effectiveInterval: 'EffectiveInterval',
      escalationsLevel: 'EscalationsLevel',
      noEffectiveInterval: 'NoEffectiveInterval',
      silenceTime: 'SilenceTime',
      statistics: 'Statistics',
      targetList: 'TargetList',
      threshold: 'Threshold',
      times: 'Times',
      webhook: 'Webhook',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comparisonOperator: 'string',
      effectiveInterval: 'string',
      escalationsLevel: 'string',
      noEffectiveInterval: 'string',
      silenceTime: 'string',
      statistics: 'string',
      targetList: DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessAlertConfigAlertConfigTargetList,
      threshold: 'string',
      times: 'string',
      webhook: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessAlertConfig extends $tea.Model {
  alertConfig?: DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessAlertConfigAlertConfig[];
  static names(): { [key: string]: string } {
    return {
      alertConfig: 'AlertConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertConfig: { 'type': 'array', 'itemType': DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessAlertConfigAlertConfig },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessMatchExpressMatchExpress extends $tea.Model {
  /**
   * @remarks
   * The matching condition. Valid values:
   * 
   * *   all (default): matches all
   * *   startWith: starts with a prefix
   * *   endWith: ends with a suffix
   * *   contains: contains
   * *   notContains: excludes
   * *   equals: equals
   * 
   * >  The matched instances are monitored by the process monitoring task.
   * 
   * @example
   * all
   */
  function?: string;
  /**
   * @remarks
   * The criteria based on which the instances are matched.
   * 
   * >  Set the value to `name`. The value name indicates that the instances are matched based on the instance name.
   * 
   * @example
   * name
   */
  name?: string;
  /**
   * @remarks
   * The keyword used to match the instance name.
   * 
   * @example
   * portalHost
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      function: 'Function',
      name: 'Name',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      function: 'string',
      name: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessMatchExpress extends $tea.Model {
  matchExpress?: DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessMatchExpressMatchExpress[];
  static names(): { [key: string]: string } {
    return {
      matchExpress: 'MatchExpress',
    };
  }

  static types(): { [key: string]: any } {
    return {
      matchExpress: { 'type': 'array', 'itemType': DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessMatchExpressMatchExpress },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcess extends $tea.Model {
  /**
   * @remarks
   * The alert rule configurations.
   */
  alertConfig?: DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessAlertConfig;
  /**
   * @remarks
   * The ID of the application group.
   * 
   * @example
   * 12345
   */
  groupId?: string;
  /**
   * @remarks
   * The ID of the process monitoring task.
   * 
   * @example
   * 3F6150F9-45C7-43F9-9578-A58B2E72****
   */
  id?: string;
  /**
   * @remarks
   * The matching conditions.
   * 
   * >  Only the instances that meet the conditional expressions are monitored by the process monitoring task.
   */
  matchExpress?: DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessMatchExpress;
  /**
   * @remarks
   * The logical operator used between conditional expressions that are used to match instances. Valid values:
   * 
   * *   all
   * *   and
   * *   or
   * 
   * @example
   * and
   */
  matchExpressFilterRelation?: string;
  /**
   * @remarks
   * The process name.
   * 
   * @example
   * sshd
   */
  processName?: string;
  static names(): { [key: string]: string } {
    return {
      alertConfig: 'AlertConfig',
      groupId: 'GroupId',
      id: 'Id',
      matchExpress: 'MatchExpress',
      matchExpressFilterRelation: 'MatchExpressFilterRelation',
      processName: 'ProcessName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertConfig: DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessAlertConfig,
      groupId: 'string',
      id: 'string',
      matchExpress: DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessMatchExpress,
      matchExpressFilterRelation: 'string',
      processName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGroupMonitoringAgentProcessResponseBodyProcesses extends $tea.Model {
  process?: DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcess[];
  static names(): { [key: string]: string } {
    return {
      process: 'Process',
    };
  }

  static types(): { [key: string]: any } {
    return {
      process: { 'type': 'array', 'itemType': DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcess },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfigEscalationListEscalationList extends $tea.Model {
  /**
   * @remarks
   * The method used to calculate metric values that trigger alerts. Valid values:
   * 
   * *   Value: the value of the HTTP status code
   * *   Average: the average HTTP response time
   * *   Value: the value of the Telnet status code
   * *   TelnetLatency: the average Telnet response time
   * *   Average: the average Ping packet loss rate
   * 
   * @example
   * Value
   */
  aggregate?: string;
  /**
   * @remarks
   * The name of the metric. Valid values:
   * 
   * *   HttpStatus
   * *   HttpLatency
   * *   TelnetStatus
   * *   TelnetLatency
   * *   PingLostRate
   * 
   * @example
   * HttpStatus
   */
  metricName?: string;
  /**
   * @remarks
   * The comparison operator that is used in the alert rule. Valid values:
   * 
   * *   `>`
   * *   `>=`
   * *   `<`
   * *   `<=`
   * *   `=`
   * 
   * @example
   * =
   */
  operator?: string;
  /**
   * @remarks
   * The consecutive number of times for which the metric value is measured before an alert is triggered.
   * 
   * @example
   * 3
   */
  times?: string;
  /**
   * @remarks
   * The alert threshold.
   * 
   * @example
   * 400
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      aggregate: 'Aggregate',
      metricName: 'MetricName',
      operator: 'Operator',
      times: 'Times',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aggregate: 'string',
      metricName: 'string',
      operator: 'string',
      times: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfigEscalationList extends $tea.Model {
  escalationList?: DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfigEscalationListEscalationList[];
  static names(): { [key: string]: string } {
    return {
      escalationList: 'escalationList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      escalationList: { 'type': 'array', 'itemType': DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfigEscalationListEscalationList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfigTargetListTarget extends $tea.Model {
  /**
   * @remarks
   * The Alibaba Cloud Resource Name (ARN) of the function.
   * 
   * Format: `arn:acs:${Service}:${Region}:${Account}:${ResourceType}/${ResourceId}`. Fields:
   * 
   * *   Service: the service code
   * *   Region: the region ID
   * *   Account: the ID of the Alibaba Cloud account
   * *   ResourceType: the resource type
   * *   ResourceId: the resource ID.
   * 
   * @example
   * acs:mns:cn-hangzhou:17754132319*****:/queues/test/messages
   */
  arn?: string;
  /**
   * @remarks
   * The ID of the resource that triggers the alert.
   * 
   * @example
   * 1
   */
  id?: string;
  /**
   * @remarks
   * The JSON-formatted parameters of the alert callback.
   * 
   * @example
   * {"key1":"value1"}
   */
  jsonParams?: string;
  /**
   * @remarks
   * The alert level. Valid values:
   * 
   * *   INFO
   * *   WARN
   * *   CRITICAL
   * 
   * @example
   * INFO
   */
  level?: string;
  static names(): { [key: string]: string } {
    return {
      arn: 'Arn',
      id: 'Id',
      jsonParams: 'JsonParams',
      level: 'Level',
    };
  }

  static types(): { [key: string]: any } {
    return {
      arn: 'string',
      id: 'string',
      jsonParams: 'string',
      level: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfigTargetList extends $tea.Model {
  target?: DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfigTargetListTarget[];
  static names(): { [key: string]: string } {
    return {
      target: 'Target',
    };
  }

  static types(): { [key: string]: any } {
    return {
      target: { 'type': 'array', 'itemType': DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfigTargetListTarget },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfig extends $tea.Model {
  /**
   * @remarks
   * The end of the time period during which the alert rule is effective. Valid values: 0 to 23.
   * 
   * For example, if the `AlertConfig.StartTime` parameter is set to 0 and the `AlertConfig.EndTime` parameter is set to 22, the alert rule is effective from 00:00:00 to 22:00:00.
   * 
   * >  Alert notifications are sent based on the specified threshold only if the alert rule is effective.
   * 
   * @example
   * 22
   */
  endTime?: number;
  /**
   * @remarks
   * The trigger conditions of the alert rule.
   */
  escalationList?: DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfigEscalationList;
  /**
   * @remarks
   * The alert notification methods. Valid values:
   * 
   * *   2: Alert notifications are sent by using emails and DingTalk chatbots.
   * *   1: Alert notifications are sent by using emails and DingTalk chatbots.
   * *   0: Alert notifications are sent by using emails and DingTalk chatbots.
   * 
   * @example
   * 0
   */
  notifyType?: number;
  /**
   * @remarks
   * The mute period during which new alerts are not sent even if the trigger conditions are met. Unit: seconds. Default value: 86400.
   * 
   * @example
   * 86400
   */
  silenceTime?: number;
  /**
   * @remarks
   * The beginning of the time period during which the alert rule is effective. Valid values: 0 to 23.
   * 
   * For example, if the `AlertConfig.StartTime` parameter is set to 0 and the `AlertConfig.EndTime` parameter is set to 22, the alert rule is effective from 00:00:00 to 22:00:00.
   * 
   * >  Alert notifications are sent based on the specified threshold only if the alert rule is effective.
   * 
   * @example
   * 0
   */
  startTime?: number;
  /**
   * @remarks
   * The monitored resources.
   */
  targetList?: DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfigTargetList;
  /**
   * @remarks
   * The callback URL.
   * 
   * CloudMonitor pushes an alert notification to the specified callback URL by sending an HTTP POST request. Only the HTTP protocol is supported.
   * 
   * @example
   * https://www.aliyun.com
   */
  webHook?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      escalationList: 'EscalationList',
      notifyType: 'NotifyType',
      silenceTime: 'SilenceTime',
      startTime: 'StartTime',
      targetList: 'TargetList',
      webHook: 'WebHook',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      escalationList: DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfigEscalationList,
      notifyType: 'number',
      silenceTime: 'number',
      startTime: 'number',
      targetList: DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfigTargetList,
      webHook: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigInstances extends $tea.Model {
  instance?: string[];
  static names(): { [key: string]: string } {
    return {
      instance: 'Instance',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instance: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigTaskOption extends $tea.Model {
  /**
   * @remarks
   * The response to the HTTP request.
   * 
   * @example
   * OK
   */
  httpKeyword?: string;
  /**
   * @remarks
   * The HTTP request method. Valid values:
   * 
   * *   GET
   * *   POST
   * *   HEAD
   * 
   * @example
   * GET
   */
  httpMethod?: string;
  /**
   * @remarks
   * The method to trigger an alert. The alert can be triggered based on whether the specified alert rule is included in the response body. Valid values:
   * 
   * *   true: If the HTTP response body includes the alert rule, an alert is triggered.
   * *   false: If the HTTP response does not include the alert rule, an alert is triggered.
   * 
   * @example
   * true
   */
  httpNegative?: boolean;
  /**
   * @remarks
   * The content of the HTTP POST request.
   * 
   * @example
   * params1=paramsValue1
   */
  httpPostContent?: string;
  /**
   * @remarks
   * The character set that is used in the HTTP response.
   * 
   * @example
   * UTF-8
   */
  httpResponseCharset?: string;
  /**
   * @remarks
   * The URI that you want to monitor. If the TaskType parameter is set to HTTP, this parameter is required.
   * 
   * @example
   * https://www.aliyun.com
   */
  httpURI?: string;
  /**
   * @remarks
   * The interval at which detection requests are sent. Unit: seconds.
   * 
   * @example
   * 60
   */
  interval?: number;
  /**
   * @remarks
   * The domain name or IP address that you want to monitor.
   * 
   * @example
   * ssh.aliyun.com
   */
  telnetOrPingHost?: string;
  static names(): { [key: string]: string } {
    return {
      httpKeyword: 'HttpKeyword',
      httpMethod: 'HttpMethod',
      httpNegative: 'HttpNegative',
      httpPostContent: 'HttpPostContent',
      httpResponseCharset: 'HttpResponseCharset',
      httpURI: 'HttpURI',
      interval: 'Interval',
      telnetOrPingHost: 'TelnetOrPingHost',
    };
  }

  static types(): { [key: string]: any } {
    return {
      httpKeyword: 'string',
      httpMethod: 'string',
      httpNegative: 'boolean',
      httpPostContent: 'string',
      httpResponseCharset: 'string',
      httpURI: 'string',
      interval: 'number',
      telnetOrPingHost: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfig extends $tea.Model {
  /**
   * @remarks
   * The configurations of the alert rule.
   */
  alertConfig?: DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfig;
  /**
   * @remarks
   * Indicates whether the availability monitoring task is disabled. Valid values:
   * 
   * *   true: The availability monitoring task is disabled.
   * *   false: The availability monitoring task is enabled.
   * 
   * @example
   * false
   */
  disabled?: boolean;
  /**
   * @remarks
   * The ID of the application group.
   * 
   * @example
   * 12345
   */
  groupId?: number;
  /**
   * @remarks
   * The name of the application group.
   * 
   * @example
   * Group_ECS
   */
  groupName?: string;
  /**
   * @remarks
   * The ID of the availability monitoring task.
   * 
   * @example
   * 123456
   */
  id?: number;
  /**
   * @remarks
   * The ECS instances that are monitored.
   */
  instances?: DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigInstances;
  /**
   * @remarks
   * The name of the availability monitoring task.
   * 
   * @example
   * ecs_instance
   */
  taskName?: string;
  /**
   * @remarks
   * The optional parameters of the availability monitoring task.
   */
  taskOption?: DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigTaskOption;
  /**
   * @remarks
   * The range of instances that are monitored by the availability monitoring task. Valid values:
   * 
   * *   GROUP: All ECS instances in the application group are monitored.
   * *   GROUP_SPEC_INSTANCE: Specified ECS instances in the application group are monitored.
   * 
   * @example
   * GROUP
   */
  taskScope?: string;
  /**
   * @remarks
   * The task type. Valid values:
   * 
   * *   PING
   * *   TELNET
   * *   HTTP
   * 
   * @example
   * HTTP
   */
  taskType?: string;
  static names(): { [key: string]: string } {
    return {
      alertConfig: 'AlertConfig',
      disabled: 'Disabled',
      groupId: 'GroupId',
      groupName: 'GroupName',
      id: 'Id',
      instances: 'Instances',
      taskName: 'TaskName',
      taskOption: 'TaskOption',
      taskScope: 'TaskScope',
      taskType: 'TaskType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertConfig: DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfig,
      disabled: 'boolean',
      groupId: 'number',
      groupName: 'string',
      id: 'number',
      instances: DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigInstances,
      taskName: 'string',
      taskOption: DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigTaskOption,
      taskScope: 'string',
      taskType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHostAvailabilityListResponseBodyTaskList extends $tea.Model {
  nodeTaskConfig?: DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfig[];
  static names(): { [key: string]: string } {
    return {
      nodeTaskConfig: 'NodeTaskConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeTaskConfig: { 'type': 'array', 'itemType': DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfig },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHybridMonitorDataListResponseBodyTimeSeriesLabels extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * instanceId
   */
  k?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * i-rj99xc6cptkk64ml****
   */
  v?: string;
  static names(): { [key: string]: string } {
    return {
      k: 'K',
      v: 'V',
    };
  }

  static types(): { [key: string]: any } {
    return {
      k: 'string',
      v: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHybridMonitorDataListResponseBodyTimeSeriesValues extends $tea.Model {
  /**
   * @remarks
   * The timestamp that indicates the time when the metric value is collected.
   * 
   * Unit: seconds.
   * 
   * @example
   * 1653804865
   */
  ts?: string;
  /**
   * @remarks
   * The metric value.
   * 
   * @example
   * 0.13
   */
  v?: string;
  static names(): { [key: string]: string } {
    return {
      ts: 'Ts',
      v: 'V',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ts: 'string',
      v: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHybridMonitorDataListResponseBodyTimeSeries extends $tea.Model {
  /**
   * @remarks
   * The tags of the time dimension.
   */
  labels?: DescribeHybridMonitorDataListResponseBodyTimeSeriesLabels[];
  /**
   * @remarks
   * The metric name.
   * 
   * @example
   * AliyunEcs_cpu_total
   */
  metricName?: string;
  /**
   * @remarks
   * The metric values that are collected at different timestamps.
   */
  values?: DescribeHybridMonitorDataListResponseBodyTimeSeriesValues[];
  static names(): { [key: string]: string } {
    return {
      labels: 'Labels',
      metricName: 'MetricName',
      values: 'Values',
    };
  }

  static types(): { [key: string]: any } {
    return {
      labels: { 'type': 'array', 'itemType': DescribeHybridMonitorDataListResponseBodyTimeSeriesLabels },
      metricName: 'string',
      values: { 'type': 'array', 'itemType': DescribeHybridMonitorDataListResponseBodyTimeSeriesValues },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespaceAliyunProductMetricListNamespaceListMetricList extends $tea.Model {
  /**
   * @remarks
   * The metrics.
   */
  list?: string[];
  /**
   * @remarks
   * The collection period of the metric.
   * 
   * Unit: seconds.
   * 
   * @example
   * 60
   */
  period?: number;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
      period: 'Period',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: { 'type': 'array', 'itemType': 'string' },
      period: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespaceAliyunProductMetricListNamespaceList extends $tea.Model {
  /**
   * @remarks
   * The metrics for the Alibaba Cloud service.
   */
  metricList?: DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespaceAliyunProductMetricListNamespaceListMetricList[];
  /**
   * @remarks
   * The namespace for the Alibaba Cloud service.
   * 
   * @example
   * acs_ecs_dashboard
   */
  namespace?: string;
  static names(): { [key: string]: string } {
    return {
      metricList: 'MetricList',
      namespace: 'Namespace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      metricList: { 'type': 'array', 'itemType': DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespaceAliyunProductMetricListNamespaceListMetricList },
      namespace: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespaceAliyunProductMetricList extends $tea.Model {
  /**
   * @remarks
   * The namespaces.
   */
  namespaceList?: DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespaceAliyunProductMetricListNamespaceList[];
  /**
   * @remarks
   * The account that is used to create the namespace.
   * 
   * @example
   * 120886317861****
   */
  userId?: number;
  /**
   * @remarks
   * The configuration file of the Alibaba Cloud service that you want to monitor by using Hybrid Cloud Monitoring.
   * 
   * *   namespace: the namespace of the Alibaba Cloud service.
   * *   metric_list: the metrics of the Alibaba Cloud service.
   * *   dimension: the resources of the Alibaba Cloud service that you want to monitor by using Hybrid Cloud Monitoring. If you do not specify a dimension, all resources of the Alibaba Cloud service are monitored.
   * 
   * @example
   * products:- namespace: acs_ecs_dashboard metric_info: - metric_list: - cpu_total dimension: \\"\\"
   */
  YAMLConfig?: string;
  static names(): { [key: string]: string } {
    return {
      namespaceList: 'NamespaceList',
      userId: 'UserId',
      YAMLConfig: 'YAMLConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      namespaceList: { 'type': 'array', 'itemType': DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespaceAliyunProductMetricListNamespaceList },
      userId: 'number',
      YAMLConfig: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespaceDetail extends $tea.Model {
  /**
   * @remarks
   * The region where the metric data is stored.
   * 
   * >  This parameter is returned if you select `m_prom_user` for `NamespaceType` when you create a namespace.
   * 
   * @example
   * cn-hangzhou
   */
  namespaceRegion?: string;
  /**
   * @remarks
   * The project where the metric data is located.
   * 
   * >  This parameter is returned if you select `m_prom_user` for `NamespaceType` when you create a namespace.
   * 
   * @example
   * cms-hybrid-120886317861****-cn-hangzhou-a83d
   */
  SLSProject?: string;
  /**
   * @remarks
   * The data retention period. Valid values:
   * 
   * *   cms.s1.large (Retention Period 15 Days)
   * *   cms.s1.xlarge (Retention Period 32 Days)
   * *   cms.s1.2xlarge (Retention Period 63 Days)
   * *   cms.s1.3xlarge (Retention Period 93 Days)
   * *   cms.s1.6xlarge (Retention Period 185 Days)
   * *   cms.s1.12xlarge (Retention Period 367 Days)
   * 
   * @example
   * cms.s1.3xlarge
   */
  spec?: string;
  static names(): { [key: string]: string } {
    return {
      namespaceRegion: 'NamespaceRegion',
      SLSProject: 'SLSProject',
      spec: 'Spec',
    };
  }

  static types(): { [key: string]: any } {
    return {
      namespaceRegion: 'string',
      SLSProject: 'string',
      spec: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespace extends $tea.Model {
  /**
   * @remarks
   * The configuration details of metric import tasks for Alibaba Cloud services.
   */
  aliyunProductMetricList?: DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespaceAliyunProductMetricList[];
  /**
   * @remarks
   * The timestamp that was generated when the namespace was created.
   * 
   * Unit: milliseconds.
   * 
   * @example
   * 1652682744000
   */
  createTime?: string;
  /**
   * @remarks
   * The description of the namespace.
   * 
   * @example
   * aliyun-test
   */
  description?: string;
  /**
   * @remarks
   * The details of the data retention period.
   */
  detail?: DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespaceDetail;
  /**
   * @remarks
   * The ID of the namespace.
   * 
   * @example
   * 3****
   */
  id?: string;
  /**
   * @remarks
   * Indicates whether the namespace is deleted. Valid values:
   * 
   * *   0: The namespace is not deleted.
   * *   1: The namespace is deleted.
   * 
   * @example
   * 0
   */
  isDelete?: number;
  /**
   * @remarks
   * The timestamp that was generated when the namespace was last modified.
   * 
   * @example
   * 1652682744000
   */
  modifyTime?: string;
  /**
   * @remarks
   * The name of the namespace.
   * 
   * @example
   * aliyun-test
   */
  namespace?: string;
  /**
   * @remarks
   * The storage scheme of metric data. Valid values:
   * 
   * *   m_prom_user: The metric data is stored in Simple Log Service.
   * *   m_prom_pool: The metric data is stored in the storage space provided by CloudMonitor.
   * 
   * @example
   * m_prom_user
   */
  namespaceType?: string;
  /**
   * @remarks
   * The number of metric import tasks for third-party services.
   * 
   * @example
   * 0
   */
  notAliyunTaskNumber?: number;
  static names(): { [key: string]: string } {
    return {
      aliyunProductMetricList: 'AliyunProductMetricList',
      createTime: 'CreateTime',
      description: 'Description',
      detail: 'Detail',
      id: 'Id',
      isDelete: 'IsDelete',
      modifyTime: 'ModifyTime',
      namespace: 'Namespace',
      namespaceType: 'NamespaceType',
      notAliyunTaskNumber: 'NotAliyunTaskNumber',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunProductMetricList: { 'type': 'array', 'itemType': DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespaceAliyunProductMetricList },
      createTime: 'string',
      description: 'string',
      detail: DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespaceDetail,
      id: 'string',
      isDelete: 'number',
      modifyTime: 'string',
      namespace: 'string',
      namespaceType: 'string',
      notAliyunTaskNumber: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHybridMonitorSLSGroupResponseBodyListSLSGroupConfig extends $tea.Model {
  /**
   * @remarks
   * The Logstore.
   * 
   * @example
   * Logstore-aliyun-all
   */
  SLSLogstore?: string;
  /**
   * @remarks
   * The Simple Log Service project.
   * 
   * @example
   * aliyun-project
   */
  SLSProject?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  SLSRegion?: string;
  /**
   * @remarks
   * The member ID.
   * 
   * **Description** This parameter is returned when you call the operation by using an administrative account.
   * 
   * @example
   * 120886317861****
   */
  SLSUserId?: string;
  static names(): { [key: string]: string } {
    return {
      SLSLogstore: 'SLSLogstore',
      SLSProject: 'SLSProject',
      SLSRegion: 'SLSRegion',
      SLSUserId: 'SLSUserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      SLSLogstore: 'string',
      SLSProject: 'string',
      SLSRegion: 'string',
      SLSUserId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHybridMonitorSLSGroupResponseBodyList extends $tea.Model {
  /**
   * @remarks
   * The time when the Logstore group was created.
   * 
   * Unit: milliseconds.
   * 
   * @example
   * 1652845630000
   */
  createTime?: string;
  /**
   * @remarks
   * The configurations of the Logstore group.
   */
  SLSGroupConfig?: DescribeHybridMonitorSLSGroupResponseBodyListSLSGroupConfig[];
  /**
   * @remarks
   * The description of the Logstore group.
   */
  SLSGroupDescription?: string;
  /**
   * @remarks
   * The name of the Logstore group.
   * 
   * @example
   * Logstore_test
   */
  SLSGroupName?: string;
  /**
   * @remarks
   * The time when the Logstore group was modified.
   * 
   * Unit: milliseconds.
   * 
   * @example
   * 1652845630000
   */
  updateTime?: string;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      SLSGroupConfig: 'SLSGroupConfig',
      SLSGroupDescription: 'SLSGroupDescription',
      SLSGroupName: 'SLSGroupName',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'string',
      SLSGroupConfig: { 'type': 'array', 'itemType': DescribeHybridMonitorSLSGroupResponseBodyListSLSGroupConfig },
      SLSGroupDescription: 'string',
      SLSGroupName: 'string',
      updateTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHybridMonitorTaskListResponseBodyTaskListAttachLabels extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * key1
   */
  name?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * value1
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHybridMonitorTaskListResponseBodyTaskListMatchExpress extends $tea.Model {
  /**
   * @remarks
   * The method that is used to match the instance name. Valid values:
   * 
   * *   startWith: starts with a prefix
   * *   endWith: ends with a suffix
   * *   all: matches all
   * *   equals: equals
   * *   contains: contains
   * *   notContains: does not contain
   * 
   * @example
   * all
   */
  function?: string;
  /**
   * @remarks
   * The instance name.
   * 
   * @example
   * name
   */
  name?: string;
  /**
   * @remarks
   * The keyword that corresponds to the instance name.
   * 
   * @example
   * ECS_instance1
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      function: 'Function',
      name: 'Name',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      function: 'string',
      name: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigExpress extends $tea.Model {
  /**
   * @remarks
   * The alias of the extended field that indicates the result of basic operations that are performed on aggregation results.
   * 
   * @example
   * SuccRate
   */
  alias?: string;
  /**
   * @remarks
   * The extended field that indicates the result of basic operations that are performed on aggregation results.
   * 
   * @example
   * success_count
   */
  express?: string;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      express: 'Express',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      express: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigFilterFilters extends $tea.Model {
  /**
   * @remarks
   * The method that is used to filter logs imported from Log Service. Valid values:
   * 
   * *   `contain`: contains
   * *   `notContain`: does not contain
   * *   `>`: greater than
   * *   `<`: less than
   * *   `=`: equal to
   * *   `! =`: not equal to
   * *   `>=`: greater than or equal to
   * *   `<=`: less than or equal to
   * 
   * @example
   * =
   */
  operator?: string;
  /**
   * @remarks
   * The name of the key that is used to filter logs imported from Log Service.
   * 
   * @example
   * host
   */
  SLSKeyName?: string;
  /**
   * @remarks
   * The value of the key that is used to filter logs imported from Log Service.
   * 
   * @example
   * 200
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      operator: 'Operator',
      SLSKeyName: 'SLSKeyName',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      operator: 'string',
      SLSKeyName: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigFilter extends $tea.Model {
  /**
   * @remarks
   * The conditions that are used to filter logs imported from Log Service.
   */
  filters?: DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigFilterFilters[];
  /**
   * @remarks
   * The relationship between multiple filter conditions. Valid values:
   * 
   * *   and (default): Logs are processed only if all filter conditions are met.
   * *   or: Logs are processed if one of the filter conditions is met.
   * 
   * @example
   * and
   */
  relation?: string;
  static names(): { [key: string]: string } {
    return {
      filters: 'Filters',
      relation: 'Relation',
    };
  }

  static types(): { [key: string]: any } {
    return {
      filters: { 'type': 'array', 'itemType': DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigFilterFilters },
      relation: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigGroupBy extends $tea.Model {
  /**
   * @remarks
   * The alias of the aggregation result.
   * 
   * @example
   * ApiResult
   */
  alias?: string;
  /**
   * @remarks
   * The name of the key that is used to aggregate logs imported from Log Service.
   * 
   * @example
   * code
   */
  SLSKeyName?: string;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      SLSKeyName: 'SLSKeyName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      SLSKeyName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigStatistics extends $tea.Model {
  /**
   * @remarks
   * The alias of the aggregation result.
   * 
   * @example
   * level_count
   */
  alias?: string;
  /**
   * @remarks
   * The function that is used to aggregate log data within a statistical period. Valid values:
   * 
   * *   count: counts the number.
   * *   sum: calculates the total value.
   * *   avg: calculates the average value.
   * *   max: calculates the maximum value.
   * *   min: calculates the minimum value.
   * *   value: collects samples within the statistical period.
   * *   countps: calculates the average number of the specified field per second by using the following formula: Counted number of the specified field/Total number of seconds within the statistical period.
   * *   sumps: calculates the average number of the specified field per second by using the following formula: Total value of the specified field/Total number of seconds within the statistical period.
   * *   distinct: counts the number of logs where the specified field appears within the statistical period.
   * *   distribution: counts the number of logs that meet a specified condition within the statistical period.
   * *   percentile: sorts the values of the specified field in ascending order, and then returns the value that is at the specified percentile within the statistical period. Example: P50.
   * 
   * @example
   * count
   */
  function?: string;
  /**
   * @remarks
   * The value of the function that is used to aggregate logs imported from Log Service.
   * 
   * *   If the `Function` parameter is set to `distribution`, this parameter indicates the lower limit of the statistical interval. For example, 200 indicates that the number of HTTP requests whose status code is 2XX is calculated.
   * *   If the `Function` parameter is set to `percentile`, this parameter specifies the percentile at which the expected value is. For example, 0.5 specifies P50.
   * 
   * @example
   * 200
   */
  parameter1?: string;
  /**
   * @remarks
   * The value of the function that is used to aggregate logs imported from Log Service.
   * 
   * > This parameter is returned only if the `Function` parameter is set to `distribution`. This parameter indicates the upper limit of the statistical interval. For example, 299 indicates that the number of HTTP requests whose status code is 2XX is calculated.
   * 
   * @example
   * 299
   */
  parameter2?: string;
  /**
   * @remarks
   * The name of the key that is used to aggregate logs imported from Log Service.
   * 
   * @example
   * name
   */
  SLSKeyName?: string;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      function: 'Function',
      parameter1: 'Parameter1',
      parameter2: 'Parameter2',
      SLSKeyName: 'SLSKeyName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      function: 'string',
      parameter1: 'string',
      parameter2: 'string',
      SLSKeyName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfig extends $tea.Model {
  /**
   * @remarks
   * The extended fields that indicate the results of basic operations that are performed on aggregation results.
   */
  express?: DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigExpress[];
  /**
   * @remarks
   * The conditions that are used to filter logs imported from Log Service.
   */
  filter?: DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigFilter;
  /**
   * @remarks
   * The dimensions based on which data is aggregated. This parameter is equivalent to the GROUP BY clause in SQL.
   */
  groupBy?: DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigGroupBy[];
  /**
   * @remarks
   * The methods that are used to aggregate logs imported from Log Service.
   */
  statistics?: DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigStatistics[];
  static names(): { [key: string]: string } {
    return {
      express: 'Express',
      filter: 'Filter',
      groupBy: 'GroupBy',
      statistics: 'Statistics',
    };
  }

  static types(): { [key: string]: any } {
    return {
      express: { 'type': 'array', 'itemType': DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigExpress },
      filter: DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigFilter,
      groupBy: { 'type': 'array', 'itemType': DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigGroupBy },
      statistics: { 'type': 'array', 'itemType': DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigStatistics },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHybridMonitorTaskListResponseBodyTaskList extends $tea.Model {
  /**
   * @remarks
   * The tags of the metric import task.
   */
  attachLabels?: DescribeHybridMonitorTaskListResponseBodyTaskListAttachLabels[];
  /**
   * @remarks
   * The interval at which the CloudMonitor agent collects host monitoring data. Valid values:
   * 
   * *   15
   * *   30
   * *   60
   * 
   * Unit: seconds.
   * 
   * @example
   * 60
   */
  collectInterval?: number;
  /**
   * @remarks
   * The URL of the destination from which the CloudMonitor agent collects host monitoring data.
   * 
   * @example
   * http://localhost
   */
  collectTargetEndpoint?: string;
  /**
   * @remarks
   * The relative path from which the CloudMonitor agent collects monitoring data.
   * 
   * @example
   * /metrics
   */
  collectTargetPath?: string;
  /**
   * @remarks
   * The type of the monitoring data. Valid values: Spring, Tomcat, Nginx, Tengine, JVM, Redis, and MySQL.
   * 
   * @example
   * nginx
   */
  collectTargetType?: string;
  /**
   * @remarks
   * The timeout period during which the CloudMonitor agent collects host monitoring data. Valid values:
   * 
   * *   0
   * *   15
   * *   30
   * *   60
   * 
   * Unit: seconds.
   * 
   * @example
   * 15
   */
  collectTimout?: number;
  /**
   * @remarks
   * The timestamp when the metric import task was created.
   * 
   * Unit: milliseconds.
   * 
   * @example
   * 1639382496000
   */
  createTime?: string;
  /**
   * @remarks
   * The description of the metric import task.
   * 
   * @example
   * aliyun
   */
  description?: string;
  /**
   * @remarks
   * The additional information of the instance.
   * 
   * @example
   * test
   */
  extraInfo?: string;
  /**
   * @remarks
   * The ID of the application group.
   * 
   * @example
   * 3607****
   */
  groupId?: string;
  /**
   * @remarks
   * The instances where monitoring data is collected in batches.
   */
  instances?: string[];
  /**
   * @example
   * C:\\UserData\\log\\*.Log
   */
  logFilePath?: string;
  /**
   * @remarks
   * The method that is used to aggregate on-premises log data.
   * 
   * @example
   * [{"metric": "metric1","filters": [{"column": "filed2","type": "include","values": ["222222"]}],"groupBys": [{"column": "filed3","name": "filed3"}],"calculates": [{"column": "field1","name": "avg","type": "avg"}]},{"metric": "metric2","filters": [{"column": "field1","type": "include","values": ["11111"]}],"groupBys": [{"column": "filed2","name": "filed2"}],"calculates": [{"column": "field1","name": "avg","type": "avg"}]}]
   */
  logProcess?: string;
  /**
   * @remarks
   * The sample on-premises log.
   * 
   * @example
   * {"logContent":"100.116.134.26 1119 - [13/Aug/2019:16:55:46 +0800] POST metrichub-cn-hongkong.aliyun.com /agent/metrics/putLines 200 0 \\"-\\" \\"127.0.0.1:7001\\" \\"Go-http-client/1.1\\" \\"-\\" \\"-\\" \\"0a98a21a15656865460656276e\\"","addData":{"field1":["1119","1119"],"filed2":["POSTx","POST"],"filed3":["true","200"]}}
   */
  logSample?: string;
  /**
   * @remarks
   * The result that is returned after on-premises log data is split based on the specified matching mode.
   * 
   * > The matching modes of on-premises log data include full regex mode, delimiter mode, and JSON mode.
   * 
   * @example
   * {"type": "regex","regex": "\\\\d+\\\\.\\\\d+\\\\.\\\\d+\\\\.\\\\d+\\\\s+(\\\\d+)\\\\s+\\\\S+\\\\s+\[\\\\d+/\\\\S+/\\\\d+:\\\\d+:\\\\d+:\\\\d+\\\\s+\\\\+\\\\d+\\\\]\\\\s+(\\\\S+)\\\\s+\\\\S+\\\\s+/\\\\S+/\\\\S+/\\\\S+\\\\s+(\\\\d+)","columns": [{"name": "field1"},{"name": "filed2","translate": {"default": "-","mappings": [{"from": "(\\\\w+)","to": "$1x","type": "regex"}]}},{"name": "filed3","translate": {"default": "-","mappings": [{"from": "NumberRange(100,300)","to": "true","type": "function"}]}}]}
   */
  logSplit?: string;
  /**
   * @remarks
   * The conditions that are used to match the instances in the application group.
   */
  matchExpress?: DescribeHybridMonitorTaskListResponseBodyTaskListMatchExpress[];
  /**
   * @remarks
   * The relationship between the conditions that are used to filter metric import tasks. Valid values:
   * 
   * *   or
   * *   and
   * 
   * @example
   * or
   */
  matchExpressRelation?: string;
  /**
   * @remarks
   * The namespace to which the host belongs.
   * 
   * @example
   * aliyun
   */
  namespace?: string;
  /**
   * @remarks
   * The network type of the host. Valid values:
   * 
   * *   `vpc`
   * *   `Internet`
   * 
   * @example
   * vpc
   */
  networkType?: string;
  /**
   * @remarks
   * The configurations of the logs that are imported from Log Service.
   * 
   * @example
   * {"express": [],"filter": {"filters": [{"key": "task_type","operator": "=","value": "1"}]},"groupby": [{"alias": "isp","key": "isp","sqlKey": "t.`isp`","valueKey": "isp"}],"interval": 60,"labels": [{"name": "__cms_app__","type": 0,"value": "sitemonitor"}],"statistics": [{"alias": "http_dns_time_avg","function": "avg","key": "http_dns_time"}]}
   */
  SLSProcess?: string;
  /**
   * @remarks
   * The configurations of the logs that are imported from Log Service.
   * 
   * > This parameter is returned only if the `TaskType` parameter is set to `aliyun_sls`.
   */
  SLSProcessConfig?: DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfig;
  /**
   * @remarks
   * The ID of the member account.
   * 
   * > This parameter is displayed only when you call this operation by using a management account.
   * 
   * @example
   * 120886317861****
   */
  targetUserId?: string;
  /**
   * @remarks
   * The ID of the metric import task.
   * 
   * @example
   * 36****
   */
  taskId?: string;
  /**
   * @remarks
   * The name of the metric import task.
   * 
   * @example
   * aliyun_task
   */
  taskName?: string;
  /**
   * @remarks
   * The type of the metric import task. Valid values:
   * 
   * *   aliyun_fc: metric import tasks for Alibaba Cloud services
   * *   aliyun_sls: metrics for logs imported from Log Service
   * 
   * @example
   * aliyun_sls
   */
  taskType?: string;
  /**
   * @remarks
   * The region where the host resides.
   * 
   * @example
   * cn-hangzhou
   */
  uploadRegion?: string;
  /**
   * @remarks
   * The configuration file of the Alibaba Cloud service that you want to monitor by using Hybrid Cloud Monitoring.
   * 
   * *   namespace: the namespace of the Alibaba Cloud service.
   * *   metric_list: the metrics of the Alibaba Cloud service.
   * 
   * @example
   * products:- namespace: acs_ecs_dashboard metric_info: - metric_list: - cpu_total
   */
  YARMConfig?: string;
  static names(): { [key: string]: string } {
    return {
      attachLabels: 'AttachLabels',
      collectInterval: 'CollectInterval',
      collectTargetEndpoint: 'CollectTargetEndpoint',
      collectTargetPath: 'CollectTargetPath',
      collectTargetType: 'CollectTargetType',
      collectTimout: 'CollectTimout',
      createTime: 'CreateTime',
      description: 'Description',
      extraInfo: 'ExtraInfo',
      groupId: 'GroupId',
      instances: 'Instances',
      logFilePath: 'LogFilePath',
      logProcess: 'LogProcess',
      logSample: 'LogSample',
      logSplit: 'LogSplit',
      matchExpress: 'MatchExpress',
      matchExpressRelation: 'MatchExpressRelation',
      namespace: 'Namespace',
      networkType: 'NetworkType',
      SLSProcess: 'SLSProcess',
      SLSProcessConfig: 'SLSProcessConfig',
      targetUserId: 'TargetUserId',
      taskId: 'TaskId',
      taskName: 'TaskName',
      taskType: 'TaskType',
      uploadRegion: 'UploadRegion',
      YARMConfig: 'YARMConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attachLabels: { 'type': 'array', 'itemType': DescribeHybridMonitorTaskListResponseBodyTaskListAttachLabels },
      collectInterval: 'number',
      collectTargetEndpoint: 'string',
      collectTargetPath: 'string',
      collectTargetType: 'string',
      collectTimout: 'number',
      createTime: 'string',
      description: 'string',
      extraInfo: 'string',
      groupId: 'string',
      instances: { 'type': 'array', 'itemType': 'string' },
      logFilePath: 'string',
      logProcess: 'string',
      logSample: 'string',
      logSplit: 'string',
      matchExpress: { 'type': 'array', 'itemType': DescribeHybridMonitorTaskListResponseBodyTaskListMatchExpress },
      matchExpressRelation: 'string',
      namespace: 'string',
      networkType: 'string',
      SLSProcess: 'string',
      SLSProcessConfig: DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfig,
      targetUserId: 'string',
      taskId: 'string',
      taskName: 'string',
      taskType: 'string',
      uploadRegion: 'string',
      YARMConfig: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLogMonitorAttributeResponseBodyLogMonitorAggregates extends $tea.Model {
  /**
   * @remarks
   * The alias of the aggregate function.
   * 
   * @example
   * HostName
   */
  alias?: string;
  /**
   * @remarks
   * The name of the field in logs.
   * 
   * @example
   * hostName
   */
  fieldName?: string;
  /**
   * @remarks
   * The function that is used to aggregate the monitoring data of logs within an aggregation period. Valid values:
   * 
   * *   count: counts the number.
   * *   sum: calculates the total value.
   * *   avg: calculates the average value.
   * *   max: selects the maximum value.
   * *   min: selects the minimum value.
   * *   countps: calculates the counted number of the specified field divided by the total number of seconds of the aggregation period.
   * *   sumps: calculates the total value of the specified field divided by the total number of seconds of the aggregation period.
   * *   distinct: counts the number of logs where the specified field appears within the aggregation period.
   * 
   * @example
   * count
   */
  function?: string;
  /**
   * @remarks
   * The maximum value.
   * 
   * @example
   * 10
   */
  max?: string;
  /**
   * @remarks
   * The minimum value.
   * 
   * @example
   * 0
   */
  min?: string;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      fieldName: 'FieldName',
      function: 'Function',
      max: 'Max',
      min: 'Min',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      fieldName: 'string',
      function: 'string',
      max: 'string',
      min: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLogMonitorAttributeResponseBodyLogMonitorValueFilter extends $tea.Model {
  /**
   * @remarks
   * The name of the log field used for matching in the filter condition.
   * 
   * @example
   * hostName
   */
  key?: string;
  /**
   * @remarks
   * The method that is used to match the field value. Valid values:
   * 
   * *   `contain`
   * *   `notContain`
   * *   `>`: greater than
   * *   `<`: less than
   * *   `>=`: greater than or equal to
   * *   `<=`: less than or equal to
   * 
   * @example
   * contain
   */
  operator?: string;
  /**
   * @remarks
   * The field value to be matched in the filter condition.
   * 
   * @example
   * portal
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      operator: 'Operator',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      operator: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLogMonitorAttributeResponseBodyLogMonitor extends $tea.Model {
  /**
   * @remarks
   * The aggregate functions.
   */
  aggregates?: DescribeLogMonitorAttributeResponseBodyLogMonitorAggregates[];
  /**
   * @remarks
   * The time when the log monitoring metric was created.
   * 
   * This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
   * 
   * @example
   * 1547431398000
   */
  gmtCreate?: number;
  /**
   * @remarks
   * The ID of the application group.
   * 
   * @example
   * 12345
   */
  groupId?: number;
  /**
   * @remarks
   * The dimension based on which the data is grouped. This parameter is equivalent to the GROUP BY clause in SQL statements. If no dimension is specified, all data is aggregated based on the aggregate function.
   */
  groupbys?: string[];
  /**
   * @remarks
   * The ID returned by Log Service.
   * 
   * @example
   * 1234
   */
  logId?: number;
  /**
   * @remarks
   * The extended field. The extended field allows you to perform basic operations on the aggregation results.
   * 
   * Assume that you have calculated TotalNumber and 5XXNumber by aggregating the data. TotalNumber indicates the total number of HTTP requests, and 5XXNumber indicates the number of HTTP requests whose status code is greater than 499. You can calculate the server error rate by adding the following formula to the extended field: 5XXNumber/TotalNumber\\*100.
   * 
   * @example
   * {"extend":{"errorPercent":"5XXNumber/TotalNumber*100"}}
   */
  metricExpress?: string;
  /**
   * @remarks
   * The name of the log monitoring metric. For more information, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * @example
   * cpu_total
   */
  metricName?: string;
  /**
   * @remarks
   * The name of the Log Service Logstore.
   * 
   * @example
   * test-logstore
   */
  slsLogstore?: string;
  /**
   * @remarks
   * The name of the Log Service project.
   * 
   * @example
   * test-project
   */
  slsProject?: string;
  /**
   * @remarks
   * The ID of the region where the Log Service Logstore resides.
   * 
   * @example
   * cn-hangzhou
   */
  slsRegionId?: string;
  /**
   * @remarks
   * The size of the tumbling window for calculation. Unit: seconds. The system performs an aggregation for each tumbling window.
   */
  tumblingwindows?: string[];
  /**
   * @remarks
   * The condition that is used to filter logs. The ValueFilter and ValueFilterRelation parameters are used in pair. The filter condition is equivalent to the WHERE clause in SQL statements.
   * 
   * If no filter condition is specified, all logs are processed. Assume that logs contain the Level field, which may be set to Error. If you need to calculate the number of times that logs of the Error level appear every minute, you can set the filter condition to Level=Error and count the number of logs that meet this condition.
   */
  valueFilter?: DescribeLogMonitorAttributeResponseBodyLogMonitorValueFilter[];
  /**
   * @remarks
   * The logical operator that is used between log filter conditions. The ValueFilter and ValueFilterRelation parameters are used in pair. Valid values:
   * 
   * *   and
   * *   or
   * 
   * @example
   * and
   */
  valueFilterRelation?: string;
  static names(): { [key: string]: string } {
    return {
      aggregates: 'Aggregates',
      gmtCreate: 'GmtCreate',
      groupId: 'GroupId',
      groupbys: 'Groupbys',
      logId: 'LogId',
      metricExpress: 'MetricExpress',
      metricName: 'MetricName',
      slsLogstore: 'SlsLogstore',
      slsProject: 'SlsProject',
      slsRegionId: 'SlsRegionId',
      tumblingwindows: 'Tumblingwindows',
      valueFilter: 'ValueFilter',
      valueFilterRelation: 'ValueFilterRelation',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aggregates: { 'type': 'array', 'itemType': DescribeLogMonitorAttributeResponseBodyLogMonitorAggregates },
      gmtCreate: 'number',
      groupId: 'number',
      groupbys: { 'type': 'array', 'itemType': 'string' },
      logId: 'number',
      metricExpress: 'string',
      metricName: 'string',
      slsLogstore: 'string',
      slsProject: 'string',
      slsRegionId: 'string',
      tumblingwindows: { 'type': 'array', 'itemType': 'string' },
      valueFilter: { 'type': 'array', 'itemType': DescribeLogMonitorAttributeResponseBodyLogMonitorValueFilter },
      valueFilterRelation: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLogMonitorListResponseBodyLogMonitorListValueFilter extends $tea.Model {
  /**
   * @remarks
   * The name of the log field used for matching in the filter condition.
   * 
   * @example
   * hostName
   */
  key?: string;
  /**
   * @remarks
   * The method that is used to match the field value. Valid values:
   * 
   * *   contain
   * *   notContain
   * *   `>`: greater than
   * *   `<`: less than
   * *   `>=`: greater than or equal to
   * *   `<=`: less than or equal to
   * 
   * @example
   * contain
   */
  operator?: string;
  /**
   * @remarks
   * The field value to be matched in the filter condition.
   * 
   * @example
   * portal
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      operator: 'Operator',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      operator: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLogMonitorListResponseBodyLogMonitorList extends $tea.Model {
  /**
   * @remarks
   * The time when the log monitoring metric was created.
   * 
   * This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
   * 
   * @example
   * 1577766395000
   */
  gmtCreate?: number;
  /**
   * @remarks
   * The ID of the application group.
   * 
   * @example
   * 12345
   */
  groupId?: number;
  /**
   * @remarks
   * The ID returned by Log Service.
   * 
   * @example
   * 12345
   */
  logId?: number;
  /**
   * @remarks
   * The name of the log monitoring metric. For more information, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * @example
   * cpu_total
   */
  metricName?: string;
  /**
   * @remarks
   * The name of the Log Service Logstore.
   * 
   * @example
   * testSlS****
   */
  slsLogstore?: string;
  /**
   * @remarks
   * The name of the Log Service project.
   * 
   * @example
   * sls-project-test****
   */
  slsProject?: string;
  /**
   * @remarks
   * The ID of the region where the Log Service Logstore resides.
   * 
   * @example
   * cn-hangzhou
   */
  slsRegionId?: string;
  /**
   * @remarks
   * The condition that is used to filter logs. The ValueFilter and ValueFilterRelation parameters are used in pair. The filter condition is equivalent to the WHERE clause in SQL statements.
   * 
   * If no filter condition is specified, all logs are processed. Assume that logs contain the Level field, which may be set to Error. If you need to calculate the number of times that logs of the Error level appear every minute, you can set the filter condition to Level=Error and count the number of logs that meet this condition.
   */
  valueFilter?: DescribeLogMonitorListResponseBodyLogMonitorListValueFilter[];
  /**
   * @remarks
   * The logical operator that is used between log filter conditions. The ValueFilter and ValueFilterRelation parameters are used in pair. Valid values:
   * 
   * *   and
   * *   or
   * 
   * @example
   * and
   */
  valueFilterRelation?: string;
  static names(): { [key: string]: string } {
    return {
      gmtCreate: 'GmtCreate',
      groupId: 'GroupId',
      logId: 'LogId',
      metricName: 'MetricName',
      slsLogstore: 'SlsLogstore',
      slsProject: 'SlsProject',
      slsRegionId: 'SlsRegionId',
      valueFilter: 'ValueFilter',
      valueFilterRelation: 'ValueFilterRelation',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gmtCreate: 'number',
      groupId: 'number',
      logId: 'number',
      metricName: 'string',
      slsLogstore: 'string',
      slsProject: 'string',
      slsRegionId: 'string',
      valueFilter: { 'type': 'array', 'itemType': DescribeLogMonitorListResponseBodyLogMonitorListValueFilter },
      valueFilterRelation: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricMetaListResponseBodyResourcesResource extends $tea.Model {
  /**
   * @remarks
   * The metric description.
   * 
   * @example
   * CPUUtilization
   */
  description?: string;
  /**
   * @remarks
   * The monitoring dimensions of the resource. Multiple monitoring dimensions are separated with commas (,).
   * 
   * @example
   * instanceId
   */
  dimensions?: string;
  /**
   * @remarks
   * The tags of the metric, including one or more JSON strings.
   * 
   * Format: `[{"name":"tag key","value":"tag value"}]`. The `name` can be repeated. The following tags are available:
   * 
   * *   metricCategory: the category of the metric.
   * *   alertEnable: indicates whether to report alerts for the metric.
   * *   alertUnit: the unit of the metric in the alerts.
   * *   unitFactor: the factor for metric unit conversion.
   * *   minAlertPeriod: the minimum interval at which the alert is reported.
   * *   productCategory: the category of the service.
   * 
   * @example
   * [{\\"name\\":\\"alertUnit\\",\\"value\\":\\"Bytes\\"},{\\"name\\":\\"minAlertPeriod\\",\\"value\\":\\"60\\"},{\\"name\\":\\"metricCategory\\",\\"value\\":\\"instanceId\\"},{\\"name\\":\\"instanceType\\",\\"value\\":\\"disaster\\"},{\\"name\\":\\"is_alarm\\",\\"value\\":\\"true\\"},{\\"name\\":\\"productCategory\\",\\"value\\":\\"kvstore_old\\"}]
   */
  labels?: string;
  /**
   * @remarks
   * The metric name.
   * 
   * @example
   * CPUUtilization
   */
  metricName?: string;
  /**
   * @remarks
   * The namespace of the cloud service.
   * 
   * @example
   * acs_kvstore
   */
  namespace?: string;
  /**
   * @remarks
   * The statistical periods of the metric. Multiple statistical periods are separated with commas (,).
   * 
   * Unit: seconds.
   * 
   * @example
   * 60,300
   */
  periods?: string;
  /**
   * @remarks
   * The statistical method. Multiple statistical methods are separated with commas (,).
   * 
   * @example
   * Average,Minimum,Maximum
   */
  statistics?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * %
   */
  unit?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      dimensions: 'Dimensions',
      labels: 'Labels',
      metricName: 'MetricName',
      namespace: 'Namespace',
      periods: 'Periods',
      statistics: 'Statistics',
      unit: 'Unit',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      dimensions: 'string',
      labels: 'string',
      metricName: 'string',
      namespace: 'string',
      periods: 'string',
      statistics: 'string',
      unit: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricMetaListResponseBodyResources extends $tea.Model {
  resource?: DescribeMetricMetaListResponseBodyResourcesResource[];
  static names(): { [key: string]: string } {
    return {
      resource: 'Resource',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resource: { 'type': 'array', 'itemType': DescribeMetricMetaListResponseBodyResourcesResource },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricRuleBlackListResponseBodyDescribeMetricRuleBlackListMetrics extends $tea.Model {
  /**
   * @remarks
   * The metric name.
   * 
   * @example
   * disk_utilization
   */
  metricName?: string;
  /**
   * @remarks
   * The extended dimension of the instance. For example, `{"device":"C:"}` specifies that the blacklist policy is applied to all C disks of the specified Elastic Compute Service (ECS) instance.
   * 
   * @example
   * [{"device":"C:"}]
   */
  resource?: string;
  static names(): { [key: string]: string } {
    return {
      metricName: 'MetricName',
      resource: 'Resource',
    };
  }

  static types(): { [key: string]: any } {
    return {
      metricName: 'string',
      resource: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricRuleBlackListResponseBodyDescribeMetricRuleBlackList extends $tea.Model {
  /**
   * @remarks
   * The category of the cloud service. For example, ApsaraDB for Redis includes the following categories: ApsaraDB for Redis (standard architecture), ApsaraDB for Redis (cluster architecture), and ApsaraDB for Redis (read/write splitting architecture). In this case, the valid values of this parameter for ApsaraDB for Redis include `kvstore_standard`, `kvstore_sharding`, and `kvstore_splitrw`.
   * 
   * @example
   * ecs
   */
  category?: string;
  /**
   * @remarks
   * The timestamp when the blacklist policy was created.
   * 
   * Unit: milliseconds.
   * 
   * @example
   * 1665714561000
   */
  createTime?: string;
  /**
   * @remarks
   * The time range within which the blacklist policy is effective.
   * 
   * @example
   * 00:00-23:59
   */
  effectiveTime?: string;
  /**
   * @remarks
   * The timestamp when the blacklist policy started to take effect.
   * 
   * Unit: milliseconds.
   * 
   * @example
   * 1640608200000
   */
  enableEndTime?: number;
  /**
   * @remarks
   * The timestamp when the blacklist policy expired.
   * 
   * Unit: milliseconds.
   * 
   * @example
   * 1640237400000
   */
  enableStartTime?: number;
  /**
   * @remarks
   * The ID of the blacklist policy.
   * 
   * @example
   * 93514c96-ceb8-47d8-8ee3-93b6d98b****
   */
  id?: string;
  /**
   * @remarks
   * The IDs of the instances that belong to the specified cloud service.
   */
  instances?: string[];
  /**
   * @remarks
   * The status of the blacklist policy. Valid values:
   * 
   * *   true: The blacklist policy is enabled.
   * *   false: The blacklist policy is disabled.
   * 
   * @example
   * true
   */
  isEnable?: boolean;
  /**
   * @remarks
   * The metrics of the instance.
   */
  metrics?: DescribeMetricRuleBlackListResponseBodyDescribeMetricRuleBlackListMetrics[];
  /**
   * @remarks
   * The name of the blacklist policy.
   * 
   * @example
   * Blacklist-01
   */
  name?: string;
  /**
   * @remarks
   * The namespace of the cloud service.
   * 
   * @example
   * acs_ecs_dashboard
   */
  namespace?: string;
  /**
   * @remarks
   * The effective scope of the blacklist policy. Valid values:
   * 
   * *   USER: The blacklist policy takes effect only within the current Alibaba Cloud account.
   * *   GROUP: The blacklist policy takes effect only within the specified application group.
   * 
   * @example
   * USER
   */
  scopeType?: string;
  /**
   * @remarks
   * The IDs of the application groups.
   */
  scopeValue?: string[];
  /**
   * @remarks
   * The timestamp when the blacklist policy was modified.
   * 
   * Unit: milliseconds.
   * 
   * @example
   * 1665718373000
   */
  updateTime?: string;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      createTime: 'CreateTime',
      effectiveTime: 'EffectiveTime',
      enableEndTime: 'EnableEndTime',
      enableStartTime: 'EnableStartTime',
      id: 'Id',
      instances: 'Instances',
      isEnable: 'IsEnable',
      metrics: 'Metrics',
      name: 'Name',
      namespace: 'Namespace',
      scopeType: 'ScopeType',
      scopeValue: 'ScopeValue',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      createTime: 'string',
      effectiveTime: 'string',
      enableEndTime: 'number',
      enableStartTime: 'number',
      id: 'string',
      instances: { 'type': 'array', 'itemType': 'string' },
      isEnable: 'boolean',
      metrics: { 'type': 'array', 'itemType': DescribeMetricRuleBlackListResponseBodyDescribeMetricRuleBlackListMetrics },
      name: 'string',
      namespace: 'string',
      scopeType: 'string',
      scopeValue: { 'type': 'array', 'itemType': 'string' },
      updateTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricRuleCountResponseBodyMetricRuleCount extends $tea.Model {
  /**
   * @remarks
   * The number of alert rules with active alerts.
   * 
   * @example
   * 5
   */
  alarm?: number;
  /**
   * @remarks
   * The number of disabled alert rules.
   * 
   * @example
   * 0
   */
  disable?: number;
  /**
   * @remarks
   * The number of alert rules without data.
   * 
   * @example
   * 0
   */
  nodata?: number;
  /**
   * @remarks
   * The number of alert rules without active alerts.
   * 
   * @example
   * 40
   */
  ok?: number;
  /**
   * @remarks
   * The total number of alert rules.
   * 
   * @example
   * 45
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      alarm: 'Alarm',
      disable: 'Disable',
      nodata: 'Nodata',
      ok: 'Ok',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alarm: 'number',
      disable: 'number',
      nodata: 'number',
      ok: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricRuleListResponseBodyAlarmsAlarmCompositeExpressionExpressionListExpressionList extends $tea.Model {
  /**
   * @remarks
   * The operator that is used to compare the metric value with the threshold. Valid values:
   * 
   * *   GreaterThanOrEqualToThreshold: greater than or equal to the threshold
   * *   GreaterThanThreshold: greater than the threshold
   * *   LessThanOrEqualToThreshold: less than or equal to the threshold
   * *   LessThanThreshold: less than the threshold
   * *   NotEqualToThreshold: not equal to the threshold
   * *   GreaterThanYesterday: greater than the metric value at the same time yesterday
   * *   LessThanYesterday: less than the metric value at the same time yesterday
   * *   GreaterThanLastWeek: greater than the metric value at the same time last week
   * *   LessThanLastWeek: less than the metric value at the same time last week
   * *   GreaterThanLastPeriod: greater than the metric value in the last monitoring cycle
   * *   LessThanLastPeriod: less than the metric value in the last monitoring cycle
   * 
   * @example
   * GreaterThanOrEqualToThreshold
   */
  comparisonOperator?: string;
  /**
   * @remarks
   * The metric that is used to monitor the cloud service.
   * 
   * @example
   * cpu_total
   */
  metricName?: string;
  /**
   * @remarks
   * The aggregation period of the metric.
   * 
   * Unit: seconds.
   * 
   * @example
   * 60
   */
  period?: number;
  /**
   * @remarks
   * The statistical method of the metric. Valid values:
   * 
   * *   $Maximum: the maximum value
   * *   $Minimum: the minimum value
   * *   $Average: the average value
   * *   $Availability: the availability rate (usually used for site monitoring)
   * 
   * >  `$` is the prefix of the metric. For information about the Alibaba Cloud services that are supported by CloudMonitor, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * @example
   * $Maximum
   */
  statistics?: string;
  /**
   * @remarks
   * The alert threshold.
   * 
   * @example
   * 90
   */
  threshold?: string;
  static names(): { [key: string]: string } {
    return {
      comparisonOperator: 'ComparisonOperator',
      metricName: 'MetricName',
      period: 'Period',
      statistics: 'Statistics',
      threshold: 'Threshold',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comparisonOperator: 'string',
      metricName: 'string',
      period: 'number',
      statistics: 'string',
      threshold: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricRuleListResponseBodyAlarmsAlarmCompositeExpressionExpressionList extends $tea.Model {
  expressionList?: DescribeMetricRuleListResponseBodyAlarmsAlarmCompositeExpressionExpressionListExpressionList[];
  static names(): { [key: string]: string } {
    return {
      expressionList: 'ExpressionList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      expressionList: { 'type': 'array', 'itemType': DescribeMetricRuleListResponseBodyAlarmsAlarmCompositeExpressionExpressionListExpressionList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricRuleListResponseBodyAlarmsAlarmCompositeExpression extends $tea.Model {
  /**
   * @remarks
   * The trigger conditions that are created in standard mode.
   */
  expressionList?: DescribeMetricRuleListResponseBodyAlarmsAlarmCompositeExpressionExpressionList;
  /**
   * @remarks
   * The relationship between the trigger conditions for multiple metrics. Valid values:
   * 
   * *   `&&`: An alert is triggered only if all metrics meet the trigger conditions. An alert is triggered only if the results of all expressions specified in the ExpressionList parameter are `true`.
   * *   `||`: An alert is triggered if one of the metrics meets the trigger conditions.
   * 
   * @example
   * ||
   */
  expressionListJoin?: string;
  /**
   * @remarks
   * The trigger conditions that are created by using expressions. You can use expressions to create trigger conditions in the following scenarios:
   * 
   * *   Set an alert blacklist for specific resources. For example, if you specify `$instanceId != \\"i-io8kfvcpp7x5****\\" ``&&`` $Average > 50`, no alert is triggered when the `average metric value` of the `i-io8kfvcpp7x5****` instance exceeds 50.
   * *   Set a special alert threshold for a specified instance in the rule. For example, if you specify `$Average > ($instanceId == \\"i-io8kfvcpp7x5****\\"? 80: 50)`, an alert is triggered when the `average metric value` of the `i-io8kfvcpp7x5****` instance exceeds 80 or the `average metric value` of other instances exceeds 50.
   * *   Limit the number of instances whose metric values exceed the threshold. For example, if you specify `count($Average > 20) > 3`, an alert is triggered only when the number of instances whose `average metric value` exceeds 20 exceeds three.
   * 
   * @example
   * $Average > ($instanceId == \\"i-io8kfvcpp7x5****\\"? 80: 50)
   */
  expressionRaw?: string;
  /**
   * @remarks
   * The level of the alert. Valid values:
   * 
   * *   Critical
   * *   Warn
   * *   Info
   * 
   * @example
   * Critical
   */
  level?: string;
  /**
   * @remarks
   * The number of consecutive triggers. If the number of times that the metric values meet the trigger conditions reaches the value of this parameter, CloudMonitor sends alert notifications.
   * 
   * @example
   * 3
   */
  times?: number;
  static names(): { [key: string]: string } {
    return {
      expressionList: 'ExpressionList',
      expressionListJoin: 'ExpressionListJoin',
      expressionRaw: 'ExpressionRaw',
      level: 'Level',
      times: 'Times',
    };
  }

  static types(): { [key: string]: any } {
    return {
      expressionList: DescribeMetricRuleListResponseBodyAlarmsAlarmCompositeExpressionExpressionList,
      expressionListJoin: 'string',
      expressionRaw: 'string',
      level: 'string',
      times: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricRuleListResponseBodyAlarmsAlarmEscalationsCritical extends $tea.Model {
  /**
   * @remarks
   * The comparison operator that is used to compare the metric value with the threshold. Valid values:
   * 
   * *   GreaterThanOrEqualToThreshold: greater than or equal to the threshold
   * *   GreaterThanThreshold: greater than the threshold
   * *   LessThanOrEqualToThreshold: less than or equal to the threshold
   * *   LessThanThreshold: less than the threshold
   * *   NotEqualToThreshold: not equal to the threshold
   * *   GreaterThanYesterday: greater than the metric value at the same time yesterday
   * *   LessThanYesterday: less than the metric value at the same time yesterday
   * *   GreaterThanLastWeek: greater than the metric value at the same time last week
   * *   LessThanLastWeek: less than the metric value at the same time last week
   * *   GreaterThanLastPeriod: greater than the metric value in the last monitoring cycle
   * *   LessThanLastPeriod: less than the metric value in the last monitoring cycle
   * 
   * @example
   * GreaterThanOrEqualToThreshold
   */
  comparisonOperator?: string;
  /**
   * @remarks
   * The additional conditions for triggering Critical-level alerts. The additional conditions take effect when the value of the ComparisonOperator parameter is GreaterThanYesterday, LessThanYesterday, GreaterThanLastWeek, LessThanLastWeek, GreaterThanLastPeriod, or LessThanLastPeriod.
   * 
   * For example, the values of the PreCondition, ComparisonOperator, and Threshold parameters are set to $Average>80, GreaterThanYesterday, and 10, respectively. An alert is triggered only when the average metric value is greater than 80 and 10% greater than the average metric value at the same time yesterday.
   * 
   * >  $Average is a placeholder that consists of `a dollar sign ($) and the statistical method`. CloudMonitor replaces the placeholder with the aggregated value or original value before value comparison.
   * 
   * @example
   * $Average>80
   */
  preCondition?: string;
  /**
   * @remarks
   * The statistical methods for Critical-level alerts.
   * 
   * @example
   * Average
   */
  statistics?: string;
  /**
   * @remarks
   * The threshold for Critical-level alerts.
   * 
   * @example
   * 90
   */
  threshold?: string;
  /**
   * @remarks
   * The consecutive number of times for which the metric value meets the alert condition before a Critical-level alert is triggered.
   * 
   * @example
   * 3
   */
  times?: number;
  static names(): { [key: string]: string } {
    return {
      comparisonOperator: 'ComparisonOperator',
      preCondition: 'PreCondition',
      statistics: 'Statistics',
      threshold: 'Threshold',
      times: 'Times',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comparisonOperator: 'string',
      preCondition: 'string',
      statistics: 'string',
      threshold: 'string',
      times: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricRuleListResponseBodyAlarmsAlarmEscalationsInfo extends $tea.Model {
  /**
   * @remarks
   * The comparison operator that is used to compare the metric value with the threshold. Valid values:
   * 
   * *   GreaterThanOrEqualToThreshold: greater than or equal to the threshold
   * *   GreaterThanThreshold: greater than the threshold
   * *   LessThanOrEqualToThreshold: less than or equal to the threshold
   * *   LessThanThreshold: less than the threshold
   * *   NotEqualToThreshold: not equal to the threshold
   * *   GreaterThanYesterday: greater than the metric value at the same time yesterday
   * *   LessThanYesterday: less than the metric value at the same time yesterday
   * *   GreaterThanLastWeek: greater than the metric value at the same time last week
   * *   LessThanLastWeek: less than the metric value at the same time last week
   * *   GreaterThanLastPeriod: greater than the metric value in the last monitoring cycle
   * *   LessThanLastPeriod: less than the metric value in the last monitoring cycle
   * 
   * @example
   * GreaterThanOrEqualToThreshold
   */
  comparisonOperator?: string;
  /**
   * @remarks
   * The additional conditions for triggering Info-level alerts. The additional conditions take effect when the value of the ComparisonOperator parameter is GreaterThanYesterday, LessThanYesterday, GreaterThanLastWeek, LessThanLastWeek, GreaterThanLastPeriod, or LessThanLastPeriod.
   * 
   * For example, the values of the PreCondition, ComparisonOperator, and Threshold parameters are set to $Average>80, GreaterThanYesterday, and 10, respectively. An alert is triggered only when the average metric value is greater than 80 and 10% greater than the average metric value at the same time yesterday.
   * 
   * >  $Average is a placeholder that consists of `a dollar sign ($) and the statistical method`. CloudMonitor replaces the placeholder with the aggregated value or original value before value comparison.
   * 
   * @example
   * $Average>80
   */
  preCondition?: string;
  /**
   * @remarks
   * The statistical methods for Info-level alerts.
   * 
   * @example
   * Average
   */
  statistics?: string;
  /**
   * @remarks
   * The threshold for Info-level alerts.
   * 
   * @example
   * 90
   */
  threshold?: string;
  /**
   * @remarks
   * The consecutive number of times for which the metric value meets the alert condition before an Info-level alert is triggered.
   * 
   * @example
   * 3
   */
  times?: number;
  static names(): { [key: string]: string } {
    return {
      comparisonOperator: 'ComparisonOperator',
      preCondition: 'PreCondition',
      statistics: 'Statistics',
      threshold: 'Threshold',
      times: 'Times',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comparisonOperator: 'string',
      preCondition: 'string',
      statistics: 'string',
      threshold: 'string',
      times: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricRuleListResponseBodyAlarmsAlarmEscalationsWarn extends $tea.Model {
  /**
   * @remarks
   * The comparison operator that is used to compare the metric value with the threshold. Valid values:
   * 
   * *   GreaterThanOrEqualToThreshold: greater than or equal to the threshold
   * *   GreaterThanThreshold: greater than the threshold
   * *   LessThanOrEqualToThreshold: less than or equal to the threshold
   * *   LessThanThreshold: less than the threshold
   * *   NotEqualToThreshold: not equal to the threshold
   * *   GreaterThanYesterday: greater than the metric value at the same time yesterday
   * *   LessThanYesterday: less than the metric value at the same time yesterday
   * *   GreaterThanLastWeek: greater than the metric value at the same time last week
   * *   LessThanLastWeek: less than the metric value at the same time last week
   * *   GreaterThanLastPeriod: greater than the metric value in the last monitoring cycle
   * *   LessThanLastPeriod: less than the metric value in the last monitoring cycle
   * 
   * @example
   * GreaterThanOrEqualToThreshold
   */
  comparisonOperator?: string;
  /**
   * @remarks
   * The additional conditions for triggering Warn-level alerts. The additional conditions take effect when the value of the ComparisonOperator parameter is GreaterThanYesterday, LessThanYesterday, GreaterThanLastWeek, LessThanLastWeek, GreaterThanLastPeriod, or LessThanLastPeriod.
   * 
   * For example, the values of the PreCondition, ComparisonOperator, and Threshold parameters are set to $Average>80, GreaterThanYesterday, and 10, respectively. An alert is triggered only when the average metric value is greater than 80 and 10% greater than the average metric value at the same time yesterday.
   * 
   * >  $Average is a placeholder that consists of `a dollar sign ($) and the statistical method`. CloudMonitor replaces the placeholder with the aggregated value or original value before value comparison.
   * 
   * @example
   * $Average>80
   */
  preCondition?: string;
  /**
   * @remarks
   * The statistical methods for Warn-level alerts.
   * 
   * @example
   * Average
   */
  statistics?: string;
  /**
   * @remarks
   * The threshold for Warn-level alerts.
   * 
   * @example
   * 90
   */
  threshold?: string;
  /**
   * @remarks
   * The consecutive number of times for which the metric value meets the alert condition before a Warn-level alert is triggered.
   * 
   * @example
   * 3
   */
  times?: number;
  static names(): { [key: string]: string } {
    return {
      comparisonOperator: 'ComparisonOperator',
      preCondition: 'PreCondition',
      statistics: 'Statistics',
      threshold: 'Threshold',
      times: 'Times',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comparisonOperator: 'string',
      preCondition: 'string',
      statistics: 'string',
      threshold: 'string',
      times: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricRuleListResponseBodyAlarmsAlarmEscalations extends $tea.Model {
  /**
   * @remarks
   * The conditions for triggering Critical-level alerts.
   */
  critical?: DescribeMetricRuleListResponseBodyAlarmsAlarmEscalationsCritical;
  /**
   * @remarks
   * The conditions for triggering Info-level alerts.
   */
  info?: DescribeMetricRuleListResponseBodyAlarmsAlarmEscalationsInfo;
  /**
   * @remarks
   * The conditions for triggering Warn-level alerts.
   */
  warn?: DescribeMetricRuleListResponseBodyAlarmsAlarmEscalationsWarn;
  static names(): { [key: string]: string } {
    return {
      critical: 'Critical',
      info: 'Info',
      warn: 'Warn',
    };
  }

  static types(): { [key: string]: any } {
    return {
      critical: DescribeMetricRuleListResponseBodyAlarmsAlarmEscalationsCritical,
      info: DescribeMetricRuleListResponseBodyAlarmsAlarmEscalationsInfo,
      warn: DescribeMetricRuleListResponseBodyAlarmsAlarmEscalationsWarn,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricRuleListResponseBodyAlarmsAlarmLabelsLabels extends $tea.Model {
  /**
   * @remarks
   * The tag key of the alert rule.
   * 
   * @example
   * cmsRuleKey
   */
  key?: string;
  /**
   * @remarks
   * The tag value of the alert rule.
   * 
   * @example
   * cmsRuleValue
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricRuleListResponseBodyAlarmsAlarmLabels extends $tea.Model {
  labels?: DescribeMetricRuleListResponseBodyAlarmsAlarmLabelsLabels[];
  static names(): { [key: string]: string } {
    return {
      labels: 'Labels',
    };
  }

  static types(): { [key: string]: any } {
    return {
      labels: { 'type': 'array', 'itemType': DescribeMetricRuleListResponseBodyAlarmsAlarmLabelsLabels },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricRuleListResponseBodyAlarmsAlarmPrometheusAnnotationsAnnotations extends $tea.Model {
  /**
   * @remarks
   * The key of the annotation.
   * 
   * @example
   * summary
   */
  key?: string;
  /**
   * @remarks
   * The value of the annotation.
   * 
   * @example
   * {{ $labels.instance }} CPU usage above 10% {current value: {{ humanizePercentage $value }} }
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricRuleListResponseBodyAlarmsAlarmPrometheusAnnotations extends $tea.Model {
  annotations?: DescribeMetricRuleListResponseBodyAlarmsAlarmPrometheusAnnotationsAnnotations[];
  static names(): { [key: string]: string } {
    return {
      annotations: 'Annotations',
    };
  }

  static types(): { [key: string]: any } {
    return {
      annotations: { 'type': 'array', 'itemType': DescribeMetricRuleListResponseBodyAlarmsAlarmPrometheusAnnotationsAnnotations },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricRuleListResponseBodyAlarmsAlarmPrometheus extends $tea.Model {
  /**
   * @remarks
   * The annotations of the Prometheus alert rule. When a Prometheus alert is triggered, the system renders the annotated keys and values to help you understand the metrics and alert rule.
   * 
   * >  This parameter is equivalent to the annotations parameter of open source Prometheus.
   */
  annotations?: DescribeMetricRuleListResponseBodyAlarmsAlarmPrometheusAnnotations;
  /**
   * @remarks
   * The level of the alert. Valid values:
   * 
   * *   Critical
   * *   Warn
   * *   Info
   * 
   * @example
   * Critical
   */
  level?: string;
  /**
   * @remarks
   * The PromQL query statement.
   * 
   * >  The data obtained by using the PromQL query statement is the monitoring data. You must include the alert threshold in this statement.
   * 
   * @example
   * CpuUsage{instanceId="xxxx"}[1m]>90
   */
  promQL?: string;
  /**
   * @remarks
   * The number of consecutive triggers. If the number of times that the metric values meet the trigger conditions reaches the value of this parameter, CloudMonitor sends alert notifications.
   * 
   * @example
   * 3
   */
  times?: number;
  static names(): { [key: string]: string } {
    return {
      annotations: 'Annotations',
      level: 'Level',
      promQL: 'PromQL',
      times: 'Times',
    };
  }

  static types(): { [key: string]: any } {
    return {
      annotations: DescribeMetricRuleListResponseBodyAlarmsAlarmPrometheusAnnotations,
      level: 'string',
      promQL: 'string',
      times: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricRuleListResponseBodyAlarmsAlarm extends $tea.Model {
  /**
   * @remarks
   * The status of the alert rule. Valid values:
   * 
   * *   OK: The alert rule has no active alerts.
   * *   ALARM: The alert rule has active alerts.
   * *   INSUFFICIENT_DATA: No data is available.
   * 
   * @example
   * OK
   */
  alertState?: string;
  /**
   * @remarks
   * The trigger conditions for multiple metrics.
   * 
   * >  The trigger conditions for a single metric and multiple metrics are mutually exclusive. You cannot specify trigger conditions for a single metric and multiple metrics at the same time.
   */
  compositeExpression?: DescribeMetricRuleListResponseBodyAlarmsAlarmCompositeExpression;
  /**
   * @remarks
   * The alert contact group.
   * 
   * @example
   * ECS_Alarm
   */
  contactGroups?: string;
  /**
   * @remarks
   * The dimensions of the alert rule.
   * 
   * @example
   * [{"instanceId":"i-2ze2d6j5uhg20x47****"}]
   */
  dimensions?: string;
  /**
   * @remarks
   * The time period during which the alert rule is effective.
   * 
   * @example
   * 05:31-23:59
   */
  effectiveInterval?: string;
  /**
   * @remarks
   * Indicates whether the alert rule is enabled. Valid values:
   * 
   * *   true: The alert rule is enabled.
   * *   false: The alert rule is disabled.
   * 
   * @example
   * true
   */
  enableState?: boolean;
  /**
   * @remarks
   * The conditions for triggering different levels of alerts.
   */
  escalations?: DescribeMetricRuleListResponseBodyAlarmsAlarmEscalations;
  /**
   * @remarks
   * The ID of the application group.
   * 
   * @example
   * 7301****
   */
  groupId?: string;
  /**
   * @remarks
   * The name of the application group.
   * 
   * >  If the alert rule is associated with an application group, the name of the application group is returned in this parameter.
   * 
   * @example
   * ECS_Group
   */
  groupName?: string;
  /**
   * @remarks
   * The tags of the alert rule.
   */
  labels?: DescribeMetricRuleListResponseBodyAlarmsAlarmLabels;
  /**
   * @remarks
   * The subject of the alert notification email.
   * 
   * @example
   * "${serviceType}-${metricName}-${levelDescription}Notification(${dimensions})"
   */
  mailSubject?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * cpu_total
   */
  metricName?: string;
  /**
   * @remarks
   * The namespace of the cloud service.
   * 
   * @example
   * acs_ecs_dashboard
   */
  namespace?: string;
  /**
   * @remarks
   * The method that is used to handle alerts when no monitoring data is found. Valid values:
   * 
   * *   KEEP_LAST_STATE (default value): No operation is performed.
   * *   INSUFFICIENT_DATA: An alert whose content is "Insufficient data" is triggered.
   * *   OK: The status is considered normal.
   * 
   * @example
   * KEEP_LAST_STATE
   */
  noDataPolicy?: string;
  /**
   * @remarks
   * The time period during which the alert rule is ineffective.
   * 
   * @example
   * 00:00-05:30
   */
  noEffectiveInterval?: string;
  /**
   * @remarks
   * The statistical period.
   * 
   * @example
   * 60
   */
  period?: string;
  /**
   * @remarks
   * The Prometheus alert rule.
   * 
   * >  This parameter is required only when you create a Prometheus alert rule for Hybrid Cloud Monitoring.
   */
  prometheus?: DescribeMetricRuleListResponseBodyAlarmsAlarmPrometheus;
  /**
   * @remarks
   * The resources that are associated with the alert rule.
   * 
   * @example
   * [{\\"instanceId\\":\\"i-2ze2d6j5uhg20x47****\\"}]
   */
  resources?: string;
  /**
   * @remarks
   * The ID of the alert rule.
   * 
   * @example
   * applyTemplate344cfd42-0f32-4fd6-805a-88d7908a****
   */
  ruleId?: string;
  /**
   * @remarks
   * The name of the alert rule.
   * 
   * @example
   * Rule_01
   */
  ruleName?: string;
  /**
   * @remarks
   * The mute period during which new alert notifications are not sent even if the trigger conditions are met. Unit: seconds. Default value: 86400. Minimum value: 3600.
   * 
   * Only one alert is reported during each mute period even if the metric value consecutively exceeds the alert rule threshold several times.
   * 
   * @example
   * 86400
   */
  silenceTime?: number;
  /**
   * @remarks
   * The type of the alert rule. Valid value: METRIC. This value indicates an alert rule for time series metrics.
   * 
   * @example
   * METRIC
   */
  sourceType?: string;
  /**
   * @remarks
   * The callback URL. CloudMonitor pushes an alert notification to the specified callback URL by sending an HTTP POST request. Only the HTTP protocol is supported.
   * 
   * @example
   * https://www.aliyun.com
   */
  webhook?: string;
  static names(): { [key: string]: string } {
    return {
      alertState: 'AlertState',
      compositeExpression: 'CompositeExpression',
      contactGroups: 'ContactGroups',
      dimensions: 'Dimensions',
      effectiveInterval: 'EffectiveInterval',
      enableState: 'EnableState',
      escalations: 'Escalations',
      groupId: 'GroupId',
      groupName: 'GroupName',
      labels: 'Labels',
      mailSubject: 'MailSubject',
      metricName: 'MetricName',
      namespace: 'Namespace',
      noDataPolicy: 'NoDataPolicy',
      noEffectiveInterval: 'NoEffectiveInterval',
      period: 'Period',
      prometheus: 'Prometheus',
      resources: 'Resources',
      ruleId: 'RuleId',
      ruleName: 'RuleName',
      silenceTime: 'SilenceTime',
      sourceType: 'SourceType',
      webhook: 'Webhook',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertState: 'string',
      compositeExpression: DescribeMetricRuleListResponseBodyAlarmsAlarmCompositeExpression,
      contactGroups: 'string',
      dimensions: 'string',
      effectiveInterval: 'string',
      enableState: 'boolean',
      escalations: DescribeMetricRuleListResponseBodyAlarmsAlarmEscalations,
      groupId: 'string',
      groupName: 'string',
      labels: DescribeMetricRuleListResponseBodyAlarmsAlarmLabels,
      mailSubject: 'string',
      metricName: 'string',
      namespace: 'string',
      noDataPolicy: 'string',
      noEffectiveInterval: 'string',
      period: 'string',
      prometheus: DescribeMetricRuleListResponseBodyAlarmsAlarmPrometheus,
      resources: 'string',
      ruleId: 'string',
      ruleName: 'string',
      silenceTime: 'number',
      sourceType: 'string',
      webhook: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricRuleListResponseBodyAlarms extends $tea.Model {
  alarm?: DescribeMetricRuleListResponseBodyAlarmsAlarm[];
  static names(): { [key: string]: string } {
    return {
      alarm: 'Alarm',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alarm: { 'type': 'array', 'itemType': DescribeMetricRuleListResponseBodyAlarmsAlarm },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricRuleTargetsResponseBodyTargetsTarget extends $tea.Model {
  /**
   * @remarks
   * The Alibaba Cloud Resource Name (ARN) of the resource. Format: `acs:{Service name abbreviation}:{regionId}:{userId}:/{Resource type}/{Resource name}/message`. Example: `acs:mns:cn-hangzhou:120886317861****:/queues/test123/message`. Fields:
   * 
   * *   {Service name abbreviation}: the abbreviation of the service name. Valid value: mns.
   * *   {userId}: the ID of the Alibaba Cloud account.
   * *   {regionId}: the region ID of the message queue or topic.
   * *   {Resource type}`: the type of the resource for which alerts are triggered. Valid values: - **queues** - **topics** {Resource name}: the name of the resource. - If the resource type is set to **queues**, the resource name is the name of the message queue. - If the resource type is set to **topics**, the resource name is the name of the topic.`
   * 
   * @example
   * acs:mns:cn-hangzhou:120886317861****:/queues/test/message
   */
  arn?: string;
  /**
   * @remarks
   * The ID of the resource for which alerts are triggered.
   * 
   * @example
   * 1
   */
  id?: string;
  /**
   * @remarks
   * The parameters of the alert callback. The parameters are in the JSON format.
   * 
   * @example
   * {"customField1":"value1","customField2":"$.name"}
   */
  jsonParams?: string;
  /**
   * @remarks
   * The level of the alert. Valid values:
   * 
   * *   INFO: information
   * *   WARN: warning
   * *   CRITICAL: critical
   * 
   * @example
   * ["INFO", "WARN", "CRITICAL"]
   */
  level?: string;
  static names(): { [key: string]: string } {
    return {
      arn: 'Arn',
      id: 'Id',
      jsonParams: 'JsonParams',
      level: 'Level',
    };
  }

  static types(): { [key: string]: any } {
    return {
      arn: 'string',
      id: 'string',
      jsonParams: 'string',
      level: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricRuleTargetsResponseBodyTargets extends $tea.Model {
  target?: DescribeMetricRuleTargetsResponseBodyTargetsTarget[];
  static names(): { [key: string]: string } {
    return {
      target: 'Target',
    };
  }

  static types(): { [key: string]: any } {
    return {
      target: { 'type': 'array', 'itemType': DescribeMetricRuleTargetsResponseBodyTargetsTarget },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateEscalationsCritical extends $tea.Model {
  /**
   * @remarks
   * The comparison operator that is used to compare the metric value with the threshold for Critical-level alerts. Valid values:
   * 
   * *   GreaterThanOrEqualToThreshold: greater than or equal to the threshold
   * *   GreaterThanThreshold: greater than the threshold
   * *   LessThanOrEqualToThreshold: less than or equal to the threshold
   * *   LessThanThreshold: less than the threshold
   * *   NotEqualToThreshold: not equal to the threshold
   * *   GreaterThanYesterday: greater than the metric value at the same time yesterday
   * *   LessThanYesterday: less than the metric value at the same time yesterday
   * *   GreaterThanLastWeek: greater than the metric value at the same time last week
   * *   LessThanLastWeek: less than the metric value at the same time last week
   * *   GreaterThanLastPeriod: greater than the metric value in the last monitoring cycle
   * *   LessThanLastPeriod: less than the metric value in the last monitoring cycle
   * 
   * @example
   * GreaterThanOrEqualToThreshold
   */
  comparisonOperator?: string;
  /**
   * @remarks
   * The statistical method for Critical-level alerts.
   * 
   * The value of the `Statistics` parameter varies with the cloud service. For more information, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * @example
   * Average
   */
  statistics?: string;
  /**
   * @remarks
   * The threshold for Critical-level alerts.
   * 
   * @example
   * 90
   */
  threshold?: string;
  /**
   * @remarks
   * The consecutive number of times for which the metric value meets the alert condition before a Critical-level alert is triggered.
   * 
   * @example
   * 5
   */
  times?: number;
  static names(): { [key: string]: string } {
    return {
      comparisonOperator: 'ComparisonOperator',
      statistics: 'Statistics',
      threshold: 'Threshold',
      times: 'Times',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comparisonOperator: 'string',
      statistics: 'string',
      threshold: 'string',
      times: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateEscalationsInfo extends $tea.Model {
  /**
   * @remarks
   * The comparison operator that is used to compare the metric value with the threshold for Info-level alerts. Valid values:
   * 
   * *   GreaterThanOrEqualToThreshold: greater than or equal to the threshold
   * *   GreaterThanThreshold: greater than the threshold
   * *   LessThanOrEqualToThreshold: less than or equal to the threshold
   * *   LessThanThreshold: less than the threshold
   * *   NotEqualToThreshold: not equal to the threshold
   * *   GreaterThanYesterday: greater than the metric value at the same time yesterday
   * *   LessThanYesterday: less than the metric value at the same time yesterday
   * *   GreaterThanLastWeek: greater than the metric value at the same time last week
   * *   LessThanLastWeek: less than the metric value at the same time last week
   * *   GreaterThanLastPeriod: greater than the metric value in the last monitoring cycle
   * *   LessThanLastPeriod: less than the metric value in the last monitoring cycle
   * 
   * @example
   * GreaterThanOrEqualToThreshold
   */
  comparisonOperator?: string;
  /**
   * @remarks
   * The statistical method for Info-level alerts.
   * 
   * The value of the `Statistics` parameter varies with the cloud service. For more information, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * @example
   * Average
   */
  statistics?: string;
  /**
   * @remarks
   * The threshold for Info-level alerts.
   * 
   * @example
   * 90
   */
  threshold?: string;
  /**
   * @remarks
   * The consecutive number of times for which the metric value meets the alert condition before an Info-level alert is triggered.
   * 
   * @example
   * 3
   */
  times?: number;
  static names(): { [key: string]: string } {
    return {
      comparisonOperator: 'ComparisonOperator',
      statistics: 'Statistics',
      threshold: 'Threshold',
      times: 'Times',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comparisonOperator: 'string',
      statistics: 'string',
      threshold: 'string',
      times: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateEscalationsWarn extends $tea.Model {
  /**
   * @remarks
   * The comparison operator that is used to compare the metric value with the threshold for Warn-level alerts. Valid values:
   * 
   * *   GreaterThanOrEqualToThreshold: greater than or equal to the threshold
   * *   GreaterThanThreshold: greater than the threshold
   * *   LessThanOrEqualToThreshold: less than or equal to the threshold
   * *   LessThanThreshold: less than the threshold
   * *   NotEqualToThreshold: not equal to the threshold
   * *   GreaterThanYesterday: greater than the metric value at the same time yesterday
   * *   LessThanYesterday: less than the metric value at the same time yesterday
   * *   GreaterThanLastWeek: greater than the metric value at the same time last week
   * *   LessThanLastWeek: less than the metric value at the same time last week
   * *   GreaterThanLastPeriod: greater than the metric value in the last monitoring cycle
   * *   LessThanLastPeriod: less than the metric value in the last monitoring cycle
   * 
   * @example
   * GreaterThanOrEqualToThreshold
   */
  comparisonOperator?: string;
  /**
   * @remarks
   * The statistical method for Warn-level alerts.
   * 
   * The value of the `Statistics` parameter varies with the cloud service. For more information, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * @example
   * Average
   */
  statistics?: string;
  /**
   * @remarks
   * The threshold for Warn-level alerts.
   * 
   * @example
   * 90
   */
  threshold?: string;
  /**
   * @remarks
   * The consecutive number of times for which the metric value meets the alert condition before a Warn-level alert is triggered.
   * 
   * @example
   * 3
   */
  times?: number;
  static names(): { [key: string]: string } {
    return {
      comparisonOperator: 'ComparisonOperator',
      statistics: 'Statistics',
      threshold: 'Threshold',
      times: 'Times',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comparisonOperator: 'string',
      statistics: 'string',
      threshold: 'string',
      times: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateEscalations extends $tea.Model {
  /**
   * @remarks
   * The conditions for triggering Critical-level alerts.
   */
  critical?: DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateEscalationsCritical;
  /**
   * @remarks
   * The conditions for triggering Info-level alerts.
   */
  info?: DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateEscalationsInfo;
  /**
   * @remarks
   * The conditions for triggering Warn-level alerts.
   */
  warn?: DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateEscalationsWarn;
  static names(): { [key: string]: string } {
    return {
      critical: 'Critical',
      info: 'Info',
      warn: 'Warn',
    };
  }

  static types(): { [key: string]: any } {
    return {
      critical: DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateEscalationsCritical,
      info: DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateEscalationsInfo,
      warn: DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateEscalationsWarn,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateLabelsLabels extends $tea.Model {
  /**
   * @remarks
   * The tag key of the alert template.
   * 
   * @example
   * label1
   */
  key?: string;
  /**
   * @remarks
   * The tag value of the alert template.
   * 
   * @example
   * value1
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateLabels extends $tea.Model {
  labels?: DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateLabelsLabels[];
  static names(): { [key: string]: string } {
    return {
      labels: 'Labels',
    };
  }

  static types(): { [key: string]: any } {
    return {
      labels: { 'type': 'array', 'itemType': DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateLabelsLabels },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplate extends $tea.Model {
  /**
   * @remarks
   * The abbreviation of the Alibaba Cloud service name.
   * 
   * @example
   * ecs
   */
  category?: string;
  /**
   * @remarks
   * The threshold and the alert level.
   */
  escalations?: DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateEscalations;
  /**
   * @remarks
   * The tags of the alert template.
   */
  labels?: DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateLabels;
  /**
   * @remarks
   * The metric name.
   * 
   * @example
   * cpu_total
   */
  metricName?: string;
  /**
   * @remarks
   * The namespace of the Alibaba Cloud service.
   * 
   * @example
   * acs_ecs_dashboard
   */
  namespace?: string;
  /**
   * @remarks
   * The method that is used to handle alerts when no monitoring data is found. Valid values:
   * 
   * *   KEEP_LAST_STATE (default): No operation is performed.
   * *   INSUFFICIENT_DATA: An alert whose content is "Insufficient data" is triggered.
   * *   OK: The status is considered normal.
   * 
   * @example
   * KEEP_LAST_STATE
   */
  noDataPolicy?: string;
  /**
   * @remarks
   * The name of the alert rule.
   * 
   * @example
   * ECS_Rule
   */
  ruleName?: string;
  /**
   * @remarks
   * The dimension of the alert. It is an extended field.
   * 
   * @example
   * {"disk":"/"}
   */
  selector?: string;
  /**
   * @remarks
   * The callback URL to which a request is sent when an alert is triggered.
   * 
   * @example
   * https://www.aliyun.com
   */
  webhook?: string;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      escalations: 'Escalations',
      labels: 'Labels',
      metricName: 'MetricName',
      namespace: 'Namespace',
      noDataPolicy: 'NoDataPolicy',
      ruleName: 'RuleName',
      selector: 'Selector',
      webhook: 'Webhook',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      escalations: DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateEscalations,
      labels: DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateLabels,
      metricName: 'string',
      namespace: 'string',
      noDataPolicy: 'string',
      ruleName: 'string',
      selector: 'string',
      webhook: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplates extends $tea.Model {
  alertTemplate?: DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplate[];
  static names(): { [key: string]: string } {
    return {
      alertTemplate: 'AlertTemplate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertTemplate: { 'type': 'array', 'itemType': DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplate },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricRuleTemplateAttributeResponseBodyResource extends $tea.Model {
  /**
   * @remarks
   * The queried alert templates.
   */
  alertTemplates?: DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplates;
  /**
   * @remarks
   * The description of the alert template.
   */
  description?: string;
  /**
   * @remarks
   * The name of the alert template.
   * 
   * @example
   * ECS_Template1
   */
  name?: string;
  /**
   * @remarks
   * The version of the alert template.
   * 
   * @example
   * 1
   */
  restVersion?: string;
  /**
   * @remarks
   * The ID of the alert template.
   * 
   * @example
   * 70****
   */
  templateId?: string;
  static names(): { [key: string]: string } {
    return {
      alertTemplates: 'AlertTemplates',
      description: 'Description',
      name: 'Name',
      restVersion: 'RestVersion',
      templateId: 'TemplateId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertTemplates: DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplates,
      description: 'string',
      name: 'string',
      restVersion: 'string',
      templateId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricRuleTemplateListResponseBodyTemplatesTemplateApplyHistoriesApplyHistory extends $tea.Model {
  /**
   * @remarks
   * The timestamp when the alert template was applied to the application group.
   * 
   * Unit: milliseconds.
   * 
   * @example
   * 1646055898000
   */
  applyTime?: number;
  /**
   * @remarks
   * The ID of the application group.
   * 
   * @example
   * 3607****
   */
  groupId?: number;
  /**
   * @remarks
   * The name of the application group.
   * 
   * @example
   * ECS_Group
   */
  groupName?: string;
  static names(): { [key: string]: string } {
    return {
      applyTime: 'ApplyTime',
      groupId: 'GroupId',
      groupName: 'GroupName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applyTime: 'number',
      groupId: 'number',
      groupName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricRuleTemplateListResponseBodyTemplatesTemplateApplyHistories extends $tea.Model {
  applyHistory?: DescribeMetricRuleTemplateListResponseBodyTemplatesTemplateApplyHistoriesApplyHistory[];
  static names(): { [key: string]: string } {
    return {
      applyHistory: 'ApplyHistory',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applyHistory: { 'type': 'array', 'itemType': DescribeMetricRuleTemplateListResponseBodyTemplatesTemplateApplyHistoriesApplyHistory },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricRuleTemplateListResponseBodyTemplatesTemplate extends $tea.Model {
  /**
   * @remarks
   * The history of applying the alert templates to application groups.
   */
  applyHistories?: DescribeMetricRuleTemplateListResponseBodyTemplatesTemplateApplyHistories;
  /**
   * @remarks
   * The description of the alert template.
   */
  description?: string;
  /**
   * @remarks
   * The timestamp when the alert template was created.
   * 
   * Unit: milliseconds.
   * 
   * @example
   * 1646018798000
   */
  gmtCreate?: number;
  /**
   * @remarks
   * The timestamp when the alert template was modified.
   * 
   * Unit: milliseconds.
   * 
   * @example
   * 1646054798000
   */
  gmtModified?: number;
  /**
   * @remarks
   * The name of the alert template.
   * 
   * @example
   * ECS_Template1
   */
  name?: string;
  /**
   * @remarks
   * The version of the alert template.
   * 
   * Default value: 0.
   * 
   * @example
   * 0
   */
  restVersion?: number;
  /**
   * @remarks
   * The ID of the alert template.
   * 
   * @example
   * 70****
   */
  templateId?: number;
  static names(): { [key: string]: string } {
    return {
      applyHistories: 'ApplyHistories',
      description: 'Description',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      name: 'Name',
      restVersion: 'RestVersion',
      templateId: 'TemplateId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applyHistories: DescribeMetricRuleTemplateListResponseBodyTemplatesTemplateApplyHistories,
      description: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      name: 'string',
      restVersion: 'number',
      templateId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricRuleTemplateListResponseBodyTemplates extends $tea.Model {
  template?: DescribeMetricRuleTemplateListResponseBodyTemplatesTemplate[];
  static names(): { [key: string]: string } {
    return {
      template: 'Template',
    };
  }

  static types(): { [key: string]: any } {
    return {
      template: { 'type': 'array', 'itemType': DescribeMetricRuleTemplateListResponseBodyTemplatesTemplate },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitorGroupCategoriesResponseBodyMonitorGroupCategoriesMonitorGroupCategoryCategoryItem extends $tea.Model {
  /**
   * @remarks
   * The abbreviation of the cloud service name.
   * 
   * >  For more information about how to obtain the abbreviation of a cloud service name, see `metricCategory` in the response parameter `Labels` of the [DescribeProjectMeta](https://help.aliyun.com/document_detail/114916.html) operation.
   * 
   * @example
   * ECS
   */
  category?: string;
  /**
   * @remarks
   * The number of resources that belong to the cloud service.
   * 
   * @example
   * 1
   */
  count?: number;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      count: 'Count',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      count: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitorGroupCategoriesResponseBodyMonitorGroupCategoriesMonitorGroupCategory extends $tea.Model {
  categoryItem?: DescribeMonitorGroupCategoriesResponseBodyMonitorGroupCategoriesMonitorGroupCategoryCategoryItem[];
  static names(): { [key: string]: string } {
    return {
      categoryItem: 'CategoryItem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      categoryItem: { 'type': 'array', 'itemType': DescribeMonitorGroupCategoriesResponseBodyMonitorGroupCategoriesMonitorGroupCategoryCategoryItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitorGroupCategoriesResponseBodyMonitorGroupCategories extends $tea.Model {
  /**
   * @remarks
   * The ID of the application group.
   * 
   * @example
   * 123456
   */
  groupId?: number;
  /**
   * @remarks
   * The cloud services to which the resources in the application group belong and the number of resources that belong to the cloud service.
   */
  monitorGroupCategory?: DescribeMonitorGroupCategoriesResponseBodyMonitorGroupCategoriesMonitorGroupCategory;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      monitorGroupCategory: 'MonitorGroupCategory',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'number',
      monitorGroupCategory: DescribeMonitorGroupCategoriesResponseBodyMonitorGroupCategoriesMonitorGroupCategory,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitorGroupDynamicRulesResponseBodyResourceResourceFiltersFilter extends $tea.Model {
  /**
   * @remarks
   * The method that is used to filter the instances. Valid values:
   * 
   * *   contains: contains
   * *   startWith: starts with a prefix
   * *   endWith: ends with a suffix
   * 
   * @example
   * contains
   */
  function?: string;
  /**
   * @remarks
   * The instance name.
   * 
   * @example
   * hostName
   */
  name?: string;
  /**
   * @remarks
   * The value of the dynamic rule.
   * 
   * @example
   * 1
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      function: 'Function',
      name: 'Name',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      function: 'string',
      name: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitorGroupDynamicRulesResponseBodyResourceResourceFilters extends $tea.Model {
  filter?: DescribeMonitorGroupDynamicRulesResponseBodyResourceResourceFiltersFilter[];
  static names(): { [key: string]: string } {
    return {
      filter: 'Filter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      filter: { 'type': 'array', 'itemType': DescribeMonitorGroupDynamicRulesResponseBodyResourceResourceFiltersFilter },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitorGroupDynamicRulesResponseBodyResourceResource extends $tea.Model {
  /**
   * @remarks
   * The type of the cloud service to which the dynamic rule belongs. Valid values:
   * 
   * *   ecs: Elastic Compute Service (ECS)
   * *   rds: ApsaraDB RDS
   * *   slb: Server Load Balancer (SLB)
   * 
   * @example
   * ecs
   */
  category?: string;
  /**
   * @remarks
   * The filter condition. Valid values:
   * 
   * *   and: queries the instances that meet all alert rules.
   * *   or: queries the instances that meet any alert rule.
   * 
   * @example
   * and
   */
  filterRelation?: string;
  /**
   * @remarks
   * The dynamic rules of the application group.
   */
  filters?: DescribeMonitorGroupDynamicRulesResponseBodyResourceResourceFilters;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      filterRelation: 'FilterRelation',
      filters: 'Filters',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      filterRelation: 'string',
      filters: DescribeMonitorGroupDynamicRulesResponseBodyResourceResourceFilters,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitorGroupDynamicRulesResponseBodyResource extends $tea.Model {
  resource?: DescribeMonitorGroupDynamicRulesResponseBodyResourceResource[];
  static names(): { [key: string]: string } {
    return {
      resource: 'Resource',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resource: { 'type': 'array', 'itemType': DescribeMonitorGroupDynamicRulesResponseBodyResourceResource },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResourceRegion extends $tea.Model {
  /**
   * @remarks
   * The zone.
   * 
   * @example
   * cn-hangzhou-f
   */
  availabilityZone?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      availabilityZone: 'AvailabilityZone',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      availabilityZone: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResourceTagsTag extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * instanceNetworkType
   */
  key?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * VPC
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResourceTags extends $tea.Model {
  tag?: DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResourceTagsTag[];
  static names(): { [key: string]: string } {
    return {
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tag: { 'type': 'array', 'itemType': DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResourceTagsTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResourceVpc extends $tea.Model {
  /**
   * @remarks
   * The VPC ID.
   * 
   * @example
   * vpc-2zew7etgiceg21****
   */
  vpcInstanceId?: string;
  /**
   * @remarks
   * The vSwitch ID.
   * 
   * @example
   * vsw-2ze36seq79n992****
   */
  vswitchInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      vpcInstanceId: 'VpcInstanceId',
      vswitchInstanceId: 'VswitchInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      vpcInstanceId: 'string',
      vswitchInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResource extends $tea.Model {
  /**
   * @remarks
   * The name of the cloud service.
   * 
   * @example
   * ecs
   */
  category?: string;
  /**
   * @remarks
   * The resource description.
   * 
   * @example
   * desc_test
   */
  desc?: string;
  /**
   * @remarks
   * The dimensions of the resource that is associated with the application group.
   * 
   * @example
   * {"instanceId":"i-m5e0k0bexac8tykr****"}
   */
  dimension?: string;
  /**
   * @remarks
   * The instance ID.
   * 
   * @example
   * i-m5e0k0bexac8tykr****
   */
  instanceId?: string;
  /**
   * @remarks
   * The instance name.
   * 
   * @example
   * hostName
   */
  instanceName?: string;
  /**
   * @remarks
   * The network type.
   * 
   * @example
   * vpc
   */
  networkType?: string;
  /**
   * @remarks
   * The region.
   */
  region?: DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResourceRegion;
  /**
   * @remarks
   * The tag of the resource.
   */
  tags?: DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResourceTags;
  /**
   * @remarks
   * The VPC description.
   */
  vpc?: DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResourceVpc;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      desc: 'Desc',
      dimension: 'Dimension',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      networkType: 'NetworkType',
      region: 'Region',
      tags: 'Tags',
      vpc: 'Vpc',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      desc: 'string',
      dimension: 'string',
      instanceId: 'string',
      instanceName: 'string',
      networkType: 'string',
      region: DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResourceRegion,
      tags: DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResourceTags,
      vpc: DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResourceVpc,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitorGroupInstanceAttributeResponseBodyResources extends $tea.Model {
  resource?: DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResource[];
  static names(): { [key: string]: string } {
    return {
      resource: 'Resource',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resource: { 'type': 'array', 'itemType': DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResource },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitorGroupInstancesResponseBodyResourcesResource extends $tea.Model {
  /**
   * @remarks
   * The abbreviation of the service name.
   * 
   * @example
   * ecs
   */
  category?: string;
  /**
   * @remarks
   * The resource ID.
   * 
   * @example
   * 12345
   */
  id?: number;
  /**
   * @remarks
   * The instance ID.
   * 
   * @example
   * i-2ze3w55tr2r****
   */
  instanceId?: string;
  /**
   * @remarks
   * The instance name.
   * 
   * @example
   * hostIP
   */
  instanceName?: string;
  /**
   * @remarks
   * The ID of the region where the instance resides.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      id: 'Id',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      id: 'number',
      instanceId: 'string',
      instanceName: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitorGroupInstancesResponseBodyResources extends $tea.Model {
  resource?: DescribeMonitorGroupInstancesResponseBodyResourcesResource[];
  static names(): { [key: string]: string } {
    return {
      resource: 'Resource',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resource: { 'type': 'array', 'itemType': DescribeMonitorGroupInstancesResponseBodyResourcesResource },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitorGroupNotifyPolicyListResponseBodyNotifyPolicyListNotifyPolicy extends $tea.Model {
  /**
   * @remarks
   * The end of the time range to query.
   * 
   * Unit: milliseconds.
   * 
   * @example
   * 1551761781273
   */
  endTime?: number;
  /**
   * @remarks
   * The ID of the application group.
   * 
   * @example
   * 6780****
   */
  groupId?: string;
  /**
   * @remarks
   * The policy ID.
   * 
   * @example
   * 123****
   */
  id?: string;
  /**
   * @remarks
   * The beginning of the time range to query.
   * 
   * Unit: milliseconds.
   * 
   * @example
   * 1551761781273
   */
  startTime?: number;
  /**
   * @remarks
   * The policy type.
   * 
   * @example
   * PauseNotify
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      groupId: 'GroupId',
      id: 'Id',
      startTime: 'StartTime',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      groupId: 'string',
      id: 'string',
      startTime: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitorGroupNotifyPolicyListResponseBodyNotifyPolicyList extends $tea.Model {
  notifyPolicy?: DescribeMonitorGroupNotifyPolicyListResponseBodyNotifyPolicyListNotifyPolicy[];
  static names(): { [key: string]: string } {
    return {
      notifyPolicy: 'NotifyPolicy',
    };
  }

  static types(): { [key: string]: any } {
    return {
      notifyPolicy: { 'type': 'array', 'itemType': DescribeMonitorGroupNotifyPolicyListResponseBodyNotifyPolicyListNotifyPolicy },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitorGroupsRequestTag extends $tea.Model {
  /**
   * @remarks
   * The tag key of the application group. Valid values of N: 1 to 5.
   * 
   * @example
   * tagKey1
   */
  key?: string;
  /**
   * @remarks
   * The tag value of the application group. Valid values of N: 1 to 5.
   * 
   * @example
   * tagValue1
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitorGroupsResponseBodyResourcesResourceContactGroupsContactGroup extends $tea.Model {
  /**
   * @remarks
   * The name of the alert contact group.
   * 
   * @example
   * CloudMonitor
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitorGroupsResponseBodyResourcesResourceContactGroups extends $tea.Model {
  contactGroup?: DescribeMonitorGroupsResponseBodyResourcesResourceContactGroupsContactGroup[];
  static names(): { [key: string]: string } {
    return {
      contactGroup: 'ContactGroup',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contactGroup: { 'type': 'array', 'itemType': DescribeMonitorGroupsResponseBodyResourcesResourceContactGroupsContactGroup },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitorGroupsResponseBodyResourcesResourceTagsTag extends $tea.Model {
  /**
   * @remarks
   * The tag key of the application group.
   * 
   * @example
   * tagKey1
   */
  key?: string;
  /**
   * @remarks
   * The tag value of the application group.
   * 
   * @example
   * tagValue1
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitorGroupsResponseBodyResourcesResourceTags extends $tea.Model {
  tag?: DescribeMonitorGroupsResponseBodyResourcesResourceTagsTag[];
  static names(): { [key: string]: string } {
    return {
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tag: { 'type': 'array', 'itemType': DescribeMonitorGroupsResponseBodyResourcesResourceTagsTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitorGroupsResponseBodyResourcesResourceTemplateIds extends $tea.Model {
  templateId?: string[];
  static names(): { [key: string]: string } {
    return {
      templateId: 'TemplateId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      templateId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitorGroupsResponseBodyResourcesResource extends $tea.Model {
  /**
   * @remarks
   * The URL of the ACK cluster from which the application group is synchronized.
   * 
   * @example
   * https://aliyun.com
   */
  bindUrl?: string;
  /**
   * @remarks
   * The alert contact groups.
   */
  contactGroups?: DescribeMonitorGroupsResponseBodyResourcesResourceContactGroups;
  /**
   * @remarks
   * The ID of the tag rule.
   * 
   * @example
   * 6b882d9a-5117-42e2-9d0c-4749a0c6****
   */
  dynamicTagRuleId?: string;
  /**
   * @remarks
   * The timestamp when the application group was created. Unit: milliseconds.
   * 
   * @example
   * 1603181891000
   */
  gmtCreate?: number;
  /**
   * @remarks
   * The timestamp when the application group was modified. Unit: milliseconds.
   * 
   * @example
   * 1603181891000
   */
  gmtModified?: number;
  /**
   * @remarks
   * The tag key that is created for the application group by using the tag rule.
   * 
   * @example
   * GroupKey1
   */
  groupFounderTagKey?: string;
  /**
   * @remarks
   * The tag value that is created for the application group by using the tag rule.
   * 
   * @example
   * GroupValue1
   */
  groupFounderTagValue?: string;
  /**
   * @remarks
   * The ID of the application group.
   * 
   * @example
   * 12345
   */
  groupId?: number;
  /**
   * @remarks
   * The name of the application group.
   * 
   * @example
   * test123
   */
  groupName?: string;
  /**
   * @remarks
   * The resource ID.
   * 
   * @example
   * rg-aek2hopjh*******
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud service.
   * 
   * @example
   * 49****
   */
  serviceId?: string;
  /**
   * @remarks
   * The tags that are attached to the application group.
   */
  tags?: DescribeMonitorGroupsResponseBodyResourcesResourceTags;
  /**
   * @remarks
   * The ID of the template.
   */
  templateIds?: DescribeMonitorGroupsResponseBodyResourcesResourceTemplateIds;
  /**
   * @remarks
   * The type of the application group. Valid values:
   * 
   * *   custom: a self-managed application group
   * *   ehpc_cluster: an application group that is synchronized from an E-HPC cluster
   * *   kubernetes: an application group that is synchronized from an ACK cluster
   * 
   * @example
   * custom
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      bindUrl: 'BindUrl',
      contactGroups: 'ContactGroups',
      dynamicTagRuleId: 'DynamicTagRuleId',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      groupFounderTagKey: 'GroupFounderTagKey',
      groupFounderTagValue: 'GroupFounderTagValue',
      groupId: 'GroupId',
      groupName: 'GroupName',
      resourceGroupId: 'ResourceGroupId',
      serviceId: 'ServiceId',
      tags: 'Tags',
      templateIds: 'TemplateIds',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bindUrl: 'string',
      contactGroups: DescribeMonitorGroupsResponseBodyResourcesResourceContactGroups,
      dynamicTagRuleId: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      groupFounderTagKey: 'string',
      groupFounderTagValue: 'string',
      groupId: 'number',
      groupName: 'string',
      resourceGroupId: 'string',
      serviceId: 'string',
      tags: DescribeMonitorGroupsResponseBodyResourcesResourceTags,
      templateIds: DescribeMonitorGroupsResponseBodyResourcesResourceTemplateIds,
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitorGroupsResponseBodyResources extends $tea.Model {
  resource?: DescribeMonitorGroupsResponseBodyResourcesResource[];
  static names(): { [key: string]: string } {
    return {
      resource: 'Resource',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resource: { 'type': 'array', 'itemType': DescribeMonitorGroupsResponseBodyResourcesResource },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaApi extends $tea.Model {
  /**
   * @remarks
   * The total quota of API calls. Unit: 10,000 calls.
   * 
   * @example
   * 500
   */
  quotaLimit?: number;
  /**
   * @remarks
   * The quota of API calls in your resource plan. Unit: 10,000 calls.
   * 
   * @example
   * 500
   */
  quotaPackage?: number;
  /**
   * @remarks
   * The used quota of API calls in your resource plan. Unit: calls.
   * 
   * @example
   * 9987
   */
  quotaUsed?: number;
  static names(): { [key: string]: string } {
    return {
      quotaLimit: 'QuotaLimit',
      quotaPackage: 'QuotaPackage',
      quotaUsed: 'QuotaUsed',
    };
  }

  static types(): { [key: string]: any } {
    return {
      quotaLimit: 'number',
      quotaPackage: 'number',
      quotaUsed: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaCustomMonitor extends $tea.Model {
  /**
   * @remarks
   * The total quota of the time series for custom monitoring.
   * 
   * @example
   * 1200
   */
  quotaLimit?: number;
  /**
   * @remarks
   * The quota of the time series for custom monitoring in your resource plan.
   * 
   * @example
   * 1000
   */
  quotaPackage?: number;
  /**
   * @remarks
   * The used quota of the time series for custom monitoring in your resource plan.
   * 
   * @example
   * 8
   */
  quotaUsed?: number;
  static names(): { [key: string]: string } {
    return {
      quotaLimit: 'QuotaLimit',
      quotaPackage: 'QuotaPackage',
      quotaUsed: 'QuotaUsed',
    };
  }

  static types(): { [key: string]: any } {
    return {
      quotaLimit: 'number',
      quotaPackage: 'number',
      quotaUsed: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaEnterpriseQuota extends $tea.Model {
  /**
   * @remarks
   * The ID of the instance monitored by Hybrid Cloud Monitoring.
   * 
   * @example
   * cms_enterprise_public_cn-7mz27pd****
   */
  instanceId?: string;
  /**
   * @remarks
   * The description of Hybrid Cloud Monitoring.
   * 
   * @example
   * ENTERPRISE
   */
  suitInfo?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      suitInfo: 'SuitInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      suitInfo: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaEventMonitor extends $tea.Model {
  /**
   * @remarks
   * The total quota of events that can be reported in event monitoring. The total quota is the value that is multiplied by 10,000.
   * 
   * @example
   * 55
   */
  quotaLimit?: number;
  /**
   * @remarks
   * The quota of events that can be reported in event monitoring in your resource plan. The total quota is the value that is multiplied by 10,000.
   * 
   * @example
   * 50
   */
  quotaPackage?: number;
  /**
   * @remarks
   * The used quota of events that can be reported in event monitoring in your resource plan. The total quota is the value that is multiplied by 10,000.
   * 
   * @example
   * 2
   */
  quotaUsed?: number;
  static names(): { [key: string]: string } {
    return {
      quotaLimit: 'QuotaLimit',
      quotaPackage: 'QuotaPackage',
      quotaUsed: 'QuotaUsed',
    };
  }

  static types(): { [key: string]: any } {
    return {
      quotaLimit: 'number',
      quotaPackage: 'number',
      quotaUsed: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaLogMonitor extends $tea.Model {
  /**
   * @remarks
   * The total quota of processed log data in log monitoring. Unit: MB/min.
   * 
   * @example
   * 150
   */
  quotaLimit?: number;
  /**
   * @remarks
   * The quota of processed log data in log monitoring in your resource plan. Unit: MB/min.
   * 
   * @example
   * 150
   */
  quotaPackage?: number;
  /**
   * @remarks
   * The used quota of processed log data in log monitoring in your resource plan. Unit: MB/min.
   * 
   * @example
   * 80
   */
  quotaUsed?: number;
  static names(): { [key: string]: string } {
    return {
      quotaLimit: 'QuotaLimit',
      quotaPackage: 'QuotaPackage',
      quotaUsed: 'QuotaUsed',
    };
  }

  static types(): { [key: string]: any } {
    return {
      quotaLimit: 'number',
      quotaPackage: 'number',
      quotaUsed: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaPhone extends $tea.Model {
  /**
   * @remarks
   * The total quota of alert phone calls. Unit: calls.
   * 
   * @example
   * 550
   */
  quotaLimit?: number;
  /**
   * @remarks
   * The quota of alert phone calls in your resource plan. Unit: calls.
   * 
   * @example
   * 500
   */
  quotaPackage?: number;
  /**
   * @remarks
   * The used quota of alert phone calls in your resource plan. Unit: calls.
   * 
   * @example
   * 100
   */
  quotaUsed?: number;
  static names(): { [key: string]: string } {
    return {
      quotaLimit: 'QuotaLimit',
      quotaPackage: 'QuotaPackage',
      quotaUsed: 'QuotaUsed',
    };
  }

  static types(): { [key: string]: any } {
    return {
      quotaLimit: 'number',
      quotaPackage: 'number',
      quotaUsed: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSMS extends $tea.Model {
  /**
   * @remarks
   * The total quota of alert text messages. Unit: messages.
   * 
   * @example
   * 550
   */
  quotaLimit?: number;
  /**
   * @remarks
   * The quota of alert text messages in your resource plan. Unit: messages.
   * 
   * @example
   * 500
   */
  quotaPackage?: number;
  /**
   * @remarks
   * The used quota of alert text messages in your resource plan. Unit: messages.
   * 
   * @example
   * 38
   */
  quotaUsed?: number;
  static names(): { [key: string]: string } {
    return {
      quotaLimit: 'QuotaLimit',
      quotaPackage: 'QuotaPackage',
      quotaUsed: 'QuotaUsed',
    };
  }

  static types(): { [key: string]: any } {
    return {
      quotaLimit: 'number',
      quotaPackage: 'number',
      quotaUsed: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorBrowser extends $tea.Model {
  /**
   * @remarks
   * The total quota of browser detection tasks.
   * 
   * @example
   * 50
   */
  quotaLimit?: number;
  /**
   * @remarks
   * The quota of browser detection tasks in your resource plan.
   * 
   * @example
   * 50
   */
  quotaPackage?: number;
  /**
   * @remarks
   * The used quota of browser detection tasks in your resource plan.
   * 
   * @example
   * 15
   */
  quotaUsed?: number;
  static names(): { [key: string]: string } {
    return {
      quotaLimit: 'QuotaLimit',
      quotaPackage: 'QuotaPackage',
      quotaUsed: 'QuotaUsed',
    };
  }

  static types(): { [key: string]: any } {
    return {
      quotaLimit: 'number',
      quotaPackage: 'number',
      quotaUsed: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorEcsProbe extends $tea.Model {
  /**
   * @remarks
   * The total quota of ECS detection points for site monitoring.
   * 
   * > The value indicates the maximum number of ECS detection points that you can select for a site monitoring task.
   * 
   * @example
   * 5
   */
  quotaLimit?: number;
  /**
   * @remarks
   * The quota of ECS detection points for site monitoring in your resource plan.
   * 
   * @example
   * 5
   */
  quotaPackage?: number;
  /**
   * @remarks
   * The used quota of ECS detection points for site monitoring in your resource plan.
   * 
   * > The value indicates the total number of ECS detection points that are used by existing site monitoring tasks.
   * 
   * @example
   * 20
   */
  quotaUsed?: number;
  static names(): { [key: string]: string } {
    return {
      quotaLimit: 'QuotaLimit',
      quotaPackage: 'QuotaPackage',
      quotaUsed: 'QuotaUsed',
    };
  }

  static types(): { [key: string]: any } {
    return {
      quotaLimit: 'number',
      quotaPackage: 'number',
      quotaUsed: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorMobile extends $tea.Model {
  /**
   * @remarks
   * The total quota of mobile detection tasks.
   * 
   * @example
   * 50
   */
  quotaLimit?: number;
  /**
   * @remarks
   * The quota of mobile detection tasks in your resource plan.
   * 
   * @example
   * 50
   */
  quotaPackage?: number;
  /**
   * @remarks
   * The used quota of mobile detection tasks in your resource plan.
   * 
   * @example
   * 15
   */
  quotaUsed?: number;
  static names(): { [key: string]: string } {
    return {
      quotaLimit: 'QuotaLimit',
      quotaPackage: 'QuotaPackage',
      quotaUsed: 'QuotaUsed',
    };
  }

  static types(): { [key: string]: any } {
    return {
      quotaLimit: 'number',
      quotaPackage: 'number',
      quotaUsed: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorOperatorProbe extends $tea.Model {
  /**
   * @remarks
   * The total quota of carrier detection points for site monitoring.
   * 
   * @example
   * 5
   */
  quotaLimit?: number;
  /**
   * @remarks
   * The quota of carrier detection points for site monitoring in your resource plan.
   * 
   * @example
   * 5
   */
  quotaPackage?: number;
  /**
   * @remarks
   * The used quota of carrier detection points for site monitoring in your resource plan.
   * 
   * @example
   * 0
   */
  quotaUsed?: number;
  static names(): { [key: string]: string } {
    return {
      quotaLimit: 'QuotaLimit',
      quotaPackage: 'QuotaPackage',
      quotaUsed: 'QuotaUsed',
    };
  }

  static types(): { [key: string]: any } {
    return {
      quotaLimit: 'number',
      quotaPackage: 'number',
      quotaUsed: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorTask extends $tea.Model {
  /**
   * @remarks
   * The total quota of site monitoring tasks.
   * 
   * @example
   * 25
   */
  quotaLimit?: number;
  /**
   * @remarks
   * The quota of site monitoring tasks in your resource plan.
   * 
   * @example
   * 20
   */
  quotaPackage?: number;
  /**
   * @remarks
   * The used quota of site monitoring tasks in your resource plan.
   * 
   * @example
   * 15
   */
  quotaUsed?: number;
  static names(): { [key: string]: string } {
    return {
      quotaLimit: 'QuotaLimit',
      quotaPackage: 'QuotaPackage',
      quotaUsed: 'QuotaUsed',
    };
  }

  static types(): { [key: string]: any } {
    return {
      quotaLimit: 'number',
      quotaPackage: 'number',
      quotaUsed: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuota extends $tea.Model {
  /**
   * @remarks
   * The details about the quota of API calls.
   */
  api?: DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaApi;
  /**
   * @remarks
   * The details about the quota for custom monitoring.
   */
  customMonitor?: DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaCustomMonitor;
  /**
   * @remarks
   * The details about the quota of Hybrid Cloud Monitoring.
   */
  enterpriseQuota?: DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaEnterpriseQuota;
  /**
   * @remarks
   * The details about the quota for event monitoring.
   */
  eventMonitor?: DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaEventMonitor;
  /**
   * @remarks
   * The time when the resource plan expires.
   * 
   * @example
   * 2021-02-28
   */
  expireTime?: string;
  /**
   * @remarks
   * The ID of the resource plan.
   * 
   * @example
   * cms_edition-cn-n6w20rn****
   */
  instanceId?: string;
  /**
   * @remarks
   * The details about the quota for log monitoring.
   */
  logMonitor?: DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaLogMonitor;
  /**
   * @remarks
   * The details about the quota of alert phone calls.
   */
  phone?: DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaPhone;
  /**
   * @remarks
   * The details about the quota of alert text messages.
   */
  SMS?: DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSMS;
  /**
   * @remarks
   * The quota of browser detection tasks.
   */
  siteMonitorBrowser?: DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorBrowser;
  /**
   * @remarks
   * The details about the quota of ECS detection points for site monitoring.
   */
  siteMonitorEcsProbe?: DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorEcsProbe;
  /**
   * @remarks
   * The quota of mobile detection tasks.
   */
  siteMonitorMobile?: DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorMobile;
  /**
   * @remarks
   * The details about the quota of carrier detection points for site monitoring.
   */
  siteMonitorOperatorProbe?: DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorOperatorProbe;
  /**
   * @remarks
   * The quota of site monitoring tasks.
   */
  siteMonitorTask?: DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorTask;
  /**
   * @remarks
   * The current edition of CloudMonitor. Valid values:
   * 
   * *   free: Free Edition
   * *   pro: Pro Edition
   * *   cms_post: pay-as-you-go
   * 
   * @example
   * pro
   */
  suitInfo?: string;
  static names(): { [key: string]: string } {
    return {
      api: 'Api',
      customMonitor: 'CustomMonitor',
      enterpriseQuota: 'EnterpriseQuota',
      eventMonitor: 'EventMonitor',
      expireTime: 'ExpireTime',
      instanceId: 'InstanceId',
      logMonitor: 'LogMonitor',
      phone: 'Phone',
      SMS: 'SMS',
      siteMonitorBrowser: 'SiteMonitorBrowser',
      siteMonitorEcsProbe: 'SiteMonitorEcsProbe',
      siteMonitorMobile: 'SiteMonitorMobile',
      siteMonitorOperatorProbe: 'SiteMonitorOperatorProbe',
      siteMonitorTask: 'SiteMonitorTask',
      suitInfo: 'SuitInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      api: DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaApi,
      customMonitor: DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaCustomMonitor,
      enterpriseQuota: DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaEnterpriseQuota,
      eventMonitor: DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaEventMonitor,
      expireTime: 'string',
      instanceId: 'string',
      logMonitor: DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaLogMonitor,
      phone: DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaPhone,
      SMS: DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSMS,
      siteMonitorBrowser: DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorBrowser,
      siteMonitorEcsProbe: DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorEcsProbe,
      siteMonitorMobile: DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorMobile,
      siteMonitorOperatorProbe: DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorOperatorProbe,
      siteMonitorTask: DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorTask,
      suitInfo: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitoringAgentHostsResponseBodyHostsHost extends $tea.Model {
  /**
   * @remarks
   * The version of the CloudMonitor agent.
   * 
   * @example
   * 3.4.6
   */
  agentVersion?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account.
   * 
   * @example
   * 103201326074****
   */
  aliUid?: number;
  /**
   * @remarks
   * The elastic IP address (EIP) of the host.
   * 
   * @example
   * 192.168.XX.XX
   */
  eipAddress?: string;
  /**
   * @remarks
   * The ID of the EIP.
   * 
   * @example
   * eip-bp16i16k9gcezyfrp****
   */
  eipId?: string;
  /**
   * @remarks
   * The name of the host.
   * 
   * @example
   * hostIP
   */
  hostName?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * i-a2d5q7pm3f9yr212****
   */
  instanceId?: string;
  /**
   * @remarks
   * The type of the ECS instance.
   * 
   * @example
   * ecs.n4
   */
  instanceTypeFamily?: string;
  /**
   * @remarks
   * The IP address of the host.
   * 
   * > Multiple IP addresses are separated with commas (,).
   * 
   * @example
   * 192.168.XX.XX
   */
  ipGroup?: string;
  /**
   * @remarks
   * The IP address of the Network Address Translation (NAT) gateway.
   * 
   * @example
   * 192.168.XX.XX
   */
  natIp?: string;
  /**
   * @remarks
   * The network type.
   * 
   * @example
   * vpc
   */
  networkType?: string;
  /**
   * @remarks
   * The operating system.
   * 
   * @example
   * Linux
   */
  operatingSystem?: string;
  /**
   * @remarks
   * The ID of the region.
   * 
   * @example
   * cn-hangzhou
   */
  region?: string;
  /**
   * @remarks
   * The serial number of the host. A host that is not provided by Alibaba Cloud has a serial number instead of an instance ID.
   * 
   * > This parameter can be used to accurately search for a monitored host.
   * 
   * @example
   * x12335-6cc8-4a22-9f21-1a00a719****
   */
  serialNumber?: string;
  /**
   * @remarks
   * Indicates whether the host is provided by Alibaba Cloud. Valid values:
   * 
   * *   true: The host is provided by Alibaba Cloud.
   * *   false: The host is not provided by Alibaba Cloud.
   * 
   * @example
   * true
   */
  isAliyunHost?: boolean;
  static names(): { [key: string]: string } {
    return {
      agentVersion: 'AgentVersion',
      aliUid: 'AliUid',
      eipAddress: 'EipAddress',
      eipId: 'EipId',
      hostName: 'HostName',
      instanceId: 'InstanceId',
      instanceTypeFamily: 'InstanceTypeFamily',
      ipGroup: 'IpGroup',
      natIp: 'NatIp',
      networkType: 'NetworkType',
      operatingSystem: 'OperatingSystem',
      region: 'Region',
      serialNumber: 'SerialNumber',
      isAliyunHost: 'isAliyunHost',
    };
  }

  static types(): { [key: string]: any } {
    return {
      agentVersion: 'string',
      aliUid: 'number',
      eipAddress: 'string',
      eipId: 'string',
      hostName: 'string',
      instanceId: 'string',
      instanceTypeFamily: 'string',
      ipGroup: 'string',
      natIp: 'string',
      networkType: 'string',
      operatingSystem: 'string',
      region: 'string',
      serialNumber: 'string',
      isAliyunHost: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitoringAgentHostsResponseBodyHosts extends $tea.Model {
  host?: DescribeMonitoringAgentHostsResponseBodyHostsHost[];
  static names(): { [key: string]: string } {
    return {
      host: 'Host',
    };
  }

  static types(): { [key: string]: any } {
    return {
      host: { 'type': 'array', 'itemType': DescribeMonitoringAgentHostsResponseBodyHostsHost },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitoringAgentProcessesResponseBodyNodeProcessesNodeProcess extends $tea.Model {
  /**
   * @remarks
   * The command used to obtain the number of processes. Valid value: `number`.
   * 
   * >  The `number` command obtains the number of processes that match the condition.
   * 
   * @example
   * number
   */
  command?: string;
  /**
   * @remarks
   * The ID of the application group.
   * 
   * @example
   * 3619****
   */
  groupId?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * i-hp3hl3cx1pbahzy8****
   */
  instanceId?: string;
  /**
   * @remarks
   * The ID of the process.
   * 
   * @example
   * 234567
   */
  processId?: number;
  /**
   * @remarks
   * The name of the process.
   * 
   * @example
   * Nginx
   */
  processName?: string;
  /**
   * @remarks
   * The user who launched the process.
   * 
   * @example
   * alice
   */
  processUser?: string;
  static names(): { [key: string]: string } {
    return {
      command: 'Command',
      groupId: 'GroupId',
      instanceId: 'InstanceId',
      processId: 'ProcessId',
      processName: 'ProcessName',
      processUser: 'ProcessUser',
    };
  }

  static types(): { [key: string]: any } {
    return {
      command: 'string',
      groupId: 'string',
      instanceId: 'string',
      processId: 'number',
      processName: 'string',
      processUser: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitoringAgentProcessesResponseBodyNodeProcesses extends $tea.Model {
  nodeProcess?: DescribeMonitoringAgentProcessesResponseBodyNodeProcessesNodeProcess[];
  static names(): { [key: string]: string } {
    return {
      nodeProcess: 'NodeProcess',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeProcess: { 'type': 'array', 'itemType': DescribeMonitoringAgentProcessesResponseBodyNodeProcessesNodeProcess },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitoringAgentStatusesResponseBodyNodeStatusListNodeStatus extends $tea.Model {
  /**
   * @remarks
   * The error code returned when the CloudMonitor agent is installed. Valid values:
   * 
   * *   Common.Timeout: The installation timed out.
   * *   Common.SLR: The service-linked role for CloudMonitor is unauthorized.
   * *   Common.OS: The operating system is not supported.
   * *   Assist.Invalid: Cloud Assistant is not running.
   * *   Assist.Invoke: An error occurred when the installation program is started.
   * *   Assist.Execute: An error occurred when the installation program is running.
   */
  agentInstallErrorCode?: string;
  /**
   * @remarks
   * Indicates whether the CloudMonitor agent is automatically installed. Valid values:
   * 
   * *   true: The CloudMonitor agent is automatically installed.
   * *   false: The CloudMonitor agent is not automatically installed.
   * 
   * @example
   * true
   */
  autoInstall?: boolean;
  /**
   * @remarks
   * The instance ID.
   * 
   * @example
   * i-hp3dunahluwajv6f****
   */
  instanceId?: string;
  /**
   * @remarks
   * Indicates whether the SysAK monitoring feature is enabled.`` Valid values:
   * 
   * *   `true`: The SysAK monitoring feature is enabled.
   * *   `false`: the SysAK monitoring feature is disabled.
   * 
   * @example
   * {"sysak":true}
   */
  osMonitorConfig?: string;
  /**
   * @remarks
   * The error status of SysOM. Valid values:
   * 
   * *   `install_fail`: SysOM fails to be installed or an unknown error occurs.
   * *   `install_assist_invalid`: SysOM fails to be installed because the status of Cloud Assistant is invalid.
   * *   `install_assist_command_fail`: SysOM fails to be installed because the installation command fails to run.
   * *   `uninstall_fail`: SysOM fails to be uninstalled or an unknown error occurs.
   * *   `uninstall_assist_invalid`: SysOM fails to be uninstalled because the status of Cloud Assistant is invalid.
   * *   `uninstall_assist_command_fail`: SysOM fails to be uninstalled because the uninstallation command fails to run.
   * 
   * @example
   * install_fail
   */
  osMonitorErrorCode?: string;
  /**
   * @remarks
   * The details of the execution error. Valid values:
   * 
   * *   `Command.ErrorCode.Fail.Downlaod.REGIN_ID`: Failed to obtain the region ID.
   * *   `Command.ErrorCode.Fail.Downlaod.SYSAK`: Failed to download the .rpm package of System Analyse Kit (SysAK).
   * *   `Command.ErrorCode.Fail.Downlaod.CMON_FILE`: Failed to download the CMON file.
   * *   `Command.ErrorCode.Fail.Downlaod.BTF`: Failed to start SysAK because the BTF file is not found.
   * *   `Command.ErrorCode.Fail.Start.SYSAK`: Failed to start SysAK due to an unknown error.
   * 
   * @example
   * Command.ErrorCode.Fail.Downlaod.REGIN_ID
   */
  osMonitorErrorDetail?: string;
  /**
   * @remarks
   * The status of SysOM. Valid values:
   * 
   * *   installing: SysOM is being installed.
   * *   running: SysOM is running.
   * *   stopped: SysOM is stopped.
   * *   uninstalling: SysOM is being uninstalled.
   * 
   * @example
   * running
   */
  osMonitorStatus?: string;
  /**
   * @remarks
   * The SysOM version.
   * 
   * @example
   * 1.3.0-12
   */
  osMonitorVersion?: string;
  /**
   * @remarks
   * The status of the CloudMonitor agent. Valid values:
   * 
   * *   running: The CloudMonitor agent is running.
   * *   stopped: The CloudMonitor agent is stopped.
   * *   installing: The CloudMonitor agent is being installed.
   * *   install_faild: The CloudMonitor agent fails to be installed.
   * *   abnormal: The CloudMonitor agent is not properly installed.
   * *   not_installed: The CloudMonitor agent is not installed.
   * 
   * @example
   * running
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      agentInstallErrorCode: 'AgentInstallErrorCode',
      autoInstall: 'AutoInstall',
      instanceId: 'InstanceId',
      osMonitorConfig: 'OsMonitorConfig',
      osMonitorErrorCode: 'OsMonitorErrorCode',
      osMonitorErrorDetail: 'OsMonitorErrorDetail',
      osMonitorStatus: 'OsMonitorStatus',
      osMonitorVersion: 'OsMonitorVersion',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      agentInstallErrorCode: 'string',
      autoInstall: 'boolean',
      instanceId: 'string',
      osMonitorConfig: 'string',
      osMonitorErrorCode: 'string',
      osMonitorErrorDetail: 'string',
      osMonitorStatus: 'string',
      osMonitorVersion: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitoringAgentStatusesResponseBodyNodeStatusList extends $tea.Model {
  nodeStatus?: DescribeMonitoringAgentStatusesResponseBodyNodeStatusListNodeStatus[];
  static names(): { [key: string]: string } {
    return {
      nodeStatus: 'NodeStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeStatus: { 'type': 'array', 'itemType': DescribeMonitoringAgentStatusesResponseBodyNodeStatusListNodeStatus },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProductResourceTagKeyListResponseBodyTagKeys extends $tea.Model {
  tagKey?: string[];
  static names(): { [key: string]: string } {
    return {
      tagKey: 'TagKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagKey: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProductsOfActiveMetricRuleResponseBodyAllProductInitMetricRuleListAllProductInitMetricRuleAlertInitConfigListAlertInitConfig extends $tea.Model {
  /**
   * @remarks
   * The operator that is used to compare the metric value with the threshold for Warn-level alerts.
   * 
   * Valid values:
   * 
   * *   LessThanThreshold: less than the threshold
   * 
   * *   GreaterThanLastWeek: greater than the metric value at the same time last week
   * 
   * *   LessThanOrEqualToThreshold: less than or equal to the threshold
   * 
   * *   NotEqualToThreshold: does not equal to the threshold
   * 
   * *   GreaterThanLastPeriod: greater than the metric value in the last monitoring cycle
   * 
   * *   GreaterThanYesterday: greater than the metric value at the same time yesterday
   * 
   * *   LessThanYesterday: less than the metric value at the same time yesterday
   * 
   * *   LessThanLastWeek: less than the metric value at the same time last week
   * 
   * *   GreaterThanOrEqualToThreshold: greater than or equal to the threshold
   * 
   * *   GreaterThanThreshold: greater than the threshold
   * 
   * *   LessThanLastPeriod: less than the metric value in the last monitoring cycle
   * 
   * @example
   * GreaterThanOrEqualToThreshold
   */
  comparisonOperator?: string;
  /**
   * @remarks
   * The consecutive number of times for which the metric value meets the alert condition before an alert is triggered.
   * 
   * @example
   * 3
   */
  evaluationCount?: string;
  /**
   * @remarks
   * The alert level.
   * 
   * Valid values:
   * 
   * *   INFO
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   * *   WARN
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   * *   CRITICAL
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   * @example
   * CRITICAL
   */
  level?: string;
  /**
   * @remarks
   * The metric name. For more information, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * @example
   * cpu_total
   */
  metricName?: string;
  /**
   * @remarks
   * The namespace of the service. For more information, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * @example
   * acs_rds_dashboard
   */
  namespace?: string;
  /**
   * @remarks
   * The aggregation period of monitoring data. Unit: minutes. For more information, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * @example
   * 1m
   */
  period?: string;
  /**
   * @remarks
   * The method used to calculate metric values that trigger alerts. For more information, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * @example
   * Average
   */
  statistics?: string;
  /**
   * @remarks
   * The alert threshold.
   * 
   * @example
   * 90
   */
  threshold?: string;
  static names(): { [key: string]: string } {
    return {
      comparisonOperator: 'ComparisonOperator',
      evaluationCount: 'EvaluationCount',
      level: 'Level',
      metricName: 'MetricName',
      namespace: 'Namespace',
      period: 'Period',
      statistics: 'Statistics',
      threshold: 'Threshold',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comparisonOperator: 'string',
      evaluationCount: 'string',
      level: 'string',
      metricName: 'string',
      namespace: 'string',
      period: 'string',
      statistics: 'string',
      threshold: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProductsOfActiveMetricRuleResponseBodyAllProductInitMetricRuleListAllProductInitMetricRuleAlertInitConfigList extends $tea.Model {
  alertInitConfig?: DescribeProductsOfActiveMetricRuleResponseBodyAllProductInitMetricRuleListAllProductInitMetricRuleAlertInitConfigListAlertInitConfig[];
  static names(): { [key: string]: string } {
    return {
      alertInitConfig: 'AlertInitConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertInitConfig: { 'type': 'array', 'itemType': DescribeProductsOfActiveMetricRuleResponseBodyAllProductInitMetricRuleListAllProductInitMetricRuleAlertInitConfigListAlertInitConfig },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProductsOfActiveMetricRuleResponseBodyAllProductInitMetricRuleListAllProductInitMetricRule extends $tea.Model {
  /**
   * @remarks
   * The initial alert rules that are generated after one-click alert is enabled for a service.
   */
  alertInitConfigList?: DescribeProductsOfActiveMetricRuleResponseBodyAllProductInitMetricRuleListAllProductInitMetricRuleAlertInitConfigList;
  /**
   * @remarks
   * The abbreviation of the service name.
   * 
   * @example
   * ecs
   */
  product?: string;
  static names(): { [key: string]: string } {
    return {
      alertInitConfigList: 'AlertInitConfigList',
      product: 'Product',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertInitConfigList: DescribeProductsOfActiveMetricRuleResponseBodyAllProductInitMetricRuleListAllProductInitMetricRuleAlertInitConfigList,
      product: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProductsOfActiveMetricRuleResponseBodyAllProductInitMetricRuleList extends $tea.Model {
  allProductInitMetricRule?: DescribeProductsOfActiveMetricRuleResponseBodyAllProductInitMetricRuleListAllProductInitMetricRule[];
  static names(): { [key: string]: string } {
    return {
      allProductInitMetricRule: 'AllProductInitMetricRule',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allProductInitMetricRule: { 'type': 'array', 'itemType': DescribeProductsOfActiveMetricRuleResponseBodyAllProductInitMetricRuleListAllProductInitMetricRule },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectMetaResponseBodyResourcesResource extends $tea.Model {
  /**
   * @remarks
   * The description.
   * 
   * @example
   * CDN
   */
  description?: string;
  /**
   * @remarks
   * The tags. Tags are used to filter services.
   * 
   * Tags are returned in the following format: `[{"name":"Tag key","value":"Tag value"}, {"name":"Tag key","value":"Tag value"}]`. The following tags are commonly used:
   * 
   * *   alertUnit: the unit of the metric value in alerts. If the unit is small, the original metric value may be too large. In this case, you can use the `alertUnit` tag to specify an appropriate unit. This tag is used in CloudMonitor.
   * *   minAlertPeriod: the minimum time interval to report a new alert. The interval at which monitoring data is reported. The value is usually 1 minute.
   * *   metricCategory: the service specification. Example: kvstore_sharding. Some Alibaba Cloud services have multiple specifications that are defined in the same namespace. This parameter is used to identify the specifications.
   * *   is_alarm: indicates whether an alert rule can be configured. We recommend that you do not use the special tags in the CloudMonitor console.
   * 
   * @example
   * [{"groupFlag":true}]
   */
  labels?: string;
  /**
   * @remarks
   * The namespace of the cloud service. Format: `acs_Service name abbreviation`. For more information about namespaces, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * @example
   * acs_cdn
   */
  namespace?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      labels: 'Labels',
      namespace: 'Namespace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      labels: 'string',
      namespace: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectMetaResponseBodyResources extends $tea.Model {
  resource?: DescribeProjectMetaResponseBodyResourcesResource[];
  static names(): { [key: string]: string } {
    return {
      resource: 'Resource',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resource: { 'type': 'array', 'itemType': DescribeProjectMetaResponseBodyResourcesResource },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSiteMonitorAttributeResponseBodyMetricRulesMetricRule extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the alert rule is enabled. Valid values:
   * 
   * *   true: The alert rule is enabled.
   * *   false: The alert rule is disabled.
   * 
   * @example
   * true
   */
  actionEnable?: string;
  /**
   * @remarks
   * The alert contact group to which alert notifications are sent.
   * 
   * @example
   * CloudMonitor
   */
  alarmActions?: string;
  /**
   * @remarks
   * The operator that is used to compare the metric value with the threshold in the alert rule. Valid values:
   * 
   * *   `>=`
   * *   `>`
   * *   `<=`
   * *   `<`
   * *   `=`
   * *   `!=`
   * *   GreaterThanYesterday: greater than the metric value at the same time yesterday
   * *   LessThanYesterday: less than the metric value at the same time yesterday
   * *   GreaterThanLastWeek: greater than the metric value at the same time last week
   * *   LessThanLastWeek: less than the metric value at the same time last week
   * *   GreaterThanLastPeriod: greater than the metric value in the last monitoring cycle
   * *   LessThanLastPeriod: less than the metric value in the last monitoring cycle
   * 
   * @example
   * GreaterThanYesterday
   */
  comparisonOperator?: string;
  /**
   * @remarks
   * The dimension of the alert rule.
   * 
   * @example
   * [{"taskId": "cc641dff-c19d-45f3-ad0a-818a0c4f****" }]
   */
  dimensions?: string;
  /**
   * @remarks
   * The consecutive number of times for which the metric value meets the alert condition before an alert is triggered.
   * 
   * @example
   * 3
   */
  evaluationCount?: string;
  /**
   * @remarks
   * The expression that is used to trigger alerts.
   * 
   * @example
   * $Availability=30
   */
  expression?: string;
  /**
   * @remarks
   * The alert severity. Valid values:
   * 
   * *   1: critical
   * *   2: warning
   * *   3: information
   * 
   * @example
   * 2
   */
  level?: string;
  /**
   * @remarks
   * The metric name.
   * 
   * @example
   * Availability
   */
  metricName?: string;
  /**
   * @remarks
   * The namespace of the cloud service.
   * 
   * The value is in the following format: acs_service name.
   * 
   * @example
   * acs_networkmonitor
   */
  namespace?: string;
  /**
   * @remarks
   * The alert contact group that receives alert notifications.
   * 
   * @example
   * [ "CloudMonitor"]
   */
  okActions?: string;
  /**
   * @remarks
   * The time interval. The value is the same as the interval at which metric data is reported. Unit: seconds.
   * 
   * >  If you specify a statistical period for the alert rule, data is queried based on the statistical period.
   * 
   * @example
   * 15s
   */
  period?: string;
  /**
   * @remarks
   * The ID of the alert rule.
   * 
   * @example
   * bf071ae_7b7aec3817b0fdf****
   */
  ruleId?: string;
  /**
   * @remarks
   * The name of the alert rule.
   * 
   * @example
   * rule1
   */
  ruleName?: string;
  /**
   * @remarks
   * The alert status. Valid values:
   * 
   * *   OK: The alert rule has no active alerts.
   * *   ALARM: The alert rule has active alerts.
   * 
   * @example
   * OK
   */
  stateValue?: string;
  /**
   * @remarks
   * The statistical method of the alert rule. Valid values:
   * 
   * *   Availability: the percentage of available detection points
   * *   AvailableNumber: the number of available detection points
   * *   ErrorCodeMaximum: a status code for an alert
   * *   ErrorCodeMinimum: all status codes for a set of alerts
   * *   Average: response time
   * 
   * @example
   * Availability
   */
  statistics?: string;
  /**
   * @remarks
   * The alert threshold.
   * 
   * @example
   * 30
   */
  threshold?: string;
  static names(): { [key: string]: string } {
    return {
      actionEnable: 'ActionEnable',
      alarmActions: 'AlarmActions',
      comparisonOperator: 'ComparisonOperator',
      dimensions: 'Dimensions',
      evaluationCount: 'EvaluationCount',
      expression: 'Expression',
      level: 'Level',
      metricName: 'MetricName',
      namespace: 'Namespace',
      okActions: 'OkActions',
      period: 'Period',
      ruleId: 'RuleId',
      ruleName: 'RuleName',
      stateValue: 'StateValue',
      statistics: 'Statistics',
      threshold: 'Threshold',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actionEnable: 'string',
      alarmActions: 'string',
      comparisonOperator: 'string',
      dimensions: 'string',
      evaluationCount: 'string',
      expression: 'string',
      level: 'string',
      metricName: 'string',
      namespace: 'string',
      okActions: 'string',
      period: 'string',
      ruleId: 'string',
      ruleName: 'string',
      stateValue: 'string',
      statistics: 'string',
      threshold: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSiteMonitorAttributeResponseBodyMetricRules extends $tea.Model {
  metricRule?: DescribeSiteMonitorAttributeResponseBodyMetricRulesMetricRule[];
  static names(): { [key: string]: string } {
    return {
      metricRule: 'MetricRule',
    };
  }

  static types(): { [key: string]: any } {
    return {
      metricRule: { 'type': 'array', 'itemType': DescribeSiteMonitorAttributeResponseBodyMetricRulesMetricRule },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSiteMonitorAttributeResponseBodySiteMonitorsCustomScheduleDays extends $tea.Model {
  days?: number[];
  static names(): { [key: string]: string } {
    return {
      days: 'days',
    };
  }

  static types(): { [key: string]: any } {
    return {
      days: { 'type': 'array', 'itemType': 'number' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSiteMonitorAttributeResponseBodySiteMonitorsCustomSchedule extends $tea.Model {
  days?: DescribeSiteMonitorAttributeResponseBodySiteMonitorsCustomScheduleDays;
  /**
   * @example
   * 18
   */
  endHour?: number;
  /**
   * @example
   * 8
   */
  startHour?: number;
  /**
   * @example
   * local
   */
  timeZone?: string;
  static names(): { [key: string]: string } {
    return {
      days: 'days',
      endHour: 'end_hour',
      startHour: 'start_hour',
      timeZone: 'time_zone',
    };
  }

  static types(): { [key: string]: any } {
    return {
      days: DescribeSiteMonitorAttributeResponseBodySiteMonitorsCustomScheduleDays,
      endHour: 'number',
      startHour: 'number',
      timeZone: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSiteMonitorAttributeResponseBodySiteMonitorsIspCitiesIspCity extends $tea.Model {
  /**
   * @remarks
   * The city ID.
   * 
   * @example
   * 738
   */
  city?: string;
  /**
   * @remarks
   * The city name.
   */
  cityName?: string;
  /**
   * @remarks
   * The carrier ID.
   * 
   * @example
   * 465
   */
  isp?: string;
  /**
   * @remarks
   * The carrier name.
   */
  ispName?: string;
  static names(): { [key: string]: string } {
    return {
      city: 'City',
      cityName: 'CityName',
      isp: 'Isp',
      ispName: 'IspName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      city: 'string',
      cityName: 'string',
      isp: 'string',
      ispName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSiteMonitorAttributeResponseBodySiteMonitorsIspCities extends $tea.Model {
  ispCity?: DescribeSiteMonitorAttributeResponseBodySiteMonitorsIspCitiesIspCity[];
  static names(): { [key: string]: string } {
    return {
      ispCity: 'IspCity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ispCity: { 'type': 'array', 'itemType': DescribeSiteMonitorAttributeResponseBodySiteMonitorsIspCitiesIspCity },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonAssertionsAssertions extends $tea.Model {
  /**
   * @example
   * lessThan
   */
  operator?: string;
  /**
   * @example
   * json path
   */
  property?: string;
  /**
   * @example
   * 0
   */
  target?: string;
  /**
   * @example
   * response_time
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      operator: 'operator',
      property: 'property',
      target: 'target',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      operator: 'string',
      property: 'string',
      target: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonAssertions extends $tea.Model {
  assertions?: DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonAssertionsAssertions[];
  static names(): { [key: string]: string } {
    return {
      assertions: 'assertions',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assertions: { 'type': 'array', 'itemType': DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonAssertionsAssertions },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBlockedUrlList extends $tea.Model {
  blockedUrlList?: string[];
  static names(): { [key: string]: string } {
    return {
      blockedUrlList: 'blocked_url_list',
    };
  }

  static types(): { [key: string]: any } {
    return {
      blockedUrlList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBrowserHeaders extends $tea.Model {
  browserHeaders?: { [key: string]: any }[];
  static names(): { [key: string]: string } {
    return {
      browserHeaders: 'browser_headers',
    };
  }

  static types(): { [key: string]: any } {
    return {
      browserHeaders: { 'type': 'array', 'itemType': { 'type': 'map', 'keyType': 'string', 'valueType': 'any' } },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBrowserHosts extends $tea.Model {
  browserHosts?: string[];
  static names(): { [key: string]: string } {
    return {
      browserHosts: 'browser_hosts',
    };
  }

  static types(): { [key: string]: any } {
    return {
      browserHosts: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBrowserInfoBrowserInfo extends $tea.Model {
  /**
   * @example
   * Chrome
   */
  browser?: string;
  /**
   * @example
   * laptop
   */
  device?: string;
  static names(): { [key: string]: string } {
    return {
      browser: 'browser',
      device: 'device',
    };
  }

  static types(): { [key: string]: any } {
    return {
      browser: 'string',
      device: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBrowserInfo extends $tea.Model {
  browserInfo?: DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBrowserInfoBrowserInfo[];
  static names(): { [key: string]: string } {
    return {
      browserInfo: 'browser_info',
    };
  }

  static types(): { [key: string]: any } {
    return {
      browserInfo: { 'type': 'array', 'itemType': DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBrowserInfoBrowserInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonExpectExistString extends $tea.Model {
  expectExistString?: string[];
  static names(): { [key: string]: string } {
    return {
      expectExistString: 'expect_exist_string',
    };
  }

  static types(): { [key: string]: any } {
    return {
      expectExistString: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonExpectNonExistString extends $tea.Model {
  expectNonExistString?: string[];
  static names(): { [key: string]: string } {
    return {
      expectNonExistString: 'expect_non_exist_string',
    };
  }

  static types(): { [key: string]: any } {
    return {
      expectNonExistString: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonQuicTarget extends $tea.Model {
  quicTarget?: string[];
  static names(): { [key: string]: string } {
    return {
      quicTarget: 'quic_target',
    };
  }

  static types(): { [key: string]: any } {
    return {
      quicTarget: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonTrafficHijackElementBlacklist extends $tea.Model {
  trafficHijackElementBlacklist?: string[];
  static names(): { [key: string]: string } {
    return {
      trafficHijackElementBlacklist: 'traffic_hijack_element_blacklist',
    };
  }

  static types(): { [key: string]: any } {
    return {
      trafficHijackElementBlacklist: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonTrafficHijackElementWhitelist extends $tea.Model {
  trafficHijackElementWhitelist?: string[];
  static names(): { [key: string]: string } {
    return {
      trafficHijackElementWhitelist: 'traffic_hijack_element_whitelist',
    };
  }

  static types(): { [key: string]: any } {
    return {
      trafficHijackElementWhitelist: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJson extends $tea.Model {
  assertions?: DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonAssertions;
  /**
   * @remarks
   * The number of retries after a DNS failure occurred.
   * 
   * @example
   * 3
   */
  attempts?: number;
  /**
   * @remarks
   * Indicates whether the security authentication feature is enabled. Valid values:
   * 
   * *   0: The feature is disabled.
   * *   1: The feature is enabled.
   * 
   * @example
   * 1
   */
  authentication?: number;
  blockedUrlList?: DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBlockedUrlList;
  browserHeaders?: DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBrowserHeaders;
  browserHosts?: DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBrowserHosts;
  browserInfo?: DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBrowserInfo;
  /**
   * @example
   * false
   */
  browserInsecure?: boolean;
  /**
   * @example
   * 1
   */
  browserTaskVersion?: string;
  /**
   * @remarks
   * The cookie of the HTTP request.
   * 
   * @example
   * lang=en
   */
  cookie?: string;
  /**
   * @example
   * false
   */
  diagnosisMtr?: boolean;
  /**
   * @example
   * false
   */
  diagnosisPing?: boolean;
  /**
   * @example
   * www.taobao.com:www.taobao.com.danuoyi.tbcache.com
   */
  dnsHijackWhitelist?: string;
  /**
   * @remarks
   * The relationship between the list of expected aliases or IP addresses and the list of DNS results. Valid values:
   * 
   * *   IN_DNS: The list of expected values is a subset of the list of DNS results.
   * *   DNS_IN: The list of DNS results is a subset of the list of expected values.
   * *   EQUAL: The list of DNS results is the same as the list of expected values.
   * *   ANY: The list of DNS results intersects with the list of expected values.
   * 
   * @example
   * IN_DNS
   */
  dnsMatchRule?: string;
  /**
   * @remarks
   * The IP address of the DNS server.
   * 
   * >  This parameter is returned only if the TaskType parameter is set to DNS.
   * 
   * @example
   * 192.168.XX.XX
   */
  dnsServer?: string;
  /**
   * @remarks
   * The type of the DNS record. This parameter is returned only if the TaskType parameter is set to DNS. Valid values:
   * 
   * *   A (default): a record that specifies an IP address related to the specified host name or domain name.
   * *   CNAME: a record that maps multiple domain names to a domain name.
   * *   NS: a record that specifies a DNS server used to parse domain names.
   * *   MX: a record that links domain names to the address of a mail server.
   * *   TXT: a record that stores the text information of host name or domain names. The text must be 1 to 512 bytes in length. The TXT record serves as a Sender Policy Framework (SPF) record to fight against spam.
   * 
   * @example
   * A
   */
  dnsType?: string;
  emptyMessage?: boolean;
  expectExistString?: DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonExpectExistString;
  expectNonExistString?: DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonExpectNonExistString;
  /**
   * @remarks
   * The domain name or alias to be parsed.
   * 
   * >  This parameter is returned only if the TaskType parameter is set to DNS.
   * 
   * @example
   * dns_server
   */
  expectValue?: string;
  /**
   * @remarks
   * The packet loss rate.
   * 
   * >  This parameter is returned only if the TaskType parameter is set to PING.
   * 
   * @example
   * 0.4
   */
  failureRate?: number;
  /**
   * @remarks
   * The header of the HTTP request.
   * 
   * @example
   * testKey:testValue
   */
  header?: string;
  /**
   * @remarks
   * The HTTP request method. Valid values:
   * 
   * *   get
   * *   post
   * *   head
   * 
   * @example
   * get
   */
  httpMethod?: string;
  ipNetwork?: string;
  /**
   * @example
   * true
   */
  isBase64Encode?: string;
  /**
   * @remarks
   * Indicates whether the alert rule is included. Valid values:
   * 
   * *   0: The alert rule is included.
   * *   1: The alert rule is excluded.
   * 
   * @example
   * 1
   */
  matchRule?: number;
  /**
   * @example
   * tlsv1.2
   */
  minTlsVersion?: string;
  /**
   * @remarks
   * The password of the SMTP, POP3, or FTP protocol.
   * 
   * @example
   * 123****
   */
  password?: string;
  /**
   * @remarks
   * The heartbeat of the PING protocol.
   * 
   * @example
   * 29
   */
  pingNum?: number;
  /**
   * @example
   * 80
   */
  pingPort?: number;
  /**
   * @example
   * icmp,tcp,udp
   */
  pingType?: string;
  /**
   * @remarks
   * The port number of the TCP, UDP, SMTP, or POP3 protocol.
   * 
   * @example
   * 110
   */
  port?: number;
  /**
   * @remarks
   * The protocol that is used to send the request.
   * 
   * @example
   * TCP
   */
  protocol?: string;
  quicEnabled?: boolean;
  quicTarget?: DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonQuicTarget;
  /**
   * @remarks
   * The content of the HTTP request.
   * 
   * @example
   * aa=bb
   */
  requestContent?: string;
  /**
   * @remarks
   * The format of the HTTP request. Valid values:
   * 
   * *   hex: hexadecimal
   * *   txt: text
   * 
   * @example
   * txt
   */
  requestFormat?: string;
  /**
   * @remarks
   * The response to the HTTP request.
   * 
   * @example
   * txt
   */
  responseContent?: string;
  /**
   * @remarks
   * The format of the HTTP response. Valid values:
   * 
   * *   hex: hexadecimal
   * *   txt: text
   * 
   * @example
   * txt
   */
  responseFormat?: string;
  /**
   * @example
   * 0
   */
  retryDelay?: number;
  /**
   * @example
   * false
   */
  strictMode?: boolean;
  /**
   * @remarks
   * The timeout period. Unit: milliseconds.
   * 
   * @example
   * 3
   */
  timeOut?: number;
  trafficHijackElementBlacklist?: DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonTrafficHijackElementBlacklist;
  /**
   * @example
   * 0
   */
  trafficHijackElementCount?: number;
  trafficHijackElementWhitelist?: DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonTrafficHijackElementWhitelist;
  /**
   * @remarks
   * The username of the FTP, SMTP, or POP3 protocol.
   * 
   * @example
   * testUser
   */
  username?: string;
  /**
   * @example
   * 3
   */
  waitTimeAfterCompletion?: number;
  static names(): { [key: string]: string } {
    return {
      assertions: 'assertions',
      attempts: 'attempts',
      authentication: 'authentication',
      blockedUrlList: 'blocked_url_list',
      browserHeaders: 'browser_headers',
      browserHosts: 'browser_hosts',
      browserInfo: 'browser_info',
      browserInsecure: 'browser_insecure',
      browserTaskVersion: 'browser_task_version',
      cookie: 'cookie',
      diagnosisMtr: 'diagnosis_mtr',
      diagnosisPing: 'diagnosis_ping',
      dnsHijackWhitelist: 'dns_hijack_whitelist',
      dnsMatchRule: 'dns_match_rule',
      dnsServer: 'dns_server',
      dnsType: 'dns_type',
      emptyMessage: 'empty_message',
      expectExistString: 'expect_exist_string',
      expectNonExistString: 'expect_non_exist_string',
      expectValue: 'expect_value',
      failureRate: 'failure_rate',
      header: 'header',
      httpMethod: 'http_method',
      ipNetwork: 'ip_network',
      isBase64Encode: 'isBase64Encode',
      matchRule: 'match_rule',
      minTlsVersion: 'min_tls_version',
      password: 'password',
      pingNum: 'ping_num',
      pingPort: 'ping_port',
      pingType: 'ping_type',
      port: 'port',
      protocol: 'protocol',
      quicEnabled: 'quic_enabled',
      quicTarget: 'quic_target',
      requestContent: 'request_content',
      requestFormat: 'request_format',
      responseContent: 'response_content',
      responseFormat: 'response_format',
      retryDelay: 'retry_delay',
      strictMode: 'strict_mode',
      timeOut: 'time_out',
      trafficHijackElementBlacklist: 'traffic_hijack_element_blacklist',
      trafficHijackElementCount: 'traffic_hijack_element_count',
      trafficHijackElementWhitelist: 'traffic_hijack_element_whitelist',
      username: 'username',
      waitTimeAfterCompletion: 'waitTime_after_completion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assertions: DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonAssertions,
      attempts: 'number',
      authentication: 'number',
      blockedUrlList: DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBlockedUrlList,
      browserHeaders: DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBrowserHeaders,
      browserHosts: DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBrowserHosts,
      browserInfo: DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBrowserInfo,
      browserInsecure: 'boolean',
      browserTaskVersion: 'string',
      cookie: 'string',
      diagnosisMtr: 'boolean',
      diagnosisPing: 'boolean',
      dnsHijackWhitelist: 'string',
      dnsMatchRule: 'string',
      dnsServer: 'string',
      dnsType: 'string',
      emptyMessage: 'boolean',
      expectExistString: DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonExpectExistString,
      expectNonExistString: DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonExpectNonExistString,
      expectValue: 'string',
      failureRate: 'number',
      header: 'string',
      httpMethod: 'string',
      ipNetwork: 'string',
      isBase64Encode: 'string',
      matchRule: 'number',
      minTlsVersion: 'string',
      password: 'string',
      pingNum: 'number',
      pingPort: 'number',
      pingType: 'string',
      port: 'number',
      protocol: 'string',
      quicEnabled: 'boolean',
      quicTarget: DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonQuicTarget,
      requestContent: 'string',
      requestFormat: 'string',
      responseContent: 'string',
      responseFormat: 'string',
      retryDelay: 'number',
      strictMode: 'boolean',
      timeOut: 'number',
      trafficHijackElementBlacklist: DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonTrafficHijackElementBlacklist,
      trafficHijackElementCount: 'number',
      trafficHijackElementWhitelist: DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonTrafficHijackElementWhitelist,
      username: 'string',
      waitTimeAfterCompletion: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSiteMonitorAttributeResponseBodySiteMonitorsVpcConfig extends $tea.Model {
  securityGroupId?: string;
  vpcId?: string;
  vswitchId?: string;
  static names(): { [key: string]: string } {
    return {
      securityGroupId: 'SecurityGroupId',
      vpcId: 'VpcId',
      vswitchId: 'VswitchId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      securityGroupId: 'string',
      vpcId: 'string',
      vswitchId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSiteMonitorAttributeResponseBodySiteMonitors extends $tea.Model {
  /**
   * @remarks
   * The URL that is monitored by the site monitoring task.
   * 
   * @example
   * https://aliyun.com
   */
  address?: string;
  /**
   * @example
   * PC
   */
  agentGroup?: string;
  customSchedule?: DescribeSiteMonitorAttributeResponseBodySiteMonitorsCustomSchedule;
  /**
   * @remarks
   * The interval at which the site monitoring task is executed. Unit: minutes. Valid values: 1, 5, 15, 30, and 60.
   * 
   * @example
   * 1
   */
  interval?: string;
  /**
   * @remarks
   * The information of detection points. The information includes the carriers that provide the detection points and the cities where the detection points reside.
   */
  ispCities?: DescribeSiteMonitorAttributeResponseBodySiteMonitorsIspCities;
  /**
   * @remarks
   * The extended options of the site monitoring task. The options vary based on the specified protocol. For more information, see [CreateSiteMonitor](https://help.aliyun.com/document_detail/115048.html).
   */
  optionJson?: DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJson;
  /**
   * @remarks
   * The ID of the site monitoring task.
   * 
   * @example
   * cc641dff-c19d-45f3-ad0a-818a0c4f****
   */
  taskId?: string;
  /**
   * @remarks
   * The name of the site monitoring task.
   * 
   * @example
   * test123
   */
  taskName?: string;
  /**
   * @remarks
   * The status of the site monitoring task. Valid values:
   * 
   * *   1: The task is enabled.
   * *   2: The task is disabled.
   * 
   * @example
   * 1
   */
  taskState?: string;
  /**
   * @remarks
   * The protocol that is used by the site monitoring task. Valid values: HTTP, HTTPS, PING, TCP, UDP, DNS, SMTP, POP3, and FTP.
   * 
   * @example
   * HTTP
   */
  taskType?: string;
  vpcConfig?: DescribeSiteMonitorAttributeResponseBodySiteMonitorsVpcConfig;
  static names(): { [key: string]: string } {
    return {
      address: 'Address',
      agentGroup: 'AgentGroup',
      customSchedule: 'CustomSchedule',
      interval: 'Interval',
      ispCities: 'IspCities',
      optionJson: 'OptionJson',
      taskId: 'TaskId',
      taskName: 'TaskName',
      taskState: 'TaskState',
      taskType: 'TaskType',
      vpcConfig: 'VpcConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      address: 'string',
      agentGroup: 'string',
      customSchedule: DescribeSiteMonitorAttributeResponseBodySiteMonitorsCustomSchedule,
      interval: 'string',
      ispCities: DescribeSiteMonitorAttributeResponseBodySiteMonitorsIspCities,
      optionJson: DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJson,
      taskId: 'string',
      taskName: 'string',
      taskState: 'string',
      taskType: 'string',
      vpcConfig: DescribeSiteMonitorAttributeResponseBodySiteMonitorsVpcConfig,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSiteMonitorISPCityListResponseBodyIspCityListIspCityIPPool extends $tea.Model {
  IPPool?: string[];
  static names(): { [key: string]: string } {
    return {
      IPPool: 'IPPool',
    };
  }

  static types(): { [key: string]: any } {
    return {
      IPPool: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSiteMonitorISPCityListResponseBodyIspCityListIspCity extends $tea.Model {
  area_en?: string;
  area_zh_cN?: string;
  /**
   * @remarks
   * The city ID.
   * 
   * @example
   * 4
   */
  city?: string;
  cityName_en?: string;
  cityName_zh_cN?: string;
  /**
   * @remarks
   * The country name.
   * 
   * > This parameter is valid only on the China site (aliyun.com).
   * 
   * @example
   * 629
   */
  country?: string;
  country_en?: string;
  country_zh_cN?: string;
  /**
   * @remarks
   * The IP address pool.
   */
  IPPool?: DescribeSiteMonitorISPCityListResponseBodyIspCityListIspCityIPPool;
  /**
   * @remarks
   * The number of IPv4 probes.
   * 
   * @example
   * 4
   */
  IPV4ProbeCount?: string;
  /**
   * @remarks
   * The number of IPv6 probes.
   * 
   * @example
   * 3
   */
  IPV6ProbeCount?: string;
  /**
   * @remarks
   * The carrier ID.
   * 
   * @example
   * 232
   */
  isp?: string;
  ispName_en?: string;
  ispName_zh_cN?: string;
  /**
   * @remarks
   * The province name.
   * 
   * @example
   * 264
   */
  region?: string;
  region_en?: string;
  region_zh_cN?: string;
  static names(): { [key: string]: string } {
    return {
      area_en: 'Area.en',
      area_zh_cN: 'Area.zh_CN',
      city: 'City',
      cityName_en: 'CityName.en',
      cityName_zh_cN: 'CityName.zh_CN',
      country: 'Country',
      country_en: 'Country.en',
      country_zh_cN: 'Country.zh_CN',
      IPPool: 'IPPool',
      IPV4ProbeCount: 'IPV4ProbeCount',
      IPV6ProbeCount: 'IPV6ProbeCount',
      isp: 'Isp',
      ispName_en: 'IspName.en',
      ispName_zh_cN: 'IspName.zh_CN',
      region: 'Region',
      region_en: 'Region.en',
      region_zh_cN: 'Region.zh_CN',
    };
  }

  static types(): { [key: string]: any } {
    return {
      area_en: 'string',
      area_zh_cN: 'string',
      city: 'string',
      cityName_en: 'string',
      cityName_zh_cN: 'string',
      country: 'string',
      country_en: 'string',
      country_zh_cN: 'string',
      IPPool: DescribeSiteMonitorISPCityListResponseBodyIspCityListIspCityIPPool,
      IPV4ProbeCount: 'string',
      IPV6ProbeCount: 'string',
      isp: 'string',
      ispName_en: 'string',
      ispName_zh_cN: 'string',
      region: 'string',
      region_en: 'string',
      region_zh_cN: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSiteMonitorISPCityListResponseBodyIspCityList extends $tea.Model {
  ispCity?: DescribeSiteMonitorISPCityListResponseBodyIspCityListIspCity[];
  static names(): { [key: string]: string } {
    return {
      ispCity: 'IspCity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ispCity: { 'type': 'array', 'itemType': DescribeSiteMonitorISPCityListResponseBodyIspCityListIspCity },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSiteMonitorListResponseBodySiteMonitorsSiteMonitorOptionsJsonAssertionsAssertions extends $tea.Model {
  /**
   * @remarks
   * The comparison operator of the assertion. Valid values:
   * 
   * *   contains: contains
   * *   doesNotContain: does not contain
   * *   matches: matches regular expressions
   * *   doesNotMatch: does not match regular expressions
   * *   is: equal to a numeric value or matches a character
   * *   isNot: not equal to
   * *   lessThan: less than
   * *   moreThan: greater than
   * 
   * @example
   * lessThan
   */
  operator?: string;
  /**
   * @remarks
   * The parsing path of the assertion.
   * 
   * *   If the assertion type is `body_json`, the path is `json path`.
   * *   If the assertion type is `body_xml`, the path is `xml path`.
   * 
   * @example
   * json path
   */
  property?: string;
  /**
   * @remarks
   * The numeric value or character used for matching.
   * 
   * @example
   * 1000
   */
  target?: string;
  /**
   * @remarks
   * The assertion type. Valid values:
   * 
   * *   response_time: checks whether the response time meets expectations.
   * *   status_code: checks whether the HTTP status code meets expectations.
   * *   header: checks whether the fields in the response header meet expectations.
   * *   body_text: checks whether the content in the response body meets expectations by using text matching.
   * *   body_json: checks whether the content in the response body meets expectations by using JSON parsing (JSONPath).
   * *   body_xml: checks whether the content in the response body meets expectations by using XML parsing (XPath).
   * 
   * @example
   * response_time
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      operator: 'operator',
      property: 'property',
      target: 'target',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      operator: 'string',
      property: 'string',
      target: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSiteMonitorListResponseBodySiteMonitorsSiteMonitorOptionsJsonAssertions extends $tea.Model {
  assertions?: DescribeSiteMonitorListResponseBodySiteMonitorsSiteMonitorOptionsJsonAssertionsAssertions[];
  static names(): { [key: string]: string } {
    return {
      assertions: 'assertions',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assertions: { 'type': 'array', 'itemType': DescribeSiteMonitorListResponseBodySiteMonitorsSiteMonitorOptionsJsonAssertionsAssertions },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSiteMonitorListResponseBodySiteMonitorsSiteMonitorOptionsJson extends $tea.Model {
  /**
   * @remarks
   * The acceptable status code.
   * 
   * >  We recommend that you configure assertions.
   * 
   * @example
   * 400
   */
  acceptableResponseCode?: string;
  /**
   * @remarks
   * The assertions.
   */
  assertions?: DescribeSiteMonitorListResponseBodySiteMonitorsSiteMonitorOptionsJsonAssertions;
  /**
   * @remarks
   * The number of retries after a DNS failure occurred.
   * 
   * @example
   * 3
   */
  attempts?: number;
  /**
   * @remarks
   * Indicates whether the security authentication feature is enabled. Valid values:
   * 
   * *   0: The feature is enabled.
   * *   1: The feature is disabled.
   * 
   * @example
   * 1
   */
  authentication?: number;
  /**
   * @remarks
   * Indicates whether the certificate is verified. Valid values:
   * 
   * *   false (default): The certificate is not verified.
   * *   true: The certificate is verified.
   * 
   * @example
   * false
   */
  certVerify?: boolean;
  /**
   * @remarks
   * The cookie of the HTTP request.
   * 
   * @example
   * lang=en
   */
  cookie?: string;
  /**
   * @remarks
   * Indicates whether MTR is automatically used to diagnose network issues if a task fails. Valid values:
   * 
   * *   false (default): MTR is not automatically used to diagnose network issues if a task fails.
   * *   true: MTR is automatically used to diagnose network issues if a task fails.
   * 
   * @example
   * false
   */
  diagnosisMtr?: boolean;
  /**
   * @remarks
   * Indicates whether ping requests are automatically sent to detect network latency if a detection task fails. Valid values:
   * 
   * *   false (default): Ping requests are not automatically sent to detect network latency if a detection task fails.
   * *   true: Ping requests are automatically sent to detect network latency if a detection task fails.
   * 
   * @example
   * false
   */
  diagnosisPing?: boolean;
  /**
   * @remarks
   * The relationship between the list of expected aliases or IP addresses and the list of DNS results. Valid values:
   * 
   * *   IN_DNS: The list of expected values is a subset of the list of DNS results.
   * *   DNS_IN: The list of DNS results is a subset of the list of expected values.
   * *   EQUAL: The list of DNS results is the same as the list of expected values.
   * *   ANY: The list of DNS results intersects with the list of expected values.
   * 
   * @example
   * IN_DNS
   */
  dnsMatchRule?: string;
  /**
   * @remarks
   * The domain name or IP address of the DNS server.
   * 
   * @example
   * 192.168.XX.XX
   */
  dnsServer?: string;
  /**
   * @remarks
   * The type of the DNS record. This parameter is returned only if the TaskType parameter is set to DNS. Valid values:
   * 
   * *   A (default): a record that specifies an IP address related to the specified host name or domain name.
   * *   CNAME: a record that maps multiple domain names to a domain name.
   * *   NS: a record that specifies a DNS server used to parse domain names.
   * *   MX: a record that links domain names to the address of a mail server.
   * *   TXT: a record that stores the text information of host name or domain names. The text must be 1 to 512 bytes in length. The TXT record serves as a Sender Policy Framework (SPF) record to fight against spam.
   * *   AAAA: a record that maps a domain name to the relevant IPv6 address.
   * 
   * @example
   * A
   */
  dnsType?: string;
  /**
   * @remarks
   * Indicates whether the DNS server of the carrier is used.
   * 
   * *   true (default): The DNS server of the carrier is used.
   * *   false: The DNS server of the carrier is not used. The default DNS server or the specified DNS server is used.
   * 
   * @example
   * true
   */
  enableOperatorDns?: boolean;
  /**
   * @remarks
   * The packet loss rate.
   * 
   * >  This parameter is returned only if the TaskType parameter is set to PING.
   * 
   * @example
   * 0.5
   */
  failureRate?: number;
  /**
   * @remarks
   * The header of the HTTP request. An HTTP header is a key-value pair in which the key and the value are separated by a colon (:). The format is `key1:value1`. Each HTTP header occupies a line.
   * 
   * @example
   * testKey:testValue
   */
  header?: string;
  /**
   * @remarks
   * The HTTP request method. Valid values:
   * 
   * *   get
   * *   post
   * *   head
   * 
   * @example
   * get
   */
  httpMethod?: string;
  /**
   * @remarks
   * Indicates whether the password is decoded by using the Base64 algorithm. Valid values:
   * 
   * *   true: The password is decoded by using the Base64 algorithm.
   * *   false (default): The password is not decoded by using the Base64 algorithm.
   * 
   * @example
   * false
   */
  isBase64Encode?: string;
  /**
   * @remarks
   * Indicates whether the alert rule is included. Valid values:
   * 
   * *   0: The alert rule is included.
   * *   1: The alert rule is not included.
   * 
   * @example
   * 0
   */
  matchRule?: number;
  /**
   * @remarks
   * The password of the SMTP, POP3, or FTP protocol.
   * 
   * @example
   * 123****
   */
  password?: string;
  /**
   * @remarks
   * The number of hops for the PING protocol.
   * 
   * @example
   * 20
   */
  pingNum?: number;
  /**
   * @remarks
   * The port number of the TCP, UDP, SMTP, or POP3 protocol.
   * 
   * @example
   * 80
   */
  port?: number;
  /**
   * @remarks
   * The protocol type of DNS detection. Valid values:
   * 
   * *   udp (default)
   * *   tcp
   * *   tcp-tls
   * 
   * @example
   * udp
   */
  protocol?: string;
  /**
   * @remarks
   * Indicates whether the PROXY protocol is enabled. Valid values:
   * 
   * *   false (default): The PROXY protocol is disabled.
   * *   true: The PROXY protocol is enabled.
   * 
   * @example
   * false
   */
  proxyProtocol?: boolean;
  /**
   * @remarks
   * The content of the HTTP request.
   * 
   * @example
   * cf0f85
   */
  requestContent?: string;
  /**
   * @remarks
   * The format of the HTTP request. Valid values:
   * 
   * *   hex: hexadecimal
   * *   txt: text
   * 
   * @example
   * hex
   */
  requestFormat?: string;
  /**
   * @remarks
   * The response to the HTTP request.
   * 
   * *   Hexadecimal format: If the request content is a byte string and cannot be represented in printable characters, you can convert the byte string to printable characters in the hexadecimal format. If you convert the byte string to printable characters in the hexadecimal format, one byte is converted to two hexadecimal characters. For example, (byte)1 is converted to `01` and (byte)27 is converted to `1B`. If the request content is a binary array in the Java format, for example, `{(byte)1, (byte)27}`, you can convert the binary array to `011b` or `011B`. Hexadecimal characters are not case-sensitive in site monitoring tasks. You can enter `011B` in the request content and set the request_format parameter to hex.
   * *   Text format: Common text refers to strings that consist of printable characters.
   * 
   * @example
   * cf0f85
   */
  responseContent?: string;
  /**
   * @remarks
   * The format of the HTTP response. Valid values:
   * 
   * *   hex: hexadecimal
   * *   txt: text
   * 
   * @example
   * hex
   */
  responseFormat?: string;
  /**
   * @remarks
   * The number of times a failed detection request is retried.
   * 
   * @example
   * 1
   */
  retryDelay?: number;
  /**
   * @remarks
   * The timeout period. Unit: milliseconds.
   * 
   * @example
   * 3000
   */
  timeOut?: number;
  /**
   * @remarks
   * Indicates whether redirects are followed if the status code 301 or 302 is returned. Valid values:
   * 
   * *   true: Redirects are not followed.
   * *   false (default): Redirects are followed.
   * 
   * @example
   * false
   */
  unfollowRedirect?: boolean;
  /**
   * @remarks
   * The username of the FTP, SMTP, or POP3 protocol.
   * 
   * @example
   * testUser
   */
  username?: string;
  static names(): { [key: string]: string } {
    return {
      acceptableResponseCode: 'acceptable_response_code',
      assertions: 'assertions',
      attempts: 'attempts',
      authentication: 'authentication',
      certVerify: 'cert_verify',
      cookie: 'cookie',
      diagnosisMtr: 'diagnosis_mtr',
      diagnosisPing: 'diagnosis_ping',
      dnsMatchRule: 'dns_match_rule',
      dnsServer: 'dns_server',
      dnsType: 'dns_type',
      enableOperatorDns: 'enable_operator_dns',
      failureRate: 'failure_rate',
      header: 'header',
      httpMethod: 'http_method',
      isBase64Encode: 'isBase64Encode',
      matchRule: 'match_rule',
      password: 'password',
      pingNum: 'ping_num',
      port: 'port',
      protocol: 'protocol',
      proxyProtocol: 'proxy_protocol',
      requestContent: 'request_content',
      requestFormat: 'request_format',
      responseContent: 'response_content',
      responseFormat: 'response_format',
      retryDelay: 'retry_delay',
      timeOut: 'time_out',
      unfollowRedirect: 'unfollow_redirect',
      username: 'username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptableResponseCode: 'string',
      assertions: DescribeSiteMonitorListResponseBodySiteMonitorsSiteMonitorOptionsJsonAssertions,
      attempts: 'number',
      authentication: 'number',
      certVerify: 'boolean',
      cookie: 'string',
      diagnosisMtr: 'boolean',
      diagnosisPing: 'boolean',
      dnsMatchRule: 'string',
      dnsServer: 'string',
      dnsType: 'string',
      enableOperatorDns: 'boolean',
      failureRate: 'number',
      header: 'string',
      httpMethod: 'string',
      isBase64Encode: 'string',
      matchRule: 'number',
      password: 'string',
      pingNum: 'number',
      port: 'number',
      protocol: 'string',
      proxyProtocol: 'boolean',
      requestContent: 'string',
      requestFormat: 'string',
      responseContent: 'string',
      responseFormat: 'string',
      retryDelay: 'number',
      timeOut: 'number',
      unfollowRedirect: 'boolean',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSiteMonitorListResponseBodySiteMonitorsSiteMonitor extends $tea.Model {
  /**
   * @remarks
   * The URL or IP address that is monitored by the site monitoring task.
   * 
   * @example
   * https://aliyun.com
   */
  address?: string;
  /**
   * @remarks
   * The detection point type. Valid values:
   * 
   * *   PC
   * *   MOBILE
   * 
   * @example
   * PC
   */
  agentGroup?: string;
  /**
   * @remarks
   * The time when the site monitoring task was created.
   * 
   * @example
   * 2021-11-01 11:05:18
   */
  createTime?: string;
  /**
   * @remarks
   * The interval at which detection requests are sent. Unit: minutes.
   * 
   * @example
   * 1
   */
  interval?: string;
  /**
   * @remarks
   * The extended options of the site monitoring task. The options vary based on the specified protocol. For more information, see [CreateSiteMonitor](https://help.aliyun.com/document_detail/115048.html).
   */
  optionsJson?: DescribeSiteMonitorListResponseBodySiteMonitorsSiteMonitorOptionsJson;
  /**
   * @remarks
   * The ID of the site monitoring task.
   * 
   * @example
   * f5783760-1b39-4b6b-80e8-453d962a****
   */
  taskId?: string;
  /**
   * @remarks
   * The name of the site monitoring task.
   */
  taskName?: string;
  /**
   * @remarks
   * The task status. Valid values:
   * 
   * *   1: The task is enabled.
   * *   2: The task is disabled.
   * 
   * @example
   * 1
   */
  taskState?: string;
  /**
   * @remarks
   * The protocol that is used by the site monitoring task. Valid values: HTTP, PING, TCP, UDP, DNS, SMTP, POP3, and FTP.
   * 
   * @example
   * TCP
   */
  taskType?: string;
  /**
   * @remarks
   * The time when the site monitoring task was updated.
   * 
   * @example
   * 2022-03-08 17:14:31
   */
  updateTime?: string;
  static names(): { [key: string]: string } {
    return {
      address: 'Address',
      agentGroup: 'AgentGroup',
      createTime: 'CreateTime',
      interval: 'Interval',
      optionsJson: 'OptionsJson',
      taskId: 'TaskId',
      taskName: 'TaskName',
      taskState: 'TaskState',
      taskType: 'TaskType',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      address: 'string',
      agentGroup: 'string',
      createTime: 'string',
      interval: 'string',
      optionsJson: DescribeSiteMonitorListResponseBodySiteMonitorsSiteMonitorOptionsJson,
      taskId: 'string',
      taskName: 'string',
      taskState: 'string',
      taskType: 'string',
      updateTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSiteMonitorListResponseBodySiteMonitors extends $tea.Model {
  siteMonitor?: DescribeSiteMonitorListResponseBodySiteMonitorsSiteMonitor[];
  static names(): { [key: string]: string } {
    return {
      siteMonitor: 'SiteMonitor',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteMonitor: { 'type': 'array', 'itemType': DescribeSiteMonitorListResponseBodySiteMonitorsSiteMonitor },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSiteMonitorQuotaResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the second-level monitoring is enabled. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * false
   */
  secondMonitor?: boolean;
  /**
   * @remarks
   * The quota of detection points that are provided by Alibaba Cloud. Five detection points are provided for free.
   * 
   * @example
   * 5
   */
  siteMonitorIdcQuota?: number;
  /**
   * @remarks
   * The quota of detection points that are not provided by Alibaba Cloud. Default value: 0.
   * 
   * @example
   * 0
   */
  siteMonitorOperatorQuotaQuota?: number;
  /**
   * @remarks
   * The used quota of site monitoring tasks.
   * 
   * @example
   * 6
   */
  siteMonitorQuotaTaskUsed?: number;
  /**
   * @remarks
   * The quota of site monitoring tasks.
   * 
   * @example
   * 10
   */
  siteMonitorTaskQuota?: number;
  /**
   * @remarks
   * The version of site monitoring. Valid values:
   * 
   * *   V1
   * *   V2
   * 
   * @example
   * V1
   */
  siteMonitorVersion?: string;
  static names(): { [key: string]: string } {
    return {
      secondMonitor: 'SecondMonitor',
      siteMonitorIdcQuota: 'SiteMonitorIdcQuota',
      siteMonitorOperatorQuotaQuota: 'SiteMonitorOperatorQuotaQuota',
      siteMonitorQuotaTaskUsed: 'SiteMonitorQuotaTaskUsed',
      siteMonitorTaskQuota: 'SiteMonitorTaskQuota',
      siteMonitorVersion: 'SiteMonitorVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      secondMonitor: 'boolean',
      siteMonitorIdcQuota: 'number',
      siteMonitorOperatorQuotaQuota: 'number',
      siteMonitorQuotaTaskUsed: 'number',
      siteMonitorTaskQuota: 'number',
      siteMonitorVersion: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSystemEventAttributeResponseBodySystemEventsSystemEvent extends $tea.Model {
  /**
   * @remarks
   * The details of the event.
   * 
   * @example
   * [{"product":"CloudMonitor","content":"{\\"ipGroup\\":\\"112.126.XX.XX,10.163.XX.XX\\",\\"tianjimonVersion\\":\\"1.2.22\\"}","groupId":"176,177,178,179,180,692,120812,1663836,96,2028302","time":"1552209568000","resourceId":"acs:ecs:cn-beijing:173651113438****:instance/i-25k35****","level":"CRITICAL","status":"stopped","instanceName":"cmssiteprobebj-6","name":"Agent_Status_Stopped","regionId":"cn-beijing"}]
   */
  content?: string;
  /**
   * @remarks
   * The ID of the application group.
   * 
   * @example
   * 12345
   */
  groupId?: string;
  /**
   * @remarks
   * The event ID.
   * 
   * @example
   * b936efc9-f621-4e8a-a6eb-076be40e****
   */
  id?: string;
  /**
   * @remarks
   * The instance name.
   * 
   * @example
   * instanceId1
   */
  instanceName?: string;
  /**
   * @remarks
   * The level of the event. Valid values:
   * 
   * *   CRITICAL
   * *   WARN
   * *   INFO
   * 
   * @example
   * WARN
   */
  level?: string;
  /**
   * @remarks
   * The event name.
   * 
   * @example
   * Agent_Status_Stopped
   */
  name?: string;
  /**
   * @remarks
   * The abbreviation of the service name.
   * 
   * @example
   * CloudMonitor
   */
  product?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The resource ID.
   * 
   * @example
   * xxxxx-1
   */
  resourceId?: string;
  /**
   * @remarks
   * The status of the event.
   * 
   * @example
   * normal
   */
  status?: string;
  /**
   * @remarks
   * The time when the event occurred. The value is a timestamp.
   * 
   * Unit: milliseconds.
   * 
   * @example
   * 1552199984000
   */
  time?: number;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      groupId: 'GroupId',
      id: 'Id',
      instanceName: 'InstanceName',
      level: 'Level',
      name: 'Name',
      product: 'Product',
      regionId: 'RegionId',
      resourceId: 'ResourceId',
      status: 'Status',
      time: 'Time',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      groupId: 'string',
      id: 'string',
      instanceName: 'string',
      level: 'string',
      name: 'string',
      product: 'string',
      regionId: 'string',
      resourceId: 'string',
      status: 'string',
      time: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSystemEventAttributeResponseBodySystemEvents extends $tea.Model {
  systemEvent?: DescribeSystemEventAttributeResponseBodySystemEventsSystemEvent[];
  static names(): { [key: string]: string } {
    return {
      systemEvent: 'SystemEvent',
    };
  }

  static types(): { [key: string]: any } {
    return {
      systemEvent: { 'type': 'array', 'itemType': DescribeSystemEventAttributeResponseBodySystemEventsSystemEvent },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSystemEventCountResponseBodySystemEventCountsSystemEventCount extends $tea.Model {
  /**
   * @remarks
   * The description of the system event.
   */
  content?: string;
  /**
   * @remarks
   * The ID of the application group.
   * 
   * @example
   * 17285****
   */
  groupId?: string;
  /**
   * @remarks
   * The name of the instance.
   * 
   * @example
   * ECS-test
   */
  instanceName?: string;
  /**
   * @remarks
   * The level of the system event. Valid values:
   * 
   * *   Critical
   * *   Warn
   * *   Info
   * 
   * @example
   * Info
   */
  level?: string;
  /**
   * @remarks
   * The name of the system event.
   * 
   * @example
   * Instance:StateChange
   */
  name?: string;
  /**
   * @remarks
   * The number of times that the system event has occurred.
   * 
   * @example
   * 3
   */
  num?: number;
  /**
   * @remarks
   * The name of the cloud service in which the system event occurred.
   * 
   * @example
   * ECS
   */
  product?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The resource ID.
   * 
   * @example
   * i-rj99xc6cptkk64ml****
   */
  resourceId?: string;
  /**
   * @remarks
   * The status of the system event.
   * 
   * @example
   * Normal
   */
  status?: string;
  /**
   * @remarks
   * The time when the system event occurred. The value is a timestamp. Unit: milliseconds.
   * 
   * @example
   * 1635993751000
   */
  time?: number;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      groupId: 'GroupId',
      instanceName: 'InstanceName',
      level: 'Level',
      name: 'Name',
      num: 'Num',
      product: 'Product',
      regionId: 'RegionId',
      resourceId: 'ResourceId',
      status: 'Status',
      time: 'Time',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      groupId: 'string',
      instanceName: 'string',
      level: 'string',
      name: 'string',
      num: 'number',
      product: 'string',
      regionId: 'string',
      resourceId: 'string',
      status: 'string',
      time: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSystemEventCountResponseBodySystemEventCounts extends $tea.Model {
  systemEventCount?: DescribeSystemEventCountResponseBodySystemEventCountsSystemEventCount[];
  static names(): { [key: string]: string } {
    return {
      systemEventCount: 'SystemEventCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      systemEventCount: { 'type': 'array', 'itemType': DescribeSystemEventCountResponseBodySystemEventCountsSystemEventCount },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSystemEventHistogramResponseBodySystemEventHistogramsSystemEventHistogram extends $tea.Model {
  /**
   * @remarks
   * The number of times the system event occurred.
   * 
   * @example
   * 2
   */
  count?: number;
  /**
   * @remarks
   * The end time.
   * 
   * This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
   * 
   * @example
   * 1552225753000
   */
  endTime?: number;
  /**
   * @remarks
   * The start time.
   * 
   * This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
   * 
   * @example
   * 1552225770000
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      endTime: 'EndTime',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      endTime: 'number',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSystemEventHistogramResponseBodySystemEventHistograms extends $tea.Model {
  systemEventHistogram?: DescribeSystemEventHistogramResponseBodySystemEventHistogramsSystemEventHistogram[];
  static names(): { [key: string]: string } {
    return {
      systemEventHistogram: 'SystemEventHistogram',
    };
  }

  static types(): { [key: string]: any } {
    return {
      systemEventHistogram: { 'type': 'array', 'itemType': DescribeSystemEventHistogramResponseBodySystemEventHistogramsSystemEventHistogram },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSystemEventMetaListResponseBodyDataResource extends $tea.Model {
  /**
   * @remarks
   * The type of the system event. Valid values:
   * 
   * *   StatusNotification
   * *   Exception
   * *   Maintenance
   * 
   * @example
   * Exception
   */
  eventType?: string;
  /**
   * @remarks
   * The level of the alert. Valid values:
   * 
   * *   CRITICAL
   * *   WARN
   * *   INFO
   * 
   * @example
   * INFO
   */
  level?: string;
  /**
   * @remarks
   * The name of the system event.
   * 
   * @example
   * SelectFailureRate
   */
  name?: string;
  /**
   * @remarks
   * The description of the system event, in Chinese.
   * 
   * @example
   * High query failure rate
   */
  nameDesc?: string;
  nameDesc_en?: string;
  /**
   * @remarks
   * The abbreviation of the service name.
   * 
   * @example
   * ADS
   */
  product?: string;
  /**
   * @remarks
   * The status of the system event.
   * 
   * @example
   * failed
   */
  status?: string;
  /**
   * @remarks
   * The description of the event status.
   * 
   * @example
   * Operation Failed
   */
  statusDesc?: string;
  static names(): { [key: string]: string } {
    return {
      eventType: 'EventType',
      level: 'Level',
      name: 'Name',
      nameDesc: 'NameDesc',
      nameDesc_en: 'NameDesc.En',
      product: 'Product',
      status: 'Status',
      statusDesc: 'StatusDesc',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventType: 'string',
      level: 'string',
      name: 'string',
      nameDesc: 'string',
      nameDesc_en: 'string',
      product: 'string',
      status: 'string',
      statusDesc: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSystemEventMetaListResponseBodyData extends $tea.Model {
  resource?: DescribeSystemEventMetaListResponseBodyDataResource[];
  static names(): { [key: string]: string } {
    return {
      resource: 'Resource',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resource: { 'type': 'array', 'itemType': DescribeSystemEventMetaListResponseBodyDataResource },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTagKeyListResponseBodyTagKeys extends $tea.Model {
  tagKey?: string[];
  static names(): { [key: string]: string } {
    return {
      tagKey: 'TagKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagKey: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTagValueListResponseBodyTagValues extends $tea.Model {
  tagValue?: string[];
  static names(): { [key: string]: string } {
    return {
      tagValue: 'TagValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagValue: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUnhealthyHostAvailabilityResponseBodyUnhealthyListNodeTaskInstanceInstanceList extends $tea.Model {
  string?: string[];
  static names(): { [key: string]: string } {
    return {
      string: 'String',
    };
  }

  static types(): { [key: string]: any } {
    return {
      string: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUnhealthyHostAvailabilityResponseBodyUnhealthyListNodeTaskInstance extends $tea.Model {
  /**
   * @remarks
   * The ID of the availability monitoring task.
   * 
   * @example
   * 123456
   */
  id?: number;
  /**
   * @remarks
   * The unhealthy instances that are detected by the availability monitoring task.
   */
  instanceList?: DescribeUnhealthyHostAvailabilityResponseBodyUnhealthyListNodeTaskInstanceInstanceList;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      instanceList: 'InstanceList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      instanceList: DescribeUnhealthyHostAvailabilityResponseBodyUnhealthyListNodeTaskInstanceInstanceList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUnhealthyHostAvailabilityResponseBodyUnhealthyList extends $tea.Model {
  nodeTaskInstance?: DescribeUnhealthyHostAvailabilityResponseBodyUnhealthyListNodeTaskInstance[];
  static names(): { [key: string]: string } {
    return {
      nodeTaskInstance: 'NodeTaskInstance',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeTaskInstance: { 'type': 'array', 'itemType': DescribeUnhealthyHostAvailabilityResponseBodyUnhealthyListNodeTaskInstance },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableSiteMonitorsResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The number of detection points.
   * 
   * @example
   * 0
   */
  count?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'count',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableSiteMonitorsResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The number of detection points.
   * 
   * @example
   * 0
   */
  count?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'count',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyGroupMonitoringAgentProcessRequestAlertConfigTargetList extends $tea.Model {
  /**
   * @remarks
   * The Alibaba Cloud Resource Name (ARN) of the resource.
   * 
   * For information about how to obtain the ARN of a resource, see [DescribeMetricRuleTargets](https://help.aliyun.com/document_detail/121592.html).
   * 
   * Format: `acs:{Service name abbreviation}:{regionId}:{userId}:/{Resource type}/{Resource name}/message`. Example: `acs:mns:cn-hangzhou:120886317861****:/queues/test123/message`. Fields:
   * 
   * - {Service name abbreviation}: the abbreviation of the service name. Valid value: mns.
   * - {userId}: the ID of the Alibaba Cloud account.
   * - {regionId}: the region ID of the message queue or topic.
   * - {Resource type}: the type of the resource for which alerts are triggered. Valid values: 
   *     - **queues** 
   *     - **topics** 
   * - {Resourcename}: the name of the resource. 
   *   - If the resource type is set to **queues**, the resource name is the name of the message queue. 
   *   - If the resource type is set to **topics**, the resource name is the name of the topic.`
   * 
   * @example
   * acs:mns:cn-hangzhou:120886317861****:/queues/test/message
   */
  arn?: string;
  /**
   * @remarks
   * The ID of the resource for which alerts are triggered.
   * 
   * For information about how to obtain the ID of a resource for which alerts are triggered, see [DescribeMetricRuleTargets](https://help.aliyun.com/document_detail/121592.html).
   * 
   * @example
   * 1
   */
  id?: string;
  /**
   * @remarks
   * The parameters of the alert callback. The parameters are in the JSON format.
   * 
   * @example
   * {"customField1":"value1","customField2":"$.name"}
   */
  jsonParams?: string;
  /**
   * @remarks
   * The level of the alert. Valid values:
   * 
   * *   INFO: information
   * *   WARN: warning
   * *   CRITICAL: critical
   * 
   * @example
   * ["INFO", "WARN", "CRITICAL"]
   */
  level?: string;
  static names(): { [key: string]: string } {
    return {
      arn: 'Arn',
      id: 'Id',
      jsonParams: 'JsonParams',
      level: 'Level',
    };
  }

  static types(): { [key: string]: any } {
    return {
      arn: 'string',
      id: 'string',
      jsonParams: 'string',
      level: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyGroupMonitoringAgentProcessRequestAlertConfig extends $tea.Model {
  /**
   * @remarks
   * The comparison operator that is used to compare the metric value with the threshold. Valid values of N: 1 to 200. Valid values:
   * 
   * *   GreaterThanOrEqualToThreshold: greater than or equal to the threshold
   * *   GreaterThanThreshold: greater than the threshold
   * *   LessThanOrEqualToThreshold: less than or equal to the threshold
   * *   LessThanThreshold: less than the threshold.
   * *   NotEqualToThreshold: not equal to the threshold
   * *   GreaterThanYesterday: greater than the metric value at the same time yesterday.
   * *   LessThanYesterday: less than the metric value at the same time yesterday
   * *   GreaterThanLastWeek: greater than the metric value at the same time last week
   * *   LessThanLastWeek: less than the metric value at the same time last week
   * *   GreaterThanLastPeriod: greater than the metric value in the last monitoring cycle
   * *   LessThanLastPeriod: less than the metric value in the last monitoring cycle
   * 
   * This parameter is required.
   * 
   * @example
   * GreaterThanOrEqualToThreshold
   */
  comparisonOperator?: string;
  /**
   * @remarks
   * The time period during which the alert rule is effective. Valid values of N: 1 to 200.
   * 
   * @example
   * 00:00-22:59
   */
  effectiveInterval?: string;
  /**
   * @remarks
   * The level of the alert. Valid values of N: 1 to 200. Valid values:
   * 
   * *   critical (default value): critical
   * *   warn: warning
   * *   info: information
   * 
   * This parameter is required.
   * 
   * @example
   * warn
   */
  escalationsLevel?: string;
  /**
   * @remarks
   * The time period during which the alert rule is ineffective. Valid values of N: 1 to 200.
   * 
   * @example
   * 23:00-23:59
   */
  noEffectiveInterval?: string;
  /**
   * @remarks
   * The mute period during which new alerts are not sent even if the trigger conditions are met. Valid values of N: 1 to 200.
   * 
   * Unit: seconds. Minimum value: 3600, which is equivalent to one hour. Default value: 86400, which is equivalent to one day.
   * 
   * >  Only one alert notification is sent during a mute period even if the metric value exceeds the alert threshold during consecutive checks.
   * 
   * @example
   * 86400
   */
  silenceTime?: string;
  /**
   * @remarks
   * The statistical aggregation method that is used to calculate the metric values. Valid values of N: 1 to 200.
   * 
   * >  Set the value to Average.
   * 
   * @example
   * Average
   */
  statistics?: string;
  /**
   * @remarks
   * The alert trigger.
   */
  targetList?: ModifyGroupMonitoringAgentProcessRequestAlertConfigTargetList[];
  /**
   * @remarks
   * The alert threshold. Valid values of N: 1 to 200.
   * 
   * This parameter is required.
   * 
   * @example
   * 5
   */
  threshold?: string;
  /**
   * @remarks
   * The number of times for which the threshold can be consecutively exceeded. Valid values of N: 1 to 200. Default value: 3.
   * 
   * >  A metric triggers an alert only after the metric value reaches the threshold consecutively for the specified times.
   * 
   * This parameter is required.
   * 
   * @example
   * 3
   */
  times?: string;
  /**
   * @remarks
   * The callback URL to which a POST request is sent when an alert is triggered based on the alert rule. Valid values of N: 1 to 200.
   * 
   * @example
   * http://www.aliyun.com
   */
  webhook?: string;
  static names(): { [key: string]: string } {
    return {
      comparisonOperator: 'ComparisonOperator',
      effectiveInterval: 'EffectiveInterval',
      escalationsLevel: 'EscalationsLevel',
      noEffectiveInterval: 'NoEffectiveInterval',
      silenceTime: 'SilenceTime',
      statistics: 'Statistics',
      targetList: 'TargetList',
      threshold: 'Threshold',
      times: 'Times',
      webhook: 'Webhook',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comparisonOperator: 'string',
      effectiveInterval: 'string',
      escalationsLevel: 'string',
      noEffectiveInterval: 'string',
      silenceTime: 'string',
      statistics: 'string',
      targetList: { 'type': 'array', 'itemType': ModifyGroupMonitoringAgentProcessRequestAlertConfigTargetList },
      threshold: 'string',
      times: 'string',
      webhook: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyHostAvailabilityRequestAlertConfig extends $tea.Model {
  /**
   * @remarks
   * The end of the time range during which the alert rule is effective. Valid values: 0 to 23.
   * 
   * For example, if the `AlertConfig.StartTime` parameter is set to 0 and the `AlertConfig.EndTime` parameter is set to 22, the alert rule is effective from 00:00:00 to 22:00:00.
   * 
   * > Alert notifications are sent based on the specified threshold only if the alert rule is effective.
   * 
   * @example
   * 22
   */
  endTime?: number;
  /**
   * @remarks
   * The alert notification methods. Valid values:
   * 
   * 0: Alert notifications are sent by using emails and DingTalk chatbots.
   * 
   * This parameter is required.
   * 
   * @example
   * 0
   */
  notifyType?: number;
  /**
   * @remarks
   * The mute period during which new alerts are not sent even if the trigger conditions are met. Unit: seconds. Default value: 86400. The default value indicates one day.
   * 
   * @example
   * 86400
   */
  silenceTime?: number;
  /**
   * @remarks
   * The beginning of the time range during which the alert rule is effective. Valid values: 0 to 23.
   * 
   * For example, if the `AlertConfig.StartTime` parameter is set to 0 and the `AlertConfig.EndTime` parameter is set to 22, the alert rule is effective from 00:00:00 to 22:00:00.
   * 
   * > Alert notifications are sent based on the specified threshold only if the alert rule is effective.
   * 
   * @example
   * 0
   */
  startTime?: number;
  /**
   * @remarks
   * The callback URL.
   * 
   * @example
   * https://www.aliyun.com/webhook.json
   */
  webHook?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      notifyType: 'NotifyType',
      silenceTime: 'SilenceTime',
      startTime: 'StartTime',
      webHook: 'WebHook',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      notifyType: 'number',
      silenceTime: 'number',
      startTime: 'number',
      webHook: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyHostAvailabilityRequestTaskOption extends $tea.Model {
  /**
   * @remarks
   * The header of the HTTP request. Format: `Parameter name:Parameter value`. Separate multiple parameters with carriage return characters. Example:
   * 
   *     params1:value1
   *     params2:value2
   * 
   * @example
   * params1:value1
   */
  httpHeader?: string;
  /**
   * @remarks
   * The HTTP request method. Valid values:
   * 
   * *   GET
   * *   POST
   * *   HEAD
   * 
   * > This parameter must be specified when TaskType is set to HTTP. For more information about how to configure the TaskType parameter, see [CreateHostAvailability](https://help.aliyun.com/document_detail/115317.html).
   * 
   * @example
   * GET
   */
  httpMethod?: string;
  /**
   * @remarks
   * The method to trigger an alert. The alert can be triggered based on whether the specified alert rule is included in the response body. Valid values:
   * 
   * *   true: If the HTTP response body includes the alert rule, an alert is triggered.
   * *   false: If the HTTP response does not include the alert rule, an alert is triggered.
   * 
   * > This parameter must be specified when TaskType is set to HTTP. For more information about how to configure the TaskType parameter, see [CreateHostAvailability](https://help.aliyun.com/document_detail/115317.html).
   * 
   * @example
   * true
   */
  httpNegative?: boolean;
  /**
   * @remarks
   * The content of the HTTP POST request.
   * 
   * @example
   * params1=value1
   */
  httpPostContent?: string;
  /**
   * @remarks
   * The character set that is used in the HTTP response.
   * 
   * > Only UTF-8 is supported.
   * 
   * @example
   * UTF-8
   */
  httpResponseCharset?: string;
  /**
   * @remarks
   * The response to the HTTP request.
   * 
   * @example
   * ok
   */
  httpResponseMatchContent?: string;
  /**
   * @remarks
   * The URI that you want to monitor. This parameter must be specified when TaskType is set to HTTP.
   * 
   * @example
   * https://www.aliyun.com
   */
  httpURI?: string;
  /**
   * @remarks
   * The interval at which detection requests are sent. Unit: seconds. Valid values: 15, 30, 60, 120, 300, 900, 1800, and 3600.
   * 
   * > This parameter is available only for the CloudMonitor agent V3.5.1 or later.
   * 
   * @example
   * 60
   */
  interval?: number;
  /**
   * @remarks
   * The domain name or IP address that you want to monitor.
   * 
   * > This parameter must be specified when TaskType is set to PING or TELNET. For more information about how to configure the TaskType parameter, see [CreateHostAvailability](https://help.aliyun.com/document_detail/115317.html).
   * 
   * @example
   * www.aliyun.com
   */
  telnetOrPingHost?: string;
  static names(): { [key: string]: string } {
    return {
      httpHeader: 'HttpHeader',
      httpMethod: 'HttpMethod',
      httpNegative: 'HttpNegative',
      httpPostContent: 'HttpPostContent',
      httpResponseCharset: 'HttpResponseCharset',
      httpResponseMatchContent: 'HttpResponseMatchContent',
      httpURI: 'HttpURI',
      interval: 'Interval',
      telnetOrPingHost: 'TelnetOrPingHost',
    };
  }

  static types(): { [key: string]: any } {
    return {
      httpHeader: 'string',
      httpMethod: 'string',
      httpNegative: 'boolean',
      httpPostContent: 'string',
      httpResponseCharset: 'string',
      httpResponseMatchContent: 'string',
      httpURI: 'string',
      interval: 'number',
      telnetOrPingHost: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyHostAvailabilityRequestAlertConfigEscalationList extends $tea.Model {
  /**
   * @remarks
   * The method used to calculate the metric values that trigger alerts. Valid values of N: 1 to 21. The value of this parameter varies based on the metric. The following items show the correspondence between metrics and calculation methods:
   * 
   * *   HttpStatus: Value
   * *   HttpLatency: Average
   * *   TelnetStatus: Value
   * *   TelnetLatency: Average
   * *   PingLostRate: Average
   * 
   * > The value Value indicates the original value and is used for metrics such as status codes. The value Average indicates the average value and is used for metrics such as the latency and packet loss rate.
   * 
   * @example
   * Value
   */
  aggregate?: string;
  /**
   * @remarks
   * The metric for which the alert feature is enabled. Valid values of N: 1 to 21. Valid values:
   * 
   * *   HttpStatus: HTTP status code
   * *   HttpLatency: HTTP response time
   * *   TelnetStatus: Telnet status code
   * *   TelnetLatency: Telnet response time
   * *   PingLostRate: Ping packet loss rate
   * 
   * This parameter is required.
   * 
   * @example
   * HttpStatus
   */
  metricName?: string;
  /**
   * @remarks
   * The comparison operator that is used in the alert rule. Valid values of N: 1 to 21. Valid values:
   * 
   * *   `>`
   * *   `>=`
   * *   `<`
   * *   `<=`
   * *   `=`
   * 
   * @example
   * >
   */
  operator?: string;
  /**
   * @remarks
   * The consecutive number of times for which the metric value meets the alert condition before an alert is triggered. Valid values of N: 1 to 21.
   * 
   * @example
   * 3
   */
  times?: number;
  /**
   * @remarks
   * The alert threshold. Valid values of N: 1 to 21.
   * 
   * @example
   * 3
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      aggregate: 'Aggregate',
      metricName: 'MetricName',
      operator: 'Operator',
      times: 'Times',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aggregate: 'string',
      metricName: 'string',
      operator: 'string',
      times: 'number',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyHostAvailabilityRequestAlertConfigTargetList extends $tea.Model {
  /**
   * @remarks
   * The Alibaba Cloud Resource Name (ARN) of the resource.
   * 
   * Format: `acs:{Service name abbreviation}:{regionId}:{userId}:/{Resource type}/{Resource name}/message`. Example: `acs:mns:cn-hangzhou:120886317861****:/queues/test123/message`. Fields:
   * 
   * *   {Service name abbreviation}: the abbreviation of the service name. Valid value: mns.
   * 
   * *   {userId}: the ID of the Alibaba Cloud account.
   * 
   * *   {regionId}: the region ID of the message queue or topic.
   * 
   * *   {Resource type}: the type of the resource that triggers the alert. Valid values:
   * 
   *     *   **queues**
   *     *   **topics**
   * 
   * *   {Resource name}: the resource name.
   * 
   *     *   If the resource type is **queues**, the resource name is the queue name.
   *     *   If the resource type is **topics**, the resource name is the topic name.
   * 
   * @example
   * acs:mns:cn-hangzhou:111:/queues/test/message
   */
  arn?: string;
  /**
   * @remarks
   * The ID of the resource for which alerts are triggered.
   * 
   * @example
   * 1
   */
  id?: string;
  /**
   * @remarks
   * The parameters of the alert callback. The parameters are in the JSON format.
   * 
   * @example
   * {"customField1":"value1","customField2":"$.name"}
   */
  jsonParams?: string;
  /**
   * @remarks
   * The alert level. Valid values:
   * 
   * *   INFO
   * *   WARN
   * *   CRITICAL
   * 
   * @example
   * ["INFO", "WARN", "CRITICAL"]
   */
  level?: string;
  static names(): { [key: string]: string } {
    return {
      arn: 'Arn',
      id: 'Id',
      jsonParams: 'JsonParams',
      level: 'Level',
    };
  }

  static types(): { [key: string]: any } {
    return {
      arn: 'string',
      id: 'string',
      jsonParams: 'string',
      level: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyHybridMonitorSLSGroupRequestSLSGroupConfig extends $tea.Model {
  /**
   * @remarks
   * The Logstore.
   * 
   * Valid values of N: 1 to 25.
   * 
   * This parameter is required.
   * 
   * @example
   * Logstore-aliyun-all
   */
  SLSLogstore?: string;
  /**
   * @remarks
   * The Simple Log Service project.
   * 
   * Valid values of N: 1 to 25.
   * 
   * This parameter is required.
   * 
   * @example
   * aliyun-project
   */
  SLSProject?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * Valid values of N: 1 to 25.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  SLSRegion?: string;
  /**
   * @remarks
   * The member ID.
   * 
   * Valid values of N: 1 to 25.
   * 
   * If you call this operation by using the management account of a resource directory, you can connect the Alibaba Cloud services that are activated for all members in the resource directory to Hybrid Cloud Monitoring. You can use the resource directory to monitor Alibaba Cloud services across enterprise accounts.
   * 
   * > If a member uses CloudMonitor for the first time, you must make sure that the service-linked role AliyunServiceRoleForCloudMonitor is attached to the member. For more information, see [Manage the service-linked role for CloudMonitor](https://help.aliyun.com/document_detail/170423.html).
   * 
   * @example
   * 120886317861****
   */
  SLSUserId?: string;
  static names(): { [key: string]: string } {
    return {
      SLSLogstore: 'SLSLogstore',
      SLSProject: 'SLSProject',
      SLSRegion: 'SLSRegion',
      SLSUserId: 'SLSUserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      SLSLogstore: 'string',
      SLSProject: 'string',
      SLSRegion: 'string',
      SLSUserId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyHybridMonitorTaskRequestAttachLabels extends $tea.Model {
  /**
   * @remarks
   * The tag key of the metric.
   * 
   * @example
   * app_service
   */
  name?: string;
  /**
   * @remarks
   * The tag value of the metric.
   * 
   * @example
   * testValue
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyHybridMonitorTaskRequestSLSProcessConfigExpress extends $tea.Model {
  /**
   * @remarks
   * The alias of the extended field that specifies the result of basic operations performed on aggregation results.
   * 
   * @example
   * SuccRate
   */
  alias?: string;
  /**
   * @remarks
   * The extended field that specifies the result of basic operations performed on aggregation results.
   * 
   * @example
   * success_count
   */
  express?: string;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      express: 'Express',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      express: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyHybridMonitorTaskRequestSLSProcessConfigFilterFilters extends $tea.Model {
  /**
   * @remarks
   * The method that is used to filter logs imported from Log Service. Valid values:
   * 
   * *   `contain`: contains
   * *   `notContain`: does not contain
   * *   `>`: greater than
   * *   `<`: less than
   * *   `=`: equal to
   * *   `! =`: not equal to
   * *   `>=`: greater than or equal to
   * *   `<=`: less than or equal to
   * 
   * @example
   * =
   */
  operator?: string;
  /**
   * @remarks
   * The name of the key that is used to filter logs imported from Log Service.
   * 
   * @example
   * code
   */
  SLSKeyName?: string;
  /**
   * @remarks
   * The value of the key that is used to filter logs imported from Log Service.
   * 
   * @example
   * 200
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      operator: 'Operator',
      SLSKeyName: 'SLSKeyName',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      operator: 'string',
      SLSKeyName: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyHybridMonitorTaskRequestSLSProcessConfigFilter extends $tea.Model {
  /**
   * @remarks
   * None
   */
  filters?: ModifyHybridMonitorTaskRequestSLSProcessConfigFilterFilters[];
  /**
   * @remarks
   * The relationship between multiple filter conditions. Valid values:
   * 
   * *   and (default): Logs are processed only if all filter conditions are met.
   * *   or: Logs are processed if one of the filter conditions is met.
   * 
   * @example
   * and
   */
  relation?: string;
  static names(): { [key: string]: string } {
    return {
      filters: 'Filters',
      relation: 'Relation',
    };
  }

  static types(): { [key: string]: any } {
    return {
      filters: { 'type': 'array', 'itemType': ModifyHybridMonitorTaskRequestSLSProcessConfigFilterFilters },
      relation: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyHybridMonitorTaskRequestSLSProcessConfigGroupBy extends $tea.Model {
  /**
   * @remarks
   * The alias of the aggregation result.
   * 
   * @example
   * ApiResult
   */
  alias?: string;
  /**
   * @remarks
   * The name of the key that is used to aggregate logs imported from Log Service.
   * 
   * @example
   * code
   */
  SLSKeyName?: string;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      SLSKeyName: 'SLSKeyName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      SLSKeyName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyHybridMonitorTaskRequestSLSProcessConfigStatistics extends $tea.Model {
  /**
   * @remarks
   * The alias of the aggregation result.
   * 
   * @example
   * level_count
   */
  alias?: string;
  /**
   * @remarks
   * The function that is used to aggregate the log data of a statistical period. Valid values:
   * 
   * *   count: counts the number.
   * *   sum: calculates the total value.
   * *   avg: calculates the average value.
   * *   max: calculates the maximum value.
   * *   min: calculates the minimum value.
   * *   value: collects samples within the statistical period.
   * *   countps: calculates the counted number of the specified field divided by the total number of seconds within the statistical period.
   * *   sumps: calculates the total value of the specified field divided by the total number of seconds within the statistical period.
   * *   distinct: counts the number of logs where the specified field appears within the statistical period.
   * *   distribution: counts the number of logs that meet a specified condition within the statistical period.
   * *   percentile: sorts the values of the specified field in ascending order, and then returns the value that is at the specified percentile within the statistical period. Example: P50.
   * 
   * @example
   * count
   */
  function?: string;
  /**
   * @remarks
   * The value of the function that is used to aggregate logs imported from Log Service.
   * 
   * *   If the `Function` parameter is set to `distribution`, this parameter specifies the lower limit of the statistical interval. For example, if you want to calculate the number of HTTP requests whose status code is 2XX, set this parameter to 200.
   * *   If you set the `Function` parameter to `percentile`, this parameter specifies the percentile at which the expected value is. For example, 0.5 specifies P50.
   * 
   * @example
   * 200
   */
  parameter1?: string;
  /**
   * @remarks
   * The value of the function that is used to aggregate logs imported from Log Service.
   * 
   * > This parameter must be specified when `Function` is set to `distribution`. This parameter specifies the upper limit of the statistical interval. For example, if you want to calculate the number of HTTP requests whose status code is 2XX, set this parameter to 299.
   * 
   * @example
   * 299
   */
  parameter2?: string;
  /**
   * @remarks
   * The name of the key that is used to aggregate logs imported from Log Service.
   * 
   * @example
   * name
   */
  SLSKeyName?: string;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      function: 'Function',
      parameter1: 'Parameter1',
      parameter2: 'Parameter2',
      SLSKeyName: 'SLSKeyName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      function: 'string',
      parameter1: 'string',
      parameter2: 'string',
      SLSKeyName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyHybridMonitorTaskRequestSLSProcessConfig extends $tea.Model {
  /**
   * @remarks
   * The extended fields that specify the results of basic operations performed on aggregation results.
   */
  express?: ModifyHybridMonitorTaskRequestSLSProcessConfigExpress[];
  /**
   * @remarks
   * The conditions that are used to filter logs imported from Log Service.
   */
  filter?: ModifyHybridMonitorTaskRequestSLSProcessConfigFilter;
  /**
   * @remarks
   * The dimensions based on which data is aggregated. This parameter is equivalent to the GROUP BY clause in SQL.
   */
  groupBy?: ModifyHybridMonitorTaskRequestSLSProcessConfigGroupBy[];
  /**
   * @remarks
   * None
   */
  statistics?: ModifyHybridMonitorTaskRequestSLSProcessConfigStatistics[];
  static names(): { [key: string]: string } {
    return {
      express: 'Express',
      filter: 'Filter',
      groupBy: 'GroupBy',
      statistics: 'Statistics',
    };
  }

  static types(): { [key: string]: any } {
    return {
      express: { 'type': 'array', 'itemType': ModifyHybridMonitorTaskRequestSLSProcessConfigExpress },
      filter: ModifyHybridMonitorTaskRequestSLSProcessConfigFilter,
      groupBy: { 'type': 'array', 'itemType': ModifyHybridMonitorTaskRequestSLSProcessConfigGroupBy },
      statistics: { 'type': 'array', 'itemType': ModifyHybridMonitorTaskRequestSLSProcessConfigStatistics },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyMetricRuleBlackListRequestMetrics extends $tea.Model {
  /**
   * @remarks
   * The name of the metric.
   * 
   * Valid values of N: 1 to 10.
   * 
   * This parameter is required.
   * 
   * @example
   * disk_utilization
   */
  metricName?: string;
  /**
   * @remarks
   * The extended dimension of the instance. For example, `{"device":"C:"}` specifies that the blacklist policy is applied to all C disks of the specified Elastic Compute Service (ECS) instance.
   * 
   * Valid values of N: 1 to 10.
   * 
   * @example
   * {"device":"C:"}
   */
  resource?: string;
  static names(): { [key: string]: string } {
    return {
      metricName: 'MetricName',
      resource: 'Resource',
    };
  }

  static types(): { [key: string]: any } {
    return {
      metricName: 'string',
      resource: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyMetricRuleTemplateRequestAlertTemplatesEscalationsCritical extends $tea.Model {
  comparisonOperator?: string;
  n?: number;
  statistics?: string;
  threshold?: string;
  times?: number;
  static names(): { [key: string]: string } {
    return {
      comparisonOperator: 'ComparisonOperator',
      n: 'N',
      statistics: 'Statistics',
      threshold: 'Threshold',
      times: 'Times',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comparisonOperator: 'string',
      n: 'number',
      statistics: 'string',
      threshold: 'string',
      times: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyMetricRuleTemplateRequestAlertTemplatesEscalationsInfo extends $tea.Model {
  comparisonOperator?: string;
  n?: number;
  statistics?: string;
  threshold?: string;
  times?: number;
  static names(): { [key: string]: string } {
    return {
      comparisonOperator: 'ComparisonOperator',
      n: 'N',
      statistics: 'Statistics',
      threshold: 'Threshold',
      times: 'Times',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comparisonOperator: 'string',
      n: 'number',
      statistics: 'string',
      threshold: 'string',
      times: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyMetricRuleTemplateRequestAlertTemplatesEscalationsWarn extends $tea.Model {
  comparisonOperator?: string;
  n?: number;
  statistics?: string;
  threshold?: string;
  times?: number;
  static names(): { [key: string]: string } {
    return {
      comparisonOperator: 'ComparisonOperator',
      n: 'N',
      statistics: 'Statistics',
      threshold: 'Threshold',
      times: 'Times',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comparisonOperator: 'string',
      n: 'number',
      statistics: 'string',
      threshold: 'string',
      times: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyMetricRuleTemplateRequestAlertTemplatesEscalations extends $tea.Model {
  critical?: ModifyMetricRuleTemplateRequestAlertTemplatesEscalationsCritical;
  info?: ModifyMetricRuleTemplateRequestAlertTemplatesEscalationsInfo;
  warn?: ModifyMetricRuleTemplateRequestAlertTemplatesEscalationsWarn;
  static names(): { [key: string]: string } {
    return {
      critical: 'Critical',
      info: 'Info',
      warn: 'Warn',
    };
  }

  static types(): { [key: string]: any } {
    return {
      critical: ModifyMetricRuleTemplateRequestAlertTemplatesEscalationsCritical,
      info: ModifyMetricRuleTemplateRequestAlertTemplatesEscalationsInfo,
      warn: ModifyMetricRuleTemplateRequestAlertTemplatesEscalationsWarn,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyMetricRuleTemplateRequestAlertTemplates extends $tea.Model {
  escalations?: ModifyMetricRuleTemplateRequestAlertTemplatesEscalations;
  /**
   * @remarks
   * The abbreviation of the cloud service name.
   * 
   * Valid values of N: 1 to 200.
   * 
   * For more information about how to obtain the abbreviation of a cloud service name, see `metricCategory` in the response parameter `Labels` of the [DescribeProjectMeta](https://help.aliyun.com/document_detail/114916.html) operation.
   * 
   * @example
   * ecs
   */
  category?: string;
  /**
   * @remarks
   * The metric name.
   * 
   * Valid values of N: 1 to 200.
   * 
   * For information about how to obtain metrics, see [DescribeMetricMetaList](https://help.aliyun.com/document_detail/98846.html) or [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * @example
   * cpu_total
   */
  metricName?: string;
  /**
   * @remarks
   * The namespace of the cloud service.
   * 
   * Valid values of N: 1 to 200.
   * 
   * For information about how to obtain the namespace of a cloud service, see [DescribeMetricMetaList](https://help.aliyun.com/document_detail/98846.html) or [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * @example
   * acs_ecs_dashboard
   */
  namespace?: string;
  /**
   * @remarks
   * The statistical period of the monitoring data.
   * 
   * Valid values of N: 1 to 200.
   * 
   * > If the value is set to 300 seconds, the monitoring data is collected every 300 seconds. If the monitoring data is reported every 1 minute, the alert system calculates the average, maximum, and minimum values of the monitoring data of 5 minutes and checks whether the aggregated values exceed the threshold. To prevent unexpected alerts, we recommend that you set this parameter together with other parameters.
   * 
   * @example
   * 60
   */
  period?: number;
  /**
   * @remarks
   * The name of the alert rule.
   * 
   * Valid values of N: 1 to 200.
   * 
   * @example
   * rule1
   */
  ruleName?: string;
  /**
   * @remarks
   * The dimension of the alert. It is an extended field.
   * 
   * Valid values of N: 1 to 200.
   * 
   * For example, an alert template is applied to an application group, this parameter is set to `{"disk":"/"}`, and the MetricName parameter is set to `DiskUtilization`. In this case, the generated alert rule is applied to the root disk partition (`"/"`) of all instances in the application group to which the alert template is applied.
   * 
   * > For more information about the values of extended fields, see [DescribeMetricRuleTemplateAttribute](https://help.aliyun.com/document_detail/114979.html).
   * 
   * @example
   * {"disk":"/"}
   */
  selector?: string;
  /**
   * @remarks
   * The callback URL.
   * 
   * Valid values of N: 1 to 200.
   * 
   * The callback URL must be accessible over the Internet. CloudMonitor pushes an alert notification to the specified callback URL by sending an HTTP POST request. Only the HTTP protocol is supported.
   * 
   * @example
   * https://apiwebhook.hipac.cn/api/v1/alarm/aly/eregfeeferrtbnmkdszp
   */
  webhook?: string;
  static names(): { [key: string]: string } {
    return {
      escalations: 'Escalations',
      category: 'Category',
      metricName: 'MetricName',
      namespace: 'Namespace',
      period: 'Period',
      ruleName: 'RuleName',
      selector: 'Selector',
      webhook: 'Webhook',
    };
  }

  static types(): { [key: string]: any } {
    return {
      escalations: ModifyMetricRuleTemplateRequestAlertTemplatesEscalations,
      category: 'string',
      metricName: 'string',
      namespace: 'string',
      period: 'number',
      ruleName: 'string',
      selector: 'string',
      webhook: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyMonitorGroupInstancesRequestInstances extends $tea.Model {
  /**
   * @remarks
   * The abbreviation of the name of the service to which the instances to be added to the application group belong. Valid values:
   * 
   * *   ECS: Elastic Compute Service (ECS) instances provided by Alibaba Cloud and hosts not provided by Alibaba Cloud
   * 
   * *   RDS: ApsaraDB for RDS
   * 
   * *   ADS: AnalyticDB
   * 
   * *   SLB: Server Load Balancer (SLB)
   * 
   * *   VPC: Virtual Private Cloud (VPC)
   * 
   * *   APIGATEWAY: API Gateway
   * 
   * *   CDN: Alibaba Cloud Content Delivery Network (CDN)
   * 
   * *   CS: Container Service for Swarm
   * 
   * *   DCDN: Dynamic Route for CDN
   * 
   * *   DDoS: Anti-DDoS Pro
   * 
   * *   EIP: Elastic IP Address (EIP)
   * 
   * *   ELASTICSEARCH: Elasticsearch
   * 
   * *   EMR: E-MapReduce
   * 
   * *   ESS: Auto Scaling
   * 
   * *   HBASE: ApsaraDB for Hbase
   * 
   * *   IOT_EDGE: IoT Edge
   * 
   * *   K8S_POD: pods in Container Service for Kubernetes
   * 
   * *   KVSTORE_SHARDING: ApsaraDB for Redis of the cluster architecture
   * 
   * *   KVSTORE_SPLITRW: ApsaraDB for Redis of the read/write splitting architecture
   * 
   * *   KVSTORE_STANDARD: ApsaraDB for Redis of the standard architecture
   * 
   * *   MEMCACHE: ApsaraDB for Memcache
   * 
   * *   MNS: Message Service (MNS)
   * 
   * *   MONGODB: ApsaraDB for MongoDB of the replica set architecture
   * 
   * *   MONGODB_CLUSTER: ApsaraDB for MongoDB of the cluster architecture
   * 
   * *   MONGODB_SHARDING: ApsaraDB for MongoDB of the sharded cluster architecture
   * 
   * *   MQ_TOPIC: MNS topics
   * 
   * *   OCS: ApsaraDB for Memcache of earlier versions
   * 
   * *   OPENSEARCH: Open Search
   * 
   * *   OSS: Object Storage Service (OSS)
   * 
   * *   POLARDB: PolarDB
   * 
   * *   PETADATA: HybridDB for MySQL
   * 
   * *   SCDN: Secure Content Delivery Network (SCDN)
   * 
   * *   SHAREBANDWIDTHPACKAGES: EIP Bandwidth Plan
   * 
   * *   SLS: Log Service
   * 
   * *   VPN: VPN Gateway
   * 
   *     Valid values of N: 1 to 2000.
   * 
   * This parameter is required.
   * 
   * @example
   * ECS
   */
  category?: string;
  /**
   * @remarks
   * The ID of the instance. Valid values of N: 1 to 2000.
   * 
   * This parameter is required.
   * 
   * @example
   * i-a2d5q7pm12****
   */
  instanceId?: string;
  /**
   * @remarks
   * The name of the instance. Valid values of N: 1 to 2000.
   * 
   * This parameter is required.
   * 
   * @example
   * HostName
   */
  instanceName?: string;
  /**
   * @remarks
   * The ID of the region where the instance resides. Valid values of N: 1 to 2000.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      instanceId: 'string',
      instanceName: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifySiteMonitorResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The number of site monitoring tasks.
   * 
   * @example
   * 1
   */
  count?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'count',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutContactRequestChannels extends $tea.Model {
  /**
   * @remarks
   * The TradeManager ID of the alert contact.
   * 
   * Specify at least one of the following alert notification targets: email address or webhook URL of the DingTalk chatbot.
   * 
   * @example
   * Jim
   */
  aliIM?: string;
  /**
   * @remarks
   * The webhook URL of the DingTalk chatbot.
   * 
   * Specify at least one of the following alert notification targets: email address or webhook URL of the DingTalk chatbot.
   * 
   * @example
   * https://oapi.dingtalk.com/robot/send?access_token=7d49515e8ebf21106a80a9cc4bb3d247771305d52fb15d6201234565****
   */
  dingWebHook?: string;
  /**
   * @remarks
   * The email address of the alert contact. After you add or modify an email address, the recipient receives an email that contains an activation link. The system adds the recipient to the list of alert contacts only after the recipient activates the email address.
   * 
   * Specify at least one of the following alert notification targets: email address or webhook URL of the DingTalk chatbot.
   * 
   * @example
   * test@aliyun.com
   */
  mail?: string;
  /**
   * @remarks
   * The phone number of the alert contact. After you add or modify a phone number, the recipient receives a text message that contains an activation link. The system adds the recipient to the list of alert contacts only after the recipient activates the phone number.
   * 
   * Specify at least one of the following alert notification targets: email address or webhook URL of the DingTalk chatbot.
   * 
   * @example
   * 1333333****
   */
  SMS?: string;
  static names(): { [key: string]: string } {
    return {
      aliIM: 'AliIM',
      dingWebHook: 'DingWebHook',
      mail: 'Mail',
      SMS: 'SMS',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliIM: 'string',
      dingWebHook: 'string',
      mail: 'string',
      SMS: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutCustomEventRequestEventInfo extends $tea.Model {
  /**
   * @remarks
   * The event content. Valid values of N: 1 to 50.
   * 
   * This parameter is required.
   * 
   * @example
   * IOException
   */
  content?: string;
  /**
   * @remarks
   * The event name. Valid values of N: 1 to 50.
   * 
   * This parameter is required.
   * 
   * @example
   * myEvent
   */
  eventName?: string;
  /**
   * @remarks
   * The ID of the application group. Valid values of N: 1 to 50.
   * 
   * Default value: 0. This value indicates that the event to be reported does not belong to any application group.
   * 
   * @example
   * 123456
   */
  groupId?: string;
  /**
   * @remarks
   * The time when the event occurred.
   * 
   * Format: `yyyyMMddTHHmmss.SSSZ`.
   * 
   * Valid values of N: 1 to 50.
   * 
   * >  You can also specify a UNIX timestamp. Example: 1552199984000. Unit: milliseconds.
   * 
   * @example
   * 20171013T170923.456+0800
   */
  time?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      eventName: 'EventName',
      groupId: 'GroupId',
      time: 'Time',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      eventName: 'string',
      groupId: 'string',
      time: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutCustomMetricRequestMetricList extends $tea.Model {
  /**
   * @remarks
   * The dimensions that specify the resources whose monitoring data you want to query. Valid values of N: 1 to 21.
   * 
   * Set the value to a collection of key-value pairs. Format:`{"Key":"Value"}`.
   * 
   * The key or value must be 1 to 64 bytes in length. Excessive characters are truncated.
   * 
   * The key or value can contain letters, digits, periods (.), hyphens (-), underscores (_), forward slashes (/), and backslashes (\\\\).
   * 
   * >  Dimensions must be formatted as a JSON string in a specified order.
   * 
   * This parameter is required.
   * 
   * @example
   * {"sampleName1":"value1","sampleName2":"value2"}
   */
  dimensions?: string;
  /**
   * @remarks
   * The ID of the application group. Valid values of N: 1 to 21.
   * 
   * >  If the metric does not belong to any application group, enter 0.
   * 
   * This parameter is required.
   * 
   * @example
   * 12345
   */
  groupId?: string;
  /**
   * @remarks
   * The name of the metric. Valid values of N: 1 to 21. For more information, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * This parameter is required.
   * 
   * @example
   * cpu_total
   */
  metricName?: string;
  /**
   * @remarks
   * The aggregation period. Valid values of N: 1 to 21. Unit: seconds. Valid values: 60 and 300.
   * 
   * >  If the MetricList.N.Type parameter is set to 1, the MetricList.N.Period parameter is required.
   * 
   * @example
   * 60
   */
  period?: string;
  /**
   * @remarks
   * The timestamp when the metric data is generated. Valid values of N: 1 to 21. The timestamp can be in one of the following formats:
   * 
   * *   The UTC timestamp that is in the YYYY-MM-DDThh:mm:ssZ format. Example: 20171012T132456.888+0800.
   * *   The UNIX timestamp of the LONG type. Example: 1508136760000.
   * 
   * @example
   * 1508136760000
   */
  time?: string;
  /**
   * @remarks
   * The type of the reported data. Valid values of N: 1 to 21. Valid values:
   * 
   * *   0: reports raw data
   * *   1: reports aggregate data
   * 
   * >  We recommend that you report aggregate data in both the aggregation periods of 60s and 300s. Otherwise, you cannot query monitoring data in a time span that is more than seven days.
   * 
   * This parameter is required.
   * 
   * @example
   * 0
   */
  type?: string;
  /**
   * @remarks
   * The collection of metric values. Valid values of N: 1 to 21.
   * 
   * >  If the MetricList.N.Type parameter is set to 0, the keys in this parameter must be set to the specified value. CloudMonitor aggregates raw data in each aggregation period to generate multiple statistical values, such as the maximum value, the count, and the total value.
   * 
   * This parameter is required.
   * 
   * @example
   * {"value":10.5}
   */
  values?: string;
  static names(): { [key: string]: string } {
    return {
      dimensions: 'Dimensions',
      groupId: 'GroupId',
      metricName: 'MetricName',
      period: 'Period',
      time: 'Time',
      type: 'Type',
      values: 'Values',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dimensions: 'string',
      groupId: 'string',
      metricName: 'string',
      period: 'string',
      time: 'string',
      type: 'string',
      values: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutEventRuleRequestEventPattern extends $tea.Model {
  /**
   * @remarks
   * The keyword that is used to filter events. If the content of an event contains the specified keyword, an alert is automatically triggered.
   * 
   * @example
   * Stopping
   */
  customFilters?: string;
  /**
   * @example
   * Exception
   */
  eventTypeList?: string[];
  /**
   * @example
   * CRITICAL
   */
  levelList?: string[];
  /**
   * @example
   * Agent_Status_Stopped
   */
  nameList?: string[];
  /**
   * @remarks
   * The type of the cloud service. Valid values of N: 1 to 50.
   * 
   * >  You can call the DescribeSystemEventMetaList operation to query the cloud services that support event-triggered alerts. For more information, see [DescribeSystemEventMetaList](https://help.aliyun.com/document_detail/114972.html).
   * 
   * This parameter is required.
   * 
   * @example
   * ecs
   */
  product?: string;
  /**
   * @remarks
   * The SQL condition that is used to filter events. If the content of an event meets the specified SQL condition, an alert is automatically triggered.
   * 
   * >  The syntax of SQL event filtering is consistent with the query syntax of Log Service.
   * 
   * @example
   * 192.168.XX.XX and Executed
   */
  SQLFilter?: string;
  /**
   * @example
   * Failed
   */
  statusList?: string[];
  static names(): { [key: string]: string } {
    return {
      customFilters: 'CustomFilters',
      eventTypeList: 'EventTypeList',
      levelList: 'LevelList',
      nameList: 'NameList',
      product: 'Product',
      SQLFilter: 'SQLFilter',
      statusList: 'StatusList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      customFilters: 'string',
      eventTypeList: { 'type': 'array', 'itemType': 'string' },
      levelList: { 'type': 'array', 'itemType': 'string' },
      nameList: { 'type': 'array', 'itemType': 'string' },
      product: 'string',
      SQLFilter: 'string',
      statusList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutEventRuleTargetsRequestContactParameters extends $tea.Model {
  /**
   * @remarks
   * The name of the alert contact group. Valid values of N: 1 to 5.
   */
  contactGroupName?: string;
  /**
   * @remarks
   * The ID of the recipient that receives alert notifications. Valid values of N: 1 to 5.
   * 
   * @example
   * 2
   */
  id?: string;
  /**
   * @remarks
   * The alert level and the corresponding notification methods. Valid values of N: 1 to 5. Valid values:
   * 
   * 4: Alert notifications are sent by using DingTalk chatbots and emails.
   * 
   * @example
   * 3
   */
  level?: string;
  static names(): { [key: string]: string } {
    return {
      contactGroupName: 'ContactGroupName',
      id: 'Id',
      level: 'Level',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contactGroupName: 'string',
      id: 'string',
      level: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutEventRuleTargetsRequestFcParameters extends $tea.Model {
  /**
   * @remarks
   * The name of the function. Valid values of N: 1 to 5.
   * 
   * @example
   * fc-test
   */
  functionName?: string;
  /**
   * @remarks
   * The ID of the recipient that receives alert notifications. Valid values of N: 1 to 5.
   * 
   * @example
   * 1
   */
  id?: string;
  /**
   * @remarks
   * The region where Function Compute is deployed. Valid values of N: 1 to 5.
   * 
   * @example
   * cn-hangzhou
   */
  region?: string;
  /**
   * @remarks
   * The name of the Function Compute service. Valid values of N: 1 to 5.
   * 
   * @example
   * fc-test
   */
  serviceName?: string;
  static names(): { [key: string]: string } {
    return {
      functionName: 'FunctionName',
      id: 'Id',
      region: 'Region',
      serviceName: 'ServiceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      functionName: 'string',
      id: 'string',
      region: 'string',
      serviceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutEventRuleTargetsRequestMnsParameters extends $tea.Model {
  /**
   * @remarks
   * The ID of the recipient that receives alert notifications. Valid values of N: 1 to 5.
   * 
   * @example
   * 3
   */
  id?: string;
  /**
   * @remarks
   * The name of the MNS queue. Valid values of N: 1 to 5.
   * 
   * @example
   * queue1
   */
  queue?: string;
  /**
   * @remarks
   * The region where Message Service (MNS) is deployed. Valid values of N: 1 to 5.
   * 
   * @example
   * cn-hangzhou
   */
  region?: string;
  /**
   * @remarks
   * The MNS topic.
   * 
   * @example
   * topic_sample
   */
  topic?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      queue: 'Queue',
      region: 'Region',
      topic: 'Topic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      queue: 'string',
      region: 'string',
      topic: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutEventRuleTargetsRequestOpenApiParameters extends $tea.Model {
  /**
   * @remarks
   * The API name.
   * 
   * @example
   * PutLogs
   */
  action?: string;
  /**
   * @remarks
   * The Alibaba Cloud Resource Name (ARN) of the resource. Valid values of N: 1 to 5. Format: `arn:acs:${Service}:${Region}:${Account}:${ResourceType}/${ResourceId}`. Fields:
   * 
   * *   Service: the code of a cloud service
   * *   Region: the region ID
   * *   Account: the ID of an Alibaba Cloud account
   * *   ResourceType: the resource type
   * *   ResourceId: the resource ID
   */
  arn?: string;
  /**
   * @remarks
   * The ID of the recipient that receives alert notifications sent by an API callback.
   * 
   * @example
   * 3
   */
  id?: string;
  /**
   * @remarks
   * The parameters of the alert callback. Specify the parameters in the JSON format.
   * 
   * @example
   * {"customField1":"value1","customField2":"$.name"}
   */
  jsonParams?: string;
  /**
   * @remarks
   * The ID of the cloud service to which the API operation belongs.
   * 
   * @example
   * log
   */
  product?: string;
  /**
   * @remarks
   * The region where the resource resides.
   * 
   * @example
   * cn-hangzhou
   */
  region?: string;
  /**
   * @remarks
   * The name of the role.
   * 
   * @example
   * MyRole
   */
  role?: string;
  /**
   * @remarks
   * The version of the API.
   * 
   * @example
   * 2019-01-01
   */
  version?: string;
  static names(): { [key: string]: string } {
    return {
      action: 'Action',
      arn: 'Arn',
      id: 'Id',
      jsonParams: 'JsonParams',
      product: 'Product',
      region: 'Region',
      role: 'Role',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      action: 'string',
      arn: 'string',
      id: 'string',
      jsonParams: 'string',
      product: 'string',
      region: 'string',
      role: 'string',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutEventRuleTargetsRequestSlsParameters extends $tea.Model {
  /**
   * @remarks
   * The ID of the recipient that receives alert notifications. Valid values of N: 1 to 5.
   * 
   * @example
   * 5
   */
  id?: string;
  /**
   * @remarks
   * The name of the Simple Log Service Logstore. Valid values of N: 1 to 5.
   * 
   * @example
   * testlogstore
   */
  logStore?: string;
  /**
   * @remarks
   * The name of the Simple Log Service project. Valid values of N: 1 to 5.
   * 
   * @example
   * testproject
   */
  project?: string;
  /**
   * @remarks
   * The region where Simple Log Service is deployed. Valid values of N: 1 to 5.
   * 
   * @example
   * cn-hangzhou
   */
  region?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      logStore: 'LogStore',
      project: 'Project',
      region: 'Region',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      logStore: 'string',
      project: 'string',
      region: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutEventRuleTargetsRequestWebhookParameters extends $tea.Model {
  /**
   * @remarks
   * The ID of the recipient that receives alert notifications. Valid values of N: 1 to 5.
   * 
   * @example
   * 4
   */
  id?: string;
  /**
   * @remarks
   * The HTTP request method. Valid values of N: 1 to 5.
   * 
   * Valid values: GET and POST.
   * 
   * @example
   * GET
   */
  method?: string;
  /**
   * @remarks
   * The name of the protocol. Valid values of N: 1 to 5. Valid values:
   * 
   * *   http
   * *   telnet
   * *   ping
   * 
   * @example
   * http
   */
  protocol?: string;
  /**
   * @remarks
   * The callback URL. Valid values of N: 1 to 5.
   * 
   * @example
   * http://www.aliyun.com
   */
  url?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      method: 'Method',
      protocol: 'Protocol',
      url: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      method: 'string',
      protocol: 'string',
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutEventRuleTargetsResponseBodyFailedContactParametersContactParameter extends $tea.Model {
  /**
   * @remarks
   * The name of the alert contact group.
   */
  contactGroupName?: string;
  /**
   * @remarks
   * The ID of the recipient.
   * 
   * @example
   * 2
   */
  id?: number;
  /**
   * @remarks
   * The alert level and the corresponding notification methods. Valid values:
   * 
   * 4: Alert notifications are sent by using DingTalk chatbots and emails.
   * 
   * @example
   * 3
   */
  level?: string;
  static names(): { [key: string]: string } {
    return {
      contactGroupName: 'ContactGroupName',
      id: 'Id',
      level: 'Level',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contactGroupName: 'string',
      id: 'number',
      level: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutEventRuleTargetsResponseBodyFailedContactParameters extends $tea.Model {
  contactParameter?: PutEventRuleTargetsResponseBodyFailedContactParametersContactParameter[];
  static names(): { [key: string]: string } {
    return {
      contactParameter: 'ContactParameter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contactParameter: { 'type': 'array', 'itemType': PutEventRuleTargetsResponseBodyFailedContactParametersContactParameter },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutEventRuleTargetsResponseBodyFailedFcParametersFcParameter extends $tea.Model {
  /**
   * @remarks
   * The name of the function.
   * 
   * @example
   * functionTest1
   */
  functionName?: string;
  /**
   * @remarks
   * The ID of the recipient.
   * 
   * @example
   * 1
   */
  id?: number;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  region?: string;
  /**
   * @remarks
   * The name of the Function Compute service.
   * 
   * @example
   * serviceTest1
   */
  serviceName?: string;
  static names(): { [key: string]: string } {
    return {
      functionName: 'FunctionName',
      id: 'Id',
      region: 'Region',
      serviceName: 'ServiceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      functionName: 'string',
      id: 'number',
      region: 'string',
      serviceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutEventRuleTargetsResponseBodyFailedFcParameters extends $tea.Model {
  fcParameter?: PutEventRuleTargetsResponseBodyFailedFcParametersFcParameter[];
  static names(): { [key: string]: string } {
    return {
      fcParameter: 'FcParameter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fcParameter: { 'type': 'array', 'itemType': PutEventRuleTargetsResponseBodyFailedFcParametersFcParameter },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutEventRuleTargetsResponseBodyFailedMnsParametersMnsParameter extends $tea.Model {
  /**
   * @remarks
   * The ID of the recipient.
   * 
   * @example
   * 2
   */
  id?: number;
  /**
   * @remarks
   * The name of the MNS queue.
   * 
   * @example
   * testQueue
   */
  queue?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  region?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      queue: 'Queue',
      region: 'Region',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      queue: 'string',
      region: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutEventRuleTargetsResponseBodyFailedMnsParameters extends $tea.Model {
  mnsParameter?: PutEventRuleTargetsResponseBodyFailedMnsParametersMnsParameter[];
  static names(): { [key: string]: string } {
    return {
      mnsParameter: 'MnsParameter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      mnsParameter: { 'type': 'array', 'itemType': PutEventRuleTargetsResponseBodyFailedMnsParametersMnsParameter },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutGroupMetricRuleRequestEscalationsCritical extends $tea.Model {
  /**
   * @remarks
   * The operator that is used to compare the metric value with the threshold for Critical-level alerts. Valid values:
   * 
   * *   GreaterThanOrEqualToThreshold: greater than or equal to the threshold
   * *   GreaterThanThreshold: greater than the threshold
   * *   LessThanOrEqualToThreshold: less than or equal to the threshold
   * *   LessThanThreshold: less than the threshold
   * *   NotEqualToThreshold: not equal to the threshold
   * *   GreaterThanYesterday: greater than the metric value at the same time yesterday
   * *   LessThanYesterday: less than the metric value at the same time yesterday
   * *   GreaterThanLastWeek: greater than the metric value at the same time last week
   * *   LessThanLastWeek: less than the metric value at the same time last week
   * *   GreaterThanLastPeriod: greater than the metric value in the last monitoring cycle
   * *   LessThanLastPeriod: less than the metric value in the last monitoring cycle
   * 
   * @example
   * GreaterThanOrEqualToThreshold
   */
  comparisonOperator?: string;
  /**
   * @remarks
   * The statistical methods for Critical-level alerts. Separate multiple statistical methods with commas (,).
   * 
   * The value of this parameter is determined by the `Statistics` column corresponding to the `MetricName` parameter of the specified cloud service. The value of this parameter can be Maximum, Minimum, or Average. For more information about how to obtain the value of this parameter, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * @example
   * Average
   */
  statistics?: string;
  /**
   * @remarks
   * The threshold for Critical-level alerts.
   * 
   * @example
   * 90
   */
  threshold?: string;
  /**
   * @remarks
   * The consecutive number of times for which the metric value meets the alert condition before a Critical-level alert is triggered.
   * 
   * @example
   * 3
   */
  times?: number;
  static names(): { [key: string]: string } {
    return {
      comparisonOperator: 'ComparisonOperator',
      statistics: 'Statistics',
      threshold: 'Threshold',
      times: 'Times',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comparisonOperator: 'string',
      statistics: 'string',
      threshold: 'string',
      times: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutGroupMetricRuleRequestEscalationsInfo extends $tea.Model {
  /**
   * @remarks
   * The operator that is used to compare the metric value with the threshold for Info-level alerts. Valid values:
   * 
   * *   GreaterThanOrEqualToThreshold: greater than or equal to the threshold
   * *   GreaterThanThreshold: greater than the threshold
   * *   LessThanOrEqualToThreshold: less than or equal to the threshold
   * *   LessThanThreshold: less than the threshold
   * *   NotEqualToThreshold: not equal to the threshold
   * *   GreaterThanYesterday: greater than the metric value at the same time yesterday
   * *   LessThanYesterday: less than the metric value at the same time yesterday
   * *   GreaterThanLastWeek: greater than the metric value at the same time last week
   * *   LessThanLastWeek: less than the metric value at the same time last week
   * *   GreaterThanLastPeriod: greater than the metric value in the last monitoring cycle
   * *   LessThanLastPeriod: less than the metric value in the last monitoring cycle
   * 
   * @example
   * GreaterThanOrEqualToThreshold
   */
  comparisonOperator?: string;
  /**
   * @remarks
   * The statistical methods for Info-level alerts. Separate multiple statistical methods with commas (,).
   * 
   * The value of this parameter is determined by the `Statistics` column corresponding to the `MetricName` parameter of the specified cloud service. The value of this parameter can be Maximum, Minimum, or Average. For more information about how to obtain the value of this parameter, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * @example
   * Average
   */
  statistics?: string;
  /**
   * @remarks
   * The threshold for Info-level alerts.
   * 
   * @example
   * 90
   */
  threshold?: string;
  /**
   * @remarks
   * The consecutive number of times for which the metric value meets the alert condition before an Info-level alert is triggered.
   * 
   * @example
   * 3
   */
  times?: number;
  static names(): { [key: string]: string } {
    return {
      comparisonOperator: 'ComparisonOperator',
      statistics: 'Statistics',
      threshold: 'Threshold',
      times: 'Times',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comparisonOperator: 'string',
      statistics: 'string',
      threshold: 'string',
      times: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutGroupMetricRuleRequestEscalationsWarn extends $tea.Model {
  /**
   * @remarks
   * The operator that is used to compare the metric value with the threshold for Warn-level alerts. Valid values:
   * 
   * *   GreaterThanOrEqualToThreshold: greater than or equal to the threshold
   * *   GreaterThanThreshold: greater than the threshold
   * *   LessThanOrEqualToThreshold: less than or equal to the threshold
   * *   LessThanThreshold: less than the threshold
   * *   NotEqualToThreshold: not equal to the threshold
   * *   GreaterThanYesterday: greater than the metric value at the same time yesterday
   * *   LessThanYesterday: less than the metric value at the same time yesterday
   * *   GreaterThanLastWeek: greater than the metric value at the same time last week
   * *   LessThanLastWeek: less than the metric value at the same time last week
   * *   GreaterThanLastPeriod: greater than the metric value in the last monitoring cycle
   * *   LessThanLastPeriod: less than the metric value in the last monitoring cycle
   * 
   * @example
   * GreaterThanOrEqualToThreshold
   */
  comparisonOperator?: string;
  /**
   * @remarks
   * The statistical methods for Warn-level alerts. Separate multiple statistical methods with commas (,).
   * 
   * The value of this parameter is determined by the `Statistics` column corresponding to the `MetricName` parameter of the specified cloud service. The value of this parameter can be Maximum, Minimum, or Average. For more information about how to obtain the value of this parameter, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * @example
   * Average
   */
  statistics?: string;
  /**
   * @remarks
   * The threshold for Warn-level alerts.
   * 
   * @example
   * 90
   */
  threshold?: string;
  /**
   * @remarks
   * The consecutive number of times for which the metric value meets the alert condition before a Warn-level alert is triggered.
   * 
   * @example
   * 3
   */
  times?: number;
  static names(): { [key: string]: string } {
    return {
      comparisonOperator: 'ComparisonOperator',
      statistics: 'Statistics',
      threshold: 'Threshold',
      times: 'Times',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comparisonOperator: 'string',
      statistics: 'string',
      threshold: 'string',
      times: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutGroupMetricRuleRequestEscalations extends $tea.Model {
  critical?: PutGroupMetricRuleRequestEscalationsCritical;
  info?: PutGroupMetricRuleRequestEscalationsInfo;
  warn?: PutGroupMetricRuleRequestEscalationsWarn;
  static names(): { [key: string]: string } {
    return {
      critical: 'Critical',
      info: 'Info',
      warn: 'Warn',
    };
  }

  static types(): { [key: string]: any } {
    return {
      critical: PutGroupMetricRuleRequestEscalationsCritical,
      info: PutGroupMetricRuleRequestEscalationsInfo,
      warn: PutGroupMetricRuleRequestEscalationsWarn,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutGroupMetricRuleRequestLabels extends $tea.Model {
  /**
   * @remarks
   * The tag key of the alert rule.
   * 
   * @example
   * key1
   */
  key?: string;
  /**
   * @remarks
   * The tag value of the alert rule.
   * 
   * @example
   * value1
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutGroupMetricRuleResponseBodyResult extends $tea.Model {
  /**
   * @remarks
   * The ID of the alert rule.
   * 
   * @example
   * 123456
   */
  ruleId?: string;
  static names(): { [key: string]: string } {
    return {
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ruleId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutHybridMonitorMetricDataRequestMetricListLabels extends $tea.Model {
  /**
   * @remarks
   * The tag key of the metric.
   * 
   * Valid values of N: 1 to 100.
   * 
   * The key can contain letters, digits, and underscores (_). The key must start with a letter or an underscore (_).
   * 
   * >  You must specify both the Key and Value parameters.
   * 
   * @example
   * IP
   */
  key?: string;
  /**
   * @remarks
   * The tag value of the metric.
   * 
   * Valid values of N: 1 to 100.
   * 
   * >  You must specify both the Key and Value parameters.
   * 
   * @example
   * 192.168.XX.XX
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutHybridMonitorMetricDataRequestMetricList extends $tea.Model {
  /**
   * @remarks
   * The tags of the metric.
   * 
   * Valid values of N: 1 to 100.
   * 
   * @example
   * app、ip、hostName等标识信息
   */
  labels?: PutHybridMonitorMetricDataRequestMetricListLabels[];
  /**
   * @remarks
   * The metric name.
   * 
   * Valid values of N: 1 to 100.
   * 
   * The name can contain letters, digits, and underscores (_). The name must start with a letter.
   * 
   * This parameter is required.
   * 
   * @example
   * CPU_Usage
   */
  name?: string;
  /**
   * @remarks
   * The time when the monitoring data is imported. The value is a timestamp.
   * 
   * Valid values of N: 1 to 100.
   * 
   * Unit: milliseconds. By default, the current time is used.
   * 
   * @example
   * 1640776119473
   */
  TS?: number;
  /**
   * @remarks
   * The value of the metric.
   * 
   * Valid values of N: 1 to 100.
   * 
   * The value must be an integer or a floating-point number.
   * 
   * This parameter is required.
   * 
   * @example
   * 90
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      labels: 'Labels',
      name: 'Name',
      TS: 'TS',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      labels: { 'type': 'array', 'itemType': PutHybridMonitorMetricDataRequestMetricListLabels },
      name: 'string',
      TS: 'number',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutHybridMonitorMetricDataResponseBodyErrorDetail extends $tea.Model {
  /**
   * @remarks
   * The error message of the invalid parameter.
   * 
   * @example
   * label name :123 not match [a-zA-Z_][a-zA-Z0-9_]*
   */
  errorMessage?: string;
  /**
   * @remarks
   * The position of the error message in the array.
   * 
   * @example
   * 0
   */
  index?: number;
  static names(): { [key: string]: string } {
    return {
      errorMessage: 'ErrorMessage',
      index: 'Index',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorMessage: 'string',
      index: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutLogMonitorRequestAggregates extends $tea.Model {
  /**
   * @remarks
   * The alias of the aggregate function. Valid values of N: 1 to 10.
   * 
   * This parameter is required.
   * 
   * @example
   * Count
   */
  alias?: string;
  /**
   * @remarks
   * The name of the field to be aggregated. Valid values of N: 1 to 10.
   * 
   * This parameter is required.
   * 
   * @example
   * sourceCount
   */
  fieldName?: string;
  /**
   * @remarks
   * The function that is used to aggregate log data within a statistical period. Valid values of N: 1 to 10. Valid values:
   * 
   * *   count: counts the number.
   * *   sum: calculates the total value.
   * *   avg: calculates the average value.
   * *   max: calculates the maximum value.
   * *   min: calculates the minimum value.
   * *   countps: calculates the number of values of the specified field divided by the total number of seconds within a statistical period.
   * *   sumps: calculates the sum of the values of the specified field divided by the total number of seconds within a statistical period.
   * *   distinct: calculates the number of unique values of the specified field within a statistical period.
   * 
   * This parameter is required.
   * 
   * @example
   * count
   */
  function?: string;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      fieldName: 'FieldName',
      function: 'Function',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      fieldName: 'string',
      function: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutLogMonitorRequestGroupbys extends $tea.Model {
  /**
   * @remarks
   * The alias of the dimension based on which the data is grouped. Valid values of N: 1 to 10.
   * 
   * @example
   * CPUUtilization
   */
  alias?: string;
  /**
   * @remarks
   * The name of the field that is specified as the dimension. Valid values of N: 1 to 10.
   * 
   * @example
   * cpu
   */
  fieldName?: string;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      fieldName: 'FieldName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      fieldName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutLogMonitorRequestValueFilter extends $tea.Model {
  /**
   * @remarks
   * The name of the log field that is used for matching in the filter condition. Valid values of N: 1 to 10.
   * 
   * @example
   * lh_source
   */
  key?: string;
  /**
   * @remarks
   * The method that is used to match the field value. Valid values of N: 1 to 10. Valid values:
   * 
   * *   `contain`: contains
   * *   `notContain`: does not contain
   * *   `>`: greater than
   * *   `<`: less than
   * *   `>=`: greater than or equal to
   * *   `<=`: less than or equal to
   * 
   * @example
   * contain
   */
  operator?: string;
  /**
   * @remarks
   * The field value to be matched in the filter condition. Valid values of N: 1 to 10.
   * 
   * @example
   * test
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      operator: 'Operator',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      operator: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutMetricRuleTargetsRequestTargets extends $tea.Model {
  /**
   * @remarks
   * The Alibaba Cloud Resource Name (ARN) of the resource. Message Service (MNS), Auto Scaling, Simple Log Service, and Function Compute are supported.
   * 
   * The following part describes the ARN of MNS and the parameters provided by the ARN:
   * 
   * `acs:mns:{regionId}:{userId}:/{Resource type}/{Resource name}/message`.
   * 
   * *   {regionId}: the region ID of the message queue or topic.
   * 
   * *   {userId}: the ID of the Alibaba Cloud account that owns the resource.
   * 
   * *   {Resource type}: the type of the resource for which alerts are triggered. Valid values:
   * 
   *     *   **queues**
   *     *   **topics**
   * 
   * *   {Resource name}: the resource name.
   * 
   *     *   If the resource type is **queues**, the resource name is the queue name.
   *     *   If the resource type is **topics**, the resource name is the topic name.
   * 
   * ARN of Auto Scaling:
   * 
   * acs:ess:{regionId}:{userId}:scalingGroupId/{Scaling group ID}:scalingRuleId/{Scaling rule ID}
   * 
   * ARN of Simple Log Service:
   * 
   * acs:log:{regionId}:{userId}:project/{Project name}/logstore/{Logstore name}
   * 
   * ARN of Function Compute:
   * 
   * acs:fc:{regionId}:{userId}:services/{Service name}/functions/{Function name}
   * 
   * This parameter is required.
   * 
   * @example
   * acs:mns:cn-hangzhou:120886317861****:/queues/test/message
   */
  arn?: string;
  /**
   * @remarks
   * The ID of the resource for which alerts are triggered.
   * 
   * For more information about how to obtain the ID of the resource for which alerts are triggered, see [DescribeMetricRuleTargets](https://help.aliyun.com/document_detail/121592.html).
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  id?: string;
  /**
   * @remarks
   * The JSON-formatted parameters of the alert callback.
   * 
   * @example
   * {"customField1":"value1","customField2":"$.name"}
   */
  jsonParams?: string;
  /**
   * @remarks
   * The alert level. Valid values:
   * 
   * *   INFO
   * *   WARN
   * *   CRITICAL
   * 
   * @example
   * ["INFO", "WARN", "CRITICAL"]
   */
  level?: string;
  static names(): { [key: string]: string } {
    return {
      arn: 'Arn',
      id: 'Id',
      jsonParams: 'JsonParams',
      level: 'Level',
    };
  }

  static types(): { [key: string]: any } {
    return {
      arn: 'string',
      id: 'string',
      jsonParams: 'string',
      level: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutMetricRuleTargetsResponseBodyFailDataTargetsTarget extends $tea.Model {
  /**
   * @remarks
   * The ARN of the resource. Format: `acs:{Service name abbreviation}:{regionId}:{userId}:/{Resource type}/{Resource name}/message`. MNS, Auto Scaling, Simple Log Service, and Function Compute are supported. Example: `acs:mns:cn-hangzhou:120886317861****:/queues/test123/message`. The following part describes the ARN of MNS and the parameters in the ARN:
   * 
   * *   {Service name abbreviation}: mns.
   * 
   * *   {userId}: the ID of the Alibaba Cloud account.
   * 
   * *   {regionId}: the region ID of the message queue or topic.
   * 
   * *   {Resource type}: the type of the resource for which alerts are triggered. Valid values:
   * 
   *     *   **queues**
   *     *   **topics**
   * 
   * *   {Resource name}: the resource name.
   * 
   *     *   If the resource type is **queues**, the resource name is the queue name.
   *     *   If the resource type is **topics**, the resource name is the topic name.
   * 
   * @example
   * acs:mns:cn-hangzhou:111:/queues/test/message
   */
  arn?: string;
  /**
   * @remarks
   * The ID of the resource for which alerts are triggered.
   * 
   * @example
   * 1
   */
  id?: string;
  /**
   * @remarks
   * The alert level. Valid values:
   * 
   * *   INFO
   * *   WARN
   * *   CRITICAL
   * 
   * @example
   * ["INFO", "WARN", "CRITICAL"]
   */
  level?: string;
  static names(): { [key: string]: string } {
    return {
      arn: 'Arn',
      id: 'Id',
      level: 'Level',
    };
  }

  static types(): { [key: string]: any } {
    return {
      arn: 'string',
      id: 'string',
      level: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutMetricRuleTargetsResponseBodyFailDataTargets extends $tea.Model {
  target?: PutMetricRuleTargetsResponseBodyFailDataTargetsTarget[];
  static names(): { [key: string]: string } {
    return {
      target: 'Target',
    };
  }

  static types(): { [key: string]: any } {
    return {
      target: { 'type': 'array', 'itemType': PutMetricRuleTargetsResponseBodyFailDataTargetsTarget },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutMetricRuleTargetsResponseBodyFailData extends $tea.Model {
  /**
   * @remarks
   * The information about the resources for which alerts are triggered.
   */
  targets?: PutMetricRuleTargetsResponseBodyFailDataTargets;
  static names(): { [key: string]: string } {
    return {
      targets: 'Targets',
    };
  }

  static types(): { [key: string]: any } {
    return {
      targets: PutMetricRuleTargetsResponseBodyFailDataTargets,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutMonitorGroupDynamicRuleRequestGroupRulesFilters extends $tea.Model {
  /**
   * @remarks
   * The method that is used to filter instances. Valid values of N: 1 to 3. Valid values:
   * 
   * *   contains: contains
   * *   notContains: does not contain
   * *   startWith: starts with a prefix
   * *   endWith: ends with a suffix
   * 
   * This parameter is required.
   * 
   * @example
   * contains
   */
  function?: string;
  /**
   * @remarks
   * The name of the field based on which instances are filtered. Valid values of N: 1 to 3.
   * 
   * Only hostnames are supported. Example: hostName.
   * 
   * This parameter is required.
   * 
   * @example
   * hostName
   */
  name?: string;
  /**
   * @remarks
   * The value to be matched with the specified field. Valid values of N: 1 to 3.
   * 
   * This parameter is required.
   * 
   * @example
   * nginx
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      function: 'Function',
      name: 'Name',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      function: 'string',
      name: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutMonitorGroupDynamicRuleRequestGroupRules extends $tea.Model {
  /**
   * @remarks
   * The cloud service to which the alert rule is applied. Valid values of N: 1 to 3. Valid values:
   * 
   * *   ecs: Elastic Compute Service (ECS)
   * *   rds: ApsaraDB RDS
   * *   slb: Server Load Balancer (SLB)
   * 
   * This parameter is required.
   * 
   * @example
   * ecs
   */
  category?: string;
  /**
   * @remarks
   * The logical operator used between conditional expressions in the alert rule. Valid values of N: 1 to 3. Valid values:
   * 
   * *   and: The instances that meet all the conditional expressions are automatically added to the application group.
   * *   or: The instances that meet one of the conditional expressions are automatically added to the application group.
   * 
   * This parameter is required.
   * 
   * @example
   * and
   */
  filterRelation?: string;
  /**
   * @remarks
   * None.
   * 
   * This parameter is required.
   */
  filters?: PutMonitorGroupDynamicRuleRequestGroupRulesFilters[];
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      filterRelation: 'FilterRelation',
      filters: 'Filters',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      filterRelation: 'string',
      filters: { 'type': 'array', 'itemType': PutMonitorGroupDynamicRuleRequestGroupRulesFilters },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutResourceMetricRuleRequestEscalationsCritical extends $tea.Model {
  /**
   * @remarks
   * The operator that is used to compare the metric value with the threshold for Critical-level alerts. Valid value:
   * 
   * *   GreaterThanOrEqualToThreshold: greater than or equal to the threshold
   * *   GreaterThanThreshold: greater than the threshold
   * *   LessThanOrEqualToThreshold: less than or equal to the threshold
   * *   LessThanThreshold: less than the threshold
   * *   NotEqualToThreshold: not equal to the threshold
   * *   GreaterThanYesterday: greater than the metric value at the same time yesterday
   * *   LessThanYesterday: less than the metric value at the same time yesterday
   * *   GreaterThanLastWeek: greater than the metric value at the same time last week
   * *   LessThanLastWeek: less than the metric value at the same time last week
   * *   GreaterThanLastPeriod: greater than the metric value in the last monitoring cycle
   * *   LessThanLastPeriod: less than the metric value in the last monitoring cycle
   * 
   * >  You must select at least one of the Critical, Warn, and Info alert levels and specify the Statistics, ComparisonOperator, Threshold, and Times parameters for each alert level.
   * 
   * @example
   * GreaterThanOrEqualToThreshold
   */
  comparisonOperator?: string;
  /**
   * @remarks
   * The statistical methods for Critical-level alerts.
   * 
   * The value of this parameter is determined by the `Statistics` column corresponding to the `MetricName` parameter of the specified cloud service. The value of this parameter can be Maximum, Minimum, or Average. For more information about how to obtain the value of this parameter, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * >  You must select at least one of the Critical, Warn, and Info alert levels and specify the Statistics, ComparisonOperator, Threshold, and Times parameters for each alert level.
   * 
   * @example
   * Average
   */
  statistics?: string;
  /**
   * @remarks
   * The threshold for Critical-level alerts.
   * 
   * >  You must select at least one of the Critical, Warn, and Info alert levels and specify the Statistics, ComparisonOperator, Threshold, and Times parameters for each alert level.
   * 
   * @example
   * 90
   */
  threshold?: string;
  /**
   * @remarks
   * The consecutive number of times for which the metric value meets the alert condition before a Critical-level alert is triggered.
   * 
   * >  You must select at least one of the Critical, Warn, and Info alert levels and specify the Statistics, ComparisonOperator, Threshold, and Times parameters for each alert level.
   * 
   * @example
   * 3
   */
  times?: number;
  static names(): { [key: string]: string } {
    return {
      comparisonOperator: 'ComparisonOperator',
      statistics: 'Statistics',
      threshold: 'Threshold',
      times: 'Times',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comparisonOperator: 'string',
      statistics: 'string',
      threshold: 'string',
      times: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutResourceMetricRuleRequestEscalationsInfo extends $tea.Model {
  /**
   * @remarks
   * The operator that is used to compare the metric value with the threshold for Info-level alerts. Valid value:
   * 
   * *   GreaterThanOrEqualToThreshold: greater than or equal to the threshold
   * *   GreaterThanThreshold: greater than the threshold
   * *   LessThanOrEqualToThreshold: less than or equal to the threshold
   * *   LessThanThreshold: less than the threshold
   * *   NotEqualToThreshold: not equal to the threshold
   * *   GreaterThanYesterday: greater than the metric value at the same time yesterday
   * *   LessThanYesterday: less than the metric value at the same time yesterday
   * *   GreaterThanLastWeek: greater than the metric value at the same time last week
   * *   LessThanLastWeek: less than the metric value at the same time last week
   * *   GreaterThanLastPeriod: greater than the metric value in the last monitoring cycle
   * *   LessThanLastPeriod: less than the metric value in the last monitoring cycle
   * 
   * >  You must select at least one of the Critical, Warn, and Info alert levels and specify the Statistics, ComparisonOperator, Threshold, and Times parameters for each alert level.
   * 
   * @example
   * GreaterThanOrEqualToThreshold
   */
  comparisonOperator?: string;
  /**
   * @remarks
   * The statistical methods for Info-level alerts.
   * 
   * The value of this parameter is determined by the `Statistics` column corresponding to the `MetricName` parameter of the specified cloud service. The value of this parameter can be Maximum, Minimum, or Average. For more information about how to obtain the value of this parameter, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * >  You must select at least one of the Critical, Warn, and Info alert levels and specify the Statistics, ComparisonOperator, Threshold, and Times parameters for each alert level.
   * 
   * @example
   * Average
   */
  statistics?: string;
  /**
   * @remarks
   * The threshold for Info-level alerts.
   * 
   * >  You must select at least one of the Critical, Warn, and Info alert levels and specify the Statistics, ComparisonOperator, Threshold, and Times parameters for each alert level.
   * 
   * @example
   * 90
   */
  threshold?: string;
  /**
   * @remarks
   * The consecutive number of times for which the metric value meets the alert condition before an Info-level alert is triggered.
   * 
   * >  You must select at least one of the Critical, Warn, and Info alert levels and specify the Statistics, ComparisonOperator, Threshold, and Times parameters for each alert level.
   * 
   * @example
   * 3
   */
  times?: number;
  static names(): { [key: string]: string } {
    return {
      comparisonOperator: 'ComparisonOperator',
      statistics: 'Statistics',
      threshold: 'Threshold',
      times: 'Times',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comparisonOperator: 'string',
      statistics: 'string',
      threshold: 'string',
      times: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutResourceMetricRuleRequestEscalationsWarn extends $tea.Model {
  /**
   * @remarks
   * The operator that is used to compare the metric value with the threshold for Warn-level alerts. Valid value:
   * 
   * *   GreaterThanOrEqualToThreshold: greater than or equal to the threshold
   * *   GreaterThanThreshold: greater than the threshold
   * *   LessThanOrEqualToThreshold: less than or equal to the threshold
   * *   LessThanThreshold: less than the threshold
   * *   NotEqualToThreshold: not equal to the threshold
   * *   GreaterThanYesterday: greater than the metric value at the same time yesterday
   * *   LessThanYesterday: less than the metric value at the same time yesterday
   * *   GreaterThanLastWeek: greater than the metric value at the same time last week
   * *   LessThanLastWeek: less than the metric value at the same time last week
   * *   GreaterThanLastPeriod: greater than the metric value in the last monitoring cycle
   * *   LessThanLastPeriod: less than the metric value in the last monitoring cycle
   * 
   * >  You must select at least one of the Critical, Warn, and Info alert levels and specify the Statistics, ComparisonOperator, Threshold, and Times parameters for each alert level.
   * 
   * @example
   * GreaterThanOrEqualToThreshold
   */
  comparisonOperator?: string;
  /**
   * @remarks
   * The statistical methods for Warn-level alerts.
   * 
   * The value of this parameter is determined by the `Statistics` column corresponding to the `MetricName` parameter of the specified cloud service. The value of this parameter can be Maximum, Minimum, or Average. For more information about how to obtain the value of this parameter, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * >  You must select at least one of the Critical, Warn, and Info alert levels and specify the Statistics, ComparisonOperator, Threshold, and Times parameters for each alert level.
   * 
   * @example
   * Average
   */
  statistics?: string;
  /**
   * @remarks
   * The threshold for Warn-level alerts.
   * 
   * >  You must select at least one of the Critical, Warn, and Info alert levels and specify the Statistics, ComparisonOperator, Threshold, and Times parameters for each alert level.
   * 
   * @example
   * 90
   */
  threshold?: string;
  /**
   * @remarks
   * The consecutive number of times for which the metric value meets the alert condition before a Warn-level alert is triggered.
   * 
   * >  You must select at least one of the Critical, Warn, and Info alert levels and specify the Statistics, ComparisonOperator, Threshold, and Times parameters for each alert level.
   * 
   * @example
   * 3
   */
  times?: number;
  static names(): { [key: string]: string } {
    return {
      comparisonOperator: 'ComparisonOperator',
      statistics: 'Statistics',
      threshold: 'Threshold',
      times: 'Times',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comparisonOperator: 'string',
      statistics: 'string',
      threshold: 'string',
      times: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutResourceMetricRuleRequestEscalations extends $tea.Model {
  critical?: PutResourceMetricRuleRequestEscalationsCritical;
  info?: PutResourceMetricRuleRequestEscalationsInfo;
  warn?: PutResourceMetricRuleRequestEscalationsWarn;
  static names(): { [key: string]: string } {
    return {
      critical: 'Critical',
      info: 'Info',
      warn: 'Warn',
    };
  }

  static types(): { [key: string]: any } {
    return {
      critical: PutResourceMetricRuleRequestEscalationsCritical,
      info: PutResourceMetricRuleRequestEscalationsInfo,
      warn: PutResourceMetricRuleRequestEscalationsWarn,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutResourceMetricRuleRequestCompositeExpressionExpressionList extends $tea.Model {
  /**
   * @remarks
   * The operator that is used to compare the metric value with the threshold. Valid value:
   * 
   * *   GreaterThanOrEqualToThreshold: greater than or equal to the threshold
   * *   GreaterThanThreshold: greater than the threshold
   * *   LessThanOrEqualToThreshold: less than or equal to the threshold
   * *   LessThanThreshold: less than the threshold
   * *   NotEqualToThreshold: not equal to the threshold
   * *   GreaterThanYesterday: greater than the metric value at the same time yesterday
   * *   LessThanYesterday: less than the metric value at the same time yesterday
   * *   GreaterThanLastWeek: greater than the metric value at the same time last week
   * *   LessThanLastWeek: less than the metric value at the same time last week
   * *   GreaterThanLastPeriod: greater than the metric value in the last monitoring cycle
   * *   LessThanLastPeriod: less than the metric value in the last monitoring cycle
   * 
   * @example
   * GreaterThanOrEqualToThreshold
   */
  comparisonOperator?: string;
  /**
   * @remarks
   * The metric that is used to monitor the cloud service.
   * 
   * @example
   * cpu_total
   */
  metricName?: string;
  /**
   * @remarks
   * The aggregation period of the metric.
   * 
   * Unit: seconds.
   * 
   * @example
   * 60
   */
  period?: number;
  /**
   * @remarks
   * The statistical method of the metric. Valid value:
   * 
   * *   $Maximum: the maximum value
   * *   $Minimum: the minimum value
   * *   $Average: the average value
   * *   $Availability: the availability rate (usually used for site monitoring)
   * 
   * >  `$` is the prefix of the metric. For information about the Alibaba Cloud services that are supported by CloudMonitor, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * @example
   * $Maximum
   */
  statistics?: string;
  /**
   * @remarks
   * The alert threshold.
   * 
   * @example
   * 90
   */
  threshold?: string;
  static names(): { [key: string]: string } {
    return {
      comparisonOperator: 'ComparisonOperator',
      metricName: 'MetricName',
      period: 'Period',
      statistics: 'Statistics',
      threshold: 'Threshold',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comparisonOperator: 'string',
      metricName: 'string',
      period: 'number',
      statistics: 'string',
      threshold: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutResourceMetricRuleRequestCompositeExpression extends $tea.Model {
  /**
   * @remarks
   * The trigger conditions that are created in standard mode.
   */
  expressionList?: PutResourceMetricRuleRequestCompositeExpressionExpressionList[];
  /**
   * @remarks
   * The relationship between the trigger conditions for multiple metrics. Valid value:
   * 
   * *   `&&`: An alert is triggered only if all metrics meet the trigger conditions. An alert is triggered only if the results of all expressions specified in the ExpressionList parameter are `true`.
   * *   `||`: An alert is triggered if one of the metrics meets the trigger conditions.
   * 
   * @example
   * ||
   */
  expressionListJoin?: string;
  /**
   * @remarks
   * The trigger conditions that are created by using expressions. You can use expressions to create trigger conditions in the following scenarios:
   * 
   * *   Set an alert blacklist for specific resources. For example, if you specify `$instanceId != \\"i-io8kfvcpp7x5****\\" ``&&`` $Average > 50`, no alert is triggered when the `average metric value` of the `i-io8kfvcpp7x5****` instance exceeds 50.
   * *   Set a special alert threshold for a specified instance in the rule. For example, if you specify `$Average > ($instanceId == \\"i-io8kfvcpp7x5****\\"? 80: 50)`, an alert is triggered when the `average metric value` of the `i-io8kfvcpp7x5****` instance exceeds 80 or the `average metric value` of other instances exceeds 50.
   * *   Limit the number of instances whose metric values exceed the threshold. For example, if you specify `count($Average > 20) > 3`, an alert is triggered only when the `average metric value` of more than three instances exceeds 20.
   * 
   * @example
   * $Average > ($instanceId == \\"i-io8kfvcpp7x5****\\"? 80: 50)
   */
  expressionRaw?: string;
  /**
   * @remarks
   * The alert level. Valid values:
   * 
   * *   Critical
   * *   Warn
   * *   Info
   * 
   * @example
   * Critical
   */
  level?: string;
  /**
   * @remarks
   * The number of consecutive triggers. If the number of times that the metric values meet the trigger conditions reaches the value of this parameter, CloudMonitor sends alert notifications.
   * 
   * @example
   * 3
   */
  times?: number;
  static names(): { [key: string]: string } {
    return {
      expressionList: 'ExpressionList',
      expressionListJoin: 'ExpressionListJoin',
      expressionRaw: 'ExpressionRaw',
      level: 'Level',
      times: 'Times',
    };
  }

  static types(): { [key: string]: any } {
    return {
      expressionList: { 'type': 'array', 'itemType': PutResourceMetricRuleRequestCompositeExpressionExpressionList },
      expressionListJoin: 'string',
      expressionRaw: 'string',
      level: 'string',
      times: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutResourceMetricRuleRequestLabels extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * tagKey1
   */
  key?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * >  You can use a template parameter to specify a tag value. CloudMonitor replaces the value of the template parameter with an actual tag value.
   * 
   * @example
   * ECS
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutResourceMetricRuleRequestPrometheusAnnotations extends $tea.Model {
  /**
   * @remarks
   * The key of the annotation.
   * 
   * @example
   * summary
   */
  key?: string;
  /**
   * @remarks
   * The value of the annotation.
   * 
   * @example
   * {{ $labels.instance }} CPU usage above 10% {current value: {{ humanizePercentage $value }} }
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutResourceMetricRuleRequestPrometheus extends $tea.Model {
  /**
   * @remarks
   * The annotations of the Prometheus alert rule. When a Prometheus alert is triggered, the system renders the annotated keys and values to help you understand the metrics and alert rule.
   * 
   * >  This parameter is equivalent to the annotations parameter of open source Prometheus.
   */
  annotations?: PutResourceMetricRuleRequestPrometheusAnnotations[];
  /**
   * @remarks
   * The alert level. Valid values:
   * 
   * *   Critical
   * *   Warn
   * *   Info
   * 
   * @example
   * Critical
   */
  level?: string;
  /**
   * @remarks
   * PromQL statements are supported.
   * 
   * >  The data obtained by using the PromQL query statement is the monitoring data. You must include the alert threshold in this statement.
   * 
   * @example
   * cpuUsage{instanceId="xxxx"}[1m]>90
   */
  promQL?: string;
  /**
   * @remarks
   * The number of consecutive triggers. If the number of times that the metric values meet the trigger conditions reaches the value of this parameter, CloudMonitor sends alert notifications.
   * 
   * @example
   * 3
   */
  times?: number;
  static names(): { [key: string]: string } {
    return {
      annotations: 'Annotations',
      level: 'Level',
      promQL: 'PromQL',
      times: 'Times',
    };
  }

  static types(): { [key: string]: any } {
    return {
      annotations: { 'type': 'array', 'itemType': PutResourceMetricRuleRequestPrometheusAnnotations },
      level: 'string',
      promQL: 'string',
      times: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutResourceMetricRuleShrinkRequestEscalationsCritical extends $tea.Model {
  /**
   * @remarks
   * The operator that is used to compare the metric value with the threshold for Critical-level alerts. Valid value:
   * 
   * *   GreaterThanOrEqualToThreshold: greater than or equal to the threshold
   * *   GreaterThanThreshold: greater than the threshold
   * *   LessThanOrEqualToThreshold: less than or equal to the threshold
   * *   LessThanThreshold: less than the threshold
   * *   NotEqualToThreshold: not equal to the threshold
   * *   GreaterThanYesterday: greater than the metric value at the same time yesterday
   * *   LessThanYesterday: less than the metric value at the same time yesterday
   * *   GreaterThanLastWeek: greater than the metric value at the same time last week
   * *   LessThanLastWeek: less than the metric value at the same time last week
   * *   GreaterThanLastPeriod: greater than the metric value in the last monitoring cycle
   * *   LessThanLastPeriod: less than the metric value in the last monitoring cycle
   * 
   * >  You must select at least one of the Critical, Warn, and Info alert levels and specify the Statistics, ComparisonOperator, Threshold, and Times parameters for each alert level.
   * 
   * @example
   * GreaterThanOrEqualToThreshold
   */
  comparisonOperator?: string;
  /**
   * @remarks
   * The statistical methods for Critical-level alerts.
   * 
   * The value of this parameter is determined by the `Statistics` column corresponding to the `MetricName` parameter of the specified cloud service. The value of this parameter can be Maximum, Minimum, or Average. For more information about how to obtain the value of this parameter, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * >  You must select at least one of the Critical, Warn, and Info alert levels and specify the Statistics, ComparisonOperator, Threshold, and Times parameters for each alert level.
   * 
   * @example
   * Average
   */
  statistics?: string;
  /**
   * @remarks
   * The threshold for Critical-level alerts.
   * 
   * >  You must select at least one of the Critical, Warn, and Info alert levels and specify the Statistics, ComparisonOperator, Threshold, and Times parameters for each alert level.
   * 
   * @example
   * 90
   */
  threshold?: string;
  /**
   * @remarks
   * The consecutive number of times for which the metric value meets the alert condition before a Critical-level alert is triggered.
   * 
   * >  You must select at least one of the Critical, Warn, and Info alert levels and specify the Statistics, ComparisonOperator, Threshold, and Times parameters for each alert level.
   * 
   * @example
   * 3
   */
  times?: number;
  static names(): { [key: string]: string } {
    return {
      comparisonOperator: 'ComparisonOperator',
      statistics: 'Statistics',
      threshold: 'Threshold',
      times: 'Times',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comparisonOperator: 'string',
      statistics: 'string',
      threshold: 'string',
      times: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutResourceMetricRuleShrinkRequestEscalationsInfo extends $tea.Model {
  /**
   * @remarks
   * The operator that is used to compare the metric value with the threshold for Info-level alerts. Valid value:
   * 
   * *   GreaterThanOrEqualToThreshold: greater than or equal to the threshold
   * *   GreaterThanThreshold: greater than the threshold
   * *   LessThanOrEqualToThreshold: less than or equal to the threshold
   * *   LessThanThreshold: less than the threshold
   * *   NotEqualToThreshold: not equal to the threshold
   * *   GreaterThanYesterday: greater than the metric value at the same time yesterday
   * *   LessThanYesterday: less than the metric value at the same time yesterday
   * *   GreaterThanLastWeek: greater than the metric value at the same time last week
   * *   LessThanLastWeek: less than the metric value at the same time last week
   * *   GreaterThanLastPeriod: greater than the metric value in the last monitoring cycle
   * *   LessThanLastPeriod: less than the metric value in the last monitoring cycle
   * 
   * >  You must select at least one of the Critical, Warn, and Info alert levels and specify the Statistics, ComparisonOperator, Threshold, and Times parameters for each alert level.
   * 
   * @example
   * GreaterThanOrEqualToThreshold
   */
  comparisonOperator?: string;
  /**
   * @remarks
   * The statistical methods for Info-level alerts.
   * 
   * The value of this parameter is determined by the `Statistics` column corresponding to the `MetricName` parameter of the specified cloud service. The value of this parameter can be Maximum, Minimum, or Average. For more information about how to obtain the value of this parameter, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * >  You must select at least one of the Critical, Warn, and Info alert levels and specify the Statistics, ComparisonOperator, Threshold, and Times parameters for each alert level.
   * 
   * @example
   * Average
   */
  statistics?: string;
  /**
   * @remarks
   * The threshold for Info-level alerts.
   * 
   * >  You must select at least one of the Critical, Warn, and Info alert levels and specify the Statistics, ComparisonOperator, Threshold, and Times parameters for each alert level.
   * 
   * @example
   * 90
   */
  threshold?: string;
  /**
   * @remarks
   * The consecutive number of times for which the metric value meets the alert condition before an Info-level alert is triggered.
   * 
   * >  You must select at least one of the Critical, Warn, and Info alert levels and specify the Statistics, ComparisonOperator, Threshold, and Times parameters for each alert level.
   * 
   * @example
   * 3
   */
  times?: number;
  static names(): { [key: string]: string } {
    return {
      comparisonOperator: 'ComparisonOperator',
      statistics: 'Statistics',
      threshold: 'Threshold',
      times: 'Times',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comparisonOperator: 'string',
      statistics: 'string',
      threshold: 'string',
      times: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutResourceMetricRuleShrinkRequestEscalationsWarn extends $tea.Model {
  /**
   * @remarks
   * The operator that is used to compare the metric value with the threshold for Warn-level alerts. Valid value:
   * 
   * *   GreaterThanOrEqualToThreshold: greater than or equal to the threshold
   * *   GreaterThanThreshold: greater than the threshold
   * *   LessThanOrEqualToThreshold: less than or equal to the threshold
   * *   LessThanThreshold: less than the threshold
   * *   NotEqualToThreshold: not equal to the threshold
   * *   GreaterThanYesterday: greater than the metric value at the same time yesterday
   * *   LessThanYesterday: less than the metric value at the same time yesterday
   * *   GreaterThanLastWeek: greater than the metric value at the same time last week
   * *   LessThanLastWeek: less than the metric value at the same time last week
   * *   GreaterThanLastPeriod: greater than the metric value in the last monitoring cycle
   * *   LessThanLastPeriod: less than the metric value in the last monitoring cycle
   * 
   * >  You must select at least one of the Critical, Warn, and Info alert levels and specify the Statistics, ComparisonOperator, Threshold, and Times parameters for each alert level.
   * 
   * @example
   * GreaterThanOrEqualToThreshold
   */
  comparisonOperator?: string;
  /**
   * @remarks
   * The statistical methods for Warn-level alerts.
   * 
   * The value of this parameter is determined by the `Statistics` column corresponding to the `MetricName` parameter of the specified cloud service. The value of this parameter can be Maximum, Minimum, or Average. For more information about how to obtain the value of this parameter, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * >  You must select at least one of the Critical, Warn, and Info alert levels and specify the Statistics, ComparisonOperator, Threshold, and Times parameters for each alert level.
   * 
   * @example
   * Average
   */
  statistics?: string;
  /**
   * @remarks
   * The threshold for Warn-level alerts.
   * 
   * >  You must select at least one of the Critical, Warn, and Info alert levels and specify the Statistics, ComparisonOperator, Threshold, and Times parameters for each alert level.
   * 
   * @example
   * 90
   */
  threshold?: string;
  /**
   * @remarks
   * The consecutive number of times for which the metric value meets the alert condition before a Warn-level alert is triggered.
   * 
   * >  You must select at least one of the Critical, Warn, and Info alert levels and specify the Statistics, ComparisonOperator, Threshold, and Times parameters for each alert level.
   * 
   * @example
   * 3
   */
  times?: number;
  static names(): { [key: string]: string } {
    return {
      comparisonOperator: 'ComparisonOperator',
      statistics: 'Statistics',
      threshold: 'Threshold',
      times: 'Times',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comparisonOperator: 'string',
      statistics: 'string',
      threshold: 'string',
      times: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutResourceMetricRuleShrinkRequestEscalations extends $tea.Model {
  critical?: PutResourceMetricRuleShrinkRequestEscalationsCritical;
  info?: PutResourceMetricRuleShrinkRequestEscalationsInfo;
  warn?: PutResourceMetricRuleShrinkRequestEscalationsWarn;
  static names(): { [key: string]: string } {
    return {
      critical: 'Critical',
      info: 'Info',
      warn: 'Warn',
    };
  }

  static types(): { [key: string]: any } {
    return {
      critical: PutResourceMetricRuleShrinkRequestEscalationsCritical,
      info: PutResourceMetricRuleShrinkRequestEscalationsInfo,
      warn: PutResourceMetricRuleShrinkRequestEscalationsWarn,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutResourceMetricRuleShrinkRequestLabels extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * tagKey1
   */
  key?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * >  You can use a template parameter to specify a tag value. CloudMonitor replaces the value of the template parameter with an actual tag value.
   * 
   * @example
   * ECS
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutResourceMetricRulesRequestRulesEscalationsCritical extends $tea.Model {
  comparisonOperator?: string;
  n?: number;
  preCondition?: string;
  statistics?: string;
  threshold?: string;
  times?: number;
  static names(): { [key: string]: string } {
    return {
      comparisonOperator: 'ComparisonOperator',
      n: 'N',
      preCondition: 'PreCondition',
      statistics: 'Statistics',
      threshold: 'Threshold',
      times: 'Times',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comparisonOperator: 'string',
      n: 'number',
      preCondition: 'string',
      statistics: 'string',
      threshold: 'string',
      times: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutResourceMetricRulesRequestRulesEscalationsInfo extends $tea.Model {
  comparisonOperator?: string;
  n?: number;
  preCondition?: string;
  statistics?: string;
  threshold?: string;
  times?: number;
  static names(): { [key: string]: string } {
    return {
      comparisonOperator: 'ComparisonOperator',
      n: 'N',
      preCondition: 'PreCondition',
      statistics: 'Statistics',
      threshold: 'Threshold',
      times: 'Times',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comparisonOperator: 'string',
      n: 'number',
      preCondition: 'string',
      statistics: 'string',
      threshold: 'string',
      times: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutResourceMetricRulesRequestRulesEscalationsWarn extends $tea.Model {
  comparisonOperator?: string;
  n?: number;
  preCondition?: string;
  statistics?: string;
  threshold?: string;
  times?: number;
  static names(): { [key: string]: string } {
    return {
      comparisonOperator: 'ComparisonOperator',
      n: 'N',
      preCondition: 'PreCondition',
      statistics: 'Statistics',
      threshold: 'Threshold',
      times: 'Times',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comparisonOperator: 'string',
      n: 'number',
      preCondition: 'string',
      statistics: 'string',
      threshold: 'string',
      times: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutResourceMetricRulesRequestRulesEscalations extends $tea.Model {
  critical?: PutResourceMetricRulesRequestRulesEscalationsCritical;
  info?: PutResourceMetricRulesRequestRulesEscalationsInfo;
  warn?: PutResourceMetricRulesRequestRulesEscalationsWarn;
  static names(): { [key: string]: string } {
    return {
      critical: 'Critical',
      info: 'Info',
      warn: 'Warn',
    };
  }

  static types(): { [key: string]: any } {
    return {
      critical: PutResourceMetricRulesRequestRulesEscalationsCritical,
      info: PutResourceMetricRulesRequestRulesEscalationsInfo,
      warn: PutResourceMetricRulesRequestRulesEscalationsWarn,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutResourceMetricRulesRequestRulesLabels extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * tagKey1
   */
  key?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * >  You can use a template parameter to specify a tag value. CloudMonitor replaces the value of the template parameter with an actual tag value.
   * 
   * @example
   * ECS
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutResourceMetricRulesRequestRules extends $tea.Model {
  escalations?: PutResourceMetricRulesRequestRulesEscalations;
  /**
   * @remarks
   * The alert contact groups. The alert notifications are sent to the alert contacts in the alert contact group.
   * 
   * Valid values of N: 1 to 500.
   * 
   * >  An alert contact group can contain one or more alert contacts. For information about how to create alert contacts and alert contact groups, see [PutContact](https://help.aliyun.com/document_detail/114923.html) and [PutContactGroup](https://help.aliyun.com/document_detail/114929.html).
   * 
   * This parameter is required.
   * 
   * @example
   * ECS_Group
   */
  contactGroups?: string;
  /**
   * @remarks
   * The time period during which the alert rule is effective.
   * 
   * Valid values of N: 1 to 500.
   * 
   * @example
   * 00:00-23:59
   */
  effectiveInterval?: string;
  /**
   * @remarks
   * The subject of the alert notification email.
   * 
   * Valid values of N: 1 to 500.
   */
  emailSubject?: string;
  /**
   * @remarks
   * The interval at which alerts are triggered based on the alert rule.
   * 
   * Unit: seconds.
   * 
   * Valid values of N: 1 to 500.
   * 
   * >  For information about how to query the statistical period of a metric, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * @example
   * 60
   */
  interval?: string;
  /**
   * @remarks
   * If the metric meets the specified condition in the alert rule and CloudMonitor sends an alert notification, the tag is also written to the metric and displayed in the alert notification.
   */
  labels?: PutResourceMetricRulesRequestRulesLabels[];
  /**
   * @remarks
   * The metric name.
   * 
   * Valid values of N: 1 to 500.
   * 
   * For information about how to query the name of a metric, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * @example
   * cpu_total
   */
  metricName?: string;
  /**
   * @remarks
   * The namespace of the cloud service.
   * 
   * Valid values of N: 1 to 500.
   * 
   * For information about how to query the namespace of a cloud service, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * This parameter is required.
   * 
   * @example
   * acs_ecs_dashboard
   */
  namespace?: string;
  /**
   * @remarks
   * The method that is used to handle alerts when no monitoring data is found. Valid values:
   * 
   * *   KEEP_LAST_STATE (default): No operation is performed.
   * *   INSUFFICIENT_DATA: An alert whose content is "Insufficient data" is triggered.
   * *   OK: The status is considered normal.
   * 
   * Valid values of N: 1 to 500.
   * 
   * @example
   * KEEP_LAST_STATE
   */
  noDataPolicy?: string;
  /**
   * @remarks
   * The time period during which the alert rule is ineffective.
   * 
   * Valid values of N: 1 to 500.
   * 
   * @example
   * 00:00-06:00
   */
  noEffectiveInterval?: string;
  /**
   * @remarks
   * The statistical period of the metric.
   * 
   * Unit: seconds. The default value is the interval at which the monitoring data of the metric is collected.
   * 
   * Valid values of N: 1 to 500.
   * 
   * >  For information about how to query the statistical period of a metric, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * @example
   * 60
   */
  period?: string;
  /**
   * @remarks
   * The information about the resource. Example: `[{"instanceId":"i-uf6j91r34rnwawoo****"}]` or `[{"userId":"100931896542****"}]`.
   * 
   * Valid values of N: 1 to 500.
   * 
   * For more information about the supported dimensions that are used to query resources, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * This parameter is required.
   * 
   * @example
   * [{"instanceId":"i-uf6j91r34rnwawoo****"}]
   */
  resources?: string;
  /**
   * @remarks
   * The ID of the alert rule.
   * 
   * Valid values of N: 1 to 500.
   * 
   * You can specify a new ID or the ID of an existing alert rule. For information about how to query the ID of an alert rule, see [DescribeMetricRuleList](https://help.aliyun.com/document_detail/114941.html).
   * 
   * >  If you specify a new ID, a threshold-triggered alert rule is created.
   * 
   * This parameter is required.
   * 
   * @example
   * a151cd6023eacee2f0978e03863cc1697c89508****
   */
  ruleId?: string;
  /**
   * @remarks
   * The name of the alert rule.
   * 
   * Valid values of N: 1 to 500.
   * 
   * You can specify a new name or the name of an existing alert rule. For information about how to query the name of an alert rule, see [DescribeMetricRuleList](https://help.aliyun.com/document_detail/114941.html).
   * 
   * >  If you specify a new name, a threshold-triggered alert rule is created.
   * 
   * This parameter is required.
   * 
   * @example
   * test123
   */
  ruleName?: string;
  /**
   * @remarks
   * The mute period during which new alert notifications are not sent even if the trigger conditions are met.
   * 
   * Unit: seconds. Default value: 86400.
   * 
   * Valid values of N: 1 to 500.
   * 
   * >  If an alert is not cleared after the mute period ends, CloudMonitor resends an alert notification.
   * 
   * @example
   * 86400
   */
  silenceTime?: number;
  /**
   * @remarks
   * The callback URL to which a POST request is sent when an alert is triggered based on the alert rule.
   * 
   * Valid values of N: 1 to 500.
   * 
   * @example
   * https://alert.aliyun.com.com:8080/callback
   */
  webhook?: string;
  static names(): { [key: string]: string } {
    return {
      escalations: 'Escalations',
      contactGroups: 'ContactGroups',
      effectiveInterval: 'EffectiveInterval',
      emailSubject: 'EmailSubject',
      interval: 'Interval',
      labels: 'Labels',
      metricName: 'MetricName',
      namespace: 'Namespace',
      noDataPolicy: 'NoDataPolicy',
      noEffectiveInterval: 'NoEffectiveInterval',
      period: 'Period',
      resources: 'Resources',
      ruleId: 'RuleId',
      ruleName: 'RuleName',
      silenceTime: 'SilenceTime',
      webhook: 'Webhook',
    };
  }

  static types(): { [key: string]: any } {
    return {
      escalations: PutResourceMetricRulesRequestRulesEscalations,
      contactGroups: 'string',
      effectiveInterval: 'string',
      emailSubject: 'string',
      interval: 'string',
      labels: { 'type': 'array', 'itemType': PutResourceMetricRulesRequestRulesLabels },
      metricName: 'string',
      namespace: 'string',
      noDataPolicy: 'string',
      noEffectiveInterval: 'string',
      period: 'string',
      resources: 'string',
      ruleId: 'string',
      ruleName: 'string',
      silenceTime: 'number',
      webhook: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutResourceMetricRulesResponseBodyFailedListResultTargetResult extends $tea.Model {
  /**
   * @remarks
   * The response code.
   * 
   * @example
   * 404
   */
  code?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * The request processing has failed due to some unknown error.
   */
  message?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * false
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutResourceMetricRulesResponseBodyFailedListResultTarget extends $tea.Model {
  /**
   * @remarks
   * The alert rule that failed to be created.
   */
  result?: PutResourceMetricRulesResponseBodyFailedListResultTargetResult;
  /**
   * @remarks
   * The ID of the alert rule.
   * 
   * @example
   * a151cd6023eacee2f0978e03863cc1697c89508****
   */
  ruleId?: string;
  static names(): { [key: string]: string } {
    return {
      result: 'Result',
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      result: PutResourceMetricRulesResponseBodyFailedListResultTargetResult,
      ruleId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutResourceMetricRulesResponseBodyFailedListResult extends $tea.Model {
  target?: PutResourceMetricRulesResponseBodyFailedListResultTarget[];
  static names(): { [key: string]: string } {
    return {
      target: 'Target',
    };
  }

  static types(): { [key: string]: any } {
    return {
      target: { 'type': 'array', 'itemType': PutResourceMetricRulesResponseBodyFailedListResultTarget },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveTagsRequestTag extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * > The tag key (`Tag.N.Key`) and tag value (`Tag.N.Value`) must be specified at the same time.
   * 
   * This parameter is required.
   * 
   * @example
   * Key1
   */
  key?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * > The tag key (`Tag.N.Key`) and tag value (`Tag.N.Value`) must be specified at the same time.
   * 
   * This parameter is required.
   * 
   * @example
   * Value1
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveTagsResponseBodyTag extends $tea.Model {
  tags?: string[];
  static names(): { [key: string]: string } {
    return {
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tags: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}


export default class Client extends OpenApi {

  constructor(config: $OpenApi.Config) {
    super(config);
    this._endpointRule = "";
    this.checkConfig(config);
    this._endpoint = this.getEndpoint("cms", this._regionId, this._endpointRule, this._network, this._suffix, this._endpointMap, this._endpoint);
  }


  getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: {[key: string ]: string}, endpoint: string): string {
    if (!Util.empty(endpoint)) {
      return endpoint;
    }

    if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
      return endpointMap[regionId];
    }

    return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
  }

  /**
   * Adds tags to an application group.
   * 
   * @remarks
   * This topic provides an example on how to add a tag to an application group whose ID is `7301****`. In this example, the key of the tag is `key1` and the value of the tag is `value1`.
   * 
   * @param request - AddTagsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddTagsResponse
   */
  async addTagsWithOptions(request: AddTagsRequest, runtime: $Util.RuntimeOptions): Promise<AddTagsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupIds)) {
      query["GroupIds"] = request.groupIds;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddTags",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddTagsResponse>(await this.callApi(params, req, runtime), new AddTagsResponse({}));
  }

  /**
   * Adds tags to an application group.
   * 
   * @remarks
   * This topic provides an example on how to add a tag to an application group whose ID is `7301****`. In this example, the key of the tag is `key1` and the value of the tag is `value1`.
   * 
   * @param request - AddTagsRequest
   * @returns AddTagsResponse
   */
  async addTags(request: AddTagsRequest): Promise<AddTagsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addTagsWithOptions(request, runtime);
  }

  /**
   * Applies an alert template to an application group to generate an alert rule.
   * 
   * @remarks
   * In this example, the `700****` alert template is applied to the `123456` application group. For the generated alert rule, the ID is `applyTemplate8ab74c6b-9f27-47ab-8841-de01dc08****`, and the name is `test123`.
   * 
   * @param request - ApplyMetricRuleTemplateRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ApplyMetricRuleTemplateResponse
   */
  async applyMetricRuleTemplateWithOptions(request: ApplyMetricRuleTemplateRequest, runtime: $Util.RuntimeOptions): Promise<ApplyMetricRuleTemplateResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appendMode)) {
      query["AppendMode"] = request.appendMode;
    }

    if (!Util.isUnset(request.applyMode)) {
      query["ApplyMode"] = request.applyMode;
    }

    if (!Util.isUnset(request.enableEndTime)) {
      query["EnableEndTime"] = request.enableEndTime;
    }

    if (!Util.isUnset(request.enableStartTime)) {
      query["EnableStartTime"] = request.enableStartTime;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.notifyLevel)) {
      query["NotifyLevel"] = request.notifyLevel;
    }

    if (!Util.isUnset(request.silenceTime)) {
      query["SilenceTime"] = request.silenceTime;
    }

    if (!Util.isUnset(request.templateIds)) {
      query["TemplateIds"] = request.templateIds;
    }

    if (!Util.isUnset(request.webhook)) {
      query["Webhook"] = request.webhook;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ApplyMetricRuleTemplate",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ApplyMetricRuleTemplateResponse>(await this.callApi(params, req, runtime), new ApplyMetricRuleTemplateResponse({}));
  }

  /**
   * Applies an alert template to an application group to generate an alert rule.
   * 
   * @remarks
   * In this example, the `700****` alert template is applied to the `123456` application group. For the generated alert rule, the ID is `applyTemplate8ab74c6b-9f27-47ab-8841-de01dc08****`, and the name is `test123`.
   * 
   * @param request - ApplyMetricRuleTemplateRequest
   * @returns ApplyMetricRuleTemplateResponse
   */
  async applyMetricRuleTemplate(request: ApplyMetricRuleTemplateRequest): Promise<ApplyMetricRuleTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.applyMetricRuleTemplateWithOptions(request, runtime);
  }

  /**
   * Creates site monitoring tasks.
   * 
   * @remarks
   * This topic provides an example on how to create a site monitoring task named `HangZhou_ECS1`. The URL that is monitored by the task is `https://www.aliyun.com` and the type of the task is `HTTP`. The returned result shows that the site monitoring task is created. The name of the site monitoring task is `HangZhou_ECS1` and the task ID is `679fbe4f-b80b-4706-91b2-5427b43e****`.
   * 
   * @param request - BatchCreateInstantSiteMonitorRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns BatchCreateInstantSiteMonitorResponse
   */
  async batchCreateInstantSiteMonitorWithOptions(request: BatchCreateInstantSiteMonitorRequest, runtime: $Util.RuntimeOptions): Promise<BatchCreateInstantSiteMonitorResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.taskList)) {
      query["TaskList"] = request.taskList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchCreateInstantSiteMonitor",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchCreateInstantSiteMonitorResponse>(await this.callApi(params, req, runtime), new BatchCreateInstantSiteMonitorResponse({}));
  }

  /**
   * Creates site monitoring tasks.
   * 
   * @remarks
   * This topic provides an example on how to create a site monitoring task named `HangZhou_ECS1`. The URL that is monitored by the task is `https://www.aliyun.com` and the type of the task is `HTTP`. The returned result shows that the site monitoring task is created. The name of the site monitoring task is `HangZhou_ECS1` and the task ID is `679fbe4f-b80b-4706-91b2-5427b43e****`.
   * 
   * @param request - BatchCreateInstantSiteMonitorRequest
   * @returns BatchCreateInstantSiteMonitorResponse
   */
  async batchCreateInstantSiteMonitor(request: BatchCreateInstantSiteMonitorRequest): Promise<BatchCreateInstantSiteMonitorResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchCreateInstantSiteMonitorWithOptions(request, runtime);
  }

  /**
   * Exports the monitoring data that is defined in the Cursor operation.
   * 
   * @remarks
   * ### [](#)Prerequisites
   * The `Cursor` information is returned by calling the [Cursor](https://help.aliyun.com/document_detail/2330730.html) operation.
   * ### [](#)Description
   * This topic provides an example on how to export the monitoring data of the `cpu_idle` metric for Elastic Compute Service (ECS). The namespace of ECS is `acs_ecs_dashboard`. The `Cursor` information is specified. A maximum of 1,000 data entries can be returned in each response.
   * 
   * @param tmpReq - BatchExportRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns BatchExportResponse
   */
  async batchExportWithOptions(tmpReq: BatchExportRequest, runtime: $Util.RuntimeOptions): Promise<BatchExportResponse> {
    Util.validateModel(tmpReq);
    let request = new BatchExportShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.measurements)) {
      request.measurementsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.measurements, "Measurements", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.cursor)) {
      body["Cursor"] = request.cursor;
    }

    if (!Util.isUnset(request.length)) {
      body["Length"] = request.length;
    }

    if (!Util.isUnset(request.measurementsShrink)) {
      body["Measurements"] = request.measurementsShrink;
    }

    if (!Util.isUnset(request.metric)) {
      body["Metric"] = request.metric;
    }

    if (!Util.isUnset(request.namespace)) {
      body["Namespace"] = request.namespace;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "BatchExport",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchExportResponse>(await this.callApi(params, req, runtime), new BatchExportResponse({}));
  }

  /**
   * Exports the monitoring data that is defined in the Cursor operation.
   * 
   * @remarks
   * ### [](#)Prerequisites
   * The `Cursor` information is returned by calling the [Cursor](https://help.aliyun.com/document_detail/2330730.html) operation.
   * ### [](#)Description
   * This topic provides an example on how to export the monitoring data of the `cpu_idle` metric for Elastic Compute Service (ECS). The namespace of ECS is `acs_ecs_dashboard`. The `Cursor` information is specified. A maximum of 1,000 data entries can be returned in each response.
   * 
   * @param request - BatchExportRequest
   * @returns BatchExportResponse
   */
  async batchExport(request: BatchExportRequest): Promise<BatchExportResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchExportWithOptions(request, runtime);
  }

  /**
   * Creates an application group based on the tags of cloud resources.
   * 
   * @remarks
   * This operation is available for Elastic Compute Service (ECS), ApsaraDB RDS, and Server Load Balancer (SLB).
   * This topic provides an example to show how to create an application group for resources whose tag key is `ecs_instance`. In this example, the alert contact group of the application group is `ECS_Group`.
   * 
   * @param request - CreateDynamicTagGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateDynamicTagGroupResponse
   */
  async createDynamicTagGroupWithOptions(request: CreateDynamicTagGroupRequest, runtime: $Util.RuntimeOptions): Promise<CreateDynamicTagGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.contactGroupList)) {
      query["ContactGroupList"] = request.contactGroupList;
    }

    if (!Util.isUnset(request.enableInstallAgent)) {
      query["EnableInstallAgent"] = request.enableInstallAgent;
    }

    if (!Util.isUnset(request.enableSubscribeEvent)) {
      query["EnableSubscribeEvent"] = request.enableSubscribeEvent;
    }

    if (!Util.isUnset(request.matchExpress)) {
      query["MatchExpress"] = request.matchExpress;
    }

    if (!Util.isUnset(request.matchExpressFilterRelation)) {
      query["MatchExpressFilterRelation"] = request.matchExpressFilterRelation;
    }

    if (!Util.isUnset(request.tagKey)) {
      query["TagKey"] = request.tagKey;
    }

    if (!Util.isUnset(request.tagRegionId)) {
      query["TagRegionId"] = request.tagRegionId;
    }

    if (!Util.isUnset(request.templateIdList)) {
      query["TemplateIdList"] = request.templateIdList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateDynamicTagGroup",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateDynamicTagGroupResponse>(await this.callApi(params, req, runtime), new CreateDynamicTagGroupResponse({}));
  }

  /**
   * Creates an application group based on the tags of cloud resources.
   * 
   * @remarks
   * This operation is available for Elastic Compute Service (ECS), ApsaraDB RDS, and Server Load Balancer (SLB).
   * This topic provides an example to show how to create an application group for resources whose tag key is `ecs_instance`. In this example, the alert contact group of the application group is `ECS_Group`.
   * 
   * @param request - CreateDynamicTagGroupRequest
   * @returns CreateDynamicTagGroupResponse
   */
  async createDynamicTagGroup(request: CreateDynamicTagGroupRequest): Promise<CreateDynamicTagGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDynamicTagGroupWithOptions(request, runtime);
  }

  /**
   * Creates one or more alert rules for a specified application group.
   * 
   * @remarks
   * This topic provides an example to show how to create an alert rule for the `cpu_total` metric of Elastic Compute Service (ECS) in the `123456` application group. The ID of the alert rule is `456789`. The name of the alert rule is `ECS_Rule1`. The alert level is `Critical`. The statistical method is `Average`. The comparison operator is `GreaterThanOrEqualToThreshold`. The alert threshold is `90`. The number of alert retries is `3`. The response shows that the alert rule named `ECS_Rule1` is created.
   * 
   * @param request - CreateGroupMetricRulesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateGroupMetricRulesResponse
   */
  async createGroupMetricRulesWithOptions(request: CreateGroupMetricRulesRequest, runtime: $Util.RuntimeOptions): Promise<CreateGroupMetricRulesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.groupMetricRules)) {
      query["GroupMetricRules"] = request.groupMetricRules;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateGroupMetricRules",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateGroupMetricRulesResponse>(await this.callApi(params, req, runtime), new CreateGroupMetricRulesResponse({}));
  }

  /**
   * Creates one or more alert rules for a specified application group.
   * 
   * @remarks
   * This topic provides an example to show how to create an alert rule for the `cpu_total` metric of Elastic Compute Service (ECS) in the `123456` application group. The ID of the alert rule is `456789`. The name of the alert rule is `ECS_Rule1`. The alert level is `Critical`. The statistical method is `Average`. The comparison operator is `GreaterThanOrEqualToThreshold`. The alert threshold is `90`. The number of alert retries is `3`. The response shows that the alert rule named `ECS_Rule1` is created.
   * 
   * @param request - CreateGroupMetricRulesRequest
   * @returns CreateGroupMetricRulesResponse
   */
  async createGroupMetricRules(request: CreateGroupMetricRulesRequest): Promise<CreateGroupMetricRulesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createGroupMetricRulesWithOptions(request, runtime);
  }

  /**
   * Creates a process monitoring task for an application group.
   * 
   * @param request - CreateGroupMonitoringAgentProcessRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateGroupMonitoringAgentProcessResponse
   */
  async createGroupMonitoringAgentProcessWithOptions(request: CreateGroupMonitoringAgentProcessRequest, runtime: $Util.RuntimeOptions): Promise<CreateGroupMonitoringAgentProcessResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.alertConfig)) {
      query["AlertConfig"] = request.alertConfig;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.matchExpress)) {
      query["MatchExpress"] = request.matchExpress;
    }

    if (!Util.isUnset(request.matchExpressFilterRelation)) {
      query["MatchExpressFilterRelation"] = request.matchExpressFilterRelation;
    }

    if (!Util.isUnset(request.processName)) {
      query["ProcessName"] = request.processName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateGroupMonitoringAgentProcess",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateGroupMonitoringAgentProcessResponse>(await this.callApi(params, req, runtime), new CreateGroupMonitoringAgentProcessResponse({}));
  }

  /**
   * Creates a process monitoring task for an application group.
   * 
   * @param request - CreateGroupMonitoringAgentProcessRequest
   * @returns CreateGroupMonitoringAgentProcessResponse
   */
  async createGroupMonitoringAgentProcess(request: CreateGroupMonitoringAgentProcessRequest): Promise<CreateGroupMonitoringAgentProcessResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createGroupMonitoringAgentProcessWithOptions(request, runtime);
  }

  /**
   * Creates an availability monitoring task.
   * 
   * @remarks
   * This topic provides an example on how to create an availability monitoring task named `task1` in an application group named `123456`. The TaskType parameter of the task is set to `HTTP`. After you start the task, the system sends alerts by using the specified email address and DingTalk chatbot.
   * 
   * @param request - CreateHostAvailabilityRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateHostAvailabilityResponse
   */
  async createHostAvailabilityWithOptions(request: CreateHostAvailabilityRequest, runtime: $Util.RuntimeOptions): Promise<CreateHostAvailabilityResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.alertConfigEscalationList)) {
      query["AlertConfigEscalationList"] = request.alertConfigEscalationList;
    }

    if (!Util.isUnset(request.alertConfigTargetList)) {
      query["AlertConfigTargetList"] = request.alertConfigTargetList;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.instanceList)) {
      query["InstanceList"] = request.instanceList;
    }

    if (!Util.isUnset(request.taskName)) {
      query["TaskName"] = request.taskName;
    }

    if (!Util.isUnset(request.taskScope)) {
      query["TaskScope"] = request.taskScope;
    }

    if (!Util.isUnset(request.taskType)) {
      query["TaskType"] = request.taskType;
    }

    if (!Util.isUnset(request.alertConfig)) {
      query["AlertConfig"] = request.alertConfig;
    }

    if (!Util.isUnset(request.taskOption)) {
      query["TaskOption"] = request.taskOption;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateHostAvailability",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateHostAvailabilityResponse>(await this.callApi(params, req, runtime), new CreateHostAvailabilityResponse({}));
  }

  /**
   * Creates an availability monitoring task.
   * 
   * @remarks
   * This topic provides an example on how to create an availability monitoring task named `task1` in an application group named `123456`. The TaskType parameter of the task is set to `HTTP`. After you start the task, the system sends alerts by using the specified email address and DingTalk chatbot.
   * 
   * @param request - CreateHostAvailabilityRequest
   * @returns CreateHostAvailabilityResponse
   */
  async createHostAvailability(request: CreateHostAvailabilityRequest): Promise<CreateHostAvailabilityResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createHostAvailabilityWithOptions(request, runtime);
  }

  /**
   * Creates a namespace.
   * 
   * @remarks
   * # [](#)Prerequisites
   * Hybrid Cloud Monitoring is activated. For more information, see [Activate Hybrid Cloud Monitoring](https://help.aliyun.com/document_detail/250773.html).
   * # [](#)Description
   * This topic provides an example on how to create a namespace named `aliyun`. In this example, the data retention period of the namespace is set to `cms.s1.3xlarge`. The returned result indicates that the namespace is created.
   * 
   * @param request - CreateHybridMonitorNamespaceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateHybridMonitorNamespaceResponse
   */
  async createHybridMonitorNamespaceWithOptions(request: CreateHybridMonitorNamespaceRequest, runtime: $Util.RuntimeOptions): Promise<CreateHybridMonitorNamespaceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.namespaceRegion)) {
      query["NamespaceRegion"] = request.namespaceRegion;
    }

    if (!Util.isUnset(request.namespaceType)) {
      query["NamespaceType"] = request.namespaceType;
    }

    if (!Util.isUnset(request.spec)) {
      query["Spec"] = request.spec;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateHybridMonitorNamespace",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateHybridMonitorNamespaceResponse>(await this.callApi(params, req, runtime), new CreateHybridMonitorNamespaceResponse({}));
  }

  /**
   * Creates a namespace.
   * 
   * @remarks
   * # [](#)Prerequisites
   * Hybrid Cloud Monitoring is activated. For more information, see [Activate Hybrid Cloud Monitoring](https://help.aliyun.com/document_detail/250773.html).
   * # [](#)Description
   * This topic provides an example on how to create a namespace named `aliyun`. In this example, the data retention period of the namespace is set to `cms.s1.3xlarge`. The returned result indicates that the namespace is created.
   * 
   * @param request - CreateHybridMonitorNamespaceRequest
   * @returns CreateHybridMonitorNamespaceResponse
   */
  async createHybridMonitorNamespace(request: CreateHybridMonitorNamespaceRequest): Promise<CreateHybridMonitorNamespaceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createHybridMonitorNamespaceWithOptions(request, runtime);
  }

  /**
   * Creates a Logstore group for the metrics of Simple Log Service logs.
   * 
   * @remarks
   * # Prerequisites
   * Simple Log Service is activated. A project and a Logstore are created in Simple Log Service. For more information, see [Getting Started](https://help.aliyun.com/document_detail/54604.html).
   * # Description
   * In this example, a Logstore group named `Logstore_test` is created. The region ID is `cn-hangzhou`. The project is `aliyun-project`. The Logstore is `Logstore-ECS`. The response shows that the Logstore group is created.
   * 
   * @param request - CreateHybridMonitorSLSGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateHybridMonitorSLSGroupResponse
   */
  async createHybridMonitorSLSGroupWithOptions(request: CreateHybridMonitorSLSGroupRequest, runtime: $Util.RuntimeOptions): Promise<CreateHybridMonitorSLSGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.SLSGroupConfig)) {
      query["SLSGroupConfig"] = request.SLSGroupConfig;
    }

    if (!Util.isUnset(request.SLSGroupDescription)) {
      query["SLSGroupDescription"] = request.SLSGroupDescription;
    }

    if (!Util.isUnset(request.SLSGroupName)) {
      query["SLSGroupName"] = request.SLSGroupName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateHybridMonitorSLSGroup",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateHybridMonitorSLSGroupResponse>(await this.callApi(params, req, runtime), new CreateHybridMonitorSLSGroupResponse({}));
  }

  /**
   * Creates a Logstore group for the metrics of Simple Log Service logs.
   * 
   * @remarks
   * # Prerequisites
   * Simple Log Service is activated. A project and a Logstore are created in Simple Log Service. For more information, see [Getting Started](https://help.aliyun.com/document_detail/54604.html).
   * # Description
   * In this example, a Logstore group named `Logstore_test` is created. The region ID is `cn-hangzhou`. The project is `aliyun-project`. The Logstore is `Logstore-ECS`. The response shows that the Logstore group is created.
   * 
   * @param request - CreateHybridMonitorSLSGroupRequest
   * @returns CreateHybridMonitorSLSGroupResponse
   */
  async createHybridMonitorSLSGroup(request: CreateHybridMonitorSLSGroupRequest): Promise<CreateHybridMonitorSLSGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createHybridMonitorSLSGroupWithOptions(request, runtime);
  }

  /**
   * Creates a metric import task for an Alibaba Cloud service or creates a metric for logs imported from Simple Log Service.
   * 
   * @remarks
   * # [](#)Prerequisites
   * *   Hybrid Cloud Monitoring is activated. For more information, see [Activate Hybrid Cloud Monitoring](https://help.aliyun.com/document_detail/250773.html).
   * *   If you want to create a metric for logs imported from Simple Log Service, make sure that you have activated Simple Log Service and created a project and a Logstore. For more information, see [Getting Started](https://help.aliyun.com/document_detail/54604.html).
   * # [](#)Description
   * This topic provides an example on how to create a metric import task named `aliyun_task` for Elastic Compute Service (ECS). The task imports the `cpu_total` metric to the `aliyun` namespace. The response shows that the metric import task is created.
   * 
   * @param request - CreateHybridMonitorTaskRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateHybridMonitorTaskResponse
   */
  async createHybridMonitorTaskWithOptions(request: CreateHybridMonitorTaskRequest, runtime: $Util.RuntimeOptions): Promise<CreateHybridMonitorTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.attachLabels)) {
      query["AttachLabels"] = request.attachLabels;
    }

    if (!Util.isUnset(request.cloudAccessId)) {
      query["CloudAccessId"] = request.cloudAccessId;
    }

    if (!Util.isUnset(request.collectInterval)) {
      query["CollectInterval"] = request.collectInterval;
    }

    if (!Util.isUnset(request.collectTargetType)) {
      query["CollectTargetType"] = request.collectTargetType;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.SLSProcessConfig)) {
      query["SLSProcessConfig"] = request.SLSProcessConfig;
    }

    if (!Util.isUnset(request.targetUserId)) {
      query["TargetUserId"] = request.targetUserId;
    }

    if (!Util.isUnset(request.targetUserIdList)) {
      query["TargetUserIdList"] = request.targetUserIdList;
    }

    if (!Util.isUnset(request.taskName)) {
      query["TaskName"] = request.taskName;
    }

    if (!Util.isUnset(request.taskType)) {
      query["TaskType"] = request.taskType;
    }

    if (!Util.isUnset(request.YARMConfig)) {
      query["YARMConfig"] = request.YARMConfig;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateHybridMonitorTask",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateHybridMonitorTaskResponse>(await this.callApi(params, req, runtime), new CreateHybridMonitorTaskResponse({}));
  }

  /**
   * Creates a metric import task for an Alibaba Cloud service or creates a metric for logs imported from Simple Log Service.
   * 
   * @remarks
   * # [](#)Prerequisites
   * *   Hybrid Cloud Monitoring is activated. For more information, see [Activate Hybrid Cloud Monitoring](https://help.aliyun.com/document_detail/250773.html).
   * *   If you want to create a metric for logs imported from Simple Log Service, make sure that you have activated Simple Log Service and created a project and a Logstore. For more information, see [Getting Started](https://help.aliyun.com/document_detail/54604.html).
   * # [](#)Description
   * This topic provides an example on how to create a metric import task named `aliyun_task` for Elastic Compute Service (ECS). The task imports the `cpu_total` metric to the `aliyun` namespace. The response shows that the metric import task is created.
   * 
   * @param request - CreateHybridMonitorTaskRequest
   * @returns CreateHybridMonitorTaskResponse
   */
  async createHybridMonitorTask(request: CreateHybridMonitorTaskRequest): Promise<CreateHybridMonitorTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createHybridMonitorTaskWithOptions(request, runtime);
  }

  /**
   * Creates an instant test task.
   * 
   * @remarks
   * You can create an instant test task only by using the Alibaba Cloud account that you used to enable Network Analysis and Monitoring. 
   * This topic provides an example to show how to create an instant test task. The name of the task is `task1`. The tested address is `http://www.aliyun.com`. The test type is `HTTP`. The number of detection points is `1`.
   * 
   * @param request - CreateInstantSiteMonitorRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateInstantSiteMonitorResponse
   */
  async createInstantSiteMonitorWithOptions(request: CreateInstantSiteMonitorRequest, runtime: $Util.RuntimeOptions): Promise<CreateInstantSiteMonitorResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.address)) {
      query["Address"] = request.address;
    }

    if (!Util.isUnset(request.ispCities)) {
      query["IspCities"] = request.ispCities;
    }

    if (!Util.isUnset(request.optionsJson)) {
      query["OptionsJson"] = request.optionsJson;
    }

    if (!Util.isUnset(request.randomIspCity)) {
      query["RandomIspCity"] = request.randomIspCity;
    }

    if (!Util.isUnset(request.taskName)) {
      query["TaskName"] = request.taskName;
    }

    if (!Util.isUnset(request.taskType)) {
      query["TaskType"] = request.taskType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateInstantSiteMonitor",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateInstantSiteMonitorResponse>(await this.callApi(params, req, runtime), new CreateInstantSiteMonitorResponse({}));
  }

  /**
   * Creates an instant test task.
   * 
   * @remarks
   * You can create an instant test task only by using the Alibaba Cloud account that you used to enable Network Analysis and Monitoring. 
   * This topic provides an example to show how to create an instant test task. The name of the task is `task1`. The tested address is `http://www.aliyun.com`. The test type is `HTTP`. The number of detection points is `1`.
   * 
   * @param request - CreateInstantSiteMonitorRequest
   * @returns CreateInstantSiteMonitorResponse
   */
  async createInstantSiteMonitor(request: CreateInstantSiteMonitorRequest): Promise<CreateInstantSiteMonitorResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createInstantSiteMonitorWithOptions(request, runtime);
  }

  /**
   * Creates a blacklist policy.
   * 
   * @remarks
   * ### Background information
   * *   CloudMonitor blocks alert notifications based on the blacklist policies that take effect. To block alert notifications when the value of a metric that belongs to a cloud service reaches the threshold that you specified, add the metric to a blacklist policy.
   * *   CloudMonitor allows you to create blacklist policies only based on threshold metrics. You cannot create blacklist policies based on system events. For more information about the cloud services and the thresholds of the metrics that are supported by CloudMonitor, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * @param request - CreateMetricRuleBlackListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateMetricRuleBlackListResponse
   */
  async createMetricRuleBlackListWithOptions(request: CreateMetricRuleBlackListRequest, runtime: $Util.RuntimeOptions): Promise<CreateMetricRuleBlackListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.category)) {
      query["Category"] = request.category;
    }

    if (!Util.isUnset(request.effectiveTime)) {
      query["EffectiveTime"] = request.effectiveTime;
    }

    if (!Util.isUnset(request.enableEndTime)) {
      query["EnableEndTime"] = request.enableEndTime;
    }

    if (!Util.isUnset(request.enableStartTime)) {
      query["EnableStartTime"] = request.enableStartTime;
    }

    if (!Util.isUnset(request.instances)) {
      query["Instances"] = request.instances;
    }

    if (!Util.isUnset(request.metrics)) {
      query["Metrics"] = request.metrics;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.scopeType)) {
      query["ScopeType"] = request.scopeType;
    }

    if (!Util.isUnset(request.scopeValue)) {
      query["ScopeValue"] = request.scopeValue;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateMetricRuleBlackList",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateMetricRuleBlackListResponse>(await this.callApi(params, req, runtime), new CreateMetricRuleBlackListResponse({}));
  }

  /**
   * Creates a blacklist policy.
   * 
   * @remarks
   * ### Background information
   * *   CloudMonitor blocks alert notifications based on the blacklist policies that take effect. To block alert notifications when the value of a metric that belongs to a cloud service reaches the threshold that you specified, add the metric to a blacklist policy.
   * *   CloudMonitor allows you to create blacklist policies only based on threshold metrics. You cannot create blacklist policies based on system events. For more information about the cloud services and the thresholds of the metrics that are supported by CloudMonitor, see [Appendix 1: Metrics](https://help.aliyun.com/document_detail/163515.html).
   * 
   * @param request - CreateMetricRuleBlackListRequest
   * @returns CreateMetricRuleBlackListResponse
   */
  async createMetricRuleBlackList(request: CreateMetricRuleBlackListRequest): Promise<CreateMetricRuleBlackListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createMetricRuleBlackListWithOptions(request, runtime);
  }

  /**
   * Associates resources with an alert rule.
   * 
   * @param request - CreateMetricRuleResourcesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateMetricRuleResourcesResponse
   */
  async createMetricRuleResourcesWithOptions(request: CreateMetricRuleResourcesRequest, runtime: $Util.RuntimeOptions): Promise<CreateMetricRuleResourcesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.overwrite)) {
      query["Overwrite"] = request.overwrite;
    }

    if (!Util.isUnset(request.resources)) {
      query["Resources"] = request.resources;
    }

    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateMetricRuleResources",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateMetricRuleResourcesResponse>(await this.callApi(params, req, runtime), new CreateMetricRuleResourcesResponse({}));
  }

  /**
   * Associates resources with an alert rule.
   * 
   * @param request - CreateMetricRuleResourcesRequest
   * @returns CreateMetricRuleResourcesResponse
   */
  async createMetricRuleResources(request: CreateMetricRuleResourcesRequest): Promise<CreateMetricRuleResourcesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createMetricRuleResourcesWithOptions(request, runtime);
  }

  /**
   * Creates an alert template.
   * 
   * @param request - CreateMetricRuleTemplateRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateMetricRuleTemplateResponse
   */
  async createMetricRuleTemplateWithOptions(request: CreateMetricRuleTemplateRequest, runtime: $Util.RuntimeOptions): Promise<CreateMetricRuleTemplateResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.alertTemplates)) {
      query["AlertTemplates"] = request.alertTemplates;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateMetricRuleTemplate",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateMetricRuleTemplateResponse>(await this.callApi(params, req, runtime), new CreateMetricRuleTemplateResponse({}));
  }

  /**
   * Creates an alert template.
   * 
   * @param request - CreateMetricRuleTemplateRequest
   * @returns CreateMetricRuleTemplateResponse
   */
  async createMetricRuleTemplate(request: CreateMetricRuleTemplateRequest): Promise<CreateMetricRuleTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createMetricRuleTemplateWithOptions(request, runtime);
  }

  /**
   * Creates a task to monitor a process.
   * 
   * @param request - CreateMonitorAgentProcessRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateMonitorAgentProcessResponse
   */
  async createMonitorAgentProcessWithOptions(request: CreateMonitorAgentProcessRequest, runtime: $Util.RuntimeOptions): Promise<CreateMonitorAgentProcessResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.processName)) {
      query["ProcessName"] = request.processName;
    }

    if (!Util.isUnset(request.processUser)) {
      query["ProcessUser"] = request.processUser;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateMonitorAgentProcess",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateMonitorAgentProcessResponse>(await this.callApi(params, req, runtime), new CreateMonitorAgentProcessResponse({}));
  }

  /**
   * Creates a task to monitor a process.
   * 
   * @param request - CreateMonitorAgentProcessRequest
   * @returns CreateMonitorAgentProcessResponse
   */
  async createMonitorAgentProcess(request: CreateMonitorAgentProcessRequest): Promise<CreateMonitorAgentProcessResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createMonitorAgentProcessWithOptions(request, runtime);
  }

  /**
   * Creates an application group.
   * 
   * @remarks
   * In this example, an application group named `ECS_Group` is created.
   * 
   * @param request - CreateMonitorGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateMonitorGroupResponse
   */
  async createMonitorGroupWithOptions(request: CreateMonitorGroupRequest, runtime: $Util.RuntimeOptions): Promise<CreateMonitorGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.contactGroups)) {
      query["ContactGroups"] = request.contactGroups;
    }

    if (!Util.isUnset(request.groupName)) {
      query["GroupName"] = request.groupName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateMonitorGroup",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateMonitorGroupResponse>(await this.callApi(params, req, runtime), new CreateMonitorGroupResponse({}));
  }

  /**
   * Creates an application group.
   * 
   * @remarks
   * In this example, an application group named `ECS_Group` is created.
   * 
   * @param request - CreateMonitorGroupRequest
   * @returns CreateMonitorGroupResponse
   */
  async createMonitorGroup(request: CreateMonitorGroupRequest): Promise<CreateMonitorGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createMonitorGroupWithOptions(request, runtime);
  }

  /**
   * Creates an application group by using a resource group.
   * 
   * @remarks
   * This topic provides an example on how to create an application group by using the resource group `CloudMonitor` and the alert contact group `ECS_Group`. The region ID of the resource group is `cn-hangzhou`.
   * 
   * @param request - CreateMonitorGroupByResourceGroupIdRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateMonitorGroupByResourceGroupIdResponse
   */
  async createMonitorGroupByResourceGroupIdWithOptions(request: CreateMonitorGroupByResourceGroupIdRequest, runtime: $Util.RuntimeOptions): Promise<CreateMonitorGroupByResourceGroupIdResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.contactGroupList)) {
      query["ContactGroupList"] = request.contactGroupList;
    }

    if (!Util.isUnset(request.enableInstallAgent)) {
      query["EnableInstallAgent"] = request.enableInstallAgent;
    }

    if (!Util.isUnset(request.enableSubscribeEvent)) {
      query["EnableSubscribeEvent"] = request.enableSubscribeEvent;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.resourceGroupName)) {
      query["ResourceGroupName"] = request.resourceGroupName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateMonitorGroupByResourceGroupId",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateMonitorGroupByResourceGroupIdResponse>(await this.callApi(params, req, runtime), new CreateMonitorGroupByResourceGroupIdResponse({}));
  }

  /**
   * Creates an application group by using a resource group.
   * 
   * @remarks
   * This topic provides an example on how to create an application group by using the resource group `CloudMonitor` and the alert contact group `ECS_Group`. The region ID of the resource group is `cn-hangzhou`.
   * 
   * @param request - CreateMonitorGroupByResourceGroupIdRequest
   * @returns CreateMonitorGroupByResourceGroupIdResponse
   */
  async createMonitorGroupByResourceGroupId(request: CreateMonitorGroupByResourceGroupIdRequest): Promise<CreateMonitorGroupByResourceGroupIdResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createMonitorGroupByResourceGroupIdWithOptions(request, runtime);
  }

  /**
   * Adds resources to an application group.
   * 
   * @remarks
   * You can add a maximum of 1,000 instances to an application group at a time. You can add a maximum of 3,000 instances of an Alibaba Cloud service to an application group. The total number of instances that you can add to an application group is unlimited.
   * In this example, an Elastic Compute Service (ECS) instance in the `China (Hangzhou)` region is added to the `3607****` application group. The instance ID is `i-2ze26xj5wwy12****` and the instance name is `test-instance-ecs`.
   * 
   * @param request - CreateMonitorGroupInstancesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateMonitorGroupInstancesResponse
   */
  async createMonitorGroupInstancesWithOptions(request: CreateMonitorGroupInstancesRequest, runtime: $Util.RuntimeOptions): Promise<CreateMonitorGroupInstancesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.instances)) {
      query["Instances"] = request.instances;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateMonitorGroupInstances",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateMonitorGroupInstancesResponse>(await this.callApi(params, req, runtime), new CreateMonitorGroupInstancesResponse({}));
  }

  /**
   * Adds resources to an application group.
   * 
   * @remarks
   * You can add a maximum of 1,000 instances to an application group at a time. You can add a maximum of 3,000 instances of an Alibaba Cloud service to an application group. The total number of instances that you can add to an application group is unlimited.
   * In this example, an Elastic Compute Service (ECS) instance in the `China (Hangzhou)` region is added to the `3607****` application group. The instance ID is `i-2ze26xj5wwy12****` and the instance name is `test-instance-ecs`.
   * 
   * @param request - CreateMonitorGroupInstancesRequest
   * @returns CreateMonitorGroupInstancesResponse
   */
  async createMonitorGroupInstances(request: CreateMonitorGroupInstancesRequest): Promise<CreateMonitorGroupInstancesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createMonitorGroupInstancesWithOptions(request, runtime);
  }

  /**
   * Creates a policy to pause alert notifications for an application group.
   * 
   * @remarks
   * If the policy is valid, no alert notifications are sent for the application group.
   * This topic describes how to create the `PauseNotify` policy to pause alert notifications for the `7301****` application group. The StartTime parameter is set to `1622949300000` and the EndTime parameter is set to `1623208500000`. This indicates that the policy is valid from `2021-06-06 11:15:00 UTC+8` to `2021-06-09 11:15:00 UTC+8`.
   * 
   * @param request - CreateMonitorGroupNotifyPolicyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateMonitorGroupNotifyPolicyResponse
   */
  async createMonitorGroupNotifyPolicyWithOptions(request: CreateMonitorGroupNotifyPolicyRequest, runtime: $Util.RuntimeOptions): Promise<CreateMonitorGroupNotifyPolicyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.policyType)) {
      query["PolicyType"] = request.policyType;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateMonitorGroupNotifyPolicy",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateMonitorGroupNotifyPolicyResponse>(await this.callApi(params, req, runtime), new CreateMonitorGroupNotifyPolicyResponse({}));
  }

  /**
   * Creates a policy to pause alert notifications for an application group.
   * 
   * @remarks
   * If the policy is valid, no alert notifications are sent for the application group.
   * This topic describes how to create the `PauseNotify` policy to pause alert notifications for the `7301****` application group. The StartTime parameter is set to `1622949300000` and the EndTime parameter is set to `1623208500000`. This indicates that the policy is valid from `2021-06-06 11:15:00 UTC+8` to `2021-06-09 11:15:00 UTC+8`.
   * 
   * @param request - CreateMonitorGroupNotifyPolicyRequest
   * @returns CreateMonitorGroupNotifyPolicyResponse
   */
  async createMonitorGroupNotifyPolicy(request: CreateMonitorGroupNotifyPolicyRequest): Promise<CreateMonitorGroupNotifyPolicyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createMonitorGroupNotifyPolicyWithOptions(request, runtime);
  }

  /**
   * Creates a task to monitor a specified process.
   * 
   * @param request - CreateMonitoringAgentProcessRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateMonitoringAgentProcessResponse
   */
  async createMonitoringAgentProcessWithOptions(request: CreateMonitoringAgentProcessRequest, runtime: $Util.RuntimeOptions): Promise<CreateMonitoringAgentProcessResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.processName)) {
      query["ProcessName"] = request.processName;
    }

    if (!Util.isUnset(request.processUser)) {
      query["ProcessUser"] = request.processUser;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateMonitoringAgentProcess",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateMonitoringAgentProcessResponse>(await this.callApi(params, req, runtime), new CreateMonitoringAgentProcessResponse({}));
  }

  /**
   * Creates a task to monitor a specified process.
   * 
   * @param request - CreateMonitoringAgentProcessRequest
   * @returns CreateMonitoringAgentProcessResponse
   */
  async createMonitoringAgentProcess(request: CreateMonitoringAgentProcessRequest): Promise<CreateMonitoringAgentProcessResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createMonitoringAgentProcessWithOptions(request, runtime);
  }

  /**
   * Creates a site monitoring task.
   * 
   * @remarks
   * This topic provides an example on how to create a site monitoring task named `HanZhou_ECS1`. The URL that is monitored by the task is `https://www.aliyun.com` and the type of the task is `HTTPS`.
   * 
   * @param request - CreateSiteMonitorRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateSiteMonitorResponse
   */
  async createSiteMonitorWithOptions(request: CreateSiteMonitorRequest, runtime: $Util.RuntimeOptions): Promise<CreateSiteMonitorResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.address)) {
      query["Address"] = request.address;
    }

    if (!Util.isUnset(request.alertIds)) {
      query["AlertIds"] = request.alertIds;
    }

    if (!Util.isUnset(request.customSchedule)) {
      query["CustomSchedule"] = request.customSchedule;
    }

    if (!Util.isUnset(request.interval)) {
      query["Interval"] = request.interval;
    }

    if (!Util.isUnset(request.ispCities)) {
      query["IspCities"] = request.ispCities;
    }

    if (!Util.isUnset(request.optionsJson)) {
      query["OptionsJson"] = request.optionsJson;
    }

    if (!Util.isUnset(request.taskName)) {
      query["TaskName"] = request.taskName;
    }

    if (!Util.isUnset(request.taskType)) {
      query["TaskType"] = request.taskType;
    }

    if (!Util.isUnset(request.vpcConfig)) {
      query["VpcConfig"] = request.vpcConfig;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateSiteMonitor",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateSiteMonitorResponse>(await this.callApi(params, req, runtime), new CreateSiteMonitorResponse({}));
  }

  /**
   * Creates a site monitoring task.
   * 
   * @remarks
   * This topic provides an example on how to create a site monitoring task named `HanZhou_ECS1`. The URL that is monitored by the task is `https://www.aliyun.com` and the type of the task is `HTTPS`.
   * 
   * @param request - CreateSiteMonitorRequest
   * @returns CreateSiteMonitorResponse
   */
  async createSiteMonitor(request: CreateSiteMonitorRequest): Promise<CreateSiteMonitorResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createSiteMonitorWithOptions(request, runtime);
  }

  /**
   * Defines the range of monitoring data that you want to export. The Cursor information is returned. When you call the BatchExport operation for the first time, you must specify the Cursor information.
   * 
   * @remarks
   * ### [](#)Prerequisites
   * Hybrid Cloud Monitoring is activated. For more information, see [Activate Hybrid Cloud Monitoring](https://help.aliyun.com/document_detail/250773.html).
   * ### [](#)Background information
   * You can call this operation to obtain the Cursor information and then call the [BatchExport](https://help.aliyun.com/document_detail/2329847.html) operation to export the monitoring data.
   * ### [](#)Description
   * This topic provides an example on how to define the monitoring data of a specified metric for a specified cloud service. In this example, the namespace of the cloud service is set to `acs_ecs_dashboard`, the metric is set to `cpu_idle`, the start time is set to `1641627000000`, and the end time is set to `1641645000000`. The number of idle CPU cores on your Elastic Compute Service (ECS) instances is measured every 60 seconds from 15:30:00, January 8, 2022 to 20:30:00, January 8, 2022. The `Cursor` information is returned.
   * 
   * @param tmpReq - CursorRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CursorResponse
   */
  async cursorWithOptions(tmpReq: CursorRequest, runtime: $Util.RuntimeOptions): Promise<CursorResponse> {
    Util.validateModel(tmpReq);
    let request = new CursorShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.matchers)) {
      request.matchersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.matchers, "Matchers", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.endTime)) {
      body["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.matchersShrink)) {
      body["Matchers"] = request.matchersShrink;
    }

    if (!Util.isUnset(request.metric)) {
      body["Metric"] = request.metric;
    }

    if (!Util.isUnset(request.namespace)) {
      body["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.period)) {
      body["Period"] = request.period;
    }

    if (!Util.isUnset(request.startTime)) {
      body["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "Cursor",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CursorResponse>(await this.callApi(params, req, runtime), new CursorResponse({}));
  }

  /**
   * Defines the range of monitoring data that you want to export. The Cursor information is returned. When you call the BatchExport operation for the first time, you must specify the Cursor information.
   * 
   * @remarks
   * ### [](#)Prerequisites
   * Hybrid Cloud Monitoring is activated. For more information, see [Activate Hybrid Cloud Monitoring](https://help.aliyun.com/document_detail/250773.html).
   * ### [](#)Background information
   * You can call this operation to obtain the Cursor information and then call the [BatchExport](https://help.aliyun.com/document_detail/2329847.html) operation to export the monitoring data.
   * ### [](#)Description
   * This topic provides an example on how to define the monitoring data of a specified metric for a specified cloud service. In this example, the namespace of the cloud service is set to `acs_ecs_dashboard`, the metric is set to `cpu_idle`, the start time is set to `1641627000000`, and the end time is set to `1641645000000`. The number of idle CPU cores on your Elastic Compute Service (ECS) instances is measured every 60 seconds from 15:30:00, January 8, 2022 to 20:30:00, January 8, 2022. The `Cursor` information is returned.
   * 
   * @param request - CursorRequest
   * @returns CursorResponse
   */
  async cursor(request: CursorRequest): Promise<CursorResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.cursorWithOptions(request, runtime);
  }

  /**
   * Deletes an alert contact.
   * 
   * @param request - DeleteContactRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteContactResponse
   */
  async deleteContactWithOptions(request: DeleteContactRequest, runtime: $Util.RuntimeOptions): Promise<DeleteContactResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.contactName)) {
      query["ContactName"] = request.contactName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteContact",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteContactResponse>(await this.callApi(params, req, runtime), new DeleteContactResponse({}));
  }

  /**
   * Deletes an alert contact.
   * 
   * @param request - DeleteContactRequest
   * @returns DeleteContactResponse
   */
  async deleteContact(request: DeleteContactRequest): Promise<DeleteContactResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteContactWithOptions(request, runtime);
  }

  /**
   * Deletes an alert group.
   * 
   * @param request - DeleteContactGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteContactGroupResponse
   */
  async deleteContactGroupWithOptions(request: DeleteContactGroupRequest, runtime: $Util.RuntimeOptions): Promise<DeleteContactGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.contactGroupName)) {
      query["ContactGroupName"] = request.contactGroupName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteContactGroup",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteContactGroupResponse>(await this.callApi(params, req, runtime), new DeleteContactGroupResponse({}));
  }

  /**
   * Deletes an alert group.
   * 
   * @param request - DeleteContactGroupRequest
   * @returns DeleteContactGroupResponse
   */
  async deleteContactGroup(request: DeleteContactGroupRequest): Promise<DeleteContactGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteContactGroupWithOptions(request, runtime);
  }

  /**
   * Deletes the reported monitoring data of a metric.
   * 
   * @param request - DeleteCustomMetricRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteCustomMetricResponse
   */
  async deleteCustomMetricWithOptions(request: DeleteCustomMetricRequest, runtime: $Util.RuntimeOptions): Promise<DeleteCustomMetricResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.md5)) {
      query["Md5"] = request.md5;
    }

    if (!Util.isUnset(request.metricName)) {
      query["MetricName"] = request.metricName;
    }

    if (!Util.isUnset(request.UUID)) {
      query["UUID"] = request.UUID;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteCustomMetric",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteCustomMetricResponse>(await this.callApi(params, req, runtime), new DeleteCustomMetricResponse({}));
  }

  /**
   * Deletes the reported monitoring data of a metric.
   * 
   * @param request - DeleteCustomMetricRequest
   * @returns DeleteCustomMetricResponse
   */
  async deleteCustomMetric(request: DeleteCustomMetricRequest): Promise<DeleteCustomMetricResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteCustomMetricWithOptions(request, runtime);
  }

  /**
   * Deletes a tag rule.
   * 
   * @param request - DeleteDynamicTagGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteDynamicTagGroupResponse
   */
  async deleteDynamicTagGroupWithOptions(request: DeleteDynamicTagGroupRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDynamicTagGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dynamicTagRuleId)) {
      query["DynamicTagRuleId"] = request.dynamicTagRuleId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteDynamicTagGroup",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteDynamicTagGroupResponse>(await this.callApi(params, req, runtime), new DeleteDynamicTagGroupResponse({}));
  }

  /**
   * Deletes a tag rule.
   * 
   * @param request - DeleteDynamicTagGroupRequest
   * @returns DeleteDynamicTagGroupResponse
   */
  async deleteDynamicTagGroup(request: DeleteDynamicTagGroupRequest): Promise<DeleteDynamicTagGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDynamicTagGroupWithOptions(request, runtime);
  }

  /**
   * Deletes the push channels of an event-triggered alert rule.
   * 
   * @param request - DeleteEventRuleTargetsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteEventRuleTargetsResponse
   */
  async deleteEventRuleTargetsWithOptions(request: DeleteEventRuleTargetsRequest, runtime: $Util.RuntimeOptions): Promise<DeleteEventRuleTargetsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ids)) {
      query["Ids"] = request.ids;
    }

    if (!Util.isUnset(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteEventRuleTargets",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteEventRuleTargetsResponse>(await this.callApi(params, req, runtime), new DeleteEventRuleTargetsResponse({}));
  }

  /**
   * Deletes the push channels of an event-triggered alert rule.
   * 
   * @param request - DeleteEventRuleTargetsRequest
   * @returns DeleteEventRuleTargetsResponse
   */
  async deleteEventRuleTargets(request: DeleteEventRuleTargetsRequest): Promise<DeleteEventRuleTargetsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteEventRuleTargetsWithOptions(request, runtime);
  }

  /**
   * Deletes one or more event-triggered alert rules.
   * 
   * @param request - DeleteEventRulesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteEventRulesResponse
   */
  async deleteEventRulesWithOptions(request: DeleteEventRulesRequest, runtime: $Util.RuntimeOptions): Promise<DeleteEventRulesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ruleNames)) {
      query["RuleNames"] = request.ruleNames;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteEventRules",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteEventRulesResponse>(await this.callApi(params, req, runtime), new DeleteEventRulesResponse({}));
  }

  /**
   * Deletes one or more event-triggered alert rules.
   * 
   * @param request - DeleteEventRulesRequest
   * @returns DeleteEventRulesResponse
   */
  async deleteEventRules(request: DeleteEventRulesRequest): Promise<DeleteEventRulesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteEventRulesWithOptions(request, runtime);
  }

  /**
   * Deletes a configuration set that is used to export monitoring data.
   * 
   * @param request - DeleteExporterOutputRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteExporterOutputResponse
   */
  async deleteExporterOutputWithOptions(request: DeleteExporterOutputRequest, runtime: $Util.RuntimeOptions): Promise<DeleteExporterOutputResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.destName)) {
      query["DestName"] = request.destName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteExporterOutput",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteExporterOutputResponse>(await this.callApi(params, req, runtime), new DeleteExporterOutputResponse({}));
  }

  /**
   * Deletes a configuration set that is used to export monitoring data.
   * 
   * @param request - DeleteExporterOutputRequest
   * @returns DeleteExporterOutputResponse
   */
  async deleteExporterOutput(request: DeleteExporterOutputRequest): Promise<DeleteExporterOutputResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteExporterOutputWithOptions(request, runtime);
  }

  /**
   * Deletes a data export rule.
   * 
   * @param request - DeleteExporterRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteExporterRuleResponse
   */
  async deleteExporterRuleWithOptions(request: DeleteExporterRuleRequest, runtime: $Util.RuntimeOptions): Promise<DeleteExporterRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteExporterRule",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteExporterRuleResponse>(await this.callApi(params, req, runtime), new DeleteExporterRuleResponse({}));
  }

  /**
   * Deletes a data export rule.
   * 
   * @param request - DeleteExporterRuleRequest
   * @returns DeleteExporterRuleResponse
   */
  async deleteExporterRule(request: DeleteExporterRuleRequest): Promise<DeleteExporterRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteExporterRuleWithOptions(request, runtime);
  }

  /**
   * Deletes a process monitoring task for an application group.
   * 
   * @param request - DeleteGroupMonitoringAgentProcessRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteGroupMonitoringAgentProcessResponse
   */
  async deleteGroupMonitoringAgentProcessWithOptions(request: DeleteGroupMonitoringAgentProcessRequest, runtime: $Util.RuntimeOptions): Promise<DeleteGroupMonitoringAgentProcessResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteGroupMonitoringAgentProcess",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteGroupMonitoringAgentProcessResponse>(await this.callApi(params, req, runtime), new DeleteGroupMonitoringAgentProcessResponse({}));
  }

  /**
   * Deletes a process monitoring task for an application group.
   * 
   * @param request - DeleteGroupMonitoringAgentProcessRequest
   * @returns DeleteGroupMonitoringAgentProcessResponse
   */
  async deleteGroupMonitoringAgentProcess(request: DeleteGroupMonitoringAgentProcessRequest): Promise<DeleteGroupMonitoringAgentProcessResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteGroupMonitoringAgentProcessWithOptions(request, runtime);
  }

  /**
   * Deletes one or more availability monitoring tasks.
   * 
   * @param request - DeleteHostAvailabilityRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteHostAvailabilityResponse
   */
  async deleteHostAvailabilityWithOptions(request: DeleteHostAvailabilityRequest, runtime: $Util.RuntimeOptions): Promise<DeleteHostAvailabilityResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteHostAvailability",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteHostAvailabilityResponse>(await this.callApi(params, req, runtime), new DeleteHostAvailabilityResponse({}));
  }

  /**
   * Deletes one or more availability monitoring tasks.
   * 
   * @param request - DeleteHostAvailabilityRequest
   * @returns DeleteHostAvailabilityResponse
   */
  async deleteHostAvailability(request: DeleteHostAvailabilityRequest): Promise<DeleteHostAvailabilityResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteHostAvailabilityWithOptions(request, runtime);
  }

  /**
   * Deletes a namespace.
   * 
   * @remarks
   * > If a metric import task is created for metrics in a namespace, you cannot delete the namespace unless you delete the task first.
   * This topic provides an example on how to delete a namespace named `aliyun`. The response shows that the namespace is deleted.
   * 
   * @param request - DeleteHybridMonitorNamespaceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteHybridMonitorNamespaceResponse
   */
  async deleteHybridMonitorNamespaceWithOptions(request: DeleteHybridMonitorNamespaceRequest, runtime: $Util.RuntimeOptions): Promise<DeleteHybridMonitorNamespaceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteHybridMonitorNamespace",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteHybridMonitorNamespaceResponse>(await this.callApi(params, req, runtime), new DeleteHybridMonitorNamespaceResponse({}));
  }

  /**
   * Deletes a namespace.
   * 
   * @remarks
   * > If a metric import task is created for metrics in a namespace, you cannot delete the namespace unless you delete the task first.
   * This topic provides an example on how to delete a namespace named `aliyun`. The response shows that the namespace is deleted.
   * 
   * @param request - DeleteHybridMonitorNamespaceRequest
   * @returns DeleteHybridMonitorNamespaceResponse
   */
  async deleteHybridMonitorNamespace(request: DeleteHybridMonitorNamespaceRequest): Promise<DeleteHybridMonitorNamespaceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteHybridMonitorNamespaceWithOptions(request, runtime);
  }

  /**
   * Deletes a Logstore group.
   * 
   * @remarks
   * This topic provides an example on how to delete a Logstore group named `Logstore_test`. The response shows that the Logstore group is deleted.
   * 
   * @param request - DeleteHybridMonitorSLSGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteHybridMonitorSLSGroupResponse
   */
  async deleteHybridMonitorSLSGroupWithOptions(request: DeleteHybridMonitorSLSGroupRequest, runtime: $Util.RuntimeOptions): Promise<DeleteHybridMonitorSLSGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.SLSGroupName)) {
      query["SLSGroupName"] = request.SLSGroupName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteHybridMonitorSLSGroup",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteHybridMonitorSLSGroupResponse>(await this.callApi(params, req, runtime), new DeleteHybridMonitorSLSGroupResponse({}));
  }

  /**
   * Deletes a Logstore group.
   * 
   * @remarks
   * This topic provides an example on how to delete a Logstore group named `Logstore_test`. The response shows that the Logstore group is deleted.
   * 
   * @param request - DeleteHybridMonitorSLSGroupRequest
   * @returns DeleteHybridMonitorSLSGroupResponse
   */
  async deleteHybridMonitorSLSGroup(request: DeleteHybridMonitorSLSGroupRequest): Promise<DeleteHybridMonitorSLSGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteHybridMonitorSLSGroupWithOptions(request, runtime);
  }

  /**
   * Deletes a metric import task for Alibaba Cloud services or a metric for the logs that are imported from Log Service.
   * 
   * @remarks
   * This topic provides an example on how to delete a metric import task whose ID is `36****`. The returned result indicates that the metric import task is deleted.
   * 
   * @param request - DeleteHybridMonitorTaskRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteHybridMonitorTaskResponse
   */
  async deleteHybridMonitorTaskWithOptions(request: DeleteHybridMonitorTaskRequest, runtime: $Util.RuntimeOptions): Promise<DeleteHybridMonitorTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.targetUserId)) {
      query["TargetUserId"] = request.targetUserId;
    }

    if (!Util.isUnset(request.taskId)) {
      query["TaskId"] = request.taskId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteHybridMonitorTask",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteHybridMonitorTaskResponse>(await this.callApi(params, req, runtime), new DeleteHybridMonitorTaskResponse({}));
  }

  /**
   * Deletes a metric import task for Alibaba Cloud services or a metric for the logs that are imported from Log Service.
   * 
   * @remarks
   * This topic provides an example on how to delete a metric import task whose ID is `36****`. The returned result indicates that the metric import task is deleted.
   * 
   * @param request - DeleteHybridMonitorTaskRequest
   * @returns DeleteHybridMonitorTaskResponse
   */
  async deleteHybridMonitorTask(request: DeleteHybridMonitorTaskRequest): Promise<DeleteHybridMonitorTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteHybridMonitorTaskWithOptions(request, runtime);
  }

  /**
   * Deletes a log monitoring metric.
   * 
   * @param request - DeleteLogMonitorRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteLogMonitorResponse
   */
  async deleteLogMonitorWithOptions(request: DeleteLogMonitorRequest, runtime: $Util.RuntimeOptions): Promise<DeleteLogMonitorResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.logId)) {
      query["LogId"] = request.logId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteLogMonitor",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteLogMonitorResponse>(await this.callApi(params, req, runtime), new DeleteLogMonitorResponse({}));
  }

  /**
   * Deletes a log monitoring metric.
   * 
   * @param request - DeleteLogMonitorRequest
   * @returns DeleteLogMonitorResponse
   */
  async deleteLogMonitor(request: DeleteLogMonitorRequest): Promise<DeleteLogMonitorResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteLogMonitorWithOptions(request, runtime);
  }

  /**
   * Deletes multiple blacklist policies at a time.
   * 
   * @param request - DeleteMetricRuleBlackListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteMetricRuleBlackListResponse
   */
  async deleteMetricRuleBlackListWithOptions(request: DeleteMetricRuleBlackListRequest, runtime: $Util.RuntimeOptions): Promise<DeleteMetricRuleBlackListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteMetricRuleBlackList",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteMetricRuleBlackListResponse>(await this.callApi(params, req, runtime), new DeleteMetricRuleBlackListResponse({}));
  }

  /**
   * Deletes multiple blacklist policies at a time.
   * 
   * @param request - DeleteMetricRuleBlackListRequest
   * @returns DeleteMetricRuleBlackListResponse
   */
  async deleteMetricRuleBlackList(request: DeleteMetricRuleBlackListRequest): Promise<DeleteMetricRuleBlackListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteMetricRuleBlackListWithOptions(request, runtime);
  }

  /**
   * Disassociates resources from an alert rule.
   * 
   * @param request - DeleteMetricRuleResourcesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteMetricRuleResourcesResponse
   */
  async deleteMetricRuleResourcesWithOptions(request: DeleteMetricRuleResourcesRequest, runtime: $Util.RuntimeOptions): Promise<DeleteMetricRuleResourcesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.resources)) {
      query["Resources"] = request.resources;
    }

    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteMetricRuleResources",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteMetricRuleResourcesResponse>(await this.callApi(params, req, runtime), new DeleteMetricRuleResourcesResponse({}));
  }

  /**
   * Disassociates resources from an alert rule.
   * 
   * @param request - DeleteMetricRuleResourcesRequest
   * @returns DeleteMetricRuleResourcesResponse
   */
  async deleteMetricRuleResources(request: DeleteMetricRuleResourcesRequest): Promise<DeleteMetricRuleResourcesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteMetricRuleResourcesWithOptions(request, runtime);
  }

  /**
   * Delete the push channels of an alert rule.
   * 
   * @param request - DeleteMetricRuleTargetsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteMetricRuleTargetsResponse
   */
  async deleteMetricRuleTargetsWithOptions(request: DeleteMetricRuleTargetsRequest, runtime: $Util.RuntimeOptions): Promise<DeleteMetricRuleTargetsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    if (!Util.isUnset(request.targetIds)) {
      query["TargetIds"] = request.targetIds;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteMetricRuleTargets",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteMetricRuleTargetsResponse>(await this.callApi(params, req, runtime), new DeleteMetricRuleTargetsResponse({}));
  }

  /**
   * Delete the push channels of an alert rule.
   * 
   * @param request - DeleteMetricRuleTargetsRequest
   * @returns DeleteMetricRuleTargetsResponse
   */
  async deleteMetricRuleTargets(request: DeleteMetricRuleTargetsRequest): Promise<DeleteMetricRuleTargetsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteMetricRuleTargetsWithOptions(request, runtime);
  }

  /**
   * Deletes an alert template.
   * 
   * @param request - DeleteMetricRuleTemplateRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteMetricRuleTemplateResponse
   */
  async deleteMetricRuleTemplateWithOptions(request: DeleteMetricRuleTemplateRequest, runtime: $Util.RuntimeOptions): Promise<DeleteMetricRuleTemplateResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.templateId)) {
      query["TemplateId"] = request.templateId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteMetricRuleTemplate",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteMetricRuleTemplateResponse>(await this.callApi(params, req, runtime), new DeleteMetricRuleTemplateResponse({}));
  }

  /**
   * Deletes an alert template.
   * 
   * @param request - DeleteMetricRuleTemplateRequest
   * @returns DeleteMetricRuleTemplateResponse
   */
  async deleteMetricRuleTemplate(request: DeleteMetricRuleTemplateRequest): Promise<DeleteMetricRuleTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteMetricRuleTemplateWithOptions(request, runtime);
  }

  /**
   * Deletes one or more alert rules.
   * 
   * @param request - DeleteMetricRulesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteMetricRulesResponse
   */
  async deleteMetricRulesWithOptions(request: DeleteMetricRulesRequest, runtime: $Util.RuntimeOptions): Promise<DeleteMetricRulesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteMetricRules",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteMetricRulesResponse>(await this.callApi(params, req, runtime), new DeleteMetricRulesResponse({}));
  }

  /**
   * Deletes one or more alert rules.
   * 
   * @param request - DeleteMetricRulesRequest
   * @returns DeleteMetricRulesResponse
   */
  async deleteMetricRules(request: DeleteMetricRulesRequest): Promise<DeleteMetricRulesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteMetricRulesWithOptions(request, runtime);
  }

  /**
   * Deletes an application group.
   * 
   * @param request - DeleteMonitorGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteMonitorGroupResponse
   */
  async deleteMonitorGroupWithOptions(request: DeleteMonitorGroupRequest, runtime: $Util.RuntimeOptions): Promise<DeleteMonitorGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteMonitorGroup",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteMonitorGroupResponse>(await this.callApi(params, req, runtime), new DeleteMonitorGroupResponse({}));
  }

  /**
   * Deletes an application group.
   * 
   * @param request - DeleteMonitorGroupRequest
   * @returns DeleteMonitorGroupResponse
   */
  async deleteMonitorGroup(request: DeleteMonitorGroupRequest): Promise<DeleteMonitorGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteMonitorGroupWithOptions(request, runtime);
  }

  /**
   * Deletes a rule that is used to dynamically add instances of a service that meet the rule to an application group.
   * 
   * @param request - DeleteMonitorGroupDynamicRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteMonitorGroupDynamicRuleResponse
   */
  async deleteMonitorGroupDynamicRuleWithOptions(request: DeleteMonitorGroupDynamicRuleRequest, runtime: $Util.RuntimeOptions): Promise<DeleteMonitorGroupDynamicRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.category)) {
      query["Category"] = request.category;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteMonitorGroupDynamicRule",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteMonitorGroupDynamicRuleResponse>(await this.callApi(params, req, runtime), new DeleteMonitorGroupDynamicRuleResponse({}));
  }

  /**
   * Deletes a rule that is used to dynamically add instances of a service that meet the rule to an application group.
   * 
   * @param request - DeleteMonitorGroupDynamicRuleRequest
   * @returns DeleteMonitorGroupDynamicRuleResponse
   */
  async deleteMonitorGroupDynamicRule(request: DeleteMonitorGroupDynamicRuleRequest): Promise<DeleteMonitorGroupDynamicRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteMonitorGroupDynamicRuleWithOptions(request, runtime);
  }

  /**
   * Removes instances from an application group.
   * 
   * @param request - DeleteMonitorGroupInstancesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteMonitorGroupInstancesResponse
   */
  async deleteMonitorGroupInstancesWithOptions(request: DeleteMonitorGroupInstancesRequest, runtime: $Util.RuntimeOptions): Promise<DeleteMonitorGroupInstancesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.category)) {
      query["Category"] = request.category;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.instanceIdList)) {
      query["InstanceIdList"] = request.instanceIdList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteMonitorGroupInstances",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteMonitorGroupInstancesResponse>(await this.callApi(params, req, runtime), new DeleteMonitorGroupInstancesResponse({}));
  }

  /**
   * Removes instances from an application group.
   * 
   * @param request - DeleteMonitorGroupInstancesRequest
   * @returns DeleteMonitorGroupInstancesResponse
   */
  async deleteMonitorGroupInstances(request: DeleteMonitorGroupInstancesRequest): Promise<DeleteMonitorGroupInstancesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteMonitorGroupInstancesWithOptions(request, runtime);
  }

  /**
   * Deletes a policy that is used to pause alert notifications for an application group.
   * 
   * @param request - DeleteMonitorGroupNotifyPolicyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteMonitorGroupNotifyPolicyResponse
   */
  async deleteMonitorGroupNotifyPolicyWithOptions(request: DeleteMonitorGroupNotifyPolicyRequest, runtime: $Util.RuntimeOptions): Promise<DeleteMonitorGroupNotifyPolicyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.policyType)) {
      query["PolicyType"] = request.policyType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteMonitorGroupNotifyPolicy",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteMonitorGroupNotifyPolicyResponse>(await this.callApi(params, req, runtime), new DeleteMonitorGroupNotifyPolicyResponse({}));
  }

  /**
   * Deletes a policy that is used to pause alert notifications for an application group.
   * 
   * @param request - DeleteMonitorGroupNotifyPolicyRequest
   * @returns DeleteMonitorGroupNotifyPolicyResponse
   */
  async deleteMonitorGroupNotifyPolicy(request: DeleteMonitorGroupNotifyPolicyRequest): Promise<DeleteMonitorGroupNotifyPolicyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteMonitorGroupNotifyPolicyWithOptions(request, runtime);
  }

  /**
   * Disables monitoring on a process.
   * 
   * @param request - DeleteMonitoringAgentProcessRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteMonitoringAgentProcessResponse
   */
  async deleteMonitoringAgentProcessWithOptions(request: DeleteMonitoringAgentProcessRequest, runtime: $Util.RuntimeOptions): Promise<DeleteMonitoringAgentProcessResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.processId)) {
      query["ProcessId"] = request.processId;
    }

    if (!Util.isUnset(request.processName)) {
      query["ProcessName"] = request.processName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteMonitoringAgentProcess",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteMonitoringAgentProcessResponse>(await this.callApi(params, req, runtime), new DeleteMonitoringAgentProcessResponse({}));
  }

  /**
   * Disables monitoring on a process.
   * 
   * @param request - DeleteMonitoringAgentProcessRequest
   * @returns DeleteMonitoringAgentProcessResponse
   */
  async deleteMonitoringAgentProcess(request: DeleteMonitoringAgentProcessRequest): Promise<DeleteMonitoringAgentProcessResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteMonitoringAgentProcessWithOptions(request, runtime);
  }

  /**
   * Deletes one or more site monitoring tasks.
   * 
   * @param request - DeleteSiteMonitorsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteSiteMonitorsResponse
   */
  async deleteSiteMonitorsWithOptions(request: DeleteSiteMonitorsRequest, runtime: $Util.RuntimeOptions): Promise<DeleteSiteMonitorsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.isDeleteAlarms)) {
      query["IsDeleteAlarms"] = request.isDeleteAlarms;
    }

    if (!Util.isUnset(request.taskIds)) {
      query["TaskIds"] = request.taskIds;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteSiteMonitors",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteSiteMonitorsResponse>(await this.callApi(params, req, runtime), new DeleteSiteMonitorsResponse({}));
  }

  /**
   * Deletes one or more site monitoring tasks.
   * 
   * @param request - DeleteSiteMonitorsRequest
   * @returns DeleteSiteMonitorsResponse
   */
  async deleteSiteMonitors(request: DeleteSiteMonitorsRequest): Promise<DeleteSiteMonitorsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteSiteMonitorsWithOptions(request, runtime);
  }

  /**
   * Queries the details of initiative alert rules.
   * 
   * @param request - DescribeActiveMetricRuleListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeActiveMetricRuleListResponse
   */
  async describeActiveMetricRuleListWithOptions(request: DescribeActiveMetricRuleListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeActiveMetricRuleListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.product)) {
      query["Product"] = request.product;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeActiveMetricRuleList",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeActiveMetricRuleListResponse>(await this.callApi(params, req, runtime), new DescribeActiveMetricRuleListResponse({}));
  }

  /**
   * Queries the details of initiative alert rules.
   * 
   * @param request - DescribeActiveMetricRuleListRequest
   * @returns DescribeActiveMetricRuleListResponse
   */
  async describeActiveMetricRuleList(request: DescribeActiveMetricRuleListRequest): Promise<DescribeActiveMetricRuleListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeActiveMetricRuleListWithOptions(request, runtime);
  }

  /**
   * Queries historical alerts.
   * 
   * @remarks
   * This API operation is no longer maintained. We recommend that you call the [DescribeAlertLogList](https://help.aliyun.com/document_detail/201087.html) operation.
   * 
   * @deprecated OpenAPI DescribeAlertHistoryList is deprecated, please use Cms::2019-01-01::DescribeAlertLogList instead.
   * 
   * @param request - DescribeAlertHistoryListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeAlertHistoryListResponse
   */
  // Deprecated
  async describeAlertHistoryListWithOptions(request: DescribeAlertHistoryListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAlertHistoryListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ascending)) {
      query["Ascending"] = request.ascending;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.metricName)) {
      query["MetricName"] = request.metricName;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.page)) {
      query["Page"] = request.page;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    if (!Util.isUnset(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.state)) {
      query["State"] = request.state;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAlertHistoryList",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAlertHistoryListResponse>(await this.callApi(params, req, runtime), new DescribeAlertHistoryListResponse({}));
  }

  /**
   * Queries historical alerts.
   * 
   * @remarks
   * This API operation is no longer maintained. We recommend that you call the [DescribeAlertLogList](https://help.aliyun.com/document_detail/201087.html) operation.
   * 
   * @deprecated OpenAPI DescribeAlertHistoryList is deprecated, please use Cms::2019-01-01::DescribeAlertLogList instead.
   * 
   * @param request - DescribeAlertHistoryListRequest
   * @returns DescribeAlertHistoryListResponse
   */
  // Deprecated
  async describeAlertHistoryList(request: DescribeAlertHistoryListRequest): Promise<DescribeAlertHistoryListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAlertHistoryListWithOptions(request, runtime);
  }

  /**
   * Queries the statistics of alert logs.
   * 
   * @remarks
   * Queries the statistics of alert logs.
   * This topic provides an example on how to query the statistics of alert logs for Elastic Compute Service (ECS) based on the `product` dimension.
   * 
   * @param request - DescribeAlertLogCountRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeAlertLogCountResponse
   */
  async describeAlertLogCountWithOptions(request: DescribeAlertLogCountRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAlertLogCountResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.contactGroup)) {
      query["ContactGroup"] = request.contactGroup;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.eventType)) {
      query["EventType"] = request.eventType;
    }

    if (!Util.isUnset(request.groupBy)) {
      query["GroupBy"] = request.groupBy;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.lastMin)) {
      query["LastMin"] = request.lastMin;
    }

    if (!Util.isUnset(request.level)) {
      query["Level"] = request.level;
    }

    if (!Util.isUnset(request.metricName)) {
      query["MetricName"] = request.metricName;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.product)) {
      query["Product"] = request.product;
    }

    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    if (!Util.isUnset(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    if (!Util.isUnset(request.searchKey)) {
      query["SearchKey"] = request.searchKey;
    }

    if (!Util.isUnset(request.sendStatus)) {
      query["SendStatus"] = request.sendStatus;
    }

    if (!Util.isUnset(request.sourceType)) {
      query["SourceType"] = request.sourceType;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAlertLogCount",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAlertLogCountResponse>(await this.callApi(params, req, runtime), new DescribeAlertLogCountResponse({}));
  }

  /**
   * Queries the statistics of alert logs.
   * 
   * @remarks
   * Queries the statistics of alert logs.
   * This topic provides an example on how to query the statistics of alert logs for Elastic Compute Service (ECS) based on the `product` dimension.
   * 
   * @param request - DescribeAlertLogCountRequest
   * @returns DescribeAlertLogCountResponse
   */
  async describeAlertLogCount(request: DescribeAlertLogCountRequest): Promise<DescribeAlertLogCountResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAlertLogCountWithOptions(request, runtime);
  }

  /**
   * Queries the number of alert logs that are generated during each interval within a period of time.
   * 
   * @remarks
   * This topic provides an example on how to query the number of alert logs for Elastic Compute Service (ECS) based on the `product` dimension.
   * 
   * @param request - DescribeAlertLogHistogramRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeAlertLogHistogramResponse
   */
  async describeAlertLogHistogramWithOptions(request: DescribeAlertLogHistogramRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAlertLogHistogramResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.contactGroup)) {
      query["ContactGroup"] = request.contactGroup;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.eventType)) {
      query["EventType"] = request.eventType;
    }

    if (!Util.isUnset(request.groupBy)) {
      query["GroupBy"] = request.groupBy;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.lastMin)) {
      query["LastMin"] = request.lastMin;
    }

    if (!Util.isUnset(request.level)) {
      query["Level"] = request.level;
    }

    if (!Util.isUnset(request.metricName)) {
      query["MetricName"] = request.metricName;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.product)) {
      query["Product"] = request.product;
    }

    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    if (!Util.isUnset(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    if (!Util.isUnset(request.searchKey)) {
      query["SearchKey"] = request.searchKey;
    }

    if (!Util.isUnset(request.sendStatus)) {
      query["SendStatus"] = request.sendStatus;
    }

    if (!Util.isUnset(request.sourceType)) {
      query["SourceType"] = request.sourceType;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAlertLogHistogram",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAlertLogHistogramResponse>(await this.callApi(params, req, runtime), new DescribeAlertLogHistogramResponse({}));
  }

  /**
   * Queries the number of alert logs that are generated during each interval within a period of time.
   * 
   * @remarks
   * This topic provides an example on how to query the number of alert logs for Elastic Compute Service (ECS) based on the `product` dimension.
   * 
   * @param request - DescribeAlertLogHistogramRequest
   * @returns DescribeAlertLogHistogramResponse
   */
  async describeAlertLogHistogram(request: DescribeAlertLogHistogramRequest): Promise<DescribeAlertLogHistogramResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAlertLogHistogramWithOptions(request, runtime);
  }

  /**
   * Queries alert logs.
   * 
   * @remarks
   * You can call the operation to query only the alert logs within the last year.
   * This topic provides an example to show how to query the alert logs of Elastic Compute Service (ECS) based on the `product` dimension.
   * 
   * @param request - DescribeAlertLogListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeAlertLogListResponse
   */
  async describeAlertLogListWithOptions(request: DescribeAlertLogListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAlertLogListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.contactGroup)) {
      query["ContactGroup"] = request.contactGroup;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.eventType)) {
      query["EventType"] = request.eventType;
    }

    if (!Util.isUnset(request.groupBy)) {
      query["GroupBy"] = request.groupBy;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.lastMin)) {
      query["LastMin"] = request.lastMin;
    }

    if (!Util.isUnset(request.level)) {
      query["Level"] = request.level;
    }

    if (!Util.isUnset(request.metricName)) {
      query["MetricName"] = request.metricName;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.product)) {
      query["Product"] = request.product;
    }

    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    if (!Util.isUnset(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    if (!Util.isUnset(request.searchKey)) {
      query["SearchKey"] = request.searchKey;
    }

    if (!Util.isUnset(request.sendStatus)) {
      query["SendStatus"] = request.sendStatus;
    }

    if (!Util.isUnset(request.sourceType)) {
      query["SourceType"] = request.sourceType;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAlertLogList",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAlertLogListResponse>(await this.callApi(params, req, runtime), new DescribeAlertLogListResponse({}));
  }

  /**
   * Queries alert logs.
   * 
   * @remarks
   * You can call the operation to query only the alert logs within the last year.
   * This topic provides an example to show how to query the alert logs of Elastic Compute Service (ECS) based on the `product` dimension.
   * 
   * @param request - DescribeAlertLogListRequest
   * @returns DescribeAlertLogListResponse
   */
  async describeAlertLogList(request: DescribeAlertLogListRequest): Promise<DescribeAlertLogListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAlertLogListWithOptions(request, runtime);
  }

  /**
   * Queries the resources for which active alerts are triggered based on an alert rule.
   * 
   * @param request - DescribeAlertingMetricRuleResourcesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeAlertingMetricRuleResourcesResponse
   */
  async describeAlertingMetricRuleResourcesWithOptions(request: DescribeAlertingMetricRuleResourcesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAlertingMetricRuleResourcesResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAlertingMetricRuleResources",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAlertingMetricRuleResourcesResponse>(await this.callApi(params, req, runtime), new DescribeAlertingMetricRuleResourcesResponse({}));
  }

  /**
   * Queries the resources for which active alerts are triggered based on an alert rule.
   * 
   * @param request - DescribeAlertingMetricRuleResourcesRequest
   * @returns DescribeAlertingMetricRuleResourcesResponse
   */
  async describeAlertingMetricRuleResources(request: DescribeAlertingMetricRuleResourcesRequest): Promise<DescribeAlertingMetricRuleResourcesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAlertingMetricRuleResourcesWithOptions(request, runtime);
  }

  /**
   * Queries alert groups.
   * 
   * @param request - DescribeContactGroupListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeContactGroupListResponse
   */
  async describeContactGroupListWithOptions(request: DescribeContactGroupListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeContactGroupListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeContactGroupList",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeContactGroupListResponse>(await this.callApi(params, req, runtime), new DescribeContactGroupListResponse({}));
  }

  /**
   * Queries alert groups.
   * 
   * @param request - DescribeContactGroupListRequest
   * @returns DescribeContactGroupListResponse
   */
  async describeContactGroupList(request: DescribeContactGroupListRequest): Promise<DescribeContactGroupListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeContactGroupListWithOptions(request, runtime);
  }

  /**
   * Queries alert contacts.
   * 
   * @param request - DescribeContactListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeContactListResponse
   */
  async describeContactListWithOptions(request: DescribeContactListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeContactListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.chanelType)) {
      query["ChanelType"] = request.chanelType;
    }

    if (!Util.isUnset(request.chanelValue)) {
      query["ChanelValue"] = request.chanelValue;
    }

    if (!Util.isUnset(request.contactName)) {
      query["ContactName"] = request.contactName;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeContactList",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeContactListResponse>(await this.callApi(params, req, runtime), new DescribeContactListResponse({}));
  }

  /**
   * Queries alert contacts.
   * 
   * @param request - DescribeContactListRequest
   * @returns DescribeContactListResponse
   */
  async describeContactList(request: DescribeContactListRequest): Promise<DescribeContactListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeContactListWithOptions(request, runtime);
  }

  /**
   * Queries the alert contacts in an alert contact group.
   * 
   * @param request - DescribeContactListByContactGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeContactListByContactGroupResponse
   */
  async describeContactListByContactGroupWithOptions(request: DescribeContactListByContactGroupRequest, runtime: $Util.RuntimeOptions): Promise<DescribeContactListByContactGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.contactGroupName)) {
      query["ContactGroupName"] = request.contactGroupName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeContactListByContactGroup",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeContactListByContactGroupResponse>(await this.callApi(params, req, runtime), new DescribeContactListByContactGroupResponse({}));
  }

  /**
   * Queries the alert contacts in an alert contact group.
   * 
   * @param request - DescribeContactListByContactGroupRequest
   * @returns DescribeContactListByContactGroupResponse
   */
  async describeContactListByContactGroup(request: DescribeContactListByContactGroupRequest): Promise<DescribeContactListByContactGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeContactListByContactGroupWithOptions(request, runtime);
  }

  /**
   * Queries the details of a custom event that occurred in a specified time period.
   * 
   * @param request - DescribeCustomEventAttributeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeCustomEventAttributeResponse
   */
  async describeCustomEventAttributeWithOptions(request: DescribeCustomEventAttributeRequest, runtime: $Util.RuntimeOptions): Promise<DescribeCustomEventAttributeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.eventId)) {
      query["EventId"] = request.eventId;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.searchKeywords)) {
      query["SearchKeywords"] = request.searchKeywords;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeCustomEventAttribute",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeCustomEventAttributeResponse>(await this.callApi(params, req, runtime), new DescribeCustomEventAttributeResponse({}));
  }

  /**
   * Queries the details of a custom event that occurred in a specified time period.
   * 
   * @param request - DescribeCustomEventAttributeRequest
   * @returns DescribeCustomEventAttributeResponse
   */
  async describeCustomEventAttribute(request: DescribeCustomEventAttributeRequest): Promise<DescribeCustomEventAttributeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeCustomEventAttributeWithOptions(request, runtime);
  }

  /**
   * Queries the number of times that a custom event occurred in a specified time period.
   * 
   * @remarks
   * >  This operation counts the number of times that a custom event occurred for each service.
   * 
   * @param request - DescribeCustomEventCountRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeCustomEventCountResponse
   */
  async describeCustomEventCountWithOptions(request: DescribeCustomEventCountRequest, runtime: $Util.RuntimeOptions): Promise<DescribeCustomEventCountResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.eventId)) {
      query["EventId"] = request.eventId;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.searchKeywords)) {
      query["SearchKeywords"] = request.searchKeywords;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeCustomEventCount",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeCustomEventCountResponse>(await this.callApi(params, req, runtime), new DescribeCustomEventCountResponse({}));
  }

  /**
   * Queries the number of times that a custom event occurred in a specified time period.
   * 
   * @remarks
   * >  This operation counts the number of times that a custom event occurred for each service.
   * 
   * @param request - DescribeCustomEventCountRequest
   * @returns DescribeCustomEventCountResponse
   */
  async describeCustomEventCount(request: DescribeCustomEventCountRequest): Promise<DescribeCustomEventCountResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeCustomEventCountWithOptions(request, runtime);
  }

  /**
   * Queries the number of times that a custom event occurred during each interval of a time period.
   * 
   * @param request - DescribeCustomEventHistogramRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeCustomEventHistogramResponse
   */
  async describeCustomEventHistogramWithOptions(request: DescribeCustomEventHistogramRequest, runtime: $Util.RuntimeOptions): Promise<DescribeCustomEventHistogramResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.eventId)) {
      query["EventId"] = request.eventId;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.level)) {
      query["Level"] = request.level;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.searchKeywords)) {
      query["SearchKeywords"] = request.searchKeywords;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeCustomEventHistogram",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeCustomEventHistogramResponse>(await this.callApi(params, req, runtime), new DescribeCustomEventHistogramResponse({}));
  }

  /**
   * Queries the number of times that a custom event occurred during each interval of a time period.
   * 
   * @param request - DescribeCustomEventHistogramRequest
   * @returns DescribeCustomEventHistogramResponse
   */
  async describeCustomEventHistogram(request: DescribeCustomEventHistogramRequest): Promise<DescribeCustomEventHistogramResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeCustomEventHistogramWithOptions(request, runtime);
  }

  /**
   * Queries the reported custom metrics of a cloud service.
   * 
   * @remarks
   * >  You can call the DescribeMetricList operation to query the metrics of a cloud service. For more information, see [DescribeMetricList](https://help.aliyun.com/document_detail/51936.html).
   * 
   * @param request - DescribeCustomMetricListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeCustomMetricListResponse
   */
  async describeCustomMetricListWithOptions(request: DescribeCustomMetricListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeCustomMetricListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dimension)) {
      query["Dimension"] = request.dimension;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.md5)) {
      query["Md5"] = request.md5;
    }

    if (!Util.isUnset(request.metricName)) {
      query["MetricName"] = request.metricName;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeCustomMetricList",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeCustomMetricListResponse>(await this.callApi(params, req, runtime), new DescribeCustomMetricListResponse({}));
  }

  /**
   * Queries the reported custom metrics of a cloud service.
   * 
   * @remarks
   * >  You can call the DescribeMetricList operation to query the metrics of a cloud service. For more information, see [DescribeMetricList](https://help.aliyun.com/document_detail/51936.html).
   * 
   * @param request - DescribeCustomMetricListRequest
   * @returns DescribeCustomMetricListResponse
   */
  async describeCustomMetricList(request: DescribeCustomMetricListRequest): Promise<DescribeCustomMetricListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeCustomMetricListWithOptions(request, runtime);
  }

  /**
   * Queries tag rules.
   * 
   * @remarks
   * This topic provides an example to show how to query tag rules that are related to `tagkey1`. The sample responses indicate that two tag rules are found. The rule IDs are `1536df65-a719-429d-8813-73cc40d7****` and `56e8cebb-b3d7-4a91-9880-78a8c84f****`.
   * 
   * @param request - DescribeDynamicTagRuleListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDynamicTagRuleListResponse
   */
  async describeDynamicTagRuleListWithOptions(request: DescribeDynamicTagRuleListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDynamicTagRuleListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dynamicTagRuleId)) {
      query["DynamicTagRuleId"] = request.dynamicTagRuleId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.tagKey)) {
      query["TagKey"] = request.tagKey;
    }

    if (!Util.isUnset(request.tagRegionId)) {
      query["TagRegionId"] = request.tagRegionId;
    }

    if (!Util.isUnset(request.tagValue)) {
      query["TagValue"] = request.tagValue;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDynamicTagRuleList",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDynamicTagRuleListResponse>(await this.callApi(params, req, runtime), new DescribeDynamicTagRuleListResponse({}));
  }

  /**
   * Queries tag rules.
   * 
   * @remarks
   * This topic provides an example to show how to query tag rules that are related to `tagkey1`. The sample responses indicate that two tag rules are found. The rule IDs are `1536df65-a719-429d-8813-73cc40d7****` and `56e8cebb-b3d7-4a91-9880-78a8c84f****`.
   * 
   * @param request - DescribeDynamicTagRuleListRequest
   * @returns DescribeDynamicTagRuleListResponse
   */
  async describeDynamicTagRuleList(request: DescribeDynamicTagRuleListRequest): Promise<DescribeDynamicTagRuleListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDynamicTagRuleListWithOptions(request, runtime);
  }

  /**
   * Queries the details of an event-triggered alert rule.
   * 
   * @remarks
   * This topic provides an example to show how to query the details of an event-triggered alert rule named `testRule`.
   * 
   * @param request - DescribeEventRuleAttributeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeEventRuleAttributeResponse
   */
  async describeEventRuleAttributeWithOptions(request: DescribeEventRuleAttributeRequest, runtime: $Util.RuntimeOptions): Promise<DescribeEventRuleAttributeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    if (!Util.isUnset(request.silenceTime)) {
      query["SilenceTime"] = request.silenceTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeEventRuleAttribute",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeEventRuleAttributeResponse>(await this.callApi(params, req, runtime), new DescribeEventRuleAttributeResponse({}));
  }

  /**
   * Queries the details of an event-triggered alert rule.
   * 
   * @remarks
   * This topic provides an example to show how to query the details of an event-triggered alert rule named `testRule`.
   * 
   * @param request - DescribeEventRuleAttributeRequest
   * @returns DescribeEventRuleAttributeResponse
   */
  async describeEventRuleAttribute(request: DescribeEventRuleAttributeRequest): Promise<DescribeEventRuleAttributeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeEventRuleAttributeWithOptions(request, runtime);
  }

  /**
   * Queries event-triggered alert rules.
   * 
   * @param request - DescribeEventRuleListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeEventRuleListResponse
   */
  async describeEventRuleListWithOptions(request: DescribeEventRuleListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeEventRuleListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.isEnable)) {
      query["IsEnable"] = request.isEnable;
    }

    if (!Util.isUnset(request.namePrefix)) {
      query["NamePrefix"] = request.namePrefix;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeEventRuleList",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeEventRuleListResponse>(await this.callApi(params, req, runtime), new DescribeEventRuleListResponse({}));
  }

  /**
   * Queries event-triggered alert rules.
   * 
   * @param request - DescribeEventRuleListRequest
   * @returns DescribeEventRuleListResponse
   */
  async describeEventRuleList(request: DescribeEventRuleListRequest): Promise<DescribeEventRuleListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeEventRuleListWithOptions(request, runtime);
  }

  /**
   * Queries the push channels of an event-triggered alert rule.
   * 
   * @remarks
   * This topic provides an example to show how to query the details of an event-triggered alert rule named `testRule`.
   * 
   * @param request - DescribeEventRuleTargetListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeEventRuleTargetListResponse
   */
  async describeEventRuleTargetListWithOptions(request: DescribeEventRuleTargetListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeEventRuleTargetListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeEventRuleTargetList",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeEventRuleTargetListResponse>(await this.callApi(params, req, runtime), new DescribeEventRuleTargetListResponse({}));
  }

  /**
   * Queries the push channels of an event-triggered alert rule.
   * 
   * @remarks
   * This topic provides an example to show how to query the details of an event-triggered alert rule named `testRule`.
   * 
   * @param request - DescribeEventRuleTargetListRequest
   * @returns DescribeEventRuleTargetListResponse
   */
  async describeEventRuleTargetList(request: DescribeEventRuleTargetListRequest): Promise<DescribeEventRuleTargetListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeEventRuleTargetListWithOptions(request, runtime);
  }

  /**
   * Queries configuration sets that are used to export monitoring data.
   * 
   * @param request - DescribeExporterOutputListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeExporterOutputListResponse
   */
  async describeExporterOutputListWithOptions(request: DescribeExporterOutputListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeExporterOutputListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeExporterOutputList",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeExporterOutputListResponse>(await this.callApi(params, req, runtime), new DescribeExporterOutputListResponse({}));
  }

  /**
   * Queries configuration sets that are used to export monitoring data.
   * 
   * @param request - DescribeExporterOutputListRequest
   * @returns DescribeExporterOutputListResponse
   */
  async describeExporterOutputList(request: DescribeExporterOutputListRequest): Promise<DescribeExporterOutputListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeExporterOutputListWithOptions(request, runtime);
  }

  /**
   * Queries data export rules.
   * 
   * @param request - DescribeExporterRuleListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeExporterRuleListResponse
   */
  async describeExporterRuleListWithOptions(request: DescribeExporterRuleListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeExporterRuleListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeExporterRuleList",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeExporterRuleListResponse>(await this.callApi(params, req, runtime), new DescribeExporterRuleListResponse({}));
  }

  /**
   * Queries data export rules.
   * 
   * @param request - DescribeExporterRuleListRequest
   * @returns DescribeExporterRuleListResponse
   */
  async describeExporterRuleList(request: DescribeExporterRuleListRequest): Promise<DescribeExporterRuleListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeExporterRuleListWithOptions(request, runtime);
  }

  /**
   * Queries the process monitoring tasks for an application group.
   * 
   * @remarks
   * You can create a process monitoring task to monitor all or the specified Elastic Compute Service (ECS) instances in an application group and configure alert rules for the process monitoring task.
   * 
   * @param request - DescribeGroupMonitoringAgentProcessRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeGroupMonitoringAgentProcessResponse
   */
  async describeGroupMonitoringAgentProcessWithOptions(request: DescribeGroupMonitoringAgentProcessRequest, runtime: $Util.RuntimeOptions): Promise<DescribeGroupMonitoringAgentProcessResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.processName)) {
      query["ProcessName"] = request.processName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeGroupMonitoringAgentProcess",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeGroupMonitoringAgentProcessResponse>(await this.callApi(params, req, runtime), new DescribeGroupMonitoringAgentProcessResponse({}));
  }

  /**
   * Queries the process monitoring tasks for an application group.
   * 
   * @remarks
   * You can create a process monitoring task to monitor all or the specified Elastic Compute Service (ECS) instances in an application group and configure alert rules for the process monitoring task.
   * 
   * @param request - DescribeGroupMonitoringAgentProcessRequest
   * @returns DescribeGroupMonitoringAgentProcessResponse
   */
  async describeGroupMonitoringAgentProcess(request: DescribeGroupMonitoringAgentProcessRequest): Promise<DescribeGroupMonitoringAgentProcessResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeGroupMonitoringAgentProcessWithOptions(request, runtime);
  }

  /**
   * Queries availability monitoring tasks.
   * 
   * @remarks
   * This topic provides an example to show how to query all the availability monitoring tasks of your Alibaba Cloud account. The sample responses indicate that the account has one availability monitoring task named `ecs_instance`.
   * 
   * @param request - DescribeHostAvailabilityListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeHostAvailabilityListResponse
   */
  async describeHostAvailabilityListWithOptions(request: DescribeHostAvailabilityListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeHostAvailabilityListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.ids)) {
      query["Ids"] = request.ids;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.taskName)) {
      query["TaskName"] = request.taskName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeHostAvailabilityList",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeHostAvailabilityListResponse>(await this.callApi(params, req, runtime), new DescribeHostAvailabilityListResponse({}));
  }

  /**
   * Queries availability monitoring tasks.
   * 
   * @remarks
   * This topic provides an example to show how to query all the availability monitoring tasks of your Alibaba Cloud account. The sample responses indicate that the account has one availability monitoring task named `ecs_instance`.
   * 
   * @param request - DescribeHostAvailabilityListRequest
   * @returns DescribeHostAvailabilityListResponse
   */
  async describeHostAvailabilityList(request: DescribeHostAvailabilityListRequest): Promise<DescribeHostAvailabilityListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeHostAvailabilityListWithOptions(request, runtime);
  }

  /**
   * Queries the monitoring data in a namespace.
   * 
   * @remarks
   * # [](#)Prerequisites
   * Hybrid Cloud Monitoring is activated. For more information, see [Activate Hybrid Cloud Monitoring](https://help.aliyun.com/document_detail/250773.html).
   * # [](#)Limits
   * The size of monitoring data that is returned in each call cannot exceed 1.5 MB. If the returned data reaches the upper limit, the query fails. You must reset the query conditions.
   * # [](#)Description
   * This topic provides an example to show how to query the monitoring data of the `AliyunEcs_cpu_total` metric in the `default-aliyun` namespace from `1653804865` (14:14:25 on May 29, 2022) to `1653805225` (14:20:25 on May 29, 2022).
   * 
   * @param request - DescribeHybridMonitorDataListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeHybridMonitorDataListResponse
   */
  async describeHybridMonitorDataListWithOptions(request: DescribeHybridMonitorDataListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeHybridMonitorDataListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.end)) {
      query["End"] = request.end;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.period)) {
      query["Period"] = request.period;
    }

    if (!Util.isUnset(request.promSQL)) {
      query["PromSQL"] = request.promSQL;
    }

    if (!Util.isUnset(request.start)) {
      query["Start"] = request.start;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeHybridMonitorDataList",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeHybridMonitorDataListResponse>(await this.callApi(params, req, runtime), new DescribeHybridMonitorDataListResponse({}));
  }

  /**
   * Queries the monitoring data in a namespace.
   * 
   * @remarks
   * # [](#)Prerequisites
   * Hybrid Cloud Monitoring is activated. For more information, see [Activate Hybrid Cloud Monitoring](https://help.aliyun.com/document_detail/250773.html).
   * # [](#)Limits
   * The size of monitoring data that is returned in each call cannot exceed 1.5 MB. If the returned data reaches the upper limit, the query fails. You must reset the query conditions.
   * # [](#)Description
   * This topic provides an example to show how to query the monitoring data of the `AliyunEcs_cpu_total` metric in the `default-aliyun` namespace from `1653804865` (14:14:25 on May 29, 2022) to `1653805225` (14:20:25 on May 29, 2022).
   * 
   * @param request - DescribeHybridMonitorDataListRequest
   * @returns DescribeHybridMonitorDataListResponse
   */
  async describeHybridMonitorDataList(request: DescribeHybridMonitorDataListRequest): Promise<DescribeHybridMonitorDataListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeHybridMonitorDataListWithOptions(request, runtime);
  }

  /**
   * Queries namespaces and the details of the related metric import tasks.
   * 
   * @remarks
   * In this example, all namespaces within the current account are queried. The response shows that the current account has only one namespace named `aliyun-test`.
   * 
   * @param request - DescribeHybridMonitorNamespaceListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeHybridMonitorNamespaceListResponse
   */
  async describeHybridMonitorNamespaceListWithOptions(request: DescribeHybridMonitorNamespaceListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeHybridMonitorNamespaceListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.keyword)) {
      query["Keyword"] = request.keyword;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.showTaskStatistic)) {
      query["ShowTaskStatistic"] = request.showTaskStatistic;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeHybridMonitorNamespaceList",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeHybridMonitorNamespaceListResponse>(await this.callApi(params, req, runtime), new DescribeHybridMonitorNamespaceListResponse({}));
  }

  /**
   * Queries namespaces and the details of the related metric import tasks.
   * 
   * @remarks
   * In this example, all namespaces within the current account are queried. The response shows that the current account has only one namespace named `aliyun-test`.
   * 
   * @param request - DescribeHybridMonitorNamespaceListRequest
   * @returns DescribeHybridMonitorNamespaceListResponse
   */
  async describeHybridMonitorNamespaceList(request: DescribeHybridMonitorNamespaceListRequest): Promise<DescribeHybridMonitorNamespaceListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeHybridMonitorNamespaceListWithOptions(request, runtime);
  }

  /**
   * Queries Logstore groups.
   * 
   * @remarks
   * In this example, all Logstore groups within the current account are queried. The response shows that the current account has two Logstore groups: `Logstore_test` and `Logstore_aliyun`.
   * 
   * @param request - DescribeHybridMonitorSLSGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeHybridMonitorSLSGroupResponse
   */
  async describeHybridMonitorSLSGroupWithOptions(request: DescribeHybridMonitorSLSGroupRequest, runtime: $Util.RuntimeOptions): Promise<DescribeHybridMonitorSLSGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.keyword)) {
      query["Keyword"] = request.keyword;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.SLSGroupName)) {
      query["SLSGroupName"] = request.SLSGroupName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeHybridMonitorSLSGroup",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeHybridMonitorSLSGroupResponse>(await this.callApi(params, req, runtime), new DescribeHybridMonitorSLSGroupResponse({}));
  }

  /**
   * Queries Logstore groups.
   * 
   * @remarks
   * In this example, all Logstore groups within the current account are queried. The response shows that the current account has two Logstore groups: `Logstore_test` and `Logstore_aliyun`.
   * 
   * @param request - DescribeHybridMonitorSLSGroupRequest
   * @returns DescribeHybridMonitorSLSGroupResponse
   */
  async describeHybridMonitorSLSGroup(request: DescribeHybridMonitorSLSGroupRequest): Promise<DescribeHybridMonitorSLSGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeHybridMonitorSLSGroupWithOptions(request, runtime);
  }

  /**
   * Queries metric import tasks.
   * 
   * @remarks
   * This topic provides an example on how to query all metric import tasks that belong to the current Alibaba Cloud account. The returned result indicates that the current account has only one metric import task. The metric import task is named `aliyun_task`.
   * 
   * @param request - DescribeHybridMonitorTaskListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeHybridMonitorTaskListResponse
   */
  async describeHybridMonitorTaskListWithOptions(request: DescribeHybridMonitorTaskListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeHybridMonitorTaskListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.includeAliyunTask)) {
      query["IncludeAliyunTask"] = request.includeAliyunTask;
    }

    if (!Util.isUnset(request.keyword)) {
      query["Keyword"] = request.keyword;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.targetUserId)) {
      query["TargetUserId"] = request.targetUserId;
    }

    if (!Util.isUnset(request.taskId)) {
      query["TaskId"] = request.taskId;
    }

    if (!Util.isUnset(request.taskType)) {
      query["TaskType"] = request.taskType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeHybridMonitorTaskList",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeHybridMonitorTaskListResponse>(await this.callApi(params, req, runtime), new DescribeHybridMonitorTaskListResponse({}));
  }

  /**
   * Queries metric import tasks.
   * 
   * @remarks
   * This topic provides an example on how to query all metric import tasks that belong to the current Alibaba Cloud account. The returned result indicates that the current account has only one metric import task. The metric import task is named `aliyun_task`.
   * 
   * @param request - DescribeHybridMonitorTaskListRequest
   * @returns DescribeHybridMonitorTaskListResponse
   */
  async describeHybridMonitorTaskList(request: DescribeHybridMonitorTaskListRequest): Promise<DescribeHybridMonitorTaskListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeHybridMonitorTaskListWithOptions(request, runtime);
  }

  /**
   * Queries the details of a log monitoring metric.
   * 
   * @param request - DescribeLogMonitorAttributeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeLogMonitorAttributeResponse
   */
  async describeLogMonitorAttributeWithOptions(request: DescribeLogMonitorAttributeRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLogMonitorAttributeResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLogMonitorAttribute",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLogMonitorAttributeResponse>(await this.callApi(params, req, runtime), new DescribeLogMonitorAttributeResponse({}));
  }

  /**
   * Queries the details of a log monitoring metric.
   * 
   * @param request - DescribeLogMonitorAttributeRequest
   * @returns DescribeLogMonitorAttributeResponse
   */
  async describeLogMonitorAttribute(request: DescribeLogMonitorAttributeRequest): Promise<DescribeLogMonitorAttributeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLogMonitorAttributeWithOptions(request, runtime);
  }

  /**
   * Queries log monitoring metrics.
   * 
   * @param request - DescribeLogMonitorListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeLogMonitorListResponse
   */
  async describeLogMonitorListWithOptions(request: DescribeLogMonitorListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLogMonitorListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.searchValue)) {
      query["SearchValue"] = request.searchValue;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLogMonitorList",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLogMonitorListResponse>(await this.callApi(params, req, runtime), new DescribeLogMonitorListResponse({}));
  }

  /**
   * Queries log monitoring metrics.
   * 
   * @param request - DescribeLogMonitorListRequest
   * @returns DescribeLogMonitorListResponse
   */
  async describeLogMonitorList(request: DescribeLogMonitorListRequest): Promise<DescribeLogMonitorListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLogMonitorListWithOptions(request, runtime);
  }

  /**
   * Queries the monitoring data of a metric for a specified cloud service.
   * 
   * @remarks
   * ### [](#)Limits
   * Each API operation can be called up to 10 times per second. An Alibaba Cloud account and the RAM users within the account share the quota.
   * ### [](#)Description
   * >  Different from [DescribeMetricList](https://help.aliyun.com/document_detail/51936.html), the DescribeMetricData operation provides statistical features. You can set the Dimension parameter to `{"instanceId": "i-abcdefgh12****"}` to aggregate all data of your Alibaba Cloud account.
   * This topic provides an example to show how to query the monitoring data of the `cpu_idle` metric for Elastic Compute Service (ECS). The namespace of ECS is `acs_ecs_dashboard`.
   * 
   * @param request - DescribeMetricDataRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeMetricDataResponse
   */
  async describeMetricDataWithOptions(request: DescribeMetricDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeMetricDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dimensions)) {
      query["Dimensions"] = request.dimensions;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.express)) {
      query["Express"] = request.express;
    }

    if (!Util.isUnset(request.length)) {
      query["Length"] = request.length;
    }

    if (!Util.isUnset(request.metricName)) {
      query["MetricName"] = request.metricName;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.period)) {
      query["Period"] = request.period;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeMetricData",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeMetricDataResponse>(await this.callApi(params, req, runtime), new DescribeMetricDataResponse({}));
  }

  /**
   * Queries the monitoring data of a metric for a specified cloud service.
   * 
   * @remarks
   * ### [](#)Limits
   * Each API operation can be called up to 10 times per second. An Alibaba Cloud account and the RAM users within the account share the quota.
   * ### [](#)Description
   * >  Different from [DescribeMetricList](https://help.aliyun.com/document_detail/51936.html), the DescribeMetricData operation provides statistical features. You can set the Dimension parameter to `{"instanceId": "i-abcdefgh12****"}` to aggregate all data of your Alibaba Cloud account.
   * This topic provides an example to show how to query the monitoring data of the `cpu_idle` metric for Elastic Compute Service (ECS). The namespace of ECS is `acs_ecs_dashboard`.
   * 
   * @param request - DescribeMetricDataRequest
   * @returns DescribeMetricDataResponse
   */
  async describeMetricData(request: DescribeMetricDataRequest): Promise<DescribeMetricDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeMetricDataWithOptions(request, runtime);
  }

  /**
   * Queries the latest monitoring data of a metric.
   * 
   * @remarks
   * ### [](#)Limits
   * Each API operation can be called up to 50 times per second. An Alibaba Cloud account and the RAM users within the account share the quota.
   * >  If `Throttling.User` or `Request was denied due to user flow control` is returned when you call an API operation, the API operation is throttled. For more information about how to handle the issue, see [How do I handle the throttling of a query API?](https://help.aliyun.com/document_detail/2615031.html)
   * ### [](#)Precautions
   * The storage duration of the monitoring data of each cloud service is related to the `Period` parameter (statistical period). A larger value of the `Period` parameter indicates that the monitoring data is distributed in a larger time range and the storage duration of the monitoring data is longer. The following list describes the specific relationships:
   * *   If the value of the `Period` parameter is less than 60 seconds, the storage duration is seven days.
   * *   If the value of the `Period` parameter is 60 seconds, the storage duration is 31 days.
   * *   If the value of the `Period` parameter is 300 seconds, the storage duration is 91 days.
   * ### [](#)Description
   * This topic provides an example on how to query the latest monitoring data of the `CPUUtilization` metric for Elastic Compute Service (ECS). The namespace of ECS is `acs_ecs_dashboard`. The returned result indicates that the monitoring data for the instance `i-abcdefgh12****` of the account `123456789876****` is queried at an interval of 60 seconds. The maximum, minimum, and average values of the metric are 100, 93.1, and 99.52.
   * 
   * @param request - DescribeMetricLastRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeMetricLastResponse
   */
  async describeMetricLastWithOptions(request: DescribeMetricLastRequest, runtime: $Util.RuntimeOptions): Promise<DescribeMetricLastResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dimensions)) {
      query["Dimensions"] = request.dimensions;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.express)) {
      query["Express"] = request.express;
    }

    if (!Util.isUnset(request.length)) {
      query["Length"] = request.length;
    }

    if (!Util.isUnset(request.metricName)) {
      query["MetricName"] = request.metricName;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.period)) {
      query["Period"] = request.period;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeMetricLast",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeMetricLastResponse>(await this.callApi(params, req, runtime), new DescribeMetricLastResponse({}));
  }

  /**
   * Queries the latest monitoring data of a metric.
   * 
   * @remarks
   * ### [](#)Limits
   * Each API operation can be called up to 50 times per second. An Alibaba Cloud account and the RAM users within the account share the quota.
   * >  If `Throttling.User` or `Request was denied due to user flow control` is returned when you call an API operation, the API operation is throttled. For more information about how to handle the issue, see [How do I handle the throttling of a query API?](https://help.aliyun.com/document_detail/2615031.html)
   * ### [](#)Precautions
   * The storage duration of the monitoring data of each cloud service is related to the `Period` parameter (statistical period). A larger value of the `Period` parameter indicates that the monitoring data is distributed in a larger time range and the storage duration of the monitoring data is longer. The following list describes the specific relationships:
   * *   If the value of the `Period` parameter is less than 60 seconds, the storage duration is seven days.
   * *   If the value of the `Period` parameter is 60 seconds, the storage duration is 31 days.
   * *   If the value of the `Period` parameter is 300 seconds, the storage duration is 91 days.
   * ### [](#)Description
   * This topic provides an example on how to query the latest monitoring data of the `CPUUtilization` metric for Elastic Compute Service (ECS). The namespace of ECS is `acs_ecs_dashboard`. The returned result indicates that the monitoring data for the instance `i-abcdefgh12****` of the account `123456789876****` is queried at an interval of 60 seconds. The maximum, minimum, and average values of the metric are 100, 93.1, and 99.52.
   * 
   * @param request - DescribeMetricLastRequest
   * @returns DescribeMetricLastResponse
   */
  async describeMetricLast(request: DescribeMetricLastRequest): Promise<DescribeMetricLastResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeMetricLastWithOptions(request, runtime);
  }

  /**
   * Queries the monitoring data of a metric for a specified cloud service.
   * 
   * @remarks
   * ## Limits
   * Each API operation can be called up to 50 times per second. An Alibaba Cloud account and the RAM users within the account share the quota. 
   * >This topic provides an example to show how to query the monitoring data of the `cpu_idle` metric for Elastic Compute Service (ECS). The namespace of ECS is `acs_ecs_dashboard`. The returned result indicates that the monitoring data for the instance `i-abcdefgh12****` of the account `120886317861****` is queried at an interval of 60 seconds. The maximum, minimum, and average values of the metric are 100, 93.1, and 99.52.
   * 
   * @param request - DescribeMetricListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeMetricListResponse
   */
  async describeMetricListWithOptions(request: DescribeMetricListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeMetricListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dimensions)) {
      query["Dimensions"] = request.dimensions;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.express)) {
      query["Express"] = request.express;
    }

    if (!Util.isUnset(request.length)) {
      query["Length"] = request.length;
    }

    if (!Util.isUnset(request.metricName)) {
      query["MetricName"] = request.metricName;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.period)) {
      query["Period"] = request.period;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeMetricList",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeMetricListResponse>(await this.callApi(params, req, runtime), new DescribeMetricListResponse({}));
  }

  /**
   * Queries the monitoring data of a metric for a specified cloud service.
   * 
   * @remarks
   * ## Limits
   * Each API operation can be called up to 50 times per second. An Alibaba Cloud account and the RAM users within the account share the quota. 
   * >This topic provides an example to show how to query the monitoring data of the `cpu_idle` metric for Elastic Compute Service (ECS). The namespace of ECS is `acs_ecs_dashboard`. The returned result indicates that the monitoring data for the instance `i-abcdefgh12****` of the account `120886317861****` is queried at an interval of 60 seconds. The maximum, minimum, and average values of the metric are 100, 93.1, and 99.52.
   * 
   * @param request - DescribeMetricListRequest
   * @returns DescribeMetricListResponse
   */
  async describeMetricList(request: DescribeMetricListRequest): Promise<DescribeMetricListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeMetricListWithOptions(request, runtime);
  }

  /**
   * Queries the details of metrics that are supported in CloudMonitor.
   * 
   * @remarks
   * This operation is used together with DescribeMetricList and DescribeMetricLast. For more information, see [DescribeMetricList](https://help.aliyun.com/document_detail/51936.html) and [DescribeMetricLast](https://help.aliyun.com/document_detail/51939.html).
   * 
   * @param request - DescribeMetricMetaListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeMetricMetaListResponse
   */
  async describeMetricMetaListWithOptions(request: DescribeMetricMetaListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeMetricMetaListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.labels)) {
      query["Labels"] = request.labels;
    }

    if (!Util.isUnset(request.metricName)) {
      query["MetricName"] = request.metricName;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeMetricMetaList",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeMetricMetaListResponse>(await this.callApi(params, req, runtime), new DescribeMetricMetaListResponse({}));
  }

  /**
   * Queries the details of metrics that are supported in CloudMonitor.
   * 
   * @remarks
   * This operation is used together with DescribeMetricList and DescribeMetricLast. For more information, see [DescribeMetricList](https://help.aliyun.com/document_detail/51936.html) and [DescribeMetricLast](https://help.aliyun.com/document_detail/51939.html).
   * 
   * @param request - DescribeMetricMetaListRequest
   * @returns DescribeMetricMetaListResponse
   */
  async describeMetricMetaList(request: DescribeMetricMetaListRequest): Promise<DescribeMetricMetaListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeMetricMetaListWithOptions(request, runtime);
  }

  /**
   * @param request - DescribeMetricRuleBlackListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeMetricRuleBlackListResponse
   */
  async describeMetricRuleBlackListWithOptions(request: DescribeMetricRuleBlackListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeMetricRuleBlackListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.category)) {
      query["Category"] = request.category;
    }

    if (!Util.isUnset(request.ids)) {
      query["Ids"] = request.ids;
    }

    if (!Util.isUnset(request.instanceIds)) {
      query["InstanceIds"] = request.instanceIds;
    }

    if (!Util.isUnset(request.isEnable)) {
      query["IsEnable"] = request.isEnable;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.order)) {
      query["Order"] = request.order;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.scopeType)) {
      query["ScopeType"] = request.scopeType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeMetricRuleBlackList",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeMetricRuleBlackListResponse>(await this.callApi(params, req, runtime), new DescribeMetricRuleBlackListResponse({}));
  }

  /**
   * @param request - DescribeMetricRuleBlackListRequest
   * @returns DescribeMetricRuleBlackListResponse
   */
  async describeMetricRuleBlackList(request: DescribeMetricRuleBlackListRequest): Promise<DescribeMetricRuleBlackListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeMetricRuleBlackListWithOptions(request, runtime);
  }

  /**
   * Queries the number of alert rules in each state.
   * 
   * @param request - DescribeMetricRuleCountRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeMetricRuleCountResponse
   */
  async describeMetricRuleCountWithOptions(request: DescribeMetricRuleCountRequest, runtime: $Util.RuntimeOptions): Promise<DescribeMetricRuleCountResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeMetricRuleCount",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeMetricRuleCountResponse>(await this.callApi(params, req, runtime), new DescribeMetricRuleCountResponse({}));
  }

  /**
   * Queries the number of alert rules in each state.
   * 
   * @param request - DescribeMetricRuleCountRequest
   * @returns DescribeMetricRuleCountResponse
   */
  async describeMetricRuleCount(request: DescribeMetricRuleCountRequest): Promise<DescribeMetricRuleCountResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeMetricRuleCountWithOptions(request, runtime);
  }

  /**
   * Queries alert rules.
   * 
   * @remarks
   * This topic provides an example on how to query all alert rules within your Alibaba Cloud account. The returned result shows that only one alert rule is found. The name of the alert rule is `Rule_01` and the ID is `applyTemplate344cfd42-0f32-4fd6-805a-88d7908a****`.
   * 
   * @param request - DescribeMetricRuleListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeMetricRuleListResponse
   */
  async describeMetricRuleListWithOptions(request: DescribeMetricRuleListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeMetricRuleListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.alertState)) {
      query["AlertState"] = request.alertState;
    }

    if (!Util.isUnset(request.dimensions)) {
      query["Dimensions"] = request.dimensions;
    }

    if (!Util.isUnset(request.enableState)) {
      query["EnableState"] = request.enableState;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.metricName)) {
      query["MetricName"] = request.metricName;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.page)) {
      query["Page"] = request.page;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.ruleIds)) {
      query["RuleIds"] = request.ruleIds;
    }

    if (!Util.isUnset(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeMetricRuleList",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeMetricRuleListResponse>(await this.callApi(params, req, runtime), new DescribeMetricRuleListResponse({}));
  }

  /**
   * Queries alert rules.
   * 
   * @remarks
   * This topic provides an example on how to query all alert rules within your Alibaba Cloud account. The returned result shows that only one alert rule is found. The name of the alert rule is `Rule_01` and the ID is `applyTemplate344cfd42-0f32-4fd6-805a-88d7908a****`.
   * 
   * @param request - DescribeMetricRuleListRequest
   * @returns DescribeMetricRuleListResponse
   */
  async describeMetricRuleList(request: DescribeMetricRuleListRequest): Promise<DescribeMetricRuleListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeMetricRuleListWithOptions(request, runtime);
  }

  /**
   * Queries the resources that are associated with a specified alert rule.
   * 
   * @remarks
   * ## Limit
   * This operation supports only Message Service (MNS) resources. 
   * >This topic provides an example on how to query the resources that are associated with an alert rule whose ID is `ae06917_75a8c43178ab66****`.
   * 
   * @param request - DescribeMetricRuleTargetsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeMetricRuleTargetsResponse
   */
  async describeMetricRuleTargetsWithOptions(request: DescribeMetricRuleTargetsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeMetricRuleTargetsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeMetricRuleTargets",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeMetricRuleTargetsResponse>(await this.callApi(params, req, runtime), new DescribeMetricRuleTargetsResponse({}));
  }

  /**
   * Queries the resources that are associated with a specified alert rule.
   * 
   * @remarks
   * ## Limit
   * This operation supports only Message Service (MNS) resources. 
   * >This topic provides an example on how to query the resources that are associated with an alert rule whose ID is `ae06917_75a8c43178ab66****`.
   * 
   * @param request - DescribeMetricRuleTargetsRequest
   * @returns DescribeMetricRuleTargetsResponse
   */
  async describeMetricRuleTargets(request: DescribeMetricRuleTargetsRequest): Promise<DescribeMetricRuleTargetsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeMetricRuleTargetsWithOptions(request, runtime);
  }

  /**
   * Queries the details of an alert template.
   * 
   * @remarks
   * This topic provides an example on how to query the details of an alert template whose ID is `70****`.
   * 
   * @param request - DescribeMetricRuleTemplateAttributeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeMetricRuleTemplateAttributeResponse
   */
  async describeMetricRuleTemplateAttributeWithOptions(request: DescribeMetricRuleTemplateAttributeRequest, runtime: $Util.RuntimeOptions): Promise<DescribeMetricRuleTemplateAttributeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.templateId)) {
      query["TemplateId"] = request.templateId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeMetricRuleTemplateAttribute",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeMetricRuleTemplateAttributeResponse>(await this.callApi(params, req, runtime), new DescribeMetricRuleTemplateAttributeResponse({}));
  }

  /**
   * Queries the details of an alert template.
   * 
   * @remarks
   * This topic provides an example on how to query the details of an alert template whose ID is `70****`.
   * 
   * @param request - DescribeMetricRuleTemplateAttributeRequest
   * @returns DescribeMetricRuleTemplateAttributeResponse
   */
  async describeMetricRuleTemplateAttribute(request: DescribeMetricRuleTemplateAttributeRequest): Promise<DescribeMetricRuleTemplateAttributeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeMetricRuleTemplateAttributeWithOptions(request, runtime);
  }

  /**
   * Queries alert templates.
   * 
   * @remarks
   * This topic provides an example on how to query alert templates. In this example, the following alert templates are returned in the response: `ECS_Template1` and `ECS_Template2`.
   * 
   * @param request - DescribeMetricRuleTemplateListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeMetricRuleTemplateListResponse
   */
  async describeMetricRuleTemplateListWithOptions(request: DescribeMetricRuleTemplateListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeMetricRuleTemplateListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.history)) {
      query["History"] = request.history;
    }

    if (!Util.isUnset(request.keyword)) {
      query["Keyword"] = request.keyword;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.order)) {
      query["Order"] = request.order;
    }

    if (!Util.isUnset(request.orderBy)) {
      query["OrderBy"] = request.orderBy;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.templateId)) {
      query["TemplateId"] = request.templateId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeMetricRuleTemplateList",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeMetricRuleTemplateListResponse>(await this.callApi(params, req, runtime), new DescribeMetricRuleTemplateListResponse({}));
  }

  /**
   * Queries alert templates.
   * 
   * @remarks
   * This topic provides an example on how to query alert templates. In this example, the following alert templates are returned in the response: `ECS_Template1` and `ECS_Template2`.
   * 
   * @param request - DescribeMetricRuleTemplateListRequest
   * @returns DescribeMetricRuleTemplateListResponse
   */
  async describeMetricRuleTemplateList(request: DescribeMetricRuleTemplateListRequest): Promise<DescribeMetricRuleTemplateListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeMetricRuleTemplateListWithOptions(request, runtime);
  }

  /**
   * Queries the latest monitoring data of a metric for a cloud service. The data can be sorted by a specified order.
   * 
   * @remarks
   * ### [](#)Limits
   * Each API operation can be called up to 10 times per second. An Alibaba Cloud account and the RAM users within the account share the quota.
   * ### [](#)Precautions
   * The storage duration of the monitoring data of each cloud service is related to the `Period` parameter (statistical period). A larger value of the `Period` parameter indicates that the monitoring data is distributed in a larger time range and the storage duration of the monitoring data is longer. The following list describes the specific relationships:
   * *   If the value of the `Period` parameter is less than 60 seconds, the storage duration is seven days.
   * *   If the value of the `Period` parameter is 60 seconds, the storage duration is 31 days.
   * *   If the value of the `Period` parameter is 300 seconds, the storage duration is 91 days.
   * ### [](#)Description
   * This topic provides an example to show how to query the monitoring data of the `cpu_idle` metric in the last 60 seconds for Elastic Compute Service (ECS). The namespace of ECS is `acs_ecs_dashboard`. The monitoring data is sorted in the descending order based on the `Average` field.
   * 
   * @param request - DescribeMetricTopRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeMetricTopResponse
   */
  async describeMetricTopWithOptions(request: DescribeMetricTopRequest, runtime: $Util.RuntimeOptions): Promise<DescribeMetricTopResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dimensions)) {
      query["Dimensions"] = request.dimensions;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.express)) {
      query["Express"] = request.express;
    }

    if (!Util.isUnset(request.length)) {
      query["Length"] = request.length;
    }

    if (!Util.isUnset(request.metricName)) {
      query["MetricName"] = request.metricName;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.orderDesc)) {
      query["OrderDesc"] = request.orderDesc;
    }

    if (!Util.isUnset(request.orderby)) {
      query["Orderby"] = request.orderby;
    }

    if (!Util.isUnset(request.period)) {
      query["Period"] = request.period;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeMetricTop",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeMetricTopResponse>(await this.callApi(params, req, runtime), new DescribeMetricTopResponse({}));
  }

  /**
   * Queries the latest monitoring data of a metric for a cloud service. The data can be sorted by a specified order.
   * 
   * @remarks
   * ### [](#)Limits
   * Each API operation can be called up to 10 times per second. An Alibaba Cloud account and the RAM users within the account share the quota.
   * ### [](#)Precautions
   * The storage duration of the monitoring data of each cloud service is related to the `Period` parameter (statistical period). A larger value of the `Period` parameter indicates that the monitoring data is distributed in a larger time range and the storage duration of the monitoring data is longer. The following list describes the specific relationships:
   * *   If the value of the `Period` parameter is less than 60 seconds, the storage duration is seven days.
   * *   If the value of the `Period` parameter is 60 seconds, the storage duration is 31 days.
   * *   If the value of the `Period` parameter is 300 seconds, the storage duration is 91 days.
   * ### [](#)Description
   * This topic provides an example to show how to query the monitoring data of the `cpu_idle` metric in the last 60 seconds for Elastic Compute Service (ECS). The namespace of ECS is `acs_ecs_dashboard`. The monitoring data is sorted in the descending order based on the `Average` field.
   * 
   * @param request - DescribeMetricTopRequest
   * @returns DescribeMetricTopResponse
   */
  async describeMetricTop(request: DescribeMetricTopRequest): Promise<DescribeMetricTopResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeMetricTopWithOptions(request, runtime);
  }

  /**
   * Queries the cloud services to which the resources in an application group belong and the number of resources that belong to each cloud service in the application group.
   * 
   * @param request - DescribeMonitorGroupCategoriesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeMonitorGroupCategoriesResponse
   */
  async describeMonitorGroupCategoriesWithOptions(request: DescribeMonitorGroupCategoriesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeMonitorGroupCategoriesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeMonitorGroupCategories",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeMonitorGroupCategoriesResponse>(await this.callApi(params, req, runtime), new DescribeMonitorGroupCategoriesResponse({}));
  }

  /**
   * Queries the cloud services to which the resources in an application group belong and the number of resources that belong to each cloud service in the application group.
   * 
   * @param request - DescribeMonitorGroupCategoriesRequest
   * @returns DescribeMonitorGroupCategoriesResponse
   */
  async describeMonitorGroupCategories(request: DescribeMonitorGroupCategoriesRequest): Promise<DescribeMonitorGroupCategoriesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeMonitorGroupCategoriesWithOptions(request, runtime);
  }

  /**
   * Queries the dynamic rules of an application group.
   * 
   * @param request - DescribeMonitorGroupDynamicRulesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeMonitorGroupDynamicRulesResponse
   */
  async describeMonitorGroupDynamicRulesWithOptions(request: DescribeMonitorGroupDynamicRulesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeMonitorGroupDynamicRulesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeMonitorGroupDynamicRules",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeMonitorGroupDynamicRulesResponse>(await this.callApi(params, req, runtime), new DescribeMonitorGroupDynamicRulesResponse({}));
  }

  /**
   * Queries the dynamic rules of an application group.
   * 
   * @param request - DescribeMonitorGroupDynamicRulesRequest
   * @returns DescribeMonitorGroupDynamicRulesResponse
   */
  async describeMonitorGroupDynamicRules(request: DescribeMonitorGroupDynamicRulesRequest): Promise<DescribeMonitorGroupDynamicRulesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeMonitorGroupDynamicRulesWithOptions(request, runtime);
  }

  /**
   * Queries the details of the resources in an application group.
   * 
   * @param request - DescribeMonitorGroupInstanceAttributeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeMonitorGroupInstanceAttributeResponse
   */
  async describeMonitorGroupInstanceAttributeWithOptions(request: DescribeMonitorGroupInstanceAttributeRequest, runtime: $Util.RuntimeOptions): Promise<DescribeMonitorGroupInstanceAttributeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.category)) {
      query["Category"] = request.category;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.instanceIds)) {
      query["InstanceIds"] = request.instanceIds;
    }

    if (!Util.isUnset(request.keyword)) {
      query["Keyword"] = request.keyword;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.total)) {
      query["Total"] = request.total;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeMonitorGroupInstanceAttribute",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeMonitorGroupInstanceAttributeResponse>(await this.callApi(params, req, runtime), new DescribeMonitorGroupInstanceAttributeResponse({}));
  }

  /**
   * Queries the details of the resources in an application group.
   * 
   * @param request - DescribeMonitorGroupInstanceAttributeRequest
   * @returns DescribeMonitorGroupInstanceAttributeResponse
   */
  async describeMonitorGroupInstanceAttribute(request: DescribeMonitorGroupInstanceAttributeRequest): Promise<DescribeMonitorGroupInstanceAttributeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeMonitorGroupInstanceAttributeWithOptions(request, runtime);
  }

  /**
   * Queries the resources in an application group.
   * 
   * @param request - DescribeMonitorGroupInstancesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeMonitorGroupInstancesResponse
   */
  async describeMonitorGroupInstancesWithOptions(request: DescribeMonitorGroupInstancesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeMonitorGroupInstancesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.category)) {
      query["Category"] = request.category;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.instanceIds)) {
      query["InstanceIds"] = request.instanceIds;
    }

    if (!Util.isUnset(request.keyword)) {
      query["Keyword"] = request.keyword;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeMonitorGroupInstances",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeMonitorGroupInstancesResponse>(await this.callApi(params, req, runtime), new DescribeMonitorGroupInstancesResponse({}));
  }

  /**
   * Queries the resources in an application group.
   * 
   * @param request - DescribeMonitorGroupInstancesRequest
   * @returns DescribeMonitorGroupInstancesResponse
   */
  async describeMonitorGroupInstances(request: DescribeMonitorGroupInstancesRequest): Promise<DescribeMonitorGroupInstancesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeMonitorGroupInstancesWithOptions(request, runtime);
  }

  /**
   * Queries the policies that are used to pause alert notifications for an application group.
   * 
   * @param request - DescribeMonitorGroupNotifyPolicyListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeMonitorGroupNotifyPolicyListResponse
   */
  async describeMonitorGroupNotifyPolicyListWithOptions(request: DescribeMonitorGroupNotifyPolicyListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeMonitorGroupNotifyPolicyListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.policyType)) {
      query["PolicyType"] = request.policyType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeMonitorGroupNotifyPolicyList",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeMonitorGroupNotifyPolicyListResponse>(await this.callApi(params, req, runtime), new DescribeMonitorGroupNotifyPolicyListResponse({}));
  }

  /**
   * Queries the policies that are used to pause alert notifications for an application group.
   * 
   * @param request - DescribeMonitorGroupNotifyPolicyListRequest
   * @returns DescribeMonitorGroupNotifyPolicyListResponse
   */
  async describeMonitorGroupNotifyPolicyList(request: DescribeMonitorGroupNotifyPolicyListRequest): Promise<DescribeMonitorGroupNotifyPolicyListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeMonitorGroupNotifyPolicyListWithOptions(request, runtime);
  }

  /**
   * Queries application groups.
   * 
   * @remarks
   * This topic provides an example of how to query the application groups of the current account. The response shows that the current account has two application groups: `testGroup124` and `test123`.
   * 
   * @param request - DescribeMonitorGroupsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeMonitorGroupsResponse
   */
  async describeMonitorGroupsWithOptions(request: DescribeMonitorGroupsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeMonitorGroupsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dynamicTagRuleId)) {
      query["DynamicTagRuleId"] = request.dynamicTagRuleId;
    }

    if (!Util.isUnset(request.groupFounderTagKey)) {
      query["GroupFounderTagKey"] = request.groupFounderTagKey;
    }

    if (!Util.isUnset(request.groupFounderTagValue)) {
      query["GroupFounderTagValue"] = request.groupFounderTagValue;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.groupName)) {
      query["GroupName"] = request.groupName;
    }

    if (!Util.isUnset(request.includeTemplateHistory)) {
      query["IncludeTemplateHistory"] = request.includeTemplateHistory;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.keyword)) {
      query["Keyword"] = request.keyword;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.selectContactGroups)) {
      query["SelectContactGroups"] = request.selectContactGroups;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    if (!Util.isUnset(request.types)) {
      query["Types"] = request.types;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeMonitorGroups",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeMonitorGroupsResponse>(await this.callApi(params, req, runtime), new DescribeMonitorGroupsResponse({}));
  }

  /**
   * Queries application groups.
   * 
   * @remarks
   * This topic provides an example of how to query the application groups of the current account. The response shows that the current account has two application groups: `testGroup124` and `test123`.
   * 
   * @param request - DescribeMonitorGroupsRequest
   * @returns DescribeMonitorGroupsResponse
   */
  async describeMonitorGroups(request: DescribeMonitorGroupsRequest): Promise<DescribeMonitorGroupsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeMonitorGroupsWithOptions(request, runtime);
  }

  /**
   * Queries the resource quotas of CloudMonitor.
   * 
   * @param request - DescribeMonitorResourceQuotaAttributeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeMonitorResourceQuotaAttributeResponse
   */
  async describeMonitorResourceQuotaAttributeWithOptions(request: DescribeMonitorResourceQuotaAttributeRequest, runtime: $Util.RuntimeOptions): Promise<DescribeMonitorResourceQuotaAttributeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.showUsed)) {
      query["ShowUsed"] = request.showUsed;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeMonitorResourceQuotaAttribute",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeMonitorResourceQuotaAttributeResponse>(await this.callApi(params, req, runtime), new DescribeMonitorResourceQuotaAttributeResponse({}));
  }

  /**
   * Queries the resource quotas of CloudMonitor.
   * 
   * @param request - DescribeMonitorResourceQuotaAttributeRequest
   * @returns DescribeMonitorResourceQuotaAttributeResponse
   */
  async describeMonitorResourceQuotaAttribute(request: DescribeMonitorResourceQuotaAttributeRequest): Promise<DescribeMonitorResourceQuotaAttributeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeMonitorResourceQuotaAttributeWithOptions(request, runtime);
  }

  /**
   * Queries the AccessKey ID and AccessKey secret that are required to install the CloudMonitor agent on a third-party host.
   * 
   * @param request - DescribeMonitoringAgentAccessKeyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeMonitoringAgentAccessKeyResponse
   */
  async describeMonitoringAgentAccessKeyWithOptions(request: DescribeMonitoringAgentAccessKeyRequest, runtime: $Util.RuntimeOptions): Promise<DescribeMonitoringAgentAccessKeyResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeMonitoringAgentAccessKey",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeMonitoringAgentAccessKeyResponse>(await this.callApi(params, req, runtime), new DescribeMonitoringAgentAccessKeyResponse({}));
  }

  /**
   * Queries the AccessKey ID and AccessKey secret that are required to install the CloudMonitor agent on a third-party host.
   * 
   * @param request - DescribeMonitoringAgentAccessKeyRequest
   * @returns DescribeMonitoringAgentAccessKeyResponse
   */
  async describeMonitoringAgentAccessKey(request: DescribeMonitoringAgentAccessKeyRequest): Promise<DescribeMonitoringAgentAccessKeyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeMonitoringAgentAccessKeyWithOptions(request, runtime);
  }

  /**
   * @param request - DescribeMonitoringAgentConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeMonitoringAgentConfigResponse
   */
  async describeMonitoringAgentConfigWithOptions(request: DescribeMonitoringAgentConfigRequest, runtime: $Util.RuntimeOptions): Promise<DescribeMonitoringAgentConfigResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeMonitoringAgentConfig",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeMonitoringAgentConfigResponse>(await this.callApi(params, req, runtime), new DescribeMonitoringAgentConfigResponse({}));
  }

  /**
   * @param request - DescribeMonitoringAgentConfigRequest
   * @returns DescribeMonitoringAgentConfigResponse
   */
  async describeMonitoringAgentConfig(request: DescribeMonitoringAgentConfigRequest): Promise<DescribeMonitoringAgentConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeMonitoringAgentConfigWithOptions(request, runtime);
  }

  /**
   * Queries all hosts within the current Alibaba Cloud account, including hosts on which the CloudMonitor agent is installed and uninstalled.
   * 
   * @param request - DescribeMonitoringAgentHostsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeMonitoringAgentHostsResponse
   */
  async describeMonitoringAgentHostsWithOptions(request: DescribeMonitoringAgentHostsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeMonitoringAgentHostsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.aliyunHost)) {
      query["AliyunHost"] = request.aliyunHost;
    }

    if (!Util.isUnset(request.hostName)) {
      query["HostName"] = request.hostName;
    }

    if (!Util.isUnset(request.instanceIds)) {
      query["InstanceIds"] = request.instanceIds;
    }

    if (!Util.isUnset(request.instanceRegionId)) {
      query["InstanceRegionId"] = request.instanceRegionId;
    }

    if (!Util.isUnset(request.keyWord)) {
      query["KeyWord"] = request.keyWord;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.serialNumbers)) {
      query["SerialNumbers"] = request.serialNumbers;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    if (!Util.isUnset(request.sysomStatus)) {
      query["SysomStatus"] = request.sysomStatus;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeMonitoringAgentHosts",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeMonitoringAgentHostsResponse>(await this.callApi(params, req, runtime), new DescribeMonitoringAgentHostsResponse({}));
  }

  /**
   * Queries all hosts within the current Alibaba Cloud account, including hosts on which the CloudMonitor agent is installed and uninstalled.
   * 
   * @param request - DescribeMonitoringAgentHostsRequest
   * @returns DescribeMonitoringAgentHostsResponse
   */
  async describeMonitoringAgentHosts(request: DescribeMonitoringAgentHostsRequest): Promise<DescribeMonitoringAgentHostsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeMonitoringAgentHostsWithOptions(request, runtime);
  }

  /**
   * @remarks
   * >  Before you call this operation, call the CreateMonitoringAgentProcess operation to create processes. For more information, see [CreateMonitoringAgentProcess](https://help.aliyun.com/document_detail/114951.html~).
   * This topic provides an example of how to query the processes of the `i-hp3hl3cx1pbahzy8****` instance. The response indicates the details of the `NGINX` and `HTTP` processes.
   * 
   * @param request - DescribeMonitoringAgentProcessesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeMonitoringAgentProcessesResponse
   */
  async describeMonitoringAgentProcessesWithOptions(request: DescribeMonitoringAgentProcessesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeMonitoringAgentProcessesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeMonitoringAgentProcesses",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeMonitoringAgentProcessesResponse>(await this.callApi(params, req, runtime), new DescribeMonitoringAgentProcessesResponse({}));
  }

  /**
   * @remarks
   * >  Before you call this operation, call the CreateMonitoringAgentProcess operation to create processes. For more information, see [CreateMonitoringAgentProcess](https://help.aliyun.com/document_detail/114951.html~).
   * This topic provides an example of how to query the processes of the `i-hp3hl3cx1pbahzy8****` instance. The response indicates the details of the `NGINX` and `HTTP` processes.
   * 
   * @param request - DescribeMonitoringAgentProcessesRequest
   * @returns DescribeMonitoringAgentProcessesResponse
   */
  async describeMonitoringAgentProcesses(request: DescribeMonitoringAgentProcessesRequest): Promise<DescribeMonitoringAgentProcessesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeMonitoringAgentProcessesWithOptions(request, runtime);
  }

  /**
   * Queries the status of the CloudMonitor agent.
   * 
   * @remarks
   * This topic describes how to query the status of the CloudMonitor agent that is installed on the `i-hp3dunahluwajv6f****` instance. The result indicates that the CloudMonitor agent is in the `running` state.
   * 
   * @param request - DescribeMonitoringAgentStatusesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeMonitoringAgentStatusesResponse
   */
  async describeMonitoringAgentStatusesWithOptions(request: DescribeMonitoringAgentStatusesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeMonitoringAgentStatusesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.hostAvailabilityTaskId)) {
      query["HostAvailabilityTaskId"] = request.hostAvailabilityTaskId;
    }

    if (!Util.isUnset(request.instanceIds)) {
      query["InstanceIds"] = request.instanceIds;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeMonitoringAgentStatuses",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeMonitoringAgentStatusesResponse>(await this.callApi(params, req, runtime), new DescribeMonitoringAgentStatusesResponse({}));
  }

  /**
   * Queries the status of the CloudMonitor agent.
   * 
   * @remarks
   * This topic describes how to query the status of the CloudMonitor agent that is installed on the `i-hp3dunahluwajv6f****` instance. The result indicates that the CloudMonitor agent is in the `running` state.
   * 
   * @param request - DescribeMonitoringAgentStatusesRequest
   * @returns DescribeMonitoringAgentStatusesResponse
   */
  async describeMonitoringAgentStatuses(request: DescribeMonitoringAgentStatusesRequest): Promise<DescribeMonitoringAgentStatusesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeMonitoringAgentStatusesWithOptions(request, runtime);
  }

  /**
   * @param request - DescribeMonitoringConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeMonitoringConfigResponse
   */
  async describeMonitoringConfigWithOptions(request: DescribeMonitoringConfigRequest, runtime: $Util.RuntimeOptions): Promise<DescribeMonitoringConfigResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeMonitoringConfig",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeMonitoringConfigResponse>(await this.callApi(params, req, runtime), new DescribeMonitoringConfigResponse({}));
  }

  /**
   * @param request - DescribeMonitoringConfigRequest
   * @returns DescribeMonitoringConfigResponse
   */
  async describeMonitoringConfig(request: DescribeMonitoringConfigRequest): Promise<DescribeMonitoringConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeMonitoringConfigWithOptions(request, runtime);
  }

  /**
   * @remarks
   * >  If a tag is attached to multiple cloud resources in the region, the key of the tag is returned only once.
   * 
   * @param request - DescribeProductResourceTagKeyListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeProductResourceTagKeyListResponse
   */
  async describeProductResourceTagKeyListWithOptions(request: DescribeProductResourceTagKeyListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeProductResourceTagKeyListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeProductResourceTagKeyList",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeProductResourceTagKeyListResponse>(await this.callApi(params, req, runtime), new DescribeProductResourceTagKeyListResponse({}));
  }

  /**
   * @remarks
   * >  If a tag is attached to multiple cloud resources in the region, the key of the tag is returned only once.
   * 
   * @param request - DescribeProductResourceTagKeyListRequest
   * @returns DescribeProductResourceTagKeyListResponse
   */
  async describeProductResourceTagKeyList(request: DescribeProductResourceTagKeyListRequest): Promise<DescribeProductResourceTagKeyListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeProductResourceTagKeyListWithOptions(request, runtime);
  }

  /**
   * Queries the cloud services for which the initiative alert feature is enabled.
   * 
   * @param request - DescribeProductsOfActiveMetricRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeProductsOfActiveMetricRuleResponse
   */
  async describeProductsOfActiveMetricRuleWithOptions(request: DescribeProductsOfActiveMetricRuleRequest, runtime: $Util.RuntimeOptions): Promise<DescribeProductsOfActiveMetricRuleResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeProductsOfActiveMetricRule",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeProductsOfActiveMetricRuleResponse>(await this.callApi(params, req, runtime), new DescribeProductsOfActiveMetricRuleResponse({}));
  }

  /**
   * Queries the cloud services for which the initiative alert feature is enabled.
   * 
   * @param request - DescribeProductsOfActiveMetricRuleRequest
   * @returns DescribeProductsOfActiveMetricRuleResponse
   */
  async describeProductsOfActiveMetricRule(request: DescribeProductsOfActiveMetricRuleRequest): Promise<DescribeProductsOfActiveMetricRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeProductsOfActiveMetricRuleWithOptions(request, runtime);
  }

  /**
   * Queries the information about monitored services in CloudMonitor.
   * 
   * @remarks
   * The information obtained by this operation includes the service description, namespace, and tags.
   * 
   * @param request - DescribeProjectMetaRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeProjectMetaResponse
   */
  async describeProjectMetaWithOptions(request: DescribeProjectMetaRequest, runtime: $Util.RuntimeOptions): Promise<DescribeProjectMetaResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.labels)) {
      query["Labels"] = request.labels;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeProjectMeta",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeProjectMetaResponse>(await this.callApi(params, req, runtime), new DescribeProjectMetaResponse({}));
  }

  /**
   * Queries the information about monitored services in CloudMonitor.
   * 
   * @remarks
   * The information obtained by this operation includes the service description, namespace, and tags.
   * 
   * @param request - DescribeProjectMetaRequest
   * @returns DescribeProjectMetaResponse
   */
  async describeProjectMeta(request: DescribeProjectMetaRequest): Promise<DescribeProjectMetaResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeProjectMetaWithOptions(request, runtime);
  }

  /**
   * Queries the details of a site monitoring task.
   * 
   * @remarks
   * This topic provides an example on how to query the details of a site monitoring task whose ID is `cc641dff-c19d-45f3-ad0a-818a0c4f****`. The returned result indicates that the task name is `test123`, the URL that is monitored by the task is `https://aliyun.com`, and the name of the carrier is `Alibaba`.
   * 
   * @param request - DescribeSiteMonitorAttributeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeSiteMonitorAttributeResponse
   */
  async describeSiteMonitorAttributeWithOptions(request: DescribeSiteMonitorAttributeRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSiteMonitorAttributeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.includeAlert)) {
      query["IncludeAlert"] = request.includeAlert;
    }

    if (!Util.isUnset(request.taskId)) {
      query["TaskId"] = request.taskId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeSiteMonitorAttribute",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSiteMonitorAttributeResponse>(await this.callApi(params, req, runtime), new DescribeSiteMonitorAttributeResponse({}));
  }

  /**
   * Queries the details of a site monitoring task.
   * 
   * @remarks
   * This topic provides an example on how to query the details of a site monitoring task whose ID is `cc641dff-c19d-45f3-ad0a-818a0c4f****`. The returned result indicates that the task name is `test123`, the URL that is monitored by the task is `https://aliyun.com`, and the name of the carrier is `Alibaba`.
   * 
   * @param request - DescribeSiteMonitorAttributeRequest
   * @returns DescribeSiteMonitorAttributeResponse
   */
  async describeSiteMonitorAttribute(request: DescribeSiteMonitorAttributeRequest): Promise<DescribeSiteMonitorAttributeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSiteMonitorAttributeWithOptions(request, runtime);
  }

  /**
   * @param request - DescribeSiteMonitorDataRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeSiteMonitorDataResponse
   */
  async describeSiteMonitorDataWithOptions(request: DescribeSiteMonitorDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSiteMonitorDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.length)) {
      query["Length"] = request.length;
    }

    if (!Util.isUnset(request.metricName)) {
      query["MetricName"] = request.metricName;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.period)) {
      query["Period"] = request.period;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.taskId)) {
      query["TaskId"] = request.taskId;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeSiteMonitorData",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSiteMonitorDataResponse>(await this.callApi(params, req, runtime), new DescribeSiteMonitorDataResponse({}));
  }

  /**
   * @param request - DescribeSiteMonitorDataRequest
   * @returns DescribeSiteMonitorDataResponse
   */
  async describeSiteMonitorData(request: DescribeSiteMonitorDataRequest): Promise<DescribeSiteMonitorDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSiteMonitorDataWithOptions(request, runtime);
  }

  /**
   * Queries the detection points that are provided by carriers.
   * 
   * @remarks
   * This topic provides an example on how to query the detection points that are provided by China Unicom in Guiyang.
   * 
   * @param request - DescribeSiteMonitorISPCityListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeSiteMonitorISPCityListResponse
   */
  async describeSiteMonitorISPCityListWithOptions(request: DescribeSiteMonitorISPCityListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSiteMonitorISPCityListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.city)) {
      query["City"] = request.city;
    }

    if (!Util.isUnset(request.IPV4)) {
      query["IPV4"] = request.IPV4;
    }

    if (!Util.isUnset(request.IPV6)) {
      query["IPV6"] = request.IPV6;
    }

    if (!Util.isUnset(request.isp)) {
      query["Isp"] = request.isp;
    }

    if (!Util.isUnset(request.viewAll)) {
      query["ViewAll"] = request.viewAll;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeSiteMonitorISPCityList",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSiteMonitorISPCityListResponse>(await this.callApi(params, req, runtime), new DescribeSiteMonitorISPCityListResponse({}));
  }

  /**
   * Queries the detection points that are provided by carriers.
   * 
   * @remarks
   * This topic provides an example on how to query the detection points that are provided by China Unicom in Guiyang.
   * 
   * @param request - DescribeSiteMonitorISPCityListRequest
   * @returns DescribeSiteMonitorISPCityListResponse
   */
  async describeSiteMonitorISPCityList(request: DescribeSiteMonitorISPCityListRequest): Promise<DescribeSiteMonitorISPCityListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSiteMonitorISPCityListWithOptions(request, runtime);
  }

  /**
   * Queries site monitoring tasks.
   * 
   * @remarks
   * This topic provides an example on how to query all the site monitoring tasks of your Alibaba Cloud account. In this example, the returned result indicates that the Alibaba Cloud account has one site monitoring task named `HanZhou_ECS2`.
   * 
   * @param request - DescribeSiteMonitorListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeSiteMonitorListResponse
   */
  async describeSiteMonitorListWithOptions(request: DescribeSiteMonitorListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSiteMonitorListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.keyword)) {
      query["Keyword"] = request.keyword;
    }

    if (!Util.isUnset(request.page)) {
      query["Page"] = request.page;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.taskId)) {
      query["TaskId"] = request.taskId;
    }

    if (!Util.isUnset(request.taskState)) {
      query["TaskState"] = request.taskState;
    }

    if (!Util.isUnset(request.taskType)) {
      query["TaskType"] = request.taskType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeSiteMonitorList",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSiteMonitorListResponse>(await this.callApi(params, req, runtime), new DescribeSiteMonitorListResponse({}));
  }

  /**
   * Queries site monitoring tasks.
   * 
   * @remarks
   * This topic provides an example on how to query all the site monitoring tasks of your Alibaba Cloud account. In this example, the returned result indicates that the Alibaba Cloud account has one site monitoring task named `HanZhou_ECS2`.
   * 
   * @param request - DescribeSiteMonitorListRequest
   * @returns DescribeSiteMonitorListResponse
   */
  async describeSiteMonitorList(request: DescribeSiteMonitorListRequest): Promise<DescribeSiteMonitorListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSiteMonitorListWithOptions(request, runtime);
  }

  /**
   * Queries the logs of one or more instant test tasks.
   * 
   * @remarks
   * You can create an instant test task only by using the Alibaba Cloud account that you used to enable Network Analysis and Monitoring.
   * This topic provides an example to show how to query the logs of an instant test task whose ID is `afa5c3ce-f944-4363-9edb-ce919a29****`.
   * 
   * @param request - DescribeSiteMonitorLogRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeSiteMonitorLogResponse
   */
  async describeSiteMonitorLogWithOptions(request: DescribeSiteMonitorLogRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSiteMonitorLogResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.browser)) {
      query["Browser"] = request.browser;
    }

    if (!Util.isUnset(request.browserInfo)) {
      query["BrowserInfo"] = request.browserInfo;
    }

    if (!Util.isUnset(request.city)) {
      query["City"] = request.city;
    }

    if (!Util.isUnset(request.device)) {
      query["Device"] = request.device;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.filter)) {
      query["Filter"] = request.filter;
    }

    if (!Util.isUnset(request.isp)) {
      query["Isp"] = request.isp;
    }

    if (!Util.isUnset(request.length)) {
      query["Length"] = request.length;
    }

    if (!Util.isUnset(request.metricName)) {
      query["MetricName"] = request.metricName;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.taskIds)) {
      query["TaskIds"] = request.taskIds;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeSiteMonitorLog",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSiteMonitorLogResponse>(await this.callApi(params, req, runtime), new DescribeSiteMonitorLogResponse({}));
  }

  /**
   * Queries the logs of one or more instant test tasks.
   * 
   * @remarks
   * You can create an instant test task only by using the Alibaba Cloud account that you used to enable Network Analysis and Monitoring.
   * This topic provides an example to show how to query the logs of an instant test task whose ID is `afa5c3ce-f944-4363-9edb-ce919a29****`.
   * 
   * @param request - DescribeSiteMonitorLogRequest
   * @returns DescribeSiteMonitorLogResponse
   */
  async describeSiteMonitorLog(request: DescribeSiteMonitorLogRequest): Promise<DescribeSiteMonitorLogResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSiteMonitorLogWithOptions(request, runtime);
  }

  /**
   * @param request - DescribeSiteMonitorQuotaRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeSiteMonitorQuotaResponse
   */
  async describeSiteMonitorQuotaWithOptions(request: DescribeSiteMonitorQuotaRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSiteMonitorQuotaResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeSiteMonitorQuota",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSiteMonitorQuotaResponse>(await this.callApi(params, req, runtime), new DescribeSiteMonitorQuotaResponse({}));
  }

  /**
   * @param request - DescribeSiteMonitorQuotaRequest
   * @returns DescribeSiteMonitorQuotaResponse
   */
  async describeSiteMonitorQuota(request: DescribeSiteMonitorQuotaRequest): Promise<DescribeSiteMonitorQuotaResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSiteMonitorQuotaWithOptions(request, runtime);
  }

  /**
   * @remarks
   * This topic provides an example to show how to query the statistics of the `Availability` metric for a site monitoring task whose ID is `ef4cdc8b-9dc7-43e7-810e-f950e56c****`. The result indicates that the availability rate of the site is `100%`.
   * 
   * @param request - DescribeSiteMonitorStatisticsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeSiteMonitorStatisticsResponse
   */
  async describeSiteMonitorStatisticsWithOptions(request: DescribeSiteMonitorStatisticsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSiteMonitorStatisticsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.metricName)) {
      query["MetricName"] = request.metricName;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.taskId)) {
      query["TaskId"] = request.taskId;
    }

    if (!Util.isUnset(request.timeRange)) {
      query["TimeRange"] = request.timeRange;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeSiteMonitorStatistics",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSiteMonitorStatisticsResponse>(await this.callApi(params, req, runtime), new DescribeSiteMonitorStatisticsResponse({}));
  }

  /**
   * @remarks
   * This topic provides an example to show how to query the statistics of the `Availability` metric for a site monitoring task whose ID is `ef4cdc8b-9dc7-43e7-810e-f950e56c****`. The result indicates that the availability rate of the site is `100%`.
   * 
   * @param request - DescribeSiteMonitorStatisticsRequest
   * @returns DescribeSiteMonitorStatisticsResponse
   */
  async describeSiteMonitorStatistics(request: DescribeSiteMonitorStatisticsRequest): Promise<DescribeSiteMonitorStatisticsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSiteMonitorStatisticsWithOptions(request, runtime);
  }

  /**
   * Queries the details of a system event.
   * 
   * @param request - DescribeSystemEventAttributeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeSystemEventAttributeResponse
   */
  async describeSystemEventAttributeWithOptions(request: DescribeSystemEventAttributeRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSystemEventAttributeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.eventType)) {
      query["EventType"] = request.eventType;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.level)) {
      query["Level"] = request.level;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.product)) {
      query["Product"] = request.product;
    }

    if (!Util.isUnset(request.searchKeywords)) {
      query["SearchKeywords"] = request.searchKeywords;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeSystemEventAttribute",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSystemEventAttributeResponse>(await this.callApi(params, req, runtime), new DescribeSystemEventAttributeResponse({}));
  }

  /**
   * Queries the details of a system event.
   * 
   * @param request - DescribeSystemEventAttributeRequest
   * @returns DescribeSystemEventAttributeResponse
   */
  async describeSystemEventAttribute(request: DescribeSystemEventAttributeRequest): Promise<DescribeSystemEventAttributeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSystemEventAttributeWithOptions(request, runtime);
  }

  /**
   * Queries the number of times that a system event of a cloud service has occurred.
   * 
   * @remarks
   * ### [](#)Background information
   * You can call the [DescribeSystemEventMetaList](https://help.aliyun.com/document_detail/114972.html) operation to query the cloud services supported by CloudMonitor and their system events.
   * ### [](#)Description
   * This topic provides an example on how to query the number of times that a system event of `Elastic Compute Service (ECS)` has occurred. The returned result shows that the specified system event has occurred three times.
   * 
   * @param request - DescribeSystemEventCountRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeSystemEventCountResponse
   */
  async describeSystemEventCountWithOptions(request: DescribeSystemEventCountRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSystemEventCountResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.eventType)) {
      query["EventType"] = request.eventType;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.level)) {
      query["Level"] = request.level;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.product)) {
      query["Product"] = request.product;
    }

    if (!Util.isUnset(request.searchKeywords)) {
      query["SearchKeywords"] = request.searchKeywords;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeSystemEventCount",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSystemEventCountResponse>(await this.callApi(params, req, runtime), new DescribeSystemEventCountResponse({}));
  }

  /**
   * Queries the number of times that a system event of a cloud service has occurred.
   * 
   * @remarks
   * ### [](#)Background information
   * You can call the [DescribeSystemEventMetaList](https://help.aliyun.com/document_detail/114972.html) operation to query the cloud services supported by CloudMonitor and their system events.
   * ### [](#)Description
   * This topic provides an example on how to query the number of times that a system event of `Elastic Compute Service (ECS)` has occurred. The returned result shows that the specified system event has occurred three times.
   * 
   * @param request - DescribeSystemEventCountRequest
   * @returns DescribeSystemEventCountResponse
   */
  async describeSystemEventCount(request: DescribeSystemEventCountRequest): Promise<DescribeSystemEventCountResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSystemEventCountWithOptions(request, runtime);
  }

  /**
   * Queries the number of times a system event occurred during each interval within a period of time.
   * 
   * @param request - DescribeSystemEventHistogramRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeSystemEventHistogramResponse
   */
  async describeSystemEventHistogramWithOptions(request: DescribeSystemEventHistogramRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSystemEventHistogramResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.eventType)) {
      query["EventType"] = request.eventType;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.level)) {
      query["Level"] = request.level;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.product)) {
      query["Product"] = request.product;
    }

    if (!Util.isUnset(request.searchKeywords)) {
      query["SearchKeywords"] = request.searchKeywords;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeSystemEventHistogram",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSystemEventHistogramResponse>(await this.callApi(params, req, runtime), new DescribeSystemEventHistogramResponse({}));
  }

  /**
   * Queries the number of times a system event occurred during each interval within a period of time.
   * 
   * @param request - DescribeSystemEventHistogramRequest
   * @returns DescribeSystemEventHistogramResponse
   */
  async describeSystemEventHistogram(request: DescribeSystemEventHistogramRequest): Promise<DescribeSystemEventHistogramResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSystemEventHistogramWithOptions(request, runtime);
  }

  /**
   * @param request - DescribeSystemEventMetaListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeSystemEventMetaListResponse
   */
  async describeSystemEventMetaListWithOptions(request: DescribeSystemEventMetaListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSystemEventMetaListResponse> {
    Util.validateModel(request);
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeSystemEventMetaList",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSystemEventMetaListResponse>(await this.callApi(params, req, runtime), new DescribeSystemEventMetaListResponse({}));
  }

  /**
   * @param request - DescribeSystemEventMetaListRequest
   * @returns DescribeSystemEventMetaListResponse
   */
  async describeSystemEventMetaList(request: DescribeSystemEventMetaListRequest): Promise<DescribeSystemEventMetaListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSystemEventMetaListWithOptions(request, runtime);
  }

  /**
   * @param request - DescribeTagKeyListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeTagKeyListResponse
   */
  async describeTagKeyListWithOptions(request: DescribeTagKeyListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeTagKeyListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeTagKeyList",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeTagKeyListResponse>(await this.callApi(params, req, runtime), new DescribeTagKeyListResponse({}));
  }

  /**
   * @param request - DescribeTagKeyListRequest
   * @returns DescribeTagKeyListResponse
   */
  async describeTagKeyList(request: DescribeTagKeyListRequest): Promise<DescribeTagKeyListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeTagKeyListWithOptions(request, runtime);
  }

  /**
   * @remarks
   * This topic provides an example of how to query the tag values corresponding to `tagKey1`. The return results are `tagValue1` and `tagValue2`.
   * 
   * @param request - DescribeTagValueListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeTagValueListResponse
   */
  async describeTagValueListWithOptions(request: DescribeTagValueListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeTagValueListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.tagKey)) {
      query["TagKey"] = request.tagKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeTagValueList",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeTagValueListResponse>(await this.callApi(params, req, runtime), new DescribeTagValueListResponse({}));
  }

  /**
   * @remarks
   * This topic provides an example of how to query the tag values corresponding to `tagKey1`. The return results are `tagValue1` and `tagValue2`.
   * 
   * @param request - DescribeTagValueListRequest
   * @returns DescribeTagValueListResponse
   */
  async describeTagValueList(request: DescribeTagValueListRequest): Promise<DescribeTagValueListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeTagValueListWithOptions(request, runtime);
  }

  /**
   * @param request - DescribeUnhealthyHostAvailabilityRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeUnhealthyHostAvailabilityResponse
   */
  async describeUnhealthyHostAvailabilityWithOptions(request: DescribeUnhealthyHostAvailabilityRequest, runtime: $Util.RuntimeOptions): Promise<DescribeUnhealthyHostAvailabilityResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeUnhealthyHostAvailability",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeUnhealthyHostAvailabilityResponse>(await this.callApi(params, req, runtime), new DescribeUnhealthyHostAvailabilityResponse({}));
  }

  /**
   * @param request - DescribeUnhealthyHostAvailabilityRequest
   * @returns DescribeUnhealthyHostAvailabilityResponse
   */
  async describeUnhealthyHostAvailability(request: DescribeUnhealthyHostAvailabilityRequest): Promise<DescribeUnhealthyHostAvailabilityResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeUnhealthyHostAvailabilityWithOptions(request, runtime);
  }

  /**
   * @param request - DisableActiveMetricRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DisableActiveMetricRuleResponse
   */
  async disableActiveMetricRuleWithOptions(request: DisableActiveMetricRuleRequest, runtime: $Util.RuntimeOptions): Promise<DisableActiveMetricRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.product)) {
      query["Product"] = request.product;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DisableActiveMetricRule",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DisableActiveMetricRuleResponse>(await this.callApi(params, req, runtime), new DisableActiveMetricRuleResponse({}));
  }

  /**
   * @param request - DisableActiveMetricRuleRequest
   * @returns DisableActiveMetricRuleResponse
   */
  async disableActiveMetricRule(request: DisableActiveMetricRuleRequest): Promise<DisableActiveMetricRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.disableActiveMetricRuleWithOptions(request, runtime);
  }

  /**
   * @param request - DisableEventRulesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DisableEventRulesResponse
   */
  async disableEventRulesWithOptions(request: DisableEventRulesRequest, runtime: $Util.RuntimeOptions): Promise<DisableEventRulesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ruleNames)) {
      query["RuleNames"] = request.ruleNames;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DisableEventRules",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DisableEventRulesResponse>(await this.callApi(params, req, runtime), new DisableEventRulesResponse({}));
  }

  /**
   * @param request - DisableEventRulesRequest
   * @returns DisableEventRulesResponse
   */
  async disableEventRules(request: DisableEventRulesRequest): Promise<DisableEventRulesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.disableEventRulesWithOptions(request, runtime);
  }

  /**
   * @param request - DisableHostAvailabilityRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DisableHostAvailabilityResponse
   */
  async disableHostAvailabilityWithOptions(request: DisableHostAvailabilityRequest, runtime: $Util.RuntimeOptions): Promise<DisableHostAvailabilityResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DisableHostAvailability",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DisableHostAvailabilityResponse>(await this.callApi(params, req, runtime), new DisableHostAvailabilityResponse({}));
  }

  /**
   * @param request - DisableHostAvailabilityRequest
   * @returns DisableHostAvailabilityResponse
   */
  async disableHostAvailability(request: DisableHostAvailabilityRequest): Promise<DisableHostAvailabilityResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.disableHostAvailabilityWithOptions(request, runtime);
  }

  /**
   * @param request - DisableMetricRulesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DisableMetricRulesResponse
   */
  async disableMetricRulesWithOptions(request: DisableMetricRulesRequest, runtime: $Util.RuntimeOptions): Promise<DisableMetricRulesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DisableMetricRules",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DisableMetricRulesResponse>(await this.callApi(params, req, runtime), new DisableMetricRulesResponse({}));
  }

  /**
   * @param request - DisableMetricRulesRequest
   * @returns DisableMetricRulesResponse
   */
  async disableMetricRules(request: DisableMetricRulesRequest): Promise<DisableMetricRulesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.disableMetricRulesWithOptions(request, runtime);
  }

  /**
   * @param request - DisableSiteMonitorsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DisableSiteMonitorsResponse
   */
  async disableSiteMonitorsWithOptions(request: DisableSiteMonitorsRequest, runtime: $Util.RuntimeOptions): Promise<DisableSiteMonitorsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.taskIds)) {
      query["TaskIds"] = request.taskIds;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DisableSiteMonitors",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DisableSiteMonitorsResponse>(await this.callApi(params, req, runtime), new DisableSiteMonitorsResponse({}));
  }

  /**
   * @param request - DisableSiteMonitorsRequest
   * @returns DisableSiteMonitorsResponse
   */
  async disableSiteMonitors(request: DisableSiteMonitorsRequest): Promise<DisableSiteMonitorsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.disableSiteMonitorsWithOptions(request, runtime);
  }

  /**
   * @param request - EnableActiveMetricRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns EnableActiveMetricRuleResponse
   */
  async enableActiveMetricRuleWithOptions(request: EnableActiveMetricRuleRequest, runtime: $Util.RuntimeOptions): Promise<EnableActiveMetricRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.product)) {
      query["Product"] = request.product;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "EnableActiveMetricRule",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<EnableActiveMetricRuleResponse>(await this.callApi(params, req, runtime), new EnableActiveMetricRuleResponse({}));
  }

  /**
   * @param request - EnableActiveMetricRuleRequest
   * @returns EnableActiveMetricRuleResponse
   */
  async enableActiveMetricRule(request: EnableActiveMetricRuleRequest): Promise<EnableActiveMetricRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.enableActiveMetricRuleWithOptions(request, runtime);
  }

  /**
   * @param request - EnableEventRulesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns EnableEventRulesResponse
   */
  async enableEventRulesWithOptions(request: EnableEventRulesRequest, runtime: $Util.RuntimeOptions): Promise<EnableEventRulesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ruleNames)) {
      query["RuleNames"] = request.ruleNames;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "EnableEventRules",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<EnableEventRulesResponse>(await this.callApi(params, req, runtime), new EnableEventRulesResponse({}));
  }

  /**
   * @param request - EnableEventRulesRequest
   * @returns EnableEventRulesResponse
   */
  async enableEventRules(request: EnableEventRulesRequest): Promise<EnableEventRulesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.enableEventRulesWithOptions(request, runtime);
  }

  /**
   * @param request - EnableHostAvailabilityRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns EnableHostAvailabilityResponse
   */
  async enableHostAvailabilityWithOptions(request: EnableHostAvailabilityRequest, runtime: $Util.RuntimeOptions): Promise<EnableHostAvailabilityResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "EnableHostAvailability",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<EnableHostAvailabilityResponse>(await this.callApi(params, req, runtime), new EnableHostAvailabilityResponse({}));
  }

  /**
   * @param request - EnableHostAvailabilityRequest
   * @returns EnableHostAvailabilityResponse
   */
  async enableHostAvailability(request: EnableHostAvailabilityRequest): Promise<EnableHostAvailabilityResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.enableHostAvailabilityWithOptions(request, runtime);
  }

  /**
   * Enables or disables multiple blacklist policies at a time.
   * 
   * @param request - EnableMetricRuleBlackListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns EnableMetricRuleBlackListResponse
   */
  async enableMetricRuleBlackListWithOptions(request: EnableMetricRuleBlackListRequest, runtime: $Util.RuntimeOptions): Promise<EnableMetricRuleBlackListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.isEnable)) {
      query["IsEnable"] = request.isEnable;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "EnableMetricRuleBlackList",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<EnableMetricRuleBlackListResponse>(await this.callApi(params, req, runtime), new EnableMetricRuleBlackListResponse({}));
  }

  /**
   * Enables or disables multiple blacklist policies at a time.
   * 
   * @param request - EnableMetricRuleBlackListRequest
   * @returns EnableMetricRuleBlackListResponse
   */
  async enableMetricRuleBlackList(request: EnableMetricRuleBlackListRequest): Promise<EnableMetricRuleBlackListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.enableMetricRuleBlackListWithOptions(request, runtime);
  }

  /**
   * Enables one or more alert rules.
   * 
   * @param request - EnableMetricRulesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns EnableMetricRulesResponse
   */
  async enableMetricRulesWithOptions(request: EnableMetricRulesRequest, runtime: $Util.RuntimeOptions): Promise<EnableMetricRulesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "EnableMetricRules",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<EnableMetricRulesResponse>(await this.callApi(params, req, runtime), new EnableMetricRulesResponse({}));
  }

  /**
   * Enables one or more alert rules.
   * 
   * @param request - EnableMetricRulesRequest
   * @returns EnableMetricRulesResponse
   */
  async enableMetricRules(request: EnableMetricRulesRequest): Promise<EnableMetricRulesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.enableMetricRulesWithOptions(request, runtime);
  }

  /**
   * @param request - EnableSiteMonitorsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns EnableSiteMonitorsResponse
   */
  async enableSiteMonitorsWithOptions(request: EnableSiteMonitorsRequest, runtime: $Util.RuntimeOptions): Promise<EnableSiteMonitorsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.taskIds)) {
      query["TaskIds"] = request.taskIds;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "EnableSiteMonitors",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<EnableSiteMonitorsResponse>(await this.callApi(params, req, runtime), new EnableSiteMonitorsResponse({}));
  }

  /**
   * @param request - EnableSiteMonitorsRequest
   * @returns EnableSiteMonitorsResponse
   */
  async enableSiteMonitors(request: EnableSiteMonitorsRequest): Promise<EnableSiteMonitorsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.enableSiteMonitorsWithOptions(request, runtime);
  }

  /**
   * @remarks
   * ## Prerequisites
   * The Cloud Assistant client is installed on an ECS instance. For more information about how to install the Cloud Assistant client, see [Overview](https://help.aliyun.com/document_detail/64601.html).
   * 
   * @param request - InstallMonitoringAgentRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns InstallMonitoringAgentResponse
   */
  async installMonitoringAgentWithOptions(request: InstallMonitoringAgentRequest, runtime: $Util.RuntimeOptions): Promise<InstallMonitoringAgentResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.force)) {
      query["Force"] = request.force;
    }

    if (!Util.isUnset(request.installCommand)) {
      query["InstallCommand"] = request.installCommand;
    }

    if (!Util.isUnset(request.instanceIds)) {
      query["InstanceIds"] = request.instanceIds;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "InstallMonitoringAgent",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<InstallMonitoringAgentResponse>(await this.callApi(params, req, runtime), new InstallMonitoringAgentResponse({}));
  }

  /**
   * @remarks
   * ## Prerequisites
   * The Cloud Assistant client is installed on an ECS instance. For more information about how to install the Cloud Assistant client, see [Overview](https://help.aliyun.com/document_detail/64601.html).
   * 
   * @param request - InstallMonitoringAgentRequest
   * @returns InstallMonitoringAgentResponse
   */
  async installMonitoringAgent(request: InstallMonitoringAgentRequest): Promise<InstallMonitoringAgentResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.installMonitoringAgentWithOptions(request, runtime);
  }

  /**
   * @param request - ModifyGroupMonitoringAgentProcessRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyGroupMonitoringAgentProcessResponse
   */
  async modifyGroupMonitoringAgentProcessWithOptions(request: ModifyGroupMonitoringAgentProcessRequest, runtime: $Util.RuntimeOptions): Promise<ModifyGroupMonitoringAgentProcessResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.alertConfig)) {
      query["AlertConfig"] = request.alertConfig;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.matchExpressFilterRelation)) {
      query["MatchExpressFilterRelation"] = request.matchExpressFilterRelation;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyGroupMonitoringAgentProcess",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyGroupMonitoringAgentProcessResponse>(await this.callApi(params, req, runtime), new ModifyGroupMonitoringAgentProcessResponse({}));
  }

  /**
   * @param request - ModifyGroupMonitoringAgentProcessRequest
   * @returns ModifyGroupMonitoringAgentProcessResponse
   */
  async modifyGroupMonitoringAgentProcess(request: ModifyGroupMonitoringAgentProcessRequest): Promise<ModifyGroupMonitoringAgentProcessResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyGroupMonitoringAgentProcessWithOptions(request, runtime);
  }

  /**
   * Modifies an availability monitoring task.
   * 
   * @remarks
   * This topic provides an example on how to change the name of an availability monitoring task named `12345` in an application group named `123456` to `task2`.
   * 
   * @param request - ModifyHostAvailabilityRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyHostAvailabilityResponse
   */
  async modifyHostAvailabilityWithOptions(request: ModifyHostAvailabilityRequest, runtime: $Util.RuntimeOptions): Promise<ModifyHostAvailabilityResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.alertConfigEscalationList)) {
      query["AlertConfigEscalationList"] = request.alertConfigEscalationList;
    }

    if (!Util.isUnset(request.alertConfigTargetList)) {
      query["AlertConfigTargetList"] = request.alertConfigTargetList;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.instanceList)) {
      query["InstanceList"] = request.instanceList;
    }

    if (!Util.isUnset(request.taskName)) {
      query["TaskName"] = request.taskName;
    }

    if (!Util.isUnset(request.taskScope)) {
      query["TaskScope"] = request.taskScope;
    }

    if (!Util.isUnset(request.alertConfig)) {
      query["AlertConfig"] = request.alertConfig;
    }

    if (!Util.isUnset(request.taskOption)) {
      query["TaskOption"] = request.taskOption;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyHostAvailability",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyHostAvailabilityResponse>(await this.callApi(params, req, runtime), new ModifyHostAvailabilityResponse({}));
  }

  /**
   * Modifies an availability monitoring task.
   * 
   * @remarks
   * This topic provides an example on how to change the name of an availability monitoring task named `12345` in an application group named `123456` to `task2`.
   * 
   * @param request - ModifyHostAvailabilityRequest
   * @returns ModifyHostAvailabilityResponse
   */
  async modifyHostAvailability(request: ModifyHostAvailabilityRequest): Promise<ModifyHostAvailabilityResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyHostAvailabilityWithOptions(request, runtime);
  }

  /**
   * @remarks
   * ***
   * 
   * @param request - ModifyHostInfoRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyHostInfoResponse
   */
  async modifyHostInfoWithOptions(request: ModifyHostInfoRequest, runtime: $Util.RuntimeOptions): Promise<ModifyHostInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.hostName)) {
      query["HostName"] = request.hostName;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyHostInfo",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyHostInfoResponse>(await this.callApi(params, req, runtime), new ModifyHostInfoResponse({}));
  }

  /**
   * @remarks
   * ***
   * 
   * @param request - ModifyHostInfoRequest
   * @returns ModifyHostInfoResponse
   */
  async modifyHostInfo(request: ModifyHostInfoRequest): Promise<ModifyHostInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyHostInfoWithOptions(request, runtime);
  }

  /**
   * Modifies a namespace.
   * 
   * @remarks
   * This topic provides an example on how to change the data retention period of the `aliyun` namespace to `cms.s1.2xlarge`. The response shows that the namespace is modified.
   * 
   * @param request - ModifyHybridMonitorNamespaceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyHybridMonitorNamespaceResponse
   */
  async modifyHybridMonitorNamespaceWithOptions(request: ModifyHybridMonitorNamespaceRequest, runtime: $Util.RuntimeOptions): Promise<ModifyHybridMonitorNamespaceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.spec)) {
      query["Spec"] = request.spec;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyHybridMonitorNamespace",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyHybridMonitorNamespaceResponse>(await this.callApi(params, req, runtime), new ModifyHybridMonitorNamespaceResponse({}));
  }

  /**
   * Modifies a namespace.
   * 
   * @remarks
   * This topic provides an example on how to change the data retention period of the `aliyun` namespace to `cms.s1.2xlarge`. The response shows that the namespace is modified.
   * 
   * @param request - ModifyHybridMonitorNamespaceRequest
   * @returns ModifyHybridMonitorNamespaceResponse
   */
  async modifyHybridMonitorNamespace(request: ModifyHybridMonitorNamespaceRequest): Promise<ModifyHybridMonitorNamespaceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyHybridMonitorNamespaceWithOptions(request, runtime);
  }

  /**
   * Modifies a Logstore group.
   * 
   * @remarks
   * In this example, a Logstore group named `Logstore_test` is modified. The Logstore of the `aliyun-project` project in the `cn-hangzhou` region is changed to `Logstore-aliyun-all`. The response shows that the Logstore group is modified.
   * 
   * @param request - ModifyHybridMonitorSLSGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyHybridMonitorSLSGroupResponse
   */
  async modifyHybridMonitorSLSGroupWithOptions(request: ModifyHybridMonitorSLSGroupRequest, runtime: $Util.RuntimeOptions): Promise<ModifyHybridMonitorSLSGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.SLSGroupConfig)) {
      query["SLSGroupConfig"] = request.SLSGroupConfig;
    }

    if (!Util.isUnset(request.SLSGroupDescription)) {
      query["SLSGroupDescription"] = request.SLSGroupDescription;
    }

    if (!Util.isUnset(request.SLSGroupName)) {
      query["SLSGroupName"] = request.SLSGroupName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyHybridMonitorSLSGroup",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyHybridMonitorSLSGroupResponse>(await this.callApi(params, req, runtime), new ModifyHybridMonitorSLSGroupResponse({}));
  }

  /**
   * Modifies a Logstore group.
   * 
   * @remarks
   * In this example, a Logstore group named `Logstore_test` is modified. The Logstore of the `aliyun-project` project in the `cn-hangzhou` region is changed to `Logstore-aliyun-all`. The response shows that the Logstore group is modified.
   * 
   * @param request - ModifyHybridMonitorSLSGroupRequest
   * @returns ModifyHybridMonitorSLSGroupResponse
   */
  async modifyHybridMonitorSLSGroup(request: ModifyHybridMonitorSLSGroupRequest): Promise<ModifyHybridMonitorSLSGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyHybridMonitorSLSGroupWithOptions(request, runtime);
  }

  /**
   * Modifies a metric for the logs that are imported from Log Service.
   * 
   * @remarks
   * This topic provides an example on how to change the collection period of a metric import task whose ID is `36****` to `15` seconds. The task is used to monitor the logs that are imported from Log Service. The returned result indicates that the metric is modified.
   * 
   * @param request - ModifyHybridMonitorTaskRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyHybridMonitorTaskResponse
   */
  async modifyHybridMonitorTaskWithOptions(request: ModifyHybridMonitorTaskRequest, runtime: $Util.RuntimeOptions): Promise<ModifyHybridMonitorTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.attachLabels)) {
      query["AttachLabels"] = request.attachLabels;
    }

    if (!Util.isUnset(request.collectInterval)) {
      query["CollectInterval"] = request.collectInterval;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.SLSProcessConfig)) {
      query["SLSProcessConfig"] = request.SLSProcessConfig;
    }

    if (!Util.isUnset(request.taskId)) {
      query["TaskId"] = request.taskId;
    }

    if (!Util.isUnset(request.taskName)) {
      query["TaskName"] = request.taskName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyHybridMonitorTask",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyHybridMonitorTaskResponse>(await this.callApi(params, req, runtime), new ModifyHybridMonitorTaskResponse({}));
  }

  /**
   * Modifies a metric for the logs that are imported from Log Service.
   * 
   * @remarks
   * This topic provides an example on how to change the collection period of a metric import task whose ID is `36****` to `15` seconds. The task is used to monitor the logs that are imported from Log Service. The returned result indicates that the metric is modified.
   * 
   * @param request - ModifyHybridMonitorTaskRequest
   * @returns ModifyHybridMonitorTaskResponse
   */
  async modifyHybridMonitorTask(request: ModifyHybridMonitorTaskRequest): Promise<ModifyHybridMonitorTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyHybridMonitorTaskWithOptions(request, runtime);
  }

  /**
   * Modifies a blacklist policy.
   * 
   * @param request - ModifyMetricRuleBlackListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyMetricRuleBlackListResponse
   */
  async modifyMetricRuleBlackListWithOptions(request: ModifyMetricRuleBlackListRequest, runtime: $Util.RuntimeOptions): Promise<ModifyMetricRuleBlackListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.category)) {
      query["Category"] = request.category;
    }

    if (!Util.isUnset(request.effectiveTime)) {
      query["EffectiveTime"] = request.effectiveTime;
    }

    if (!Util.isUnset(request.enableEndTime)) {
      query["EnableEndTime"] = request.enableEndTime;
    }

    if (!Util.isUnset(request.enableStartTime)) {
      query["EnableStartTime"] = request.enableStartTime;
    }

    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.instances)) {
      query["Instances"] = request.instances;
    }

    if (!Util.isUnset(request.metrics)) {
      query["Metrics"] = request.metrics;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.scopeType)) {
      query["ScopeType"] = request.scopeType;
    }

    if (!Util.isUnset(request.scopeValue)) {
      query["ScopeValue"] = request.scopeValue;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyMetricRuleBlackList",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyMetricRuleBlackListResponse>(await this.callApi(params, req, runtime), new ModifyMetricRuleBlackListResponse({}));
  }

  /**
   * Modifies a blacklist policy.
   * 
   * @param request - ModifyMetricRuleBlackListRequest
   * @returns ModifyMetricRuleBlackListResponse
   */
  async modifyMetricRuleBlackList(request: ModifyMetricRuleBlackListRequest): Promise<ModifyMetricRuleBlackListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyMetricRuleBlackListWithOptions(request, runtime);
  }

  /**
   * Modifies an alert template.
   * 
   * @remarks
   * This topic provides an example on how to modify an alert template whose version is `1` and ID is `123456`. The alert level is changed to `Critical`. The statistical method is changed to `Average`. The alert threshold comparator is changed to `GreaterThanOrEqualToThreshold`. The alert threshold is changed to `90`. The number of alert retries is changed to `3`. The response shows that the alert template is modified.
   * 
   * @param request - ModifyMetricRuleTemplateRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyMetricRuleTemplateResponse
   */
  async modifyMetricRuleTemplateWithOptions(request: ModifyMetricRuleTemplateRequest, runtime: $Util.RuntimeOptions): Promise<ModifyMetricRuleTemplateResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.alertTemplates)) {
      query["AlertTemplates"] = request.alertTemplates;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.restVersion)) {
      query["RestVersion"] = request.restVersion;
    }

    if (!Util.isUnset(request.templateId)) {
      query["TemplateId"] = request.templateId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyMetricRuleTemplate",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyMetricRuleTemplateResponse>(await this.callApi(params, req, runtime), new ModifyMetricRuleTemplateResponse({}));
  }

  /**
   * Modifies an alert template.
   * 
   * @remarks
   * This topic provides an example on how to modify an alert template whose version is `1` and ID is `123456`. The alert level is changed to `Critical`. The statistical method is changed to `Average`. The alert threshold comparator is changed to `GreaterThanOrEqualToThreshold`. The alert threshold is changed to `90`. The number of alert retries is changed to `3`. The response shows that the alert template is modified.
   * 
   * @param request - ModifyMetricRuleTemplateRequest
   * @returns ModifyMetricRuleTemplateResponse
   */
  async modifyMetricRuleTemplate(request: ModifyMetricRuleTemplateRequest): Promise<ModifyMetricRuleTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyMetricRuleTemplateWithOptions(request, runtime);
  }

  /**
   * @param request - ModifyMonitorGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyMonitorGroupResponse
   */
  async modifyMonitorGroupWithOptions(request: ModifyMonitorGroupRequest, runtime: $Util.RuntimeOptions): Promise<ModifyMonitorGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.contactGroups)) {
      query["ContactGroups"] = request.contactGroups;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.groupName)) {
      query["GroupName"] = request.groupName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyMonitorGroup",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyMonitorGroupResponse>(await this.callApi(params, req, runtime), new ModifyMonitorGroupResponse({}));
  }

  /**
   * @param request - ModifyMonitorGroupRequest
   * @returns ModifyMonitorGroupResponse
   */
  async modifyMonitorGroup(request: ModifyMonitorGroupRequest): Promise<ModifyMonitorGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyMonitorGroupWithOptions(request, runtime);
  }

  /**
   * @param request - ModifyMonitorGroupInstancesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyMonitorGroupInstancesResponse
   */
  async modifyMonitorGroupInstancesWithOptions(request: ModifyMonitorGroupInstancesRequest, runtime: $Util.RuntimeOptions): Promise<ModifyMonitorGroupInstancesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.instances)) {
      query["Instances"] = request.instances;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyMonitorGroupInstances",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyMonitorGroupInstancesResponse>(await this.callApi(params, req, runtime), new ModifyMonitorGroupInstancesResponse({}));
  }

  /**
   * @param request - ModifyMonitorGroupInstancesRequest
   * @returns ModifyMonitorGroupInstancesResponse
   */
  async modifyMonitorGroupInstances(request: ModifyMonitorGroupInstancesRequest): Promise<ModifyMonitorGroupInstancesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyMonitorGroupInstancesWithOptions(request, runtime);
  }

  /**
   * Modifies a site monitoring task.
   * 
   * @remarks
   * The number of site monitoring tasks.
   * 
   * @param request - ModifySiteMonitorRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifySiteMonitorResponse
   */
  async modifySiteMonitorWithOptions(request: ModifySiteMonitorRequest, runtime: $Util.RuntimeOptions): Promise<ModifySiteMonitorResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.address)) {
      query["Address"] = request.address;
    }

    if (!Util.isUnset(request.alertIds)) {
      query["AlertIds"] = request.alertIds;
    }

    if (!Util.isUnset(request.customSchedule)) {
      query["CustomSchedule"] = request.customSchedule;
    }

    if (!Util.isUnset(request.interval)) {
      query["Interval"] = request.interval;
    }

    if (!Util.isUnset(request.intervalUnit)) {
      query["IntervalUnit"] = request.intervalUnit;
    }

    if (!Util.isUnset(request.ispCities)) {
      query["IspCities"] = request.ispCities;
    }

    if (!Util.isUnset(request.optionsJson)) {
      query["OptionsJson"] = request.optionsJson;
    }

    if (!Util.isUnset(request.taskId)) {
      query["TaskId"] = request.taskId;
    }

    if (!Util.isUnset(request.taskName)) {
      query["TaskName"] = request.taskName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifySiteMonitor",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifySiteMonitorResponse>(await this.callApi(params, req, runtime), new ModifySiteMonitorResponse({}));
  }

  /**
   * Modifies a site monitoring task.
   * 
   * @remarks
   * The number of site monitoring tasks.
   * 
   * @param request - ModifySiteMonitorRequest
   * @returns ModifySiteMonitorResponse
   */
  async modifySiteMonitor(request: ModifySiteMonitorRequest): Promise<ModifySiteMonitorResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifySiteMonitorWithOptions(request, runtime);
  }

  /**
   * @deprecated OpenAPI OpenCmsService is deprecated
   * 
   * @param request - OpenCmsServiceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns OpenCmsServiceResponse
   */
  // Deprecated
  async openCmsServiceWithOptions(runtime: $Util.RuntimeOptions): Promise<OpenCmsServiceResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "OpenCmsService",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<OpenCmsServiceResponse>(await this.callApi(params, req, runtime), new OpenCmsServiceResponse({}));
  }

  /**
   * @deprecated OpenAPI OpenCmsService is deprecated
   * @returns OpenCmsServiceResponse
   */
  // Deprecated
  async openCmsService(): Promise<OpenCmsServiceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.openCmsServiceWithOptions(runtime);
  }

  /**
   * @param request - PutContactRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns PutContactResponse
   */
  async putContactWithOptions(request: PutContactRequest, runtime: $Util.RuntimeOptions): Promise<PutContactResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.contactName)) {
      query["ContactName"] = request.contactName;
    }

    if (!Util.isUnset(request.describe)) {
      query["Describe"] = request.describe;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.channels)) {
      query["Channels"] = request.channels;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "PutContact",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PutContactResponse>(await this.callApi(params, req, runtime), new PutContactResponse({}));
  }

  /**
   * @param request - PutContactRequest
   * @returns PutContactResponse
   */
  async putContact(request: PutContactRequest): Promise<PutContactResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.putContactWithOptions(request, runtime);
  }

  /**
   * 添加或者修改报警联系人组
   * 
   * @remarks
   * This topic provides an example on how to create an alert contact group named `ECS_Group`.
   * 
   * @param request - PutContactGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns PutContactGroupResponse
   */
  async putContactGroupWithOptions(request: PutContactGroupRequest, runtime: $Util.RuntimeOptions): Promise<PutContactGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.contactGroupName)) {
      query["ContactGroupName"] = request.contactGroupName;
    }

    if (!Util.isUnset(request.contactNames)) {
      query["ContactNames"] = request.contactNames;
    }

    if (!Util.isUnset(request.describe)) {
      query["Describe"] = request.describe;
    }

    if (!Util.isUnset(request.enableSubscribed)) {
      query["EnableSubscribed"] = request.enableSubscribed;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "PutContactGroup",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PutContactGroupResponse>(await this.callApi(params, req, runtime), new PutContactGroupResponse({}));
  }

  /**
   * 添加或者修改报警联系人组
   * 
   * @remarks
   * This topic provides an example on how to create an alert contact group named `ECS_Group`.
   * 
   * @param request - PutContactGroupRequest
   * @returns PutContactGroupResponse
   */
  async putContactGroup(request: PutContactGroupRequest): Promise<PutContactGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.putContactGroupWithOptions(request, runtime);
  }

  /**
   * Reports custom events.
   * 
   * @param request - PutCustomEventRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns PutCustomEventResponse
   */
  async putCustomEventWithOptions(request: PutCustomEventRequest, runtime: $Util.RuntimeOptions): Promise<PutCustomEventResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.eventInfo)) {
      query["EventInfo"] = request.eventInfo;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "PutCustomEvent",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PutCustomEventResponse>(await this.callApi(params, req, runtime), new PutCustomEventResponse({}));
  }

  /**
   * Reports custom events.
   * 
   * @param request - PutCustomEventRequest
   * @returns PutCustomEventResponse
   */
  async putCustomEvent(request: PutCustomEventRequest): Promise<PutCustomEventResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.putCustomEventWithOptions(request, runtime);
  }

  /**
   * @remarks
   * Before you call this operation, call the PutCustomEvent operation to report the monitoring data of the custom event. For more information, see [PutCustomEvent](https://help.aliyun.com/document_detail/115012.html).
   * 
   * @param request - PutCustomEventRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns PutCustomEventRuleResponse
   */
  async putCustomEventRuleWithOptions(request: PutCustomEventRuleRequest, runtime: $Util.RuntimeOptions): Promise<PutCustomEventRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.contactGroups)) {
      query["ContactGroups"] = request.contactGroups;
    }

    if (!Util.isUnset(request.effectiveInterval)) {
      query["EffectiveInterval"] = request.effectiveInterval;
    }

    if (!Util.isUnset(request.emailSubject)) {
      query["EmailSubject"] = request.emailSubject;
    }

    if (!Util.isUnset(request.eventName)) {
      query["EventName"] = request.eventName;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.level)) {
      query["Level"] = request.level;
    }

    if (!Util.isUnset(request.period)) {
      query["Period"] = request.period;
    }

    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    if (!Util.isUnset(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    if (!Util.isUnset(request.threshold)) {
      query["Threshold"] = request.threshold;
    }

    if (!Util.isUnset(request.webhook)) {
      query["Webhook"] = request.webhook;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "PutCustomEventRule",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PutCustomEventRuleResponse>(await this.callApi(params, req, runtime), new PutCustomEventRuleResponse({}));
  }

  /**
   * @remarks
   * Before you call this operation, call the PutCustomEvent operation to report the monitoring data of the custom event. For more information, see [PutCustomEvent](https://help.aliyun.com/document_detail/115012.html).
   * 
   * @param request - PutCustomEventRuleRequest
   * @returns PutCustomEventRuleResponse
   */
  async putCustomEventRule(request: PutCustomEventRuleRequest): Promise<PutCustomEventRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.putCustomEventRuleWithOptions(request, runtime);
  }

  /**
   * @remarks
   * >  We recommend that you call the [PutHybridMonitorMetricData](https://help.aliyun.com/document_detail/383455.html) operation of Hybrid Cloud Monitoring to report monitoring data.
   * 
   * @param request - PutCustomMetricRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns PutCustomMetricResponse
   */
  async putCustomMetricWithOptions(request: PutCustomMetricRequest, runtime: $Util.RuntimeOptions): Promise<PutCustomMetricResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.metricList)) {
      query["MetricList"] = request.metricList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "PutCustomMetric",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PutCustomMetricResponse>(await this.callApi(params, req, runtime), new PutCustomMetricResponse({}));
  }

  /**
   * @remarks
   * >  We recommend that you call the [PutHybridMonitorMetricData](https://help.aliyun.com/document_detail/383455.html) operation of Hybrid Cloud Monitoring to report monitoring data.
   * 
   * @param request - PutCustomMetricRequest
   * @returns PutCustomMetricResponse
   */
  async putCustomMetric(request: PutCustomMetricRequest): Promise<PutCustomMetricResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.putCustomMetricWithOptions(request, runtime);
  }

  /**
   * @remarks
   * Before you call this operation, call the PutCustomMetric operation to report custom monitoring data. For more information, see [PutCustomMetric](https://help.aliyun.com/document_detail/115004.html).
   * 
   * @param request - PutCustomMetricRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns PutCustomMetricRuleResponse
   */
  async putCustomMetricRuleWithOptions(request: PutCustomMetricRuleRequest, runtime: $Util.RuntimeOptions): Promise<PutCustomMetricRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.comparisonOperator)) {
      query["ComparisonOperator"] = request.comparisonOperator;
    }

    if (!Util.isUnset(request.contactGroups)) {
      query["ContactGroups"] = request.contactGroups;
    }

    if (!Util.isUnset(request.effectiveInterval)) {
      query["EffectiveInterval"] = request.effectiveInterval;
    }

    if (!Util.isUnset(request.emailSubject)) {
      query["EmailSubject"] = request.emailSubject;
    }

    if (!Util.isUnset(request.evaluationCount)) {
      query["EvaluationCount"] = request.evaluationCount;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.level)) {
      query["Level"] = request.level;
    }

    if (!Util.isUnset(request.metricName)) {
      query["MetricName"] = request.metricName;
    }

    if (!Util.isUnset(request.period)) {
      query["Period"] = request.period;
    }

    if (!Util.isUnset(request.resources)) {
      query["Resources"] = request.resources;
    }

    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    if (!Util.isUnset(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    if (!Util.isUnset(request.silenceTime)) {
      query["SilenceTime"] = request.silenceTime;
    }

    if (!Util.isUnset(request.statistics)) {
      query["Statistics"] = request.statistics;
    }

    if (!Util.isUnset(request.threshold)) {
      query["Threshold"] = request.threshold;
    }

    if (!Util.isUnset(request.webhook)) {
      query["Webhook"] = request.webhook;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "PutCustomMetricRule",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PutCustomMetricRuleResponse>(await this.callApi(params, req, runtime), new PutCustomMetricRuleResponse({}));
  }

  /**
   * @remarks
   * Before you call this operation, call the PutCustomMetric operation to report custom monitoring data. For more information, see [PutCustomMetric](https://help.aliyun.com/document_detail/115004.html).
   * 
   * @param request - PutCustomMetricRuleRequest
   * @returns PutCustomMetricRuleResponse
   */
  async putCustomMetricRule(request: PutCustomMetricRuleRequest): Promise<PutCustomMetricRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.putCustomMetricRuleWithOptions(request, runtime);
  }

  /**
   * 创建或者修改事件监控
   * 
   * @remarks
   * If the specified rule name does not exist, an event-triggered alert rule is created. If the specified rule name exists, the specified event-triggered alert rule is modified.
   * In this example, the `myRuleName` alert rule is created for the `ecs` cloud service.
   * 
   * @param request - PutEventRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns PutEventRuleResponse
   */
  async putEventRuleWithOptions(request: PutEventRuleRequest, runtime: $Util.RuntimeOptions): Promise<PutEventRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.eventPattern)) {
      query["EventPattern"] = request.eventPattern;
    }

    if (!Util.isUnset(request.eventType)) {
      query["EventType"] = request.eventType;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    if (!Util.isUnset(request.silenceTime)) {
      query["SilenceTime"] = request.silenceTime;
    }

    if (!Util.isUnset(request.state)) {
      query["State"] = request.state;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "PutEventRule",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PutEventRuleResponse>(await this.callApi(params, req, runtime), new PutEventRuleResponse({}));
  }

  /**
   * 创建或者修改事件监控
   * 
   * @remarks
   * If the specified rule name does not exist, an event-triggered alert rule is created. If the specified rule name exists, the specified event-triggered alert rule is modified.
   * In this example, the `myRuleName` alert rule is created for the `ecs` cloud service.
   * 
   * @param request - PutEventRuleRequest
   * @returns PutEventRuleResponse
   */
  async putEventRule(request: PutEventRuleRequest): Promise<PutEventRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.putEventRuleWithOptions(request, runtime);
  }

  /**
   * Adds or modifies the push channels of an event-triggered alert rule.
   * 
   * @param request - PutEventRuleTargetsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns PutEventRuleTargetsResponse
   */
  async putEventRuleTargetsWithOptions(request: PutEventRuleTargetsRequest, runtime: $Util.RuntimeOptions): Promise<PutEventRuleTargetsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.contactParameters)) {
      query["ContactParameters"] = request.contactParameters;
    }

    if (!Util.isUnset(request.fcParameters)) {
      query["FcParameters"] = request.fcParameters;
    }

    if (!Util.isUnset(request.mnsParameters)) {
      query["MnsParameters"] = request.mnsParameters;
    }

    if (!Util.isUnset(request.openApiParameters)) {
      query["OpenApiParameters"] = request.openApiParameters;
    }

    if (!Util.isUnset(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    if (!Util.isUnset(request.slsParameters)) {
      query["SlsParameters"] = request.slsParameters;
    }

    if (!Util.isUnset(request.webhookParameters)) {
      query["WebhookParameters"] = request.webhookParameters;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "PutEventRuleTargets",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PutEventRuleTargetsResponse>(await this.callApi(params, req, runtime), new PutEventRuleTargetsResponse({}));
  }

  /**
   * Adds or modifies the push channels of an event-triggered alert rule.
   * 
   * @param request - PutEventRuleTargetsRequest
   * @returns PutEventRuleTargetsResponse
   */
  async putEventRuleTargets(request: PutEventRuleTargetsRequest): Promise<PutEventRuleTargetsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.putEventRuleTargetsWithOptions(request, runtime);
  }

  /**
   * Creates or modifies a configuration set for exporting monitoring data.
   * 
   * @remarks
   * > The monitoring data can be exported only to Log Service. More services will be supported in the future.
   * 
   * @param request - PutExporterOutputRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns PutExporterOutputResponse
   */
  async putExporterOutputWithOptions(request: PutExporterOutputRequest, runtime: $Util.RuntimeOptions): Promise<PutExporterOutputResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.configJson)) {
      query["ConfigJson"] = request.configJson;
    }

    if (!Util.isUnset(request.desc)) {
      query["Desc"] = request.desc;
    }

    if (!Util.isUnset(request.destName)) {
      query["DestName"] = request.destName;
    }

    if (!Util.isUnset(request.destType)) {
      query["DestType"] = request.destType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "PutExporterOutput",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PutExporterOutputResponse>(await this.callApi(params, req, runtime), new PutExporterOutputResponse({}));
  }

  /**
   * Creates or modifies a configuration set for exporting monitoring data.
   * 
   * @remarks
   * > The monitoring data can be exported only to Log Service. More services will be supported in the future.
   * 
   * @param request - PutExporterOutputRequest
   * @returns PutExporterOutputResponse
   */
  async putExporterOutput(request: PutExporterOutputRequest): Promise<PutExporterOutputResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.putExporterOutputWithOptions(request, runtime);
  }

  /**
   * Creates or modifies a data export rule.
   * 
   * @param request - PutExporterRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns PutExporterRuleResponse
   */
  async putExporterRuleWithOptions(request: PutExporterRuleRequest, runtime: $Util.RuntimeOptions): Promise<PutExporterRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.describe)) {
      query["Describe"] = request.describe;
    }

    if (!Util.isUnset(request.dstNames)) {
      query["DstNames"] = request.dstNames;
    }

    if (!Util.isUnset(request.metricName)) {
      query["MetricName"] = request.metricName;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    if (!Util.isUnset(request.targetWindows)) {
      query["TargetWindows"] = request.targetWindows;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "PutExporterRule",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PutExporterRuleResponse>(await this.callApi(params, req, runtime), new PutExporterRuleResponse({}));
  }

  /**
   * Creates or modifies a data export rule.
   * 
   * @param request - PutExporterRuleRequest
   * @returns PutExporterRuleResponse
   */
  async putExporterRule(request: PutExporterRuleRequest): Promise<PutExporterRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.putExporterRuleWithOptions(request, runtime);
  }

  /**
   * Creates or modifies an alert rule for an application group.
   * 
   * @remarks
   * This topic provides an example on how to create an alert rule for the `cpu_total` metric of Elastic Compute Service (ECS) in the `17285****` application group. The ID of the alert rule is `123456`. The name of the alert rule is `Rule_test`. The alert level is `Critical`. The statistical method is `Average`. The alert threshold comparator is `GreaterThanOrEqualToThreshold`. The alert threshold is `90`. The number of alert retries is `3`. The returned result shows that the alert rule is created and the alert rule ID is `123456`.
   * 
   * @param request - PutGroupMetricRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns PutGroupMetricRuleResponse
   */
  async putGroupMetricRuleWithOptions(request: PutGroupMetricRuleRequest, runtime: $Util.RuntimeOptions): Promise<PutGroupMetricRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.category)) {
      query["Category"] = request.category;
    }

    if (!Util.isUnset(request.contactGroups)) {
      query["ContactGroups"] = request.contactGroups;
    }

    if (!Util.isUnset(request.dimensions)) {
      query["Dimensions"] = request.dimensions;
    }

    if (!Util.isUnset(request.effectiveInterval)) {
      query["EffectiveInterval"] = request.effectiveInterval;
    }

    if (!Util.isUnset(request.emailSubject)) {
      query["EmailSubject"] = request.emailSubject;
    }

    if (!Util.isUnset(request.extraDimensionJson)) {
      query["ExtraDimensionJson"] = request.extraDimensionJson;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.interval)) {
      query["Interval"] = request.interval;
    }

    if (!Util.isUnset(request.labels)) {
      query["Labels"] = request.labels;
    }

    if (!Util.isUnset(request.metricName)) {
      query["MetricName"] = request.metricName;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.noDataPolicy)) {
      query["NoDataPolicy"] = request.noDataPolicy;
    }

    if (!Util.isUnset(request.noEffectiveInterval)) {
      query["NoEffectiveInterval"] = request.noEffectiveInterval;
    }

    if (!Util.isUnset(request.options)) {
      query["Options"] = request.options;
    }

    if (!Util.isUnset(request.period)) {
      query["Period"] = request.period;
    }

    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    if (!Util.isUnset(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    if (!Util.isUnset(request.silenceTime)) {
      query["SilenceTime"] = request.silenceTime;
    }

    if (!Util.isUnset(request.webhook)) {
      query["Webhook"] = request.webhook;
    }

    if (!Util.isUnset(request.escalations)) {
      query["Escalations"] = request.escalations;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "PutGroupMetricRule",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PutGroupMetricRuleResponse>(await this.callApi(params, req, runtime), new PutGroupMetricRuleResponse({}));
  }

  /**
   * Creates or modifies an alert rule for an application group.
   * 
   * @remarks
   * This topic provides an example on how to create an alert rule for the `cpu_total` metric of Elastic Compute Service (ECS) in the `17285****` application group. The ID of the alert rule is `123456`. The name of the alert rule is `Rule_test`. The alert level is `Critical`. The statistical method is `Average`. The alert threshold comparator is `GreaterThanOrEqualToThreshold`. The alert threshold is `90`. The number of alert retries is `3`. The returned result shows that the alert rule is created and the alert rule ID is `123456`.
   * 
   * @param request - PutGroupMetricRuleRequest
   * @returns PutGroupMetricRuleResponse
   */
  async putGroupMetricRule(request: PutGroupMetricRuleRequest): Promise<PutGroupMetricRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.putGroupMetricRuleWithOptions(request, runtime);
  }

  /**
   * Imports the monitoring data of a metric to a namespace of Hybrid Cloud Monitoring.
   * 
   * @remarks
   * # [](#)Prerequisites
   * Hybrid Cloud Monitoring is activated. For more information, see [Activate Hybrid Cloud Monitoring](https://help.aliyun.com/document_detail/250773.html).
   * # [](#)Limits
   * The size of the monitoring data that you import at a time must be less than or equal to 1 MB.
   * # [](#)Description
   * This topic provides an example on how to import the monitoring data of the `CPU_Usage` metric to the `default-aliyun` namespace of Hybrid Cloud Monitoring.
   * 
   * @param request - PutHybridMonitorMetricDataRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns PutHybridMonitorMetricDataResponse
   */
  async putHybridMonitorMetricDataWithOptions(request: PutHybridMonitorMetricDataRequest, runtime: $Util.RuntimeOptions): Promise<PutHybridMonitorMetricDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.metricList)) {
      query["MetricList"] = request.metricList;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "PutHybridMonitorMetricData",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PutHybridMonitorMetricDataResponse>(await this.callApi(params, req, runtime), new PutHybridMonitorMetricDataResponse({}));
  }

  /**
   * Imports the monitoring data of a metric to a namespace of Hybrid Cloud Monitoring.
   * 
   * @remarks
   * # [](#)Prerequisites
   * Hybrid Cloud Monitoring is activated. For more information, see [Activate Hybrid Cloud Monitoring](https://help.aliyun.com/document_detail/250773.html).
   * # [](#)Limits
   * The size of the monitoring data that you import at a time must be less than or equal to 1 MB.
   * # [](#)Description
   * This topic provides an example on how to import the monitoring data of the `CPU_Usage` metric to the `default-aliyun` namespace of Hybrid Cloud Monitoring.
   * 
   * @param request - PutHybridMonitorMetricDataRequest
   * @returns PutHybridMonitorMetricDataResponse
   */
  async putHybridMonitorMetricData(request: PutHybridMonitorMetricDataRequest): Promise<PutHybridMonitorMetricDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.putHybridMonitorMetricDataWithOptions(request, runtime);
  }

  /**
   * Creates or modifies a log monitoring metric.
   * 
   * @remarks
   * In the example of this topic, the `cpu_total` log monitoring metric is created. The response shows that the log monitoring metric is created and the metric ID is `16****`.
   * 
   * @param request - PutLogMonitorRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns PutLogMonitorResponse
   */
  async putLogMonitorWithOptions(request: PutLogMonitorRequest, runtime: $Util.RuntimeOptions): Promise<PutLogMonitorResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.aggregates)) {
      query["Aggregates"] = request.aggregates;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.groupbys)) {
      query["Groupbys"] = request.groupbys;
    }

    if (!Util.isUnset(request.logId)) {
      query["LogId"] = request.logId;
    }

    if (!Util.isUnset(request.metricExpress)) {
      query["MetricExpress"] = request.metricExpress;
    }

    if (!Util.isUnset(request.metricName)) {
      query["MetricName"] = request.metricName;
    }

    if (!Util.isUnset(request.slsLogstore)) {
      query["SlsLogstore"] = request.slsLogstore;
    }

    if (!Util.isUnset(request.slsProject)) {
      query["SlsProject"] = request.slsProject;
    }

    if (!Util.isUnset(request.slsRegionId)) {
      query["SlsRegionId"] = request.slsRegionId;
    }

    if (!Util.isUnset(request.tumblingwindows)) {
      query["Tumblingwindows"] = request.tumblingwindows;
    }

    if (!Util.isUnset(request.unit)) {
      query["Unit"] = request.unit;
    }

    if (!Util.isUnset(request.valueFilter)) {
      query["ValueFilter"] = request.valueFilter;
    }

    if (!Util.isUnset(request.valueFilterRelation)) {
      query["ValueFilterRelation"] = request.valueFilterRelation;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "PutLogMonitor",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PutLogMonitorResponse>(await this.callApi(params, req, runtime), new PutLogMonitorResponse({}));
  }

  /**
   * Creates or modifies a log monitoring metric.
   * 
   * @remarks
   * In the example of this topic, the `cpu_total` log monitoring metric is created. The response shows that the log monitoring metric is created and the metric ID is `16****`.
   * 
   * @param request - PutLogMonitorRequest
   * @returns PutLogMonitorResponse
   */
  async putLogMonitor(request: PutLogMonitorRequest): Promise<PutLogMonitorResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.putLogMonitorWithOptions(request, runtime);
  }

  /**
   * Adds or modifies the push channels of an alert rule.
   * 
   * @remarks
   * # [](#)
   * This topic provides an example on how to associate an alert rule with a resource. In this example, the alert rule is `ae06917_75a8c43178ab66****`, the resource is `acs:mns:cn-hangzhou:120886317861****:/queues/test/message`, and the ID of the resource for which alerts are triggered is `1`. The response indicates that the resource is associated with the specified alert rule.
   * 
   * @param request - PutMetricRuleTargetsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns PutMetricRuleTargetsResponse
   */
  async putMetricRuleTargetsWithOptions(request: PutMetricRuleTargetsRequest, runtime: $Util.RuntimeOptions): Promise<PutMetricRuleTargetsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    if (!Util.isUnset(request.targets)) {
      query["Targets"] = request.targets;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "PutMetricRuleTargets",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PutMetricRuleTargetsResponse>(await this.callApi(params, req, runtime), new PutMetricRuleTargetsResponse({}));
  }

  /**
   * Adds or modifies the push channels of an alert rule.
   * 
   * @remarks
   * # [](#)
   * This topic provides an example on how to associate an alert rule with a resource. In this example, the alert rule is `ae06917_75a8c43178ab66****`, the resource is `acs:mns:cn-hangzhou:120886317861****:/queues/test/message`, and the ID of the resource for which alerts are triggered is `1`. The response indicates that the resource is associated with the specified alert rule.
   * 
   * @param request - PutMetricRuleTargetsRequest
   * @returns PutMetricRuleTargetsResponse
   */
  async putMetricRuleTargets(request: PutMetricRuleTargetsRequest): Promise<PutMetricRuleTargetsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.putMetricRuleTargetsWithOptions(request, runtime);
  }

  /**
   * Creates or modifies an alert rule to dynamically add instances that meet the rule to an application group.
   * 
   * @param request - PutMonitorGroupDynamicRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns PutMonitorGroupDynamicRuleResponse
   */
  async putMonitorGroupDynamicRuleWithOptions(request: PutMonitorGroupDynamicRuleRequest, runtime: $Util.RuntimeOptions): Promise<PutMonitorGroupDynamicRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.groupRules)) {
      query["GroupRules"] = request.groupRules;
    }

    if (!Util.isUnset(request.isAsync)) {
      query["IsAsync"] = request.isAsync;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "PutMonitorGroupDynamicRule",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PutMonitorGroupDynamicRuleResponse>(await this.callApi(params, req, runtime), new PutMonitorGroupDynamicRuleResponse({}));
  }

  /**
   * Creates or modifies an alert rule to dynamically add instances that meet the rule to an application group.
   * 
   * @param request - PutMonitorGroupDynamicRuleRequest
   * @returns PutMonitorGroupDynamicRuleResponse
   */
  async putMonitorGroupDynamicRule(request: PutMonitorGroupDynamicRuleRequest): Promise<PutMonitorGroupDynamicRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.putMonitorGroupDynamicRuleWithOptions(request, runtime);
  }

  /**
   * Configures global settings for the CloudMonitor agent.
   * 
   * @param request - PutMonitoringConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns PutMonitoringConfigResponse
   */
  async putMonitoringConfigWithOptions(request: PutMonitoringConfigRequest, runtime: $Util.RuntimeOptions): Promise<PutMonitoringConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.autoInstall)) {
      query["AutoInstall"] = request.autoInstall;
    }

    if (!Util.isUnset(request.enableInstallAgentNewECS)) {
      query["EnableInstallAgentNewECS"] = request.enableInstallAgentNewECS;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "PutMonitoringConfig",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PutMonitoringConfigResponse>(await this.callApi(params, req, runtime), new PutMonitoringConfigResponse({}));
  }

  /**
   * Configures global settings for the CloudMonitor agent.
   * 
   * @param request - PutMonitoringConfigRequest
   * @returns PutMonitoringConfigResponse
   */
  async putMonitoringConfig(request: PutMonitoringConfigRequest): Promise<PutMonitoringConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.putMonitoringConfigWithOptions(request, runtime);
  }

  /**
   * Creates an alert rule for a metric of a resource.
   * 
   * @remarks
   * This topic provides an example on how to create a threshold-triggered alert rule for the `cpu_total` metric of an Elastic Compute Service (ECS) instance whose ID is `i-uf6j91r34rnwawoo****`. The namespace of ECS metrics is `acs_ecs_dashboard`. The alert contact group of the alert rule is `ECS_Group`. The name of the alert rule is `test123`. The ID of the alert rule is `a151cd6023eacee2f0978e03863cc1697c89508****`. The statistical method for Critical-level alerts is `Average`. The comparison operator for Critical-level alerts is `GreaterThanOrEqualToThreshold`. The threshold for Critical-level alerts is `90`. The consecutive number of times for which the metric value meets the trigger condition before a Critical-level alert is triggered is `3`.
   * 
   * @param tmpReq - PutResourceMetricRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns PutResourceMetricRuleResponse
   */
  async putResourceMetricRuleWithOptions(tmpReq: PutResourceMetricRuleRequest, runtime: $Util.RuntimeOptions): Promise<PutResourceMetricRuleResponse> {
    Util.validateModel(tmpReq);
    let request = new PutResourceMetricRuleShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.compositeExpression)) {
      request.compositeExpressionShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.compositeExpression, "CompositeExpression", "json");
    }

    if (!Util.isUnset(tmpReq.prometheus)) {
      request.prometheusShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.prometheus, "Prometheus", "json");
    }

    let query = { };
    if (!Util.isUnset(request.compositeExpressionShrink)) {
      query["CompositeExpression"] = request.compositeExpressionShrink;
    }

    if (!Util.isUnset(request.contactGroups)) {
      query["ContactGroups"] = request.contactGroups;
    }

    if (!Util.isUnset(request.effectiveInterval)) {
      query["EffectiveInterval"] = request.effectiveInterval;
    }

    if (!Util.isUnset(request.emailSubject)) {
      query["EmailSubject"] = request.emailSubject;
    }

    if (!Util.isUnset(request.interval)) {
      query["Interval"] = request.interval;
    }

    if (!Util.isUnset(request.labels)) {
      query["Labels"] = request.labels;
    }

    if (!Util.isUnset(request.metricName)) {
      query["MetricName"] = request.metricName;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.noDataPolicy)) {
      query["NoDataPolicy"] = request.noDataPolicy;
    }

    if (!Util.isUnset(request.noEffectiveInterval)) {
      query["NoEffectiveInterval"] = request.noEffectiveInterval;
    }

    if (!Util.isUnset(request.period)) {
      query["Period"] = request.period;
    }

    if (!Util.isUnset(request.prometheusShrink)) {
      query["Prometheus"] = request.prometheusShrink;
    }

    if (!Util.isUnset(request.resources)) {
      query["Resources"] = request.resources;
    }

    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    if (!Util.isUnset(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    if (!Util.isUnset(request.silenceTime)) {
      query["SilenceTime"] = request.silenceTime;
    }

    if (!Util.isUnset(request.webhook)) {
      query["Webhook"] = request.webhook;
    }

    if (!Util.isUnset(request.escalations)) {
      query["Escalations"] = request.escalations;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "PutResourceMetricRule",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PutResourceMetricRuleResponse>(await this.callApi(params, req, runtime), new PutResourceMetricRuleResponse({}));
  }

  /**
   * Creates an alert rule for a metric of a resource.
   * 
   * @remarks
   * This topic provides an example on how to create a threshold-triggered alert rule for the `cpu_total` metric of an Elastic Compute Service (ECS) instance whose ID is `i-uf6j91r34rnwawoo****`. The namespace of ECS metrics is `acs_ecs_dashboard`. The alert contact group of the alert rule is `ECS_Group`. The name of the alert rule is `test123`. The ID of the alert rule is `a151cd6023eacee2f0978e03863cc1697c89508****`. The statistical method for Critical-level alerts is `Average`. The comparison operator for Critical-level alerts is `GreaterThanOrEqualToThreshold`. The threshold for Critical-level alerts is `90`. The consecutive number of times for which the metric value meets the trigger condition before a Critical-level alert is triggered is `3`.
   * 
   * @param request - PutResourceMetricRuleRequest
   * @returns PutResourceMetricRuleResponse
   */
  async putResourceMetricRule(request: PutResourceMetricRuleRequest): Promise<PutResourceMetricRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.putResourceMetricRuleWithOptions(request, runtime);
  }

  /**
   * Creates multiple alert rules for the specified metric of a specified resource.
   * 
   * @remarks
   * This topic provides an example on how to create a threshold-triggered alert rule for the `cpu_total` metric of an Elastic Compute Service (ECS) instance whose ID is `i-uf6j91r34rnwawoo****`. The namespace of ECS metrics is `acs_ecs_dashboard`. The alert contact group of the alert rule is `ECS_Group`. The name of the alert rule is `test123`. The ID of the alert rule is `a151cd6023eacee2f0978e03863cc1697c89508****`. The statistical method for Critical-level alerts is `Average`. The comparison operator for Critical-level alerts is `GreaterThanOrEqualToThreshold`. The threshold for Critical-level alerts is `90`. The consecutive number of times for which the metric value meets the trigger condition before a Critical-level alert is triggered is `3`.
   * 
   * @param request - PutResourceMetricRulesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns PutResourceMetricRulesResponse
   */
  async putResourceMetricRulesWithOptions(request: PutResourceMetricRulesRequest, runtime: $Util.RuntimeOptions): Promise<PutResourceMetricRulesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.rules)) {
      query["Rules"] = request.rules;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "PutResourceMetricRules",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PutResourceMetricRulesResponse>(await this.callApi(params, req, runtime), new PutResourceMetricRulesResponse({}));
  }

  /**
   * Creates multiple alert rules for the specified metric of a specified resource.
   * 
   * @remarks
   * This topic provides an example on how to create a threshold-triggered alert rule for the `cpu_total` metric of an Elastic Compute Service (ECS) instance whose ID is `i-uf6j91r34rnwawoo****`. The namespace of ECS metrics is `acs_ecs_dashboard`. The alert contact group of the alert rule is `ECS_Group`. The name of the alert rule is `test123`. The ID of the alert rule is `a151cd6023eacee2f0978e03863cc1697c89508****`. The statistical method for Critical-level alerts is `Average`. The comparison operator for Critical-level alerts is `GreaterThanOrEqualToThreshold`. The threshold for Critical-level alerts is `90`. The consecutive number of times for which the metric value meets the trigger condition before a Critical-level alert is triggered is `3`.
   * 
   * @param request - PutResourceMetricRulesRequest
   * @returns PutResourceMetricRulesResponse
   */
  async putResourceMetricRules(request: PutResourceMetricRulesRequest): Promise<PutResourceMetricRulesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.putResourceMetricRulesWithOptions(request, runtime);
  }

  /**
   * Deletes tags.
   * 
   * @param request - RemoveTagsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RemoveTagsResponse
   */
  async removeTagsWithOptions(request: RemoveTagsRequest, runtime: $Util.RuntimeOptions): Promise<RemoveTagsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupIds)) {
      query["GroupIds"] = request.groupIds;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RemoveTags",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RemoveTagsResponse>(await this.callApi(params, req, runtime), new RemoveTagsResponse({}));
  }

  /**
   * Deletes tags.
   * 
   * @param request - RemoveTagsRequest
   * @returns RemoveTagsResponse
   */
  async removeTags(request: RemoveTagsRequest): Promise<RemoveTagsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.removeTagsWithOptions(request, runtime);
  }

  /**
   * @remarks
   * This operation is used to test whether a system event can be triggered as expected. You can call this operation to simulate a system event and check whether an expected response is returned after an alert is triggered by the system event.
   * 
   * @param request - SendDryRunSystemEventRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SendDryRunSystemEventResponse
   */
  async sendDryRunSystemEventWithOptions(request: SendDryRunSystemEventRequest, runtime: $Util.RuntimeOptions): Promise<SendDryRunSystemEventResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.eventContent)) {
      query["EventContent"] = request.eventContent;
    }

    if (!Util.isUnset(request.eventName)) {
      query["EventName"] = request.eventName;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.product)) {
      query["Product"] = request.product;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SendDryRunSystemEvent",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SendDryRunSystemEventResponse>(await this.callApi(params, req, runtime), new SendDryRunSystemEventResponse({}));
  }

  /**
   * @remarks
   * This operation is used to test whether a system event can be triggered as expected. You can call this operation to simulate a system event and check whether an expected response is returned after an alert is triggered by the system event.
   * 
   * @param request - SendDryRunSystemEventRequest
   * @returns SendDryRunSystemEventResponse
   */
  async sendDryRunSystemEvent(request: SendDryRunSystemEventRequest): Promise<SendDryRunSystemEventResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.sendDryRunSystemEventWithOptions(request, runtime);
  }

  /**
   * @remarks
   * >  This API operation is not applicable to ECS instances. To uninstall the agent from an ECS instance, see [Install and uninstall the Cloud Monitor agent](https://help.aliyun.com/document_detail/183482.html).
   * 
   * @param request - UninstallMonitoringAgentRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UninstallMonitoringAgentResponse
   */
  async uninstallMonitoringAgentWithOptions(request: UninstallMonitoringAgentRequest, runtime: $Util.RuntimeOptions): Promise<UninstallMonitoringAgentResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UninstallMonitoringAgent",
      version: "2019-01-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UninstallMonitoringAgentResponse>(await this.callApi(params, req, runtime), new UninstallMonitoringAgentResponse({}));
  }

  /**
   * @remarks
   * >  This API operation is not applicable to ECS instances. To uninstall the agent from an ECS instance, see [Install and uninstall the Cloud Monitor agent](https://help.aliyun.com/document_detail/183482.html).
   * 
   * @param request - UninstallMonitoringAgentRequest
   * @returns UninstallMonitoringAgentResponse
   */
  async uninstallMonitoringAgent(request: UninstallMonitoringAgentRequest): Promise<UninstallMonitoringAgentResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.uninstallMonitoringAgentWithOptions(request, runtime);
  }

}
