// This file is auto-generated, don't edit it
/**
 *
 */
import Util, * as $Util from '@alicloud/tea-util';
import OpenApi, * as $OpenApi from '@alicloud/openapi-client';
import OpenApiUtil from '@alicloud/openapi-util';
import EndpointUtil from '@alicloud/endpoint-util';
import * as $tea from '@alicloud/tea-typescript';

export class AddClusterServiceRequest extends $tea.Model {
  clusterId?: string;
  comment?: string;
  regionId?: string;
  resourceOwnerId?: number;
  service?: AddClusterServiceRequestService[];
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      comment: 'Comment',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      service: 'Service',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      comment: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
      service: { 'type': 'array', 'itemType': AddClusterServiceRequestService },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddClusterServiceResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddClusterServiceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: AddClusterServiceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: AddClusterServiceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddScalingConfigItemV2Request extends $tea.Model {
  configItemInformation?: string;
  configItemType?: string;
  regionId?: string;
  resourceGroupId?: string;
  resourceOwnerId?: number;
  scalingGroupBizId?: string;
  static names(): { [key: string]: string } {
    return {
      configItemInformation: 'ConfigItemInformation',
      configItemType: 'ConfigItemType',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      resourceOwnerId: 'ResourceOwnerId',
      scalingGroupBizId: 'ScalingGroupBizId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configItemInformation: 'string',
      configItemType: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      resourceOwnerId: 'number',
      scalingGroupBizId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddScalingConfigItemV2ResponseBody extends $tea.Model {
  data?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddScalingConfigItemV2Response extends $tea.Model {
  headers: { [key: string]: string };
  body: AddScalingConfigItemV2ResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: AddScalingConfigItemV2ResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AuthorizeSecurityGroupRequest extends $tea.Model {
  bizContent?: string;
  bizType?: string;
  clusterId?: string;
  regionId?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      bizContent: 'BizContent',
      bizType: 'BizType',
      clusterId: 'ClusterId',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizContent: 'string',
      bizType: 'string',
      clusterId: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AuthorizeSecurityGroupResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AuthorizeSecurityGroupResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: AuthorizeSecurityGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: AuthorizeSecurityGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelOrderRequest extends $tea.Model {
  clusterId?: string;
  regionId?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelOrderResponseBody extends $tea.Model {
  requestId?: string;
  clusterId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      clusterId: 'clusterId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      clusterId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelOrderResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CancelOrderResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CancelOrderResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CloneFlowRequest extends $tea.Model {
  id?: string;
  projectId?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      projectId: 'ProjectId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      projectId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CloneFlowResponseBody extends $tea.Model {
  id?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CloneFlowResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CloneFlowResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CloneFlowResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CloneFlowJobRequest extends $tea.Model {
  id?: string;
  name?: string;
  projectId?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      name: 'Name',
      projectId: 'ProjectId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      name: 'string',
      projectId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CloneFlowJobResponseBody extends $tea.Model {
  id?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CloneFlowJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CloneFlowJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CloneFlowJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateBackupRequest extends $tea.Model {
  backupPlanId?: string;
  metadataType?: string;
  regionId?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      backupPlanId: 'BackupPlanId',
      metadataType: 'MetadataType',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      backupPlanId: 'string',
      metadataType: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateBackupResponseBody extends $tea.Model {
  bizId?: string;
  clusterBizId?: string;
  dataSourceId?: number;
  ecmTaskId?: number;
  endTime?: number;
  gmtCreate?: number;
  gmtModified?: number;
  hostName?: string;
  requestId?: string;
  startTime?: number;
  taskDetail?: string;
  taskProcess?: number;
  taskResultDetail?: string;
  taskStatus?: string;
  taskType?: string;
  triggerType?: string;
  triggerUser?: string;
  static names(): { [key: string]: string } {
    return {
      bizId: 'BizId',
      clusterBizId: 'ClusterBizId',
      dataSourceId: 'DataSourceId',
      ecmTaskId: 'EcmTaskId',
      endTime: 'EndTime',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      hostName: 'HostName',
      requestId: 'RequestId',
      startTime: 'StartTime',
      taskDetail: 'TaskDetail',
      taskProcess: 'TaskProcess',
      taskResultDetail: 'TaskResultDetail',
      taskStatus: 'TaskStatus',
      taskType: 'TaskType',
      triggerType: 'TriggerType',
      triggerUser: 'TriggerUser',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizId: 'string',
      clusterBizId: 'string',
      dataSourceId: 'number',
      ecmTaskId: 'number',
      endTime: 'number',
      gmtCreate: 'number',
      gmtModified: 'number',
      hostName: 'string',
      requestId: 'string',
      startTime: 'number',
      taskDetail: 'string',
      taskProcess: 'number',
      taskResultDetail: 'string',
      taskStatus: 'string',
      taskType: 'string',
      triggerType: 'string',
      triggerUser: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateBackupResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateBackupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateBackupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateBackupPlanRequest extends $tea.Model {
  clusterId?: string;
  description?: string;
  name?: string;
  regionId?: string;
  resourceOwnerId?: number;
  rootPath?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      description: 'Description',
      name: 'Name',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      rootPath: 'RootPath',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      description: 'string',
      name: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
      rootPath: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateBackupPlanResponseBody extends $tea.Model {
  clusterId?: string;
  description?: string;
  id?: string;
  name?: string;
  requestId?: string;
  rootPath?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      description: 'Description',
      id: 'Id',
      name: 'Name',
      requestId: 'RequestId',
      rootPath: 'RootPath',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      description: 'string',
      id: 'string',
      name: 'string',
      requestId: 'string',
      rootPath: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateBackupPlanResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateBackupPlanResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateBackupPlanResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateClusterBootstrapActionRequest extends $tea.Model {
  bootstrapAction?: CreateClusterBootstrapActionRequestBootstrapAction[];
  clusterId?: string;
  regionId?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      bootstrapAction: 'BootstrapAction',
      clusterId: 'ClusterId',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bootstrapAction: { 'type': 'array', 'itemType': CreateClusterBootstrapActionRequestBootstrapAction },
      clusterId: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateClusterBootstrapActionResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateClusterBootstrapActionResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateClusterBootstrapActionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateClusterBootstrapActionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateClusterHostGroupRequest extends $tea.Model {
  clusterId?: string;
  comment?: string;
  hostGroupName?: string;
  hostGroupParams?: string;
  hostGroupType?: string;
  payType?: string;
  regionId?: string;
  resourceOwnerId?: number;
  securityGroupId?: string;
  vswitchId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      comment: 'Comment',
      hostGroupName: 'HostGroupName',
      hostGroupParams: 'HostGroupParams',
      hostGroupType: 'HostGroupType',
      payType: 'PayType',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      securityGroupId: 'SecurityGroupId',
      vswitchId: 'VswitchId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      comment: 'string',
      hostGroupName: 'string',
      hostGroupParams: 'string',
      hostGroupType: 'string',
      payType: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
      securityGroupId: 'string',
      vswitchId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateClusterHostGroupResponseBody extends $tea.Model {
  clusterId?: string;
  hostGroupId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      hostGroupId: 'HostGroupId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      hostGroupId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateClusterHostGroupResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateClusterHostGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateClusterHostGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateClusterTemplateRequest extends $tea.Model {
  autoRenew?: boolean;
  bootstrapAction?: CreateClusterTemplateRequestBootstrapAction[];
  clientToken?: string;
  clusterType?: string;
  config?: CreateClusterTemplateRequestConfig[];
  configurations?: string;
  depositType?: string;
  easEnable?: boolean;
  emrVer?: string;
  highAvailabilityEnable?: boolean;
  hostGroup?: CreateClusterTemplateRequestHostGroup[];
  initCustomHiveMetaDb?: boolean;
  instanceGeneration?: string;
  ioOptimized?: boolean;
  isOpenPublicIp?: boolean;
  keyPairName?: string;
  logPath?: string;
  machineType?: string;
  masterPwd?: string;
  metaStoreConf?: string;
  metaStoreType?: string;
  netType?: string;
  optionSoftWareList?: string[];
  period?: number;
  regionId?: string;
  resourceGroupId?: string;
  resourceOwnerId?: number;
  securityGroupId?: string;
  securityGroupName?: string;
  sshEnable?: boolean;
  tag?: CreateClusterTemplateRequestTag[];
  templateName?: string;
  useCustomHiveMetaDb?: boolean;
  useLocalMetaDb?: boolean;
  userDefinedEmrEcsRole?: string;
  vSwitchId?: string;
  vpcId?: string;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      autoRenew: 'AutoRenew',
      bootstrapAction: 'BootstrapAction',
      clientToken: 'ClientToken',
      clusterType: 'ClusterType',
      config: 'Config',
      configurations: 'Configurations',
      depositType: 'DepositType',
      easEnable: 'EasEnable',
      emrVer: 'EmrVer',
      highAvailabilityEnable: 'HighAvailabilityEnable',
      hostGroup: 'HostGroup',
      initCustomHiveMetaDb: 'InitCustomHiveMetaDb',
      instanceGeneration: 'InstanceGeneration',
      ioOptimized: 'IoOptimized',
      isOpenPublicIp: 'IsOpenPublicIp',
      keyPairName: 'KeyPairName',
      logPath: 'LogPath',
      machineType: 'MachineType',
      masterPwd: 'MasterPwd',
      metaStoreConf: 'MetaStoreConf',
      metaStoreType: 'MetaStoreType',
      netType: 'NetType',
      optionSoftWareList: 'OptionSoftWareList',
      period: 'Period',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      resourceOwnerId: 'ResourceOwnerId',
      securityGroupId: 'SecurityGroupId',
      securityGroupName: 'SecurityGroupName',
      sshEnable: 'SshEnable',
      tag: 'Tag',
      templateName: 'TemplateName',
      useCustomHiveMetaDb: 'UseCustomHiveMetaDb',
      useLocalMetaDb: 'UseLocalMetaDb',
      userDefinedEmrEcsRole: 'UserDefinedEmrEcsRole',
      vSwitchId: 'VSwitchId',
      vpcId: 'VpcId',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoRenew: 'boolean',
      bootstrapAction: { 'type': 'array', 'itemType': CreateClusterTemplateRequestBootstrapAction },
      clientToken: 'string',
      clusterType: 'string',
      config: { 'type': 'array', 'itemType': CreateClusterTemplateRequestConfig },
      configurations: 'string',
      depositType: 'string',
      easEnable: 'boolean',
      emrVer: 'string',
      highAvailabilityEnable: 'boolean',
      hostGroup: { 'type': 'array', 'itemType': CreateClusterTemplateRequestHostGroup },
      initCustomHiveMetaDb: 'boolean',
      instanceGeneration: 'string',
      ioOptimized: 'boolean',
      isOpenPublicIp: 'boolean',
      keyPairName: 'string',
      logPath: 'string',
      machineType: 'string',
      masterPwd: 'string',
      metaStoreConf: 'string',
      metaStoreType: 'string',
      netType: 'string',
      optionSoftWareList: { 'type': 'array', 'itemType': 'string' },
      period: 'number',
      regionId: 'string',
      resourceGroupId: 'string',
      resourceOwnerId: 'number',
      securityGroupId: 'string',
      securityGroupName: 'string',
      sshEnable: 'boolean',
      tag: { 'type': 'array', 'itemType': CreateClusterTemplateRequestTag },
      templateName: 'string',
      useCustomHiveMetaDb: 'boolean',
      useLocalMetaDb: 'boolean',
      userDefinedEmrEcsRole: 'string',
      vSwitchId: 'string',
      vpcId: 'string',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateClusterTemplateResponseBody extends $tea.Model {
  clusterTemplateId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterTemplateId: 'ClusterTemplateId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterTemplateId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateClusterTemplateResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateClusterTemplateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateClusterTemplateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateClusterV2Request extends $tea.Model {
  authorizeContent?: string;
  autoPayOrder?: boolean;
  autoRenew?: boolean;
  bootstrapAction?: CreateClusterV2RequestBootstrapAction[];
  chargeType?: string;
  clickHouseConf?: string;
  clientToken?: string;
  clusterType?: string;
  config?: CreateClusterV2RequestConfig[];
  configurations?: string;
  depositType?: string;
  easEnable?: boolean;
  emrVer?: string;
  extraAttributes?: string;
  highAvailabilityEnable?: boolean;
  hostComponentInfo?: CreateClusterV2RequestHostComponentInfo[];
  hostGroup?: CreateClusterV2RequestHostGroup[];
  initCustomHiveMetaDB?: boolean;
  instanceGeneration?: string;
  ioOptimized?: boolean;
  isOpenPublicIp?: boolean;
  keyPairName?: string;
  logPath?: string;
  machineType?: string;
  masterPwd?: string;
  metaStoreConf?: string;
  metaStoreType?: string;
  name?: string;
  netType?: string;
  optionSoftWareList?: string[];
  period?: number;
  promotionInfo?: CreateClusterV2RequestPromotionInfo[];
  regionId?: string;
  relatedClusterId?: string;
  resourceGroupId?: string;
  resourceOwnerId?: number;
  securityGroupId?: string;
  securityGroupName?: string;
  serviceInfo?: CreateClusterV2RequestServiceInfo[];
  sshEnable?: boolean;
  tag?: CreateClusterV2RequestTag[];
  useCustomHiveMetaDB?: boolean;
  useLocalMetaDb?: boolean;
  userDefinedEmrEcsRole?: string;
  userInfo?: CreateClusterV2RequestUserInfo[];
  vSwitchId?: string;
  vpcId?: string;
  whiteListType?: string;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      authorizeContent: 'AuthorizeContent',
      autoPayOrder: 'AutoPayOrder',
      autoRenew: 'AutoRenew',
      bootstrapAction: 'BootstrapAction',
      chargeType: 'ChargeType',
      clickHouseConf: 'ClickHouseConf',
      clientToken: 'ClientToken',
      clusterType: 'ClusterType',
      config: 'Config',
      configurations: 'Configurations',
      depositType: 'DepositType',
      easEnable: 'EasEnable',
      emrVer: 'EmrVer',
      extraAttributes: 'ExtraAttributes',
      highAvailabilityEnable: 'HighAvailabilityEnable',
      hostComponentInfo: 'HostComponentInfo',
      hostGroup: 'HostGroup',
      initCustomHiveMetaDB: 'InitCustomHiveMetaDB',
      instanceGeneration: 'InstanceGeneration',
      ioOptimized: 'IoOptimized',
      isOpenPublicIp: 'IsOpenPublicIp',
      keyPairName: 'KeyPairName',
      logPath: 'LogPath',
      machineType: 'MachineType',
      masterPwd: 'MasterPwd',
      metaStoreConf: 'MetaStoreConf',
      metaStoreType: 'MetaStoreType',
      name: 'Name',
      netType: 'NetType',
      optionSoftWareList: 'OptionSoftWareList',
      period: 'Period',
      promotionInfo: 'PromotionInfo',
      regionId: 'RegionId',
      relatedClusterId: 'RelatedClusterId',
      resourceGroupId: 'ResourceGroupId',
      resourceOwnerId: 'ResourceOwnerId',
      securityGroupId: 'SecurityGroupId',
      securityGroupName: 'SecurityGroupName',
      serviceInfo: 'ServiceInfo',
      sshEnable: 'SshEnable',
      tag: 'Tag',
      useCustomHiveMetaDB: 'UseCustomHiveMetaDB',
      useLocalMetaDb: 'UseLocalMetaDb',
      userDefinedEmrEcsRole: 'UserDefinedEmrEcsRole',
      userInfo: 'UserInfo',
      vSwitchId: 'VSwitchId',
      vpcId: 'VpcId',
      whiteListType: 'WhiteListType',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authorizeContent: 'string',
      autoPayOrder: 'boolean',
      autoRenew: 'boolean',
      bootstrapAction: { 'type': 'array', 'itemType': CreateClusterV2RequestBootstrapAction },
      chargeType: 'string',
      clickHouseConf: 'string',
      clientToken: 'string',
      clusterType: 'string',
      config: { 'type': 'array', 'itemType': CreateClusterV2RequestConfig },
      configurations: 'string',
      depositType: 'string',
      easEnable: 'boolean',
      emrVer: 'string',
      extraAttributes: 'string',
      highAvailabilityEnable: 'boolean',
      hostComponentInfo: { 'type': 'array', 'itemType': CreateClusterV2RequestHostComponentInfo },
      hostGroup: { 'type': 'array', 'itemType': CreateClusterV2RequestHostGroup },
      initCustomHiveMetaDB: 'boolean',
      instanceGeneration: 'string',
      ioOptimized: 'boolean',
      isOpenPublicIp: 'boolean',
      keyPairName: 'string',
      logPath: 'string',
      machineType: 'string',
      masterPwd: 'string',
      metaStoreConf: 'string',
      metaStoreType: 'string',
      name: 'string',
      netType: 'string',
      optionSoftWareList: { 'type': 'array', 'itemType': 'string' },
      period: 'number',
      promotionInfo: { 'type': 'array', 'itemType': CreateClusterV2RequestPromotionInfo },
      regionId: 'string',
      relatedClusterId: 'string',
      resourceGroupId: 'string',
      resourceOwnerId: 'number',
      securityGroupId: 'string',
      securityGroupName: 'string',
      serviceInfo: { 'type': 'array', 'itemType': CreateClusterV2RequestServiceInfo },
      sshEnable: 'boolean',
      tag: { 'type': 'array', 'itemType': CreateClusterV2RequestTag },
      useCustomHiveMetaDB: 'boolean',
      useLocalMetaDb: 'boolean',
      userDefinedEmrEcsRole: 'string',
      userInfo: { 'type': 'array', 'itemType': CreateClusterV2RequestUserInfo },
      vSwitchId: 'string',
      vpcId: 'string',
      whiteListType: 'string',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateClusterV2ResponseBody extends $tea.Model {
  clusterId?: string;
  coreOrderId?: string;
  emrOrderId?: string;
  masterOrderId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      coreOrderId: 'CoreOrderId',
      emrOrderId: 'EmrOrderId',
      masterOrderId: 'MasterOrderId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      coreOrderId: 'string',
      emrOrderId: 'string',
      masterOrderId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateClusterV2Response extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateClusterV2ResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateClusterV2ResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateClusterWithTemplateRequest extends $tea.Model {
  clusterName?: string;
  resourceGroupId?: string;
  resourceOwnerId?: number;
  templateBizId?: string;
  uniqueTag?: string;
  static names(): { [key: string]: string } {
    return {
      clusterName: 'ClusterName',
      resourceGroupId: 'ResourceGroupId',
      resourceOwnerId: 'ResourceOwnerId',
      templateBizId: 'TemplateBizId',
      uniqueTag: 'UniqueTag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterName: 'string',
      resourceGroupId: 'string',
      resourceOwnerId: 'number',
      templateBizId: 'string',
      uniqueTag: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateClusterWithTemplateResponseBody extends $tea.Model {
  clusterId?: string;
  coreOrderId?: string;
  emrOrderId?: string;
  masterOrderId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      coreOrderId: 'CoreOrderId',
      emrOrderId: 'EmrOrderId',
      masterOrderId: 'MasterOrderId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      coreOrderId: 'string',
      emrOrderId: 'string',
      masterOrderId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateClusterWithTemplateResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateClusterWithTemplateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateClusterWithTemplateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataSourceRequest extends $tea.Model {
  clusterId?: string;
  conf?: string;
  description?: string;
  name?: string;
  navParentId?: string;
  regionId?: string;
  resourceGroupId?: string;
  resourceOwnerId?: number;
  sourceType?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      conf: 'Conf',
      description: 'Description',
      name: 'Name',
      navParentId: 'NavParentId',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      resourceOwnerId: 'ResourceOwnerId',
      sourceType: 'SourceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      conf: 'string',
      description: 'string',
      name: 'string',
      navParentId: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      resourceOwnerId: 'number',
      sourceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataSourceResponseBody extends $tea.Model {
  id?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataSourceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateDataSourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateDataSourceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateExecutionPlanRequest extends $tea.Model {
  bootstrapAction?: CreateExecutionPlanRequestBootstrapAction[];
  clusterId?: string;
  clusterName?: string;
  clusterType?: string;
  config?: CreateExecutionPlanRequestConfig[];
  configurations?: string;
  createClusterOnDemand?: boolean;
  dayOfMonth?: string;
  dayOfWeek?: string;
  easEnable?: boolean;
  ecsOrder?: CreateExecutionPlanRequestEcsOrder[];
  emrVer?: string;
  highAvailabilityEnable?: boolean;
  initCustomHiveMetaDB?: boolean;
  instanceGeneration?: string;
  ioOptimized?: boolean;
  isOpenPublicIp?: boolean;
  jobIdList?: string[];
  logEnable?: boolean;
  logPath?: string;
  name?: string;
  netType?: string;
  optionSoftWareList?: string[];
  regionId?: string;
  resourceOwnerId?: number;
  securityGroupId?: string;
  startTime?: number;
  strategy?: string;
  timeInterval?: number;
  timeUnit?: string;
  useCustomHiveMetaDB?: boolean;
  useLocalMetaDb?: boolean;
  userDefinedEmrEcsRole?: string;
  vSwitchId?: string;
  vpcId?: string;
  workflowDefinition?: string;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      bootstrapAction: 'BootstrapAction',
      clusterId: 'ClusterId',
      clusterName: 'ClusterName',
      clusterType: 'ClusterType',
      config: 'Config',
      configurations: 'Configurations',
      createClusterOnDemand: 'CreateClusterOnDemand',
      dayOfMonth: 'DayOfMonth',
      dayOfWeek: 'DayOfWeek',
      easEnable: 'EasEnable',
      ecsOrder: 'EcsOrder',
      emrVer: 'EmrVer',
      highAvailabilityEnable: 'HighAvailabilityEnable',
      initCustomHiveMetaDB: 'InitCustomHiveMetaDB',
      instanceGeneration: 'InstanceGeneration',
      ioOptimized: 'IoOptimized',
      isOpenPublicIp: 'IsOpenPublicIp',
      jobIdList: 'JobIdList',
      logEnable: 'LogEnable',
      logPath: 'LogPath',
      name: 'Name',
      netType: 'NetType',
      optionSoftWareList: 'OptionSoftWareList',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      securityGroupId: 'SecurityGroupId',
      startTime: 'StartTime',
      strategy: 'Strategy',
      timeInterval: 'TimeInterval',
      timeUnit: 'TimeUnit',
      useCustomHiveMetaDB: 'UseCustomHiveMetaDB',
      useLocalMetaDb: 'UseLocalMetaDb',
      userDefinedEmrEcsRole: 'UserDefinedEmrEcsRole',
      vSwitchId: 'VSwitchId',
      vpcId: 'VpcId',
      workflowDefinition: 'WorkflowDefinition',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bootstrapAction: { 'type': 'array', 'itemType': CreateExecutionPlanRequestBootstrapAction },
      clusterId: 'string',
      clusterName: 'string',
      clusterType: 'string',
      config: { 'type': 'array', 'itemType': CreateExecutionPlanRequestConfig },
      configurations: 'string',
      createClusterOnDemand: 'boolean',
      dayOfMonth: 'string',
      dayOfWeek: 'string',
      easEnable: 'boolean',
      ecsOrder: { 'type': 'array', 'itemType': CreateExecutionPlanRequestEcsOrder },
      emrVer: 'string',
      highAvailabilityEnable: 'boolean',
      initCustomHiveMetaDB: 'boolean',
      instanceGeneration: 'string',
      ioOptimized: 'boolean',
      isOpenPublicIp: 'boolean',
      jobIdList: { 'type': 'array', 'itemType': 'string' },
      logEnable: 'boolean',
      logPath: 'string',
      name: 'string',
      netType: 'string',
      optionSoftWareList: { 'type': 'array', 'itemType': 'string' },
      regionId: 'string',
      resourceOwnerId: 'number',
      securityGroupId: 'string',
      startTime: 'number',
      strategy: 'string',
      timeInterval: 'number',
      timeUnit: 'string',
      useCustomHiveMetaDB: 'boolean',
      useLocalMetaDb: 'boolean',
      userDefinedEmrEcsRole: 'string',
      vSwitchId: 'string',
      vpcId: 'string',
      workflowDefinition: 'string',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateExecutionPlanResponseBody extends $tea.Model {
  id?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateExecutionPlanResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateExecutionPlanResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateExecutionPlanResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFlowRequest extends $tea.Model {
  alertConf?: string;
  alertDingDingGroupBizId?: string;
  alertUserGroupBizId?: string;
  application?: string;
  clusterId?: string;
  createCluster?: boolean;
  cronExpr?: string;
  description?: string;
  endSchedule?: number;
  hostName?: string;
  lifecycle?: string;
  logArchiveLocation?: string;
  name?: string;
  namespace?: string;
  parentCategory?: string;
  parentFlowList?: string;
  projectId?: string;
  regionId?: string;
  startSchedule?: number;
  static names(): { [key: string]: string } {
    return {
      alertConf: 'AlertConf',
      alertDingDingGroupBizId: 'AlertDingDingGroupBizId',
      alertUserGroupBizId: 'AlertUserGroupBizId',
      application: 'Application',
      clusterId: 'ClusterId',
      createCluster: 'CreateCluster',
      cronExpr: 'CronExpr',
      description: 'Description',
      endSchedule: 'EndSchedule',
      hostName: 'HostName',
      lifecycle: 'Lifecycle',
      logArchiveLocation: 'LogArchiveLocation',
      name: 'Name',
      namespace: 'Namespace',
      parentCategory: 'ParentCategory',
      parentFlowList: 'ParentFlowList',
      projectId: 'ProjectId',
      regionId: 'RegionId',
      startSchedule: 'StartSchedule',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertConf: 'string',
      alertDingDingGroupBizId: 'string',
      alertUserGroupBizId: 'string',
      application: 'string',
      clusterId: 'string',
      createCluster: 'boolean',
      cronExpr: 'string',
      description: 'string',
      endSchedule: 'number',
      hostName: 'string',
      lifecycle: 'string',
      logArchiveLocation: 'string',
      name: 'string',
      namespace: 'string',
      parentCategory: 'string',
      parentFlowList: 'string',
      projectId: 'string',
      regionId: 'string',
      startSchedule: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFlowResponseBody extends $tea.Model {
  id?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFlowResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateFlowResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateFlowResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFlowCategoryRequest extends $tea.Model {
  name?: string;
  parentId?: string;
  projectId?: string;
  regionId?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      parentId: 'ParentId',
      projectId: 'ProjectId',
      regionId: 'RegionId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      parentId: 'string',
      projectId: 'string',
      regionId: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFlowCategoryResponseBody extends $tea.Model {
  id?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFlowCategoryResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateFlowCategoryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateFlowCategoryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFlowForWebRequest extends $tea.Model {
  alertConf?: string;
  alertDingDingGroupBizId?: string;
  alertUserGroupBizId?: string;
  clusterId?: string;
  createCluster?: boolean;
  cronExpr?: string;
  description?: string;
  endSchedule?: number;
  graph?: string;
  hostName?: string;
  lifecycle?: string;
  logArchiveLocation?: string;
  name?: string;
  namespace?: string;
  parentCategory?: string;
  parentFlowList?: string;
  projectId?: string;
  regionId?: string;
  startSchedule?: number;
  static names(): { [key: string]: string } {
    return {
      alertConf: 'AlertConf',
      alertDingDingGroupBizId: 'AlertDingDingGroupBizId',
      alertUserGroupBizId: 'AlertUserGroupBizId',
      clusterId: 'ClusterId',
      createCluster: 'CreateCluster',
      cronExpr: 'CronExpr',
      description: 'Description',
      endSchedule: 'EndSchedule',
      graph: 'Graph',
      hostName: 'HostName',
      lifecycle: 'Lifecycle',
      logArchiveLocation: 'LogArchiveLocation',
      name: 'Name',
      namespace: 'Namespace',
      parentCategory: 'ParentCategory',
      parentFlowList: 'ParentFlowList',
      projectId: 'ProjectId',
      regionId: 'RegionId',
      startSchedule: 'StartSchedule',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertConf: 'string',
      alertDingDingGroupBizId: 'string',
      alertUserGroupBizId: 'string',
      clusterId: 'string',
      createCluster: 'boolean',
      cronExpr: 'string',
      description: 'string',
      endSchedule: 'number',
      graph: 'string',
      hostName: 'string',
      lifecycle: 'string',
      logArchiveLocation: 'string',
      name: 'string',
      namespace: 'string',
      parentCategory: 'string',
      parentFlowList: 'string',
      projectId: 'string',
      regionId: 'string',
      startSchedule: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFlowForWebResponseBody extends $tea.Model {
  id?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFlowForWebResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateFlowForWebResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateFlowForWebResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFlowJobRequest extends $tea.Model {
  adhoc?: boolean;
  alertConf?: string;
  clusterId?: string;
  customVariables?: string;
  description?: string;
  envConf?: string;
  failAct?: string;
  maxRetry?: number;
  maxRunningTimeSec?: number;
  mode?: string;
  monitorConf?: string;
  name?: string;
  paramConf?: string;
  params?: string;
  parentCategory?: string;
  projectId?: string;
  regionId?: string;
  resourceList?: CreateFlowJobRequestResourceList[];
  retryInterval?: number;
  retryPolicy?: string;
  runConf?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      adhoc: 'Adhoc',
      alertConf: 'AlertConf',
      clusterId: 'ClusterId',
      customVariables: 'CustomVariables',
      description: 'Description',
      envConf: 'EnvConf',
      failAct: 'FailAct',
      maxRetry: 'MaxRetry',
      maxRunningTimeSec: 'MaxRunningTimeSec',
      mode: 'Mode',
      monitorConf: 'MonitorConf',
      name: 'Name',
      paramConf: 'ParamConf',
      params: 'Params',
      parentCategory: 'ParentCategory',
      projectId: 'ProjectId',
      regionId: 'RegionId',
      resourceList: 'ResourceList',
      retryInterval: 'RetryInterval',
      retryPolicy: 'RetryPolicy',
      runConf: 'RunConf',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adhoc: 'boolean',
      alertConf: 'string',
      clusterId: 'string',
      customVariables: 'string',
      description: 'string',
      envConf: 'string',
      failAct: 'string',
      maxRetry: 'number',
      maxRunningTimeSec: 'number',
      mode: 'string',
      monitorConf: 'string',
      name: 'string',
      paramConf: 'string',
      params: 'string',
      parentCategory: 'string',
      projectId: 'string',
      regionId: 'string',
      resourceList: { 'type': 'array', 'itemType': CreateFlowJobRequestResourceList },
      retryInterval: 'number',
      retryPolicy: 'string',
      runConf: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFlowJobResponseBody extends $tea.Model {
  id?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFlowJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateFlowJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateFlowJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFlowProjectRequest extends $tea.Model {
  description?: string;
  name?: string;
  productType?: string;
  regionId?: string;
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      productType: 'ProductType',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      productType: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFlowProjectResponseBody extends $tea.Model {
  id?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFlowProjectResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateFlowProjectResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateFlowProjectResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFlowProjectClusterSettingRequest extends $tea.Model {
  clusterId?: string;
  defaultQueue?: string;
  defaultUser?: string;
  hostList?: string[];
  projectId?: string;
  queueList?: string[];
  regionId?: string;
  userList?: string[];
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      defaultQueue: 'DefaultQueue',
      defaultUser: 'DefaultUser',
      hostList: 'HostList',
      projectId: 'ProjectId',
      queueList: 'QueueList',
      regionId: 'RegionId',
      userList: 'UserList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      defaultQueue: 'string',
      defaultUser: 'string',
      hostList: { 'type': 'array', 'itemType': 'string' },
      projectId: 'string',
      queueList: { 'type': 'array', 'itemType': 'string' },
      regionId: 'string',
      userList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFlowProjectClusterSettingResponseBody extends $tea.Model {
  data?: boolean;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFlowProjectClusterSettingResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateFlowProjectClusterSettingResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateFlowProjectClusterSettingResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFlowProjectUserRequest extends $tea.Model {
  projectId?: string;
  regionId?: string;
  user?: CreateFlowProjectUserRequestUser[];
  static names(): { [key: string]: string } {
    return {
      projectId: 'ProjectId',
      regionId: 'RegionId',
      user: 'User',
    };
  }

  static types(): { [key: string]: any } {
    return {
      projectId: 'string',
      regionId: 'string',
      user: { 'type': 'array', 'itemType': CreateFlowProjectUserRequestUser },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFlowProjectUserResponseBody extends $tea.Model {
  data?: boolean;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFlowProjectUserResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateFlowProjectUserResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateFlowProjectUserResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateJobRequest extends $tea.Model {
  failAct?: string;
  maxRetry?: number;
  name?: string;
  regionId?: string;
  resourceGroupId?: string;
  resourceOwnerId?: number;
  retryInterval?: number;
  runParameter?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      failAct: 'FailAct',
      maxRetry: 'MaxRetry',
      name: 'Name',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      resourceOwnerId: 'ResourceOwnerId',
      retryInterval: 'RetryInterval',
      runParameter: 'RunParameter',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failAct: 'string',
      maxRetry: 'number',
      name: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      resourceOwnerId: 'number',
      retryInterval: 'number',
      runParameter: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateJobResponseBody extends $tea.Model {
  id?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLibraryRequest extends $tea.Model {
  libraryVersion?: string;
  name?: string;
  properties?: string;
  regionId?: string;
  resourceOwnerId?: number;
  scope?: string;
  sourceLocation?: string;
  sourceType?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      libraryVersion: 'LibraryVersion',
      name: 'Name',
      properties: 'Properties',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      scope: 'Scope',
      sourceLocation: 'SourceLocation',
      sourceType: 'SourceType',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      libraryVersion: 'string',
      name: 'string',
      properties: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
      scope: 'string',
      sourceLocation: 'string',
      sourceType: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLibraryResponseBody extends $tea.Model {
  data?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLibraryResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateLibraryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateLibraryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMetaTablePreviewTaskRequest extends $tea.Model {
  clusterId?: string;
  databaseId?: string;
  password?: string;
  regionId?: string;
  resourceGroupId?: string;
  resourceOwnerId?: number;
  tableId?: string;
  user?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      databaseId: 'DatabaseId',
      password: 'Password',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      resourceOwnerId: 'ResourceOwnerId',
      tableId: 'TableId',
      user: 'User',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      databaseId: 'string',
      password: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      resourceOwnerId: 'number',
      tableId: 'string',
      user: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMetaTablePreviewTaskResponseBody extends $tea.Model {
  requestId?: string;
  taskId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      taskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMetaTablePreviewTaskResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateMetaTablePreviewTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateMetaTablePreviewTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateResourcePoolRequest extends $tea.Model {
  active?: boolean;
  clusterId?: string;
  config?: CreateResourcePoolRequestConfig[];
  name?: string;
  note?: string;
  poolType?: string;
  regionId?: string;
  resourceOwnerId?: number;
  yarnSiteConfig?: string;
  static names(): { [key: string]: string } {
    return {
      active: 'Active',
      clusterId: 'ClusterId',
      config: 'Config',
      name: 'Name',
      note: 'Note',
      poolType: 'PoolType',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      yarnSiteConfig: 'YarnSiteConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      active: 'boolean',
      clusterId: 'string',
      config: { 'type': 'array', 'itemType': CreateResourcePoolRequestConfig },
      name: 'string',
      note: 'string',
      poolType: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
      yarnSiteConfig: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateResourcePoolResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateResourcePoolResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateResourcePoolResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateResourcePoolResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateResourceQueueRequest extends $tea.Model {
  clusterId?: string;
  config?: CreateResourceQueueRequestConfig[];
  leaf?: boolean;
  name?: string;
  parentQueueId?: number;
  qualifiedName?: string;
  regionId?: string;
  resourceOwnerId?: number;
  resourcePoolId?: number;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      config: 'Config',
      leaf: 'Leaf',
      name: 'Name',
      parentQueueId: 'ParentQueueId',
      qualifiedName: 'QualifiedName',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      resourcePoolId: 'ResourcePoolId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      config: { 'type': 'array', 'itemType': CreateResourceQueueRequestConfig },
      leaf: 'boolean',
      name: 'string',
      parentQueueId: 'number',
      qualifiedName: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
      resourcePoolId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateResourceQueueResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateResourceQueueResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateResourceQueueResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateResourceQueueResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateScalingGroupV2Request extends $tea.Model {
  description?: string;
  hostGroupId?: string;
  name?: string;
  regionId?: string;
  resourceGroupId?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      hostGroupId: 'HostGroupId',
      name: 'Name',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      hostGroupId: 'string',
      name: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateScalingGroupV2ResponseBody extends $tea.Model {
  data?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateScalingGroupV2Response extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateScalingGroupV2ResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateScalingGroupV2ResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateScalingRuleRequest extends $tea.Model {
  adjustmentType?: string;
  adjustmentValue?: number;
  cloudWatchTrigger?: CreateScalingRuleRequestCloudWatchTrigger[];
  clusterId?: string;
  cooldown?: number;
  hostGroupId?: string;
  launchExpirationTime?: number;
  launchTime?: string;
  recurrenceEndTime?: string;
  recurrenceType?: string;
  recurrenceValue?: string;
  regionId?: string;
  resourceOwnerId?: number;
  ruleCategory?: string;
  ruleName?: string;
  schedulerTrigger?: CreateScalingRuleRequestSchedulerTrigger[];
  timeoutWithGrace?: number;
  withGrace?: boolean;
  static names(): { [key: string]: string } {
    return {
      adjustmentType: 'AdjustmentType',
      adjustmentValue: 'AdjustmentValue',
      cloudWatchTrigger: 'CloudWatchTrigger',
      clusterId: 'ClusterId',
      cooldown: 'Cooldown',
      hostGroupId: 'HostGroupId',
      launchExpirationTime: 'LaunchExpirationTime',
      launchTime: 'LaunchTime',
      recurrenceEndTime: 'RecurrenceEndTime',
      recurrenceType: 'RecurrenceType',
      recurrenceValue: 'RecurrenceValue',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      ruleCategory: 'RuleCategory',
      ruleName: 'RuleName',
      schedulerTrigger: 'SchedulerTrigger',
      timeoutWithGrace: 'TimeoutWithGrace',
      withGrace: 'WithGrace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adjustmentType: 'string',
      adjustmentValue: 'number',
      cloudWatchTrigger: { 'type': 'array', 'itemType': CreateScalingRuleRequestCloudWatchTrigger },
      clusterId: 'string',
      cooldown: 'number',
      hostGroupId: 'string',
      launchExpirationTime: 'number',
      launchTime: 'string',
      recurrenceEndTime: 'string',
      recurrenceType: 'string',
      recurrenceValue: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
      ruleCategory: 'string',
      ruleName: 'string',
      schedulerTrigger: { 'type': 'array', 'itemType': CreateScalingRuleRequestSchedulerTrigger },
      timeoutWithGrace: 'number',
      withGrace: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateScalingRuleResponseBody extends $tea.Model {
  requestId?: string;
  scalingRuleId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      scalingRuleId: 'ScalingRuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      scalingRuleId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateScalingRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateScalingRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateScalingRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTagRequest extends $tea.Model {
  category?: string;
  description?: string;
  id?: number;
  name?: string;
  regionId?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      description: 'Description',
      id: 'Id',
      name: 'Name',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      description: 'string',
      id: 'number',
      name: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTagResponseBody extends $tea.Model {
  data?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTagResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateTagResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateTagResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUserRequest extends $tea.Model {
  aliyunUserId?: string;
  description?: string;
  groupIdList?: number[];
  regionId?: string;
  resourceOwnerId?: number;
  roleIdList?: number[];
  status?: string;
  userAccountParamList?: CreateUserRequestUserAccountParamList[];
  userName?: string;
  userType?: string;
  static names(): { [key: string]: string } {
    return {
      aliyunUserId: 'AliyunUserId',
      description: 'Description',
      groupIdList: 'GroupIdList',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      roleIdList: 'RoleIdList',
      status: 'Status',
      userAccountParamList: 'UserAccountParamList',
      userName: 'UserName',
      userType: 'UserType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunUserId: 'string',
      description: 'string',
      groupIdList: { 'type': 'array', 'itemType': 'number' },
      regionId: 'string',
      resourceOwnerId: 'number',
      roleIdList: { 'type': 'array', 'itemType': 'number' },
      status: 'string',
      userAccountParamList: { 'type': 'array', 'itemType': CreateUserRequestUserAccountParamList },
      userName: 'string',
      userType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUserResponseBody extends $tea.Model {
  data?: boolean;
  paging?: boolean;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      paging: 'Paging',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      paging: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUserResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateUserResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateUserResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUsersRequest extends $tea.Model {
  clusterId?: string;
  regionId?: string;
  resourceOwnerId?: number;
  userInfo?: CreateUsersRequestUserInfo[];
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      userInfo: 'UserInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
      userInfo: { 'type': 'array', 'itemType': CreateUsersRequestUserInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUsersResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUsersResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: CreateUsersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: CreateUsersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DecommissionHostComponentRequest extends $tea.Model {
  clusterId?: string;
  componentName?: string;
  hostInstanceId?: string;
  regionId?: string;
  resourceOwnerId?: number;
  serviceName?: string;
  timeoutSeconds?: number;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      componentName: 'ComponentName',
      hostInstanceId: 'HostInstanceId',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      serviceName: 'ServiceName',
      timeoutSeconds: 'TimeoutSeconds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      componentName: 'string',
      hostInstanceId: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
      serviceName: 'string',
      timeoutSeconds: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DecommissionHostComponentResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DecommissionHostComponentResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DecommissionHostComponentResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DecommissionHostComponentResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteClusterTemplateRequest extends $tea.Model {
  bizId?: string;
  regionId?: string;
  resourceGroupId?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      bizId: 'BizId',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizId: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteClusterTemplateResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteClusterTemplateResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteClusterTemplateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteClusterTemplateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteExecutionPlanRequest extends $tea.Model {
  id?: string;
  regionId?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteExecutionPlanResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteExecutionPlanResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteExecutionPlanResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteExecutionPlanResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteFlowRequest extends $tea.Model {
  id?: string;
  projectId?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      projectId: 'ProjectId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      projectId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteFlowResponseBody extends $tea.Model {
  data?: boolean;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteFlowResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteFlowResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteFlowResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteFlowCategoryRequest extends $tea.Model {
  id?: string;
  projectId?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      projectId: 'ProjectId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      projectId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteFlowCategoryResponseBody extends $tea.Model {
  data?: boolean;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteFlowCategoryResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteFlowCategoryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteFlowCategoryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteFlowJobRequest extends $tea.Model {
  id?: string;
  projectId?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      projectId: 'ProjectId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      projectId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteFlowJobResponseBody extends $tea.Model {
  data?: boolean;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteFlowJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteFlowJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteFlowJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteFlowProjectRequest extends $tea.Model {
  projectId?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      projectId: 'ProjectId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      projectId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteFlowProjectResponseBody extends $tea.Model {
  data?: boolean;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteFlowProjectResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteFlowProjectResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteFlowProjectResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteFlowProjectClusterSettingRequest extends $tea.Model {
  clusterId?: string;
  projectId?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      projectId: 'ProjectId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      projectId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteFlowProjectClusterSettingResponseBody extends $tea.Model {
  data?: boolean;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteFlowProjectClusterSettingResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteFlowProjectClusterSettingResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteFlowProjectClusterSettingResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteFlowProjectUserRequest extends $tea.Model {
  projectId?: string;
  regionId?: string;
  userName?: string;
  static names(): { [key: string]: string } {
    return {
      projectId: 'ProjectId',
      regionId: 'RegionId',
      userName: 'UserName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      projectId: 'string',
      regionId: 'string',
      userName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteFlowProjectUserResponseBody extends $tea.Model {
  data?: boolean;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteFlowProjectUserResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteFlowProjectUserResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteFlowProjectUserResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteJobRequest extends $tea.Model {
  id?: string;
  regionId?: string;
  resourceGroupId?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteJobResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLibrariesRequest extends $tea.Model {
  libraryBizIdList?: string[];
  regionId?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      libraryBizIdList: 'LibraryBizIdList',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      libraryBizIdList: { 'type': 'array', 'itemType': 'string' },
      regionId: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLibrariesResponseBody extends $tea.Model {
  data?: boolean;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLibrariesResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteLibrariesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteLibrariesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteResourcePoolRequest extends $tea.Model {
  clusterId?: string;
  regionId?: string;
  resourceOwnerId?: number;
  resourcePoolId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      resourcePoolId: 'ResourcePoolId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
      resourcePoolId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteResourcePoolResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteResourcePoolResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteResourcePoolResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteResourcePoolResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteResourceQueueRequest extends $tea.Model {
  clusterId?: string;
  regionId?: string;
  resourceOwnerId?: number;
  resourceQueueId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      resourceQueueId: 'ResourceQueueId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
      resourceQueueId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteResourceQueueResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteResourceQueueResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteResourceQueueResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteResourceQueueResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteScalingRuleRequest extends $tea.Model {
  clusterId?: string;
  hostGroupId?: string;
  regionId?: string;
  resourceOwnerId?: number;
  scalingRuleId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      hostGroupId: 'HostGroupId',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      scalingRuleId: 'ScalingRuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      hostGroupId: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
      scalingRuleId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteScalingRuleResponseBody extends $tea.Model {
  data?: boolean;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteScalingRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteScalingRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteScalingRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTagRequest extends $tea.Model {
  category?: string;
  description?: string;
  id?: number;
  name?: string;
  regionId?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      description: 'Description',
      id: 'Id',
      name: 'Name',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      description: 'string',
      id: 'number',
      name: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTagResponseBody extends $tea.Model {
  data?: boolean;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTagResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteTagResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteTagResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteUserRequest extends $tea.Model {
  clusterId?: string;
  regionId?: string;
  resourceOwnerId?: number;
  type?: string;
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      type: 'Type',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
      type: 'string',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteUserResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteUserResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DeleteUserResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DeleteUserResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterBasicInfoRequest extends $tea.Model {
  clusterId?: string;
  regionId?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterBasicInfoResponseBody extends $tea.Model {
  clusterInfo?: DescribeClusterBasicInfoResponseBodyClusterInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterInfo: 'ClusterInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterInfo: DescribeClusterBasicInfoResponseBodyClusterInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterBasicInfoResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeClusterBasicInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeClusterBasicInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterMetaCollectRequest extends $tea.Model {
  clusterId?: string;
  regionId?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterMetaCollectResponseBody extends $tea.Model {
  clusterId?: string;
  metaStoreType?: string;
  requestId?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      metaStoreType: 'MetaStoreType',
      requestId: 'RequestId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      metaStoreType: 'string',
      requestId: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterMetaCollectResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeClusterMetaCollectResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeClusterMetaCollectResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterOperationHostTaskLogRequest extends $tea.Model {
  clusterId?: string;
  hostId?: string;
  operationId?: string;
  regionId?: string;
  resourceOwnerId?: number;
  status?: string;
  taskId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      hostId: 'HostId',
      operationId: 'OperationId',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      status: 'Status',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      hostId: 'string',
      operationId: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
      status: 'string',
      taskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterOperationHostTaskLogResponseBody extends $tea.Model {
  requestId?: string;
  stderr?: string;
  stdout?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      stderr: 'Stderr',
      stdout: 'Stdout',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      stderr: 'string',
      stdout: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterOperationHostTaskLogResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeClusterOperationHostTaskLogResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeClusterOperationHostTaskLogResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterResourcePoolSchedulerTypeRequest extends $tea.Model {
  clusterId?: string;
  regionId?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterResourcePoolSchedulerTypeResponseBody extends $tea.Model {
  currentSchedulerType?: string;
  defaultSchedulerType?: string;
  requestId?: string;
  supportSchedulerType?: string;
  static names(): { [key: string]: string } {
    return {
      currentSchedulerType: 'CurrentSchedulerType',
      defaultSchedulerType: 'DefaultSchedulerType',
      requestId: 'RequestId',
      supportSchedulerType: 'SupportSchedulerType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentSchedulerType: 'string',
      defaultSchedulerType: 'string',
      requestId: 'string',
      supportSchedulerType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterResourcePoolSchedulerTypeResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeClusterResourcePoolSchedulerTypeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeClusterResourcePoolSchedulerTypeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterServiceRequest extends $tea.Model {
  clusterId?: string;
  regionId?: string;
  resourceOwnerId?: number;
  serviceName?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      serviceName: 'ServiceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
      serviceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterServiceResponseBody extends $tea.Model {
  requestId?: string;
  serviceInfo?: DescribeClusterServiceResponseBodyServiceInfo;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      serviceInfo: 'ServiceInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      serviceInfo: DescribeClusterServiceResponseBodyServiceInfo,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterServiceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeClusterServiceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeClusterServiceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterServiceConfigRequest extends $tea.Model {
  clusterId?: string;
  configVersion?: string;
  groupId?: string;
  hostInstanceId?: string;
  regionId?: string;
  resourceOwnerId?: number;
  serviceName?: string;
  tagValue?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      configVersion: 'ConfigVersion',
      groupId: 'GroupId',
      hostInstanceId: 'HostInstanceId',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      serviceName: 'ServiceName',
      tagValue: 'TagValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      configVersion: 'string',
      groupId: 'string',
      hostInstanceId: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
      serviceName: 'string',
      tagValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterServiceConfigResponseBody extends $tea.Model {
  config?: DescribeClusterServiceConfigResponseBodyConfig;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      config: 'Config',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      config: DescribeClusterServiceConfigResponseBodyConfig,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterServiceConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeClusterServiceConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeClusterServiceConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterServiceConfigHistoryRequest extends $tea.Model {
  clusterId?: string;
  configVersion?: string;
  regionId?: string;
  resourceOwnerId?: number;
  serviceName?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      configVersion: 'ConfigVersion',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      serviceName: 'ServiceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      configVersion: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
      serviceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterServiceConfigHistoryResponseBody extends $tea.Model {
  config?: DescribeClusterServiceConfigHistoryResponseBodyConfig;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      config: 'Config',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      config: DescribeClusterServiceConfigHistoryResponseBodyConfig,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterServiceConfigHistoryResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeClusterServiceConfigHistoryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeClusterServiceConfigHistoryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterServiceConfigTagRequest extends $tea.Model {
  clusterId?: string;
  configTag?: string;
  regionId?: string;
  resourceOwnerId?: number;
  serviceName?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      configTag: 'ConfigTag',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      serviceName: 'ServiceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      configTag: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
      serviceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterServiceConfigTagResponseBody extends $tea.Model {
  configTagList?: DescribeClusterServiceConfigTagResponseBodyConfigTagList;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      configTagList: 'ConfigTagList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configTagList: DescribeClusterServiceConfigTagResponseBodyConfigTagList,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterServiceConfigTagResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeClusterServiceConfigTagResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeClusterServiceConfigTagResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterTemplateRequest extends $tea.Model {
  bizId?: string;
  resourceGroupId?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      bizId: 'BizId',
      resourceGroupId: 'ResourceGroupId',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizId: 'string',
      resourceGroupId: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterTemplateResponseBody extends $tea.Model {
  requestId?: string;
  templateInfo?: DescribeClusterTemplateResponseBodyTemplateInfo;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      templateInfo: 'TemplateInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      templateInfo: DescribeClusterTemplateResponseBodyTemplateInfo,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterTemplateResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeClusterTemplateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeClusterTemplateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterV2Request extends $tea.Model {
  id?: string;
  regionId?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterV2ResponseBody extends $tea.Model {
  clusterInfo?: DescribeClusterV2ResponseBodyClusterInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterInfo: 'ClusterInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterInfo: DescribeClusterV2ResponseBodyClusterInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterV2Response extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeClusterV2ResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeClusterV2ResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDataSourceRequest extends $tea.Model {
  id?: string;
  regionId?: string;
  resourceGroupId?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDataSourceResponseBody extends $tea.Model {
  categoryId?: string;
  clusterId?: string;
  conf?: string;
  createFrom?: string;
  creator?: string;
  description?: string;
  gmtCreate?: number;
  gmtModified?: number;
  id?: string;
  modifier?: string;
  name?: string;
  requestId?: string;
  sourceType?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      categoryId: 'CategoryId',
      clusterId: 'ClusterId',
      conf: 'Conf',
      createFrom: 'CreateFrom',
      creator: 'Creator',
      description: 'Description',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      id: 'Id',
      modifier: 'Modifier',
      name: 'Name',
      requestId: 'RequestId',
      sourceType: 'SourceType',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      categoryId: 'string',
      clusterId: 'string',
      conf: 'string',
      createFrom: 'string',
      creator: 'string',
      description: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      id: 'string',
      modifier: 'string',
      name: 'string',
      requestId: 'string',
      sourceType: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDataSourceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeDataSourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeDataSourceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDiskOpsActivityRequest extends $tea.Model {
  clusterId?: string;
  currentStage?: string;
  currentState?: string;
  diskId?: string;
  eventId?: string;
  instanceId?: string;
  regionId?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      currentStage: 'CurrentStage',
      currentState: 'CurrentState',
      diskId: 'DiskId',
      eventId: 'EventId',
      instanceId: 'InstanceId',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      currentStage: 'string',
      currentState: 'string',
      diskId: 'string',
      eventId: 'string',
      instanceId: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDiskOpsActivityResponseBody extends $tea.Model {
  activityState?: string;
  clusterType?: string;
  currentActivity?: string;
  errorMessage?: string;
  needReboot?: boolean;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      activityState: 'ActivityState',
      clusterType: 'ClusterType',
      currentActivity: 'CurrentActivity',
      errorMessage: 'ErrorMessage',
      needReboot: 'NeedReboot',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      activityState: 'string',
      clusterType: 'string',
      currentActivity: 'string',
      errorMessage: 'string',
      needReboot: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDiskOpsActivityResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeDiskOpsActivityResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeDiskOpsActivityResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEmrMainVersionRequest extends $tea.Model {
  emrVersion?: string;
  regionId?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      emrVersion: 'EmrVersion',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      emrVersion: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEmrMainVersionResponseBody extends $tea.Model {
  emrMainVersion?: DescribeEmrMainVersionResponseBodyEmrMainVersion;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      emrMainVersion: 'EmrMainVersion',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      emrMainVersion: DescribeEmrMainVersionResponseBodyEmrMainVersion,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEmrMainVersionResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeEmrMainVersionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeEmrMainVersionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExecutionPlanRequest extends $tea.Model {
  id?: string;
  regionId?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExecutionPlanResponseBody extends $tea.Model {
  clusterId?: string;
  clusterInfo?: DescribeExecutionPlanResponseBodyClusterInfo;
  clusterName?: string;
  createClusterOnDemand?: boolean;
  dayOfMonth?: string;
  dayOfWeek?: string;
  executionPlanVersion?: number;
  id?: string;
  jobInfoList?: DescribeExecutionPlanResponseBodyJobInfoList;
  name?: string;
  requestId?: string;
  startTime?: number;
  status?: string;
  strategy?: string;
  timeInterval?: number;
  timeUnit?: string;
  workflowApp?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      clusterInfo: 'ClusterInfo',
      clusterName: 'ClusterName',
      createClusterOnDemand: 'CreateClusterOnDemand',
      dayOfMonth: 'DayOfMonth',
      dayOfWeek: 'DayOfWeek',
      executionPlanVersion: 'ExecutionPlanVersion',
      id: 'Id',
      jobInfoList: 'JobInfoList',
      name: 'Name',
      requestId: 'RequestId',
      startTime: 'StartTime',
      status: 'Status',
      strategy: 'Strategy',
      timeInterval: 'TimeInterval',
      timeUnit: 'TimeUnit',
      workflowApp: 'WorkflowApp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      clusterInfo: DescribeExecutionPlanResponseBodyClusterInfo,
      clusterName: 'string',
      createClusterOnDemand: 'boolean',
      dayOfMonth: 'string',
      dayOfWeek: 'string',
      executionPlanVersion: 'number',
      id: 'string',
      jobInfoList: DescribeExecutionPlanResponseBodyJobInfoList,
      name: 'string',
      requestId: 'string',
      startTime: 'number',
      status: 'string',
      strategy: 'string',
      timeInterval: 'number',
      timeUnit: 'string',
      workflowApp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExecutionPlanResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeExecutionPlanResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeExecutionPlanResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFlowRequest extends $tea.Model {
  id?: string;
  projectId?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      projectId: 'ProjectId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      projectId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFlowResponseBody extends $tea.Model {
  alertConf?: string;
  alertDingDingGroupBizId?: string;
  alertUserGroupBizId?: string;
  application?: string;
  categoryId?: string;
  clusterId?: string;
  createCluster?: boolean;
  cronExpr?: string;
  description?: string;
  editLockDetail?: string;
  endSchedule?: number;
  gmtCreate?: number;
  gmtModified?: number;
  graph?: string;
  hostName?: string;
  id?: string;
  lifecycle?: string;
  logArchiveLocation?: string;
  name?: string;
  namespace?: string;
  parentFlowList?: DescribeFlowResponseBodyParentFlowList;
  periodic?: boolean;
  requestId?: string;
  startSchedule?: number;
  status?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      alertConf: 'AlertConf',
      alertDingDingGroupBizId: 'AlertDingDingGroupBizId',
      alertUserGroupBizId: 'AlertUserGroupBizId',
      application: 'Application',
      categoryId: 'CategoryId',
      clusterId: 'ClusterId',
      createCluster: 'CreateCluster',
      cronExpr: 'CronExpr',
      description: 'Description',
      editLockDetail: 'EditLockDetail',
      endSchedule: 'EndSchedule',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      graph: 'Graph',
      hostName: 'HostName',
      id: 'Id',
      lifecycle: 'Lifecycle',
      logArchiveLocation: 'LogArchiveLocation',
      name: 'Name',
      namespace: 'Namespace',
      parentFlowList: 'ParentFlowList',
      periodic: 'Periodic',
      requestId: 'RequestId',
      startSchedule: 'StartSchedule',
      status: 'Status',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertConf: 'string',
      alertDingDingGroupBizId: 'string',
      alertUserGroupBizId: 'string',
      application: 'string',
      categoryId: 'string',
      clusterId: 'string',
      createCluster: 'boolean',
      cronExpr: 'string',
      description: 'string',
      editLockDetail: 'string',
      endSchedule: 'number',
      gmtCreate: 'number',
      gmtModified: 'number',
      graph: 'string',
      hostName: 'string',
      id: 'string',
      lifecycle: 'string',
      logArchiveLocation: 'string',
      name: 'string',
      namespace: 'string',
      parentFlowList: DescribeFlowResponseBodyParentFlowList,
      periodic: 'boolean',
      requestId: 'string',
      startSchedule: 'number',
      status: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFlowResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeFlowResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeFlowResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFlowCategoryRequest extends $tea.Model {
  id?: string;
  projectId?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      projectId: 'ProjectId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      projectId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFlowCategoryResponseBody extends $tea.Model {
  categoryType?: string;
  gmtCreate?: number;
  gmtModified?: number;
  id?: string;
  name?: string;
  objectId?: string;
  objectType?: string;
  parentId?: string;
  projectId?: string;
  requestId?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      categoryType: 'CategoryType',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      id: 'Id',
      name: 'Name',
      objectId: 'ObjectId',
      objectType: 'ObjectType',
      parentId: 'ParentId',
      projectId: 'ProjectId',
      requestId: 'RequestId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      categoryType: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      id: 'string',
      name: 'string',
      objectId: 'string',
      objectType: 'string',
      parentId: 'string',
      projectId: 'string',
      requestId: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFlowCategoryResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeFlowCategoryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeFlowCategoryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFlowCategoryTreeRequest extends $tea.Model {
  categoryId?: string;
  keyword?: string;
  mode?: string;
  projectId?: string;
  regionId?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      categoryId: 'CategoryId',
      keyword: 'Keyword',
      mode: 'Mode',
      projectId: 'ProjectId',
      regionId: 'RegionId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      categoryId: 'string',
      keyword: 'string',
      mode: 'string',
      projectId: 'string',
      regionId: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFlowCategoryTreeResponseBody extends $tea.Model {
  data?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFlowCategoryTreeResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeFlowCategoryTreeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeFlowCategoryTreeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFlowInstanceRequest extends $tea.Model {
  id?: string;
  projectId?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      projectId: 'ProjectId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      projectId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFlowInstanceResponseBody extends $tea.Model {
  clusterId?: string;
  cronExpression?: string;
  dependencyFlowList?: DescribeFlowInstanceResponseBodyDependencyFlowList;
  duration?: number;
  endTime?: number;
  flowId?: string;
  flowName?: string;
  gmtCreate?: number;
  gmtModified?: number;
  graph?: string;
  hasNodeFailed?: boolean;
  id?: string;
  lifecycle?: string;
  logArchiveLocation?: string;
  namespace?: string;
  nodeInstance?: DescribeFlowInstanceResponseBodyNodeInstance;
  projectId?: string;
  requestId?: string;
  scheduleTime?: number;
  startTime?: number;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      cronExpression: 'CronExpression',
      dependencyFlowList: 'DependencyFlowList',
      duration: 'Duration',
      endTime: 'EndTime',
      flowId: 'FlowId',
      flowName: 'FlowName',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      graph: 'Graph',
      hasNodeFailed: 'HasNodeFailed',
      id: 'Id',
      lifecycle: 'Lifecycle',
      logArchiveLocation: 'LogArchiveLocation',
      namespace: 'Namespace',
      nodeInstance: 'NodeInstance',
      projectId: 'ProjectId',
      requestId: 'RequestId',
      scheduleTime: 'ScheduleTime',
      startTime: 'StartTime',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      cronExpression: 'string',
      dependencyFlowList: DescribeFlowInstanceResponseBodyDependencyFlowList,
      duration: 'number',
      endTime: 'number',
      flowId: 'string',
      flowName: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      graph: 'string',
      hasNodeFailed: 'boolean',
      id: 'string',
      lifecycle: 'string',
      logArchiveLocation: 'string',
      namespace: 'string',
      nodeInstance: DescribeFlowInstanceResponseBodyNodeInstance,
      projectId: 'string',
      requestId: 'string',
      scheduleTime: 'number',
      startTime: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFlowInstanceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeFlowInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeFlowInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFlowJobRequest extends $tea.Model {
  id?: string;
  projectId?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      projectId: 'ProjectId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      projectId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFlowJobResponseBody extends $tea.Model {
  adhoc?: string;
  alertConf?: string;
  categoryId?: string;
  customVariables?: string;
  description?: string;
  editLockDetail?: string;
  envConf?: string;
  failAct?: string;
  gmtCreate?: number;
  gmtModified?: number;
  id?: string;
  lastInstanceId?: string;
  maxRetry?: number;
  maxRunningTimeSec?: number;
  monitorConf?: string;
  name?: string;
  paramConf?: string;
  params?: string;
  requestId?: string;
  resourceList?: DescribeFlowJobResponseBodyResourceList;
  retryInterval?: number;
  retryPolicy?: string;
  runConf?: string;
  type?: string;
  mode?: string;
  static names(): { [key: string]: string } {
    return {
      adhoc: 'Adhoc',
      alertConf: 'AlertConf',
      categoryId: 'CategoryId',
      customVariables: 'CustomVariables',
      description: 'Description',
      editLockDetail: 'EditLockDetail',
      envConf: 'EnvConf',
      failAct: 'FailAct',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      id: 'Id',
      lastInstanceId: 'LastInstanceId',
      maxRetry: 'MaxRetry',
      maxRunningTimeSec: 'MaxRunningTimeSec',
      monitorConf: 'MonitorConf',
      name: 'Name',
      paramConf: 'ParamConf',
      params: 'Params',
      requestId: 'RequestId',
      resourceList: 'ResourceList',
      retryInterval: 'RetryInterval',
      retryPolicy: 'RetryPolicy',
      runConf: 'RunConf',
      type: 'Type',
      mode: 'mode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adhoc: 'string',
      alertConf: 'string',
      categoryId: 'string',
      customVariables: 'string',
      description: 'string',
      editLockDetail: 'string',
      envConf: 'string',
      failAct: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      id: 'string',
      lastInstanceId: 'string',
      maxRetry: 'number',
      maxRunningTimeSec: 'number',
      monitorConf: 'string',
      name: 'string',
      paramConf: 'string',
      params: 'string',
      requestId: 'string',
      resourceList: DescribeFlowJobResponseBodyResourceList,
      retryInterval: 'number',
      retryPolicy: 'string',
      runConf: 'string',
      type: 'string',
      mode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFlowJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeFlowJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeFlowJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFlowNodeInstanceRequest extends $tea.Model {
  id?: string;
  projectId?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      projectId: 'ProjectId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      projectId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFlowNodeInstanceResponseBody extends $tea.Model {
  adhoc?: boolean;
  clusterId?: string;
  clusterName?: string;
  duration?: number;
  endTime?: number;
  envConf?: string;
  externalChildIds?: string;
  externalId?: string;
  externalInfo?: string;
  externalStatus?: string;
  externalSubId?: string;
  failAct?: string;
  flowId?: string;
  flowInstanceId?: string;
  gmtCreate?: number;
  gmtModified?: number;
  hostName?: string;
  id?: string;
  jobId?: string;
  jobName?: string;
  jobParams?: string;
  jobType?: string;
  maxRetry?: string;
  mode?: string;
  monitorConf?: string;
  nodeName?: string;
  paramConf?: string;
  pending?: boolean;
  projectId?: string;
  requestId?: string;
  retries?: number;
  retryInterval?: string;
  retryPolicy?: string;
  runConf?: string;
  startTime?: number;
  status?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      adhoc: 'Adhoc',
      clusterId: 'ClusterId',
      clusterName: 'ClusterName',
      duration: 'Duration',
      endTime: 'EndTime',
      envConf: 'EnvConf',
      externalChildIds: 'ExternalChildIds',
      externalId: 'ExternalId',
      externalInfo: 'ExternalInfo',
      externalStatus: 'ExternalStatus',
      externalSubId: 'ExternalSubId',
      failAct: 'FailAct',
      flowId: 'FlowId',
      flowInstanceId: 'FlowInstanceId',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      hostName: 'HostName',
      id: 'Id',
      jobId: 'JobId',
      jobName: 'JobName',
      jobParams: 'JobParams',
      jobType: 'JobType',
      maxRetry: 'MaxRetry',
      mode: 'Mode',
      monitorConf: 'MonitorConf',
      nodeName: 'NodeName',
      paramConf: 'ParamConf',
      pending: 'Pending',
      projectId: 'ProjectId',
      requestId: 'RequestId',
      retries: 'Retries',
      retryInterval: 'RetryInterval',
      retryPolicy: 'RetryPolicy',
      runConf: 'RunConf',
      startTime: 'StartTime',
      status: 'Status',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adhoc: 'boolean',
      clusterId: 'string',
      clusterName: 'string',
      duration: 'number',
      endTime: 'number',
      envConf: 'string',
      externalChildIds: 'string',
      externalId: 'string',
      externalInfo: 'string',
      externalStatus: 'string',
      externalSubId: 'string',
      failAct: 'string',
      flowId: 'string',
      flowInstanceId: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      hostName: 'string',
      id: 'string',
      jobId: 'string',
      jobName: 'string',
      jobParams: 'string',
      jobType: 'string',
      maxRetry: 'string',
      mode: 'string',
      monitorConf: 'string',
      nodeName: 'string',
      paramConf: 'string',
      pending: 'boolean',
      projectId: 'string',
      requestId: 'string',
      retries: 'number',
      retryInterval: 'string',
      retryPolicy: 'string',
      runConf: 'string',
      startTime: 'number',
      status: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFlowNodeInstanceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeFlowNodeInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeFlowNodeInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFlowNodeInstanceContainerLogRequest extends $tea.Model {
  appId?: string;
  containerId?: string;
  length?: number;
  logName?: string;
  nodeInstanceId?: string;
  offset?: number;
  projectId?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      containerId: 'ContainerId',
      length: 'Length',
      logName: 'LogName',
      nodeInstanceId: 'NodeInstanceId',
      offset: 'Offset',
      projectId: 'ProjectId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      containerId: 'string',
      length: 'number',
      logName: 'string',
      nodeInstanceId: 'string',
      offset: 'number',
      projectId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFlowNodeInstanceContainerLogResponseBody extends $tea.Model {
  logEnd?: boolean;
  logEntrys?: DescribeFlowNodeInstanceContainerLogResponseBodyLogEntrys;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      logEnd: 'LogEnd',
      logEntrys: 'LogEntrys',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logEnd: 'boolean',
      logEntrys: DescribeFlowNodeInstanceContainerLogResponseBodyLogEntrys,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFlowNodeInstanceContainerLogResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeFlowNodeInstanceContainerLogResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeFlowNodeInstanceContainerLogResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFlowNodeInstanceLauncherLogRequest extends $tea.Model {
  endTime?: number;
  length?: number;
  lines?: number;
  nodeInstanceId?: string;
  offset?: number;
  projectId?: string;
  regionId?: string;
  reverse?: boolean;
  start?: number;
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      length: 'Length',
      lines: 'Lines',
      nodeInstanceId: 'NodeInstanceId',
      offset: 'Offset',
      projectId: 'ProjectId',
      regionId: 'RegionId',
      reverse: 'Reverse',
      start: 'Start',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      length: 'number',
      lines: 'number',
      nodeInstanceId: 'string',
      offset: 'number',
      projectId: 'string',
      regionId: 'string',
      reverse: 'boolean',
      start: 'number',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFlowNodeInstanceLauncherLogResponseBody extends $tea.Model {
  logEnd?: boolean;
  logEntrys?: DescribeFlowNodeInstanceLauncherLogResponseBodyLogEntrys;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      logEnd: 'LogEnd',
      logEntrys: 'LogEntrys',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logEnd: 'boolean',
      logEntrys: DescribeFlowNodeInstanceLauncherLogResponseBodyLogEntrys,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFlowNodeInstanceLauncherLogResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeFlowNodeInstanceLauncherLogResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeFlowNodeInstanceLauncherLogResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFlowProjectRequest extends $tea.Model {
  projectId?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      projectId: 'ProjectId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      projectId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFlowProjectResponseBody extends $tea.Model {
  description?: string;
  gmtCreate?: number;
  gmtModified?: number;
  id?: string;
  name?: string;
  requestId?: string;
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      id: 'Id',
      name: 'Name',
      requestId: 'RequestId',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      id: 'string',
      name: 'string',
      requestId: 'string',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFlowProjectResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeFlowProjectResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeFlowProjectResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFlowProjectClusterSettingRequest extends $tea.Model {
  clusterId?: string;
  projectId?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      projectId: 'ProjectId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      projectId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFlowProjectClusterSettingResponseBody extends $tea.Model {
  clusterId?: string;
  defaultQueue?: string;
  defaultUser?: string;
  gmtCreate?: number;
  gmtModified?: number;
  hostList?: DescribeFlowProjectClusterSettingResponseBodyHostList;
  k8sClusterId?: string;
  projectId?: string;
  queueList?: DescribeFlowProjectClusterSettingResponseBodyQueueList;
  requestId?: string;
  userList?: DescribeFlowProjectClusterSettingResponseBodyUserList;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      defaultQueue: 'DefaultQueue',
      defaultUser: 'DefaultUser',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      hostList: 'HostList',
      k8sClusterId: 'K8sClusterId',
      projectId: 'ProjectId',
      queueList: 'QueueList',
      requestId: 'RequestId',
      userList: 'UserList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      defaultQueue: 'string',
      defaultUser: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      hostList: DescribeFlowProjectClusterSettingResponseBodyHostList,
      k8sClusterId: 'string',
      projectId: 'string',
      queueList: DescribeFlowProjectClusterSettingResponseBodyQueueList,
      requestId: 'string',
      userList: DescribeFlowProjectClusterSettingResponseBodyUserList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFlowProjectClusterSettingResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeFlowProjectClusterSettingResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeFlowProjectClusterSettingResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeJobRequest extends $tea.Model {
  id?: string;
  regionId?: string;
  resourceGroupId?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeJobResponseBody extends $tea.Model {
  failAct?: string;
  id?: string;
  maxRetry?: number;
  name?: string;
  requestId?: string;
  retryInterval?: number;
  runParameter?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      failAct: 'FailAct',
      id: 'Id',
      maxRetry: 'MaxRetry',
      name: 'Name',
      requestId: 'RequestId',
      retryInterval: 'RetryInterval',
      runParameter: 'RunParameter',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failAct: 'string',
      id: 'string',
      maxRetry: 'number',
      name: 'string',
      requestId: 'string',
      retryInterval: 'number',
      runParameter: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLibraryDetailRequest extends $tea.Model {
  libraryBizId?: string;
  regionId?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      libraryBizId: 'LibraryBizId',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      libraryBizId: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLibraryDetailResponseBody extends $tea.Model {
  bizId?: string;
  createTime?: number;
  libraryVersion?: string;
  name?: string;
  properties?: string;
  requestId?: string;
  scope?: string;
  sourceLocation?: string;
  sourceType?: string;
  type?: string;
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      bizId: 'BizId',
      createTime: 'CreateTime',
      libraryVersion: 'LibraryVersion',
      name: 'Name',
      properties: 'Properties',
      requestId: 'RequestId',
      scope: 'Scope',
      sourceLocation: 'SourceLocation',
      sourceType: 'SourceType',
      type: 'Type',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizId: 'string',
      createTime: 'number',
      libraryVersion: 'string',
      name: 'string',
      properties: 'string',
      requestId: 'string',
      scope: 'string',
      sourceLocation: 'string',
      sourceType: 'string',
      type: 'string',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLibraryDetailResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeLibraryDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeLibraryDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLibraryInstallTaskDetailRequest extends $tea.Model {
  regionId?: string;
  resourceOwnerId?: number;
  taskBizId?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      taskBizId: 'TaskBizId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      resourceOwnerId: 'number',
      taskBizId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLibraryInstallTaskDetailResponseBody extends $tea.Model {
  clusterBizId?: string;
  detail?: string;
  endTime?: number;
  executeTime?: number;
  hostname?: string;
  libraryBizId?: string;
  requestId?: string;
  startTime?: number;
  taskGroupId?: string;
  taskId?: string;
  taskProcess?: number;
  taskStatus?: string;
  taskType?: string;
  static names(): { [key: string]: string } {
    return {
      clusterBizId: 'ClusterBizId',
      detail: 'Detail',
      endTime: 'EndTime',
      executeTime: 'ExecuteTime',
      hostname: 'Hostname',
      libraryBizId: 'LibraryBizId',
      requestId: 'RequestId',
      startTime: 'StartTime',
      taskGroupId: 'TaskGroupId',
      taskId: 'TaskId',
      taskProcess: 'TaskProcess',
      taskStatus: 'TaskStatus',
      taskType: 'TaskType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterBizId: 'string',
      detail: 'string',
      endTime: 'number',
      executeTime: 'number',
      hostname: 'string',
      libraryBizId: 'string',
      requestId: 'string',
      startTime: 'number',
      taskGroupId: 'string',
      taskId: 'string',
      taskProcess: 'number',
      taskStatus: 'string',
      taskType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLibraryInstallTaskDetailResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeLibraryInstallTaskDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeLibraryInstallTaskDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetaTablePreviewTaskRequest extends $tea.Model {
  regionId?: string;
  resourceGroupId?: string;
  resourceOwnerId?: number;
  taskId?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      resourceOwnerId: 'ResourceOwnerId',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      resourceGroupId: 'string',
      resourceOwnerId: 'number',
      taskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetaTablePreviewTaskResponseBody extends $tea.Model {
  data?: DescribeMetaTablePreviewTaskResponseBodyData;
  endTime?: number;
  executeTime?: number;
  requestId?: string;
  startTime?: number;
  taskId?: string;
  taskProcess?: number;
  taskStatus?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      endTime: 'EndTime',
      executeTime: 'ExecuteTime',
      requestId: 'RequestId',
      startTime: 'StartTime',
      taskId: 'TaskId',
      taskProcess: 'TaskProcess',
      taskStatus: 'TaskStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: DescribeMetaTablePreviewTaskResponseBodyData,
      endTime: 'number',
      executeTime: 'number',
      requestId: 'string',
      startTime: 'number',
      taskId: 'string',
      taskProcess: 'number',
      taskStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetaTablePreviewTaskResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeMetaTablePreviewTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeMetaTablePreviewTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeScalingActivityRequest extends $tea.Model {
  clusterId?: string;
  hostGroupId?: string;
  regionId?: string;
  resourceOwnerId?: number;
  scalingActivityId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      hostGroupId: 'HostGroupId',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      scalingActivityId: 'ScalingActivityId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      hostGroupId: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
      scalingActivityId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeScalingActivityResponseBody extends $tea.Model {
  bizId?: string;
  cause?: string;
  description?: string;
  endTime?: number;
  expectNum?: number;
  instanceIds?: string;
  requestId?: string;
  scalingRuleId?: string;
  startTime?: number;
  status?: string;
  totalCapacity?: number;
  transition?: string;
  static names(): { [key: string]: string } {
    return {
      bizId: 'BizId',
      cause: 'Cause',
      description: 'Description',
      endTime: 'EndTime',
      expectNum: 'ExpectNum',
      instanceIds: 'InstanceIds',
      requestId: 'RequestId',
      scalingRuleId: 'ScalingRuleId',
      startTime: 'StartTime',
      status: 'Status',
      totalCapacity: 'TotalCapacity',
      transition: 'Transition',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizId: 'string',
      cause: 'string',
      description: 'string',
      endTime: 'number',
      expectNum: 'number',
      instanceIds: 'string',
      requestId: 'string',
      scalingRuleId: 'string',
      startTime: 'number',
      status: 'string',
      totalCapacity: 'number',
      transition: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeScalingActivityResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeScalingActivityResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeScalingActivityResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeScalingCommonConfigRequest extends $tea.Model {
  regionId?: string;
  resourceGroupId?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      resourceGroupId: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeScalingCommonConfigResponseBody extends $tea.Model {
  autoScalingConfigDecommissionQueryInterval?: number;
  autoScalingConfigSystemDiskSize?: number;
  autoScalingCoolDownTime?: number;
  autoScalingGroupMaxSizeLimit?: number;
  autoScalingGroupMinSizeLimit?: number;
  autoScalingHookHeartbeatDefaultTime?: number;
  autoScalingMNSScalingThreadSleepTime?: number;
  autoScalingRuleAlarmDelayLimit?: number;
  autoScalingRuleAlarmSilentTime?: number;
  autoScalingRuleMinDelayLimit?: number;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      autoScalingConfigDecommissionQueryInterval: 'AutoScalingConfigDecommissionQueryInterval',
      autoScalingConfigSystemDiskSize: 'AutoScalingConfigSystemDiskSize',
      autoScalingCoolDownTime: 'AutoScalingCoolDownTime',
      autoScalingGroupMaxSizeLimit: 'AutoScalingGroupMaxSizeLimit',
      autoScalingGroupMinSizeLimit: 'AutoScalingGroupMinSizeLimit',
      autoScalingHookHeartbeatDefaultTime: 'AutoScalingHookHeartbeatDefaultTime',
      autoScalingMNSScalingThreadSleepTime: 'AutoScalingMNSScalingThreadSleepTime',
      autoScalingRuleAlarmDelayLimit: 'AutoScalingRuleAlarmDelayLimit',
      autoScalingRuleAlarmSilentTime: 'AutoScalingRuleAlarmSilentTime',
      autoScalingRuleMinDelayLimit: 'AutoScalingRuleMinDelayLimit',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoScalingConfigDecommissionQueryInterval: 'number',
      autoScalingConfigSystemDiskSize: 'number',
      autoScalingCoolDownTime: 'number',
      autoScalingGroupMaxSizeLimit: 'number',
      autoScalingGroupMinSizeLimit: 'number',
      autoScalingHookHeartbeatDefaultTime: 'number',
      autoScalingMNSScalingThreadSleepTime: 'number',
      autoScalingRuleAlarmDelayLimit: 'number',
      autoScalingRuleAlarmSilentTime: 'number',
      autoScalingRuleMinDelayLimit: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeScalingCommonConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeScalingCommonConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeScalingCommonConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeScalingConfigItemV2Request extends $tea.Model {
  configItemType?: string;
  regionId?: string;
  resourceGroupId?: string;
  resourceOwnerId?: number;
  scalingConfigItemId?: string;
  scalingGroupBizId?: string;
  static names(): { [key: string]: string } {
    return {
      configItemType: 'ConfigItemType',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      resourceOwnerId: 'ResourceOwnerId',
      scalingConfigItemId: 'ScalingConfigItemId',
      scalingGroupBizId: 'ScalingGroupBizId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configItemType: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      resourceOwnerId: 'number',
      scalingConfigItemId: 'string',
      scalingGroupBizId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeScalingConfigItemV2ResponseBody extends $tea.Model {
  configItemInformation?: string;
  configItemType?: string;
  requestId?: string;
  scalingConfigItemBizId?: string;
  scalingGroupBizId?: string;
  static names(): { [key: string]: string } {
    return {
      configItemInformation: 'ConfigItemInformation',
      configItemType: 'ConfigItemType',
      requestId: 'RequestId',
      scalingConfigItemBizId: 'ScalingConfigItemBizId',
      scalingGroupBizId: 'ScalingGroupBizId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configItemInformation: 'string',
      configItemType: 'string',
      requestId: 'string',
      scalingConfigItemBizId: 'string',
      scalingGroupBizId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeScalingConfigItemV2Response extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeScalingConfigItemV2ResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeScalingConfigItemV2ResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeScalingGroupInstanceV2Request extends $tea.Model {
  hostGroupBizId?: string;
  regionId?: string;
  resourceGroupId?: string;
  resourceOwnerId?: number;
  scalingGroupBizId?: string;
  static names(): { [key: string]: string } {
    return {
      hostGroupBizId: 'HostGroupBizId',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      resourceOwnerId: 'ResourceOwnerId',
      scalingGroupBizId: 'ScalingGroupBizId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      hostGroupBizId: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      resourceOwnerId: 'number',
      scalingGroupBizId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeScalingGroupInstanceV2ResponseBody extends $tea.Model {
  activeRuleCategory?: string;
  defaultCooldown?: number;
  hostGroupId?: string;
  maxSize?: number;
  minSize?: number;
  multiAvailablePolicy?: string;
  multiAvailablePolicyParam?: string;
  requestId?: string;
  scalingConfig?: DescribeScalingGroupInstanceV2ResponseBodyScalingConfig;
  scalingGroupId?: string;
  scalingRuleList?: DescribeScalingGroupInstanceV2ResponseBodyScalingRuleList;
  timeoutWithGrace?: number;
  withGrace?: boolean;
  static names(): { [key: string]: string } {
    return {
      activeRuleCategory: 'ActiveRuleCategory',
      defaultCooldown: 'DefaultCooldown',
      hostGroupId: 'HostGroupId',
      maxSize: 'MaxSize',
      minSize: 'MinSize',
      multiAvailablePolicy: 'MultiAvailablePolicy',
      multiAvailablePolicyParam: 'MultiAvailablePolicyParam',
      requestId: 'RequestId',
      scalingConfig: 'ScalingConfig',
      scalingGroupId: 'ScalingGroupId',
      scalingRuleList: 'ScalingRuleList',
      timeoutWithGrace: 'TimeoutWithGrace',
      withGrace: 'WithGrace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      activeRuleCategory: 'string',
      defaultCooldown: 'number',
      hostGroupId: 'string',
      maxSize: 'number',
      minSize: 'number',
      multiAvailablePolicy: 'string',
      multiAvailablePolicyParam: 'string',
      requestId: 'string',
      scalingConfig: DescribeScalingGroupInstanceV2ResponseBodyScalingConfig,
      scalingGroupId: 'string',
      scalingRuleList: DescribeScalingGroupInstanceV2ResponseBodyScalingRuleList,
      timeoutWithGrace: 'number',
      withGrace: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeScalingGroupInstanceV2Response extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeScalingGroupInstanceV2ResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeScalingGroupInstanceV2ResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeScalingGroupV2Request extends $tea.Model {
  hostGroupBizId?: string;
  regionId?: string;
  resourceGroupId?: string;
  resourceOwnerId?: number;
  scalingGroupBizId?: string;
  static names(): { [key: string]: string } {
    return {
      hostGroupBizId: 'HostGroupBizId',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      resourceOwnerId: 'ResourceOwnerId',
      scalingGroupBizId: 'ScalingGroupBizId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      hostGroupBizId: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      resourceOwnerId: 'number',
      scalingGroupBizId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeScalingGroupV2ResponseBody extends $tea.Model {
  activeStatus?: string;
  configState?: string;
  description?: string;
  hostGroupBizId?: string;
  name?: string;
  requestId?: string;
  scalingGroupId?: string;
  scalingInMode?: string;
  scalingMaxSize?: number;
  scalingMinSize?: number;
  static names(): { [key: string]: string } {
    return {
      activeStatus: 'ActiveStatus',
      configState: 'ConfigState',
      description: 'Description',
      hostGroupBizId: 'HostGroupBizId',
      name: 'Name',
      requestId: 'RequestId',
      scalingGroupId: 'ScalingGroupId',
      scalingInMode: 'ScalingInMode',
      scalingMaxSize: 'ScalingMaxSize',
      scalingMinSize: 'ScalingMinSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      activeStatus: 'string',
      configState: 'string',
      description: 'string',
      hostGroupBizId: 'string',
      name: 'string',
      requestId: 'string',
      scalingGroupId: 'string',
      scalingInMode: 'string',
      scalingMaxSize: 'number',
      scalingMinSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeScalingGroupV2Response extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeScalingGroupV2ResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeScalingGroupV2ResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeScalingRuleRequest extends $tea.Model {
  clusterId?: string;
  hostGroupId?: string;
  regionId?: string;
  resourceOwnerId?: number;
  scalingRuleId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      hostGroupId: 'HostGroupId',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      scalingRuleId: 'ScalingRuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      hostGroupId: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
      scalingRuleId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeScalingRuleResponseBody extends $tea.Model {
  adjustmentType?: string;
  adjustmentValue?: number;
  cloudWatchTrigger?: DescribeScalingRuleResponseBodyCloudWatchTrigger;
  cooldown?: number;
  gmtCreate?: string;
  gmtModified?: string;
  id?: string;
  requestId?: string;
  ruleCategory?: string;
  ruleName?: string;
  schedulerTrigger?: DescribeScalingRuleResponseBodySchedulerTrigger;
  status?: string;
  timeoutWithGrace?: number;
  withGrace?: boolean;
  static names(): { [key: string]: string } {
    return {
      adjustmentType: 'AdjustmentType',
      adjustmentValue: 'AdjustmentValue',
      cloudWatchTrigger: 'CloudWatchTrigger',
      cooldown: 'Cooldown',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      id: 'Id',
      requestId: 'RequestId',
      ruleCategory: 'RuleCategory',
      ruleName: 'RuleName',
      schedulerTrigger: 'SchedulerTrigger',
      status: 'Status',
      timeoutWithGrace: 'TimeoutWithGrace',
      withGrace: 'WithGrace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adjustmentType: 'string',
      adjustmentValue: 'number',
      cloudWatchTrigger: DescribeScalingRuleResponseBodyCloudWatchTrigger,
      cooldown: 'number',
      gmtCreate: 'string',
      gmtModified: 'string',
      id: 'string',
      requestId: 'string',
      ruleCategory: 'string',
      ruleName: 'string',
      schedulerTrigger: DescribeScalingRuleResponseBodySchedulerTrigger,
      status: 'string',
      timeoutWithGrace: 'number',
      withGrace: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeScalingRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeScalingRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeScalingRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSecurityGroupAttributeRequest extends $tea.Model {
  clusterId?: string;
  regionId?: string;
  resourceGroupId?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSecurityGroupAttributeResponseBody extends $tea.Model {
  availableGroupList?: DescribeSecurityGroupAttributeResponseBodyAvailableGroupList;
  requestId?: string;
  securityGroupAttributeList?: DescribeSecurityGroupAttributeResponseBodySecurityGroupAttributeList;
  static names(): { [key: string]: string } {
    return {
      availableGroupList: 'AvailableGroupList',
      requestId: 'RequestId',
      securityGroupAttributeList: 'SecurityGroupAttributeList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      availableGroupList: DescribeSecurityGroupAttributeResponseBodyAvailableGroupList,
      requestId: 'string',
      securityGroupAttributeList: DescribeSecurityGroupAttributeResponseBodySecurityGroupAttributeList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSecurityGroupAttributeResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DescribeSecurityGroupAttributeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DescribeSecurityGroupAttributeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DetachAndReleaseClusterEniRequest extends $tea.Model {
  regionId?: string;
  resourceOwnerId?: number;
  targetClusterId?: string;
  vswitchId?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      targetClusterId: 'TargetClusterId',
      vswitchId: 'VswitchId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      resourceOwnerId: 'number',
      targetClusterId: 'string',
      vswitchId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DetachAndReleaseClusterEniResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DetachAndReleaseClusterEniResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: DetachAndReleaseClusterEniResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: DetachAndReleaseClusterEniResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetHdfsCapacityStatisticInfoRequest extends $tea.Model {
  clusterId?: string;
  fromDatetime?: string;
  regionId?: string;
  resourceOwnerId?: number;
  toDatetime?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      fromDatetime: 'FromDatetime',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      toDatetime: 'ToDatetime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      fromDatetime: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
      toDatetime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetHdfsCapacityStatisticInfoResponseBody extends $tea.Model {
  hdfsCapacityList?: GetHdfsCapacityStatisticInfoResponseBodyHdfsCapacityList;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      hdfsCapacityList: 'HdfsCapacityList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      hdfsCapacityList: GetHdfsCapacityStatisticInfoResponseBodyHdfsCapacityList,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetHdfsCapacityStatisticInfoResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: GetHdfsCapacityStatisticInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: GetHdfsCapacityStatisticInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetJobInputStatisticInfoRequest extends $tea.Model {
  clusterId?: string;
  fromDatetime?: string;
  pageNumber?: number;
  pageSize?: number;
  regionId?: string;
  resourceOwnerId?: number;
  toDatetime?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      fromDatetime: 'FromDatetime',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      toDatetime: 'ToDatetime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      fromDatetime: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      resourceOwnerId: 'number',
      toDatetime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetJobInputStatisticInfoResponseBody extends $tea.Model {
  jobInputList?: GetJobInputStatisticInfoResponseBodyJobInputList;
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      jobInputList: 'JobInputList',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      jobInputList: GetJobInputStatisticInfoResponseBodyJobInputList,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetJobInputStatisticInfoResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: GetJobInputStatisticInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: GetJobInputStatisticInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetJobOutputStatisticInfoRequest extends $tea.Model {
  clusterId?: string;
  fromDatetime?: string;
  pageNumber?: number;
  pageSize?: number;
  regionId?: string;
  resourceOwnerId?: number;
  toDatetime?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      fromDatetime: 'FromDatetime',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      toDatetime: 'ToDatetime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      fromDatetime: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      resourceOwnerId: 'number',
      toDatetime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetJobOutputStatisticInfoResponseBody extends $tea.Model {
  jobOutputList?: GetJobOutputStatisticInfoResponseBodyJobOutputList;
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      jobOutputList: 'JobOutputList',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      jobOutputList: GetJobOutputStatisticInfoResponseBodyJobOutputList,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetJobOutputStatisticInfoResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: GetJobOutputStatisticInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: GetJobOutputStatisticInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetJobRunningTimeStatisticInfoRequest extends $tea.Model {
  clusterId?: string;
  fromDatetime?: string;
  pageNumber?: number;
  pageSize?: number;
  regionId?: string;
  resourceOwnerId?: number;
  toDatetime?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      fromDatetime: 'FromDatetime',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      toDatetime: 'ToDatetime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      fromDatetime: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      resourceOwnerId: 'number',
      toDatetime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetJobRunningTimeStatisticInfoResponseBody extends $tea.Model {
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  runningTimeList?: GetJobRunningTimeStatisticInfoResponseBodyRunningTimeList;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      runningTimeList: 'RunningTimeList',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      runningTimeList: GetJobRunningTimeStatisticInfoResponseBodyRunningTimeList,
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetJobRunningTimeStatisticInfoResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: GetJobRunningTimeStatisticInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: GetJobRunningTimeStatisticInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetQueueInputStatisticInfoRequest extends $tea.Model {
  clusterId?: string;
  fromDatetime?: string;
  regionId?: string;
  resourceOwnerId?: number;
  toDatetime?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      fromDatetime: 'FromDatetime',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      toDatetime: 'ToDatetime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      fromDatetime: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
      toDatetime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetQueueInputStatisticInfoResponseBody extends $tea.Model {
  queueInputList?: GetQueueInputStatisticInfoResponseBodyQueueInputList;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      queueInputList: 'QueueInputList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      queueInputList: GetQueueInputStatisticInfoResponseBodyQueueInputList,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetQueueInputStatisticInfoResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: GetQueueInputStatisticInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: GetQueueInputStatisticInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetQueueOutputStatisticInfoRequest extends $tea.Model {
  clusterId?: string;
  fromDatetime?: string;
  regionId?: string;
  resourceOwnerId?: number;
  toDatetime?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      fromDatetime: 'FromDatetime',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      toDatetime: 'ToDatetime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      fromDatetime: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
      toDatetime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetQueueOutputStatisticInfoResponseBody extends $tea.Model {
  queueOutputList?: GetQueueOutputStatisticInfoResponseBodyQueueOutputList;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      queueOutputList: 'QueueOutputList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      queueOutputList: GetQueueOutputStatisticInfoResponseBodyQueueOutputList,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetQueueOutputStatisticInfoResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: GetQueueOutputStatisticInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: GetQueueOutputStatisticInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetQueueSubmissionStatisticInfoRequest extends $tea.Model {
  applicationType?: string;
  clusterId?: string;
  finalStatus?: string;
  fromDatetime?: string;
  regionId?: string;
  resourceOwnerId?: number;
  toDatetime?: string;
  static names(): { [key: string]: string } {
    return {
      applicationType: 'ApplicationType',
      clusterId: 'ClusterId',
      finalStatus: 'FinalStatus',
      fromDatetime: 'FromDatetime',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      toDatetime: 'ToDatetime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applicationType: 'string',
      clusterId: 'string',
      finalStatus: 'string',
      fromDatetime: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
      toDatetime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetQueueSubmissionStatisticInfoResponseBody extends $tea.Model {
  queueSubmissionList?: GetQueueSubmissionStatisticInfoResponseBodyQueueSubmissionList;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      queueSubmissionList: 'QueueSubmissionList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      queueSubmissionList: GetQueueSubmissionStatisticInfoResponseBodyQueueSubmissionList,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetQueueSubmissionStatisticInfoResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: GetQueueSubmissionStatisticInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: GetQueueSubmissionStatisticInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserInputStatisticInfoRequest extends $tea.Model {
  clusterId?: string;
  fromDatetime?: string;
  regionId?: string;
  resourceOwnerId?: number;
  toDatetime?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      fromDatetime: 'FromDatetime',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      toDatetime: 'ToDatetime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      fromDatetime: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
      toDatetime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserInputStatisticInfoResponseBody extends $tea.Model {
  requestId?: string;
  userInputList?: GetUserInputStatisticInfoResponseBodyUserInputList;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      userInputList: 'UserInputList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      userInputList: GetUserInputStatisticInfoResponseBodyUserInputList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserInputStatisticInfoResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: GetUserInputStatisticInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: GetUserInputStatisticInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserOutputStatisticInfoRequest extends $tea.Model {
  clusterId?: string;
  fromDatetime?: string;
  regionId?: string;
  resourceOwnerId?: number;
  toDatetime?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      fromDatetime: 'FromDatetime',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      toDatetime: 'ToDatetime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      fromDatetime: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
      toDatetime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserOutputStatisticInfoResponseBody extends $tea.Model {
  requestId?: string;
  userOutputList?: GetUserOutputStatisticInfoResponseBodyUserOutputList;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      userOutputList: 'UserOutputList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      userOutputList: GetUserOutputStatisticInfoResponseBodyUserOutputList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserOutputStatisticInfoResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: GetUserOutputStatisticInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: GetUserOutputStatisticInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserSubmissionStatisticInfoRequest extends $tea.Model {
  applicationType?: string;
  clusterId?: string;
  finalStatus?: string;
  fromDatetime?: string;
  regionId?: string;
  resourceOwnerId?: number;
  toDatetime?: string;
  static names(): { [key: string]: string } {
    return {
      applicationType: 'ApplicationType',
      clusterId: 'ClusterId',
      finalStatus: 'FinalStatus',
      fromDatetime: 'FromDatetime',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      toDatetime: 'ToDatetime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applicationType: 'string',
      clusterId: 'string',
      finalStatus: 'string',
      fromDatetime: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
      toDatetime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserSubmissionStatisticInfoResponseBody extends $tea.Model {
  requestId?: string;
  userSubmissionList?: GetUserSubmissionStatisticInfoResponseBodyUserSubmissionList;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      userSubmissionList: 'UserSubmissionList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      userSubmissionList: GetUserSubmissionStatisticInfoResponseBodyUserSubmissionList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserSubmissionStatisticInfoResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: GetUserSubmissionStatisticInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: GetUserSubmissionStatisticInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InstallLibrariesRequest extends $tea.Model {
  clusterBizIdList?: string[];
  libraryBizId?: string;
  regionId?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      clusterBizIdList: 'ClusterBizIdList',
      libraryBizId: 'LibraryBizId',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterBizIdList: { 'type': 'array', 'itemType': 'string' },
      libraryBizId: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InstallLibrariesResponseBody extends $tea.Model {
  data?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InstallLibrariesResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: InstallLibrariesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: InstallLibrariesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class JoinResourceGroupRequest extends $tea.Model {
  regionId?: string;
  resourceGroupId?: string;
  resourceId?: string;
  resourceOwnerId?: number;
  resourceType?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      resourceId: 'ResourceId',
      resourceOwnerId: 'ResourceOwnerId',
      resourceType: 'ResourceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      resourceGroupId: 'string',
      resourceId: 'string',
      resourceOwnerId: 'number',
      resourceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class JoinResourceGroupResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class JoinResourceGroupResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: JoinResourceGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: JoinResourceGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class KillFlowJobRequest extends $tea.Model {
  jobInstanceId?: string;
  projectId?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      jobInstanceId: 'JobInstanceId',
      projectId: 'ProjectId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      jobInstanceId: 'string',
      projectId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class KillFlowJobResponseBody extends $tea.Model {
  data?: boolean;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class KillFlowJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: KillFlowJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: KillFlowJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAdviceActionRequest extends $tea.Model {
  clusterId?: string;
  component?: string;
  pageNumber?: number;
  pageSize?: number;
  regionId?: string;
  resourceOwnerId?: number;
  serviceName?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      component: 'Component',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      serviceName: 'ServiceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      component: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      resourceOwnerId: 'number',
      serviceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAdviceActionResponseBody extends $tea.Model {
  items?: ListAdviceActionResponseBodyItems;
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: ListAdviceActionResponseBodyItems,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAdviceActionResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListAdviceActionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListAdviceActionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListApmApplicationRequest extends $tea.Model {
  appId?: string;
  clusterId?: string;
  diagnoseResult?: string;
  endTimeFrom?: number;
  endTimeTo?: number;
  finalStatus?: string;
  jobType?: string;
  name?: string;
  orderBy?: string;
  pageNumber?: number;
  pageSize?: number;
  queue?: string;
  regionId?: string;
  resourceOwnerId?: number;
  startTimeFrom?: number;
  startTimeTo?: number;
  state?: string;
  user?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      clusterId: 'ClusterId',
      diagnoseResult: 'DiagnoseResult',
      endTimeFrom: 'EndTimeFrom',
      endTimeTo: 'EndTimeTo',
      finalStatus: 'FinalStatus',
      jobType: 'JobType',
      name: 'Name',
      orderBy: 'OrderBy',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      queue: 'Queue',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      startTimeFrom: 'StartTimeFrom',
      startTimeTo: 'StartTimeTo',
      state: 'State',
      user: 'User',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      clusterId: 'string',
      diagnoseResult: 'string',
      endTimeFrom: 'number',
      endTimeTo: 'number',
      finalStatus: 'string',
      jobType: 'string',
      name: 'string',
      orderBy: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      queue: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
      startTimeFrom: 'number',
      startTimeTo: 'number',
      state: 'string',
      user: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListApmApplicationResponseBody extends $tea.Model {
  apmAppInfoList?: ListApmApplicationResponseBodyApmAppInfoList;
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      apmAppInfoList: 'ApmAppInfoList',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apmAppInfoList: ListApmApplicationResponseBodyApmAppInfoList,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListApmApplicationResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListApmApplicationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListApmApplicationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListBackupsRequest extends $tea.Model {
  backupId?: string[];
  backupPlanId?: string;
  bizId?: string;
  clusterId?: string;
  currentSize?: number;
  id?: number;
  limit?: number;
  metadataType?: string;
  orderMode?: string;
  pageCount?: number;
  pageNumber?: number;
  pageSize?: number;
  regionId?: string;
  resourceOwnerId?: number;
  serviceName?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      backupId: 'BackupId',
      backupPlanId: 'BackupPlanId',
      bizId: 'BizId',
      clusterId: 'ClusterId',
      currentSize: 'CurrentSize',
      id: 'Id',
      limit: 'Limit',
      metadataType: 'MetadataType',
      orderMode: 'OrderMode',
      pageCount: 'PageCount',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      serviceName: 'ServiceName',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      backupId: { 'type': 'array', 'itemType': 'string' },
      backupPlanId: 'string',
      bizId: 'string',
      clusterId: 'string',
      currentSize: 'number',
      id: 'number',
      limit: 'number',
      metadataType: 'string',
      orderMode: 'string',
      pageCount: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      resourceOwnerId: 'number',
      serviceName: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListBackupsResponseBody extends $tea.Model {
  items?: ListBackupsResponseBodyItems;
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: ListBackupsResponseBodyItems,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListBackupsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListBackupsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListBackupsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterHostRequest extends $tea.Model {
  clusterId?: string;
  componentName?: string;
  groupType?: string;
  hostGroupId?: string;
  hostInstanceId?: string;
  hostName?: string;
  pageNumber?: number;
  pageSize?: number;
  privateIp?: string;
  publicIp?: string;
  regionId?: string;
  resourceOwnerId?: number;
  statusList?: string[];
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      componentName: 'ComponentName',
      groupType: 'GroupType',
      hostGroupId: 'HostGroupId',
      hostInstanceId: 'HostInstanceId',
      hostName: 'HostName',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      privateIp: 'PrivateIp',
      publicIp: 'PublicIp',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      statusList: 'StatusList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      componentName: 'string',
      groupType: 'string',
      hostGroupId: 'string',
      hostInstanceId: 'string',
      hostName: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      privateIp: 'string',
      publicIp: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
      statusList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterHostResponseBody extends $tea.Model {
  hostList?: ListClusterHostResponseBodyHostList;
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      hostList: 'HostList',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      hostList: ListClusterHostResponseBodyHostList,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterHostResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListClusterHostResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListClusterHostResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterHostComponentRequest extends $tea.Model {
  clusterId?: string;
  componentName?: string;
  componentStatus?: string;
  hostInstanceId?: string;
  hostName?: string;
  hostRole?: string;
  pageNumber?: number;
  pageSize?: number;
  regionId?: string;
  resourceOwnerId?: number;
  serviceName?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      componentName: 'ComponentName',
      componentStatus: 'ComponentStatus',
      hostInstanceId: 'HostInstanceId',
      hostName: 'HostName',
      hostRole: 'HostRole',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      serviceName: 'ServiceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      componentName: 'string',
      componentStatus: 'string',
      hostInstanceId: 'string',
      hostName: 'string',
      hostRole: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      resourceOwnerId: 'number',
      serviceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterHostComponentResponseBody extends $tea.Model {
  componentList?: ListClusterHostComponentResponseBodyComponentList;
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      componentList: 'ComponentList',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      componentList: ListClusterHostComponentResponseBodyComponentList,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterHostComponentResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListClusterHostComponentResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListClusterHostComponentResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterHostGroupRequest extends $tea.Model {
  clusterId?: string;
  hostGroupId?: string;
  hostGroupName?: string;
  hostGroupType?: string;
  pageNumber?: number;
  pageSize?: number;
  regionId?: string;
  resourceOwnerId?: number;
  statusList?: string[];
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      hostGroupId: 'HostGroupId',
      hostGroupName: 'HostGroupName',
      hostGroupType: 'HostGroupType',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      statusList: 'StatusList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      hostGroupId: 'string',
      hostGroupName: 'string',
      hostGroupType: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      resourceOwnerId: 'number',
      statusList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterHostGroupResponseBody extends $tea.Model {
  clusterId?: string;
  hostGroupList?: ListClusterHostGroupResponseBodyHostGroupList;
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      hostGroupList: 'HostGroupList',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      hostGroupList: ListClusterHostGroupResponseBodyHostGroupList,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterHostGroupResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListClusterHostGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListClusterHostGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterInstalledServiceRequest extends $tea.Model {
  clusterId?: string;
  pageNumber?: number;
  pageSize?: number;
  regionId?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterInstalledServiceResponseBody extends $tea.Model {
  clusterInstalledServiceList?: ListClusterInstalledServiceResponseBodyClusterInstalledServiceList;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterInstalledServiceList: 'ClusterInstalledServiceList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterInstalledServiceList: ListClusterInstalledServiceResponseBodyClusterInstalledServiceList,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterInstalledServiceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListClusterInstalledServiceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListClusterInstalledServiceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterOperationRequest extends $tea.Model {
  clusterId?: string;
  operationId?: string;
  pageNumber?: number;
  pageSize?: number;
  regionId?: string;
  resourceOwnerId?: number;
  serviceName?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      operationId: 'OperationId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      serviceName: 'ServiceName',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      operationId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      resourceOwnerId: 'number',
      serviceName: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterOperationResponseBody extends $tea.Model {
  clusterOperationList?: ListClusterOperationResponseBodyClusterOperationList;
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      clusterOperationList: 'ClusterOperationList',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterOperationList: ListClusterOperationResponseBodyClusterOperationList,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterOperationResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListClusterOperationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListClusterOperationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterOperationHostRequest extends $tea.Model {
  clusterId?: string;
  operationId?: string;
  pageNumber?: number;
  pageSize?: number;
  regionId?: string;
  resourceOwnerId?: number;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      operationId: 'OperationId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      operationId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      resourceOwnerId: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterOperationHostResponseBody extends $tea.Model {
  clusterOperationHostList?: ListClusterOperationHostResponseBodyClusterOperationHostList;
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      clusterOperationHostList: 'ClusterOperationHostList',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterOperationHostList: ListClusterOperationHostResponseBodyClusterOperationHostList,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterOperationHostResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListClusterOperationHostResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListClusterOperationHostResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterOperationHostTaskRequest extends $tea.Model {
  clusterId?: string;
  hostId?: string;
  operationId?: string;
  pageNumber?: number;
  pageSize?: number;
  regionId?: string;
  resourceOwnerId?: number;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      hostId: 'HostId',
      operationId: 'OperationId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      hostId: 'string',
      operationId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      resourceOwnerId: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterOperationHostTaskResponseBody extends $tea.Model {
  clusterOperationHostTaskList?: ListClusterOperationHostTaskResponseBodyClusterOperationHostTaskList;
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      clusterOperationHostTaskList: 'ClusterOperationHostTaskList',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterOperationHostTaskList: ListClusterOperationHostTaskResponseBodyClusterOperationHostTaskList,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterOperationHostTaskResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListClusterOperationHostTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListClusterOperationHostTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterOperationTaskRequest extends $tea.Model {
  clusterId?: string;
  operationId?: string;
  pageNumber?: number;
  pageSize?: number;
  regionId?: string;
  resourceOwnerId?: number;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      operationId: 'OperationId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      operationId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      resourceOwnerId: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterOperationTaskResponseBody extends $tea.Model {
  clusterOperationTaskList?: ListClusterOperationTaskResponseBodyClusterOperationTaskList;
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      clusterOperationTaskList: 'ClusterOperationTaskList',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterOperationTaskList: ListClusterOperationTaskResponseBodyClusterOperationTaskList,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterOperationTaskResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListClusterOperationTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListClusterOperationTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterServiceRequest extends $tea.Model {
  clusterId?: string;
  pageNumber?: number;
  pageSize?: number;
  regionId?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterServiceResponseBody extends $tea.Model {
  clusterServiceList?: ListClusterServiceResponseBodyClusterServiceList;
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      clusterServiceList: 'ClusterServiceList',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterServiceList: ListClusterServiceResponseBodyClusterServiceList,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterServiceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListClusterServiceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListClusterServiceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterServiceComponentRequest extends $tea.Model {
  clusterId?: string;
  componentName?: string;
  componentStatus?: string;
  pageNumber?: number;
  pageSize?: number;
  podName?: string;
  regionId?: string;
  resourceOwnerId?: number;
  serviceName?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      componentName: 'ComponentName',
      componentStatus: 'ComponentStatus',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      podName: 'PodName',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      serviceName: 'ServiceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      componentName: 'string',
      componentStatus: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      podName: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
      serviceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterServiceComponentResponseBody extends $tea.Model {
  componentList?: ListClusterServiceComponentResponseBodyComponentList;
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      componentList: 'ComponentList',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      componentList: ListClusterServiceComponentResponseBodyComponentList,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterServiceComponentResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListClusterServiceComponentResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListClusterServiceComponentResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterServiceComponentHealthInfoRequest extends $tea.Model {
  clusterId?: string;
  componentName?: string;
  regionId?: string;
  resourceOwnerId?: number;
  serviceName?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      componentName: 'ComponentName',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      serviceName: 'ServiceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      componentName: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
      serviceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterServiceComponentHealthInfoResponseBody extends $tea.Model {
  clusterId?: string;
  healthInfoList?: ListClusterServiceComponentHealthInfoResponseBodyHealthInfoList;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      healthInfoList: 'HealthInfoList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      healthInfoList: ListClusterServiceComponentHealthInfoResponseBodyHealthInfoList,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterServiceComponentHealthInfoResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListClusterServiceComponentHealthInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListClusterServiceComponentHealthInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterServiceConfigHistoryRequest extends $tea.Model {
  author?: string;
  clusterId?: string;
  comment?: string;
  configFileName?: string;
  configItemKey?: string;
  configVersion?: string;
  hostGroupId?: string;
  hostInstanceId?: string;
  pageNumber?: number;
  pageSize?: number;
  regionId?: string;
  resourceOwnerId?: number;
  serviceName?: string;
  static names(): { [key: string]: string } {
    return {
      author: 'Author',
      clusterId: 'ClusterId',
      comment: 'Comment',
      configFileName: 'ConfigFileName',
      configItemKey: 'ConfigItemKey',
      configVersion: 'ConfigVersion',
      hostGroupId: 'HostGroupId',
      hostInstanceId: 'HostInstanceId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      serviceName: 'ServiceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      author: 'string',
      clusterId: 'string',
      comment: 'string',
      configFileName: 'string',
      configItemKey: 'string',
      configVersion: 'string',
      hostGroupId: 'string',
      hostInstanceId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      resourceOwnerId: 'number',
      serviceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterServiceConfigHistoryResponseBody extends $tea.Model {
  configHistoryList?: ListClusterServiceConfigHistoryResponseBodyConfigHistoryList;
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      configHistoryList: 'ConfigHistoryList',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configHistoryList: ListClusterServiceConfigHistoryResponseBodyConfigHistoryList,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterServiceConfigHistoryResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListClusterServiceConfigHistoryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListClusterServiceConfigHistoryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterServiceQuickLinkRequest extends $tea.Model {
  clusterId?: string;
  directType?: boolean;
  regionId?: string;
  resourceOwnerId?: number;
  serviceName?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      directType: 'DirectType',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      serviceName: 'ServiceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      directType: 'boolean',
      regionId: 'string',
      resourceOwnerId: 'number',
      serviceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterServiceQuickLinkResponseBody extends $tea.Model {
  quickLinkList?: ListClusterServiceQuickLinkResponseBodyQuickLinkList;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      quickLinkList: 'QuickLinkList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      quickLinkList: ListClusterServiceQuickLinkResponseBodyQuickLinkList,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterServiceQuickLinkResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListClusterServiceQuickLinkResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListClusterServiceQuickLinkResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterTemplatesRequest extends $tea.Model {
  bizId?: string;
  pageNumber?: number;
  pageSize?: number;
  productType?: string;
  regionId?: string;
  resourceGroupId?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      bizId: 'BizId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      productType: 'ProductType',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      productType: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterTemplatesResponseBody extends $tea.Model {
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  templateInfoList?: ListClusterTemplatesResponseBodyTemplateInfoList;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      templateInfoList: 'TemplateInfoList',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      templateInfoList: ListClusterTemplatesResponseBodyTemplateInfoList,
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterTemplatesResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListClusterTemplatesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListClusterTemplatesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClustersRequest extends $tea.Model {
  clusterTypeList?: string[];
  createType?: string;
  defaultStatus?: boolean;
  depositType?: string;
  expiredTagList?: string[];
  isDesc?: boolean;
  machineType?: string;
  name?: string;
  pageNumber?: number;
  pageSize?: number;
  regionId?: string;
  resourceGroupId?: string;
  resourceOwnerId?: number;
  statusList?: string[];
  tag?: ListClustersRequestTag[];
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterTypeList: 'ClusterTypeList',
      createType: 'CreateType',
      defaultStatus: 'DefaultStatus',
      depositType: 'DepositType',
      expiredTagList: 'ExpiredTagList',
      isDesc: 'IsDesc',
      machineType: 'MachineType',
      name: 'Name',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      resourceOwnerId: 'ResourceOwnerId',
      statusList: 'StatusList',
      tag: 'Tag',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterTypeList: { 'type': 'array', 'itemType': 'string' },
      createType: 'string',
      defaultStatus: 'boolean',
      depositType: 'string',
      expiredTagList: { 'type': 'array', 'itemType': 'string' },
      isDesc: 'boolean',
      machineType: 'string',
      name: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      resourceGroupId: 'string',
      resourceOwnerId: 'number',
      statusList: { 'type': 'array', 'itemType': 'string' },
      tag: { 'type': 'array', 'itemType': ListClustersRequestTag },
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClustersResponseBody extends $tea.Model {
  clusters?: ListClustersResponseBodyClusters;
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      clusters: 'Clusters',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusters: ListClustersResponseBodyClusters,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClustersResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListClustersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListClustersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataSourceRequest extends $tea.Model {
  createFrom?: string;
  id?: string;
  name?: string;
  pageNumber?: number;
  pageSize?: number;
  projectId?: string;
  regionId?: string;
  resourceGroupId?: string;
  resourceOwnerId?: number;
  sourceType?: string;
  static names(): { [key: string]: string } {
    return {
      createFrom: 'CreateFrom',
      id: 'Id',
      name: 'Name',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      projectId: 'ProjectId',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      resourceOwnerId: 'ResourceOwnerId',
      sourceType: 'SourceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createFrom: 'string',
      id: 'string',
      name: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      projectId: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      resourceOwnerId: 'number',
      sourceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataSourceResponseBody extends $tea.Model {
  dataSourceList?: ListDataSourceResponseBodyDataSourceList;
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      dataSourceList: 'DataSourceList',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataSourceList: ListDataSourceResponseBodyDataSourceList,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataSourceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListDataSourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListDataSourceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDiskOpsEventsRequest extends $tea.Model {
  clusterId?: string;
  endTime?: number;
  pageNumber?: number;
  pageSize?: number;
  regionId?: string;
  resourceOwnerId?: number;
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      endTime: 'EndTime',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      endTime: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      resourceOwnerId: 'number',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDiskOpsEventsResponseBody extends $tea.Model {
  eventList?: ListDiskOpsEventsResponseBodyEventList;
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      eventList: 'EventList',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventList: ListDiskOpsEventsResponseBodyEventList,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDiskOpsEventsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListDiskOpsEventsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListDiskOpsEventsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEmrAvailableConfigRequest extends $tea.Model {
  regionId?: string;
  resourceGroupId?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      resourceGroupId: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEmrAvailableConfigResponseBody extends $tea.Model {
  emrMainVersionList?: ListEmrAvailableConfigResponseBodyEmrMainVersionList;
  keyPairNameList?: ListEmrAvailableConfigResponseBodyKeyPairNameList;
  requestId?: string;
  securityGroupList?: ListEmrAvailableConfigResponseBodySecurityGroupList;
  vpcInfoList?: ListEmrAvailableConfigResponseBodyVpcInfoList;
  static names(): { [key: string]: string } {
    return {
      emrMainVersionList: 'EmrMainVersionList',
      keyPairNameList: 'KeyPairNameList',
      requestId: 'RequestId',
      securityGroupList: 'SecurityGroupList',
      vpcInfoList: 'VpcInfoList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      emrMainVersionList: ListEmrAvailableConfigResponseBodyEmrMainVersionList,
      keyPairNameList: ListEmrAvailableConfigResponseBodyKeyPairNameList,
      requestId: 'string',
      securityGroupList: ListEmrAvailableConfigResponseBodySecurityGroupList,
      vpcInfoList: ListEmrAvailableConfigResponseBodyVpcInfoList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEmrAvailableConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListEmrAvailableConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListEmrAvailableConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEmrAvailableResourceRequest extends $tea.Model {
  clusterId?: string;
  clusterType?: string;
  dataDiskType?: string;
  depositType?: string;
  destinationResource?: string;
  emrVersion?: string;
  instanceChargeType?: string;
  instanceType?: string;
  netType?: string;
  regionId?: string;
  resourceGroupId?: string;
  resourceOwnerId?: number;
  spotStrategy?: string;
  systemDiskType?: string;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      clusterType: 'ClusterType',
      dataDiskType: 'DataDiskType',
      depositType: 'DepositType',
      destinationResource: 'DestinationResource',
      emrVersion: 'EmrVersion',
      instanceChargeType: 'InstanceChargeType',
      instanceType: 'InstanceType',
      netType: 'NetType',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      resourceOwnerId: 'ResourceOwnerId',
      spotStrategy: 'SpotStrategy',
      systemDiskType: 'SystemDiskType',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      clusterType: 'string',
      dataDiskType: 'string',
      depositType: 'string',
      destinationResource: 'string',
      emrVersion: 'string',
      instanceChargeType: 'string',
      instanceType: 'string',
      netType: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      resourceOwnerId: 'number',
      spotStrategy: 'string',
      systemDiskType: 'string',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEmrAvailableResourceResponseBody extends $tea.Model {
  emrZoneInfoList?: ListEmrAvailableResourceResponseBodyEmrZoneInfoList;
  regionId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      emrZoneInfoList: 'EmrZoneInfoList',
      regionId: 'RegionId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      emrZoneInfoList: ListEmrAvailableResourceResponseBodyEmrZoneInfoList,
      regionId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEmrAvailableResourceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListEmrAvailableResourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListEmrAvailableResourceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEmrMainVersionRequest extends $tea.Model {
  emrVersion?: string;
  pageNumber?: number;
  pageSize?: number;
  regionId?: string;
  resourceOwnerId?: number;
  stackName?: string;
  stackVersion?: string;
  static names(): { [key: string]: string } {
    return {
      emrVersion: 'EmrVersion',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      stackName: 'StackName',
      stackVersion: 'StackVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      emrVersion: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      resourceOwnerId: 'number',
      stackName: 'string',
      stackVersion: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEmrMainVersionResponseBody extends $tea.Model {
  emrMainVersionList?: ListEmrMainVersionResponseBodyEmrMainVersionList;
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      emrMainVersionList: 'EmrMainVersionList',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      emrMainVersionList: ListEmrMainVersionResponseBodyEmrMainVersionList,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEmrMainVersionResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListEmrMainVersionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListEmrMainVersionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListExecutionPlanInstancesRequest extends $tea.Model {
  executionPlanIdList?: string[];
  isDesc?: boolean;
  onlyLastInstance?: boolean;
  pageNumber?: number;
  pageSize?: number;
  regionId?: string;
  resourceOwnerId?: number;
  statusList?: string[];
  static names(): { [key: string]: string } {
    return {
      executionPlanIdList: 'ExecutionPlanIdList',
      isDesc: 'IsDesc',
      onlyLastInstance: 'OnlyLastInstance',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      statusList: 'StatusList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      executionPlanIdList: { 'type': 'array', 'itemType': 'string' },
      isDesc: 'boolean',
      onlyLastInstance: 'boolean',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      resourceOwnerId: 'number',
      statusList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListExecutionPlanInstancesResponseBody extends $tea.Model {
  executionPlanInstances?: ListExecutionPlanInstancesResponseBodyExecutionPlanInstances;
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      executionPlanInstances: 'ExecutionPlanInstances',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      executionPlanInstances: ListExecutionPlanInstancesResponseBodyExecutionPlanInstances,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListExecutionPlanInstancesResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListExecutionPlanInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListExecutionPlanInstancesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowRequest extends $tea.Model {
  clusterId?: string;
  id?: string;
  jobId?: string;
  name?: string;
  pageNumber?: number;
  pageSize?: number;
  periodic?: boolean;
  projectId?: string;
  regionId?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      id: 'Id',
      jobId: 'JobId',
      name: 'Name',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      periodic: 'Periodic',
      projectId: 'ProjectId',
      regionId: 'RegionId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      id: 'string',
      jobId: 'string',
      name: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      periodic: 'boolean',
      projectId: 'string',
      regionId: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowResponseBody extends $tea.Model {
  flow?: ListFlowResponseBodyFlow;
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      flow: 'Flow',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      flow: ListFlowResponseBodyFlow,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListFlowResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListFlowResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowCategoryRequest extends $tea.Model {
  pageNumber?: number;
  pageSize?: number;
  parentId?: string;
  projectId?: string;
  regionId?: string;
  root?: boolean;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      parentId: 'ParentId',
      projectId: 'ProjectId',
      regionId: 'RegionId',
      root: 'Root',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      parentId: 'string',
      projectId: 'string',
      regionId: 'string',
      root: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowCategoryResponseBody extends $tea.Model {
  categories?: ListFlowCategoryResponseBodyCategories;
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      categories: 'Categories',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      categories: ListFlowCategoryResponseBodyCategories,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowCategoryResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListFlowCategoryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListFlowCategoryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowClusterRequest extends $tea.Model {
  pageNumber?: number;
  pageSize?: number;
  projectId?: string;
  regionId?: string;
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      projectId: 'ProjectId',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      projectId: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowClusterResponseBody extends $tea.Model {
  clusters?: ListFlowClusterResponseBodyClusters;
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      clusters: 'Clusters',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusters: ListFlowClusterResponseBodyClusters,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowClusterResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListFlowClusterResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListFlowClusterResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowClusterAllRequest extends $tea.Model {
  productType?: string;
  regionId?: string;
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      productType: 'ProductType',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      productType: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowClusterAllResponseBody extends $tea.Model {
  clusters?: ListFlowClusterAllResponseBodyClusters;
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      clusters: 'Clusters',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusters: ListFlowClusterAllResponseBodyClusters,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowClusterAllResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListFlowClusterAllResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListFlowClusterAllResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowClusterAllHostsRequest extends $tea.Model {
  clusterId?: string;
  projectId?: string;
  regionId?: string;
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      projectId: 'ProjectId',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      projectId: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowClusterAllHostsResponseBody extends $tea.Model {
  hostList?: ListFlowClusterAllHostsResponseBodyHostList;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      hostList: 'HostList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      hostList: ListFlowClusterAllHostsResponseBodyHostList,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowClusterAllHostsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListFlowClusterAllHostsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListFlowClusterAllHostsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowClusterHostRequest extends $tea.Model {
  clusterId?: string;
  projectId?: string;
  regionId?: string;
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      projectId: 'ProjectId',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      projectId: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowClusterHostResponseBody extends $tea.Model {
  hostList?: ListFlowClusterHostResponseBodyHostList;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      hostList: 'HostList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      hostList: ListFlowClusterHostResponseBodyHostList,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowClusterHostResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListFlowClusterHostResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListFlowClusterHostResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowInstanceRequest extends $tea.Model {
  flowId?: string;
  flowName?: string;
  id?: string;
  instanceId?: string;
  nodeInstanceId?: string;
  orderBy?: string;
  orderType?: string;
  owner?: string;
  pageNumber?: number;
  pageSize?: number;
  projectId?: string;
  regionId?: string;
  statusList?: string[];
  timeRange?: string;
  static names(): { [key: string]: string } {
    return {
      flowId: 'FlowId',
      flowName: 'FlowName',
      id: 'Id',
      instanceId: 'InstanceId',
      nodeInstanceId: 'NodeInstanceId',
      orderBy: 'OrderBy',
      orderType: 'OrderType',
      owner: 'Owner',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      projectId: 'ProjectId',
      regionId: 'RegionId',
      statusList: 'StatusList',
      timeRange: 'TimeRange',
    };
  }

  static types(): { [key: string]: any } {
    return {
      flowId: 'string',
      flowName: 'string',
      id: 'string',
      instanceId: 'string',
      nodeInstanceId: 'string',
      orderBy: 'string',
      orderType: 'string',
      owner: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      projectId: 'string',
      regionId: 'string',
      statusList: { 'type': 'array', 'itemType': 'string' },
      timeRange: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowInstanceResponseBody extends $tea.Model {
  flowInstances?: ListFlowInstanceResponseBodyFlowInstances;
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      flowInstances: 'FlowInstances',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      flowInstances: ListFlowInstanceResponseBodyFlowInstances,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowInstanceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListFlowInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListFlowInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowJobRequest extends $tea.Model {
  adhoc?: boolean;
  id?: string;
  name?: string;
  pageNumber?: number;
  pageSize?: number;
  projectId?: string;
  regionId?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      adhoc: 'Adhoc',
      id: 'Id',
      name: 'Name',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      projectId: 'ProjectId',
      regionId: 'RegionId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adhoc: 'boolean',
      id: 'string',
      name: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      projectId: 'string',
      regionId: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowJobResponseBody extends $tea.Model {
  jobList?: ListFlowJobResponseBodyJobList;
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      jobList: 'JobList',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      jobList: ListFlowJobResponseBodyJobList,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListFlowJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListFlowJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowJobHistoryRequest extends $tea.Model {
  id?: string;
  instanceId?: string;
  jobType?: string;
  pageNumber?: number;
  pageSize?: number;
  projectId?: string;
  regionId?: string;
  statusList?: string[];
  timeRange?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      instanceId: 'InstanceId',
      jobType: 'JobType',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      projectId: 'ProjectId',
      regionId: 'RegionId',
      statusList: 'StatusList',
      timeRange: 'TimeRange',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      instanceId: 'string',
      jobType: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      projectId: 'string',
      regionId: 'string',
      statusList: { 'type': 'array', 'itemType': 'string' },
      timeRange: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowJobHistoryResponseBody extends $tea.Model {
  nodeInstances?: ListFlowJobHistoryResponseBodyNodeInstances;
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      nodeInstances: 'NodeInstances',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeInstances: ListFlowJobHistoryResponseBodyNodeInstances,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowJobHistoryResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListFlowJobHistoryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListFlowJobHistoryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowNodeInstanceRequest extends $tea.Model {
  orderBy?: string;
  orderType?: string;
  pageNumber?: number;
  pageSize?: number;
  projectId?: string;
  regionId?: string;
  resourceGroupId?: string;
  startTime?: number;
  statusList?: string[];
  static names(): { [key: string]: string } {
    return {
      orderBy: 'OrderBy',
      orderType: 'OrderType',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      projectId: 'ProjectId',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      startTime: 'StartTime',
      statusList: 'StatusList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderBy: 'string',
      orderType: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      projectId: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      startTime: 'number',
      statusList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowNodeInstanceResponseBody extends $tea.Model {
  flowNodeInstances?: ListFlowNodeInstanceResponseBodyFlowNodeInstances;
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      flowNodeInstances: 'FlowNodeInstances',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      flowNodeInstances: ListFlowNodeInstanceResponseBodyFlowNodeInstances,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowNodeInstanceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListFlowNodeInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListFlowNodeInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowNodeInstanceContainerStatusRequest extends $tea.Model {
  nodeInstanceId?: string;
  pageNumber?: number;
  pageSize?: number;
  projectId?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      nodeInstanceId: 'NodeInstanceId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      projectId: 'ProjectId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeInstanceId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      projectId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowNodeInstanceContainerStatusResponseBody extends $tea.Model {
  containerStatusList?: ListFlowNodeInstanceContainerStatusResponseBodyContainerStatusList;
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      containerStatusList: 'ContainerStatusList',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      containerStatusList: ListFlowNodeInstanceContainerStatusResponseBodyContainerStatusList,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowNodeInstanceContainerStatusResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListFlowNodeInstanceContainerStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListFlowNodeInstanceContainerStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowNodeSqlResultRequest extends $tea.Model {
  length?: number;
  nodeInstanceId?: string;
  offset?: number;
  projectId?: string;
  regionId?: string;
  sqlIndex?: number;
  static names(): { [key: string]: string } {
    return {
      length: 'Length',
      nodeInstanceId: 'NodeInstanceId',
      offset: 'Offset',
      projectId: 'ProjectId',
      regionId: 'RegionId',
      sqlIndex: 'SqlIndex',
    };
  }

  static types(): { [key: string]: any } {
    return {
      length: 'number',
      nodeInstanceId: 'string',
      offset: 'number',
      projectId: 'string',
      regionId: 'string',
      sqlIndex: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowNodeSqlResultResponseBody extends $tea.Model {
  end?: boolean;
  headerList?: ListFlowNodeSqlResultResponseBodyHeaderList;
  requestId?: string;
  rowList?: ListFlowNodeSqlResultResponseBodyRowList;
  static names(): { [key: string]: string } {
    return {
      end: 'End',
      headerList: 'HeaderList',
      requestId: 'RequestId',
      rowList: 'RowList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      end: 'boolean',
      headerList: ListFlowNodeSqlResultResponseBodyHeaderList,
      requestId: 'string',
      rowList: ListFlowNodeSqlResultResponseBodyRowList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowNodeSqlResultResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListFlowNodeSqlResultResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListFlowNodeSqlResultResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowProjectRequest extends $tea.Model {
  name?: string;
  pageNumber?: number;
  pageSize?: number;
  productType?: string;
  projectId?: string;
  regionId?: string;
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      productType: 'ProductType',
      projectId: 'ProjectId',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      productType: 'string',
      projectId: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowProjectResponseBody extends $tea.Model {
  pageNumber?: number;
  pageSize?: number;
  projects?: ListFlowProjectResponseBodyProjects;
  requestId?: string;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      projects: 'Projects',
      requestId: 'RequestId',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      projects: ListFlowProjectResponseBodyProjects,
      requestId: 'string',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowProjectResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListFlowProjectResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListFlowProjectResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowProjectClusterSettingRequest extends $tea.Model {
  pageNumber?: number;
  pageSize?: number;
  projectId?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      projectId: 'ProjectId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      projectId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowProjectClusterSettingResponseBody extends $tea.Model {
  clusterSettings?: ListFlowProjectClusterSettingResponseBodyClusterSettings;
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      clusterSettings: 'ClusterSettings',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterSettings: ListFlowProjectClusterSettingResponseBodyClusterSettings,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowProjectClusterSettingResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListFlowProjectClusterSettingResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListFlowProjectClusterSettingResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowProjectUserRequest extends $tea.Model {
  pageNumber?: number;
  pageSize?: number;
  projectId?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      projectId: 'ProjectId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      projectId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowProjectUserResponseBody extends $tea.Model {
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  total?: number;
  users?: ListFlowProjectUserResponseBodyUsers;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      total: 'Total',
      users: 'Users',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      total: 'number',
      users: ListFlowProjectUserResponseBodyUsers,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowProjectUserResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListFlowProjectUserResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListFlowProjectUserResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobExecutionInstancesRequest extends $tea.Model {
  executionPlanInstanceId?: string;
  isDesc?: boolean;
  pageNumber?: number;
  pageSize?: number;
  regionId?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      executionPlanInstanceId: 'ExecutionPlanInstanceId',
      isDesc: 'IsDesc',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      executionPlanInstanceId: 'string',
      isDesc: 'boolean',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobExecutionInstancesResponseBody extends $tea.Model {
  jobInstances?: ListJobExecutionInstancesResponseBodyJobInstances;
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      jobInstances: 'JobInstances',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      jobInstances: ListJobExecutionInstancesResponseBodyJobInstances,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobExecutionInstancesResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListJobExecutionInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListJobExecutionInstancesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobsRequest extends $tea.Model {
  isDesc?: boolean;
  pageNumber?: number;
  pageSize?: number;
  queryString?: string;
  queryType?: string;
  regionId?: string;
  resourceGroupId?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      isDesc: 'IsDesc',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      queryString: 'QueryString',
      queryType: 'QueryType',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isDesc: 'boolean',
      pageNumber: 'number',
      pageSize: 'number',
      queryString: 'string',
      queryType: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobsResponseBody extends $tea.Model {
  jobs?: ListJobsResponseBodyJobs;
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      jobs: 'Jobs',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      jobs: ListJobsResponseBodyJobs,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobsResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListJobsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListJobsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLibrariesRequest extends $tea.Model {
  clusterBizId?: string;
  currentSize?: number;
  limit?: number;
  orderField?: string;
  orderMode?: string;
  pageCount?: number;
  pageNumber?: number;
  pageSize?: number;
  regionId?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      clusterBizId: 'ClusterBizId',
      currentSize: 'CurrentSize',
      limit: 'Limit',
      orderField: 'OrderField',
      orderMode: 'OrderMode',
      pageCount: 'PageCount',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterBizId: 'string',
      currentSize: 'number',
      limit: 'number',
      orderField: 'string',
      orderMode: 'string',
      pageCount: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLibrariesResponseBody extends $tea.Model {
  items?: ListLibrariesResponseBodyItems;
  nextToken?: string;
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
      nextToken: 'NextToken',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: ListLibrariesResponseBodyItems,
      nextToken: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLibrariesResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListLibrariesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListLibrariesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLibraryInstallTasksRequest extends $tea.Model {
  clusterBizId?: string;
  currentSize?: number;
  libraryBizId?: string;
  limit?: number;
  orderField?: string;
  orderMode?: string;
  pageCount?: number;
  pageNumber?: number;
  pageSize?: number;
  regionId?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      clusterBizId: 'ClusterBizId',
      currentSize: 'CurrentSize',
      libraryBizId: 'LibraryBizId',
      limit: 'Limit',
      orderField: 'OrderField',
      orderMode: 'OrderMode',
      pageCount: 'PageCount',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterBizId: 'string',
      currentSize: 'number',
      libraryBizId: 'string',
      limit: 'number',
      orderField: 'string',
      orderMode: 'string',
      pageCount: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLibraryInstallTasksResponseBody extends $tea.Model {
  items?: ListLibraryInstallTasksResponseBodyItems;
  nextToken?: string;
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
      nextToken: 'NextToken',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: ListLibraryInstallTasksResponseBodyItems,
      nextToken: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLibraryInstallTasksResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListLibraryInstallTasksResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListLibraryInstallTasksResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLibraryStatusRequest extends $tea.Model {
  clusterBizId?: string;
  currentSize?: number;
  libraryBizId?: string;
  limit?: number;
  orderField?: string;
  orderMode?: string;
  pageCount?: number;
  pageNumber?: number;
  pageSize?: number;
  regionId?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      clusterBizId: 'ClusterBizId',
      currentSize: 'CurrentSize',
      libraryBizId: 'LibraryBizId',
      limit: 'Limit',
      orderField: 'OrderField',
      orderMode: 'OrderMode',
      pageCount: 'PageCount',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterBizId: 'string',
      currentSize: 'number',
      libraryBizId: 'string',
      limit: 'number',
      orderField: 'string',
      orderMode: 'string',
      pageCount: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLibraryStatusResponseBody extends $tea.Model {
  items?: ListLibraryStatusResponseBodyItems;
  nextToken?: string;
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
      nextToken: 'NextToken',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: ListLibraryStatusResponseBodyItems,
      nextToken: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLibraryStatusResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListLibraryStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListLibraryStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLocalDiskComponentInfoRequest extends $tea.Model {
  clusterId?: string;
  instanceId?: string;
  regionId?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      instanceId: 'InstanceId',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      instanceId: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLocalDiskComponentInfoResponseBody extends $tea.Model {
  componentInfoList?: ListLocalDiskComponentInfoResponseBodyComponentInfoList;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      componentInfoList: 'ComponentInfoList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      componentInfoList: ListLocalDiskComponentInfoResponseBodyComponentInfoList,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLocalDiskComponentInfoResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListLocalDiskComponentInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListLocalDiskComponentInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListResourcePoolRequest extends $tea.Model {
  clusterId?: string;
  pageNumber?: number;
  pageSize?: number;
  poolType?: string;
  regionId?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      poolType: 'PoolType',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      poolType: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListResourcePoolResponseBody extends $tea.Model {
  pageNumber?: number;
  pageSize?: number;
  poolInfoList?: ListResourcePoolResponseBodyPoolInfoList;
  requestId?: string;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      poolInfoList: 'PoolInfoList',
      requestId: 'RequestId',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      poolInfoList: ListResourcePoolResponseBodyPoolInfoList,
      requestId: 'string',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListResourcePoolResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListResourcePoolResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListResourcePoolResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRolesRequest extends $tea.Model {
  regionId?: string;
  resourceOwnerId?: number;
  resourceType?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      resourceType: 'ResourceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      resourceOwnerId: 'number',
      resourceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRolesResponseBody extends $tea.Model {
  data?: ListRolesResponseBodyData;
  paging?: boolean;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      paging: 'Paging',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: ListRolesResponseBodyData,
      paging: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRolesResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListRolesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListRolesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListScalingActivityV2Request extends $tea.Model {
  clusterBizId?: string;
  currentSize?: number;
  hostGroupId?: string;
  hostGroupName?: string;
  limit?: number;
  orderField?: string;
  orderMode?: string;
  pageCount?: number;
  pageNumber?: number;
  pageSize?: number;
  regionId?: string;
  resourceGroupId?: string;
  resourceOwnerId?: number;
  scalingGroupBizId?: string;
  scalingRuleName?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      clusterBizId: 'ClusterBizId',
      currentSize: 'CurrentSize',
      hostGroupId: 'HostGroupId',
      hostGroupName: 'HostGroupName',
      limit: 'Limit',
      orderField: 'OrderField',
      orderMode: 'OrderMode',
      pageCount: 'PageCount',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      resourceOwnerId: 'ResourceOwnerId',
      scalingGroupBizId: 'ScalingGroupBizId',
      scalingRuleName: 'ScalingRuleName',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterBizId: 'string',
      currentSize: 'number',
      hostGroupId: 'string',
      hostGroupName: 'string',
      limit: 'number',
      orderField: 'string',
      orderMode: 'string',
      pageCount: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      resourceGroupId: 'string',
      resourceOwnerId: 'number',
      scalingGroupBizId: 'string',
      scalingRuleName: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListScalingActivityV2ResponseBody extends $tea.Model {
  items?: ListScalingActivityV2ResponseBodyItems;
  nextToken?: string;
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
      nextToken: 'NextToken',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: ListScalingActivityV2ResponseBodyItems,
      nextToken: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListScalingActivityV2Response extends $tea.Model {
  headers: { [key: string]: string };
  body: ListScalingActivityV2ResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListScalingActivityV2ResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListScalingConfigItemV2Request extends $tea.Model {
  configItemType?: string;
  pageNumber?: number;
  pageSize?: number;
  regionId?: string;
  resourceGroupId?: string;
  resourceOwnerId?: number;
  scalingGroupBizId?: string;
  static names(): { [key: string]: string } {
    return {
      configItemType: 'ConfigItemType',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      resourceOwnerId: 'ResourceOwnerId',
      scalingGroupBizId: 'ScalingGroupBizId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configItemType: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      resourceGroupId: 'string',
      resourceOwnerId: 'number',
      scalingGroupBizId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListScalingConfigItemV2ResponseBody extends $tea.Model {
  items?: ListScalingConfigItemV2ResponseBodyItems;
  nextToken?: string;
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
      nextToken: 'NextToken',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: ListScalingConfigItemV2ResponseBodyItems,
      nextToken: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListScalingConfigItemV2Response extends $tea.Model {
  headers: { [key: string]: string };
  body: ListScalingConfigItemV2ResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListScalingConfigItemV2ResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListScalingGroupV2Request extends $tea.Model {
  clusterBizId?: string;
  currentSize?: number;
  limit?: number;
  orderField?: string;
  orderMode?: string;
  pageCount?: number;
  pageNumber?: number;
  pageSize?: number;
  regionId?: string;
  resourceGroupId?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      clusterBizId: 'ClusterBizId',
      currentSize: 'CurrentSize',
      limit: 'Limit',
      orderField: 'OrderField',
      orderMode: 'OrderMode',
      pageCount: 'PageCount',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterBizId: 'string',
      currentSize: 'number',
      limit: 'number',
      orderField: 'string',
      orderMode: 'string',
      pageCount: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      resourceGroupId: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListScalingGroupV2ResponseBody extends $tea.Model {
  items?: ListScalingGroupV2ResponseBodyItems;
  nextToken?: string;
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
      nextToken: 'NextToken',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: ListScalingGroupV2ResponseBodyItems,
      nextToken: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListScalingGroupV2Response extends $tea.Model {
  headers: { [key: string]: string };
  body: ListScalingGroupV2ResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListScalingGroupV2ResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSecurityGroupRequest extends $tea.Model {
  depositType?: string;
  netType?: string;
  productType?: string;
  regionId?: string;
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      depositType: 'DepositType',
      netType: 'NetType',
      productType: 'ProductType',
      regionId: 'RegionId',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      depositType: 'string',
      netType: 'string',
      productType: 'string',
      regionId: 'string',
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSecurityGroupResponseBody extends $tea.Model {
  requestId?: string;
  securityGroupList?: ListSecurityGroupResponseBodySecurityGroupList;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      securityGroupList: 'SecurityGroupList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      securityGroupList: ListSecurityGroupResponseBodySecurityGroupList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSecurityGroupResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListSecurityGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListSecurityGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListStackRequest extends $tea.Model {
  pageNumber?: number;
  pageSize?: number;
  regionId?: string;
  resourceOwnerId?: number;
  stackName?: string;
  stackVersion?: string;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      stackName: 'StackName',
      stackVersion: 'StackVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      resourceOwnerId: 'number',
      stackName: 'string',
      stackVersion: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListStackResponseBody extends $tea.Model {
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  stackList?: ListStackResponseBodyStackList;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      stackList: 'StackList',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      stackList: ListStackResponseBodyStackList,
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListStackResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListStackResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListStackResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTagKeysRequest extends $tea.Model {
  category?: string;
  nextToken?: string;
  pageSize?: number;
  regionId?: string;
  resourceOwnerId?: number;
  resourceType?: string;
  scope?: string;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      nextToken: 'NextToken',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      resourceType: 'ResourceType',
      scope: 'Scope',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      nextToken: 'string',
      pageSize: 'number',
      regionId: 'string',
      resourceOwnerId: 'number',
      resourceType: 'string',
      scope: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTagKeysResponseBody extends $tea.Model {
  code?: string;
  keys?: ListTagKeysResponseBodyKeys;
  message?: string;
  nextToken?: string;
  pageSize?: number;
  requestId?: string;
  success?: boolean;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      keys: 'Keys',
      message: 'Message',
      nextToken: 'NextToken',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      keys: ListTagKeysResponseBodyKeys,
      message: 'string',
      nextToken: 'string',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTagKeysResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListTagKeysResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListTagKeysResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTagResourcesRequest extends $tea.Model {
  nextToken?: string;
  regionId?: string;
  resourceId?: string[];
  resourceOwnerId?: number;
  resourceType?: string;
  tag?: ListTagResourcesRequestTag[];
  static names(): { [key: string]: string } {
    return {
      nextToken: 'NextToken',
      regionId: 'RegionId',
      resourceId: 'ResourceId',
      resourceOwnerId: 'ResourceOwnerId',
      resourceType: 'ResourceType',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nextToken: 'string',
      regionId: 'string',
      resourceId: { 'type': 'array', 'itemType': 'string' },
      resourceOwnerId: 'number',
      resourceType: 'string',
      tag: { 'type': 'array', 'itemType': ListTagResourcesRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTagResourcesResponseBody extends $tea.Model {
  nextToken?: string;
  requestId?: string;
  tagResources?: ListTagResourcesResponseBodyTagResources;
  static names(): { [key: string]: string } {
    return {
      nextToken: 'NextToken',
      requestId: 'RequestId',
      tagResources: 'TagResources',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nextToken: 'string',
      requestId: 'string',
      tagResources: ListTagResourcesResponseBodyTagResources,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTagResourcesResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListTagResourcesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListTagResourcesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTagValuesRequest extends $tea.Model {
  key?: string;
  nextToken?: string;
  pageSize?: number;
  regionId?: string;
  resourceOwnerId?: number;
  resourceType?: string;
  scope?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      nextToken: 'NextToken',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      resourceType: 'ResourceType',
      scope: 'Scope',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      nextToken: 'string',
      pageSize: 'number',
      regionId: 'string',
      resourceOwnerId: 'number',
      resourceType: 'string',
      scope: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTagValuesResponseBody extends $tea.Model {
  code?: string;
  message?: string;
  nextToken?: string;
  pageSize?: number;
  requestId?: string;
  success?: boolean;
  totalCount?: number;
  values?: ListTagValuesResponseBodyValues;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      nextToken: 'NextToken',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
      values: 'Values',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      nextToken: 'string',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
      values: ListTagValuesResponseBodyValues,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTagValuesResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListTagValuesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListTagValuesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUsersRequest extends $tea.Model {
  clusterId?: string;
  regionId?: string;
  resourceOwnerId?: number;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUsersResponseBody extends $tea.Model {
  requestId?: string;
  userList?: ListUsersResponseBodyUserList;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      userList: 'UserList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      userList: ListUsersResponseBodyUserList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUsersResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListUsersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListUsersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListVswitchRequest extends $tea.Model {
  depositType?: string;
  productType?: string;
  regionId?: string;
  vpcId?: string;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      depositType: 'DepositType',
      productType: 'ProductType',
      regionId: 'RegionId',
      vpcId: 'VpcId',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      depositType: 'string',
      productType: 'string',
      regionId: 'string',
      vpcId: 'string',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListVswitchResponseBody extends $tea.Model {
  requestId?: string;
  vswitchList?: ListVswitchResponseBodyVswitchList;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      vswitchList: 'VswitchList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      vswitchList: ListVswitchResponseBodyVswitchList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListVswitchResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ListVswitchResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ListVswitchResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyClusterBootstrapActionRequest extends $tea.Model {
  bootstrapAction?: ModifyClusterBootstrapActionRequestBootstrapAction[];
  clusterId?: string;
  id?: string;
  regionId?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      bootstrapAction: 'BootstrapAction',
      clusterId: 'ClusterId',
      id: 'Id',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bootstrapAction: { 'type': 'array', 'itemType': ModifyClusterBootstrapActionRequestBootstrapAction },
      clusterId: 'string',
      id: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyClusterBootstrapActionResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyClusterBootstrapActionResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyClusterBootstrapActionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyClusterBootstrapActionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyClusterHostGroupRequest extends $tea.Model {
  clusterId?: string;
  comment?: string;
  hostGroupId?: string;
  hostGroupName?: string;
  regionId?: string;
  resourceOwnerId?: number;
  securityGroupId?: string;
  vswitchId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      comment: 'Comment',
      hostGroupId: 'HostGroupId',
      hostGroupName: 'HostGroupName',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      securityGroupId: 'SecurityGroupId',
      vswitchId: 'VswitchId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      comment: 'string',
      hostGroupId: 'string',
      hostGroupName: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
      securityGroupId: 'string',
      vswitchId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyClusterHostGroupResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyClusterHostGroupResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyClusterHostGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyClusterHostGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyClusterMetaCollectRequest extends $tea.Model {
  clusterId?: string;
  regionId?: string;
  resourceOwnerId?: number;
  switchOn?: boolean;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      switchOn: 'SwitchOn',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
      switchOn: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyClusterMetaCollectResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyClusterMetaCollectResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyClusterMetaCollectResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyClusterMetaCollectResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyClusterNameRequest extends $tea.Model {
  id?: string;
  name?: string;
  regionId?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      name: 'Name',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      name: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyClusterNameResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyClusterNameResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyClusterNameResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyClusterNameResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyClusterSecurityGroupRuleRequest extends $tea.Model {
  clusterId?: string;
  ipProtocol?: string;
  modifyType?: string;
  nicType?: string;
  portRange?: string;
  regionId?: string;
  resourceOwnerId?: number;
  whiteIp?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      ipProtocol: 'IpProtocol',
      modifyType: 'ModifyType',
      nicType: 'NicType',
      portRange: 'PortRange',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      whiteIp: 'WhiteIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      ipProtocol: 'string',
      modifyType: 'string',
      nicType: 'string',
      portRange: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
      whiteIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyClusterSecurityGroupRuleResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyClusterSecurityGroupRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyClusterSecurityGroupRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyClusterSecurityGroupRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyClusterServiceConfigRequest extends $tea.Model {
  clusterId?: string;
  comment?: string;
  configParams?: string;
  configType?: string;
  customConfigParams?: string;
  gatewayClusterIdList?: string[];
  groupId?: string;
  hostInstanceId?: string;
  refreshHostConfig?: boolean;
  regionId?: string;
  resourceOwnerId?: number;
  serviceName?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      comment: 'Comment',
      configParams: 'ConfigParams',
      configType: 'ConfigType',
      customConfigParams: 'CustomConfigParams',
      gatewayClusterIdList: 'GatewayClusterIdList',
      groupId: 'GroupId',
      hostInstanceId: 'HostInstanceId',
      refreshHostConfig: 'RefreshHostConfig',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      serviceName: 'ServiceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      comment: 'string',
      configParams: 'string',
      configType: 'string',
      customConfigParams: 'string',
      gatewayClusterIdList: { 'type': 'array', 'itemType': 'string' },
      groupId: 'string',
      hostInstanceId: 'string',
      refreshHostConfig: 'boolean',
      regionId: 'string',
      resourceOwnerId: 'number',
      serviceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyClusterServiceConfigResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyClusterServiceConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyClusterServiceConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyClusterServiceConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyClusterTemplateRequest extends $tea.Model {
  autoRenew?: boolean;
  bizId?: string;
  bootstrapAction?: ModifyClusterTemplateRequestBootstrapAction[];
  chargeType?: string;
  clusterType?: string;
  config?: ModifyClusterTemplateRequestConfig[];
  configurations?: string;
  depositType?: string;
  easEnable?: boolean;
  emrVer?: string;
  highAvailabilityEnable?: boolean;
  hostGroup?: ModifyClusterTemplateRequestHostGroup[];
  initCustomHiveMetaDb?: boolean;
  instanceGeneration?: string;
  ioOptimized?: boolean;
  isOpenPublicIp?: boolean;
  keyPairName?: string;
  logPath?: string;
  machineType?: string;
  masterPwd?: string;
  metaStoreConf?: string;
  metaStoreType?: string;
  netType?: string;
  optionSoftWareList?: string[];
  period?: number;
  regionId?: string;
  resourceGroupId?: string;
  resourceOwnerId?: number;
  securityGroupId?: string;
  securityGroupName?: string;
  sshEnable?: boolean;
  tag?: ModifyClusterTemplateRequestTag[];
  templateName?: string;
  useCustomHiveMetaDb?: boolean;
  useLocalMetaDb?: boolean;
  userDefinedEmrEcsRole?: string;
  vSwitchId?: string;
  vpcId?: string;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      autoRenew: 'AutoRenew',
      bizId: 'BizId',
      bootstrapAction: 'BootstrapAction',
      chargeType: 'ChargeType',
      clusterType: 'ClusterType',
      config: 'Config',
      configurations: 'Configurations',
      depositType: 'DepositType',
      easEnable: 'EasEnable',
      emrVer: 'EmrVer',
      highAvailabilityEnable: 'HighAvailabilityEnable',
      hostGroup: 'HostGroup',
      initCustomHiveMetaDb: 'InitCustomHiveMetaDb',
      instanceGeneration: 'InstanceGeneration',
      ioOptimized: 'IoOptimized',
      isOpenPublicIp: 'IsOpenPublicIp',
      keyPairName: 'KeyPairName',
      logPath: 'LogPath',
      machineType: 'MachineType',
      masterPwd: 'MasterPwd',
      metaStoreConf: 'MetaStoreConf',
      metaStoreType: 'MetaStoreType',
      netType: 'NetType',
      optionSoftWareList: 'OptionSoftWareList',
      period: 'Period',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      resourceOwnerId: 'ResourceOwnerId',
      securityGroupId: 'SecurityGroupId',
      securityGroupName: 'SecurityGroupName',
      sshEnable: 'SshEnable',
      tag: 'Tag',
      templateName: 'TemplateName',
      useCustomHiveMetaDb: 'UseCustomHiveMetaDb',
      useLocalMetaDb: 'UseLocalMetaDb',
      userDefinedEmrEcsRole: 'UserDefinedEmrEcsRole',
      vSwitchId: 'VSwitchId',
      vpcId: 'VpcId',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoRenew: 'boolean',
      bizId: 'string',
      bootstrapAction: { 'type': 'array', 'itemType': ModifyClusterTemplateRequestBootstrapAction },
      chargeType: 'string',
      clusterType: 'string',
      config: { 'type': 'array', 'itemType': ModifyClusterTemplateRequestConfig },
      configurations: 'string',
      depositType: 'string',
      easEnable: 'boolean',
      emrVer: 'string',
      highAvailabilityEnable: 'boolean',
      hostGroup: { 'type': 'array', 'itemType': ModifyClusterTemplateRequestHostGroup },
      initCustomHiveMetaDb: 'boolean',
      instanceGeneration: 'string',
      ioOptimized: 'boolean',
      isOpenPublicIp: 'boolean',
      keyPairName: 'string',
      logPath: 'string',
      machineType: 'string',
      masterPwd: 'string',
      metaStoreConf: 'string',
      metaStoreType: 'string',
      netType: 'string',
      optionSoftWareList: { 'type': 'array', 'itemType': 'string' },
      period: 'number',
      regionId: 'string',
      resourceGroupId: 'string',
      resourceOwnerId: 'number',
      securityGroupId: 'string',
      securityGroupName: 'string',
      sshEnable: 'boolean',
      tag: { 'type': 'array', 'itemType': ModifyClusterTemplateRequestTag },
      templateName: 'string',
      useCustomHiveMetaDb: 'boolean',
      useLocalMetaDb: 'boolean',
      userDefinedEmrEcsRole: 'string',
      vSwitchId: 'string',
      vpcId: 'string',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyClusterTemplateResponseBody extends $tea.Model {
  clusterTemplateId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterTemplateId: 'ClusterTemplateId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterTemplateId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyClusterTemplateResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyClusterTemplateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyClusterTemplateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyExecutionPlanRequest extends $tea.Model {
  bootstrapAction?: ModifyExecutionPlanRequestBootstrapAction[];
  clusterId?: string;
  clusterName?: string;
  clusterType?: string;
  config?: ModifyExecutionPlanRequestConfig[];
  configurations?: string;
  createClusterOnDemand?: boolean;
  dayOfMonth?: string;
  dayOfWeek?: string;
  easEnable?: boolean;
  ecsOrder?: ModifyExecutionPlanRequestEcsOrder[];
  emrVer?: string;
  executionPlanVersion?: number;
  highAvailabilityEnable?: boolean;
  id?: string;
  initCustomHiveMetaDB?: boolean;
  instanceGeneration?: string;
  ioOptimized?: boolean;
  isOpenPublicIp?: boolean;
  jobIdList?: string[];
  logEnable?: boolean;
  logPath?: string;
  name?: string;
  netType?: string;
  optionSoftWareList?: string[];
  regionId?: string;
  resourceOwnerId?: number;
  securityGroupId?: string;
  startTime?: number;
  strategy?: string;
  timeInterval?: number;
  timeUnit?: string;
  useCustomHiveMetaDB?: boolean;
  useLocalMetaDb?: boolean;
  userDefinedEmrEcsRole?: string;
  vSwitchId?: string;
  vpcId?: string;
  workflowDefinition?: string;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      bootstrapAction: 'BootstrapAction',
      clusterId: 'ClusterId',
      clusterName: 'ClusterName',
      clusterType: 'ClusterType',
      config: 'Config',
      configurations: 'Configurations',
      createClusterOnDemand: 'CreateClusterOnDemand',
      dayOfMonth: 'DayOfMonth',
      dayOfWeek: 'DayOfWeek',
      easEnable: 'EasEnable',
      ecsOrder: 'EcsOrder',
      emrVer: 'EmrVer',
      executionPlanVersion: 'ExecutionPlanVersion',
      highAvailabilityEnable: 'HighAvailabilityEnable',
      id: 'Id',
      initCustomHiveMetaDB: 'InitCustomHiveMetaDB',
      instanceGeneration: 'InstanceGeneration',
      ioOptimized: 'IoOptimized',
      isOpenPublicIp: 'IsOpenPublicIp',
      jobIdList: 'JobIdList',
      logEnable: 'LogEnable',
      logPath: 'LogPath',
      name: 'Name',
      netType: 'NetType',
      optionSoftWareList: 'OptionSoftWareList',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      securityGroupId: 'SecurityGroupId',
      startTime: 'StartTime',
      strategy: 'Strategy',
      timeInterval: 'TimeInterval',
      timeUnit: 'TimeUnit',
      useCustomHiveMetaDB: 'UseCustomHiveMetaDB',
      useLocalMetaDb: 'UseLocalMetaDb',
      userDefinedEmrEcsRole: 'UserDefinedEmrEcsRole',
      vSwitchId: 'VSwitchId',
      vpcId: 'VpcId',
      workflowDefinition: 'WorkflowDefinition',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bootstrapAction: { 'type': 'array', 'itemType': ModifyExecutionPlanRequestBootstrapAction },
      clusterId: 'string',
      clusterName: 'string',
      clusterType: 'string',
      config: { 'type': 'array', 'itemType': ModifyExecutionPlanRequestConfig },
      configurations: 'string',
      createClusterOnDemand: 'boolean',
      dayOfMonth: 'string',
      dayOfWeek: 'string',
      easEnable: 'boolean',
      ecsOrder: { 'type': 'array', 'itemType': ModifyExecutionPlanRequestEcsOrder },
      emrVer: 'string',
      executionPlanVersion: 'number',
      highAvailabilityEnable: 'boolean',
      id: 'string',
      initCustomHiveMetaDB: 'boolean',
      instanceGeneration: 'string',
      ioOptimized: 'boolean',
      isOpenPublicIp: 'boolean',
      jobIdList: { 'type': 'array', 'itemType': 'string' },
      logEnable: 'boolean',
      logPath: 'string',
      name: 'string',
      netType: 'string',
      optionSoftWareList: { 'type': 'array', 'itemType': 'string' },
      regionId: 'string',
      resourceOwnerId: 'number',
      securityGroupId: 'string',
      startTime: 'number',
      strategy: 'string',
      timeInterval: 'number',
      timeUnit: 'string',
      useCustomHiveMetaDB: 'boolean',
      useLocalMetaDb: 'boolean',
      userDefinedEmrEcsRole: 'string',
      vSwitchId: 'string',
      vpcId: 'string',
      workflowDefinition: 'string',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyExecutionPlanResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyExecutionPlanResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyExecutionPlanResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyExecutionPlanResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyFlowRequest extends $tea.Model {
  alertConf?: string;
  alertDingDingGroupBizId?: string;
  alertUserGroupBizId?: string;
  application?: string;
  clusterId?: string;
  createCluster?: boolean;
  cronExpr?: string;
  description?: string;
  endSchedule?: number;
  hostName?: string;
  id?: string;
  lifecycle?: string;
  logArchiveLocation?: string;
  name?: string;
  namespace?: string;
  parentCategory?: string;
  parentFlowList?: string;
  periodic?: boolean;
  projectId?: string;
  regionId?: string;
  startSchedule?: number;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      alertConf: 'AlertConf',
      alertDingDingGroupBizId: 'AlertDingDingGroupBizId',
      alertUserGroupBizId: 'AlertUserGroupBizId',
      application: 'Application',
      clusterId: 'ClusterId',
      createCluster: 'CreateCluster',
      cronExpr: 'CronExpr',
      description: 'Description',
      endSchedule: 'EndSchedule',
      hostName: 'HostName',
      id: 'Id',
      lifecycle: 'Lifecycle',
      logArchiveLocation: 'LogArchiveLocation',
      name: 'Name',
      namespace: 'Namespace',
      parentCategory: 'ParentCategory',
      parentFlowList: 'ParentFlowList',
      periodic: 'Periodic',
      projectId: 'ProjectId',
      regionId: 'RegionId',
      startSchedule: 'StartSchedule',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertConf: 'string',
      alertDingDingGroupBizId: 'string',
      alertUserGroupBizId: 'string',
      application: 'string',
      clusterId: 'string',
      createCluster: 'boolean',
      cronExpr: 'string',
      description: 'string',
      endSchedule: 'number',
      hostName: 'string',
      id: 'string',
      lifecycle: 'string',
      logArchiveLocation: 'string',
      name: 'string',
      namespace: 'string',
      parentCategory: 'string',
      parentFlowList: 'string',
      periodic: 'boolean',
      projectId: 'string',
      regionId: 'string',
      startSchedule: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyFlowResponseBody extends $tea.Model {
  data?: boolean;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyFlowResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyFlowResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyFlowResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyFlowCategoryRequest extends $tea.Model {
  id?: string;
  name?: string;
  parentId?: string;
  projectId?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      name: 'Name',
      parentId: 'ParentId',
      projectId: 'ProjectId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      name: 'string',
      parentId: 'string',
      projectId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyFlowCategoryResponseBody extends $tea.Model {
  data?: boolean;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyFlowCategoryResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyFlowCategoryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyFlowCategoryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyFlowForWebRequest extends $tea.Model {
  alertConf?: string;
  alertDingDingGroupBizId?: string;
  alertUserGroupBizId?: string;
  clusterId?: string;
  createCluster?: boolean;
  cronExpr?: string;
  description?: string;
  endSchedule?: number;
  graph?: string;
  hostName?: string;
  id?: string;
  lifecycle?: string;
  logArchiveLocation?: string;
  name?: string;
  namespace?: string;
  parentCategory?: string;
  parentFlowList?: string;
  periodic?: boolean;
  projectId?: string;
  regionId?: string;
  startSchedule?: number;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      alertConf: 'AlertConf',
      alertDingDingGroupBizId: 'AlertDingDingGroupBizId',
      alertUserGroupBizId: 'AlertUserGroupBizId',
      clusterId: 'ClusterId',
      createCluster: 'CreateCluster',
      cronExpr: 'CronExpr',
      description: 'Description',
      endSchedule: 'EndSchedule',
      graph: 'Graph',
      hostName: 'HostName',
      id: 'Id',
      lifecycle: 'Lifecycle',
      logArchiveLocation: 'LogArchiveLocation',
      name: 'Name',
      namespace: 'Namespace',
      parentCategory: 'ParentCategory',
      parentFlowList: 'ParentFlowList',
      periodic: 'Periodic',
      projectId: 'ProjectId',
      regionId: 'RegionId',
      startSchedule: 'StartSchedule',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertConf: 'string',
      alertDingDingGroupBizId: 'string',
      alertUserGroupBizId: 'string',
      clusterId: 'string',
      createCluster: 'boolean',
      cronExpr: 'string',
      description: 'string',
      endSchedule: 'number',
      graph: 'string',
      hostName: 'string',
      id: 'string',
      lifecycle: 'string',
      logArchiveLocation: 'string',
      name: 'string',
      namespace: 'string',
      parentCategory: 'string',
      parentFlowList: 'string',
      periodic: 'boolean',
      projectId: 'string',
      regionId: 'string',
      startSchedule: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyFlowForWebResponseBody extends $tea.Model {
  data?: boolean;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyFlowForWebResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyFlowForWebResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyFlowForWebResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyFlowJobRequest extends $tea.Model {
  alertConf?: string;
  clusterId?: string;
  customVariables?: string;
  description?: string;
  envConf?: string;
  failAct?: string;
  id?: string;
  maxRetry?: number;
  maxRunningTimeSec?: number;
  mode?: string;
  monitorConf?: string;
  name?: string;
  paramConf?: string;
  params?: string;
  projectId?: string;
  regionId?: string;
  resourceList?: ModifyFlowJobRequestResourceList[];
  retryInterval?: number;
  retryPolicy?: string;
  runConf?: string;
  static names(): { [key: string]: string } {
    return {
      alertConf: 'AlertConf',
      clusterId: 'ClusterId',
      customVariables: 'CustomVariables',
      description: 'Description',
      envConf: 'EnvConf',
      failAct: 'FailAct',
      id: 'Id',
      maxRetry: 'MaxRetry',
      maxRunningTimeSec: 'MaxRunningTimeSec',
      mode: 'Mode',
      monitorConf: 'MonitorConf',
      name: 'Name',
      paramConf: 'ParamConf',
      params: 'Params',
      projectId: 'ProjectId',
      regionId: 'RegionId',
      resourceList: 'ResourceList',
      retryInterval: 'RetryInterval',
      retryPolicy: 'RetryPolicy',
      runConf: 'RunConf',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertConf: 'string',
      clusterId: 'string',
      customVariables: 'string',
      description: 'string',
      envConf: 'string',
      failAct: 'string',
      id: 'string',
      maxRetry: 'number',
      maxRunningTimeSec: 'number',
      mode: 'string',
      monitorConf: 'string',
      name: 'string',
      paramConf: 'string',
      params: 'string',
      projectId: 'string',
      regionId: 'string',
      resourceList: { 'type': 'array', 'itemType': ModifyFlowJobRequestResourceList },
      retryInterval: 'number',
      retryPolicy: 'string',
      runConf: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyFlowJobResponseBody extends $tea.Model {
  data?: boolean;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyFlowJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyFlowJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyFlowJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyFlowProjectRequest extends $tea.Model {
  description?: string;
  name?: string;
  projectId?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      projectId: 'ProjectId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      projectId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyFlowProjectResponseBody extends $tea.Model {
  data?: boolean;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyFlowProjectResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyFlowProjectResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyFlowProjectResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyFlowProjectClusterSettingRequest extends $tea.Model {
  clusterId?: string;
  defaultQueue?: string;
  defaultUser?: string;
  hostList?: string[];
  projectId?: string;
  queueList?: string[];
  regionId?: string;
  userList?: string[];
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      defaultQueue: 'DefaultQueue',
      defaultUser: 'DefaultUser',
      hostList: 'HostList',
      projectId: 'ProjectId',
      queueList: 'QueueList',
      regionId: 'RegionId',
      userList: 'UserList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      defaultQueue: 'string',
      defaultUser: 'string',
      hostList: { 'type': 'array', 'itemType': 'string' },
      projectId: 'string',
      queueList: { 'type': 'array', 'itemType': 'string' },
      regionId: 'string',
      userList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyFlowProjectClusterSettingResponseBody extends $tea.Model {
  data?: boolean;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyFlowProjectClusterSettingResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyFlowProjectClusterSettingResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyFlowProjectClusterSettingResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyJobRequest extends $tea.Model {
  failAct?: string;
  id?: string;
  maxRetry?: number;
  name?: string;
  regionId?: string;
  resourceGroupId?: string;
  resourceOwnerId?: number;
  retryInterval?: number;
  runParameter?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      failAct: 'FailAct',
      id: 'Id',
      maxRetry: 'MaxRetry',
      name: 'Name',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      resourceOwnerId: 'ResourceOwnerId',
      retryInterval: 'RetryInterval',
      runParameter: 'RunParameter',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failAct: 'string',
      id: 'string',
      maxRetry: 'number',
      name: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      resourceOwnerId: 'number',
      retryInterval: 'number',
      runParameter: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyJobResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyResourcePoolRequest extends $tea.Model {
  active?: boolean;
  clusterId?: string;
  config?: ModifyResourcePoolRequestConfig[];
  id?: string;
  name?: string;
  regionId?: string;
  resourceOwnerId?: number;
  yarnsiteconfig?: string;
  static names(): { [key: string]: string } {
    return {
      active: 'Active',
      clusterId: 'ClusterId',
      config: 'Config',
      id: 'Id',
      name: 'Name',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      yarnsiteconfig: 'Yarnsiteconfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      active: 'boolean',
      clusterId: 'string',
      config: { 'type': 'array', 'itemType': ModifyResourcePoolRequestConfig },
      id: 'string',
      name: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
      yarnsiteconfig: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyResourcePoolResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyResourcePoolResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyResourcePoolResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyResourcePoolResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyResourcePoolSchedulerTypeRequest extends $tea.Model {
  clusterId?: string;
  regionId?: string;
  resourceOwnerId?: number;
  schedulerType?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      schedulerType: 'SchedulerType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
      schedulerType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyResourcePoolSchedulerTypeResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyResourcePoolSchedulerTypeResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyResourcePoolSchedulerTypeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyResourcePoolSchedulerTypeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyResourceQueueRequest extends $tea.Model {
  clusterId?: string;
  config?: ModifyResourceQueueRequestConfig[];
  id?: string;
  leaf?: boolean;
  name?: string;
  parentQueueId?: number;
  qualifiedName?: string;
  regionId?: string;
  resourceOwnerId?: number;
  resourcePoolId?: number;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      config: 'Config',
      id: 'Id',
      leaf: 'Leaf',
      name: 'Name',
      parentQueueId: 'ParentQueueId',
      qualifiedName: 'QualifiedName',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      resourcePoolId: 'ResourcePoolId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      config: { 'type': 'array', 'itemType': ModifyResourceQueueRequestConfig },
      id: 'string',
      leaf: 'boolean',
      name: 'string',
      parentQueueId: 'number',
      qualifiedName: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
      resourcePoolId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyResourceQueueResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyResourceQueueResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyResourceQueueResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyResourceQueueResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyScalingConfigItemV2Request extends $tea.Model {
  configItemBizId?: string;
  configItemInformation?: string;
  configItemType?: string;
  regionId?: string;
  resourceGroupId?: string;
  resourceOwnerId?: number;
  scalingGroupBizId?: string;
  static names(): { [key: string]: string } {
    return {
      configItemBizId: 'ConfigItemBizId',
      configItemInformation: 'ConfigItemInformation',
      configItemType: 'ConfigItemType',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      resourceOwnerId: 'ResourceOwnerId',
      scalingGroupBizId: 'ScalingGroupBizId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configItemBizId: 'string',
      configItemInformation: 'string',
      configItemType: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      resourceOwnerId: 'number',
      scalingGroupBizId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyScalingConfigItemV2ResponseBody extends $tea.Model {
  data?: boolean;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyScalingConfigItemV2Response extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyScalingConfigItemV2ResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyScalingConfigItemV2ResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyScalingGroupV2Request extends $tea.Model {
  description?: string;
  name?: string;
  regionId?: string;
  resourceGroupId?: string;
  resourceOwnerId?: number;
  scalingGroupBizId?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      resourceOwnerId: 'ResourceOwnerId',
      scalingGroupBizId: 'ScalingGroupBizId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      resourceOwnerId: 'number',
      scalingGroupBizId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyScalingGroupV2ResponseBody extends $tea.Model {
  data?: boolean;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyScalingGroupV2Response extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyScalingGroupV2ResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyScalingGroupV2ResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyScalingRuleRequest extends $tea.Model {
  adjustmentType?: string;
  adjustmentValue?: number;
  cloudWatchTrigger?: ModifyScalingRuleRequestCloudWatchTrigger[];
  clusterId?: string;
  cooldown?: number;
  hostGroupId?: string;
  launchExpirationTime?: number;
  launchTime?: string;
  recurrenceEndTime?: string;
  recurrenceType?: string;
  recurrenceValue?: string;
  regionId?: string;
  resourceOwnerId?: number;
  ruleName?: string;
  scalingRuleId?: string;
  schedulerTrigger?: ModifyScalingRuleRequestSchedulerTrigger[];
  timeoutWithGrace?: number;
  withGrace?: boolean;
  static names(): { [key: string]: string } {
    return {
      adjustmentType: 'AdjustmentType',
      adjustmentValue: 'AdjustmentValue',
      cloudWatchTrigger: 'CloudWatchTrigger',
      clusterId: 'ClusterId',
      cooldown: 'Cooldown',
      hostGroupId: 'HostGroupId',
      launchExpirationTime: 'LaunchExpirationTime',
      launchTime: 'LaunchTime',
      recurrenceEndTime: 'RecurrenceEndTime',
      recurrenceType: 'RecurrenceType',
      recurrenceValue: 'RecurrenceValue',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      ruleName: 'RuleName',
      scalingRuleId: 'ScalingRuleId',
      schedulerTrigger: 'SchedulerTrigger',
      timeoutWithGrace: 'TimeoutWithGrace',
      withGrace: 'WithGrace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adjustmentType: 'string',
      adjustmentValue: 'number',
      cloudWatchTrigger: { 'type': 'array', 'itemType': ModifyScalingRuleRequestCloudWatchTrigger },
      clusterId: 'string',
      cooldown: 'number',
      hostGroupId: 'string',
      launchExpirationTime: 'number',
      launchTime: 'string',
      recurrenceEndTime: 'string',
      recurrenceType: 'string',
      recurrenceValue: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
      ruleName: 'string',
      scalingRuleId: 'string',
      schedulerTrigger: { 'type': 'array', 'itemType': ModifyScalingRuleRequestSchedulerTrigger },
      timeoutWithGrace: 'number',
      withGrace: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyScalingRuleResponseBody extends $tea.Model {
  requestId?: string;
  scalingRuleId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      scalingRuleId: 'ScalingRuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      scalingRuleId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyScalingRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyScalingRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyScalingRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyScalingTaskGroupRequest extends $tea.Model {
  activeRuleCategory?: string;
  clusterId?: string;
  defaultCooldown?: number;
  hostGroupId?: string;
  maxSize?: number;
  minSize?: number;
  regionId?: string;
  resourceOwnerId?: number;
  timeoutWithGrace?: number;
  withGrace?: boolean;
  static names(): { [key: string]: string } {
    return {
      activeRuleCategory: 'ActiveRuleCategory',
      clusterId: 'ClusterId',
      defaultCooldown: 'DefaultCooldown',
      hostGroupId: 'HostGroupId',
      maxSize: 'MaxSize',
      minSize: 'MinSize',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      timeoutWithGrace: 'TimeoutWithGrace',
      withGrace: 'WithGrace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      activeRuleCategory: 'string',
      clusterId: 'string',
      defaultCooldown: 'number',
      hostGroupId: 'string',
      maxSize: 'number',
      minSize: 'number',
      regionId: 'string',
      resourceOwnerId: 'number',
      timeoutWithGrace: 'number',
      withGrace: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyScalingTaskGroupResponseBody extends $tea.Model {
  hostGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      hostGroupId: 'HostGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      hostGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyScalingTaskGroupResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ModifyScalingTaskGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ModifyScalingTaskGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEntityRequest extends $tea.Model {
  category?: string;
  description?: string;
  id?: number;
  name?: string;
  regionId?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      description: 'Description',
      id: 'Id',
      name: 'Name',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      description: 'string',
      id: 'number',
      name: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEntityResponseBody extends $tea.Model {
  items?: QueryEntityResponseBodyItems;
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: QueryEntityResponseBodyItems,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEntityResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryEntityResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryEntityResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTagRequest extends $tea.Model {
  entityId?: string;
  entityType?: string;
  regionId?: string;
  resourceOwnerId?: number;
  tagId?: number;
  static names(): { [key: string]: string } {
    return {
      entityId: 'EntityId',
      entityType: 'EntityType',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      tagId: 'TagId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      entityId: 'string',
      entityType: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
      tagId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTagResponseBody extends $tea.Model {
  items?: QueryTagResponseBodyItems;
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: QueryTagResponseBodyItems,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTagResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: QueryTagResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: QueryTagResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RefreshClusterResourcePoolRequest extends $tea.Model {
  clusterId?: string;
  regionId?: string;
  resourceOwnerId?: number;
  resourcePoolId?: number;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      resourcePoolId: 'ResourcePoolId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
      resourcePoolId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RefreshClusterResourcePoolResponseBody extends $tea.Model {
  operationId?: string;
  requestId?: string;
  workFlowInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      operationId: 'OperationId',
      requestId: 'RequestId',
      workFlowInstanceId: 'WorkFlowInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      operationId: 'string',
      requestId: 'string',
      workFlowInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RefreshClusterResourcePoolResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: RefreshClusterResourcePoolResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: RefreshClusterResourcePoolResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleaseClusterRequest extends $tea.Model {
  forceRelease?: boolean;
  id?: string;
  regionId?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      forceRelease: 'ForceRelease',
      id: 'Id',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      forceRelease: 'boolean',
      id: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleaseClusterResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleaseClusterResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ReleaseClusterResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ReleaseClusterResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleaseClusterHostGroupRequest extends $tea.Model {
  clusterId?: string;
  hostGroupId?: string;
  instanceIdList?: string;
  regionId?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      hostGroupId: 'HostGroupId',
      instanceIdList: 'InstanceIdList',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      hostGroupId: 'string',
      instanceIdList: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleaseClusterHostGroupResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleaseClusterHostGroupResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ReleaseClusterHostGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ReleaseClusterHostGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveScalingConfigItemV2Request extends $tea.Model {
  configItemBizId?: string;
  configItemType?: string;
  regionId?: string;
  resourceGroupId?: string;
  resourceOwnerId?: number;
  scalingGroupBizId?: string;
  static names(): { [key: string]: string } {
    return {
      configItemBizId: 'ConfigItemBizId',
      configItemType: 'ConfigItemType',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      resourceOwnerId: 'ResourceOwnerId',
      scalingGroupBizId: 'ScalingGroupBizId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configItemBizId: 'string',
      configItemType: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      resourceOwnerId: 'number',
      scalingGroupBizId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveScalingConfigItemV2ResponseBody extends $tea.Model {
  data?: boolean;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveScalingConfigItemV2Response extends $tea.Model {
  headers: { [key: string]: string };
  body: RemoveScalingConfigItemV2ResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: RemoveScalingConfigItemV2ResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RerunFlowRequest extends $tea.Model {
  flowInstanceId?: string;
  projectId?: string;
  reRunFail?: boolean;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      flowInstanceId: 'FlowInstanceId',
      projectId: 'ProjectId',
      reRunFail: 'ReRunFail',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      flowInstanceId: 'string',
      projectId: 'string',
      reRunFail: 'boolean',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RerunFlowResponseBody extends $tea.Model {
  data?: boolean;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RerunFlowResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: RerunFlowResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: RerunFlowResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResizeClusterV2Request extends $tea.Model {
  autoPayOrder?: boolean;
  clusterId?: string;
  hostComponentInfo?: ResizeClusterV2RequestHostComponentInfo[];
  hostGroup?: ResizeClusterV2RequestHostGroup[];
  isOpenPublicIp?: boolean;
  promotionInfo?: ResizeClusterV2RequestPromotionInfo[];
  regionId?: string;
  vswitchId?: string;
  static names(): { [key: string]: string } {
    return {
      autoPayOrder: 'AutoPayOrder',
      clusterId: 'ClusterId',
      hostComponentInfo: 'HostComponentInfo',
      hostGroup: 'HostGroup',
      isOpenPublicIp: 'IsOpenPublicIp',
      promotionInfo: 'PromotionInfo',
      regionId: 'RegionId',
      vswitchId: 'VswitchId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoPayOrder: 'boolean',
      clusterId: 'string',
      hostComponentInfo: { 'type': 'array', 'itemType': ResizeClusterV2RequestHostComponentInfo },
      hostGroup: { 'type': 'array', 'itemType': ResizeClusterV2RequestHostGroup },
      isOpenPublicIp: 'boolean',
      promotionInfo: { 'type': 'array', 'itemType': ResizeClusterV2RequestPromotionInfo },
      regionId: 'string',
      vswitchId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResizeClusterV2ResponseBody extends $tea.Model {
  clusterId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResizeClusterV2Response extends $tea.Model {
  headers: { [key: string]: string };
  body: ResizeClusterV2ResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ResizeClusterV2ResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResumeExecutionPlanSchedulerRequest extends $tea.Model {
  id?: string;
  regionId?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResumeExecutionPlanSchedulerResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResumeExecutionPlanSchedulerResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ResumeExecutionPlanSchedulerResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ResumeExecutionPlanSchedulerResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResumeFlowRequest extends $tea.Model {
  flowInstanceId?: string;
  projectId?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      flowInstanceId: 'FlowInstanceId',
      projectId: 'ProjectId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      flowInstanceId: 'string',
      projectId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResumeFlowResponseBody extends $tea.Model {
  data?: boolean;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResumeFlowResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: ResumeFlowResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: ResumeFlowResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RetryOperationRequest extends $tea.Model {
  operationId?: string;
  regionId?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      operationId: 'OperationId',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      operationId: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RetryOperationResponseBody extends $tea.Model {
  errCode?: string;
  errMsg?: string;
  requestId?: string;
  success?: string;
  static names(): { [key: string]: string } {
    return {
      errCode: 'ErrCode',
      errMsg: 'ErrMsg',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errCode: 'string',
      errMsg: 'string',
      requestId: 'string',
      success: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RetryOperationResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: RetryOperationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: RetryOperationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RunClusterServiceActionRequest extends $tea.Model {
  clusterId?: string;
  comment?: string;
  componentNameList?: string;
  customCommand?: string;
  customParams?: string;
  executeStrategy?: string;
  hostGroupIdList?: string[];
  hostIdList?: string;
  interval?: number;
  isRolling?: boolean;
  nodeCountPerBatch?: number;
  onlyRestartStaleConfigNodes?: boolean;
  regionId?: string;
  resourceOwnerId?: number;
  serviceActionName?: string;
  serviceName?: string;
  totlerateFailCount?: number;
  turnOnMaintenanceMode?: boolean;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      comment: 'Comment',
      componentNameList: 'ComponentNameList',
      customCommand: 'CustomCommand',
      customParams: 'CustomParams',
      executeStrategy: 'ExecuteStrategy',
      hostGroupIdList: 'HostGroupIdList',
      hostIdList: 'HostIdList',
      interval: 'Interval',
      isRolling: 'IsRolling',
      nodeCountPerBatch: 'NodeCountPerBatch',
      onlyRestartStaleConfigNodes: 'OnlyRestartStaleConfigNodes',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      serviceActionName: 'ServiceActionName',
      serviceName: 'ServiceName',
      totlerateFailCount: 'TotlerateFailCount',
      turnOnMaintenanceMode: 'TurnOnMaintenanceMode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      comment: 'string',
      componentNameList: 'string',
      customCommand: 'string',
      customParams: 'string',
      executeStrategy: 'string',
      hostGroupIdList: { 'type': 'array', 'itemType': 'string' },
      hostIdList: 'string',
      interval: 'number',
      isRolling: 'boolean',
      nodeCountPerBatch: 'number',
      onlyRestartStaleConfigNodes: 'boolean',
      regionId: 'string',
      resourceOwnerId: 'number',
      serviceActionName: 'string',
      serviceName: 'string',
      totlerateFailCount: 'number',
      turnOnMaintenanceMode: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RunClusterServiceActionResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RunClusterServiceActionResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: RunClusterServiceActionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: RunClusterServiceActionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RunDiskOpsActivityRequest extends $tea.Model {
  clusterId?: string;
  currentStage?: string;
  currentState?: string;
  diskId?: string;
  eventId?: string;
  instanceId?: string;
  regionId?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      currentStage: 'CurrentStage',
      currentState: 'CurrentState',
      diskId: 'DiskId',
      eventId: 'EventId',
      instanceId: 'InstanceId',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      currentStage: 'string',
      currentState: 'string',
      diskId: 'string',
      eventId: 'string',
      instanceId: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RunDiskOpsActivityResponseBody extends $tea.Model {
  activityState?: string;
  clusterType?: string;
  currentActivity?: string;
  errorMessage?: string;
  needReboot?: boolean;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      activityState: 'ActivityState',
      clusterType: 'ClusterType',
      currentActivity: 'CurrentActivity',
      errorMessage: 'ErrorMessage',
      needReboot: 'NeedReboot',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      activityState: 'string',
      clusterType: 'string',
      currentActivity: 'string',
      errorMessage: 'string',
      needReboot: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RunDiskOpsActivityResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: RunDiskOpsActivityResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: RunDiskOpsActivityResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RunExecutionPlanRequest extends $tea.Model {
  arguments?: { [key: string]: any };
  id?: string;
  regionId?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      arguments: 'Arguments',
      id: 'Id',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      arguments: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      id: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RunExecutionPlanShrinkRequest extends $tea.Model {
  argumentsShrink?: string;
  id?: string;
  regionId?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      argumentsShrink: 'Arguments',
      id: 'Id',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      argumentsShrink: 'string',
      id: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RunExecutionPlanResponseBody extends $tea.Model {
  executionPlanInstanceId?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      executionPlanInstanceId: 'ExecutionPlanInstanceId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      executionPlanInstanceId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RunExecutionPlanResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: RunExecutionPlanResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: RunExecutionPlanResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RunScalingActionV2Request extends $tea.Model {
  actionParam?: string;
  regionId?: string;
  resourceGroupId?: string;
  resourceOwnerId?: number;
  scalingActionType?: string;
  scalingGroupBizId?: string;
  static names(): { [key: string]: string } {
    return {
      actionParam: 'ActionParam',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      resourceOwnerId: 'ResourceOwnerId',
      scalingActionType: 'ScalingActionType',
      scalingGroupBizId: 'ScalingGroupBizId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actionParam: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      resourceOwnerId: 'number',
      scalingActionType: 'string',
      scalingGroupBizId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RunScalingActionV2ResponseBody extends $tea.Model {
  data?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RunScalingActionV2Response extends $tea.Model {
  headers: { [key: string]: string };
  body: RunScalingActionV2ResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: RunScalingActionV2ResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchLogRequest extends $tea.Model {
  clusterId?: string;
  fromTimestamp?: number;
  hostInnerIp?: string;
  hostName?: string;
  line?: number;
  logstoreName?: string;
  offset?: number;
  regionId?: string;
  resourceOwnerId?: number;
  reverse?: boolean;
  slsQueryString?: string;
  toTimestamp?: number;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      fromTimestamp: 'FromTimestamp',
      hostInnerIp: 'HostInnerIp',
      hostName: 'HostName',
      line: 'Line',
      logstoreName: 'LogstoreName',
      offset: 'Offset',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      reverse: 'Reverse',
      slsQueryString: 'SlsQueryString',
      toTimestamp: 'ToTimestamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      fromTimestamp: 'number',
      hostInnerIp: 'string',
      hostName: 'string',
      line: 'number',
      logstoreName: 'string',
      offset: 'number',
      regionId: 'string',
      resourceOwnerId: 'number',
      reverse: 'boolean',
      slsQueryString: 'string',
      toTimestamp: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchLogResponseBody extends $tea.Model {
  completed?: boolean;
  requestId?: string;
  slsLogItemList?: SearchLogResponseBodySlsLogItemList;
  static names(): { [key: string]: string } {
    return {
      completed: 'Completed',
      requestId: 'RequestId',
      slsLogItemList: 'SlsLogItemList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      completed: 'boolean',
      requestId: 'string',
      slsLogItemList: SearchLogResponseBodySlsLogItemList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchLogResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: SearchLogResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: SearchLogResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartFlowRequest extends $tea.Model {
  flowInstanceId?: string;
  projectId?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      flowInstanceId: 'FlowInstanceId',
      projectId: 'ProjectId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      flowInstanceId: 'string',
      projectId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartFlowResponseBody extends $tea.Model {
  data?: boolean;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartFlowResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: StartFlowResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: StartFlowResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitFlowRequest extends $tea.Model {
  conf?: string;
  flowId?: string;
  projectId?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      conf: 'Conf',
      flowId: 'FlowId',
      projectId: 'ProjectId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      conf: 'string',
      flowId: 'string',
      projectId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitFlowResponseBody extends $tea.Model {
  id?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitFlowResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: SubmitFlowResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: SubmitFlowResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitFlowJobRequest extends $tea.Model {
  clusterId?: string;
  conf?: string;
  hostName?: string;
  jobId?: string;
  jobInstanceId?: string;
  namespace?: string;
  projectId?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      conf: 'Conf',
      hostName: 'HostName',
      jobId: 'JobId',
      jobInstanceId: 'JobInstanceId',
      namespace: 'Namespace',
      projectId: 'ProjectId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      conf: 'string',
      hostName: 'string',
      jobId: 'string',
      jobInstanceId: 'string',
      namespace: 'string',
      projectId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitFlowJobResponseBody extends $tea.Model {
  id?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitFlowJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: SubmitFlowJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: SubmitFlowJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SuspendExecutionPlanSchedulerRequest extends $tea.Model {
  id?: string;
  regionId?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SuspendExecutionPlanSchedulerResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SuspendExecutionPlanSchedulerResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: SuspendExecutionPlanSchedulerResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: SuspendExecutionPlanSchedulerResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SuspendFlowRequest extends $tea.Model {
  flowInstanceId?: string;
  projectId?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      flowInstanceId: 'FlowInstanceId',
      projectId: 'ProjectId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      flowInstanceId: 'string',
      projectId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SuspendFlowResponseBody extends $tea.Model {
  data?: boolean;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SuspendFlowResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: SuspendFlowResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: SuspendFlowResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TagResourcesRequest extends $tea.Model {
  regionId?: string;
  resourceId?: string[];
  resourceOwnerId?: number;
  resourceType?: string;
  tag?: TagResourcesRequestTag[];
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      resourceId: 'ResourceId',
      resourceOwnerId: 'ResourceOwnerId',
      resourceType: 'ResourceType',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      resourceId: { 'type': 'array', 'itemType': 'string' },
      resourceOwnerId: 'number',
      resourceType: 'string',
      tag: { 'type': 'array', 'itemType': TagResourcesRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TagResourcesResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TagResourcesResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: TagResourcesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: TagResourcesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UninstallLibrariesRequest extends $tea.Model {
  clusterBizIdList?: string[];
  libraryBizId?: string;
  regionId?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      clusterBizIdList: 'ClusterBizIdList',
      libraryBizId: 'LibraryBizId',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterBizIdList: { 'type': 'array', 'itemType': 'string' },
      libraryBizId: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UninstallLibrariesResponseBody extends $tea.Model {
  data?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UninstallLibrariesResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: UninstallLibrariesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: UninstallLibrariesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UntagResourcesRequest extends $tea.Model {
  all?: boolean;
  regionId?: string;
  resourceId?: string[];
  resourceOwnerId?: number;
  resourceType?: string;
  tagKey?: string[];
  static names(): { [key: string]: string } {
    return {
      all: 'All',
      regionId: 'RegionId',
      resourceId: 'ResourceId',
      resourceOwnerId: 'ResourceOwnerId',
      resourceType: 'ResourceType',
      tagKey: 'TagKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      all: 'boolean',
      regionId: 'string',
      resourceId: { 'type': 'array', 'itemType': 'string' },
      resourceOwnerId: 'number',
      resourceType: 'string',
      tagKey: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UntagResourcesResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UntagResourcesResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: UntagResourcesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: UntagResourcesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDataSourceRequest extends $tea.Model {
  conf?: string;
  description?: string;
  id?: string;
  name?: string;
  regionId?: string;
  resourceGroupId?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      conf: 'Conf',
      description: 'Description',
      id: 'Id',
      name: 'Name',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      conf: 'string',
      description: 'string',
      id: 'string',
      name: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDataSourceResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDataSourceResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: UpdateDataSourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: UpdateDataSourceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateLibraryInstallTaskStatusRequest extends $tea.Model {
  regionId?: string;
  resourceOwnerId?: number;
  status?: string;
  taskBizId?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      status: 'Status',
      taskBizId: 'TaskBizId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      resourceOwnerId: 'number',
      status: 'string',
      taskBizId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateLibraryInstallTaskStatusResponseBody extends $tea.Model {
  data?: boolean;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateLibraryInstallTaskStatusResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: UpdateLibraryInstallTaskStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: UpdateLibraryInstallTaskStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTagRequest extends $tea.Model {
  category?: string;
  description?: string;
  id?: number;
  name?: string;
  regionId?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      description: 'Description',
      id: 'Id',
      name: 'Name',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      description: 'string',
      id: 'number',
      name: 'string',
      regionId: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTagResponseBody extends $tea.Model {
  data?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTagResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: UpdateTagResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: UpdateTagResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateUserRequest extends $tea.Model {
  aliyunUserId?: string;
  description?: string;
  groupIdList?: number[];
  regionId?: string;
  resourceOwnerId?: number;
  roleIdList?: number[];
  status?: string;
  userAccountParamList?: UpdateUserRequestUserAccountParamList[];
  userName?: string;
  userType?: string;
  static names(): { [key: string]: string } {
    return {
      aliyunUserId: 'AliyunUserId',
      description: 'Description',
      groupIdList: 'GroupIdList',
      regionId: 'RegionId',
      resourceOwnerId: 'ResourceOwnerId',
      roleIdList: 'RoleIdList',
      status: 'Status',
      userAccountParamList: 'UserAccountParamList',
      userName: 'UserName',
      userType: 'UserType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunUserId: 'string',
      description: 'string',
      groupIdList: { 'type': 'array', 'itemType': 'number' },
      regionId: 'string',
      resourceOwnerId: 'number',
      roleIdList: { 'type': 'array', 'itemType': 'number' },
      status: 'string',
      userAccountParamList: { 'type': 'array', 'itemType': UpdateUserRequestUserAccountParamList },
      userName: 'string',
      userType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateUserResponseBody extends $tea.Model {
  data?: boolean;
  paging?: boolean;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      paging: 'Paging',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      paging: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateUserResponse extends $tea.Model {
  headers: { [key: string]: string };
  body: UpdateUserResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      body: UpdateUserResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddClusterServiceRequestService extends $tea.Model {
  serviceName?: string;
  serviceVersion?: string;
  static names(): { [key: string]: string } {
    return {
      serviceName: 'ServiceName',
      serviceVersion: 'ServiceVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      serviceName: 'string',
      serviceVersion: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateClusterBootstrapActionRequestBootstrapAction extends $tea.Model {
  arg?: string;
  executionFailStrategy?: string;
  executionMoment?: string;
  executionTarget?: string;
  name?: string;
  path?: string;
  static names(): { [key: string]: string } {
    return {
      arg: 'Arg',
      executionFailStrategy: 'ExecutionFailStrategy',
      executionMoment: 'ExecutionMoment',
      executionTarget: 'ExecutionTarget',
      name: 'Name',
      path: 'Path',
    };
  }

  static types(): { [key: string]: any } {
    return {
      arg: 'string',
      executionFailStrategy: 'string',
      executionMoment: 'string',
      executionTarget: 'string',
      name: 'string',
      path: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateClusterTemplateRequestBootstrapAction extends $tea.Model {
  arg?: string;
  executionFailStrategy?: string;
  executionMoment?: string;
  executionTarget?: string;
  name?: string;
  path?: string;
  static names(): { [key: string]: string } {
    return {
      arg: 'Arg',
      executionFailStrategy: 'ExecutionFailStrategy',
      executionMoment: 'ExecutionMoment',
      executionTarget: 'ExecutionTarget',
      name: 'Name',
      path: 'Path',
    };
  }

  static types(): { [key: string]: any } {
    return {
      arg: 'string',
      executionFailStrategy: 'string',
      executionMoment: 'string',
      executionTarget: 'string',
      name: 'string',
      path: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateClusterTemplateRequestConfig extends $tea.Model {
  configKey?: string;
  configValue?: string;
  encrypt?: string;
  fileName?: string;
  replace?: string;
  serviceName?: string;
  static names(): { [key: string]: string } {
    return {
      configKey: 'ConfigKey',
      configValue: 'ConfigValue',
      encrypt: 'Encrypt',
      fileName: 'FileName',
      replace: 'Replace',
      serviceName: 'ServiceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configKey: 'string',
      configValue: 'string',
      encrypt: 'string',
      fileName: 'string',
      replace: 'string',
      serviceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateClusterTemplateRequestHostGroup extends $tea.Model {
  autoRenew?: boolean;
  chargeType?: string;
  clusterId?: string;
  comment?: string;
  createType?: string;
  diskCapacity?: number;
  diskCount?: number;
  diskType?: string;
  hostGroupId?: string;
  hostGroupName?: string;
  hostGroupType?: string;
  instanceType?: string;
  multiInstanceTypes?: string;
  nodeCount?: number;
  period?: number;
  privatePoolOptionsId?: string;
  privatePoolOptionsMatchCriteria?: string;
  sysDiskCapacity?: number;
  sysDiskType?: string;
  vSwitchId?: string;
  static names(): { [key: string]: string } {
    return {
      autoRenew: 'AutoRenew',
      chargeType: 'ChargeType',
      clusterId: 'ClusterId',
      comment: 'Comment',
      createType: 'CreateType',
      diskCapacity: 'DiskCapacity',
      diskCount: 'DiskCount',
      diskType: 'DiskType',
      hostGroupId: 'HostGroupId',
      hostGroupName: 'HostGroupName',
      hostGroupType: 'HostGroupType',
      instanceType: 'InstanceType',
      multiInstanceTypes: 'MultiInstanceTypes',
      nodeCount: 'NodeCount',
      period: 'Period',
      privatePoolOptionsId: 'PrivatePoolOptionsId',
      privatePoolOptionsMatchCriteria: 'PrivatePoolOptionsMatchCriteria',
      sysDiskCapacity: 'SysDiskCapacity',
      sysDiskType: 'SysDiskType',
      vSwitchId: 'VSwitchId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoRenew: 'boolean',
      chargeType: 'string',
      clusterId: 'string',
      comment: 'string',
      createType: 'string',
      diskCapacity: 'number',
      diskCount: 'number',
      diskType: 'string',
      hostGroupId: 'string',
      hostGroupName: 'string',
      hostGroupType: 'string',
      instanceType: 'string',
      multiInstanceTypes: 'string',
      nodeCount: 'number',
      period: 'number',
      privatePoolOptionsId: 'string',
      privatePoolOptionsMatchCriteria: 'string',
      sysDiskCapacity: 'number',
      sysDiskType: 'string',
      vSwitchId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateClusterTemplateRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateClusterV2RequestBootstrapAction extends $tea.Model {
  arg?: string;
  executionFailStrategy?: string;
  executionMoment?: string;
  executionTarget?: string;
  name?: string;
  path?: string;
  static names(): { [key: string]: string } {
    return {
      arg: 'Arg',
      executionFailStrategy: 'ExecutionFailStrategy',
      executionMoment: 'ExecutionMoment',
      executionTarget: 'ExecutionTarget',
      name: 'Name',
      path: 'Path',
    };
  }

  static types(): { [key: string]: any } {
    return {
      arg: 'string',
      executionFailStrategy: 'string',
      executionMoment: 'string',
      executionTarget: 'string',
      name: 'string',
      path: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateClusterV2RequestConfig extends $tea.Model {
  configKey?: string;
  configValue?: string;
  encrypt?: string;
  fileName?: string;
  replace?: string;
  serviceName?: string;
  static names(): { [key: string]: string } {
    return {
      configKey: 'ConfigKey',
      configValue: 'ConfigValue',
      encrypt: 'Encrypt',
      fileName: 'FileName',
      replace: 'Replace',
      serviceName: 'ServiceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configKey: 'string',
      configValue: 'string',
      encrypt: 'string',
      fileName: 'string',
      replace: 'string',
      serviceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateClusterV2RequestHostComponentInfo extends $tea.Model {
  componentNameList?: string[];
  hostName?: string;
  serviceName?: string;
  static names(): { [key: string]: string } {
    return {
      componentNameList: 'ComponentNameList',
      hostName: 'HostName',
      serviceName: 'ServiceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      componentNameList: { 'type': 'array', 'itemType': 'string' },
      hostName: 'string',
      serviceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateClusterV2RequestHostGroup extends $tea.Model {
  autoRenew?: boolean;
  chargeType?: string;
  clusterId?: string;
  comment?: string;
  createType?: string;
  diskCapacity?: number;
  diskCount?: number;
  diskType?: string;
  gpuDriver?: string;
  hostGroupId?: string;
  hostGroupName?: string;
  hostGroupType?: string;
  instanceType?: string;
  nodeCount?: number;
  period?: number;
  privatePoolOptionsId?: string;
  privatePoolOptionsMatchCriteria?: string;
  sysDiskCapacity?: number;
  sysDiskType?: string;
  vSwitchId?: string;
  static names(): { [key: string]: string } {
    return {
      autoRenew: 'AutoRenew',
      chargeType: 'ChargeType',
      clusterId: 'ClusterId',
      comment: 'Comment',
      createType: 'CreateType',
      diskCapacity: 'DiskCapacity',
      diskCount: 'DiskCount',
      diskType: 'DiskType',
      gpuDriver: 'GpuDriver',
      hostGroupId: 'HostGroupId',
      hostGroupName: 'HostGroupName',
      hostGroupType: 'HostGroupType',
      instanceType: 'InstanceType',
      nodeCount: 'NodeCount',
      period: 'Period',
      privatePoolOptionsId: 'PrivatePoolOptionsId',
      privatePoolOptionsMatchCriteria: 'PrivatePoolOptionsMatchCriteria',
      sysDiskCapacity: 'SysDiskCapacity',
      sysDiskType: 'SysDiskType',
      vSwitchId: 'VSwitchId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoRenew: 'boolean',
      chargeType: 'string',
      clusterId: 'string',
      comment: 'string',
      createType: 'string',
      diskCapacity: 'number',
      diskCount: 'number',
      diskType: 'string',
      gpuDriver: 'string',
      hostGroupId: 'string',
      hostGroupName: 'string',
      hostGroupType: 'string',
      instanceType: 'string',
      nodeCount: 'number',
      period: 'number',
      privatePoolOptionsId: 'string',
      privatePoolOptionsMatchCriteria: 'string',
      sysDiskCapacity: 'number',
      sysDiskType: 'string',
      vSwitchId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateClusterV2RequestPromotionInfo extends $tea.Model {
  productCode?: string;
  promotionOptionCode?: string;
  promotionOptionNo?: string;
  static names(): { [key: string]: string } {
    return {
      productCode: 'ProductCode',
      promotionOptionCode: 'PromotionOptionCode',
      promotionOptionNo: 'PromotionOptionNo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      productCode: 'string',
      promotionOptionCode: 'string',
      promotionOptionNo: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateClusterV2RequestServiceInfo extends $tea.Model {
  serviceName?: string;
  serviceVersion?: string;
  static names(): { [key: string]: string } {
    return {
      serviceName: 'ServiceName',
      serviceVersion: 'ServiceVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      serviceName: 'string',
      serviceVersion: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateClusterV2RequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateClusterV2RequestUserInfo extends $tea.Model {
  password?: string;
  userId?: string;
  userName?: string;
  static names(): { [key: string]: string } {
    return {
      password: 'Password',
      userId: 'UserId',
      userName: 'UserName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      password: 'string',
      userId: 'string',
      userName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateExecutionPlanRequestBootstrapAction extends $tea.Model {
  arg?: string;
  executionFailStrategy?: string;
  executionMoment?: string;
  executionTarget?: string;
  name?: string;
  path?: string;
  static names(): { [key: string]: string } {
    return {
      arg: 'Arg',
      executionFailStrategy: 'ExecutionFailStrategy',
      executionMoment: 'ExecutionMoment',
      executionTarget: 'ExecutionTarget',
      name: 'Name',
      path: 'Path',
    };
  }

  static types(): { [key: string]: any } {
    return {
      arg: 'string',
      executionFailStrategy: 'string',
      executionMoment: 'string',
      executionTarget: 'string',
      name: 'string',
      path: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateExecutionPlanRequestConfig extends $tea.Model {
  configKey?: string;
  configValue?: string;
  encrypt?: string;
  fileName?: string;
  replace?: string;
  serviceName?: string;
  static names(): { [key: string]: string } {
    return {
      configKey: 'ConfigKey',
      configValue: 'ConfigValue',
      encrypt: 'Encrypt',
      fileName: 'FileName',
      replace: 'Replace',
      serviceName: 'ServiceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configKey: 'string',
      configValue: 'string',
      encrypt: 'string',
      fileName: 'string',
      replace: 'string',
      serviceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateExecutionPlanRequestEcsOrder extends $tea.Model {
  diskCapacity?: number;
  diskCount?: number;
  diskType?: string;
  index?: number;
  instanceType?: string;
  nodeCount?: number;
  nodeType?: string;
  static names(): { [key: string]: string } {
    return {
      diskCapacity: 'DiskCapacity',
      diskCount: 'DiskCount',
      diskType: 'DiskType',
      index: 'Index',
      instanceType: 'InstanceType',
      nodeCount: 'NodeCount',
      nodeType: 'NodeType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      diskCapacity: 'number',
      diskCount: 'number',
      diskType: 'string',
      index: 'number',
      instanceType: 'string',
      nodeCount: 'number',
      nodeType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFlowJobRequestResourceList extends $tea.Model {
  alias?: string;
  path?: string;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      path: 'Path',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      path: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFlowProjectUserRequestUser extends $tea.Model {
  userId?: string;
  userName?: string;
  static names(): { [key: string]: string } {
    return {
      userId: 'UserId',
      userName: 'UserName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      userId: 'string',
      userName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateResourcePoolRequestConfig extends $tea.Model {
  category?: string;
  configKey?: string;
  configValue?: string;
  note?: string;
  targetId?: string;
  configType?: string;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      configKey: 'ConfigKey',
      configValue: 'ConfigValue',
      note: 'Note',
      targetId: 'TargetId',
      configType: 'configType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      configKey: 'string',
      configValue: 'string',
      note: 'string',
      targetId: 'string',
      configType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateResourceQueueRequestConfig extends $tea.Model {
  category?: string;
  configKey?: string;
  configValue?: string;
  note?: string;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      configKey: 'ConfigKey',
      configValue: 'ConfigValue',
      note: 'Note',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      configKey: 'string',
      configValue: 'string',
      note: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateScalingRuleRequestCloudWatchTrigger extends $tea.Model {
  comparisonOperator?: string;
  evaluationCount?: string;
  metricName?: string;
  period?: number;
  statistics?: string;
  threshold?: string;
  static names(): { [key: string]: string } {
    return {
      comparisonOperator: 'ComparisonOperator',
      evaluationCount: 'EvaluationCount',
      metricName: 'MetricName',
      period: 'Period',
      statistics: 'Statistics',
      threshold: 'Threshold',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comparisonOperator: 'string',
      evaluationCount: 'string',
      metricName: 'string',
      period: 'number',
      statistics: 'string',
      threshold: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateScalingRuleRequestSchedulerTrigger extends $tea.Model {
  launchExpirationTime?: number;
  launchTime?: string;
  recurrenceEndTime?: string;
  recurrenceType?: string;
  recurrenceValue?: string;
  static names(): { [key: string]: string } {
    return {
      launchExpirationTime: 'LaunchExpirationTime',
      launchTime: 'LaunchTime',
      recurrenceEndTime: 'RecurrenceEndTime',
      recurrenceType: 'RecurrenceType',
      recurrenceValue: 'RecurrenceValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      launchExpirationTime: 'number',
      launchTime: 'string',
      recurrenceEndTime: 'string',
      recurrenceType: 'string',
      recurrenceValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUserRequestUserAccountParamList extends $tea.Model {
  accountPassword?: string;
  accountType?: string;
  authType?: string;
  static names(): { [key: string]: string } {
    return {
      accountPassword: 'AccountPassword',
      accountType: 'AccountType',
      authType: 'AuthType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountPassword: 'string',
      accountType: 'string',
      authType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUsersRequestUserInfo extends $tea.Model {
  type?: string;
  userId?: string;
  userName?: string;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
      userId: 'UserId',
      userName: 'UserName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
      userId: 'string',
      userName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterBasicInfoResponseBodyClusterInfoAccessInfoZKLinksZKLink extends $tea.Model {
  link?: string;
  port?: string;
  static names(): { [key: string]: string } {
    return {
      link: 'Link',
      port: 'Port',
    };
  }

  static types(): { [key: string]: any } {
    return {
      link: 'string',
      port: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterBasicInfoResponseBodyClusterInfoAccessInfoZKLinks extends $tea.Model {
  ZKLink?: DescribeClusterBasicInfoResponseBodyClusterInfoAccessInfoZKLinksZKLink[];
  static names(): { [key: string]: string } {
    return {
      ZKLink: 'ZKLink',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ZKLink: { 'type': 'array', 'itemType': DescribeClusterBasicInfoResponseBodyClusterInfoAccessInfoZKLinksZKLink },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterBasicInfoResponseBodyClusterInfoAccessInfo extends $tea.Model {
  ZKLinks?: DescribeClusterBasicInfoResponseBodyClusterInfoAccessInfoZKLinks;
  static names(): { [key: string]: string } {
    return {
      ZKLinks: 'ZKLinks',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ZKLinks: DescribeClusterBasicInfoResponseBodyClusterInfoAccessInfoZKLinks,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterBasicInfoResponseBodyClusterInfoBootstrapActionListBootstrapAction extends $tea.Model {
  arg?: string;
  name?: string;
  path?: string;
  static names(): { [key: string]: string } {
    return {
      arg: 'Arg',
      name: 'Name',
      path: 'Path',
    };
  }

  static types(): { [key: string]: any } {
    return {
      arg: 'string',
      name: 'string',
      path: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterBasicInfoResponseBodyClusterInfoBootstrapActionList extends $tea.Model {
  bootstrapAction?: DescribeClusterBasicInfoResponseBodyClusterInfoBootstrapActionListBootstrapAction[];
  static names(): { [key: string]: string } {
    return {
      bootstrapAction: 'BootstrapAction',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bootstrapAction: { 'type': 'array', 'itemType': DescribeClusterBasicInfoResponseBodyClusterInfoBootstrapActionListBootstrapAction },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterBasicInfoResponseBodyClusterInfoFailReason extends $tea.Model {
  errorCode?: string;
  errorMsg?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMsg: 'ErrorMsg',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMsg: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterBasicInfoResponseBodyClusterInfoGatewayClusterInfoListGatewayClusterInfo extends $tea.Model {
  clusterId?: string;
  clusterName?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      clusterName: 'ClusterName',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      clusterName: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterBasicInfoResponseBodyClusterInfoGatewayClusterInfoList extends $tea.Model {
  gatewayClusterInfo?: DescribeClusterBasicInfoResponseBodyClusterInfoGatewayClusterInfoListGatewayClusterInfo[];
  static names(): { [key: string]: string } {
    return {
      gatewayClusterInfo: 'GatewayClusterInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gatewayClusterInfo: { 'type': 'array', 'itemType': DescribeClusterBasicInfoResponseBodyClusterInfoGatewayClusterInfoListGatewayClusterInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterBasicInfoResponseBodyClusterInfoHostPoolInfo extends $tea.Model {
  hpBizId?: string;
  hpName?: string;
  static names(): { [key: string]: string } {
    return {
      hpBizId: 'HpBizId',
      hpName: 'HpName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      hpBizId: 'string',
      hpName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterBasicInfoResponseBodyClusterInfoRelateClusterInfo extends $tea.Model {
  clusterId?: string;
  clusterName?: string;
  clusterType?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      clusterName: 'ClusterName',
      clusterType: 'ClusterType',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      clusterName: 'string',
      clusterType: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterBasicInfoResponseBodyClusterInfoSoftwareInfoSoftwaresSoftware extends $tea.Model {
  displayName?: string;
  name?: string;
  onlyDisplay?: boolean;
  startTpe?: number;
  version?: string;
  static names(): { [key: string]: string } {
    return {
      displayName: 'DisplayName',
      name: 'Name',
      onlyDisplay: 'OnlyDisplay',
      startTpe: 'StartTpe',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      displayName: 'string',
      name: 'string',
      onlyDisplay: 'boolean',
      startTpe: 'number',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterBasicInfoResponseBodyClusterInfoSoftwareInfoSoftwares extends $tea.Model {
  software?: DescribeClusterBasicInfoResponseBodyClusterInfoSoftwareInfoSoftwaresSoftware[];
  static names(): { [key: string]: string } {
    return {
      software: 'Software',
    };
  }

  static types(): { [key: string]: any } {
    return {
      software: { 'type': 'array', 'itemType': DescribeClusterBasicInfoResponseBodyClusterInfoSoftwareInfoSoftwaresSoftware },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterBasicInfoResponseBodyClusterInfoSoftwareInfo extends $tea.Model {
  clusterType?: string;
  emrVer?: string;
  softwares?: DescribeClusterBasicInfoResponseBodyClusterInfoSoftwareInfoSoftwares;
  static names(): { [key: string]: string } {
    return {
      clusterType: 'ClusterType',
      emrVer: 'EmrVer',
      softwares: 'Softwares',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterType: 'string',
      emrVer: 'string',
      softwares: DescribeClusterBasicInfoResponseBodyClusterInfoSoftwareInfoSoftwares,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterBasicInfoResponseBodyClusterInfo extends $tea.Model {
  accessInfo?: DescribeClusterBasicInfoResponseBodyClusterInfoAccessInfo;
  autoScalingAllowed?: boolean;
  autoScalingByLoadAllowed?: boolean;
  autoScalingEnable?: boolean;
  autoScalingSpotWithLimitAllowed?: boolean;
  autoScalingVersion?: string;
  autoScalingWithGraceAllowed?: boolean;
  bootstrapActionList?: DescribeClusterBasicInfoResponseBodyClusterInfoBootstrapActionList;
  bootstrapFailed?: boolean;
  chargeType?: string;
  clusterId?: string;
  configurations?: string;
  coreNodeInService?: number;
  coreNodeTotal?: number;
  createResource?: string;
  createType?: string;
  depositType?: string;
  easEnable?: boolean;
  expiredTime?: number;
  extraInfo?: string;
  failReason?: DescribeClusterBasicInfoResponseBodyClusterInfoFailReason;
  gatewayClusterIds?: string;
  gatewayClusterInfoList?: DescribeClusterBasicInfoResponseBodyClusterInfoGatewayClusterInfoList;
  highAvailabilityEnable?: boolean;
  hostPoolInfo?: DescribeClusterBasicInfoResponseBodyClusterInfoHostPoolInfo;
  imageId?: string;
  instanceGeneration?: string;
  ioOptimized?: boolean;
  k8sClusterId?: string;
  localMetaDb?: boolean;
  logEnable?: boolean;
  logPath?: string;
  machineType?: string;
  masterNodeInService?: number;
  masterNodeTotal?: number;
  metaStoreType?: string;
  name?: string;
  netType?: string;
  operationId?: string;
  period?: number;
  regionId?: string;
  relateClusterId?: string;
  relateClusterInfo?: DescribeClusterBasicInfoResponseBodyClusterInfoRelateClusterInfo;
  resizeDiskEnable?: boolean;
  runningTime?: number;
  securityGroupId?: string;
  securityGroupName?: string;
  showSoftwareInterface?: boolean;
  softwareInfo?: DescribeClusterBasicInfoResponseBodyClusterInfoSoftwareInfo;
  startTime?: number;
  status?: string;
  stopTime?: number;
  taskNodeInService?: number;
  taskNodeTotal?: number;
  userDefinedEmrEcsRole?: string;
  userId?: string;
  vSwitchId?: string;
  vpcId?: string;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      accessInfo: 'AccessInfo',
      autoScalingAllowed: 'AutoScalingAllowed',
      autoScalingByLoadAllowed: 'AutoScalingByLoadAllowed',
      autoScalingEnable: 'AutoScalingEnable',
      autoScalingSpotWithLimitAllowed: 'AutoScalingSpotWithLimitAllowed',
      autoScalingVersion: 'AutoScalingVersion',
      autoScalingWithGraceAllowed: 'AutoScalingWithGraceAllowed',
      bootstrapActionList: 'BootstrapActionList',
      bootstrapFailed: 'BootstrapFailed',
      chargeType: 'ChargeType',
      clusterId: 'ClusterId',
      configurations: 'Configurations',
      coreNodeInService: 'CoreNodeInService',
      coreNodeTotal: 'CoreNodeTotal',
      createResource: 'CreateResource',
      createType: 'CreateType',
      depositType: 'DepositType',
      easEnable: 'EasEnable',
      expiredTime: 'ExpiredTime',
      extraInfo: 'ExtraInfo',
      failReason: 'FailReason',
      gatewayClusterIds: 'GatewayClusterIds',
      gatewayClusterInfoList: 'GatewayClusterInfoList',
      highAvailabilityEnable: 'HighAvailabilityEnable',
      hostPoolInfo: 'HostPoolInfo',
      imageId: 'ImageId',
      instanceGeneration: 'InstanceGeneration',
      ioOptimized: 'IoOptimized',
      k8sClusterId: 'K8sClusterId',
      localMetaDb: 'LocalMetaDb',
      logEnable: 'LogEnable',
      logPath: 'LogPath',
      machineType: 'MachineType',
      masterNodeInService: 'MasterNodeInService',
      masterNodeTotal: 'MasterNodeTotal',
      metaStoreType: 'MetaStoreType',
      name: 'Name',
      netType: 'NetType',
      operationId: 'OperationId',
      period: 'Period',
      regionId: 'RegionId',
      relateClusterId: 'RelateClusterId',
      relateClusterInfo: 'RelateClusterInfo',
      resizeDiskEnable: 'ResizeDiskEnable',
      runningTime: 'RunningTime',
      securityGroupId: 'SecurityGroupId',
      securityGroupName: 'SecurityGroupName',
      showSoftwareInterface: 'ShowSoftwareInterface',
      softwareInfo: 'SoftwareInfo',
      startTime: 'StartTime',
      status: 'Status',
      stopTime: 'StopTime',
      taskNodeInService: 'TaskNodeInService',
      taskNodeTotal: 'TaskNodeTotal',
      userDefinedEmrEcsRole: 'UserDefinedEmrEcsRole',
      userId: 'UserId',
      vSwitchId: 'VSwitchId',
      vpcId: 'VpcId',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessInfo: DescribeClusterBasicInfoResponseBodyClusterInfoAccessInfo,
      autoScalingAllowed: 'boolean',
      autoScalingByLoadAllowed: 'boolean',
      autoScalingEnable: 'boolean',
      autoScalingSpotWithLimitAllowed: 'boolean',
      autoScalingVersion: 'string',
      autoScalingWithGraceAllowed: 'boolean',
      bootstrapActionList: DescribeClusterBasicInfoResponseBodyClusterInfoBootstrapActionList,
      bootstrapFailed: 'boolean',
      chargeType: 'string',
      clusterId: 'string',
      configurations: 'string',
      coreNodeInService: 'number',
      coreNodeTotal: 'number',
      createResource: 'string',
      createType: 'string',
      depositType: 'string',
      easEnable: 'boolean',
      expiredTime: 'number',
      extraInfo: 'string',
      failReason: DescribeClusterBasicInfoResponseBodyClusterInfoFailReason,
      gatewayClusterIds: 'string',
      gatewayClusterInfoList: DescribeClusterBasicInfoResponseBodyClusterInfoGatewayClusterInfoList,
      highAvailabilityEnable: 'boolean',
      hostPoolInfo: DescribeClusterBasicInfoResponseBodyClusterInfoHostPoolInfo,
      imageId: 'string',
      instanceGeneration: 'string',
      ioOptimized: 'boolean',
      k8sClusterId: 'string',
      localMetaDb: 'boolean',
      logEnable: 'boolean',
      logPath: 'string',
      machineType: 'string',
      masterNodeInService: 'number',
      masterNodeTotal: 'number',
      metaStoreType: 'string',
      name: 'string',
      netType: 'string',
      operationId: 'string',
      period: 'number',
      regionId: 'string',
      relateClusterId: 'string',
      relateClusterInfo: DescribeClusterBasicInfoResponseBodyClusterInfoRelateClusterInfo,
      resizeDiskEnable: 'boolean',
      runningTime: 'number',
      securityGroupId: 'string',
      securityGroupName: 'string',
      showSoftwareInterface: 'boolean',
      softwareInfo: DescribeClusterBasicInfoResponseBodyClusterInfoSoftwareInfo,
      startTime: 'number',
      status: 'string',
      stopTime: 'number',
      taskNodeInService: 'number',
      taskNodeTotal: 'number',
      userDefinedEmrEcsRole: 'string',
      userId: 'string',
      vSwitchId: 'string',
      vpcId: 'string',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterServiceResponseBodyServiceInfoClusterServiceSummaryListClusterServiceSummary extends $tea.Model {
  alertInfo?: string;
  category?: string;
  desiredStoppedValue?: number;
  displayName?: string;
  key?: string;
  status?: string;
  type?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      alertInfo: 'AlertInfo',
      category: 'Category',
      desiredStoppedValue: 'DesiredStoppedValue',
      displayName: 'DisplayName',
      key: 'Key',
      status: 'Status',
      type: 'Type',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertInfo: 'string',
      category: 'string',
      desiredStoppedValue: 'number',
      displayName: 'string',
      key: 'string',
      status: 'string',
      type: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterServiceResponseBodyServiceInfoClusterServiceSummaryList extends $tea.Model {
  clusterServiceSummary?: DescribeClusterServiceResponseBodyServiceInfoClusterServiceSummaryListClusterServiceSummary[];
  static names(): { [key: string]: string } {
    return {
      clusterServiceSummary: 'ClusterServiceSummary',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterServiceSummary: { 'type': 'array', 'itemType': DescribeClusterServiceResponseBodyServiceInfoClusterServiceSummaryListClusterServiceSummary },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterServiceResponseBodyServiceInfoNeedRestartComponentNameList extends $tea.Model {
  service?: string[];
  static names(): { [key: string]: string } {
    return {
      service: 'Service',
    };
  }

  static types(): { [key: string]: any } {
    return {
      service: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterServiceResponseBodyServiceInfoNeedRestartHostIdList extends $tea.Model {
  service?: string[];
  static names(): { [key: string]: string } {
    return {
      service: 'Service',
    };
  }

  static types(): { [key: string]: any } {
    return {
      service: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterServiceResponseBodyServiceInfoServiceActionListServiceAction extends $tea.Model {
  actionName?: string;
  command?: string;
  componentName?: string;
  displayName?: string;
  serviceName?: string;
  static names(): { [key: string]: string } {
    return {
      actionName: 'ActionName',
      command: 'Command',
      componentName: 'ComponentName',
      displayName: 'DisplayName',
      serviceName: 'ServiceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actionName: 'string',
      command: 'string',
      componentName: 'string',
      displayName: 'string',
      serviceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterServiceResponseBodyServiceInfoServiceActionList extends $tea.Model {
  serviceAction?: DescribeClusterServiceResponseBodyServiceInfoServiceActionListServiceAction[];
  static names(): { [key: string]: string } {
    return {
      serviceAction: 'ServiceAction',
    };
  }

  static types(): { [key: string]: any } {
    return {
      serviceAction: { 'type': 'array', 'itemType': DescribeClusterServiceResponseBodyServiceInfoServiceActionListServiceAction },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterServiceResponseBodyServiceInfo extends $tea.Model {
  clusterServiceSummaryList?: DescribeClusterServiceResponseBodyServiceInfoClusterServiceSummaryList;
  needRestartComponentNameList?: DescribeClusterServiceResponseBodyServiceInfoNeedRestartComponentNameList;
  needRestartHostIdList?: DescribeClusterServiceResponseBodyServiceInfoNeedRestartHostIdList;
  needRestartInfo?: string;
  needRestartNum?: number;
  serviceActionList?: DescribeClusterServiceResponseBodyServiceInfoServiceActionList;
  serviceName?: string;
  serviceStatus?: string;
  serviceVersion?: string;
  static names(): { [key: string]: string } {
    return {
      clusterServiceSummaryList: 'ClusterServiceSummaryList',
      needRestartComponentNameList: 'NeedRestartComponentNameList',
      needRestartHostIdList: 'NeedRestartHostIdList',
      needRestartInfo: 'NeedRestartInfo',
      needRestartNum: 'NeedRestartNum',
      serviceActionList: 'ServiceActionList',
      serviceName: 'ServiceName',
      serviceStatus: 'ServiceStatus',
      serviceVersion: 'ServiceVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterServiceSummaryList: DescribeClusterServiceResponseBodyServiceInfoClusterServiceSummaryList,
      needRestartComponentNameList: DescribeClusterServiceResponseBodyServiceInfoNeedRestartComponentNameList,
      needRestartHostIdList: DescribeClusterServiceResponseBodyServiceInfoNeedRestartHostIdList,
      needRestartInfo: 'string',
      needRestartNum: 'number',
      serviceActionList: DescribeClusterServiceResponseBodyServiceInfoServiceActionList,
      serviceName: 'string',
      serviceStatus: 'string',
      serviceVersion: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterServiceConfigResponseBodyConfigConfigValueListConfigValueConfigItemValueListConfigItemValue extends $tea.Model {
  description?: string;
  isCustom?: boolean;
  itemName?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      isCustom: 'IsCustom',
      itemName: 'ItemName',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      isCustom: 'boolean',
      itemName: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterServiceConfigResponseBodyConfigConfigValueListConfigValueConfigItemValueList extends $tea.Model {
  configItemValue?: DescribeClusterServiceConfigResponseBodyConfigConfigValueListConfigValueConfigItemValueListConfigItemValue[];
  static names(): { [key: string]: string } {
    return {
      configItemValue: 'ConfigItemValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configItemValue: { 'type': 'array', 'itemType': DescribeClusterServiceConfigResponseBodyConfigConfigValueListConfigValueConfigItemValueListConfigItemValue },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterServiceConfigResponseBodyConfigConfigValueListConfigValue extends $tea.Model {
  allowCustom?: boolean;
  configItemValueList?: DescribeClusterServiceConfigResponseBodyConfigConfigValueListConfigValueConfigItemValueList;
  configName?: string;
  scope?: string;
  scopeId?: number;
  static names(): { [key: string]: string } {
    return {
      allowCustom: 'AllowCustom',
      configItemValueList: 'ConfigItemValueList',
      configName: 'ConfigName',
      scope: 'Scope',
      scopeId: 'ScopeId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allowCustom: 'boolean',
      configItemValueList: DescribeClusterServiceConfigResponseBodyConfigConfigValueListConfigValueConfigItemValueList,
      configName: 'string',
      scope: 'string',
      scopeId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterServiceConfigResponseBodyConfigConfigValueList extends $tea.Model {
  configValue?: DescribeClusterServiceConfigResponseBodyConfigConfigValueListConfigValue[];
  static names(): { [key: string]: string } {
    return {
      configValue: 'ConfigValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configValue: { 'type': 'array', 'itemType': DescribeClusterServiceConfigResponseBodyConfigConfigValueListConfigValue },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoEffectWay extends $tea.Model {
  effectType?: string;
  invokeServiceName?: string;
  static names(): { [key: string]: string } {
    return {
      effectType: 'EffectType',
      invokeServiceName: 'InvokeServiceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      effectType: 'string',
      invokeServiceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyTypes extends $tea.Model {
  propertyType?: string[];
  static names(): { [key: string]: string } {
    return {
      propertyType: 'propertyType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      propertyType: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyValueAttributesEntriesValueEntryInfo extends $tea.Model {
  description?: string;
  label?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      label: 'Label',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      label: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyValueAttributesEntries extends $tea.Model {
  valueEntryInfo?: DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyValueAttributesEntriesValueEntryInfo[];
  static names(): { [key: string]: string } {
    return {
      valueEntryInfo: 'ValueEntryInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      valueEntryInfo: { 'type': 'array', 'itemType': DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyValueAttributesEntriesValueEntryInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyValueAttributes extends $tea.Model {
  entries?: DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyValueAttributesEntries;
  hidden?: boolean;
  incrememtStep?: string;
  maximum?: string;
  mimimum?: string;
  readOnly?: boolean;
  type?: string;
  unit?: string;
  static names(): { [key: string]: string } {
    return {
      entries: 'Entries',
      hidden: 'Hidden',
      incrememtStep: 'IncrememtStep',
      maximum: 'Maximum',
      mimimum: 'Mimimum',
      readOnly: 'ReadOnly',
      type: 'Type',
      unit: 'Unit',
    };
  }

  static types(): { [key: string]: any } {
    return {
      entries: DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyValueAttributesEntries,
      hidden: 'boolean',
      incrememtStep: 'string',
      maximum: 'string',
      mimimum: 'string',
      readOnly: 'boolean',
      type: 'string',
      unit: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfo extends $tea.Model {
  component?: string;
  description?: string;
  displayName?: string;
  effectWay?: DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoEffectWay;
  fileName?: string;
  name?: string;
  propertyTypes?: DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyTypes;
  propertyValueAttributes?: DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyValueAttributes;
  serviceName?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      component: 'Component',
      description: 'Description',
      displayName: 'DisplayName',
      effectWay: 'EffectWay',
      fileName: 'FileName',
      name: 'Name',
      propertyTypes: 'PropertyTypes',
      propertyValueAttributes: 'PropertyValueAttributes',
      serviceName: 'ServiceName',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      component: 'string',
      description: 'string',
      displayName: 'string',
      effectWay: DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoEffectWay,
      fileName: 'string',
      name: 'string',
      propertyTypes: DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyTypes,
      propertyValueAttributes: DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyValueAttributes,
      serviceName: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterServiceConfigResponseBodyConfigPropertyInfoList extends $tea.Model {
  propertyInfo?: DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfo[];
  static names(): { [key: string]: string } {
    return {
      propertyInfo: 'PropertyInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      propertyInfo: { 'type': 'array', 'itemType': DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterServiceConfigResponseBodyConfig extends $tea.Model {
  applied?: string;
  author?: string;
  comment?: string;
  configValueList?: DescribeClusterServiceConfigResponseBodyConfigConfigValueList;
  configVersion?: string;
  createTime?: string;
  propertyInfoList?: DescribeClusterServiceConfigResponseBodyConfigPropertyInfoList;
  serviceName?: string;
  static names(): { [key: string]: string } {
    return {
      applied: 'Applied',
      author: 'Author',
      comment: 'Comment',
      configValueList: 'ConfigValueList',
      configVersion: 'ConfigVersion',
      createTime: 'CreateTime',
      propertyInfoList: 'PropertyInfoList',
      serviceName: 'ServiceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applied: 'string',
      author: 'string',
      comment: 'string',
      configValueList: DescribeClusterServiceConfigResponseBodyConfigConfigValueList,
      configVersion: 'string',
      createTime: 'string',
      propertyInfoList: DescribeClusterServiceConfigResponseBodyConfigPropertyInfoList,
      serviceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterServiceConfigHistoryResponseBodyConfigConfigValueListConfigValueConfigItemValueListConfigItemValue extends $tea.Model {
  changeType?: string;
  itemName?: string;
  oldValue?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      changeType: 'ChangeType',
      itemName: 'ItemName',
      oldValue: 'OldValue',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      changeType: 'string',
      itemName: 'string',
      oldValue: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterServiceConfigHistoryResponseBodyConfigConfigValueListConfigValueConfigItemValueList extends $tea.Model {
  configItemValue?: DescribeClusterServiceConfigHistoryResponseBodyConfigConfigValueListConfigValueConfigItemValueListConfigItemValue[];
  static names(): { [key: string]: string } {
    return {
      configItemValue: 'ConfigItemValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configItemValue: { 'type': 'array', 'itemType': DescribeClusterServiceConfigHistoryResponseBodyConfigConfigValueListConfigValueConfigItemValueListConfigItemValue },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterServiceConfigHistoryResponseBodyConfigConfigValueListConfigValue extends $tea.Model {
  configItemValueList?: DescribeClusterServiceConfigHistoryResponseBodyConfigConfigValueListConfigValueConfigItemValueList;
  configName?: string;
  static names(): { [key: string]: string } {
    return {
      configItemValueList: 'ConfigItemValueList',
      configName: 'ConfigName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configItemValueList: DescribeClusterServiceConfigHistoryResponseBodyConfigConfigValueListConfigValueConfigItemValueList,
      configName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterServiceConfigHistoryResponseBodyConfigConfigValueList extends $tea.Model {
  configValue?: DescribeClusterServiceConfigHistoryResponseBodyConfigConfigValueListConfigValue[];
  static names(): { [key: string]: string } {
    return {
      configValue: 'ConfigValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configValue: { 'type': 'array', 'itemType': DescribeClusterServiceConfigHistoryResponseBodyConfigConfigValueListConfigValue },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterServiceConfigHistoryResponseBodyConfig extends $tea.Model {
  applied?: boolean;
  author?: string;
  comment?: string;
  configValueList?: DescribeClusterServiceConfigHistoryResponseBodyConfigConfigValueList;
  configVersion?: string;
  createTime?: string;
  serviceName?: string;
  static names(): { [key: string]: string } {
    return {
      applied: 'Applied',
      author: 'Author',
      comment: 'Comment',
      configValueList: 'ConfigValueList',
      configVersion: 'ConfigVersion',
      createTime: 'CreateTime',
      serviceName: 'ServiceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applied: 'boolean',
      author: 'string',
      comment: 'string',
      configValueList: DescribeClusterServiceConfigHistoryResponseBodyConfigConfigValueList,
      configVersion: 'string',
      createTime: 'string',
      serviceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterServiceConfigTagResponseBodyConfigTagListConfigTagValueListValue extends $tea.Model {
  value?: string;
  valueDesc?: string;
  static names(): { [key: string]: string } {
    return {
      value: 'Value',
      valueDesc: 'ValueDesc',
    };
  }

  static types(): { [key: string]: any } {
    return {
      value: 'string',
      valueDesc: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterServiceConfigTagResponseBodyConfigTagListConfigTagValueList extends $tea.Model {
  value?: DescribeClusterServiceConfigTagResponseBodyConfigTagListConfigTagValueListValue[];
  static names(): { [key: string]: string } {
    return {
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      value: { 'type': 'array', 'itemType': DescribeClusterServiceConfigTagResponseBodyConfigTagListConfigTagValueListValue },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterServiceConfigTagResponseBodyConfigTagListConfigTag extends $tea.Model {
  tag?: string;
  tagDesc?: string;
  valueList?: DescribeClusterServiceConfigTagResponseBodyConfigTagListConfigTagValueList;
  static names(): { [key: string]: string } {
    return {
      tag: 'Tag',
      tagDesc: 'TagDesc',
      valueList: 'ValueList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tag: 'string',
      tagDesc: 'string',
      valueList: DescribeClusterServiceConfigTagResponseBodyConfigTagListConfigTagValueList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterServiceConfigTagResponseBodyConfigTagList extends $tea.Model {
  configTag?: DescribeClusterServiceConfigTagResponseBodyConfigTagListConfigTag[];
  static names(): { [key: string]: string } {
    return {
      configTag: 'ConfigTag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configTag: { 'type': 'array', 'itemType': DescribeClusterServiceConfigTagResponseBodyConfigTagListConfigTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterTemplateResponseBodyTemplateInfoBootstrapActionListBootstrapAction extends $tea.Model {
  arg?: string;
  name?: string;
  path?: string;
  static names(): { [key: string]: string } {
    return {
      arg: 'Arg',
      name: 'Name',
      path: 'Path',
    };
  }

  static types(): { [key: string]: any } {
    return {
      arg: 'string',
      name: 'string',
      path: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterTemplateResponseBodyTemplateInfoBootstrapActionList extends $tea.Model {
  bootstrapAction?: DescribeClusterTemplateResponseBodyTemplateInfoBootstrapActionListBootstrapAction[];
  static names(): { [key: string]: string } {
    return {
      bootstrapAction: 'BootstrapAction',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bootstrapAction: { 'type': 'array', 'itemType': DescribeClusterTemplateResponseBodyTemplateInfoBootstrapActionListBootstrapAction },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterTemplateResponseBodyTemplateInfoConfigListConfig extends $tea.Model {
  configKey?: string;
  configValue?: string;
  encrypt?: string;
  fileName?: string;
  replace?: string;
  serviceName?: string;
  static names(): { [key: string]: string } {
    return {
      configKey: 'ConfigKey',
      configValue: 'ConfigValue',
      encrypt: 'Encrypt',
      fileName: 'FileName',
      replace: 'Replace',
      serviceName: 'ServiceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configKey: 'string',
      configValue: 'string',
      encrypt: 'string',
      fileName: 'string',
      replace: 'string',
      serviceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterTemplateResponseBodyTemplateInfoConfigList extends $tea.Model {
  config?: DescribeClusterTemplateResponseBodyTemplateInfoConfigListConfig[];
  static names(): { [key: string]: string } {
    return {
      config: 'Config',
    };
  }

  static types(): { [key: string]: any } {
    return {
      config: { 'type': 'array', 'itemType': DescribeClusterTemplateResponseBodyTemplateInfoConfigListConfig },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterTemplateResponseBodyTemplateInfoHostGroupListHostGroup extends $tea.Model {
  chargeType?: string;
  diskCapacity?: number;
  diskCount?: number;
  diskType?: string;
  hostGroupId?: string;
  hostGroupName?: string;
  hostGroupType?: string;
  instanceType?: string;
  multiInstanceTypes?: string;
  nodeCount?: number;
  period?: string;
  sysDiskCapacity?: number;
  sysDiskType?: string;
  static names(): { [key: string]: string } {
    return {
      chargeType: 'ChargeType',
      diskCapacity: 'DiskCapacity',
      diskCount: 'DiskCount',
      diskType: 'DiskType',
      hostGroupId: 'HostGroupId',
      hostGroupName: 'HostGroupName',
      hostGroupType: 'HostGroupType',
      instanceType: 'InstanceType',
      multiInstanceTypes: 'MultiInstanceTypes',
      nodeCount: 'NodeCount',
      period: 'Period',
      sysDiskCapacity: 'SysDiskCapacity',
      sysDiskType: 'SysDiskType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      chargeType: 'string',
      diskCapacity: 'number',
      diskCount: 'number',
      diskType: 'string',
      hostGroupId: 'string',
      hostGroupName: 'string',
      hostGroupType: 'string',
      instanceType: 'string',
      multiInstanceTypes: 'string',
      nodeCount: 'number',
      period: 'string',
      sysDiskCapacity: 'number',
      sysDiskType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterTemplateResponseBodyTemplateInfoHostGroupList extends $tea.Model {
  hostGroup?: DescribeClusterTemplateResponseBodyTemplateInfoHostGroupListHostGroup[];
  static names(): { [key: string]: string } {
    return {
      hostGroup: 'HostGroup',
    };
  }

  static types(): { [key: string]: any } {
    return {
      hostGroup: { 'type': 'array', 'itemType': DescribeClusterTemplateResponseBodyTemplateInfoHostGroupListHostGroup },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterTemplateResponseBodyTemplateInfoSoftwareInfoList extends $tea.Model {
  softwareInfo?: string[];
  static names(): { [key: string]: string } {
    return {
      softwareInfo: 'SoftwareInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      softwareInfo: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterTemplateResponseBodyTemplateInfoTagsTag extends $tea.Model {
  tagKey?: string;
  tagValue?: string;
  static names(): { [key: string]: string } {
    return {
      tagKey: 'TagKey',
      tagValue: 'TagValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagKey: 'string',
      tagValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterTemplateResponseBodyTemplateInfoTags extends $tea.Model {
  tag?: DescribeClusterTemplateResponseBodyTemplateInfoTagsTag[];
  static names(): { [key: string]: string } {
    return {
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tag: { 'type': 'array', 'itemType': DescribeClusterTemplateResponseBodyTemplateInfoTagsTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterTemplateResponseBodyTemplateInfo extends $tea.Model {
  allowNotebook?: boolean;
  bootstrapActionList?: DescribeClusterTemplateResponseBodyTemplateInfoBootstrapActionList;
  clusterType?: string;
  configList?: DescribeClusterTemplateResponseBodyTemplateInfoConfigList;
  configurations?: string;
  createSource?: string;
  depositType?: string;
  easEnable?: boolean;
  emrVer?: string;
  gmtCreate?: number;
  gmtModified?: number;
  highAvailabilityEnable?: boolean;
  hostGroupList?: DescribeClusterTemplateResponseBodyTemplateInfoHostGroupList;
  id?: string;
  initCustomHiveMetaDb?: boolean;
  instanceGeneration?: string;
  ioOptimized?: boolean;
  isOpenPublicIp?: boolean;
  keyPairName?: string;
  logEnable?: boolean;
  logPath?: string;
  machineType?: string;
  masterNodeTotal?: number;
  masterPwd?: string;
  metaStoreConf?: string;
  metaStoreType?: string;
  netType?: string;
  securityGroupId?: string;
  securityGroupName?: string;
  softwareInfoList?: DescribeClusterTemplateResponseBodyTemplateInfoSoftwareInfoList;
  sshEnable?: boolean;
  tags?: DescribeClusterTemplateResponseBodyTemplateInfoTags;
  templateName?: string;
  useCustomHiveMetaDb?: boolean;
  useLocalMetaDb?: boolean;
  userDefinedEmrEcsRole?: string;
  userId?: string;
  vSwitchId?: string;
  vpcId?: string;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      allowNotebook: 'AllowNotebook',
      bootstrapActionList: 'BootstrapActionList',
      clusterType: 'ClusterType',
      configList: 'ConfigList',
      configurations: 'Configurations',
      createSource: 'CreateSource',
      depositType: 'DepositType',
      easEnable: 'EasEnable',
      emrVer: 'EmrVer',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      highAvailabilityEnable: 'HighAvailabilityEnable',
      hostGroupList: 'HostGroupList',
      id: 'Id',
      initCustomHiveMetaDb: 'InitCustomHiveMetaDb',
      instanceGeneration: 'InstanceGeneration',
      ioOptimized: 'IoOptimized',
      isOpenPublicIp: 'IsOpenPublicIp',
      keyPairName: 'KeyPairName',
      logEnable: 'LogEnable',
      logPath: 'LogPath',
      machineType: 'MachineType',
      masterNodeTotal: 'MasterNodeTotal',
      masterPwd: 'MasterPwd',
      metaStoreConf: 'MetaStoreConf',
      metaStoreType: 'MetaStoreType',
      netType: 'NetType',
      securityGroupId: 'SecurityGroupId',
      securityGroupName: 'SecurityGroupName',
      softwareInfoList: 'SoftwareInfoList',
      sshEnable: 'SshEnable',
      tags: 'Tags',
      templateName: 'TemplateName',
      useCustomHiveMetaDb: 'UseCustomHiveMetaDb',
      useLocalMetaDb: 'UseLocalMetaDb',
      userDefinedEmrEcsRole: 'UserDefinedEmrEcsRole',
      userId: 'UserId',
      vSwitchId: 'VSwitchId',
      vpcId: 'VpcId',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allowNotebook: 'boolean',
      bootstrapActionList: DescribeClusterTemplateResponseBodyTemplateInfoBootstrapActionList,
      clusterType: 'string',
      configList: DescribeClusterTemplateResponseBodyTemplateInfoConfigList,
      configurations: 'string',
      createSource: 'string',
      depositType: 'string',
      easEnable: 'boolean',
      emrVer: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      highAvailabilityEnable: 'boolean',
      hostGroupList: DescribeClusterTemplateResponseBodyTemplateInfoHostGroupList,
      id: 'string',
      initCustomHiveMetaDb: 'boolean',
      instanceGeneration: 'string',
      ioOptimized: 'boolean',
      isOpenPublicIp: 'boolean',
      keyPairName: 'string',
      logEnable: 'boolean',
      logPath: 'string',
      machineType: 'string',
      masterNodeTotal: 'number',
      masterPwd: 'string',
      metaStoreConf: 'string',
      metaStoreType: 'string',
      netType: 'string',
      securityGroupId: 'string',
      securityGroupName: 'string',
      softwareInfoList: DescribeClusterTemplateResponseBodyTemplateInfoSoftwareInfoList,
      sshEnable: 'boolean',
      tags: DescribeClusterTemplateResponseBodyTemplateInfoTags,
      templateName: 'string',
      useCustomHiveMetaDb: 'boolean',
      useLocalMetaDb: 'boolean',
      userDefinedEmrEcsRole: 'string',
      userId: 'string',
      vSwitchId: 'string',
      vpcId: 'string',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterV2ResponseBodyClusterInfoAccessInfoZKLinksZKLink extends $tea.Model {
  link?: string;
  port?: string;
  static names(): { [key: string]: string } {
    return {
      link: 'Link',
      port: 'Port',
    };
  }

  static types(): { [key: string]: any } {
    return {
      link: 'string',
      port: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterV2ResponseBodyClusterInfoAccessInfoZKLinks extends $tea.Model {
  ZKLink?: DescribeClusterV2ResponseBodyClusterInfoAccessInfoZKLinksZKLink[];
  static names(): { [key: string]: string } {
    return {
      ZKLink: 'ZKLink',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ZKLink: { 'type': 'array', 'itemType': DescribeClusterV2ResponseBodyClusterInfoAccessInfoZKLinksZKLink },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterV2ResponseBodyClusterInfoAccessInfo extends $tea.Model {
  ZKLinks?: DescribeClusterV2ResponseBodyClusterInfoAccessInfoZKLinks;
  static names(): { [key: string]: string } {
    return {
      ZKLinks: 'ZKLinks',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ZKLinks: DescribeClusterV2ResponseBodyClusterInfoAccessInfoZKLinks,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterV2ResponseBodyClusterInfoBootstrapActionListBootstrapAction extends $tea.Model {
  arg?: string;
  name?: string;
  path?: string;
  static names(): { [key: string]: string } {
    return {
      arg: 'Arg',
      name: 'Name',
      path: 'Path',
    };
  }

  static types(): { [key: string]: any } {
    return {
      arg: 'string',
      name: 'string',
      path: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterV2ResponseBodyClusterInfoBootstrapActionList extends $tea.Model {
  bootstrapAction?: DescribeClusterV2ResponseBodyClusterInfoBootstrapActionListBootstrapAction[];
  static names(): { [key: string]: string } {
    return {
      bootstrapAction: 'BootstrapAction',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bootstrapAction: { 'type': 'array', 'itemType': DescribeClusterV2ResponseBodyClusterInfoBootstrapActionListBootstrapAction },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterV2ResponseBodyClusterInfoFailReason extends $tea.Model {
  errorCode?: string;
  errorMsg?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMsg: 'ErrorMsg',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMsg: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterV2ResponseBodyClusterInfoGatewayClusterInfoListGatewayClusterInfo extends $tea.Model {
  clusterId?: string;
  clusterName?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      clusterName: 'ClusterName',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      clusterName: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterV2ResponseBodyClusterInfoGatewayClusterInfoList extends $tea.Model {
  gatewayClusterInfo?: DescribeClusterV2ResponseBodyClusterInfoGatewayClusterInfoListGatewayClusterInfo[];
  static names(): { [key: string]: string } {
    return {
      gatewayClusterInfo: 'GatewayClusterInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gatewayClusterInfo: { 'type': 'array', 'itemType': DescribeClusterV2ResponseBodyClusterInfoGatewayClusterInfoListGatewayClusterInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDaemonInfosDaemonInfo extends $tea.Model {
  name?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDaemonInfos extends $tea.Model {
  daemonInfo?: DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDaemonInfosDaemonInfo[];
  static names(): { [key: string]: string } {
    return {
      daemonInfo: 'DaemonInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      daemonInfo: { 'type': 'array', 'itemType': DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDaemonInfosDaemonInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDiskInfosDiskInfo extends $tea.Model {
  device?: string;
  diskId?: string;
  diskName?: string;
  size?: number;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      device: 'Device',
      diskId: 'DiskId',
      diskName: 'DiskName',
      size: 'Size',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      device: 'string',
      diskId: 'string',
      diskName: 'string',
      size: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDiskInfos extends $tea.Model {
  diskInfo?: DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDiskInfosDiskInfo[];
  static names(): { [key: string]: string } {
    return {
      diskInfo: 'DiskInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      diskInfo: { 'type': 'array', 'itemType': DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDiskInfosDiskInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNode extends $tea.Model {
  createTime?: string;
  daemonInfos?: DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDaemonInfos;
  diskInfos?: DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDiskInfos;
  emrExpiredTime?: string;
  expiredTime?: string;
  innerIp?: string;
  instanceId?: string;
  pubIp?: string;
  status?: string;
  supportIpV6?: boolean;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      daemonInfos: 'DaemonInfos',
      diskInfos: 'DiskInfos',
      emrExpiredTime: 'EmrExpiredTime',
      expiredTime: 'ExpiredTime',
      innerIp: 'InnerIp',
      instanceId: 'InstanceId',
      pubIp: 'PubIp',
      status: 'Status',
      supportIpV6: 'SupportIpV6',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'string',
      daemonInfos: DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDaemonInfos,
      diskInfos: DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDiskInfos,
      emrExpiredTime: 'string',
      expiredTime: 'string',
      innerIp: 'string',
      instanceId: 'string',
      pubIp: 'string',
      status: 'string',
      supportIpV6: 'boolean',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodes extends $tea.Model {
  node?: DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNode[];
  static names(): { [key: string]: string } {
    return {
      node: 'Node',
    };
  }

  static types(): { [key: string]: any } {
    return {
      node: { 'type': 'array', 'itemType': DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNode },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroup extends $tea.Model {
  bandWidth?: string;
  chargeType?: string;
  cpuCore?: number;
  diskCapacity?: number;
  diskCount?: number;
  diskType?: string;
  hostGroupChangeStatus?: string;
  hostGroupChangeType?: string;
  hostGroupId?: string;
  hostGroupName?: string;
  hostGroupSubType?: string;
  hostGroupType?: string;
  instanceType?: string;
  lockReason?: string;
  lockType?: string;
  memoryCapacity?: number;
  nodeCount?: number;
  nodes?: DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodes;
  period?: string;
  static names(): { [key: string]: string } {
    return {
      bandWidth: 'BandWidth',
      chargeType: 'ChargeType',
      cpuCore: 'CpuCore',
      diskCapacity: 'DiskCapacity',
      diskCount: 'DiskCount',
      diskType: 'DiskType',
      hostGroupChangeStatus: 'HostGroupChangeStatus',
      hostGroupChangeType: 'HostGroupChangeType',
      hostGroupId: 'HostGroupId',
      hostGroupName: 'HostGroupName',
      hostGroupSubType: 'HostGroupSubType',
      hostGroupType: 'HostGroupType',
      instanceType: 'InstanceType',
      lockReason: 'LockReason',
      lockType: 'LockType',
      memoryCapacity: 'MemoryCapacity',
      nodeCount: 'NodeCount',
      nodes: 'Nodes',
      period: 'Period',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bandWidth: 'string',
      chargeType: 'string',
      cpuCore: 'number',
      diskCapacity: 'number',
      diskCount: 'number',
      diskType: 'string',
      hostGroupChangeStatus: 'string',
      hostGroupChangeType: 'string',
      hostGroupId: 'string',
      hostGroupName: 'string',
      hostGroupSubType: 'string',
      hostGroupType: 'string',
      instanceType: 'string',
      lockReason: 'string',
      lockType: 'string',
      memoryCapacity: 'number',
      nodeCount: 'number',
      nodes: DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodes,
      period: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterV2ResponseBodyClusterInfoHostGroupList extends $tea.Model {
  hostGroup?: DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroup[];
  static names(): { [key: string]: string } {
    return {
      hostGroup: 'HostGroup',
    };
  }

  static types(): { [key: string]: any } {
    return {
      hostGroup: { 'type': 'array', 'itemType': DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroup },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterV2ResponseBodyClusterInfoHostPoolInfo extends $tea.Model {
  hpBizId?: string;
  hpName?: string;
  static names(): { [key: string]: string } {
    return {
      hpBizId: 'HpBizId',
      hpName: 'HpName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      hpBizId: 'string',
      hpName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterV2ResponseBodyClusterInfoRelateClusterInfo extends $tea.Model {
  clusterId?: string;
  clusterName?: string;
  clusterType?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      clusterName: 'ClusterName',
      clusterType: 'ClusterType',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      clusterName: 'string',
      clusterType: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterV2ResponseBodyClusterInfoSoftwareInfoSoftwaresSoftware extends $tea.Model {
  displayName?: string;
  name?: string;
  onlyDisplay?: boolean;
  startTpe?: number;
  version?: string;
  static names(): { [key: string]: string } {
    return {
      displayName: 'DisplayName',
      name: 'Name',
      onlyDisplay: 'OnlyDisplay',
      startTpe: 'StartTpe',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      displayName: 'string',
      name: 'string',
      onlyDisplay: 'boolean',
      startTpe: 'number',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterV2ResponseBodyClusterInfoSoftwareInfoSoftwares extends $tea.Model {
  software?: DescribeClusterV2ResponseBodyClusterInfoSoftwareInfoSoftwaresSoftware[];
  static names(): { [key: string]: string } {
    return {
      software: 'Software',
    };
  }

  static types(): { [key: string]: any } {
    return {
      software: { 'type': 'array', 'itemType': DescribeClusterV2ResponseBodyClusterInfoSoftwareInfoSoftwaresSoftware },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterV2ResponseBodyClusterInfoSoftwareInfo extends $tea.Model {
  clusterType?: string;
  emrVer?: string;
  softwares?: DescribeClusterV2ResponseBodyClusterInfoSoftwareInfoSoftwares;
  static names(): { [key: string]: string } {
    return {
      clusterType: 'ClusterType',
      emrVer: 'EmrVer',
      softwares: 'Softwares',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterType: 'string',
      emrVer: 'string',
      softwares: DescribeClusterV2ResponseBodyClusterInfoSoftwareInfoSoftwares,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterV2ResponseBodyClusterInfo extends $tea.Model {
  accessInfo?: DescribeClusterV2ResponseBodyClusterInfoAccessInfo;
  autoScalingAllowed?: boolean;
  autoScalingByLoadAllowed?: boolean;
  autoScalingEnable?: boolean;
  autoScalingSpotWithLimitAllowed?: boolean;
  autoScalingVersion?: string;
  autoScalingWithGraceAllowed?: boolean;
  bootstrapActionList?: DescribeClusterV2ResponseBodyClusterInfoBootstrapActionList;
  bootstrapFailed?: boolean;
  chargeType?: string;
  configurations?: string;
  coreNodeInService?: number;
  coreNodeTotal?: number;
  createResource?: string;
  createType?: string;
  depositType?: string;
  easEnable?: boolean;
  expiredTime?: number;
  extraInfo?: string;
  failReason?: DescribeClusterV2ResponseBodyClusterInfoFailReason;
  gatewayClusterIds?: string;
  gatewayClusterInfoList?: DescribeClusterV2ResponseBodyClusterInfoGatewayClusterInfoList;
  highAvailabilityEnable?: boolean;
  hostGroupList?: DescribeClusterV2ResponseBodyClusterInfoHostGroupList;
  hostPoolInfo?: DescribeClusterV2ResponseBodyClusterInfoHostPoolInfo;
  id?: string;
  imageId?: string;
  instanceGeneration?: string;
  ioOptimized?: boolean;
  k8sClusterId?: string;
  localMetaDb?: boolean;
  logEnable?: boolean;
  logPath?: string;
  machineType?: string;
  masterNodeInService?: number;
  masterNodeTotal?: number;
  metaStoreType?: string;
  name?: string;
  netType?: string;
  period?: number;
  regionId?: string;
  relateClusterId?: string;
  relateClusterInfo?: DescribeClusterV2ResponseBodyClusterInfoRelateClusterInfo;
  resizeDiskEnable?: boolean;
  runningTime?: number;
  securityGroupId?: string;
  securityGroupName?: string;
  showSoftwareInterface?: boolean;
  softwareInfo?: DescribeClusterV2ResponseBodyClusterInfoSoftwareInfo;
  startTime?: number;
  status?: string;
  stopTime?: number;
  taskNodeInService?: number;
  taskNodeTotal?: number;
  userDefinedEmrEcsRole?: string;
  userId?: string;
  vSwitchId?: string;
  vpcId?: string;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      accessInfo: 'AccessInfo',
      autoScalingAllowed: 'AutoScalingAllowed',
      autoScalingByLoadAllowed: 'AutoScalingByLoadAllowed',
      autoScalingEnable: 'AutoScalingEnable',
      autoScalingSpotWithLimitAllowed: 'AutoScalingSpotWithLimitAllowed',
      autoScalingVersion: 'AutoScalingVersion',
      autoScalingWithGraceAllowed: 'AutoScalingWithGraceAllowed',
      bootstrapActionList: 'BootstrapActionList',
      bootstrapFailed: 'BootstrapFailed',
      chargeType: 'ChargeType',
      configurations: 'Configurations',
      coreNodeInService: 'CoreNodeInService',
      coreNodeTotal: 'CoreNodeTotal',
      createResource: 'CreateResource',
      createType: 'CreateType',
      depositType: 'DepositType',
      easEnable: 'EasEnable',
      expiredTime: 'ExpiredTime',
      extraInfo: 'ExtraInfo',
      failReason: 'FailReason',
      gatewayClusterIds: 'GatewayClusterIds',
      gatewayClusterInfoList: 'GatewayClusterInfoList',
      highAvailabilityEnable: 'HighAvailabilityEnable',
      hostGroupList: 'HostGroupList',
      hostPoolInfo: 'HostPoolInfo',
      id: 'Id',
      imageId: 'ImageId',
      instanceGeneration: 'InstanceGeneration',
      ioOptimized: 'IoOptimized',
      k8sClusterId: 'K8sClusterId',
      localMetaDb: 'LocalMetaDb',
      logEnable: 'LogEnable',
      logPath: 'LogPath',
      machineType: 'MachineType',
      masterNodeInService: 'MasterNodeInService',
      masterNodeTotal: 'MasterNodeTotal',
      metaStoreType: 'MetaStoreType',
      name: 'Name',
      netType: 'NetType',
      period: 'Period',
      regionId: 'RegionId',
      relateClusterId: 'RelateClusterId',
      relateClusterInfo: 'RelateClusterInfo',
      resizeDiskEnable: 'ResizeDiskEnable',
      runningTime: 'RunningTime',
      securityGroupId: 'SecurityGroupId',
      securityGroupName: 'SecurityGroupName',
      showSoftwareInterface: 'ShowSoftwareInterface',
      softwareInfo: 'SoftwareInfo',
      startTime: 'StartTime',
      status: 'Status',
      stopTime: 'StopTime',
      taskNodeInService: 'TaskNodeInService',
      taskNodeTotal: 'TaskNodeTotal',
      userDefinedEmrEcsRole: 'UserDefinedEmrEcsRole',
      userId: 'UserId',
      vSwitchId: 'VSwitchId',
      vpcId: 'VpcId',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessInfo: DescribeClusterV2ResponseBodyClusterInfoAccessInfo,
      autoScalingAllowed: 'boolean',
      autoScalingByLoadAllowed: 'boolean',
      autoScalingEnable: 'boolean',
      autoScalingSpotWithLimitAllowed: 'boolean',
      autoScalingVersion: 'string',
      autoScalingWithGraceAllowed: 'boolean',
      bootstrapActionList: DescribeClusterV2ResponseBodyClusterInfoBootstrapActionList,
      bootstrapFailed: 'boolean',
      chargeType: 'string',
      configurations: 'string',
      coreNodeInService: 'number',
      coreNodeTotal: 'number',
      createResource: 'string',
      createType: 'string',
      depositType: 'string',
      easEnable: 'boolean',
      expiredTime: 'number',
      extraInfo: 'string',
      failReason: DescribeClusterV2ResponseBodyClusterInfoFailReason,
      gatewayClusterIds: 'string',
      gatewayClusterInfoList: DescribeClusterV2ResponseBodyClusterInfoGatewayClusterInfoList,
      highAvailabilityEnable: 'boolean',
      hostGroupList: DescribeClusterV2ResponseBodyClusterInfoHostGroupList,
      hostPoolInfo: DescribeClusterV2ResponseBodyClusterInfoHostPoolInfo,
      id: 'string',
      imageId: 'string',
      instanceGeneration: 'string',
      ioOptimized: 'boolean',
      k8sClusterId: 'string',
      localMetaDb: 'boolean',
      logEnable: 'boolean',
      logPath: 'string',
      machineType: 'string',
      masterNodeInService: 'number',
      masterNodeTotal: 'number',
      metaStoreType: 'string',
      name: 'string',
      netType: 'string',
      period: 'number',
      regionId: 'string',
      relateClusterId: 'string',
      relateClusterInfo: DescribeClusterV2ResponseBodyClusterInfoRelateClusterInfo,
      resizeDiskEnable: 'boolean',
      runningTime: 'number',
      securityGroupId: 'string',
      securityGroupName: 'string',
      showSoftwareInterface: 'boolean',
      softwareInfo: DescribeClusterV2ResponseBodyClusterInfoSoftwareInfo,
      startTime: 'number',
      status: 'string',
      stopTime: 'number',
      taskNodeInService: 'number',
      taskNodeTotal: 'number',
      userDefinedEmrEcsRole: 'string',
      userId: 'string',
      vSwitchId: 'string',
      vpcId: 'string',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEmrMainVersionResponseBodyEmrMainVersionClusterTypeInfoListClusterTypeInfoServiceInfoListServiceInfo extends $tea.Model {
  display?: boolean;
  mandatory?: boolean;
  serviceDisplayName?: string;
  serviceDisplayVersion?: string;
  serviceName?: string;
  serviceVersion?: string;
  static names(): { [key: string]: string } {
    return {
      display: 'Display',
      mandatory: 'Mandatory',
      serviceDisplayName: 'ServiceDisplayName',
      serviceDisplayVersion: 'ServiceDisplayVersion',
      serviceName: 'ServiceName',
      serviceVersion: 'ServiceVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      display: 'boolean',
      mandatory: 'boolean',
      serviceDisplayName: 'string',
      serviceDisplayVersion: 'string',
      serviceName: 'string',
      serviceVersion: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEmrMainVersionResponseBodyEmrMainVersionClusterTypeInfoListClusterTypeInfoServiceInfoList extends $tea.Model {
  serviceInfo?: DescribeEmrMainVersionResponseBodyEmrMainVersionClusterTypeInfoListClusterTypeInfoServiceInfoListServiceInfo[];
  static names(): { [key: string]: string } {
    return {
      serviceInfo: 'ServiceInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      serviceInfo: { 'type': 'array', 'itemType': DescribeEmrMainVersionResponseBodyEmrMainVersionClusterTypeInfoListClusterTypeInfoServiceInfoListServiceInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEmrMainVersionResponseBodyEmrMainVersionClusterTypeInfoListClusterTypeInfo extends $tea.Model {
  clusterType?: string;
  serviceInfoList?: DescribeEmrMainVersionResponseBodyEmrMainVersionClusterTypeInfoListClusterTypeInfoServiceInfoList;
  static names(): { [key: string]: string } {
    return {
      clusterType: 'ClusterType',
      serviceInfoList: 'ServiceInfoList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterType: 'string',
      serviceInfoList: DescribeEmrMainVersionResponseBodyEmrMainVersionClusterTypeInfoListClusterTypeInfoServiceInfoList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEmrMainVersionResponseBodyEmrMainVersionClusterTypeInfoList extends $tea.Model {
  clusterTypeInfo?: DescribeEmrMainVersionResponseBodyEmrMainVersionClusterTypeInfoListClusterTypeInfo[];
  static names(): { [key: string]: string } {
    return {
      clusterTypeInfo: 'ClusterTypeInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterTypeInfo: { 'type': 'array', 'itemType': DescribeEmrMainVersionResponseBodyEmrMainVersionClusterTypeInfoListClusterTypeInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEmrMainVersionResponseBodyEmrMainVersionClusterTypeWhiteUserListClusterTypeWhiteUser extends $tea.Model {
  clusterType?: string;
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterType: 'ClusterType',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterType: 'string',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEmrMainVersionResponseBodyEmrMainVersionClusterTypeWhiteUserList extends $tea.Model {
  clusterTypeWhiteUser?: DescribeEmrMainVersionResponseBodyEmrMainVersionClusterTypeWhiteUserListClusterTypeWhiteUser[];
  static names(): { [key: string]: string } {
    return {
      clusterTypeWhiteUser: 'ClusterTypeWhiteUser',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterTypeWhiteUser: { 'type': 'array', 'itemType': DescribeEmrMainVersionResponseBodyEmrMainVersionClusterTypeWhiteUserListClusterTypeWhiteUser },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEmrMainVersionResponseBodyEmrMainVersionWhiteUserList extends $tea.Model {
  wwhiteUser?: string[];
  static names(): { [key: string]: string } {
    return {
      wwhiteUser: 'WwhiteUser',
    };
  }

  static types(): { [key: string]: any } {
    return {
      wwhiteUser: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEmrMainVersionResponseBodyEmrMainVersion extends $tea.Model {
  clusterTypeInfoList?: DescribeEmrMainVersionResponseBodyEmrMainVersionClusterTypeInfoList;
  clusterTypeWhiteUserList?: DescribeEmrMainVersionResponseBodyEmrMainVersionClusterTypeWhiteUserList;
  display?: boolean;
  ecmVersion?: boolean;
  emrVersion?: string;
  imageId?: string;
  publishType?: string;
  regionId?: string;
  stackName?: string;
  stackVersion?: string;
  whiteUserList?: DescribeEmrMainVersionResponseBodyEmrMainVersionWhiteUserList;
  static names(): { [key: string]: string } {
    return {
      clusterTypeInfoList: 'ClusterTypeInfoList',
      clusterTypeWhiteUserList: 'ClusterTypeWhiteUserList',
      display: 'Display',
      ecmVersion: 'EcmVersion',
      emrVersion: 'EmrVersion',
      imageId: 'ImageId',
      publishType: 'PublishType',
      regionId: 'RegionId',
      stackName: 'StackName',
      stackVersion: 'StackVersion',
      whiteUserList: 'WhiteUserList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterTypeInfoList: DescribeEmrMainVersionResponseBodyEmrMainVersionClusterTypeInfoList,
      clusterTypeWhiteUserList: DescribeEmrMainVersionResponseBodyEmrMainVersionClusterTypeWhiteUserList,
      display: 'boolean',
      ecmVersion: 'boolean',
      emrVersion: 'string',
      imageId: 'string',
      publishType: 'string',
      regionId: 'string',
      stackName: 'string',
      stackVersion: 'string',
      whiteUserList: DescribeEmrMainVersionResponseBodyEmrMainVersionWhiteUserList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExecutionPlanResponseBodyClusterInfoBootstrapActionListBootstrapAction extends $tea.Model {
  arg?: string;
  name?: string;
  path?: string;
  static names(): { [key: string]: string } {
    return {
      arg: 'Arg',
      name: 'Name',
      path: 'Path',
    };
  }

  static types(): { [key: string]: any } {
    return {
      arg: 'string',
      name: 'string',
      path: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExecutionPlanResponseBodyClusterInfoBootstrapActionList extends $tea.Model {
  bootstrapAction?: DescribeExecutionPlanResponseBodyClusterInfoBootstrapActionListBootstrapAction[];
  static names(): { [key: string]: string } {
    return {
      bootstrapAction: 'BootstrapAction',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bootstrapAction: { 'type': 'array', 'itemType': DescribeExecutionPlanResponseBodyClusterInfoBootstrapActionListBootstrapAction },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExecutionPlanResponseBodyClusterInfoConfigListConfig extends $tea.Model {
  configKey?: string;
  configValue?: string;
  encrypt?: string;
  fileName?: string;
  serviceName?: string;
  static names(): { [key: string]: string } {
    return {
      configKey: 'ConfigKey',
      configValue: 'ConfigValue',
      encrypt: 'Encrypt',
      fileName: 'FileName',
      serviceName: 'ServiceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configKey: 'string',
      configValue: 'string',
      encrypt: 'string',
      fileName: 'string',
      serviceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExecutionPlanResponseBodyClusterInfoConfigList extends $tea.Model {
  config?: DescribeExecutionPlanResponseBodyClusterInfoConfigListConfig[];
  static names(): { [key: string]: string } {
    return {
      config: 'Config',
    };
  }

  static types(): { [key: string]: any } {
    return {
      config: { 'type': 'array', 'itemType': DescribeExecutionPlanResponseBodyClusterInfoConfigListConfig },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExecutionPlanResponseBodyClusterInfoEcsOrdersEcsOrderInfo extends $tea.Model {
  diskCapacity?: number;
  diskCount?: number;
  diskType?: string;
  index?: number;
  instanceType?: string;
  nodeCount?: number;
  nodeType?: string;
  static names(): { [key: string]: string } {
    return {
      diskCapacity: 'DiskCapacity',
      diskCount: 'DiskCount',
      diskType: 'DiskType',
      index: 'Index',
      instanceType: 'InstanceType',
      nodeCount: 'NodeCount',
      nodeType: 'NodeType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      diskCapacity: 'number',
      diskCount: 'number',
      diskType: 'string',
      index: 'number',
      instanceType: 'string',
      nodeCount: 'number',
      nodeType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExecutionPlanResponseBodyClusterInfoEcsOrders extends $tea.Model {
  ecsOrderInfo?: DescribeExecutionPlanResponseBodyClusterInfoEcsOrdersEcsOrderInfo[];
  static names(): { [key: string]: string } {
    return {
      ecsOrderInfo: 'EcsOrderInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ecsOrderInfo: { 'type': 'array', 'itemType': DescribeExecutionPlanResponseBodyClusterInfoEcsOrdersEcsOrderInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExecutionPlanResponseBodyClusterInfoSoftwareInfoSoftwaresSoftware extends $tea.Model {
  displayName?: string;
  name?: string;
  onlyDisplay?: boolean;
  optional?: boolean;
  startTpe?: number;
  version?: string;
  static names(): { [key: string]: string } {
    return {
      displayName: 'DisplayName',
      name: 'Name',
      onlyDisplay: 'OnlyDisplay',
      optional: 'Optional',
      startTpe: 'StartTpe',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      displayName: 'string',
      name: 'string',
      onlyDisplay: 'boolean',
      optional: 'boolean',
      startTpe: 'number',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExecutionPlanResponseBodyClusterInfoSoftwareInfoSoftwares extends $tea.Model {
  software?: DescribeExecutionPlanResponseBodyClusterInfoSoftwareInfoSoftwaresSoftware[];
  static names(): { [key: string]: string } {
    return {
      software: 'Software',
    };
  }

  static types(): { [key: string]: any } {
    return {
      software: { 'type': 'array', 'itemType': DescribeExecutionPlanResponseBodyClusterInfoSoftwareInfoSoftwaresSoftware },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExecutionPlanResponseBodyClusterInfoSoftwareInfo extends $tea.Model {
  clusterType?: string;
  emrVer?: string;
  softwares?: DescribeExecutionPlanResponseBodyClusterInfoSoftwareInfoSoftwares;
  static names(): { [key: string]: string } {
    return {
      clusterType: 'ClusterType',
      emrVer: 'EmrVer',
      softwares: 'Softwares',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterType: 'string',
      emrVer: 'string',
      softwares: DescribeExecutionPlanResponseBodyClusterInfoSoftwareInfoSoftwares,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExecutionPlanResponseBodyClusterInfo extends $tea.Model {
  bootstrapActionList?: DescribeExecutionPlanResponseBodyClusterInfoBootstrapActionList;
  clusterType?: string;
  configList?: DescribeExecutionPlanResponseBodyClusterInfoConfigList;
  configurations?: string;
  easEnable?: boolean;
  ecsOrders?: DescribeExecutionPlanResponseBodyClusterInfoEcsOrders;
  emrVer?: string;
  highAvailabilityEnable?: boolean;
  initCustomHiveMetaDB?: boolean;
  instanceGeneration?: string;
  ioOptimized?: boolean;
  logEnable?: boolean;
  logPath?: string;
  name?: string;
  netType?: string;
  securityGroupId?: string;
  softwareInfo?: DescribeExecutionPlanResponseBodyClusterInfoSoftwareInfo;
  useCustomHiveMetaDB?: boolean;
  useLocalMetaDb?: boolean;
  userDefinedEmrEcsRole?: string;
  vSwitchId?: string;
  vpcId?: string;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      bootstrapActionList: 'BootstrapActionList',
      clusterType: 'ClusterType',
      configList: 'ConfigList',
      configurations: 'Configurations',
      easEnable: 'EasEnable',
      ecsOrders: 'EcsOrders',
      emrVer: 'EmrVer',
      highAvailabilityEnable: 'HighAvailabilityEnable',
      initCustomHiveMetaDB: 'InitCustomHiveMetaDB',
      instanceGeneration: 'InstanceGeneration',
      ioOptimized: 'IoOptimized',
      logEnable: 'LogEnable',
      logPath: 'LogPath',
      name: 'Name',
      netType: 'NetType',
      securityGroupId: 'SecurityGroupId',
      softwareInfo: 'SoftwareInfo',
      useCustomHiveMetaDB: 'UseCustomHiveMetaDB',
      useLocalMetaDb: 'UseLocalMetaDb',
      userDefinedEmrEcsRole: 'UserDefinedEmrEcsRole',
      vSwitchId: 'VSwitchId',
      vpcId: 'VpcId',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bootstrapActionList: DescribeExecutionPlanResponseBodyClusterInfoBootstrapActionList,
      clusterType: 'string',
      configList: DescribeExecutionPlanResponseBodyClusterInfoConfigList,
      configurations: 'string',
      easEnable: 'boolean',
      ecsOrders: DescribeExecutionPlanResponseBodyClusterInfoEcsOrders,
      emrVer: 'string',
      highAvailabilityEnable: 'boolean',
      initCustomHiveMetaDB: 'boolean',
      instanceGeneration: 'string',
      ioOptimized: 'boolean',
      logEnable: 'boolean',
      logPath: 'string',
      name: 'string',
      netType: 'string',
      securityGroupId: 'string',
      softwareInfo: DescribeExecutionPlanResponseBodyClusterInfoSoftwareInfo,
      useCustomHiveMetaDB: 'boolean',
      useLocalMetaDb: 'boolean',
      userDefinedEmrEcsRole: 'string',
      vSwitchId: 'string',
      vpcId: 'string',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExecutionPlanResponseBodyJobInfoListJobInfo extends $tea.Model {
  failAct?: string;
  id?: string;
  name?: string;
  runParameter?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      failAct: 'FailAct',
      id: 'Id',
      name: 'Name',
      runParameter: 'RunParameter',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failAct: 'string',
      id: 'string',
      name: 'string',
      runParameter: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExecutionPlanResponseBodyJobInfoList extends $tea.Model {
  jobInfo?: DescribeExecutionPlanResponseBodyJobInfoListJobInfo[];
  static names(): { [key: string]: string } {
    return {
      jobInfo: 'JobInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      jobInfo: { 'type': 'array', 'itemType': DescribeExecutionPlanResponseBodyJobInfoListJobInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFlowResponseBodyParentFlowListParentFlow extends $tea.Model {
  parentFlowId?: string;
  parentFlowName?: string;
  projectId?: string;
  projectName?: string;
  static names(): { [key: string]: string } {
    return {
      parentFlowId: 'ParentFlowId',
      parentFlowName: 'ParentFlowName',
      projectId: 'ProjectId',
      projectName: 'ProjectName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      parentFlowId: 'string',
      parentFlowName: 'string',
      projectId: 'string',
      projectName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFlowResponseBodyParentFlowList extends $tea.Model {
  parentFlow?: DescribeFlowResponseBodyParentFlowListParentFlow[];
  static names(): { [key: string]: string } {
    return {
      parentFlow: 'ParentFlow',
    };
  }

  static types(): { [key: string]: any } {
    return {
      parentFlow: { 'type': 'array', 'itemType': DescribeFlowResponseBodyParentFlowListParentFlow },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFlowInstanceResponseBodyDependencyFlowListParentFlow extends $tea.Model {
  bizDate?: number;
  dependencyFlowId?: string;
  dependencyInstanceId?: string;
  flowId?: string;
  flowInstanceId?: string;
  meet?: boolean;
  projectId?: string;
  scheduleKey?: string;
  static names(): { [key: string]: string } {
    return {
      bizDate: 'BizDate',
      dependencyFlowId: 'DependencyFlowId',
      dependencyInstanceId: 'DependencyInstanceId',
      flowId: 'FlowId',
      flowInstanceId: 'FlowInstanceId',
      meet: 'Meet',
      projectId: 'ProjectId',
      scheduleKey: 'ScheduleKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizDate: 'number',
      dependencyFlowId: 'string',
      dependencyInstanceId: 'string',
      flowId: 'string',
      flowInstanceId: 'string',
      meet: 'boolean',
      projectId: 'string',
      scheduleKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFlowInstanceResponseBodyDependencyFlowList extends $tea.Model {
  parentFlow?: DescribeFlowInstanceResponseBodyDependencyFlowListParentFlow[];
  static names(): { [key: string]: string } {
    return {
      parentFlow: 'ParentFlow',
    };
  }

  static types(): { [key: string]: any } {
    return {
      parentFlow: { 'type': 'array', 'itemType': DescribeFlowInstanceResponseBodyDependencyFlowListParentFlow },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFlowInstanceResponseBodyNodeInstanceNodeInstance extends $tea.Model {
  clusterId?: string;
  duration?: number;
  endTime?: number;
  externalId?: string;
  externalInfo?: string;
  externalStatus?: string;
  failAct?: string;
  gmtCreate?: number;
  gmtModified?: number;
  hostName?: string;
  id?: string;
  jobId?: string;
  jobName?: string;
  jobType?: string;
  maxRetry?: string;
  nodeName?: string;
  pending?: boolean;
  projectId?: string;
  retries?: number;
  retryInterval?: string;
  startTime?: number;
  status?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      duration: 'Duration',
      endTime: 'EndTime',
      externalId: 'ExternalId',
      externalInfo: 'ExternalInfo',
      externalStatus: 'ExternalStatus',
      failAct: 'FailAct',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      hostName: 'HostName',
      id: 'Id',
      jobId: 'JobId',
      jobName: 'JobName',
      jobType: 'JobType',
      maxRetry: 'MaxRetry',
      nodeName: 'NodeName',
      pending: 'Pending',
      projectId: 'ProjectId',
      retries: 'Retries',
      retryInterval: 'RetryInterval',
      startTime: 'StartTime',
      status: 'Status',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      duration: 'number',
      endTime: 'number',
      externalId: 'string',
      externalInfo: 'string',
      externalStatus: 'string',
      failAct: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      hostName: 'string',
      id: 'string',
      jobId: 'string',
      jobName: 'string',
      jobType: 'string',
      maxRetry: 'string',
      nodeName: 'string',
      pending: 'boolean',
      projectId: 'string',
      retries: 'number',
      retryInterval: 'string',
      startTime: 'number',
      status: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFlowInstanceResponseBodyNodeInstance extends $tea.Model {
  nodeInstance?: DescribeFlowInstanceResponseBodyNodeInstanceNodeInstance[];
  static names(): { [key: string]: string } {
    return {
      nodeInstance: 'NodeInstance',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeInstance: { 'type': 'array', 'itemType': DescribeFlowInstanceResponseBodyNodeInstanceNodeInstance },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFlowJobResponseBodyResourceListResource extends $tea.Model {
  alias?: string;
  path?: string;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      path: 'Path',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      path: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFlowJobResponseBodyResourceList extends $tea.Model {
  resource?: DescribeFlowJobResponseBodyResourceListResource[];
  static names(): { [key: string]: string } {
    return {
      resource: 'Resource',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resource: { 'type': 'array', 'itemType': DescribeFlowJobResponseBodyResourceListResource },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFlowNodeInstanceContainerLogResponseBodyLogEntrysLogEntry extends $tea.Model {
  content?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFlowNodeInstanceContainerLogResponseBodyLogEntrys extends $tea.Model {
  logEntry?: DescribeFlowNodeInstanceContainerLogResponseBodyLogEntrysLogEntry[];
  static names(): { [key: string]: string } {
    return {
      logEntry: 'LogEntry',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logEntry: { 'type': 'array', 'itemType': DescribeFlowNodeInstanceContainerLogResponseBodyLogEntrysLogEntry },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFlowNodeInstanceLauncherLogResponseBodyLogEntrysLogEntry extends $tea.Model {
  content?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFlowNodeInstanceLauncherLogResponseBodyLogEntrys extends $tea.Model {
  logEntry?: DescribeFlowNodeInstanceLauncherLogResponseBodyLogEntrysLogEntry[];
  static names(): { [key: string]: string } {
    return {
      logEntry: 'LogEntry',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logEntry: { 'type': 'array', 'itemType': DescribeFlowNodeInstanceLauncherLogResponseBodyLogEntrysLogEntry },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFlowProjectClusterSettingResponseBodyHostList extends $tea.Model {
  host?: string[];
  static names(): { [key: string]: string } {
    return {
      host: 'Host',
    };
  }

  static types(): { [key: string]: any } {
    return {
      host: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFlowProjectClusterSettingResponseBodyQueueList extends $tea.Model {
  queue?: string[];
  static names(): { [key: string]: string } {
    return {
      queue: 'Queue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      queue: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFlowProjectClusterSettingResponseBodyUserList extends $tea.Model {
  user?: string[];
  static names(): { [key: string]: string } {
    return {
      user: 'User',
    };
  }

  static types(): { [key: string]: any } {
    return {
      user: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetaTablePreviewTaskResponseBodyDataHeaders extends $tea.Model {
  header?: string[];
  static names(): { [key: string]: string } {
    return {
      header: 'Header',
    };
  }

  static types(): { [key: string]: any } {
    return {
      header: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetaTablePreviewTaskResponseBodyDataRowsRowColumns extends $tea.Model {
  column?: string[];
  static names(): { [key: string]: string } {
    return {
      column: 'Column',
    };
  }

  static types(): { [key: string]: any } {
    return {
      column: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetaTablePreviewTaskResponseBodyDataRowsRow extends $tea.Model {
  columns?: DescribeMetaTablePreviewTaskResponseBodyDataRowsRowColumns;
  static names(): { [key: string]: string } {
    return {
      columns: 'Columns',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columns: DescribeMetaTablePreviewTaskResponseBodyDataRowsRowColumns,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetaTablePreviewTaskResponseBodyDataRows extends $tea.Model {
  row?: DescribeMetaTablePreviewTaskResponseBodyDataRowsRow[];
  static names(): { [key: string]: string } {
    return {
      row: 'Row',
    };
  }

  static types(): { [key: string]: any } {
    return {
      row: { 'type': 'array', 'itemType': DescribeMetaTablePreviewTaskResponseBodyDataRowsRow },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetaTablePreviewTaskResponseBodyData extends $tea.Model {
  headers?: DescribeMetaTablePreviewTaskResponseBodyDataHeaders;
  rows?: DescribeMetaTablePreviewTaskResponseBodyDataRows;
  static names(): { [key: string]: string } {
    return {
      headers: 'Headers',
      rows: 'Rows',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: DescribeMetaTablePreviewTaskResponseBodyDataHeaders,
      rows: DescribeMetaTablePreviewTaskResponseBodyDataRows,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeScalingGroupInstanceV2ResponseBodyScalingConfigInstanceTypeList extends $tea.Model {
  instanceType?: string[];
  static names(): { [key: string]: string } {
    return {
      instanceType: 'InstanceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceType: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeScalingGroupInstanceV2ResponseBodyScalingConfigSpotPriceLimitsSpotPriceLimit extends $tea.Model {
  instanceType?: string;
  priceLimit?: number;
  static names(): { [key: string]: string } {
    return {
      instanceType: 'InstanceType',
      priceLimit: 'PriceLimit',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceType: 'string',
      priceLimit: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeScalingGroupInstanceV2ResponseBodyScalingConfigSpotPriceLimits extends $tea.Model {
  spotPriceLimit?: DescribeScalingGroupInstanceV2ResponseBodyScalingConfigSpotPriceLimitsSpotPriceLimit[];
  static names(): { [key: string]: string } {
    return {
      spotPriceLimit: 'SpotPriceLimit',
    };
  }

  static types(): { [key: string]: any } {
    return {
      spotPriceLimit: { 'type': 'array', 'itemType': DescribeScalingGroupInstanceV2ResponseBodyScalingConfigSpotPriceLimitsSpotPriceLimit },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeScalingGroupInstanceV2ResponseBodyScalingConfig extends $tea.Model {
  dataDiskCategory?: string;
  dataDiskCount?: number;
  dataDiskSize?: number;
  instanceTypeList?: DescribeScalingGroupInstanceV2ResponseBodyScalingConfigInstanceTypeList;
  payType?: string;
  spotPriceLimits?: DescribeScalingGroupInstanceV2ResponseBodyScalingConfigSpotPriceLimits;
  spotStrategy?: string;
  sysDiskCategory?: string;
  sysDiskSize?: number;
  static names(): { [key: string]: string } {
    return {
      dataDiskCategory: 'DataDiskCategory',
      dataDiskCount: 'DataDiskCount',
      dataDiskSize: 'DataDiskSize',
      instanceTypeList: 'InstanceTypeList',
      payType: 'PayType',
      spotPriceLimits: 'SpotPriceLimits',
      spotStrategy: 'SpotStrategy',
      sysDiskCategory: 'SysDiskCategory',
      sysDiskSize: 'SysDiskSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataDiskCategory: 'string',
      dataDiskCount: 'number',
      dataDiskSize: 'number',
      instanceTypeList: DescribeScalingGroupInstanceV2ResponseBodyScalingConfigInstanceTypeList,
      payType: 'string',
      spotPriceLimits: DescribeScalingGroupInstanceV2ResponseBodyScalingConfigSpotPriceLimits,
      spotStrategy: 'string',
      sysDiskCategory: 'string',
      sysDiskSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeScalingGroupInstanceV2ResponseBodyScalingRuleListScalingRuleCloudWatchTrigger extends $tea.Model {
  comparisonOperator?: string;
  evaluationCount?: string;
  metricDisplayName?: string;
  metricName?: string;
  period?: number;
  statistics?: string;
  threshold?: string;
  unit?: string;
  static names(): { [key: string]: string } {
    return {
      comparisonOperator: 'ComparisonOperator',
      evaluationCount: 'EvaluationCount',
      metricDisplayName: 'MetricDisplayName',
      metricName: 'MetricName',
      period: 'Period',
      statistics: 'Statistics',
      threshold: 'Threshold',
      unit: 'Unit',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comparisonOperator: 'string',
      evaluationCount: 'string',
      metricDisplayName: 'string',
      metricName: 'string',
      period: 'number',
      statistics: 'string',
      threshold: 'string',
      unit: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeScalingGroupInstanceV2ResponseBodyScalingRuleListScalingRuleSchedulerTrigger extends $tea.Model {
  launchExpirationTime?: number;
  launchTime?: number;
  recurrenceEndTime?: number;
  recurrenceType?: string;
  recurrenceValue?: string;
  static names(): { [key: string]: string } {
    return {
      launchExpirationTime: 'LaunchExpirationTime',
      launchTime: 'LaunchTime',
      recurrenceEndTime: 'RecurrenceEndTime',
      recurrenceType: 'RecurrenceType',
      recurrenceValue: 'RecurrenceValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      launchExpirationTime: 'number',
      launchTime: 'number',
      recurrenceEndTime: 'number',
      recurrenceType: 'string',
      recurrenceValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeScalingGroupInstanceV2ResponseBodyScalingRuleListScalingRule extends $tea.Model {
  adjustmentType?: string;
  adjustmentValue?: number;
  cloudWatchTrigger?: DescribeScalingGroupInstanceV2ResponseBodyScalingRuleListScalingRuleCloudWatchTrigger;
  cooldown?: number;
  essScalingRuleId?: string;
  launchExpirationTime?: number;
  launchTime?: string;
  recurrenceEndTime?: string;
  recurrenceType?: string;
  recurrenceValue?: string;
  ruleCategory?: string;
  ruleName?: string;
  scalingGroupId?: number;
  schedulerTrigger?: DescribeScalingGroupInstanceV2ResponseBodyScalingRuleListScalingRuleSchedulerTrigger;
  status?: string;
  timeoutWithGrace?: number;
  withGrace?: boolean;
  static names(): { [key: string]: string } {
    return {
      adjustmentType: 'AdjustmentType',
      adjustmentValue: 'AdjustmentValue',
      cloudWatchTrigger: 'CloudWatchTrigger',
      cooldown: 'Cooldown',
      essScalingRuleId: 'EssScalingRuleId',
      launchExpirationTime: 'LaunchExpirationTime',
      launchTime: 'LaunchTime',
      recurrenceEndTime: 'RecurrenceEndTime',
      recurrenceType: 'RecurrenceType',
      recurrenceValue: 'RecurrenceValue',
      ruleCategory: 'RuleCategory',
      ruleName: 'RuleName',
      scalingGroupId: 'ScalingGroupId',
      schedulerTrigger: 'SchedulerTrigger',
      status: 'Status',
      timeoutWithGrace: 'TimeoutWithGrace',
      withGrace: 'WithGrace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adjustmentType: 'string',
      adjustmentValue: 'number',
      cloudWatchTrigger: DescribeScalingGroupInstanceV2ResponseBodyScalingRuleListScalingRuleCloudWatchTrigger,
      cooldown: 'number',
      essScalingRuleId: 'string',
      launchExpirationTime: 'number',
      launchTime: 'string',
      recurrenceEndTime: 'string',
      recurrenceType: 'string',
      recurrenceValue: 'string',
      ruleCategory: 'string',
      ruleName: 'string',
      scalingGroupId: 'number',
      schedulerTrigger: DescribeScalingGroupInstanceV2ResponseBodyScalingRuleListScalingRuleSchedulerTrigger,
      status: 'string',
      timeoutWithGrace: 'number',
      withGrace: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeScalingGroupInstanceV2ResponseBodyScalingRuleList extends $tea.Model {
  scalingRule?: DescribeScalingGroupInstanceV2ResponseBodyScalingRuleListScalingRule[];
  static names(): { [key: string]: string } {
    return {
      scalingRule: 'ScalingRule',
    };
  }

  static types(): { [key: string]: any } {
    return {
      scalingRule: { 'type': 'array', 'itemType': DescribeScalingGroupInstanceV2ResponseBodyScalingRuleListScalingRule },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeScalingRuleResponseBodyCloudWatchTrigger extends $tea.Model {
  comparisonOperator?: string;
  evaluationCount?: string;
  metricDisplayName?: string;
  metricName?: string;
  period?: number;
  statistics?: string;
  threshold?: string;
  unit?: string;
  static names(): { [key: string]: string } {
    return {
      comparisonOperator: 'ComparisonOperator',
      evaluationCount: 'EvaluationCount',
      metricDisplayName: 'MetricDisplayName',
      metricName: 'MetricName',
      period: 'Period',
      statistics: 'Statistics',
      threshold: 'Threshold',
      unit: 'Unit',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comparisonOperator: 'string',
      evaluationCount: 'string',
      metricDisplayName: 'string',
      metricName: 'string',
      period: 'number',
      statistics: 'string',
      threshold: 'string',
      unit: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeScalingRuleResponseBodySchedulerTrigger extends $tea.Model {
  launchExpirationTime?: number;
  launchTime?: number;
  recurrenceEndTime?: number;
  recurrenceType?: string;
  recurrenceValue?: string;
  static names(): { [key: string]: string } {
    return {
      launchExpirationTime: 'LaunchExpirationTime',
      launchTime: 'LaunchTime',
      recurrenceEndTime: 'RecurrenceEndTime',
      recurrenceType: 'RecurrenceType',
      recurrenceValue: 'RecurrenceValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      launchExpirationTime: 'number',
      launchTime: 'number',
      recurrenceEndTime: 'number',
      recurrenceType: 'string',
      recurrenceValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSecurityGroupAttributeResponseBodyAvailableGroupListSecurityGroup extends $tea.Model {
  availableInstanceAmount?: number;
  creationTime?: string;
  description?: string;
  ecsCount?: number;
  securityGroupId?: string;
  securityGroupName?: string;
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      availableInstanceAmount: 'AvailableInstanceAmount',
      creationTime: 'CreationTime',
      description: 'Description',
      ecsCount: 'EcsCount',
      securityGroupId: 'SecurityGroupId',
      securityGroupName: 'SecurityGroupName',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      availableInstanceAmount: 'number',
      creationTime: 'string',
      description: 'string',
      ecsCount: 'number',
      securityGroupId: 'string',
      securityGroupName: 'string',
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSecurityGroupAttributeResponseBodyAvailableGroupList extends $tea.Model {
  securityGroup?: DescribeSecurityGroupAttributeResponseBodyAvailableGroupListSecurityGroup[];
  static names(): { [key: string]: string } {
    return {
      securityGroup: 'SecurityGroup',
    };
  }

  static types(): { [key: string]: any } {
    return {
      securityGroup: { 'type': 'array', 'itemType': DescribeSecurityGroupAttributeResponseBodyAvailableGroupListSecurityGroup },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSecurityGroupAttributeResponseBodySecurityGroupAttributeListSecurityGroupAttribute extends $tea.Model {
  bizContent?: string;
  bizType?: string;
  static names(): { [key: string]: string } {
    return {
      bizContent: 'BizContent',
      bizType: 'BizType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizContent: 'string',
      bizType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSecurityGroupAttributeResponseBodySecurityGroupAttributeList extends $tea.Model {
  securityGroupAttribute?: DescribeSecurityGroupAttributeResponseBodySecurityGroupAttributeListSecurityGroupAttribute[];
  static names(): { [key: string]: string } {
    return {
      securityGroupAttribute: 'SecurityGroupAttribute',
    };
  }

  static types(): { [key: string]: any } {
    return {
      securityGroupAttribute: { 'type': 'array', 'itemType': DescribeSecurityGroupAttributeResponseBodySecurityGroupAttributeListSecurityGroupAttribute },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetHdfsCapacityStatisticInfoResponseBodyHdfsCapacityListClusterStatHdfsCapacity extends $tea.Model {
  capacityRemaining?: number;
  capacityRemainingGB?: number;
  capacityTotal?: number;
  capacityTotalGB?: number;
  capacityUsed?: number;
  capacityUsedGB?: number;
  capacityUsedNonDfs?: number;
  clusterBizId?: string;
  dateTime?: string;
  static names(): { [key: string]: string } {
    return {
      capacityRemaining: 'CapacityRemaining',
      capacityRemainingGB: 'CapacityRemainingGB',
      capacityTotal: 'CapacityTotal',
      capacityTotalGB: 'CapacityTotalGB',
      capacityUsed: 'CapacityUsed',
      capacityUsedGB: 'CapacityUsedGB',
      capacityUsedNonDfs: 'CapacityUsedNonDfs',
      clusterBizId: 'ClusterBizId',
      dateTime: 'DateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      capacityRemaining: 'number',
      capacityRemainingGB: 'number',
      capacityTotal: 'number',
      capacityTotalGB: 'number',
      capacityUsed: 'number',
      capacityUsedGB: 'number',
      capacityUsedNonDfs: 'number',
      clusterBizId: 'string',
      dateTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetHdfsCapacityStatisticInfoResponseBodyHdfsCapacityList extends $tea.Model {
  clusterStatHdfsCapacity?: GetHdfsCapacityStatisticInfoResponseBodyHdfsCapacityListClusterStatHdfsCapacity[];
  static names(): { [key: string]: string } {
    return {
      clusterStatHdfsCapacity: 'ClusterStatHdfsCapacity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterStatHdfsCapacity: { 'type': 'array', 'itemType': GetHdfsCapacityStatisticInfoResponseBodyHdfsCapacityListClusterStatHdfsCapacity },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetJobInputStatisticInfoResponseBodyJobInputListClusterStatJobInput extends $tea.Model {
  applicationId?: string;
  bytesInput?: number;
  finishTime?: number;
  jobId?: string;
  name?: string;
  queue?: string;
  startTime?: number;
  state?: string;
  user?: string;
  static names(): { [key: string]: string } {
    return {
      applicationId: 'ApplicationId',
      bytesInput: 'BytesInput',
      finishTime: 'FinishTime',
      jobId: 'JobId',
      name: 'Name',
      queue: 'Queue',
      startTime: 'StartTime',
      state: 'State',
      user: 'User',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applicationId: 'string',
      bytesInput: 'number',
      finishTime: 'number',
      jobId: 'string',
      name: 'string',
      queue: 'string',
      startTime: 'number',
      state: 'string',
      user: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetJobInputStatisticInfoResponseBodyJobInputList extends $tea.Model {
  clusterStatJobInput?: GetJobInputStatisticInfoResponseBodyJobInputListClusterStatJobInput[];
  static names(): { [key: string]: string } {
    return {
      clusterStatJobInput: 'ClusterStatJobInput',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterStatJobInput: { 'type': 'array', 'itemType': GetJobInputStatisticInfoResponseBodyJobInputListClusterStatJobInput },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetJobOutputStatisticInfoResponseBodyJobOutputListClusterStatJobOutput extends $tea.Model {
  applicationId?: string;
  bytesOutput?: number;
  finishTime?: number;
  jobId?: string;
  name?: string;
  queue?: string;
  startTime?: number;
  state?: string;
  user?: string;
  static names(): { [key: string]: string } {
    return {
      applicationId: 'ApplicationId',
      bytesOutput: 'BytesOutput',
      finishTime: 'FinishTime',
      jobId: 'JobId',
      name: 'Name',
      queue: 'Queue',
      startTime: 'StartTime',
      state: 'State',
      user: 'User',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applicationId: 'string',
      bytesOutput: 'number',
      finishTime: 'number',
      jobId: 'string',
      name: 'string',
      queue: 'string',
      startTime: 'number',
      state: 'string',
      user: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetJobOutputStatisticInfoResponseBodyJobOutputList extends $tea.Model {
  clusterStatJobOutput?: GetJobOutputStatisticInfoResponseBodyJobOutputListClusterStatJobOutput[];
  static names(): { [key: string]: string } {
    return {
      clusterStatJobOutput: 'ClusterStatJobOutput',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterStatJobOutput: { 'type': 'array', 'itemType': GetJobOutputStatisticInfoResponseBodyJobOutputListClusterStatJobOutput },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetJobRunningTimeStatisticInfoResponseBodyRunningTimeListClusterStatJobRunningTime extends $tea.Model {
  applicationId?: string;
  finishTime?: number;
  jobId?: string;
  name?: string;
  queue?: string;
  runningTime?: number;
  startTime?: number;
  state?: string;
  user?: string;
  static names(): { [key: string]: string } {
    return {
      applicationId: 'ApplicationId',
      finishTime: 'FinishTime',
      jobId: 'JobId',
      name: 'Name',
      queue: 'Queue',
      runningTime: 'RunningTime',
      startTime: 'StartTime',
      state: 'State',
      user: 'User',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applicationId: 'string',
      finishTime: 'number',
      jobId: 'string',
      name: 'string',
      queue: 'string',
      runningTime: 'number',
      startTime: 'number',
      state: 'string',
      user: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetJobRunningTimeStatisticInfoResponseBodyRunningTimeList extends $tea.Model {
  clusterStatJobRunningTime?: GetJobRunningTimeStatisticInfoResponseBodyRunningTimeListClusterStatJobRunningTime[];
  static names(): { [key: string]: string } {
    return {
      clusterStatJobRunningTime: 'ClusterStatJobRunningTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterStatJobRunningTime: { 'type': 'array', 'itemType': GetJobRunningTimeStatisticInfoResponseBodyRunningTimeListClusterStatJobRunningTime },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetQueueInputStatisticInfoResponseBodyQueueInputListClusterStatQueueInput extends $tea.Model {
  bytesInput?: number;
  queue?: string;
  static names(): { [key: string]: string } {
    return {
      bytesInput: 'BytesInput',
      queue: 'Queue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bytesInput: 'number',
      queue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetQueueInputStatisticInfoResponseBodyQueueInputList extends $tea.Model {
  clusterStatQueueInput?: GetQueueInputStatisticInfoResponseBodyQueueInputListClusterStatQueueInput[];
  static names(): { [key: string]: string } {
    return {
      clusterStatQueueInput: 'ClusterStatQueueInput',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterStatQueueInput: { 'type': 'array', 'itemType': GetQueueInputStatisticInfoResponseBodyQueueInputListClusterStatQueueInput },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetQueueOutputStatisticInfoResponseBodyQueueOutputListClusterStatQueueOutput extends $tea.Model {
  bytesOutput?: number;
  queue?: string;
  static names(): { [key: string]: string } {
    return {
      bytesOutput: 'BytesOutput',
      queue: 'Queue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bytesOutput: 'number',
      queue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetQueueOutputStatisticInfoResponseBodyQueueOutputList extends $tea.Model {
  clusterStatQueueOutput?: GetQueueOutputStatisticInfoResponseBodyQueueOutputListClusterStatQueueOutput[];
  static names(): { [key: string]: string } {
    return {
      clusterStatQueueOutput: 'ClusterStatQueueOutput',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterStatQueueOutput: { 'type': 'array', 'itemType': GetQueueOutputStatisticInfoResponseBodyQueueOutputListClusterStatQueueOutput },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetQueueSubmissionStatisticInfoResponseBodyQueueSubmissionListClusterStatQueueSubmission extends $tea.Model {
  queue?: string;
  submission?: number;
  static names(): { [key: string]: string } {
    return {
      queue: 'Queue',
      submission: 'Submission',
    };
  }

  static types(): { [key: string]: any } {
    return {
      queue: 'string',
      submission: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetQueueSubmissionStatisticInfoResponseBodyQueueSubmissionList extends $tea.Model {
  clusterStatQueueSubmission?: GetQueueSubmissionStatisticInfoResponseBodyQueueSubmissionListClusterStatQueueSubmission[];
  static names(): { [key: string]: string } {
    return {
      clusterStatQueueSubmission: 'ClusterStatQueueSubmission',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterStatQueueSubmission: { 'type': 'array', 'itemType': GetQueueSubmissionStatisticInfoResponseBodyQueueSubmissionListClusterStatQueueSubmission },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserInputStatisticInfoResponseBodyUserInputListClusterStatUserInput extends $tea.Model {
  bytesInput?: number;
  user?: string;
  static names(): { [key: string]: string } {
    return {
      bytesInput: 'BytesInput',
      user: 'User',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bytesInput: 'number',
      user: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserInputStatisticInfoResponseBodyUserInputList extends $tea.Model {
  clusterStatUserInput?: GetUserInputStatisticInfoResponseBodyUserInputListClusterStatUserInput[];
  static names(): { [key: string]: string } {
    return {
      clusterStatUserInput: 'ClusterStatUserInput',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterStatUserInput: { 'type': 'array', 'itemType': GetUserInputStatisticInfoResponseBodyUserInputListClusterStatUserInput },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserOutputStatisticInfoResponseBodyUserOutputListClusterStatUserOutput extends $tea.Model {
  bytesOutput?: number;
  user?: string;
  static names(): { [key: string]: string } {
    return {
      bytesOutput: 'BytesOutput',
      user: 'User',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bytesOutput: 'number',
      user: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserOutputStatisticInfoResponseBodyUserOutputList extends $tea.Model {
  clusterStatUserOutput?: GetUserOutputStatisticInfoResponseBodyUserOutputListClusterStatUserOutput[];
  static names(): { [key: string]: string } {
    return {
      clusterStatUserOutput: 'ClusterStatUserOutput',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterStatUserOutput: { 'type': 'array', 'itemType': GetUserOutputStatisticInfoResponseBodyUserOutputListClusterStatUserOutput },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserSubmissionStatisticInfoResponseBodyUserSubmissionListClusterStatUserSubmission extends $tea.Model {
  submission?: number;
  user?: string;
  static names(): { [key: string]: string } {
    return {
      submission: 'Submission',
      user: 'User',
    };
  }

  static types(): { [key: string]: any } {
    return {
      submission: 'number',
      user: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserSubmissionStatisticInfoResponseBodyUserSubmissionList extends $tea.Model {
  clusterStatUserSubmission?: GetUserSubmissionStatisticInfoResponseBodyUserSubmissionListClusterStatUserSubmission[];
  static names(): { [key: string]: string } {
    return {
      clusterStatUserSubmission: 'ClusterStatUserSubmission',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterStatUserSubmission: { 'type': 'array', 'itemType': GetUserSubmissionStatisticInfoResponseBodyUserSubmissionListClusterStatUserSubmission },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAdviceActionResponseBodyItemsItem extends $tea.Model {
  actionType?: string;
  clusterId?: string;
  command?: string;
  component?: string;
  configItemKey?: string;
  configName?: string;
  gmtCreate?: number;
  gmtModified?: number;
  hostgroupName?: string;
  serviceName?: string;
  static names(): { [key: string]: string } {
    return {
      actionType: 'ActionType',
      clusterId: 'ClusterId',
      command: 'Command',
      component: 'Component',
      configItemKey: 'ConfigItemKey',
      configName: 'ConfigName',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      hostgroupName: 'HostgroupName',
      serviceName: 'ServiceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actionType: 'string',
      clusterId: 'string',
      command: 'string',
      component: 'string',
      configItemKey: 'string',
      configName: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      hostgroupName: 'string',
      serviceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAdviceActionResponseBodyItems extends $tea.Model {
  item?: ListAdviceActionResponseBodyItemsItem[];
  static names(): { [key: string]: string } {
    return {
      item: 'Item',
    };
  }

  static types(): { [key: string]: any } {
    return {
      item: { 'type': 'array', 'itemType': ListAdviceActionResponseBodyItemsItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListApmApplicationResponseBodyApmAppInfoListApmAppInfo extends $tea.Model {
  allocatedMemory?: number;
  allocatedVcore?: number;
  applicationId?: string;
  applicationType?: string;
  clusterBizId?: string;
  clusterUsagePercent?: number;
  diagnoseCode?: string;
  diagnoseResult?: string;
  diagnostics?: string;
  duration?: number;
  finalStatus?: string;
  finishedTime?: number;
  memorySeconds?: number;
  name?: string;
  progress?: number;
  queue?: string;
  queueUsagePercent?: number;
  resourceRequests?: string;
  runningContainers?: number;
  runningDuration?: number;
  startTime?: number;
  state?: string;
  submitTime?: number;
  user?: string;
  vcoreSeconds?: number;
  static names(): { [key: string]: string } {
    return {
      allocatedMemory: 'AllocatedMemory',
      allocatedVcore: 'AllocatedVcore',
      applicationId: 'ApplicationId',
      applicationType: 'ApplicationType',
      clusterBizId: 'ClusterBizId',
      clusterUsagePercent: 'ClusterUsagePercent',
      diagnoseCode: 'DiagnoseCode',
      diagnoseResult: 'DiagnoseResult',
      diagnostics: 'Diagnostics',
      duration: 'Duration',
      finalStatus: 'FinalStatus',
      finishedTime: 'FinishedTime',
      memorySeconds: 'MemorySeconds',
      name: 'Name',
      progress: 'Progress',
      queue: 'Queue',
      queueUsagePercent: 'QueueUsagePercent',
      resourceRequests: 'ResourceRequests',
      runningContainers: 'RunningContainers',
      runningDuration: 'RunningDuration',
      startTime: 'StartTime',
      state: 'State',
      submitTime: 'SubmitTime',
      user: 'User',
      vcoreSeconds: 'VcoreSeconds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allocatedMemory: 'number',
      allocatedVcore: 'number',
      applicationId: 'string',
      applicationType: 'string',
      clusterBizId: 'string',
      clusterUsagePercent: 'number',
      diagnoseCode: 'string',
      diagnoseResult: 'string',
      diagnostics: 'string',
      duration: 'number',
      finalStatus: 'string',
      finishedTime: 'number',
      memorySeconds: 'number',
      name: 'string',
      progress: 'number',
      queue: 'string',
      queueUsagePercent: 'number',
      resourceRequests: 'string',
      runningContainers: 'number',
      runningDuration: 'number',
      startTime: 'number',
      state: 'string',
      submitTime: 'number',
      user: 'string',
      vcoreSeconds: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListApmApplicationResponseBodyApmAppInfoList extends $tea.Model {
  apmAppInfo?: ListApmApplicationResponseBodyApmAppInfoListApmAppInfo[];
  static names(): { [key: string]: string } {
    return {
      apmAppInfo: 'ApmAppInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apmAppInfo: { 'type': 'array', 'itemType': ListApmApplicationResponseBodyApmAppInfoListApmAppInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListBackupsResponseBodyItemsItemMetadataInfo extends $tea.Model {
  metadataType?: string;
  properties?: string;
  static names(): { [key: string]: string } {
    return {
      metadataType: 'MetadataType',
      properties: 'Properties',
    };
  }

  static types(): { [key: string]: any } {
    return {
      metadataType: 'string',
      properties: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListBackupsResponseBodyItemsItem extends $tea.Model {
  backupPlanId?: string;
  clusterId?: string;
  createTime?: number;
  id?: string;
  md5?: string;
  metadataInfo?: ListBackupsResponseBodyItemsItemMetadataInfo;
  status?: string;
  storePath?: string;
  tarFileName?: string;
  static names(): { [key: string]: string } {
    return {
      backupPlanId: 'BackupPlanId',
      clusterId: 'ClusterId',
      createTime: 'CreateTime',
      id: 'Id',
      md5: 'Md5',
      metadataInfo: 'MetadataInfo',
      status: 'Status',
      storePath: 'StorePath',
      tarFileName: 'TarFileName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      backupPlanId: 'string',
      clusterId: 'string',
      createTime: 'number',
      id: 'string',
      md5: 'string',
      metadataInfo: ListBackupsResponseBodyItemsItemMetadataInfo,
      status: 'string',
      storePath: 'string',
      tarFileName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListBackupsResponseBodyItems extends $tea.Model {
  item?: ListBackupsResponseBodyItemsItem[];
  static names(): { [key: string]: string } {
    return {
      item: 'Item',
    };
  }

  static types(): { [key: string]: any } {
    return {
      item: { 'type': 'array', 'itemType': ListBackupsResponseBodyItemsItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterHostResponseBodyHostListHostDiskListDisk extends $tea.Model {
  blockMountPoint?: string;
  device?: string;
  diskId?: string;
  diskMountPoint?: string;
  diskSize?: number;
  diskType?: string;
  event?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      blockMountPoint: 'BlockMountPoint',
      device: 'Device',
      diskId: 'DiskId',
      diskMountPoint: 'DiskMountPoint',
      diskSize: 'DiskSize',
      diskType: 'DiskType',
      event: 'Event',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      blockMountPoint: 'string',
      device: 'string',
      diskId: 'string',
      diskMountPoint: 'string',
      diskSize: 'number',
      diskType: 'string',
      event: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterHostResponseBodyHostListHostDiskList extends $tea.Model {
  disk?: ListClusterHostResponseBodyHostListHostDiskListDisk[];
  static names(): { [key: string]: string } {
    return {
      disk: 'Disk',
    };
  }

  static types(): { [key: string]: any } {
    return {
      disk: { 'type': 'array', 'itemType': ListClusterHostResponseBodyHostListHostDiskListDisk },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterHostResponseBodyHostListHost extends $tea.Model {
  chargeType?: string;
  cpu?: number;
  createTime?: string;
  diskList?: ListClusterHostResponseBodyHostListHostDiskList;
  emrExpiredTime?: string;
  expiredTime?: number;
  hostGroupId?: string;
  hostInstanceId?: string;
  hostName?: string;
  instanceStatus?: string;
  instanceType?: string;
  memory?: number;
  privateIp?: string;
  publicIp?: string;
  role?: string;
  serialNumber?: string;
  status?: string;
  supportIpV6?: boolean;
  type?: string;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      chargeType: 'ChargeType',
      cpu: 'Cpu',
      createTime: 'CreateTime',
      diskList: 'DiskList',
      emrExpiredTime: 'EmrExpiredTime',
      expiredTime: 'ExpiredTime',
      hostGroupId: 'HostGroupId',
      hostInstanceId: 'HostInstanceId',
      hostName: 'HostName',
      instanceStatus: 'InstanceStatus',
      instanceType: 'InstanceType',
      memory: 'Memory',
      privateIp: 'PrivateIp',
      publicIp: 'PublicIp',
      role: 'Role',
      serialNumber: 'SerialNumber',
      status: 'Status',
      supportIpV6: 'SupportIpV6',
      type: 'Type',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      chargeType: 'string',
      cpu: 'number',
      createTime: 'string',
      diskList: ListClusterHostResponseBodyHostListHostDiskList,
      emrExpiredTime: 'string',
      expiredTime: 'number',
      hostGroupId: 'string',
      hostInstanceId: 'string',
      hostName: 'string',
      instanceStatus: 'string',
      instanceType: 'string',
      memory: 'number',
      privateIp: 'string',
      publicIp: 'string',
      role: 'string',
      serialNumber: 'string',
      status: 'string',
      supportIpV6: 'boolean',
      type: 'string',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterHostResponseBodyHostList extends $tea.Model {
  host?: ListClusterHostResponseBodyHostListHost[];
  static names(): { [key: string]: string } {
    return {
      host: 'Host',
    };
  }

  static types(): { [key: string]: any } {
    return {
      host: { 'type': 'array', 'itemType': ListClusterHostResponseBodyHostListHost },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterHostComponentResponseBodyComponentListComponent extends $tea.Model {
  commissionStatus?: string;
  componentDisplayName?: string;
  componentName?: string;
  cpu?: number;
  healthReportTime?: number;
  healthStatus?: string;
  hostId?: string;
  hostInstanceId?: string;
  hostName?: string;
  instanceType?: string;
  memory?: number;
  needRestart?: boolean;
  privateIp?: string;
  publicIp?: string;
  role?: string;
  serialNumber?: string;
  serverStatus?: string;
  serviceDisplayName?: string;
  serviceName?: string;
  state?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      commissionStatus: 'CommissionStatus',
      componentDisplayName: 'ComponentDisplayName',
      componentName: 'ComponentName',
      cpu: 'Cpu',
      healthReportTime: 'HealthReportTime',
      healthStatus: 'HealthStatus',
      hostId: 'HostId',
      hostInstanceId: 'HostInstanceId',
      hostName: 'HostName',
      instanceType: 'InstanceType',
      memory: 'Memory',
      needRestart: 'NeedRestart',
      privateIp: 'PrivateIp',
      publicIp: 'PublicIp',
      role: 'Role',
      serialNumber: 'SerialNumber',
      serverStatus: 'ServerStatus',
      serviceDisplayName: 'ServiceDisplayName',
      serviceName: 'ServiceName',
      state: 'State',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commissionStatus: 'string',
      componentDisplayName: 'string',
      componentName: 'string',
      cpu: 'number',
      healthReportTime: 'number',
      healthStatus: 'string',
      hostId: 'string',
      hostInstanceId: 'string',
      hostName: 'string',
      instanceType: 'string',
      memory: 'number',
      needRestart: 'boolean',
      privateIp: 'string',
      publicIp: 'string',
      role: 'string',
      serialNumber: 'string',
      serverStatus: 'string',
      serviceDisplayName: 'string',
      serviceName: 'string',
      state: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterHostComponentResponseBodyComponentList extends $tea.Model {
  component?: ListClusterHostComponentResponseBodyComponentListComponent[];
  static names(): { [key: string]: string } {
    return {
      component: 'Component',
    };
  }

  static types(): { [key: string]: any } {
    return {
      component: { 'type': 'array', 'itemType': ListClusterHostComponentResponseBodyComponentListComponent },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterHostGroupResponseBodyHostGroupListHostGroup extends $tea.Model {
  chargeType?: string;
  comment?: string;
  costSavingPercent?: number;
  cpu?: number;
  dataDiskCount?: number;
  dataDiskSize?: number;
  dataDiskType?: string;
  hostGroupChangeStatus?: string;
  hostGroupChangeType?: string;
  hostGroupId?: string;
  hostGroupName?: string;
  hostGroupSubType?: string;
  hostGroupType?: string;
  instanceType?: string;
  lockReason?: string;
  lockType?: string;
  memory?: number;
  nodeCount?: number;
  payType?: string;
  scalingGroupActiveStatus?: string;
  scalingGroupBizId?: string;
  scalingGroupConfigState?: string;
  scalingGroupMaxNode?: number;
  scalingGroupMinNode?: number;
  scalingInMode?: string;
  securityGroupId?: string;
  status?: string;
  systemDiskCount?: number;
  systemDiskSize?: number;
  systemDiskType?: string;
  vswitchId?: string;
  gmtCreate?: string;
  gmtModified?: string;
  static names(): { [key: string]: string } {
    return {
      chargeType: 'ChargeType',
      comment: 'Comment',
      costSavingPercent: 'CostSavingPercent',
      cpu: 'Cpu',
      dataDiskCount: 'DataDiskCount',
      dataDiskSize: 'DataDiskSize',
      dataDiskType: 'DataDiskType',
      hostGroupChangeStatus: 'HostGroupChangeStatus',
      hostGroupChangeType: 'HostGroupChangeType',
      hostGroupId: 'HostGroupId',
      hostGroupName: 'HostGroupName',
      hostGroupSubType: 'HostGroupSubType',
      hostGroupType: 'HostGroupType',
      instanceType: 'InstanceType',
      lockReason: 'LockReason',
      lockType: 'LockType',
      memory: 'Memory',
      nodeCount: 'NodeCount',
      payType: 'PayType',
      scalingGroupActiveStatus: 'ScalingGroupActiveStatus',
      scalingGroupBizId: 'ScalingGroupBizId',
      scalingGroupConfigState: 'ScalingGroupConfigState',
      scalingGroupMaxNode: 'ScalingGroupMaxNode',
      scalingGroupMinNode: 'ScalingGroupMinNode',
      scalingInMode: 'ScalingInMode',
      securityGroupId: 'SecurityGroupId',
      status: 'Status',
      systemDiskCount: 'SystemDiskCount',
      systemDiskSize: 'SystemDiskSize',
      systemDiskType: 'SystemDiskType',
      vswitchId: 'VswitchId',
      gmtCreate: 'gmtCreate',
      gmtModified: 'gmtModified',
    };
  }

  static types(): { [key: string]: any } {
    return {
      chargeType: 'string',
      comment: 'string',
      costSavingPercent: 'number',
      cpu: 'number',
      dataDiskCount: 'number',
      dataDiskSize: 'number',
      dataDiskType: 'string',
      hostGroupChangeStatus: 'string',
      hostGroupChangeType: 'string',
      hostGroupId: 'string',
      hostGroupName: 'string',
      hostGroupSubType: 'string',
      hostGroupType: 'string',
      instanceType: 'string',
      lockReason: 'string',
      lockType: 'string',
      memory: 'number',
      nodeCount: 'number',
      payType: 'string',
      scalingGroupActiveStatus: 'string',
      scalingGroupBizId: 'string',
      scalingGroupConfigState: 'string',
      scalingGroupMaxNode: 'number',
      scalingGroupMinNode: 'number',
      scalingInMode: 'string',
      securityGroupId: 'string',
      status: 'string',
      systemDiskCount: 'number',
      systemDiskSize: 'number',
      systemDiskType: 'string',
      vswitchId: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterHostGroupResponseBodyHostGroupList extends $tea.Model {
  hostGroup?: ListClusterHostGroupResponseBodyHostGroupListHostGroup[];
  static names(): { [key: string]: string } {
    return {
      hostGroup: 'HostGroup',
    };
  }

  static types(): { [key: string]: any } {
    return {
      hostGroup: { 'type': 'array', 'itemType': ListClusterHostGroupResponseBodyHostGroupListHostGroup },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterInstalledServiceResponseBodyClusterInstalledServiceListClusterInstalledServiceServiceActionListServiceAction extends $tea.Model {
  actionName?: string;
  command?: string;
  componentName?: string;
  displayName?: string;
  serviceName?: string;
  static names(): { [key: string]: string } {
    return {
      actionName: 'ActionName',
      command: 'Command',
      componentName: 'ComponentName',
      displayName: 'DisplayName',
      serviceName: 'ServiceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actionName: 'string',
      command: 'string',
      componentName: 'string',
      displayName: 'string',
      serviceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterInstalledServiceResponseBodyClusterInstalledServiceListClusterInstalledServiceServiceActionList extends $tea.Model {
  serviceAction?: ListClusterInstalledServiceResponseBodyClusterInstalledServiceListClusterInstalledServiceServiceActionListServiceAction[];
  static names(): { [key: string]: string } {
    return {
      serviceAction: 'ServiceAction',
    };
  }

  static types(): { [key: string]: any } {
    return {
      serviceAction: { 'type': 'array', 'itemType': ListClusterInstalledServiceResponseBodyClusterInstalledServiceListClusterInstalledServiceServiceActionListServiceAction },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterInstalledServiceResponseBodyClusterInstalledServiceListClusterInstalledService extends $tea.Model {
  serviceActionList?: ListClusterInstalledServiceResponseBodyClusterInstalledServiceListClusterInstalledServiceServiceActionList;
  serviceDisplayName?: string;
  serviceEcmVersion?: string;
  serviceName?: string;
  serviceVersion?: string;
  state?: string;
  abnormalNum?: number;
  comment?: string;
  needRestartNum?: number;
  notStartedNum?: number;
  onlyClient?: boolean;
  serviceStatus?: string;
  static names(): { [key: string]: string } {
    return {
      serviceActionList: 'ServiceActionList',
      serviceDisplayName: 'ServiceDisplayName',
      serviceEcmVersion: 'ServiceEcmVersion',
      serviceName: 'ServiceName',
      serviceVersion: 'ServiceVersion',
      state: 'State',
      abnormalNum: 'abnormalNum',
      comment: 'comment',
      needRestartNum: 'needRestartNum',
      notStartedNum: 'notStartedNum',
      onlyClient: 'onlyClient',
      serviceStatus: 'serviceStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      serviceActionList: ListClusterInstalledServiceResponseBodyClusterInstalledServiceListClusterInstalledServiceServiceActionList,
      serviceDisplayName: 'string',
      serviceEcmVersion: 'string',
      serviceName: 'string',
      serviceVersion: 'string',
      state: 'string',
      abnormalNum: 'number',
      comment: 'string',
      needRestartNum: 'number',
      notStartedNum: 'number',
      onlyClient: 'boolean',
      serviceStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterInstalledServiceResponseBodyClusterInstalledServiceList extends $tea.Model {
  clusterInstalledService?: ListClusterInstalledServiceResponseBodyClusterInstalledServiceListClusterInstalledService[];
  static names(): { [key: string]: string } {
    return {
      clusterInstalledService: 'ClusterInstalledService',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterInstalledService: { 'type': 'array', 'itemType': ListClusterInstalledServiceResponseBodyClusterInstalledServiceListClusterInstalledService },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterOperationResponseBodyClusterOperationListClusterOperation extends $tea.Model {
  comment?: string;
  duration?: string;
  operationId?: string;
  operationName?: string;
  percentage?: string;
  startTime?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      comment: 'Comment',
      duration: 'Duration',
      operationId: 'OperationId',
      operationName: 'OperationName',
      percentage: 'Percentage',
      startTime: 'StartTime',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comment: 'string',
      duration: 'string',
      operationId: 'string',
      operationName: 'string',
      percentage: 'string',
      startTime: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterOperationResponseBodyClusterOperationList extends $tea.Model {
  clusterOperation?: ListClusterOperationResponseBodyClusterOperationListClusterOperation[];
  static names(): { [key: string]: string } {
    return {
      clusterOperation: 'ClusterOperation',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterOperation: { 'type': 'array', 'itemType': ListClusterOperationResponseBodyClusterOperationListClusterOperation },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterOperationHostResponseBodyClusterOperationHostListClusterOperationHost extends $tea.Model {
  hostId?: string;
  hostName?: string;
  percentage?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      hostId: 'HostId',
      hostName: 'HostName',
      percentage: 'Percentage',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      hostId: 'string',
      hostName: 'string',
      percentage: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterOperationHostResponseBodyClusterOperationHostList extends $tea.Model {
  clusterOperationHost?: ListClusterOperationHostResponseBodyClusterOperationHostListClusterOperationHost[];
  static names(): { [key: string]: string } {
    return {
      clusterOperationHost: 'ClusterOperationHost',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterOperationHost: { 'type': 'array', 'itemType': ListClusterOperationHostResponseBodyClusterOperationHostListClusterOperationHost },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterOperationHostTaskResponseBodyClusterOperationHostTaskListClusterOperationHostTask extends $tea.Model {
  percentage?: string;
  status?: string;
  taskId?: string;
  taskName?: string;
  static names(): { [key: string]: string } {
    return {
      percentage: 'Percentage',
      status: 'Status',
      taskId: 'TaskId',
      taskName: 'TaskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      percentage: 'string',
      status: 'string',
      taskId: 'string',
      taskName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterOperationHostTaskResponseBodyClusterOperationHostTaskList extends $tea.Model {
  clusterOperationHostTask?: ListClusterOperationHostTaskResponseBodyClusterOperationHostTaskListClusterOperationHostTask[];
  static names(): { [key: string]: string } {
    return {
      clusterOperationHostTask: 'ClusterOperationHostTask',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterOperationHostTask: { 'type': 'array', 'itemType': ListClusterOperationHostTaskResponseBodyClusterOperationHostTaskListClusterOperationHostTask },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterOperationTaskResponseBodyClusterOperationTaskListClusterOperationTask extends $tea.Model {
  percentage?: string;
  status?: string;
  taskId?: string;
  taskName?: string;
  static names(): { [key: string]: string } {
    return {
      percentage: 'Percentage',
      status: 'Status',
      taskId: 'TaskId',
      taskName: 'TaskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      percentage: 'string',
      status: 'string',
      taskId: 'string',
      taskName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterOperationTaskResponseBodyClusterOperationTaskList extends $tea.Model {
  clusterOperationTask?: ListClusterOperationTaskResponseBodyClusterOperationTaskListClusterOperationTask[];
  static names(): { [key: string]: string } {
    return {
      clusterOperationTask: 'ClusterOperationTask',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterOperationTask: { 'type': 'array', 'itemType': ListClusterOperationTaskResponseBodyClusterOperationTaskListClusterOperationTask },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterServiceResponseBodyClusterServiceListClusterServiceServiceActionListServiceAction extends $tea.Model {
  actionName?: string;
  command?: string;
  componentName?: string;
  displayName?: string;
  serviceName?: string;
  static names(): { [key: string]: string } {
    return {
      actionName: 'ActionName',
      command: 'Command',
      componentName: 'ComponentName',
      displayName: 'DisplayName',
      serviceName: 'ServiceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actionName: 'string',
      command: 'string',
      componentName: 'string',
      displayName: 'string',
      serviceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterServiceResponseBodyClusterServiceListClusterServiceServiceActionList extends $tea.Model {
  serviceAction?: ListClusterServiceResponseBodyClusterServiceListClusterServiceServiceActionListServiceAction[];
  static names(): { [key: string]: string } {
    return {
      serviceAction: 'ServiceAction',
    };
  }

  static types(): { [key: string]: any } {
    return {
      serviceAction: { 'type': 'array', 'itemType': ListClusterServiceResponseBodyClusterServiceListClusterServiceServiceActionListServiceAction },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterServiceResponseBodyClusterServiceListClusterService extends $tea.Model {
  abnormalNum?: number;
  clientType?: boolean;
  healthStatus?: string;
  installStatus?: boolean;
  needRestartInfo?: string;
  needRestartNum?: number;
  notStartInfo?: string;
  serviceActionList?: ListClusterServiceResponseBodyClusterServiceListClusterServiceServiceActionList;
  serviceDisplayName?: string;
  serviceName?: string;
  serviceStatus?: string;
  serviceVersion?: string;
  state?: string;
  stoppedNum?: number;
  static names(): { [key: string]: string } {
    return {
      abnormalNum: 'AbnormalNum',
      clientType: 'ClientType',
      healthStatus: 'HealthStatus',
      installStatus: 'InstallStatus',
      needRestartInfo: 'NeedRestartInfo',
      needRestartNum: 'NeedRestartNum',
      notStartInfo: 'NotStartInfo',
      serviceActionList: 'ServiceActionList',
      serviceDisplayName: 'ServiceDisplayName',
      serviceName: 'ServiceName',
      serviceStatus: 'ServiceStatus',
      serviceVersion: 'ServiceVersion',
      state: 'State',
      stoppedNum: 'StoppedNum',
    };
  }

  static types(): { [key: string]: any } {
    return {
      abnormalNum: 'number',
      clientType: 'boolean',
      healthStatus: 'string',
      installStatus: 'boolean',
      needRestartInfo: 'string',
      needRestartNum: 'number',
      notStartInfo: 'string',
      serviceActionList: ListClusterServiceResponseBodyClusterServiceListClusterServiceServiceActionList,
      serviceDisplayName: 'string',
      serviceName: 'string',
      serviceStatus: 'string',
      serviceVersion: 'string',
      state: 'string',
      stoppedNum: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterServiceResponseBodyClusterServiceList extends $tea.Model {
  clusterService?: ListClusterServiceResponseBodyClusterServiceListClusterService[];
  static names(): { [key: string]: string } {
    return {
      clusterService: 'ClusterService',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterService: { 'type': 'array', 'itemType': ListClusterServiceResponseBodyClusterServiceListClusterService },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterServiceComponentResponseBodyComponentListComponent extends $tea.Model {
  commissionStatus?: string;
  componentDisplayName?: string;
  componentName?: string;
  desiredCount?: number;
  namespace?: string;
  needRestart?: boolean;
  podName?: string;
  privateIp?: string;
  publicIp?: string;
  role?: string;
  serverStatus?: string;
  serviceDisplayName?: string;
  serviceName?: string;
  status?: string;
  workloadName?: string;
  workloadType?: string;
  static names(): { [key: string]: string } {
    return {
      commissionStatus: 'CommissionStatus',
      componentDisplayName: 'ComponentDisplayName',
      componentName: 'ComponentName',
      desiredCount: 'DesiredCount',
      namespace: 'Namespace',
      needRestart: 'NeedRestart',
      podName: 'PodName',
      privateIp: 'PrivateIp',
      publicIp: 'PublicIp',
      role: 'Role',
      serverStatus: 'ServerStatus',
      serviceDisplayName: 'ServiceDisplayName',
      serviceName: 'ServiceName',
      status: 'Status',
      workloadName: 'WorkloadName',
      workloadType: 'WorkloadType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commissionStatus: 'string',
      componentDisplayName: 'string',
      componentName: 'string',
      desiredCount: 'number',
      namespace: 'string',
      needRestart: 'boolean',
      podName: 'string',
      privateIp: 'string',
      publicIp: 'string',
      role: 'string',
      serverStatus: 'string',
      serviceDisplayName: 'string',
      serviceName: 'string',
      status: 'string',
      workloadName: 'string',
      workloadType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterServiceComponentResponseBodyComponentList extends $tea.Model {
  component?: ListClusterServiceComponentResponseBodyComponentListComponent[];
  static names(): { [key: string]: string } {
    return {
      component: 'Component',
    };
  }

  static types(): { [key: string]: any } {
    return {
      component: { 'type': 'array', 'itemType': ListClusterServiceComponentResponseBodyComponentListComponent },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterServiceComponentHealthInfoResponseBodyHealthInfoListHealthInfoHealthDetailListHealthDetailHealthRuleParam extends $tea.Model {
  component?: string;
  hostNames?: string;
  pass?: string;
  ruleDescription?: string;
  ruleId?: string;
  ruleTitle?: string;
  service?: string;
  static names(): { [key: string]: string } {
    return {
      component: 'Component',
      hostNames: 'HostNames',
      pass: 'Pass',
      ruleDescription: 'RuleDescription',
      ruleId: 'RuleId',
      ruleTitle: 'RuleTitle',
      service: 'Service',
    };
  }

  static types(): { [key: string]: any } {
    return {
      component: 'string',
      hostNames: 'string',
      pass: 'string',
      ruleDescription: 'string',
      ruleId: 'string',
      ruleTitle: 'string',
      service: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterServiceComponentHealthInfoResponseBodyHealthInfoListHealthInfoHealthDetailListHealthDetail extends $tea.Model {
  healthRuleParam?: ListClusterServiceComponentHealthInfoResponseBodyHealthInfoListHealthInfoHealthDetailListHealthDetailHealthRuleParam;
  code?: string;
  static names(): { [key: string]: string } {
    return {
      healthRuleParam: 'HealthRuleParam',
      code: 'code',
    };
  }

  static types(): { [key: string]: any } {
    return {
      healthRuleParam: ListClusterServiceComponentHealthInfoResponseBodyHealthInfoListHealthInfoHealthDetailListHealthDetailHealthRuleParam,
      code: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterServiceComponentHealthInfoResponseBodyHealthInfoListHealthInfoHealthDetailList extends $tea.Model {
  healthDetail?: ListClusterServiceComponentHealthInfoResponseBodyHealthInfoListHealthInfoHealthDetailListHealthDetail[];
  static names(): { [key: string]: string } {
    return {
      healthDetail: 'HealthDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      healthDetail: { 'type': 'array', 'itemType': ListClusterServiceComponentHealthInfoResponseBodyHealthInfoListHealthInfoHealthDetailListHealthDetail },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterServiceComponentHealthInfoResponseBodyHealthInfoListHealthInfo extends $tea.Model {
  agentHeartBeatLostNum?: number;
  badHealthNum?: number;
  componentName?: string;
  createdTime?: number;
  disabledHealthNum?: number;
  goodHealthNum?: number;
  healthDetailList?: ListClusterServiceComponentHealthInfoResponseBodyHealthInfoListHealthInfoHealthDetailList;
  healthLevel?: string;
  healthStatus?: string;
  manualStoppedNum?: number;
  noneHealthNum?: number;
  normalNum?: number;
  serviceName?: string;
  stoppedHealthNum?: number;
  stoppedNum?: number;
  totalNum?: number;
  unknownHealthNum?: number;
  warningHealthNum?: number;
  static names(): { [key: string]: string } {
    return {
      agentHeartBeatLostNum: 'AgentHeartBeatLostNum',
      badHealthNum: 'BadHealthNum',
      componentName: 'ComponentName',
      createdTime: 'CreatedTime',
      disabledHealthNum: 'DisabledHealthNum',
      goodHealthNum: 'GoodHealthNum',
      healthDetailList: 'HealthDetailList',
      healthLevel: 'HealthLevel',
      healthStatus: 'HealthStatus',
      manualStoppedNum: 'ManualStoppedNum',
      noneHealthNum: 'NoneHealthNum',
      normalNum: 'NormalNum',
      serviceName: 'ServiceName',
      stoppedHealthNum: 'StoppedHealthNum',
      stoppedNum: 'StoppedNum',
      totalNum: 'TotalNum',
      unknownHealthNum: 'UnknownHealthNum',
      warningHealthNum: 'WarningHealthNum',
    };
  }

  static types(): { [key: string]: any } {
    return {
      agentHeartBeatLostNum: 'number',
      badHealthNum: 'number',
      componentName: 'string',
      createdTime: 'number',
      disabledHealthNum: 'number',
      goodHealthNum: 'number',
      healthDetailList: ListClusterServiceComponentHealthInfoResponseBodyHealthInfoListHealthInfoHealthDetailList,
      healthLevel: 'string',
      healthStatus: 'string',
      manualStoppedNum: 'number',
      noneHealthNum: 'number',
      normalNum: 'number',
      serviceName: 'string',
      stoppedHealthNum: 'number',
      stoppedNum: 'number',
      totalNum: 'number',
      unknownHealthNum: 'number',
      warningHealthNum: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterServiceComponentHealthInfoResponseBodyHealthInfoList extends $tea.Model {
  healthInfo?: ListClusterServiceComponentHealthInfoResponseBodyHealthInfoListHealthInfo[];
  static names(): { [key: string]: string } {
    return {
      healthInfo: 'HealthInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      healthInfo: { 'type': 'array', 'itemType': ListClusterServiceComponentHealthInfoResponseBodyHealthInfoListHealthInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterServiceConfigHistoryResponseBodyConfigHistoryListConfigHistory extends $tea.Model {
  applied?: boolean;
  author?: string;
  comment?: string;
  configFileName?: string;
  configItemName?: string;
  configVersion?: string;
  createTime?: number;
  hostGroupId?: string;
  hostGroupName?: string;
  hostInstanceId?: string;
  hostName?: string;
  newValue?: string;
  oldValue?: string;
  serviceName?: string;
  static names(): { [key: string]: string } {
    return {
      applied: 'Applied',
      author: 'Author',
      comment: 'Comment',
      configFileName: 'ConfigFileName',
      configItemName: 'ConfigItemName',
      configVersion: 'ConfigVersion',
      createTime: 'CreateTime',
      hostGroupId: 'HostGroupId',
      hostGroupName: 'HostGroupName',
      hostInstanceId: 'HostInstanceId',
      hostName: 'HostName',
      newValue: 'NewValue',
      oldValue: 'OldValue',
      serviceName: 'ServiceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applied: 'boolean',
      author: 'string',
      comment: 'string',
      configFileName: 'string',
      configItemName: 'string',
      configVersion: 'string',
      createTime: 'number',
      hostGroupId: 'string',
      hostGroupName: 'string',
      hostInstanceId: 'string',
      hostName: 'string',
      newValue: 'string',
      oldValue: 'string',
      serviceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterServiceConfigHistoryResponseBodyConfigHistoryList extends $tea.Model {
  configHistory?: ListClusterServiceConfigHistoryResponseBodyConfigHistoryListConfigHistory[];
  static names(): { [key: string]: string } {
    return {
      configHistory: 'ConfigHistory',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configHistory: { 'type': 'array', 'itemType': ListClusterServiceConfigHistoryResponseBodyConfigHistoryListConfigHistory },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterServiceQuickLinkResponseBodyQuickLinkListQuickLink extends $tea.Model {
  port?: string;
  protocol?: string;
  quickLinkAddress?: string;
  serviceDisplayName?: string;
  serviceName?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      port: 'Port',
      protocol: 'Protocol',
      quickLinkAddress: 'QuickLinkAddress',
      serviceDisplayName: 'ServiceDisplayName',
      serviceName: 'ServiceName',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      port: 'string',
      protocol: 'string',
      quickLinkAddress: 'string',
      serviceDisplayName: 'string',
      serviceName: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterServiceQuickLinkResponseBodyQuickLinkList extends $tea.Model {
  quickLink?: ListClusterServiceQuickLinkResponseBodyQuickLinkListQuickLink[];
  static names(): { [key: string]: string } {
    return {
      quickLink: 'QuickLink',
    };
  }

  static types(): { [key: string]: any } {
    return {
      quickLink: { 'type': 'array', 'itemType': ListClusterServiceQuickLinkResponseBodyQuickLinkListQuickLink },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoBootstrapActionListBootstrapAction extends $tea.Model {
  arg?: string;
  name?: string;
  path?: string;
  static names(): { [key: string]: string } {
    return {
      arg: 'Arg',
      name: 'Name',
      path: 'Path',
    };
  }

  static types(): { [key: string]: any } {
    return {
      arg: 'string',
      name: 'string',
      path: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoBootstrapActionList extends $tea.Model {
  bootstrapAction?: ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoBootstrapActionListBootstrapAction[];
  static names(): { [key: string]: string } {
    return {
      bootstrapAction: 'BootstrapAction',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bootstrapAction: { 'type': 'array', 'itemType': ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoBootstrapActionListBootstrapAction },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoConfigListConfig extends $tea.Model {
  configKey?: string;
  configValue?: string;
  encrypt?: string;
  fileName?: string;
  replace?: string;
  serviceName?: string;
  static names(): { [key: string]: string } {
    return {
      configKey: 'ConfigKey',
      configValue: 'ConfigValue',
      encrypt: 'Encrypt',
      fileName: 'FileName',
      replace: 'Replace',
      serviceName: 'ServiceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configKey: 'string',
      configValue: 'string',
      encrypt: 'string',
      fileName: 'string',
      replace: 'string',
      serviceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoConfigList extends $tea.Model {
  config?: ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoConfigListConfig[];
  static names(): { [key: string]: string } {
    return {
      config: 'Config',
    };
  }

  static types(): { [key: string]: any } {
    return {
      config: { 'type': 'array', 'itemType': ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoConfigListConfig },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoHostGroupListHostGroup extends $tea.Model {
  chargeType?: string;
  diskCapacity?: number;
  diskCount?: number;
  diskType?: string;
  hostGroupId?: string;
  hostGroupName?: string;
  hostGroupType?: string;
  instanceType?: string;
  multiInstanceTypes?: string;
  nodeCount?: number;
  period?: string;
  sysDiskCapacity?: number;
  sysDiskType?: string;
  static names(): { [key: string]: string } {
    return {
      chargeType: 'ChargeType',
      diskCapacity: 'DiskCapacity',
      diskCount: 'DiskCount',
      diskType: 'DiskType',
      hostGroupId: 'HostGroupId',
      hostGroupName: 'HostGroupName',
      hostGroupType: 'HostGroupType',
      instanceType: 'InstanceType',
      multiInstanceTypes: 'MultiInstanceTypes',
      nodeCount: 'NodeCount',
      period: 'Period',
      sysDiskCapacity: 'SysDiskCapacity',
      sysDiskType: 'SysDiskType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      chargeType: 'string',
      diskCapacity: 'number',
      diskCount: 'number',
      diskType: 'string',
      hostGroupId: 'string',
      hostGroupName: 'string',
      hostGroupType: 'string',
      instanceType: 'string',
      multiInstanceTypes: 'string',
      nodeCount: 'number',
      period: 'string',
      sysDiskCapacity: 'number',
      sysDiskType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoHostGroupList extends $tea.Model {
  hostGroup?: ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoHostGroupListHostGroup[];
  static names(): { [key: string]: string } {
    return {
      hostGroup: 'HostGroup',
    };
  }

  static types(): { [key: string]: any } {
    return {
      hostGroup: { 'type': 'array', 'itemType': ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoHostGroupListHostGroup },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoSoftwareInfoList extends $tea.Model {
  softwareInfo?: string[];
  static names(): { [key: string]: string } {
    return {
      softwareInfo: 'SoftwareInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      softwareInfo: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfo extends $tea.Model {
  allowNotebook?: boolean;
  bootstrapActionList?: ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoBootstrapActionList;
  clusterType?: string;
  configList?: ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoConfigList;
  configurations?: string;
  createSource?: string;
  depositType?: string;
  easEnable?: boolean;
  gmtCreate?: number;
  gmtModified?: number;
  highAvailabilityEnable?: boolean;
  hostGroupList?: ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoHostGroupList;
  id?: string;
  initCustomHiveMetaDb?: boolean;
  instanceGeneration?: string;
  ioOptimized?: boolean;
  isOpenPublicIp?: boolean;
  keyPairName?: string;
  logEnable?: boolean;
  logPath?: string;
  machineType?: string;
  masterNodeTotal?: number;
  metaStoreConf?: string;
  metaStoreType?: string;
  netType?: string;
  securityGroupId?: string;
  securityGroupName?: string;
  softwareInfoList?: ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoSoftwareInfoList;
  sshEnable?: boolean;
  templateName?: string;
  useCustomHiveMetaDb?: boolean;
  useLocalMetaDb?: boolean;
  userDefinedEmrEcsRole?: string;
  userId?: string;
  vSwitchId?: string;
  vpcId?: string;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      allowNotebook: 'AllowNotebook',
      bootstrapActionList: 'BootstrapActionList',
      clusterType: 'ClusterType',
      configList: 'ConfigList',
      configurations: 'Configurations',
      createSource: 'CreateSource',
      depositType: 'DepositType',
      easEnable: 'EasEnable',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      highAvailabilityEnable: 'HighAvailabilityEnable',
      hostGroupList: 'HostGroupList',
      id: 'Id',
      initCustomHiveMetaDb: 'InitCustomHiveMetaDb',
      instanceGeneration: 'InstanceGeneration',
      ioOptimized: 'IoOptimized',
      isOpenPublicIp: 'IsOpenPublicIp',
      keyPairName: 'KeyPairName',
      logEnable: 'LogEnable',
      logPath: 'LogPath',
      machineType: 'MachineType',
      masterNodeTotal: 'MasterNodeTotal',
      metaStoreConf: 'MetaStoreConf',
      metaStoreType: 'MetaStoreType',
      netType: 'NetType',
      securityGroupId: 'SecurityGroupId',
      securityGroupName: 'SecurityGroupName',
      softwareInfoList: 'SoftwareInfoList',
      sshEnable: 'SshEnable',
      templateName: 'TemplateName',
      useCustomHiveMetaDb: 'UseCustomHiveMetaDb',
      useLocalMetaDb: 'UseLocalMetaDb',
      userDefinedEmrEcsRole: 'UserDefinedEmrEcsRole',
      userId: 'UserId',
      vSwitchId: 'VSwitchId',
      vpcId: 'VpcId',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allowNotebook: 'boolean',
      bootstrapActionList: ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoBootstrapActionList,
      clusterType: 'string',
      configList: ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoConfigList,
      configurations: 'string',
      createSource: 'string',
      depositType: 'string',
      easEnable: 'boolean',
      gmtCreate: 'number',
      gmtModified: 'number',
      highAvailabilityEnable: 'boolean',
      hostGroupList: ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoHostGroupList,
      id: 'string',
      initCustomHiveMetaDb: 'boolean',
      instanceGeneration: 'string',
      ioOptimized: 'boolean',
      isOpenPublicIp: 'boolean',
      keyPairName: 'string',
      logEnable: 'boolean',
      logPath: 'string',
      machineType: 'string',
      masterNodeTotal: 'number',
      metaStoreConf: 'string',
      metaStoreType: 'string',
      netType: 'string',
      securityGroupId: 'string',
      securityGroupName: 'string',
      softwareInfoList: ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoSoftwareInfoList,
      sshEnable: 'boolean',
      templateName: 'string',
      useCustomHiveMetaDb: 'boolean',
      useLocalMetaDb: 'boolean',
      userDefinedEmrEcsRole: 'string',
      userId: 'string',
      vSwitchId: 'string',
      vpcId: 'string',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterTemplatesResponseBodyTemplateInfoList extends $tea.Model {
  templateInfo?: ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfo[];
  static names(): { [key: string]: string } {
    return {
      templateInfo: 'TemplateInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      templateInfo: { 'type': 'array', 'itemType': ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClustersRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClustersResponseBodyClustersClusterInfoFailReason extends $tea.Model {
  errorCode?: string;
  errorMsg?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMsg: 'ErrorMsg',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMsg: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClustersResponseBodyClustersClusterInfoOrderTaskInfo extends $tea.Model {
  currentCount?: number;
  orderIdList?: string;
  targetCount?: number;
  static names(): { [key: string]: string } {
    return {
      currentCount: 'CurrentCount',
      orderIdList: 'OrderIdList',
      targetCount: 'TargetCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentCount: 'number',
      orderIdList: 'string',
      targetCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClustersResponseBodyClustersClusterInfoTagsTag extends $tea.Model {
  tagKey?: string;
  tagValue?: string;
  static names(): { [key: string]: string } {
    return {
      tagKey: 'TagKey',
      tagValue: 'TagValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagKey: 'string',
      tagValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClustersResponseBodyClustersClusterInfoTags extends $tea.Model {
  tag?: ListClustersResponseBodyClustersClusterInfoTagsTag[];
  static names(): { [key: string]: string } {
    return {
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tag: { 'type': 'array', 'itemType': ListClustersResponseBodyClustersClusterInfoTagsTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClustersResponseBodyClustersClusterInfo extends $tea.Model {
  chargeType?: string;
  createResource?: string;
  createTime?: number;
  depositType?: string;
  expiredTime?: number;
  failReason?: ListClustersResponseBodyClustersClusterInfoFailReason;
  hasUncompletedOrder?: boolean;
  id?: string;
  k8sClusterId?: string;
  machineType?: string;
  metaStoreType?: string;
  name?: string;
  operationId?: number;
  orderList?: string;
  orderTaskInfo?: ListClustersResponseBodyClustersClusterInfoOrderTaskInfo;
  period?: number;
  runningTime?: number;
  status?: string;
  tags?: ListClustersResponseBodyClustersClusterInfoTags;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      chargeType: 'ChargeType',
      createResource: 'CreateResource',
      createTime: 'CreateTime',
      depositType: 'DepositType',
      expiredTime: 'ExpiredTime',
      failReason: 'FailReason',
      hasUncompletedOrder: 'HasUncompletedOrder',
      id: 'Id',
      k8sClusterId: 'K8sClusterId',
      machineType: 'MachineType',
      metaStoreType: 'MetaStoreType',
      name: 'Name',
      operationId: 'OperationId',
      orderList: 'OrderList',
      orderTaskInfo: 'OrderTaskInfo',
      period: 'Period',
      runningTime: 'RunningTime',
      status: 'Status',
      tags: 'Tags',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      chargeType: 'string',
      createResource: 'string',
      createTime: 'number',
      depositType: 'string',
      expiredTime: 'number',
      failReason: ListClustersResponseBodyClustersClusterInfoFailReason,
      hasUncompletedOrder: 'boolean',
      id: 'string',
      k8sClusterId: 'string',
      machineType: 'string',
      metaStoreType: 'string',
      name: 'string',
      operationId: 'number',
      orderList: 'string',
      orderTaskInfo: ListClustersResponseBodyClustersClusterInfoOrderTaskInfo,
      period: 'number',
      runningTime: 'number',
      status: 'string',
      tags: ListClustersResponseBodyClustersClusterInfoTags,
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClustersResponseBodyClusters extends $tea.Model {
  clusterInfo?: ListClustersResponseBodyClustersClusterInfo[];
  static names(): { [key: string]: string } {
    return {
      clusterInfo: 'ClusterInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterInfo: { 'type': 'array', 'itemType': ListClustersResponseBodyClustersClusterInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataSourceResponseBodyDataSourceListDataSource extends $tea.Model {
  clusterId?: string;
  conf?: string;
  createFrom?: string;
  creator?: string;
  description?: string;
  gmtCreate?: number;
  gmtModified?: number;
  id?: string;
  modifier?: string;
  name?: string;
  sourceType?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      conf: 'Conf',
      createFrom: 'CreateFrom',
      creator: 'Creator',
      description: 'Description',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      id: 'Id',
      modifier: 'Modifier',
      name: 'Name',
      sourceType: 'SourceType',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      conf: 'string',
      createFrom: 'string',
      creator: 'string',
      description: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      id: 'string',
      modifier: 'string',
      name: 'string',
      sourceType: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataSourceResponseBodyDataSourceList extends $tea.Model {
  dataSource?: ListDataSourceResponseBodyDataSourceListDataSource[];
  static names(): { [key: string]: string } {
    return {
      dataSource: 'DataSource',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataSource: { 'type': 'array', 'itemType': ListDataSourceResponseBodyDataSourceListDataSource },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDiskOpsEventsResponseBodyEventListDiskOpsEventInfo extends $tea.Model {
  clusterBizId?: string;
  clusterName?: string;
  currentActivity?: string;
  currentActivityState?: string;
  diskDevice?: string;
  diskId?: string;
  diskMountPoint?: string;
  eventId?: string;
  eventTriggerTime?: number;
  eventType?: string;
  instanceId?: string;
  instanceName?: string;
  instanceStatus?: string;
  privateIp?: string;
  regionId?: string;
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterBizId: 'ClusterBizId',
      clusterName: 'ClusterName',
      currentActivity: 'CurrentActivity',
      currentActivityState: 'CurrentActivityState',
      diskDevice: 'DiskDevice',
      diskId: 'DiskId',
      diskMountPoint: 'DiskMountPoint',
      eventId: 'EventId',
      eventTriggerTime: 'EventTriggerTime',
      eventType: 'EventType',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      instanceStatus: 'InstanceStatus',
      privateIp: 'PrivateIp',
      regionId: 'RegionId',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterBizId: 'string',
      clusterName: 'string',
      currentActivity: 'string',
      currentActivityState: 'string',
      diskDevice: 'string',
      diskId: 'string',
      diskMountPoint: 'string',
      eventId: 'string',
      eventTriggerTime: 'number',
      eventType: 'string',
      instanceId: 'string',
      instanceName: 'string',
      instanceStatus: 'string',
      privateIp: 'string',
      regionId: 'string',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDiskOpsEventsResponseBodyEventList extends $tea.Model {
  diskOpsEventInfo?: ListDiskOpsEventsResponseBodyEventListDiskOpsEventInfo[];
  static names(): { [key: string]: string } {
    return {
      diskOpsEventInfo: 'DiskOpsEventInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      diskOpsEventInfo: { 'type': 'array', 'itemType': ListDiskOpsEventsResponseBodyEventListDiskOpsEventInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEmrAvailableConfigResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfoClusterServiceInfoListClusterServiceInfo extends $tea.Model {
  mandatory?: boolean;
  serviceDisplayName?: string;
  serviceName?: string;
  serviceVersion?: string;
  static names(): { [key: string]: string } {
    return {
      mandatory: 'Mandatory',
      serviceDisplayName: 'ServiceDisplayName',
      serviceName: 'ServiceName',
      serviceVersion: 'ServiceVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      mandatory: 'boolean',
      serviceDisplayName: 'string',
      serviceName: 'string',
      serviceVersion: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEmrAvailableConfigResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfoClusterServiceInfoList extends $tea.Model {
  clusterServiceInfo?: ListEmrAvailableConfigResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfoClusterServiceInfoListClusterServiceInfo[];
  static names(): { [key: string]: string } {
    return {
      clusterServiceInfo: 'ClusterServiceInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterServiceInfo: { 'type': 'array', 'itemType': ListEmrAvailableConfigResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfoClusterServiceInfoListClusterServiceInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEmrAvailableConfigResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfo extends $tea.Model {
  clusterServiceInfoList?: ListEmrAvailableConfigResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfoClusterServiceInfoList;
  clusterType?: string;
  static names(): { [key: string]: string } {
    return {
      clusterServiceInfoList: 'ClusterServiceInfoList',
      clusterType: 'ClusterType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterServiceInfoList: ListEmrAvailableConfigResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfoClusterServiceInfoList,
      clusterType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEmrAvailableConfigResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoList extends $tea.Model {
  clusterTypeInfo?: ListEmrAvailableConfigResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfo[];
  static names(): { [key: string]: string } {
    return {
      clusterTypeInfo: 'ClusterTypeInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterTypeInfo: { 'type': 'array', 'itemType': ListEmrAvailableConfigResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEmrAvailableConfigResponseBodyEmrMainVersionListEmrMainVersion extends $tea.Model {
  clusterTypeInfoList?: ListEmrAvailableConfigResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoList;
  ecmVersion?: boolean;
  extraInfo?: string;
  mainVersionName?: string;
  onCloudNative?: boolean;
  publishType?: string;
  regionId?: string;
  stackName?: string;
  stackVersion?: string;
  static names(): { [key: string]: string } {
    return {
      clusterTypeInfoList: 'ClusterTypeInfoList',
      ecmVersion: 'EcmVersion',
      extraInfo: 'ExtraInfo',
      mainVersionName: 'MainVersionName',
      onCloudNative: 'OnCloudNative',
      publishType: 'PublishType',
      regionId: 'RegionId',
      stackName: 'StackName',
      stackVersion: 'StackVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterTypeInfoList: ListEmrAvailableConfigResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoList,
      ecmVersion: 'boolean',
      extraInfo: 'string',
      mainVersionName: 'string',
      onCloudNative: 'boolean',
      publishType: 'string',
      regionId: 'string',
      stackName: 'string',
      stackVersion: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEmrAvailableConfigResponseBodyEmrMainVersionList extends $tea.Model {
  emrMainVersion?: ListEmrAvailableConfigResponseBodyEmrMainVersionListEmrMainVersion[];
  static names(): { [key: string]: string } {
    return {
      emrMainVersion: 'EmrMainVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      emrMainVersion: { 'type': 'array', 'itemType': ListEmrAvailableConfigResponseBodyEmrMainVersionListEmrMainVersion },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEmrAvailableConfigResponseBodyKeyPairNameList extends $tea.Model {
  keyPairName?: string[];
  static names(): { [key: string]: string } {
    return {
      keyPairName: 'KeyPairName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      keyPairName: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEmrAvailableConfigResponseBodySecurityGroupListSecurityGroup extends $tea.Model {
  availableInstanceAmount?: number;
  creationTime?: string;
  description?: string;
  ecsCount?: number;
  securityGroupId?: string;
  securityGroupName?: string;
  securityGroupType?: string;
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      availableInstanceAmount: 'AvailableInstanceAmount',
      creationTime: 'CreationTime',
      description: 'Description',
      ecsCount: 'EcsCount',
      securityGroupId: 'SecurityGroupId',
      securityGroupName: 'SecurityGroupName',
      securityGroupType: 'SecurityGroupType',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      availableInstanceAmount: 'number',
      creationTime: 'string',
      description: 'string',
      ecsCount: 'number',
      securityGroupId: 'string',
      securityGroupName: 'string',
      securityGroupType: 'string',
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEmrAvailableConfigResponseBodySecurityGroupList extends $tea.Model {
  securityGroup?: ListEmrAvailableConfigResponseBodySecurityGroupListSecurityGroup[];
  static names(): { [key: string]: string } {
    return {
      securityGroup: 'SecurityGroup',
    };
  }

  static types(): { [key: string]: any } {
    return {
      securityGroup: { 'type': 'array', 'itemType': ListEmrAvailableConfigResponseBodySecurityGroupListSecurityGroup },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEmrAvailableConfigResponseBodyVpcInfoListVpcInfoVswitchInfoListVswitchInfo extends $tea.Model {
  availableIpAddressCount?: number;
  cidrBlock?: string;
  creationTime?: string;
  description?: string;
  vpcId?: string;
  vswitchId?: string;
  vswitchName?: string;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      availableIpAddressCount: 'AvailableIpAddressCount',
      cidrBlock: 'CidrBlock',
      creationTime: 'CreationTime',
      description: 'Description',
      vpcId: 'VpcId',
      vswitchId: 'VswitchId',
      vswitchName: 'VswitchName',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      availableIpAddressCount: 'number',
      cidrBlock: 'string',
      creationTime: 'string',
      description: 'string',
      vpcId: 'string',
      vswitchId: 'string',
      vswitchName: 'string',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEmrAvailableConfigResponseBodyVpcInfoListVpcInfoVswitchInfoList extends $tea.Model {
  vswitchInfo?: ListEmrAvailableConfigResponseBodyVpcInfoListVpcInfoVswitchInfoListVswitchInfo[];
  static names(): { [key: string]: string } {
    return {
      vswitchInfo: 'VswitchInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      vswitchInfo: { 'type': 'array', 'itemType': ListEmrAvailableConfigResponseBodyVpcInfoListVpcInfoVswitchInfoListVswitchInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEmrAvailableConfigResponseBodyVpcInfoListVpcInfo extends $tea.Model {
  cidrBlock?: string;
  creationTime?: string;
  description?: string;
  VRouterId?: string;
  vpcId?: string;
  vpcName?: string;
  vswitchInfoList?: ListEmrAvailableConfigResponseBodyVpcInfoListVpcInfoVswitchInfoList;
  static names(): { [key: string]: string } {
    return {
      cidrBlock: 'CidrBlock',
      creationTime: 'CreationTime',
      description: 'Description',
      VRouterId: 'VRouterId',
      vpcId: 'VpcId',
      vpcName: 'VpcName',
      vswitchInfoList: 'VswitchInfoList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cidrBlock: 'string',
      creationTime: 'string',
      description: 'string',
      VRouterId: 'string',
      vpcId: 'string',
      vpcName: 'string',
      vswitchInfoList: ListEmrAvailableConfigResponseBodyVpcInfoListVpcInfoVswitchInfoList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEmrAvailableConfigResponseBodyVpcInfoList extends $tea.Model {
  vpcInfo?: ListEmrAvailableConfigResponseBodyVpcInfoListVpcInfo[];
  static names(): { [key: string]: string } {
    return {
      vpcInfo: 'VpcInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      vpcInfo: { 'type': 'array', 'itemType': ListEmrAvailableConfigResponseBodyVpcInfoListVpcInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfoEmrResourceInfoListEmrResourceInfoSupportedResourceListSupportedResourceEmrInstanceType extends $tea.Model {
  baselineCredit?: number;
  cpuCoreCount?: number;
  eniQuantity?: number;
  GPUAmount?: number;
  GPUSpec?: string;
  initialCredit?: number;
  instanceBandwidthRx?: number;
  instanceBandwidthTx?: number;
  instancePpsRx?: number;
  instancePpsTx?: number;
  instanceType?: string;
  instanceTypeFamily?: string;
  localStorageAmount?: number;
  localStorageCapacity?: number;
  localStorageCategory?: string;
  memorySize?: number;
  static names(): { [key: string]: string } {
    return {
      baselineCredit: 'BaselineCredit',
      cpuCoreCount: 'CpuCoreCount',
      eniQuantity: 'EniQuantity',
      GPUAmount: 'GPUAmount',
      GPUSpec: 'GPUSpec',
      initialCredit: 'InitialCredit',
      instanceBandwidthRx: 'InstanceBandwidthRx',
      instanceBandwidthTx: 'InstanceBandwidthTx',
      instancePpsRx: 'InstancePpsRx',
      instancePpsTx: 'InstancePpsTx',
      instanceType: 'InstanceType',
      instanceTypeFamily: 'InstanceTypeFamily',
      localStorageAmount: 'LocalStorageAmount',
      localStorageCapacity: 'LocalStorageCapacity',
      localStorageCategory: 'LocalStorageCategory',
      memorySize: 'MemorySize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      baselineCredit: 'number',
      cpuCoreCount: 'number',
      eniQuantity: 'number',
      GPUAmount: 'number',
      GPUSpec: 'string',
      initialCredit: 'number',
      instanceBandwidthRx: 'number',
      instanceBandwidthTx: 'number',
      instancePpsRx: 'number',
      instancePpsTx: 'number',
      instanceType: 'string',
      instanceTypeFamily: 'string',
      localStorageAmount: 'number',
      localStorageCapacity: 'number',
      localStorageCategory: 'string',
      memorySize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfoEmrResourceInfoListEmrResourceInfoSupportedResourceListSupportedResourceSupportNodeTypeList extends $tea.Model {
  supportNodeType?: string[];
  static names(): { [key: string]: string } {
    return {
      supportNodeType: 'SupportNodeType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      supportNodeType: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfoEmrResourceInfoListEmrResourceInfoSupportedResourceListSupportedResource extends $tea.Model {
  emrInstanceType?: ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfoEmrResourceInfoListEmrResourceInfoSupportedResourceListSupportedResourceEmrInstanceType;
  max?: number;
  min?: number;
  supportNodeTypeList?: ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfoEmrResourceInfoListEmrResourceInfoSupportedResourceListSupportedResourceSupportNodeTypeList;
  unit?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      emrInstanceType: 'EmrInstanceType',
      max: 'Max',
      min: 'Min',
      supportNodeTypeList: 'SupportNodeTypeList',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      emrInstanceType: ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfoEmrResourceInfoListEmrResourceInfoSupportedResourceListSupportedResourceEmrInstanceType,
      max: 'number',
      min: 'number',
      supportNodeTypeList: ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfoEmrResourceInfoListEmrResourceInfoSupportedResourceListSupportedResourceSupportNodeTypeList,
      unit: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfoEmrResourceInfoListEmrResourceInfoSupportedResourceList extends $tea.Model {
  supportedResource?: ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfoEmrResourceInfoListEmrResourceInfoSupportedResourceListSupportedResource[];
  static names(): { [key: string]: string } {
    return {
      supportedResource: 'SupportedResource',
    };
  }

  static types(): { [key: string]: any } {
    return {
      supportedResource: { 'type': 'array', 'itemType': ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfoEmrResourceInfoListEmrResourceInfoSupportedResourceListSupportedResource },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfoEmrResourceInfoListEmrResourceInfo extends $tea.Model {
  supportedResourceList?: ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfoEmrResourceInfoListEmrResourceInfoSupportedResourceList;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      supportedResourceList: 'SupportedResourceList',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      supportedResourceList: ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfoEmrResourceInfoListEmrResourceInfoSupportedResourceList,
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfoEmrResourceInfoList extends $tea.Model {
  emrResourceInfo?: ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfoEmrResourceInfoListEmrResourceInfo[];
  static names(): { [key: string]: string } {
    return {
      emrResourceInfo: 'EmrResourceInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      emrResourceInfo: { 'type': 'array', 'itemType': ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfoEmrResourceInfoListEmrResourceInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfo extends $tea.Model {
  emrResourceInfoList?: ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfoEmrResourceInfoList;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      emrResourceInfoList: 'EmrResourceInfoList',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      emrResourceInfoList: ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfoEmrResourceInfoList,
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEmrAvailableResourceResponseBodyEmrZoneInfoList extends $tea.Model {
  emrZoneInfo?: ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfo[];
  static names(): { [key: string]: string } {
    return {
      emrZoneInfo: 'EmrZoneInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      emrZoneInfo: { 'type': 'array', 'itemType': ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfoServiceInfoListServiceInfo extends $tea.Model {
  display?: boolean;
  mandatory?: boolean;
  serviceDisplayName?: string;
  serviceDisplayVersion?: string;
  serviceName?: string;
  serviceVersion?: string;
  static names(): { [key: string]: string } {
    return {
      display: 'Display',
      mandatory: 'Mandatory',
      serviceDisplayName: 'ServiceDisplayName',
      serviceDisplayVersion: 'ServiceDisplayVersion',
      serviceName: 'ServiceName',
      serviceVersion: 'ServiceVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      display: 'boolean',
      mandatory: 'boolean',
      serviceDisplayName: 'string',
      serviceDisplayVersion: 'string',
      serviceName: 'string',
      serviceVersion: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfoServiceInfoList extends $tea.Model {
  serviceInfo?: ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfoServiceInfoListServiceInfo[];
  static names(): { [key: string]: string } {
    return {
      serviceInfo: 'ServiceInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      serviceInfo: { 'type': 'array', 'itemType': ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfoServiceInfoListServiceInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfo extends $tea.Model {
  clusterType?: string;
  serviceInfoList?: ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfoServiceInfoList;
  static names(): { [key: string]: string } {
    return {
      clusterType: 'ClusterType',
      serviceInfoList: 'ServiceInfoList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterType: 'string',
      serviceInfoList: ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfoServiceInfoList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoList extends $tea.Model {
  clusterTypeInfo?: ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfo[];
  static names(): { [key: string]: string } {
    return {
      clusterTypeInfo: 'ClusterTypeInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterTypeInfo: { 'type': 'array', 'itemType': ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeWhiteUserListClusterTypeWhiteUser extends $tea.Model {
  clusterType?: string;
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterType: 'ClusterType',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterType: 'string',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeWhiteUserList extends $tea.Model {
  clusterTypeWhiteUser?: ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeWhiteUserListClusterTypeWhiteUser[];
  static names(): { [key: string]: string } {
    return {
      clusterTypeWhiteUser: 'ClusterTypeWhiteUser',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterTypeWhiteUser: { 'type': 'array', 'itemType': ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeWhiteUserListClusterTypeWhiteUser },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionWhiteUserList extends $tea.Model {
  whiteUser?: string[];
  static names(): { [key: string]: string } {
    return {
      whiteUser: 'WhiteUser',
    };
  }

  static types(): { [key: string]: any } {
    return {
      whiteUser: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersion extends $tea.Model {
  clusterTypeInfoList?: ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoList;
  clusterTypeWhiteUserList?: ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeWhiteUserList;
  display?: boolean;
  ecmVersion?: boolean;
  emrVersion?: string;
  imageId?: string;
  publishType?: string;
  regionId?: string;
  stackName?: string;
  stackVersion?: string;
  whiteUserList?: ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionWhiteUserList;
  static names(): { [key: string]: string } {
    return {
      clusterTypeInfoList: 'ClusterTypeInfoList',
      clusterTypeWhiteUserList: 'ClusterTypeWhiteUserList',
      display: 'Display',
      ecmVersion: 'EcmVersion',
      emrVersion: 'EmrVersion',
      imageId: 'ImageId',
      publishType: 'PublishType',
      regionId: 'RegionId',
      stackName: 'StackName',
      stackVersion: 'StackVersion',
      whiteUserList: 'WhiteUserList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterTypeInfoList: ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoList,
      clusterTypeWhiteUserList: ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeWhiteUserList,
      display: 'boolean',
      ecmVersion: 'boolean',
      emrVersion: 'string',
      imageId: 'string',
      publishType: 'string',
      regionId: 'string',
      stackName: 'string',
      stackVersion: 'string',
      whiteUserList: ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionWhiteUserList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEmrMainVersionResponseBodyEmrMainVersionList extends $tea.Model {
  emrMainVersion?: ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersion[];
  static names(): { [key: string]: string } {
    return {
      emrMainVersion: 'EmrMainVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      emrMainVersion: { 'type': 'array', 'itemType': ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersion },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListExecutionPlanInstancesResponseBodyExecutionPlanInstancesExecutionPlanInstance extends $tea.Model {
  clusterId?: string;
  clusterName?: string;
  clusterType?: string;
  executionPlanId?: string;
  executionPlanName?: string;
  id?: string;
  logEnable?: boolean;
  logPath?: string;
  runTime?: number;
  startTime?: number;
  status?: string;
  workflowApp?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      clusterName: 'ClusterName',
      clusterType: 'ClusterType',
      executionPlanId: 'ExecutionPlanId',
      executionPlanName: 'ExecutionPlanName',
      id: 'Id',
      logEnable: 'LogEnable',
      logPath: 'LogPath',
      runTime: 'RunTime',
      startTime: 'StartTime',
      status: 'Status',
      workflowApp: 'WorkflowApp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      clusterName: 'string',
      clusterType: 'string',
      executionPlanId: 'string',
      executionPlanName: 'string',
      id: 'string',
      logEnable: 'boolean',
      logPath: 'string',
      runTime: 'number',
      startTime: 'number',
      status: 'string',
      workflowApp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListExecutionPlanInstancesResponseBodyExecutionPlanInstances extends $tea.Model {
  executionPlanInstance?: ListExecutionPlanInstancesResponseBodyExecutionPlanInstancesExecutionPlanInstance[];
  static names(): { [key: string]: string } {
    return {
      executionPlanInstance: 'ExecutionPlanInstance',
    };
  }

  static types(): { [key: string]: any } {
    return {
      executionPlanInstance: { 'type': 'array', 'itemType': ListExecutionPlanInstancesResponseBodyExecutionPlanInstancesExecutionPlanInstance },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowResponseBodyFlowFlow extends $tea.Model {
  alertConf?: string;
  alertDingDingGroupBizId?: string;
  alertUserGroupBizId?: string;
  categoryId?: string;
  clusterId?: string;
  createCluster?: boolean;
  cronExpr?: string;
  description?: string;
  endSchedule?: number;
  gmtCreate?: number;
  gmtModified?: number;
  graph?: string;
  hostName?: string;
  id?: string;
  name?: string;
  periodic?: boolean;
  projectId?: string;
  startSchedule?: number;
  status?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      alertConf: 'AlertConf',
      alertDingDingGroupBizId: 'AlertDingDingGroupBizId',
      alertUserGroupBizId: 'AlertUserGroupBizId',
      categoryId: 'CategoryId',
      clusterId: 'ClusterId',
      createCluster: 'CreateCluster',
      cronExpr: 'CronExpr',
      description: 'Description',
      endSchedule: 'EndSchedule',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      graph: 'Graph',
      hostName: 'HostName',
      id: 'Id',
      name: 'Name',
      periodic: 'Periodic',
      projectId: 'ProjectId',
      startSchedule: 'StartSchedule',
      status: 'Status',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertConf: 'string',
      alertDingDingGroupBizId: 'string',
      alertUserGroupBizId: 'string',
      categoryId: 'string',
      clusterId: 'string',
      createCluster: 'boolean',
      cronExpr: 'string',
      description: 'string',
      endSchedule: 'number',
      gmtCreate: 'number',
      gmtModified: 'number',
      graph: 'string',
      hostName: 'string',
      id: 'string',
      name: 'string',
      periodic: 'boolean',
      projectId: 'string',
      startSchedule: 'number',
      status: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowResponseBodyFlow extends $tea.Model {
  flow?: ListFlowResponseBodyFlowFlow[];
  static names(): { [key: string]: string } {
    return {
      flow: 'Flow',
    };
  }

  static types(): { [key: string]: any } {
    return {
      flow: { 'type': 'array', 'itemType': ListFlowResponseBodyFlowFlow },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowCategoryResponseBodyCategoriesCategory extends $tea.Model {
  categoryType?: string;
  gmtCreate?: number;
  gmtModified?: number;
  id?: string;
  name?: string;
  objectId?: string;
  objectType?: string;
  parentId?: string;
  projectId?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      categoryType: 'CategoryType',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      id: 'Id',
      name: 'Name',
      objectId: 'ObjectId',
      objectType: 'ObjectType',
      parentId: 'ParentId',
      projectId: 'ProjectId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      categoryType: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      id: 'string',
      name: 'string',
      objectId: 'string',
      objectType: 'string',
      parentId: 'string',
      projectId: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowCategoryResponseBodyCategories extends $tea.Model {
  category?: ListFlowCategoryResponseBodyCategoriesCategory[];
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: { 'type': 'array', 'itemType': ListFlowCategoryResponseBodyCategoriesCategory },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowClusterResponseBodyClustersClusterInfoFailReason extends $tea.Model {
  errorCode?: string;
  errorMsg?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMsg: 'ErrorMsg',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMsg: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowClusterResponseBodyClustersClusterInfoOrderTaskInfo extends $tea.Model {
  currentCount?: number;
  orderIdList?: string;
  targetCount?: number;
  static names(): { [key: string]: string } {
    return {
      currentCount: 'CurrentCount',
      orderIdList: 'OrderIdList',
      targetCount: 'TargetCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentCount: 'number',
      orderIdList: 'string',
      targetCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowClusterResponseBodyClustersClusterInfo extends $tea.Model {
  chargeType?: string;
  createResource?: string;
  createTime?: number;
  expiredTime?: number;
  failReason?: ListFlowClusterResponseBodyClustersClusterInfoFailReason;
  hasUncompletedOrder?: boolean;
  id?: string;
  k8sClusterId?: string;
  name?: string;
  orderList?: string;
  orderTaskInfo?: ListFlowClusterResponseBodyClustersClusterInfoOrderTaskInfo;
  period?: number;
  runningTime?: number;
  status?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      chargeType: 'ChargeType',
      createResource: 'CreateResource',
      createTime: 'CreateTime',
      expiredTime: 'ExpiredTime',
      failReason: 'FailReason',
      hasUncompletedOrder: 'HasUncompletedOrder',
      id: 'Id',
      k8sClusterId: 'K8sClusterId',
      name: 'Name',
      orderList: 'OrderList',
      orderTaskInfo: 'OrderTaskInfo',
      period: 'Period',
      runningTime: 'RunningTime',
      status: 'Status',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      chargeType: 'string',
      createResource: 'string',
      createTime: 'number',
      expiredTime: 'number',
      failReason: ListFlowClusterResponseBodyClustersClusterInfoFailReason,
      hasUncompletedOrder: 'boolean',
      id: 'string',
      k8sClusterId: 'string',
      name: 'string',
      orderList: 'string',
      orderTaskInfo: ListFlowClusterResponseBodyClustersClusterInfoOrderTaskInfo,
      period: 'number',
      runningTime: 'number',
      status: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowClusterResponseBodyClusters extends $tea.Model {
  clusterInfo?: ListFlowClusterResponseBodyClustersClusterInfo[];
  static names(): { [key: string]: string } {
    return {
      clusterInfo: 'ClusterInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterInfo: { 'type': 'array', 'itemType': ListFlowClusterResponseBodyClustersClusterInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowClusterAllResponseBodyClustersClusterInfoFailReason extends $tea.Model {
  errorCode?: string;
  errorMsg?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMsg: 'ErrorMsg',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMsg: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowClusterAllResponseBodyClustersClusterInfoOrderTaskInfo extends $tea.Model {
  currentCount?: number;
  orderIdList?: string;
  targetCount?: number;
  static names(): { [key: string]: string } {
    return {
      currentCount: 'CurrentCount',
      orderIdList: 'OrderIdList',
      targetCount: 'TargetCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentCount: 'number',
      orderIdList: 'string',
      targetCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowClusterAllResponseBodyClustersClusterInfo extends $tea.Model {
  chargeType?: string;
  createResource?: string;
  createTime?: number;
  expiredTime?: number;
  failReason?: ListFlowClusterAllResponseBodyClustersClusterInfoFailReason;
  hasUncompletedOrder?: boolean;
  id?: string;
  k8sClusterId?: string;
  name?: string;
  orderList?: string;
  orderTaskInfo?: ListFlowClusterAllResponseBodyClustersClusterInfoOrderTaskInfo;
  period?: number;
  runningTime?: number;
  status?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      chargeType: 'ChargeType',
      createResource: 'CreateResource',
      createTime: 'CreateTime',
      expiredTime: 'ExpiredTime',
      failReason: 'FailReason',
      hasUncompletedOrder: 'HasUncompletedOrder',
      id: 'Id',
      k8sClusterId: 'K8sClusterId',
      name: 'Name',
      orderList: 'OrderList',
      orderTaskInfo: 'OrderTaskInfo',
      period: 'Period',
      runningTime: 'RunningTime',
      status: 'Status',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      chargeType: 'string',
      createResource: 'string',
      createTime: 'number',
      expiredTime: 'number',
      failReason: ListFlowClusterAllResponseBodyClustersClusterInfoFailReason,
      hasUncompletedOrder: 'boolean',
      id: 'string',
      k8sClusterId: 'string',
      name: 'string',
      orderList: 'string',
      orderTaskInfo: ListFlowClusterAllResponseBodyClustersClusterInfoOrderTaskInfo,
      period: 'number',
      runningTime: 'number',
      status: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowClusterAllResponseBodyClusters extends $tea.Model {
  clusterInfo?: ListFlowClusterAllResponseBodyClustersClusterInfo[];
  static names(): { [key: string]: string } {
    return {
      clusterInfo: 'ClusterInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterInfo: { 'type': 'array', 'itemType': ListFlowClusterAllResponseBodyClustersClusterInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowClusterAllHostsResponseBodyHostListHost extends $tea.Model {
  cpu?: number;
  hostId?: string;
  hostInstanceId?: string;
  hostName?: string;
  instanceType?: string;
  memory?: number;
  privateIp?: string;
  publicIp?: string;
  role?: string;
  serialNumber?: string;
  status?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      cpu: 'Cpu',
      hostId: 'HostId',
      hostInstanceId: 'HostInstanceId',
      hostName: 'HostName',
      instanceType: 'InstanceType',
      memory: 'Memory',
      privateIp: 'PrivateIp',
      publicIp: 'PublicIp',
      role: 'Role',
      serialNumber: 'SerialNumber',
      status: 'Status',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cpu: 'number',
      hostId: 'string',
      hostInstanceId: 'string',
      hostName: 'string',
      instanceType: 'string',
      memory: 'number',
      privateIp: 'string',
      publicIp: 'string',
      role: 'string',
      serialNumber: 'string',
      status: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowClusterAllHostsResponseBodyHostList extends $tea.Model {
  host?: ListFlowClusterAllHostsResponseBodyHostListHost[];
  static names(): { [key: string]: string } {
    return {
      host: 'Host',
    };
  }

  static types(): { [key: string]: any } {
    return {
      host: { 'type': 'array', 'itemType': ListFlowClusterAllHostsResponseBodyHostListHost },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowClusterHostResponseBodyHostListHost extends $tea.Model {
  cpu?: number;
  hostId?: string;
  hostInstanceId?: string;
  hostName?: string;
  instanceType?: string;
  memory?: number;
  privateIp?: string;
  publicIp?: string;
  role?: string;
  serialNumber?: string;
  status?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      cpu: 'Cpu',
      hostId: 'HostId',
      hostInstanceId: 'HostInstanceId',
      hostName: 'HostName',
      instanceType: 'InstanceType',
      memory: 'Memory',
      privateIp: 'PrivateIp',
      publicIp: 'PublicIp',
      role: 'Role',
      serialNumber: 'SerialNumber',
      status: 'Status',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cpu: 'number',
      hostId: 'string',
      hostInstanceId: 'string',
      hostName: 'string',
      instanceType: 'string',
      memory: 'number',
      privateIp: 'string',
      publicIp: 'string',
      role: 'string',
      serialNumber: 'string',
      status: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowClusterHostResponseBodyHostList extends $tea.Model {
  host?: ListFlowClusterHostResponseBodyHostListHost[];
  static names(): { [key: string]: string } {
    return {
      host: 'Host',
    };
  }

  static types(): { [key: string]: any } {
    return {
      host: { 'type': 'array', 'itemType': ListFlowClusterHostResponseBodyHostListHost },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowInstanceResponseBodyFlowInstancesFlowInstance extends $tea.Model {
  clusterId?: string;
  duration?: number;
  endTime?: number;
  flowId?: string;
  flowName?: string;
  gmtCreate?: number;
  gmtModified?: number;
  hasNodeFailed?: boolean;
  id?: string;
  owner?: string;
  projectId?: string;
  scheduleTime?: number;
  startTime?: number;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      duration: 'Duration',
      endTime: 'EndTime',
      flowId: 'FlowId',
      flowName: 'FlowName',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      hasNodeFailed: 'HasNodeFailed',
      id: 'Id',
      owner: 'Owner',
      projectId: 'ProjectId',
      scheduleTime: 'ScheduleTime',
      startTime: 'StartTime',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      duration: 'number',
      endTime: 'number',
      flowId: 'string',
      flowName: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      hasNodeFailed: 'boolean',
      id: 'string',
      owner: 'string',
      projectId: 'string',
      scheduleTime: 'number',
      startTime: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowInstanceResponseBodyFlowInstances extends $tea.Model {
  flowInstance?: ListFlowInstanceResponseBodyFlowInstancesFlowInstance[];
  static names(): { [key: string]: string } {
    return {
      flowInstance: 'FlowInstance',
    };
  }

  static types(): { [key: string]: any } {
    return {
      flowInstance: { 'type': 'array', 'itemType': ListFlowInstanceResponseBodyFlowInstancesFlowInstance },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowJobResponseBodyJobListJobResourceListResource extends $tea.Model {
  alias?: string;
  path?: string;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      path: 'Path',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      path: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowJobResponseBodyJobListJobResourceList extends $tea.Model {
  resource?: ListFlowJobResponseBodyJobListJobResourceListResource[];
  static names(): { [key: string]: string } {
    return {
      resource: 'Resource',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resource: { 'type': 'array', 'itemType': ListFlowJobResponseBodyJobListJobResourceListResource },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowJobResponseBodyJobListJob extends $tea.Model {
  adhoc?: string;
  alertConf?: string;
  categoryId?: string;
  customVariables?: string;
  description?: string;
  envConf?: string;
  failAct?: string;
  gmtCreate?: number;
  gmtModified?: number;
  id?: string;
  lastInstanceDetail?: string;
  maxRetry?: number;
  monitorConf?: string;
  name?: string;
  paramConf?: string;
  params?: string;
  resourceList?: ListFlowJobResponseBodyJobListJobResourceList;
  retryInterval?: number;
  runConf?: string;
  type?: string;
  mode?: string;
  static names(): { [key: string]: string } {
    return {
      adhoc: 'Adhoc',
      alertConf: 'AlertConf',
      categoryId: 'CategoryId',
      customVariables: 'CustomVariables',
      description: 'Description',
      envConf: 'EnvConf',
      failAct: 'FailAct',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      id: 'Id',
      lastInstanceDetail: 'LastInstanceDetail',
      maxRetry: 'MaxRetry',
      monitorConf: 'MonitorConf',
      name: 'Name',
      paramConf: 'ParamConf',
      params: 'Params',
      resourceList: 'ResourceList',
      retryInterval: 'RetryInterval',
      runConf: 'RunConf',
      type: 'Type',
      mode: 'mode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adhoc: 'string',
      alertConf: 'string',
      categoryId: 'string',
      customVariables: 'string',
      description: 'string',
      envConf: 'string',
      failAct: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      id: 'string',
      lastInstanceDetail: 'string',
      maxRetry: 'number',
      monitorConf: 'string',
      name: 'string',
      paramConf: 'string',
      params: 'string',
      resourceList: ListFlowJobResponseBodyJobListJobResourceList,
      retryInterval: 'number',
      runConf: 'string',
      type: 'string',
      mode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowJobResponseBodyJobList extends $tea.Model {
  job?: ListFlowJobResponseBodyJobListJob[];
  static names(): { [key: string]: string } {
    return {
      job: 'Job',
    };
  }

  static types(): { [key: string]: any } {
    return {
      job: { 'type': 'array', 'itemType': ListFlowJobResponseBodyJobListJob },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowJobHistoryResponseBodyNodeInstancesNodeInstance extends $tea.Model {
  clusterId?: string;
  endTime?: number;
  envConf?: string;
  externalId?: string;
  externalInfo?: string;
  externalStatus?: string;
  failAct?: string;
  gmtCreate?: number;
  gmtModified?: number;
  hostName?: string;
  id?: string;
  jobId?: string;
  jobName?: string;
  jobParams?: string;
  jobType?: string;
  maxRetry?: number;
  nodeName?: string;
  paramConf?: string;
  projectId?: string;
  retries?: number;
  retryInterval?: number;
  runConf?: string;
  startTime?: number;
  status?: string;
  type?: string;
  pending?: boolean;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      endTime: 'EndTime',
      envConf: 'EnvConf',
      externalId: 'ExternalId',
      externalInfo: 'ExternalInfo',
      externalStatus: 'ExternalStatus',
      failAct: 'FailAct',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      hostName: 'HostName',
      id: 'Id',
      jobId: 'JobId',
      jobName: 'JobName',
      jobParams: 'JobParams',
      jobType: 'JobType',
      maxRetry: 'MaxRetry',
      nodeName: 'NodeName',
      paramConf: 'ParamConf',
      projectId: 'ProjectId',
      retries: 'Retries',
      retryInterval: 'RetryInterval',
      runConf: 'RunConf',
      startTime: 'StartTime',
      status: 'Status',
      type: 'Type',
      pending: 'pending',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      endTime: 'number',
      envConf: 'string',
      externalId: 'string',
      externalInfo: 'string',
      externalStatus: 'string',
      failAct: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      hostName: 'string',
      id: 'string',
      jobId: 'string',
      jobName: 'string',
      jobParams: 'string',
      jobType: 'string',
      maxRetry: 'number',
      nodeName: 'string',
      paramConf: 'string',
      projectId: 'string',
      retries: 'number',
      retryInterval: 'number',
      runConf: 'string',
      startTime: 'number',
      status: 'string',
      type: 'string',
      pending: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowJobHistoryResponseBodyNodeInstances extends $tea.Model {
  nodeInstance?: ListFlowJobHistoryResponseBodyNodeInstancesNodeInstance[];
  static names(): { [key: string]: string } {
    return {
      nodeInstance: 'NodeInstance',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeInstance: { 'type': 'array', 'itemType': ListFlowJobHistoryResponseBodyNodeInstancesNodeInstance },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowNodeInstanceResponseBodyFlowNodeInstancesFlowNodeInstance extends $tea.Model {
  clusterId?: string;
  duration?: number;
  endTime?: number;
  externalChildIds?: string;
  externalId?: string;
  externalInfo?: string;
  externalStatus?: string;
  externalSubId?: string;
  failAct?: string;
  flowId?: string;
  flowInstanceId?: string;
  gmtCreate?: number;
  gmtModified?: number;
  hostName?: string;
  id?: string;
  jobId?: string;
  jobName?: string;
  jobParams?: string;
  jobType?: string;
  maxRetry?: string;
  nodeName?: string;
  pending?: boolean;
  projectId?: string;
  retries?: number;
  retryInterval?: string;
  startTime?: number;
  status?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      duration: 'Duration',
      endTime: 'EndTime',
      externalChildIds: 'ExternalChildIds',
      externalId: 'ExternalId',
      externalInfo: 'ExternalInfo',
      externalStatus: 'ExternalStatus',
      externalSubId: 'ExternalSubId',
      failAct: 'FailAct',
      flowId: 'FlowId',
      flowInstanceId: 'FlowInstanceId',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      hostName: 'HostName',
      id: 'Id',
      jobId: 'JobId',
      jobName: 'JobName',
      jobParams: 'JobParams',
      jobType: 'JobType',
      maxRetry: 'MaxRetry',
      nodeName: 'NodeName',
      pending: 'Pending',
      projectId: 'ProjectId',
      retries: 'Retries',
      retryInterval: 'RetryInterval',
      startTime: 'StartTime',
      status: 'Status',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      duration: 'number',
      endTime: 'number',
      externalChildIds: 'string',
      externalId: 'string',
      externalInfo: 'string',
      externalStatus: 'string',
      externalSubId: 'string',
      failAct: 'string',
      flowId: 'string',
      flowInstanceId: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      hostName: 'string',
      id: 'string',
      jobId: 'string',
      jobName: 'string',
      jobParams: 'string',
      jobType: 'string',
      maxRetry: 'string',
      nodeName: 'string',
      pending: 'boolean',
      projectId: 'string',
      retries: 'number',
      retryInterval: 'string',
      startTime: 'number',
      status: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowNodeInstanceResponseBodyFlowNodeInstances extends $tea.Model {
  flowNodeInstance?: ListFlowNodeInstanceResponseBodyFlowNodeInstancesFlowNodeInstance[];
  static names(): { [key: string]: string } {
    return {
      flowNodeInstance: 'FlowNodeInstance',
    };
  }

  static types(): { [key: string]: any } {
    return {
      flowNodeInstance: { 'type': 'array', 'itemType': ListFlowNodeInstanceResponseBodyFlowNodeInstancesFlowNodeInstance },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowNodeInstanceContainerStatusResponseBodyContainerStatusListContainerStatus extends $tea.Model {
  applicationId?: string;
  containerId?: string;
  hostName?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      applicationId: 'ApplicationId',
      containerId: 'ContainerId',
      hostName: 'HostName',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applicationId: 'string',
      containerId: 'string',
      hostName: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowNodeInstanceContainerStatusResponseBodyContainerStatusList extends $tea.Model {
  containerStatus?: ListFlowNodeInstanceContainerStatusResponseBodyContainerStatusListContainerStatus[];
  static names(): { [key: string]: string } {
    return {
      containerStatus: 'ContainerStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      containerStatus: { 'type': 'array', 'itemType': ListFlowNodeInstanceContainerStatusResponseBodyContainerStatusListContainerStatus },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowNodeSqlResultResponseBodyHeaderList extends $tea.Model {
  header?: string[];
  static names(): { [key: string]: string } {
    return {
      header: 'Header',
    };
  }

  static types(): { [key: string]: any } {
    return {
      header: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowNodeSqlResultResponseBodyRowListRowRowItemList extends $tea.Model {
  rowItem?: string[];
  static names(): { [key: string]: string } {
    return {
      rowItem: 'rowItem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      rowItem: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowNodeSqlResultResponseBodyRowListRow extends $tea.Model {
  rowIndex?: number;
  rowItemList?: ListFlowNodeSqlResultResponseBodyRowListRowRowItemList;
  static names(): { [key: string]: string } {
    return {
      rowIndex: 'RowIndex',
      rowItemList: 'RowItemList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      rowIndex: 'number',
      rowItemList: ListFlowNodeSqlResultResponseBodyRowListRowRowItemList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowNodeSqlResultResponseBodyRowList extends $tea.Model {
  row?: ListFlowNodeSqlResultResponseBodyRowListRow[];
  static names(): { [key: string]: string } {
    return {
      row: 'Row',
    };
  }

  static types(): { [key: string]: any } {
    return {
      row: { 'type': 'array', 'itemType': ListFlowNodeSqlResultResponseBodyRowListRow },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowProjectResponseBodyProjectsProject extends $tea.Model {
  description?: string;
  gmtCreate?: number;
  gmtModified?: number;
  id?: string;
  name?: string;
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      id: 'Id',
      name: 'Name',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      id: 'string',
      name: 'string',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowProjectResponseBodyProjects extends $tea.Model {
  project?: ListFlowProjectResponseBodyProjectsProject[];
  static names(): { [key: string]: string } {
    return {
      project: 'Project',
    };
  }

  static types(): { [key: string]: any } {
    return {
      project: { 'type': 'array', 'itemType': ListFlowProjectResponseBodyProjectsProject },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSettingHostList extends $tea.Model {
  host?: string[];
  static names(): { [key: string]: string } {
    return {
      host: 'Host',
    };
  }

  static types(): { [key: string]: any } {
    return {
      host: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSettingQueueList extends $tea.Model {
  queue?: string[];
  static names(): { [key: string]: string } {
    return {
      queue: 'Queue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      queue: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSettingUserList extends $tea.Model {
  user?: string[];
  static names(): { [key: string]: string } {
    return {
      user: 'User',
    };
  }

  static types(): { [key: string]: any } {
    return {
      user: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSetting extends $tea.Model {
  clusterId?: string;
  clusterName?: string;
  defaultQueue?: string;
  defaultUser?: string;
  gmtCreate?: number;
  gmtModified?: number;
  hostList?: ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSettingHostList;
  k8sClusterId?: string;
  projectId?: string;
  queueList?: ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSettingQueueList;
  userList?: ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSettingUserList;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      clusterName: 'ClusterName',
      defaultQueue: 'DefaultQueue',
      defaultUser: 'DefaultUser',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      hostList: 'HostList',
      k8sClusterId: 'K8sClusterId',
      projectId: 'ProjectId',
      queueList: 'QueueList',
      userList: 'UserList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      clusterName: 'string',
      defaultQueue: 'string',
      defaultUser: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      hostList: ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSettingHostList,
      k8sClusterId: 'string',
      projectId: 'string',
      queueList: ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSettingQueueList,
      userList: ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSettingUserList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowProjectClusterSettingResponseBodyClusterSettings extends $tea.Model {
  clusterSetting?: ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSetting[];
  static names(): { [key: string]: string } {
    return {
      clusterSetting: 'ClusterSetting',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterSetting: { 'type': 'array', 'itemType': ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSetting },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowProjectUserResponseBodyUsersUser extends $tea.Model {
  accountUserId?: string;
  gmtCreate?: number;
  gmtModified?: number;
  ownerId?: string;
  projectId?: string;
  userName?: string;
  static names(): { [key: string]: string } {
    return {
      accountUserId: 'AccountUserId',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      ownerId: 'OwnerId',
      projectId: 'ProjectId',
      userName: 'UserName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountUserId: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      ownerId: 'string',
      projectId: 'string',
      userName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFlowProjectUserResponseBodyUsers extends $tea.Model {
  user?: ListFlowProjectUserResponseBodyUsersUser[];
  static names(): { [key: string]: string } {
    return {
      user: 'User',
    };
  }

  static types(): { [key: string]: any } {
    return {
      user: { 'type': 'array', 'itemType': ListFlowProjectUserResponseBodyUsersUser },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobExecutionInstancesResponseBodyJobInstancesJobInstance extends $tea.Model {
  clusterId?: string;
  id?: string;
  jobId?: string;
  jobName?: string;
  jobType?: string;
  retryInfo?: string;
  runTime?: number;
  startTime?: number;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      id: 'Id',
      jobId: 'JobId',
      jobName: 'JobName',
      jobType: 'JobType',
      retryInfo: 'RetryInfo',
      runTime: 'RunTime',
      startTime: 'StartTime',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      id: 'string',
      jobId: 'string',
      jobName: 'string',
      jobType: 'string',
      retryInfo: 'string',
      runTime: 'number',
      startTime: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobExecutionInstancesResponseBodyJobInstances extends $tea.Model {
  jobInstance?: ListJobExecutionInstancesResponseBodyJobInstancesJobInstance[];
  static names(): { [key: string]: string } {
    return {
      jobInstance: 'JobInstance',
    };
  }

  static types(): { [key: string]: any } {
    return {
      jobInstance: { 'type': 'array', 'itemType': ListJobExecutionInstancesResponseBodyJobInstancesJobInstance },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobsResponseBodyJobsJobInfo extends $tea.Model {
  failAct?: string;
  id?: string;
  maxRetry?: number;
  name?: string;
  retryInterval?: number;
  runParameter?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      failAct: 'FailAct',
      id: 'Id',
      maxRetry: 'MaxRetry',
      name: 'Name',
      retryInterval: 'RetryInterval',
      runParameter: 'RunParameter',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failAct: 'string',
      id: 'string',
      maxRetry: 'number',
      name: 'string',
      retryInterval: 'number',
      runParameter: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListJobsResponseBodyJobs extends $tea.Model {
  jobInfo?: ListJobsResponseBodyJobsJobInfo[];
  static names(): { [key: string]: string } {
    return {
      jobInfo: 'JobInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      jobInfo: { 'type': 'array', 'itemType': ListJobsResponseBodyJobsJobInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLibrariesResponseBodyItemsItem extends $tea.Model {
  bizId?: string;
  createTime?: number;
  libraryVersion?: string;
  name?: string;
  properties?: string;
  scope?: string;
  sourceLocation?: string;
  sourceType?: string;
  type?: string;
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      bizId: 'BizId',
      createTime: 'CreateTime',
      libraryVersion: 'LibraryVersion',
      name: 'Name',
      properties: 'Properties',
      scope: 'Scope',
      sourceLocation: 'SourceLocation',
      sourceType: 'SourceType',
      type: 'Type',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizId: 'string',
      createTime: 'number',
      libraryVersion: 'string',
      name: 'string',
      properties: 'string',
      scope: 'string',
      sourceLocation: 'string',
      sourceType: 'string',
      type: 'string',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLibrariesResponseBodyItems extends $tea.Model {
  item?: ListLibrariesResponseBodyItemsItem[];
  static names(): { [key: string]: string } {
    return {
      item: 'Item',
    };
  }

  static types(): { [key: string]: any } {
    return {
      item: { 'type': 'array', 'itemType': ListLibrariesResponseBodyItemsItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLibraryInstallTasksResponseBodyItemsItem extends $tea.Model {
  clusterBizId?: string;
  detail?: string;
  endTime?: number;
  executeTime?: number;
  hostname?: string;
  libraryBizId?: string;
  startTime?: number;
  taskGroupId?: string;
  taskId?: string;
  taskProcess?: number;
  taskStatus?: string;
  taskType?: string;
  static names(): { [key: string]: string } {
    return {
      clusterBizId: 'ClusterBizId',
      detail: 'Detail',
      endTime: 'EndTime',
      executeTime: 'ExecuteTime',
      hostname: 'Hostname',
      libraryBizId: 'LibraryBizId',
      startTime: 'StartTime',
      taskGroupId: 'TaskGroupId',
      taskId: 'TaskId',
      taskProcess: 'TaskProcess',
      taskStatus: 'TaskStatus',
      taskType: 'TaskType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterBizId: 'string',
      detail: 'string',
      endTime: 'number',
      executeTime: 'number',
      hostname: 'string',
      libraryBizId: 'string',
      startTime: 'number',
      taskGroupId: 'string',
      taskId: 'string',
      taskProcess: 'number',
      taskStatus: 'string',
      taskType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLibraryInstallTasksResponseBodyItems extends $tea.Model {
  item?: ListLibraryInstallTasksResponseBodyItemsItem[];
  static names(): { [key: string]: string } {
    return {
      item: 'Item',
    };
  }

  static types(): { [key: string]: any } {
    return {
      item: { 'type': 'array', 'itemType': ListLibraryInstallTasksResponseBodyItemsItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLibraryStatusResponseBodyItemsItem extends $tea.Model {
  clusterBizId?: string;
  clusterName?: string;
  libraryBizId?: string;
  libraryName?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      clusterBizId: 'ClusterBizId',
      clusterName: 'ClusterName',
      libraryBizId: 'LibraryBizId',
      libraryName: 'LibraryName',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterBizId: 'string',
      clusterName: 'string',
      libraryBizId: 'string',
      libraryName: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLibraryStatusResponseBodyItems extends $tea.Model {
  item?: ListLibraryStatusResponseBodyItemsItem[];
  static names(): { [key: string]: string } {
    return {
      item: 'Item',
    };
  }

  static types(): { [key: string]: any } {
    return {
      item: { 'type': 'array', 'itemType': ListLibraryStatusResponseBodyItemsItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLocalDiskComponentInfoResponseBodyComponentInfoListComponentInfoApmMetrics extends $tea.Model {
  apmMetric?: string[];
  static names(): { [key: string]: string } {
    return {
      apmMetric: 'ApmMetric',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apmMetric: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLocalDiskComponentInfoResponseBodyComponentInfoListComponentInfoMountParamsMountParamOptions extends $tea.Model {
  option?: string[];
  static names(): { [key: string]: string } {
    return {
      option: 'Option',
    };
  }

  static types(): { [key: string]: any } {
    return {
      option: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLocalDiskComponentInfoResponseBodyComponentInfoListComponentInfoMountParamsMountParam extends $tea.Model {
  defaultValue?: string;
  key?: string;
  max?: number;
  min?: number;
  name?: string;
  options?: ListLocalDiskComponentInfoResponseBodyComponentInfoListComponentInfoMountParamsMountParamOptions;
  tips?: string;
  unit?: string;
  valueType?: string;
  static names(): { [key: string]: string } {
    return {
      defaultValue: 'DefaultValue',
      key: 'Key',
      max: 'Max',
      min: 'Min',
      name: 'Name',
      options: 'Options',
      tips: 'Tips',
      unit: 'Unit',
      valueType: 'ValueType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      defaultValue: 'string',
      key: 'string',
      max: 'number',
      min: 'number',
      name: 'string',
      options: ListLocalDiskComponentInfoResponseBodyComponentInfoListComponentInfoMountParamsMountParamOptions,
      tips: 'string',
      unit: 'string',
      valueType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLocalDiskComponentInfoResponseBodyComponentInfoListComponentInfoMountParams extends $tea.Model {
  mountParam?: ListLocalDiskComponentInfoResponseBodyComponentInfoListComponentInfoMountParamsMountParam[];
  static names(): { [key: string]: string } {
    return {
      mountParam: 'MountParam',
    };
  }

  static types(): { [key: string]: any } {
    return {
      mountParam: { 'type': 'array', 'itemType': ListLocalDiskComponentInfoResponseBodyComponentInfoListComponentInfoMountParamsMountParam },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLocalDiskComponentInfoResponseBodyComponentInfoListComponentInfo extends $tea.Model {
  apmMetrics?: ListLocalDiskComponentInfoResponseBodyComponentInfoListComponentInfoApmMetrics;
  componentDisplayName?: string;
  componentName?: string;
  isolateWarningMsg?: string;
  mountParams?: ListLocalDiskComponentInfoResponseBodyComponentInfoListComponentInfoMountParams;
  mountWarningMsg?: string;
  rebootWarningMsg?: string;
  serviceDisplayName?: string;
  serviceName?: string;
  supportDiskHotSwap?: boolean;
  static names(): { [key: string]: string } {
    return {
      apmMetrics: 'ApmMetrics',
      componentDisplayName: 'ComponentDisplayName',
      componentName: 'ComponentName',
      isolateWarningMsg: 'IsolateWarningMsg',
      mountParams: 'MountParams',
      mountWarningMsg: 'MountWarningMsg',
      rebootWarningMsg: 'RebootWarningMsg',
      serviceDisplayName: 'ServiceDisplayName',
      serviceName: 'ServiceName',
      supportDiskHotSwap: 'SupportDiskHotSwap',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apmMetrics: ListLocalDiskComponentInfoResponseBodyComponentInfoListComponentInfoApmMetrics,
      componentDisplayName: 'string',
      componentName: 'string',
      isolateWarningMsg: 'string',
      mountParams: ListLocalDiskComponentInfoResponseBodyComponentInfoListComponentInfoMountParams,
      mountWarningMsg: 'string',
      rebootWarningMsg: 'string',
      serviceDisplayName: 'string',
      serviceName: 'string',
      supportDiskHotSwap: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLocalDiskComponentInfoResponseBodyComponentInfoList extends $tea.Model {
  componentInfo?: ListLocalDiskComponentInfoResponseBodyComponentInfoListComponentInfo[];
  static names(): { [key: string]: string } {
    return {
      componentInfo: 'ComponentInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      componentInfo: { 'type': 'array', 'itemType': ListLocalDiskComponentInfoResponseBodyComponentInfoListComponentInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListResourcePoolResponseBodyPoolInfoListPoolInfoEcmResourcePool extends $tea.Model {
  active?: boolean;
  id?: number;
  name?: string;
  note?: string;
  poolType?: string;
  userId?: string;
  yarnSiteConfig?: string;
  static names(): { [key: string]: string } {
    return {
      active: 'Active',
      id: 'Id',
      name: 'Name',
      note: 'Note',
      poolType: 'PoolType',
      userId: 'UserId',
      yarnSiteConfig: 'YarnSiteConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      active: 'boolean',
      id: 'number',
      name: 'string',
      note: 'string',
      poolType: 'string',
      userId: 'string',
      yarnSiteConfig: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListResourcePoolResponseBodyPoolInfoListPoolInfoEcmResourcePoolConfigListEcmResourcePoolConfig extends $tea.Model {
  category?: string;
  configKey?: string;
  configType?: string;
  configValue?: string;
  id?: number;
  note?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      configKey: 'ConfigKey',
      configType: 'ConfigType',
      configValue: 'ConfigValue',
      id: 'Id',
      note: 'Note',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      configKey: 'string',
      configType: 'string',
      configValue: 'string',
      id: 'number',
      note: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListResourcePoolResponseBodyPoolInfoListPoolInfoEcmResourcePoolConfigList extends $tea.Model {
  ecmResourcePoolConfig?: ListResourcePoolResponseBodyPoolInfoListPoolInfoEcmResourcePoolConfigListEcmResourcePoolConfig[];
  static names(): { [key: string]: string } {
    return {
      ecmResourcePoolConfig: 'EcmResourcePoolConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ecmResourcePoolConfig: { 'type': 'array', 'itemType': ListResourcePoolResponseBodyPoolInfoListPoolInfoEcmResourcePoolConfigListEcmResourcePoolConfig },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListResourcePoolResponseBodyPoolInfoListPoolInfoQueueListQueueEcmResourcePoolConfigListEcmResourcePoolConfig extends $tea.Model {
  category?: string;
  configKey?: string;
  configType?: string;
  configValue?: string;
  id?: number;
  note?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      configKey: 'ConfigKey',
      configType: 'ConfigType',
      configValue: 'ConfigValue',
      id: 'Id',
      note: 'Note',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      configKey: 'string',
      configType: 'string',
      configValue: 'string',
      id: 'number',
      note: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListResourcePoolResponseBodyPoolInfoListPoolInfoQueueListQueueEcmResourcePoolConfigList extends $tea.Model {
  ecmResourcePoolConfig?: ListResourcePoolResponseBodyPoolInfoListPoolInfoQueueListQueueEcmResourcePoolConfigListEcmResourcePoolConfig[];
  static names(): { [key: string]: string } {
    return {
      ecmResourcePoolConfig: 'EcmResourcePoolConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ecmResourcePoolConfig: { 'type': 'array', 'itemType': ListResourcePoolResponseBodyPoolInfoListPoolInfoQueueListQueueEcmResourcePoolConfigListEcmResourcePoolConfig },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListResourcePoolResponseBodyPoolInfoListPoolInfoQueueListQueueEcmResourceQueue extends $tea.Model {
  id?: number;
  leaf?: boolean;
  name?: string;
  parentQueueId?: number;
  qualifiedName?: string;
  queueType?: string;
  resourcePoolId?: number;
  status?: string;
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      leaf: 'Leaf',
      name: 'Name',
      parentQueueId: 'ParentQueueId',
      qualifiedName: 'QualifiedName',
      queueType: 'QueueType',
      resourcePoolId: 'ResourcePoolId',
      status: 'Status',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      leaf: 'boolean',
      name: 'string',
      parentQueueId: 'number',
      qualifiedName: 'string',
      queueType: 'string',
      resourcePoolId: 'number',
      status: 'string',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListResourcePoolResponseBodyPoolInfoListPoolInfoQueueListQueue extends $tea.Model {
  ecmResourcePoolConfigList?: ListResourcePoolResponseBodyPoolInfoListPoolInfoQueueListQueueEcmResourcePoolConfigList;
  ecmResourceQueue?: ListResourcePoolResponseBodyPoolInfoListPoolInfoQueueListQueueEcmResourceQueue;
  static names(): { [key: string]: string } {
    return {
      ecmResourcePoolConfigList: 'EcmResourcePoolConfigList',
      ecmResourceQueue: 'EcmResourceQueue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ecmResourcePoolConfigList: ListResourcePoolResponseBodyPoolInfoListPoolInfoQueueListQueueEcmResourcePoolConfigList,
      ecmResourceQueue: ListResourcePoolResponseBodyPoolInfoListPoolInfoQueueListQueueEcmResourceQueue,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListResourcePoolResponseBodyPoolInfoListPoolInfoQueueList extends $tea.Model {
  queue?: ListResourcePoolResponseBodyPoolInfoListPoolInfoQueueListQueue[];
  static names(): { [key: string]: string } {
    return {
      queue: 'Queue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      queue: { 'type': 'array', 'itemType': ListResourcePoolResponseBodyPoolInfoListPoolInfoQueueListQueue },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListResourcePoolResponseBodyPoolInfoListPoolInfo extends $tea.Model {
  ecmResourcePool?: ListResourcePoolResponseBodyPoolInfoListPoolInfoEcmResourcePool;
  ecmResourcePoolConfigList?: ListResourcePoolResponseBodyPoolInfoListPoolInfoEcmResourcePoolConfigList;
  queueList?: ListResourcePoolResponseBodyPoolInfoListPoolInfoQueueList;
  static names(): { [key: string]: string } {
    return {
      ecmResourcePool: 'EcmResourcePool',
      ecmResourcePoolConfigList: 'EcmResourcePoolConfigList',
      queueList: 'QueueList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ecmResourcePool: ListResourcePoolResponseBodyPoolInfoListPoolInfoEcmResourcePool,
      ecmResourcePoolConfigList: ListResourcePoolResponseBodyPoolInfoListPoolInfoEcmResourcePoolConfigList,
      queueList: ListResourcePoolResponseBodyPoolInfoListPoolInfoQueueList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListResourcePoolResponseBodyPoolInfoList extends $tea.Model {
  poolInfo?: ListResourcePoolResponseBodyPoolInfoListPoolInfo[];
  static names(): { [key: string]: string } {
    return {
      poolInfo: 'PoolInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      poolInfo: { 'type': 'array', 'itemType': ListResourcePoolResponseBodyPoolInfoListPoolInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRolesResponseBodyDataRoleDTO extends $tea.Model {
  description?: string;
  gmtCreate?: string;
  gmtModified?: string;
  id?: number;
  name?: string;
  resourceType?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      id: 'Id',
      name: 'Name',
      resourceType: 'ResourceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      id: 'number',
      name: 'string',
      resourceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRolesResponseBodyData extends $tea.Model {
  roleDTO?: ListRolesResponseBodyDataRoleDTO[];
  static names(): { [key: string]: string } {
    return {
      roleDTO: 'roleDTO',
    };
  }

  static types(): { [key: string]: any } {
    return {
      roleDTO: { 'type': 'array', 'itemType': ListRolesResponseBodyDataRoleDTO },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListScalingActivityV2ResponseBodyItemsItem extends $tea.Model {
  bizId?: string;
  cause?: string;
  description?: string;
  endTime?: number;
  expectNum?: number;
  hostGroupBizId?: string;
  hostGroupName?: string;
  instanceIds?: string;
  scalingRuleId?: string;
  scalingRuleName?: string;
  startTime?: number;
  status?: string;
  totalCapacity?: number;
  transition?: string;
  static names(): { [key: string]: string } {
    return {
      bizId: 'BizId',
      cause: 'Cause',
      description: 'Description',
      endTime: 'EndTime',
      expectNum: 'ExpectNum',
      hostGroupBizId: 'HostGroupBizId',
      hostGroupName: 'HostGroupName',
      instanceIds: 'InstanceIds',
      scalingRuleId: 'ScalingRuleId',
      scalingRuleName: 'ScalingRuleName',
      startTime: 'StartTime',
      status: 'Status',
      totalCapacity: 'TotalCapacity',
      transition: 'Transition',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizId: 'string',
      cause: 'string',
      description: 'string',
      endTime: 'number',
      expectNum: 'number',
      hostGroupBizId: 'string',
      hostGroupName: 'string',
      instanceIds: 'string',
      scalingRuleId: 'string',
      scalingRuleName: 'string',
      startTime: 'number',
      status: 'string',
      totalCapacity: 'number',
      transition: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListScalingActivityV2ResponseBodyItems extends $tea.Model {
  item?: ListScalingActivityV2ResponseBodyItemsItem[];
  static names(): { [key: string]: string } {
    return {
      item: 'Item',
    };
  }

  static types(): { [key: string]: any } {
    return {
      item: { 'type': 'array', 'itemType': ListScalingActivityV2ResponseBodyItemsItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListScalingConfigItemV2ResponseBodyItemsItem extends $tea.Model {
  configItemInformation?: string;
  configItemType?: string;
  scalingConfigItemBizId?: string;
  scalingGroupBizId?: string;
  static names(): { [key: string]: string } {
    return {
      configItemInformation: 'ConfigItemInformation',
      configItemType: 'ConfigItemType',
      scalingConfigItemBizId: 'ScalingConfigItemBizId',
      scalingGroupBizId: 'ScalingGroupBizId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configItemInformation: 'string',
      configItemType: 'string',
      scalingConfigItemBizId: 'string',
      scalingGroupBizId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListScalingConfigItemV2ResponseBodyItems extends $tea.Model {
  item?: ListScalingConfigItemV2ResponseBodyItemsItem[];
  static names(): { [key: string]: string } {
    return {
      item: 'Item',
    };
  }

  static types(): { [key: string]: any } {
    return {
      item: { 'type': 'array', 'itemType': ListScalingConfigItemV2ResponseBodyItemsItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListScalingGroupV2ResponseBodyItemsItem extends $tea.Model {
  activeStatus?: string;
  description?: string;
  hostGroupBizId?: string;
  name?: string;
  scalingGroupId?: string;
  scalingInMode?: string;
  scalingMaxSize?: number;
  scalingMinSize?: number;
  static names(): { [key: string]: string } {
    return {
      activeStatus: 'ActiveStatus',
      description: 'Description',
      hostGroupBizId: 'HostGroupBizId',
      name: 'Name',
      scalingGroupId: 'ScalingGroupId',
      scalingInMode: 'ScalingInMode',
      scalingMaxSize: 'ScalingMaxSize',
      scalingMinSize: 'ScalingMinSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      activeStatus: 'string',
      description: 'string',
      hostGroupBizId: 'string',
      name: 'string',
      scalingGroupId: 'string',
      scalingInMode: 'string',
      scalingMaxSize: 'number',
      scalingMinSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListScalingGroupV2ResponseBodyItems extends $tea.Model {
  item?: ListScalingGroupV2ResponseBodyItemsItem[];
  static names(): { [key: string]: string } {
    return {
      item: 'Item',
    };
  }

  static types(): { [key: string]: any } {
    return {
      item: { 'type': 'array', 'itemType': ListScalingGroupV2ResponseBodyItemsItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSecurityGroupResponseBodySecurityGroupListSecurityGroup extends $tea.Model {
  availableInstanceAmount?: number;
  creationTime?: string;
  description?: string;
  ecsCount?: number;
  securityGroupId?: string;
  securityGroupName?: string;
  securityGroupType?: string;
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      availableInstanceAmount: 'AvailableInstanceAmount',
      creationTime: 'CreationTime',
      description: 'Description',
      ecsCount: 'EcsCount',
      securityGroupId: 'SecurityGroupId',
      securityGroupName: 'SecurityGroupName',
      securityGroupType: 'SecurityGroupType',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      availableInstanceAmount: 'number',
      creationTime: 'string',
      description: 'string',
      ecsCount: 'number',
      securityGroupId: 'string',
      securityGroupName: 'string',
      securityGroupType: 'string',
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSecurityGroupResponseBodySecurityGroupList extends $tea.Model {
  securityGroup?: ListSecurityGroupResponseBodySecurityGroupListSecurityGroup[];
  static names(): { [key: string]: string } {
    return {
      securityGroup: 'SecurityGroup',
    };
  }

  static types(): { [key: string]: any } {
    return {
      securityGroup: { 'type': 'array', 'itemType': ListSecurityGroupResponseBodySecurityGroupListSecurityGroup },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListStackResponseBodyStackListStack extends $tea.Model {
  name?: string;
  status?: string;
  version?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      status: 'Status',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      status: 'string',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListStackResponseBodyStackList extends $tea.Model {
  stack?: ListStackResponseBodyStackListStack[];
  static names(): { [key: string]: string } {
    return {
      stack: 'Stack',
    };
  }

  static types(): { [key: string]: any } {
    return {
      stack: { 'type': 'array', 'itemType': ListStackResponseBodyStackListStack },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTagKeysResponseBodyKeys extends $tea.Model {
  key?: string[];
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTagResourcesRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTagResourcesResponseBodyTagResourcesTagResource extends $tea.Model {
  resourceId?: string;
  resourceType?: string;
  tagKey?: string;
  tagValue?: string;
  static names(): { [key: string]: string } {
    return {
      resourceId: 'ResourceId',
      resourceType: 'ResourceType',
      tagKey: 'TagKey',
      tagValue: 'TagValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceId: 'string',
      resourceType: 'string',
      tagKey: 'string',
      tagValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTagResourcesResponseBodyTagResources extends $tea.Model {
  tagResource?: ListTagResourcesResponseBodyTagResourcesTagResource[];
  static names(): { [key: string]: string } {
    return {
      tagResource: 'TagResource',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagResource: { 'type': 'array', 'itemType': ListTagResourcesResponseBodyTagResourcesTagResource },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTagValuesResponseBodyValues extends $tea.Model {
  value?: string[];
  static names(): { [key: string]: string } {
    return {
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      value: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUsersResponseBodyUserListUser extends $tea.Model {
  groupName?: string;
  k8sStatus?: string;
  kerberosStatus?: string;
  knoxStatus?: string;
  linuxStatus?: string;
  userId?: string;
  userName?: string;
  static names(): { [key: string]: string } {
    return {
      groupName: 'GroupName',
      k8sStatus: 'K8sStatus',
      kerberosStatus: 'KerberosStatus',
      knoxStatus: 'KnoxStatus',
      linuxStatus: 'LinuxStatus',
      userId: 'UserId',
      userName: 'UserName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupName: 'string',
      k8sStatus: 'string',
      kerberosStatus: 'string',
      knoxStatus: 'string',
      linuxStatus: 'string',
      userId: 'string',
      userName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUsersResponseBodyUserList extends $tea.Model {
  user?: ListUsersResponseBodyUserListUser[];
  static names(): { [key: string]: string } {
    return {
      user: 'User',
    };
  }

  static types(): { [key: string]: any } {
    return {
      user: { 'type': 'array', 'itemType': ListUsersResponseBodyUserListUser },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListVswitchResponseBodyVswitchListVswitch extends $tea.Model {
  availableIpAddressCount?: string;
  cidrBlock?: string;
  creationTime?: string;
  description?: string;
  isDefault?: boolean;
  resourceGroupId?: string;
  status?: string;
  vSwitchId?: string;
  vSwitchName?: string;
  vpcId?: string;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      availableIpAddressCount: 'AvailableIpAddressCount',
      cidrBlock: 'CidrBlock',
      creationTime: 'CreationTime',
      description: 'Description',
      isDefault: 'IsDefault',
      resourceGroupId: 'ResourceGroupId',
      status: 'Status',
      vSwitchId: 'VSwitchId',
      vSwitchName: 'VSwitchName',
      vpcId: 'VpcId',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      availableIpAddressCount: 'string',
      cidrBlock: 'string',
      creationTime: 'string',
      description: 'string',
      isDefault: 'boolean',
      resourceGroupId: 'string',
      status: 'string',
      vSwitchId: 'string',
      vSwitchName: 'string',
      vpcId: 'string',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListVswitchResponseBodyVswitchList extends $tea.Model {
  vswitch?: ListVswitchResponseBodyVswitchListVswitch[];
  static names(): { [key: string]: string } {
    return {
      vswitch: 'Vswitch',
    };
  }

  static types(): { [key: string]: any } {
    return {
      vswitch: { 'type': 'array', 'itemType': ListVswitchResponseBodyVswitchListVswitch },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyClusterBootstrapActionRequestBootstrapAction extends $tea.Model {
  arg?: string;
  executionFailStrategy?: string;
  executionMoment?: string;
  executionTarget?: string;
  name?: string;
  path?: string;
  static names(): { [key: string]: string } {
    return {
      arg: 'Arg',
      executionFailStrategy: 'ExecutionFailStrategy',
      executionMoment: 'ExecutionMoment',
      executionTarget: 'ExecutionTarget',
      name: 'Name',
      path: 'Path',
    };
  }

  static types(): { [key: string]: any } {
    return {
      arg: 'string',
      executionFailStrategy: 'string',
      executionMoment: 'string',
      executionTarget: 'string',
      name: 'string',
      path: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyClusterTemplateRequestBootstrapAction extends $tea.Model {
  arg?: string;
  executionFailStrategy?: string;
  executionMoment?: string;
  executionTarget?: string;
  name?: string;
  path?: string;
  static names(): { [key: string]: string } {
    return {
      arg: 'Arg',
      executionFailStrategy: 'ExecutionFailStrategy',
      executionMoment: 'ExecutionMoment',
      executionTarget: 'ExecutionTarget',
      name: 'Name',
      path: 'Path',
    };
  }

  static types(): { [key: string]: any } {
    return {
      arg: 'string',
      executionFailStrategy: 'string',
      executionMoment: 'string',
      executionTarget: 'string',
      name: 'string',
      path: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyClusterTemplateRequestConfig extends $tea.Model {
  configKey?: string;
  configValue?: string;
  encrypt?: string;
  fileName?: string;
  replace?: string;
  serviceName?: string;
  static names(): { [key: string]: string } {
    return {
      configKey: 'ConfigKey',
      configValue: 'ConfigValue',
      encrypt: 'Encrypt',
      fileName: 'FileName',
      replace: 'Replace',
      serviceName: 'ServiceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configKey: 'string',
      configValue: 'string',
      encrypt: 'string',
      fileName: 'string',
      replace: 'string',
      serviceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyClusterTemplateRequestHostGroup extends $tea.Model {
  autoRenew?: boolean;
  chargeType?: string;
  clusterId?: string;
  comment?: string;
  createType?: string;
  diskCapacity?: number;
  diskCount?: number;
  diskType?: string;
  hostGroupId?: string;
  hostGroupName?: string;
  hostGroupType?: string;
  instanceType?: string;
  multiInstanceTypes?: string;
  nodeCount?: number;
  period?: number;
  sysDiskCapacity?: number;
  sysDiskType?: string;
  vSwitchId?: string;
  static names(): { [key: string]: string } {
    return {
      autoRenew: 'AutoRenew',
      chargeType: 'ChargeType',
      clusterId: 'ClusterId',
      comment: 'Comment',
      createType: 'CreateType',
      diskCapacity: 'DiskCapacity',
      diskCount: 'DiskCount',
      diskType: 'DiskType',
      hostGroupId: 'HostGroupId',
      hostGroupName: 'HostGroupName',
      hostGroupType: 'HostGroupType',
      instanceType: 'InstanceType',
      multiInstanceTypes: 'MultiInstanceTypes',
      nodeCount: 'NodeCount',
      period: 'Period',
      sysDiskCapacity: 'SysDiskCapacity',
      sysDiskType: 'SysDiskType',
      vSwitchId: 'VSwitchId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoRenew: 'boolean',
      chargeType: 'string',
      clusterId: 'string',
      comment: 'string',
      createType: 'string',
      diskCapacity: 'number',
      diskCount: 'number',
      diskType: 'string',
      hostGroupId: 'string',
      hostGroupName: 'string',
      hostGroupType: 'string',
      instanceType: 'string',
      multiInstanceTypes: 'string',
      nodeCount: 'number',
      period: 'number',
      sysDiskCapacity: 'number',
      sysDiskType: 'string',
      vSwitchId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyClusterTemplateRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyExecutionPlanRequestBootstrapAction extends $tea.Model {
  arg?: string;
  executionFailStrategy?: string;
  executionMoment?: string;
  executionTarget?: string;
  name?: string;
  path?: string;
  static names(): { [key: string]: string } {
    return {
      arg: 'Arg',
      executionFailStrategy: 'ExecutionFailStrategy',
      executionMoment: 'ExecutionMoment',
      executionTarget: 'ExecutionTarget',
      name: 'Name',
      path: 'Path',
    };
  }

  static types(): { [key: string]: any } {
    return {
      arg: 'string',
      executionFailStrategy: 'string',
      executionMoment: 'string',
      executionTarget: 'string',
      name: 'string',
      path: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyExecutionPlanRequestConfig extends $tea.Model {
  configKey?: string;
  configValue?: string;
  encrypt?: string;
  fileName?: string;
  replace?: string;
  serviceName?: string;
  static names(): { [key: string]: string } {
    return {
      configKey: 'ConfigKey',
      configValue: 'ConfigValue',
      encrypt: 'Encrypt',
      fileName: 'FileName',
      replace: 'Replace',
      serviceName: 'ServiceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configKey: 'string',
      configValue: 'string',
      encrypt: 'string',
      fileName: 'string',
      replace: 'string',
      serviceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyExecutionPlanRequestEcsOrder extends $tea.Model {
  diskCapacity?: number;
  diskCount?: number;
  diskType?: string;
  index?: number;
  instanceType?: string;
  nodeCount?: number;
  nodeType?: string;
  static names(): { [key: string]: string } {
    return {
      diskCapacity: 'DiskCapacity',
      diskCount: 'DiskCount',
      diskType: 'DiskType',
      index: 'Index',
      instanceType: 'InstanceType',
      nodeCount: 'NodeCount',
      nodeType: 'NodeType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      diskCapacity: 'number',
      diskCount: 'number',
      diskType: 'string',
      index: 'number',
      instanceType: 'string',
      nodeCount: 'number',
      nodeType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyFlowJobRequestResourceList extends $tea.Model {
  alias?: string;
  path?: string;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      path: 'Path',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      path: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyResourcePoolRequestConfig extends $tea.Model {
  category?: string;
  configKey?: string;
  configValue?: string;
  id?: string;
  note?: string;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      configKey: 'ConfigKey',
      configValue: 'ConfigValue',
      id: 'Id',
      note: 'Note',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      configKey: 'string',
      configValue: 'string',
      id: 'string',
      note: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyResourceQueueRequestConfig extends $tea.Model {
  category?: string;
  configKey?: string;
  configValue?: string;
  id?: number;
  note?: string;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      configKey: 'ConfigKey',
      configValue: 'ConfigValue',
      id: 'Id',
      note: 'Note',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      configKey: 'string',
      configValue: 'string',
      id: 'number',
      note: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyScalingRuleRequestCloudWatchTrigger extends $tea.Model {
  comparisonOperator?: string;
  evaluationCount?: string;
  metricName?: string;
  period?: number;
  statistics?: string;
  threshold?: string;
  static names(): { [key: string]: string } {
    return {
      comparisonOperator: 'ComparisonOperator',
      evaluationCount: 'EvaluationCount',
      metricName: 'MetricName',
      period: 'Period',
      statistics: 'Statistics',
      threshold: 'Threshold',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comparisonOperator: 'string',
      evaluationCount: 'string',
      metricName: 'string',
      period: 'number',
      statistics: 'string',
      threshold: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyScalingRuleRequestSchedulerTrigger extends $tea.Model {
  launchExpirationTime?: number;
  launchTime?: string;
  recurrenceEndTime?: string;
  recurrenceType?: string;
  recurrenceValue?: string;
  static names(): { [key: string]: string } {
    return {
      launchExpirationTime: 'LaunchExpirationTime',
      launchTime: 'LaunchTime',
      recurrenceEndTime: 'RecurrenceEndTime',
      recurrenceType: 'RecurrenceType',
      recurrenceValue: 'RecurrenceValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      launchExpirationTime: 'number',
      launchTime: 'string',
      recurrenceEndTime: 'string',
      recurrenceType: 'string',
      recurrenceValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEntityResponseBodyItemsItem extends $tea.Model {
  entityId?: string;
  entityType?: string;
  tagId?: number;
  static names(): { [key: string]: string } {
    return {
      entityId: 'EntityId',
      entityType: 'EntityType',
      tagId: 'TagId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      entityId: 'string',
      entityType: 'string',
      tagId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEntityResponseBodyItems extends $tea.Model {
  item?: QueryEntityResponseBodyItemsItem[];
  static names(): { [key: string]: string } {
    return {
      item: 'Item',
    };
  }

  static types(): { [key: string]: any } {
    return {
      item: { 'type': 'array', 'itemType': QueryEntityResponseBodyItemsItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTagResponseBodyItemsItem extends $tea.Model {
  category?: string;
  description?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      description: 'Description',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      description: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTagResponseBodyItems extends $tea.Model {
  item?: QueryTagResponseBodyItemsItem[];
  static names(): { [key: string]: string } {
    return {
      item: 'Item',
    };
  }

  static types(): { [key: string]: any } {
    return {
      item: { 'type': 'array', 'itemType': QueryTagResponseBodyItemsItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResizeClusterV2RequestHostComponentInfo extends $tea.Model {
  componentNameList?: string[];
  hostName?: string;
  serviceName?: string;
  static names(): { [key: string]: string } {
    return {
      componentNameList: 'ComponentNameList',
      hostName: 'HostName',
      serviceName: 'ServiceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      componentNameList: { 'type': 'array', 'itemType': 'string' },
      hostName: 'string',
      serviceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResizeClusterV2RequestHostGroup extends $tea.Model {
  autoRenew?: boolean;
  chargeType?: string;
  clusterId?: string;
  comment?: string;
  createType?: string;
  diskCapacity?: number;
  diskCount?: number;
  diskType?: string;
  hostGroupId?: string;
  hostGroupName?: string;
  hostGroupType?: string;
  hostKeyPairName?: string;
  hostPassword?: string;
  instanceType?: string;
  nodeCount?: number;
  period?: number;
  privatePoolOptionsId?: string;
  privatePoolOptionsMatchCriteria?: string;
  sysDiskCapacity?: number;
  sysDiskType?: string;
  vswitchId?: number;
  static names(): { [key: string]: string } {
    return {
      autoRenew: 'AutoRenew',
      chargeType: 'ChargeType',
      clusterId: 'ClusterId',
      comment: 'Comment',
      createType: 'CreateType',
      diskCapacity: 'DiskCapacity',
      diskCount: 'DiskCount',
      diskType: 'DiskType',
      hostGroupId: 'HostGroupId',
      hostGroupName: 'HostGroupName',
      hostGroupType: 'HostGroupType',
      hostKeyPairName: 'HostKeyPairName',
      hostPassword: 'HostPassword',
      instanceType: 'InstanceType',
      nodeCount: 'NodeCount',
      period: 'Period',
      privatePoolOptionsId: 'PrivatePoolOptionsId',
      privatePoolOptionsMatchCriteria: 'PrivatePoolOptionsMatchCriteria',
      sysDiskCapacity: 'SysDiskCapacity',
      sysDiskType: 'SysDiskType',
      vswitchId: 'VswitchId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoRenew: 'boolean',
      chargeType: 'string',
      clusterId: 'string',
      comment: 'string',
      createType: 'string',
      diskCapacity: 'number',
      diskCount: 'number',
      diskType: 'string',
      hostGroupId: 'string',
      hostGroupName: 'string',
      hostGroupType: 'string',
      hostKeyPairName: 'string',
      hostPassword: 'string',
      instanceType: 'string',
      nodeCount: 'number',
      period: 'number',
      privatePoolOptionsId: 'string',
      privatePoolOptionsMatchCriteria: 'string',
      sysDiskCapacity: 'number',
      sysDiskType: 'string',
      vswitchId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResizeClusterV2RequestPromotionInfo extends $tea.Model {
  productCode?: string;
  promotionOptionCode?: string;
  promotionOptionNo?: string;
  static names(): { [key: string]: string } {
    return {
      productCode: 'ProductCode',
      promotionOptionCode: 'PromotionOptionCode',
      promotionOptionNo: 'PromotionOptionNo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      productCode: 'string',
      promotionOptionCode: 'string',
      promotionOptionNo: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchLogResponseBodySlsLogItemListSlsLogItem extends $tea.Model {
  content?: string;
  hostName?: string;
  packId?: string;
  packMeta?: string;
  path?: string;
  sourceIp?: string;
  timestamp?: number;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      hostName: 'HostName',
      packId: 'PackId',
      packMeta: 'PackMeta',
      path: 'Path',
      sourceIp: 'SourceIp',
      timestamp: 'Timestamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      hostName: 'string',
      packId: 'string',
      packMeta: 'string',
      path: 'string',
      sourceIp: 'string',
      timestamp: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchLogResponseBodySlsLogItemList extends $tea.Model {
  slsLogItem?: SearchLogResponseBodySlsLogItemListSlsLogItem[];
  static names(): { [key: string]: string } {
    return {
      slsLogItem: 'SlsLogItem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      slsLogItem: { 'type': 'array', 'itemType': SearchLogResponseBodySlsLogItemListSlsLogItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TagResourcesRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateUserRequestUserAccountParamList extends $tea.Model {
  accountPassword?: string;
  accountType?: string;
  authType?: string;
  static names(): { [key: string]: string } {
    return {
      accountPassword: 'AccountPassword',
      accountType: 'AccountType',
      authType: 'AuthType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountPassword: 'string',
      accountType: 'string',
      authType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}


export default class Client extends OpenApi {

  constructor(config: $OpenApi.Config) {
    super(config);
    this._endpointRule = "regional";
    this._endpointMap = {
      'cn-beijing': "emr.aliyuncs.com",
      'cn-hangzhou': "emr.aliyuncs.com",
      'cn-shanghai': "emr.aliyuncs.com",
      'cn-shenzhen': "emr.aliyuncs.com",
      'ap-southeast-1': "emr.aliyuncs.com",
      'us-west-1': "emr.aliyuncs.com",
      'cn-hangzhou-finance': "emr.aliyuncs.com",
      'cn-shenzhen-finance-1': "emr.aliyuncs.com",
      'cn-shanghai-finance-1': "emr.aliyuncs.com",
    };
    this.checkConfig(config);
    this._endpoint = this.getEndpoint("emr", this._regionId, this._endpointRule, this._network, this._suffix, this._endpointMap, this._endpoint);
  }


  getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: {[key: string ]: string}, endpoint: string): string {
    if (!Util.empty(endpoint)) {
      return endpoint;
    }

    if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
      return endpointMap[regionId];
    }

    return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
  }

  async addClusterServiceWithOptions(request: AddClusterServiceRequest, runtime: $Util.RuntimeOptions): Promise<AddClusterServiceResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["Comment"] = request.comment;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["Service"] = request.service;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "AddClusterService",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<AddClusterServiceResponse>(await this.callApi(params, req, runtime), new AddClusterServiceResponse({}));
  }

  async addClusterService(request: AddClusterServiceRequest): Promise<AddClusterServiceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addClusterServiceWithOptions(request, runtime);
  }

  async addScalingConfigItemV2WithOptions(request: AddScalingConfigItemV2Request, runtime: $Util.RuntimeOptions): Promise<AddScalingConfigItemV2Response> {
    Util.validateModel(request);
    let query = { };
    query["ConfigItemInformation"] = request.configItemInformation;
    query["ConfigItemType"] = request.configItemType;
    query["RegionId"] = request.regionId;
    query["ResourceGroupId"] = request.resourceGroupId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["ScalingGroupBizId"] = request.scalingGroupBizId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "AddScalingConfigItemV2",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<AddScalingConfigItemV2Response>(await this.callApi(params, req, runtime), new AddScalingConfigItemV2Response({}));
  }

  async addScalingConfigItemV2(request: AddScalingConfigItemV2Request): Promise<AddScalingConfigItemV2Response> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addScalingConfigItemV2WithOptions(request, runtime);
  }

  async authorizeSecurityGroupWithOptions(request: AuthorizeSecurityGroupRequest, runtime: $Util.RuntimeOptions): Promise<AuthorizeSecurityGroupResponse> {
    Util.validateModel(request);
    let query = { };
    query["BizContent"] = request.bizContent;
    query["BizType"] = request.bizType;
    query["ClusterId"] = request.clusterId;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "AuthorizeSecurityGroup",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<AuthorizeSecurityGroupResponse>(await this.callApi(params, req, runtime), new AuthorizeSecurityGroupResponse({}));
  }

  async authorizeSecurityGroup(request: AuthorizeSecurityGroupRequest): Promise<AuthorizeSecurityGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.authorizeSecurityGroupWithOptions(request, runtime);
  }

  async cancelOrderWithOptions(request: CancelOrderRequest, runtime: $Util.RuntimeOptions): Promise<CancelOrderResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "CancelOrder",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CancelOrderResponse>(await this.callApi(params, req, runtime), new CancelOrderResponse({}));
  }

  async cancelOrder(request: CancelOrderRequest): Promise<CancelOrderResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.cancelOrderWithOptions(request, runtime);
  }

  async cloneFlowWithOptions(request: CloneFlowRequest, runtime: $Util.RuntimeOptions): Promise<CloneFlowResponse> {
    Util.validateModel(request);
    let query = { };
    query["Id"] = request.id;
    query["ProjectId"] = request.projectId;
    query["RegionId"] = request.regionId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "CloneFlow",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CloneFlowResponse>(await this.callApi(params, req, runtime), new CloneFlowResponse({}));
  }

  async cloneFlow(request: CloneFlowRequest): Promise<CloneFlowResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.cloneFlowWithOptions(request, runtime);
  }

  async cloneFlowJobWithOptions(request: CloneFlowJobRequest, runtime: $Util.RuntimeOptions): Promise<CloneFlowJobResponse> {
    Util.validateModel(request);
    let query = { };
    query["Id"] = request.id;
    query["Name"] = request.name;
    query["ProjectId"] = request.projectId;
    query["RegionId"] = request.regionId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "CloneFlowJob",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CloneFlowJobResponse>(await this.callApi(params, req, runtime), new CloneFlowJobResponse({}));
  }

  async cloneFlowJob(request: CloneFlowJobRequest): Promise<CloneFlowJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.cloneFlowJobWithOptions(request, runtime);
  }

  async createBackupWithOptions(request: CreateBackupRequest, runtime: $Util.RuntimeOptions): Promise<CreateBackupResponse> {
    Util.validateModel(request);
    let query = { };
    query["BackupPlanId"] = request.backupPlanId;
    query["MetadataType"] = request.metadataType;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "CreateBackup",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateBackupResponse>(await this.callApi(params, req, runtime), new CreateBackupResponse({}));
  }

  async createBackup(request: CreateBackupRequest): Promise<CreateBackupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createBackupWithOptions(request, runtime);
  }

  async createBackupPlanWithOptions(request: CreateBackupPlanRequest, runtime: $Util.RuntimeOptions): Promise<CreateBackupPlanResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["Description"] = request.description;
    query["Name"] = request.name;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["RootPath"] = request.rootPath;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "CreateBackupPlan",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateBackupPlanResponse>(await this.callApi(params, req, runtime), new CreateBackupPlanResponse({}));
  }

  async createBackupPlan(request: CreateBackupPlanRequest): Promise<CreateBackupPlanResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createBackupPlanWithOptions(request, runtime);
  }

  async createClusterBootstrapActionWithOptions(request: CreateClusterBootstrapActionRequest, runtime: $Util.RuntimeOptions): Promise<CreateClusterBootstrapActionResponse> {
    Util.validateModel(request);
    let query = { };
    query["BootstrapAction"] = request.bootstrapAction;
    query["ClusterId"] = request.clusterId;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "CreateClusterBootstrapAction",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateClusterBootstrapActionResponse>(await this.callApi(params, req, runtime), new CreateClusterBootstrapActionResponse({}));
  }

  async createClusterBootstrapAction(request: CreateClusterBootstrapActionRequest): Promise<CreateClusterBootstrapActionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createClusterBootstrapActionWithOptions(request, runtime);
  }

  async createClusterHostGroupWithOptions(request: CreateClusterHostGroupRequest, runtime: $Util.RuntimeOptions): Promise<CreateClusterHostGroupResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["Comment"] = request.comment;
    query["HostGroupName"] = request.hostGroupName;
    query["HostGroupParams"] = request.hostGroupParams;
    query["HostGroupType"] = request.hostGroupType;
    query["PayType"] = request.payType;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["SecurityGroupId"] = request.securityGroupId;
    query["VswitchId"] = request.vswitchId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "CreateClusterHostGroup",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateClusterHostGroupResponse>(await this.callApi(params, req, runtime), new CreateClusterHostGroupResponse({}));
  }

  async createClusterHostGroup(request: CreateClusterHostGroupRequest): Promise<CreateClusterHostGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createClusterHostGroupWithOptions(request, runtime);
  }

  async createClusterTemplateWithOptions(request: CreateClusterTemplateRequest, runtime: $Util.RuntimeOptions): Promise<CreateClusterTemplateResponse> {
    Util.validateModel(request);
    let query = { };
    query["AutoRenew"] = request.autoRenew;
    query["BootstrapAction"] = request.bootstrapAction;
    query["ClientToken"] = request.clientToken;
    query["ClusterType"] = request.clusterType;
    query["Config"] = request.config;
    query["Configurations"] = request.configurations;
    query["DepositType"] = request.depositType;
    query["EasEnable"] = request.easEnable;
    query["EmrVer"] = request.emrVer;
    query["HighAvailabilityEnable"] = request.highAvailabilityEnable;
    query["HostGroup"] = request.hostGroup;
    query["InitCustomHiveMetaDb"] = request.initCustomHiveMetaDb;
    query["InstanceGeneration"] = request.instanceGeneration;
    query["IoOptimized"] = request.ioOptimized;
    query["IsOpenPublicIp"] = request.isOpenPublicIp;
    query["KeyPairName"] = request.keyPairName;
    query["LogPath"] = request.logPath;
    query["MachineType"] = request.machineType;
    query["MasterPwd"] = request.masterPwd;
    query["MetaStoreConf"] = request.metaStoreConf;
    query["MetaStoreType"] = request.metaStoreType;
    query["NetType"] = request.netType;
    query["OptionSoftWareList"] = request.optionSoftWareList;
    query["Period"] = request.period;
    query["RegionId"] = request.regionId;
    query["ResourceGroupId"] = request.resourceGroupId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["SecurityGroupId"] = request.securityGroupId;
    query["SecurityGroupName"] = request.securityGroupName;
    query["SshEnable"] = request.sshEnable;
    query["Tag"] = request.tag;
    query["TemplateName"] = request.templateName;
    query["UseCustomHiveMetaDb"] = request.useCustomHiveMetaDb;
    query["UseLocalMetaDb"] = request.useLocalMetaDb;
    query["UserDefinedEmrEcsRole"] = request.userDefinedEmrEcsRole;
    query["VSwitchId"] = request.vSwitchId;
    query["VpcId"] = request.vpcId;
    query["ZoneId"] = request.zoneId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "CreateClusterTemplate",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateClusterTemplateResponse>(await this.callApi(params, req, runtime), new CreateClusterTemplateResponse({}));
  }

  async createClusterTemplate(request: CreateClusterTemplateRequest): Promise<CreateClusterTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createClusterTemplateWithOptions(request, runtime);
  }

  async createClusterV2WithOptions(request: CreateClusterV2Request, runtime: $Util.RuntimeOptions): Promise<CreateClusterV2Response> {
    Util.validateModel(request);
    let query = { };
    query["AuthorizeContent"] = request.authorizeContent;
    query["AutoPayOrder"] = request.autoPayOrder;
    query["AutoRenew"] = request.autoRenew;
    query["BootstrapAction"] = request.bootstrapAction;
    query["ChargeType"] = request.chargeType;
    query["ClickHouseConf"] = request.clickHouseConf;
    query["ClientToken"] = request.clientToken;
    query["ClusterType"] = request.clusterType;
    query["Config"] = request.config;
    query["Configurations"] = request.configurations;
    query["DepositType"] = request.depositType;
    query["EasEnable"] = request.easEnable;
    query["EmrVer"] = request.emrVer;
    query["ExtraAttributes"] = request.extraAttributes;
    query["HighAvailabilityEnable"] = request.highAvailabilityEnable;
    query["HostComponentInfo"] = request.hostComponentInfo;
    query["HostGroup"] = request.hostGroup;
    query["InitCustomHiveMetaDB"] = request.initCustomHiveMetaDB;
    query["InstanceGeneration"] = request.instanceGeneration;
    query["IoOptimized"] = request.ioOptimized;
    query["IsOpenPublicIp"] = request.isOpenPublicIp;
    query["KeyPairName"] = request.keyPairName;
    query["LogPath"] = request.logPath;
    query["MachineType"] = request.machineType;
    query["MasterPwd"] = request.masterPwd;
    query["MetaStoreConf"] = request.metaStoreConf;
    query["MetaStoreType"] = request.metaStoreType;
    query["Name"] = request.name;
    query["NetType"] = request.netType;
    query["OptionSoftWareList"] = request.optionSoftWareList;
    query["Period"] = request.period;
    query["PromotionInfo"] = request.promotionInfo;
    query["RegionId"] = request.regionId;
    query["RelatedClusterId"] = request.relatedClusterId;
    query["ResourceGroupId"] = request.resourceGroupId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["SecurityGroupId"] = request.securityGroupId;
    query["SecurityGroupName"] = request.securityGroupName;
    query["ServiceInfo"] = request.serviceInfo;
    query["SshEnable"] = request.sshEnable;
    query["Tag"] = request.tag;
    query["UseCustomHiveMetaDB"] = request.useCustomHiveMetaDB;
    query["UseLocalMetaDb"] = request.useLocalMetaDb;
    query["UserDefinedEmrEcsRole"] = request.userDefinedEmrEcsRole;
    query["UserInfo"] = request.userInfo;
    query["VSwitchId"] = request.vSwitchId;
    query["VpcId"] = request.vpcId;
    query["WhiteListType"] = request.whiteListType;
    query["ZoneId"] = request.zoneId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "CreateClusterV2",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateClusterV2Response>(await this.callApi(params, req, runtime), new CreateClusterV2Response({}));
  }

  async createClusterV2(request: CreateClusterV2Request): Promise<CreateClusterV2Response> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createClusterV2WithOptions(request, runtime);
  }

  async createClusterWithTemplateWithOptions(request: CreateClusterWithTemplateRequest, runtime: $Util.RuntimeOptions): Promise<CreateClusterWithTemplateResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterName"] = request.clusterName;
    query["ResourceGroupId"] = request.resourceGroupId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["TemplateBizId"] = request.templateBizId;
    query["UniqueTag"] = request.uniqueTag;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "CreateClusterWithTemplate",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateClusterWithTemplateResponse>(await this.callApi(params, req, runtime), new CreateClusterWithTemplateResponse({}));
  }

  async createClusterWithTemplate(request: CreateClusterWithTemplateRequest): Promise<CreateClusterWithTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createClusterWithTemplateWithOptions(request, runtime);
  }

  async createDataSourceWithOptions(request: CreateDataSourceRequest, runtime: $Util.RuntimeOptions): Promise<CreateDataSourceResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["Conf"] = request.conf;
    query["Description"] = request.description;
    query["Name"] = request.name;
    query["NavParentId"] = request.navParentId;
    query["RegionId"] = request.regionId;
    query["ResourceGroupId"] = request.resourceGroupId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["SourceType"] = request.sourceType;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "CreateDataSource",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateDataSourceResponse>(await this.callApi(params, req, runtime), new CreateDataSourceResponse({}));
  }

  async createDataSource(request: CreateDataSourceRequest): Promise<CreateDataSourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDataSourceWithOptions(request, runtime);
  }

  async createExecutionPlanWithOptions(request: CreateExecutionPlanRequest, runtime: $Util.RuntimeOptions): Promise<CreateExecutionPlanResponse> {
    Util.validateModel(request);
    let query = { };
    query["BootstrapAction"] = request.bootstrapAction;
    query["ClusterId"] = request.clusterId;
    query["ClusterName"] = request.clusterName;
    query["ClusterType"] = request.clusterType;
    query["Config"] = request.config;
    query["Configurations"] = request.configurations;
    query["CreateClusterOnDemand"] = request.createClusterOnDemand;
    query["DayOfMonth"] = request.dayOfMonth;
    query["DayOfWeek"] = request.dayOfWeek;
    query["EasEnable"] = request.easEnable;
    query["EcsOrder"] = request.ecsOrder;
    query["EmrVer"] = request.emrVer;
    query["HighAvailabilityEnable"] = request.highAvailabilityEnable;
    query["InitCustomHiveMetaDB"] = request.initCustomHiveMetaDB;
    query["InstanceGeneration"] = request.instanceGeneration;
    query["IoOptimized"] = request.ioOptimized;
    query["IsOpenPublicIp"] = request.isOpenPublicIp;
    query["JobIdList"] = request.jobIdList;
    query["LogEnable"] = request.logEnable;
    query["LogPath"] = request.logPath;
    query["Name"] = request.name;
    query["NetType"] = request.netType;
    query["OptionSoftWareList"] = request.optionSoftWareList;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["SecurityGroupId"] = request.securityGroupId;
    query["StartTime"] = request.startTime;
    query["Strategy"] = request.strategy;
    query["TimeInterval"] = request.timeInterval;
    query["TimeUnit"] = request.timeUnit;
    query["UseCustomHiveMetaDB"] = request.useCustomHiveMetaDB;
    query["UseLocalMetaDb"] = request.useLocalMetaDb;
    query["UserDefinedEmrEcsRole"] = request.userDefinedEmrEcsRole;
    query["VSwitchId"] = request.vSwitchId;
    query["VpcId"] = request.vpcId;
    query["WorkflowDefinition"] = request.workflowDefinition;
    query["ZoneId"] = request.zoneId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "CreateExecutionPlan",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateExecutionPlanResponse>(await this.callApi(params, req, runtime), new CreateExecutionPlanResponse({}));
  }

  async createExecutionPlan(request: CreateExecutionPlanRequest): Promise<CreateExecutionPlanResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createExecutionPlanWithOptions(request, runtime);
  }

  async createFlowWithOptions(request: CreateFlowRequest, runtime: $Util.RuntimeOptions): Promise<CreateFlowResponse> {
    Util.validateModel(request);
    let query = { };
    query["AlertConf"] = request.alertConf;
    query["AlertDingDingGroupBizId"] = request.alertDingDingGroupBizId;
    query["AlertUserGroupBizId"] = request.alertUserGroupBizId;
    query["Application"] = request.application;
    query["ClusterId"] = request.clusterId;
    query["CreateCluster"] = request.createCluster;
    query["CronExpr"] = request.cronExpr;
    query["Description"] = request.description;
    query["EndSchedule"] = request.endSchedule;
    query["HostName"] = request.hostName;
    query["Lifecycle"] = request.lifecycle;
    query["LogArchiveLocation"] = request.logArchiveLocation;
    query["Name"] = request.name;
    query["Namespace"] = request.namespace;
    query["ParentCategory"] = request.parentCategory;
    query["ParentFlowList"] = request.parentFlowList;
    query["ProjectId"] = request.projectId;
    query["RegionId"] = request.regionId;
    query["StartSchedule"] = request.startSchedule;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "CreateFlow",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateFlowResponse>(await this.callApi(params, req, runtime), new CreateFlowResponse({}));
  }

  async createFlow(request: CreateFlowRequest): Promise<CreateFlowResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createFlowWithOptions(request, runtime);
  }

  async createFlowCategoryWithOptions(request: CreateFlowCategoryRequest, runtime: $Util.RuntimeOptions): Promise<CreateFlowCategoryResponse> {
    Util.validateModel(request);
    let query = { };
    query["Name"] = request.name;
    query["ParentId"] = request.parentId;
    query["ProjectId"] = request.projectId;
    query["RegionId"] = request.regionId;
    query["Type"] = request.type;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "CreateFlowCategory",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateFlowCategoryResponse>(await this.callApi(params, req, runtime), new CreateFlowCategoryResponse({}));
  }

  async createFlowCategory(request: CreateFlowCategoryRequest): Promise<CreateFlowCategoryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createFlowCategoryWithOptions(request, runtime);
  }

  async createFlowForWebWithOptions(request: CreateFlowForWebRequest, runtime: $Util.RuntimeOptions): Promise<CreateFlowForWebResponse> {
    Util.validateModel(request);
    let query = { };
    query["AlertConf"] = request.alertConf;
    query["AlertDingDingGroupBizId"] = request.alertDingDingGroupBizId;
    query["AlertUserGroupBizId"] = request.alertUserGroupBizId;
    query["ClusterId"] = request.clusterId;
    query["CreateCluster"] = request.createCluster;
    query["CronExpr"] = request.cronExpr;
    query["Description"] = request.description;
    query["EndSchedule"] = request.endSchedule;
    query["Graph"] = request.graph;
    query["HostName"] = request.hostName;
    query["Lifecycle"] = request.lifecycle;
    query["LogArchiveLocation"] = request.logArchiveLocation;
    query["Name"] = request.name;
    query["Namespace"] = request.namespace;
    query["ParentCategory"] = request.parentCategory;
    query["ParentFlowList"] = request.parentFlowList;
    query["ProjectId"] = request.projectId;
    query["RegionId"] = request.regionId;
    query["StartSchedule"] = request.startSchedule;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "CreateFlowForWeb",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateFlowForWebResponse>(await this.callApi(params, req, runtime), new CreateFlowForWebResponse({}));
  }

  async createFlowForWeb(request: CreateFlowForWebRequest): Promise<CreateFlowForWebResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createFlowForWebWithOptions(request, runtime);
  }

  async createFlowJobWithOptions(request: CreateFlowJobRequest, runtime: $Util.RuntimeOptions): Promise<CreateFlowJobResponse> {
    Util.validateModel(request);
    let query = { };
    query["Adhoc"] = request.adhoc;
    query["AlertConf"] = request.alertConf;
    query["ClusterId"] = request.clusterId;
    query["FailAct"] = request.failAct;
    query["MaxRetry"] = request.maxRetry;
    query["MaxRunningTimeSec"] = request.maxRunningTimeSec;
    query["Mode"] = request.mode;
    query["Name"] = request.name;
    query["ParentCategory"] = request.parentCategory;
    query["ProjectId"] = request.projectId;
    query["RegionId"] = request.regionId;
    query["RetryInterval"] = request.retryInterval;
    query["RetryPolicy"] = request.retryPolicy;
    query["Type"] = request.type;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "CreateFlowJob",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateFlowJobResponse>(await this.callApi(params, req, runtime), new CreateFlowJobResponse({}));
  }

  async createFlowJob(request: CreateFlowJobRequest): Promise<CreateFlowJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createFlowJobWithOptions(request, runtime);
  }

  async createFlowProjectWithOptions(request: CreateFlowProjectRequest, runtime: $Util.RuntimeOptions): Promise<CreateFlowProjectResponse> {
    Util.validateModel(request);
    let query = { };
    query["Description"] = request.description;
    query["Name"] = request.name;
    query["ProductType"] = request.productType;
    query["RegionId"] = request.regionId;
    query["ResourceGroupId"] = request.resourceGroupId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "CreateFlowProject",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateFlowProjectResponse>(await this.callApi(params, req, runtime), new CreateFlowProjectResponse({}));
  }

  async createFlowProject(request: CreateFlowProjectRequest): Promise<CreateFlowProjectResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createFlowProjectWithOptions(request, runtime);
  }

  async createFlowProjectClusterSettingWithOptions(request: CreateFlowProjectClusterSettingRequest, runtime: $Util.RuntimeOptions): Promise<CreateFlowProjectClusterSettingResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["DefaultQueue"] = request.defaultQueue;
    query["DefaultUser"] = request.defaultUser;
    query["HostList"] = request.hostList;
    query["ProjectId"] = request.projectId;
    query["QueueList"] = request.queueList;
    query["RegionId"] = request.regionId;
    query["UserList"] = request.userList;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "CreateFlowProjectClusterSetting",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateFlowProjectClusterSettingResponse>(await this.callApi(params, req, runtime), new CreateFlowProjectClusterSettingResponse({}));
  }

  async createFlowProjectClusterSetting(request: CreateFlowProjectClusterSettingRequest): Promise<CreateFlowProjectClusterSettingResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createFlowProjectClusterSettingWithOptions(request, runtime);
  }

  async createFlowProjectUserWithOptions(request: CreateFlowProjectUserRequest, runtime: $Util.RuntimeOptions): Promise<CreateFlowProjectUserResponse> {
    Util.validateModel(request);
    let query = { };
    query["ProjectId"] = request.projectId;
    query["RegionId"] = request.regionId;
    query["User"] = request.user;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "CreateFlowProjectUser",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateFlowProjectUserResponse>(await this.callApi(params, req, runtime), new CreateFlowProjectUserResponse({}));
  }

  async createFlowProjectUser(request: CreateFlowProjectUserRequest): Promise<CreateFlowProjectUserResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createFlowProjectUserWithOptions(request, runtime);
  }

  async createJobWithOptions(request: CreateJobRequest, runtime: $Util.RuntimeOptions): Promise<CreateJobResponse> {
    Util.validateModel(request);
    let query = { };
    query["FailAct"] = request.failAct;
    query["MaxRetry"] = request.maxRetry;
    query["Name"] = request.name;
    query["RegionId"] = request.regionId;
    query["ResourceGroupId"] = request.resourceGroupId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["RetryInterval"] = request.retryInterval;
    query["RunParameter"] = request.runParameter;
    query["Type"] = request.type;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "CreateJob",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateJobResponse>(await this.callApi(params, req, runtime), new CreateJobResponse({}));
  }

  async createJob(request: CreateJobRequest): Promise<CreateJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createJobWithOptions(request, runtime);
  }

  async createLibraryWithOptions(request: CreateLibraryRequest, runtime: $Util.RuntimeOptions): Promise<CreateLibraryResponse> {
    Util.validateModel(request);
    let query = { };
    query["LibraryVersion"] = request.libraryVersion;
    query["Name"] = request.name;
    query["Properties"] = request.properties;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["Scope"] = request.scope;
    query["SourceLocation"] = request.sourceLocation;
    query["SourceType"] = request.sourceType;
    query["Type"] = request.type;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "CreateLibrary",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateLibraryResponse>(await this.callApi(params, req, runtime), new CreateLibraryResponse({}));
  }

  async createLibrary(request: CreateLibraryRequest): Promise<CreateLibraryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createLibraryWithOptions(request, runtime);
  }

  async createMetaTablePreviewTaskWithOptions(request: CreateMetaTablePreviewTaskRequest, runtime: $Util.RuntimeOptions): Promise<CreateMetaTablePreviewTaskResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["DatabaseId"] = request.databaseId;
    query["Password"] = request.password;
    query["RegionId"] = request.regionId;
    query["ResourceGroupId"] = request.resourceGroupId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["TableId"] = request.tableId;
    query["User"] = request.user;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "CreateMetaTablePreviewTask",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateMetaTablePreviewTaskResponse>(await this.callApi(params, req, runtime), new CreateMetaTablePreviewTaskResponse({}));
  }

  async createMetaTablePreviewTask(request: CreateMetaTablePreviewTaskRequest): Promise<CreateMetaTablePreviewTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createMetaTablePreviewTaskWithOptions(request, runtime);
  }

  async createResourcePoolWithOptions(request: CreateResourcePoolRequest, runtime: $Util.RuntimeOptions): Promise<CreateResourcePoolResponse> {
    Util.validateModel(request);
    let query = { };
    query["Active"] = request.active;
    query["ClusterId"] = request.clusterId;
    query["Config"] = request.config;
    query["Name"] = request.name;
    query["Note"] = request.note;
    query["PoolType"] = request.poolType;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["YarnSiteConfig"] = request.yarnSiteConfig;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "CreateResourcePool",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateResourcePoolResponse>(await this.callApi(params, req, runtime), new CreateResourcePoolResponse({}));
  }

  async createResourcePool(request: CreateResourcePoolRequest): Promise<CreateResourcePoolResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createResourcePoolWithOptions(request, runtime);
  }

  async createResourceQueueWithOptions(request: CreateResourceQueueRequest, runtime: $Util.RuntimeOptions): Promise<CreateResourceQueueResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["Config"] = request.config;
    query["Leaf"] = request.leaf;
    query["Name"] = request.name;
    query["ParentQueueId"] = request.parentQueueId;
    query["QualifiedName"] = request.qualifiedName;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["ResourcePoolId"] = request.resourcePoolId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "CreateResourceQueue",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateResourceQueueResponse>(await this.callApi(params, req, runtime), new CreateResourceQueueResponse({}));
  }

  async createResourceQueue(request: CreateResourceQueueRequest): Promise<CreateResourceQueueResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createResourceQueueWithOptions(request, runtime);
  }

  async createScalingGroupV2WithOptions(request: CreateScalingGroupV2Request, runtime: $Util.RuntimeOptions): Promise<CreateScalingGroupV2Response> {
    Util.validateModel(request);
    let query = { };
    query["Description"] = request.description;
    query["HostGroupId"] = request.hostGroupId;
    query["Name"] = request.name;
    query["RegionId"] = request.regionId;
    query["ResourceGroupId"] = request.resourceGroupId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "CreateScalingGroupV2",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateScalingGroupV2Response>(await this.callApi(params, req, runtime), new CreateScalingGroupV2Response({}));
  }

  async createScalingGroupV2(request: CreateScalingGroupV2Request): Promise<CreateScalingGroupV2Response> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createScalingGroupV2WithOptions(request, runtime);
  }

  async createScalingRuleWithOptions(request: CreateScalingRuleRequest, runtime: $Util.RuntimeOptions): Promise<CreateScalingRuleResponse> {
    Util.validateModel(request);
    let query = { };
    query["AdjustmentType"] = request.adjustmentType;
    query["AdjustmentValue"] = request.adjustmentValue;
    query["CloudWatchTrigger"] = request.cloudWatchTrigger;
    query["ClusterId"] = request.clusterId;
    query["Cooldown"] = request.cooldown;
    query["HostGroupId"] = request.hostGroupId;
    query["LaunchExpirationTime"] = request.launchExpirationTime;
    query["LaunchTime"] = request.launchTime;
    query["RecurrenceEndTime"] = request.recurrenceEndTime;
    query["RecurrenceType"] = request.recurrenceType;
    query["RecurrenceValue"] = request.recurrenceValue;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["RuleCategory"] = request.ruleCategory;
    query["RuleName"] = request.ruleName;
    query["SchedulerTrigger"] = request.schedulerTrigger;
    query["TimeoutWithGrace"] = request.timeoutWithGrace;
    query["WithGrace"] = request.withGrace;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "CreateScalingRule",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateScalingRuleResponse>(await this.callApi(params, req, runtime), new CreateScalingRuleResponse({}));
  }

  async createScalingRule(request: CreateScalingRuleRequest): Promise<CreateScalingRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createScalingRuleWithOptions(request, runtime);
  }

  async createTagWithOptions(request: CreateTagRequest, runtime: $Util.RuntimeOptions): Promise<CreateTagResponse> {
    Util.validateModel(request);
    let query = { };
    query["Category"] = request.category;
    query["Description"] = request.description;
    query["Id"] = request.id;
    query["Name"] = request.name;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "CreateTag",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateTagResponse>(await this.callApi(params, req, runtime), new CreateTagResponse({}));
  }

  async createTag(request: CreateTagRequest): Promise<CreateTagResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createTagWithOptions(request, runtime);
  }

  async createUserWithOptions(request: CreateUserRequest, runtime: $Util.RuntimeOptions): Promise<CreateUserResponse> {
    Util.validateModel(request);
    let query = { };
    query["AliyunUserId"] = request.aliyunUserId;
    query["Description"] = request.description;
    query["GroupIdList"] = request.groupIdList;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["RoleIdList"] = request.roleIdList;
    query["Status"] = request.status;
    query["UserAccountParamList"] = request.userAccountParamList;
    query["UserName"] = request.userName;
    query["UserType"] = request.userType;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "CreateUser",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateUserResponse>(await this.callApi(params, req, runtime), new CreateUserResponse({}));
  }

  async createUser(request: CreateUserRequest): Promise<CreateUserResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createUserWithOptions(request, runtime);
  }

  async createUsersWithOptions(request: CreateUsersRequest, runtime: $Util.RuntimeOptions): Promise<CreateUsersResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["UserInfo"] = request.userInfo;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "CreateUsers",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<CreateUsersResponse>(await this.callApi(params, req, runtime), new CreateUsersResponse({}));
  }

  async createUsers(request: CreateUsersRequest): Promise<CreateUsersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createUsersWithOptions(request, runtime);
  }

  async decommissionHostComponentWithOptions(request: DecommissionHostComponentRequest, runtime: $Util.RuntimeOptions): Promise<DecommissionHostComponentResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["ComponentName"] = request.componentName;
    query["HostInstanceId"] = request.hostInstanceId;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["ServiceName"] = request.serviceName;
    query["TimeoutSeconds"] = request.timeoutSeconds;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "DecommissionHostComponent",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DecommissionHostComponentResponse>(await this.callApi(params, req, runtime), new DecommissionHostComponentResponse({}));
  }

  async decommissionHostComponent(request: DecommissionHostComponentRequest): Promise<DecommissionHostComponentResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.decommissionHostComponentWithOptions(request, runtime);
  }

  async deleteClusterTemplateWithOptions(request: DeleteClusterTemplateRequest, runtime: $Util.RuntimeOptions): Promise<DeleteClusterTemplateResponse> {
    Util.validateModel(request);
    let query = { };
    query["BizId"] = request.bizId;
    query["RegionId"] = request.regionId;
    query["ResourceGroupId"] = request.resourceGroupId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "DeleteClusterTemplate",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeleteClusterTemplateResponse>(await this.callApi(params, req, runtime), new DeleteClusterTemplateResponse({}));
  }

  async deleteClusterTemplate(request: DeleteClusterTemplateRequest): Promise<DeleteClusterTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteClusterTemplateWithOptions(request, runtime);
  }

  async deleteExecutionPlanWithOptions(request: DeleteExecutionPlanRequest, runtime: $Util.RuntimeOptions): Promise<DeleteExecutionPlanResponse> {
    Util.validateModel(request);
    let query = { };
    query["Id"] = request.id;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "DeleteExecutionPlan",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeleteExecutionPlanResponse>(await this.callApi(params, req, runtime), new DeleteExecutionPlanResponse({}));
  }

  async deleteExecutionPlan(request: DeleteExecutionPlanRequest): Promise<DeleteExecutionPlanResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteExecutionPlanWithOptions(request, runtime);
  }

  async deleteFlowWithOptions(request: DeleteFlowRequest, runtime: $Util.RuntimeOptions): Promise<DeleteFlowResponse> {
    Util.validateModel(request);
    let query = { };
    query["Id"] = request.id;
    query["ProjectId"] = request.projectId;
    query["RegionId"] = request.regionId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "DeleteFlow",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeleteFlowResponse>(await this.callApi(params, req, runtime), new DeleteFlowResponse({}));
  }

  async deleteFlow(request: DeleteFlowRequest): Promise<DeleteFlowResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteFlowWithOptions(request, runtime);
  }

  async deleteFlowCategoryWithOptions(request: DeleteFlowCategoryRequest, runtime: $Util.RuntimeOptions): Promise<DeleteFlowCategoryResponse> {
    Util.validateModel(request);
    let query = { };
    query["Id"] = request.id;
    query["ProjectId"] = request.projectId;
    query["RegionId"] = request.regionId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "DeleteFlowCategory",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeleteFlowCategoryResponse>(await this.callApi(params, req, runtime), new DeleteFlowCategoryResponse({}));
  }

  async deleteFlowCategory(request: DeleteFlowCategoryRequest): Promise<DeleteFlowCategoryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteFlowCategoryWithOptions(request, runtime);
  }

  async deleteFlowJobWithOptions(request: DeleteFlowJobRequest, runtime: $Util.RuntimeOptions): Promise<DeleteFlowJobResponse> {
    Util.validateModel(request);
    let query = { };
    query["Id"] = request.id;
    query["ProjectId"] = request.projectId;
    query["RegionId"] = request.regionId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "DeleteFlowJob",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeleteFlowJobResponse>(await this.callApi(params, req, runtime), new DeleteFlowJobResponse({}));
  }

  async deleteFlowJob(request: DeleteFlowJobRequest): Promise<DeleteFlowJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteFlowJobWithOptions(request, runtime);
  }

  async deleteFlowProjectWithOptions(request: DeleteFlowProjectRequest, runtime: $Util.RuntimeOptions): Promise<DeleteFlowProjectResponse> {
    Util.validateModel(request);
    let query = { };
    query["ProjectId"] = request.projectId;
    query["RegionId"] = request.regionId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "DeleteFlowProject",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeleteFlowProjectResponse>(await this.callApi(params, req, runtime), new DeleteFlowProjectResponse({}));
  }

  async deleteFlowProject(request: DeleteFlowProjectRequest): Promise<DeleteFlowProjectResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteFlowProjectWithOptions(request, runtime);
  }

  async deleteFlowProjectClusterSettingWithOptions(request: DeleteFlowProjectClusterSettingRequest, runtime: $Util.RuntimeOptions): Promise<DeleteFlowProjectClusterSettingResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["ProjectId"] = request.projectId;
    query["RegionId"] = request.regionId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "DeleteFlowProjectClusterSetting",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeleteFlowProjectClusterSettingResponse>(await this.callApi(params, req, runtime), new DeleteFlowProjectClusterSettingResponse({}));
  }

  async deleteFlowProjectClusterSetting(request: DeleteFlowProjectClusterSettingRequest): Promise<DeleteFlowProjectClusterSettingResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteFlowProjectClusterSettingWithOptions(request, runtime);
  }

  async deleteFlowProjectUserWithOptions(request: DeleteFlowProjectUserRequest, runtime: $Util.RuntimeOptions): Promise<DeleteFlowProjectUserResponse> {
    Util.validateModel(request);
    let query = { };
    query["ProjectId"] = request.projectId;
    query["RegionId"] = request.regionId;
    query["UserName"] = request.userName;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "DeleteFlowProjectUser",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeleteFlowProjectUserResponse>(await this.callApi(params, req, runtime), new DeleteFlowProjectUserResponse({}));
  }

  async deleteFlowProjectUser(request: DeleteFlowProjectUserRequest): Promise<DeleteFlowProjectUserResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteFlowProjectUserWithOptions(request, runtime);
  }

  async deleteJobWithOptions(request: DeleteJobRequest, runtime: $Util.RuntimeOptions): Promise<DeleteJobResponse> {
    Util.validateModel(request);
    let query = { };
    query["Id"] = request.id;
    query["RegionId"] = request.regionId;
    query["ResourceGroupId"] = request.resourceGroupId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "DeleteJob",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeleteJobResponse>(await this.callApi(params, req, runtime), new DeleteJobResponse({}));
  }

  async deleteJob(request: DeleteJobRequest): Promise<DeleteJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteJobWithOptions(request, runtime);
  }

  async deleteLibrariesWithOptions(request: DeleteLibrariesRequest, runtime: $Util.RuntimeOptions): Promise<DeleteLibrariesResponse> {
    Util.validateModel(request);
    let query = { };
    query["LibraryBizIdList"] = request.libraryBizIdList;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "DeleteLibraries",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeleteLibrariesResponse>(await this.callApi(params, req, runtime), new DeleteLibrariesResponse({}));
  }

  async deleteLibraries(request: DeleteLibrariesRequest): Promise<DeleteLibrariesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteLibrariesWithOptions(request, runtime);
  }

  async deleteResourcePoolWithOptions(request: DeleteResourcePoolRequest, runtime: $Util.RuntimeOptions): Promise<DeleteResourcePoolResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["ResourcePoolId"] = request.resourcePoolId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "DeleteResourcePool",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeleteResourcePoolResponse>(await this.callApi(params, req, runtime), new DeleteResourcePoolResponse({}));
  }

  async deleteResourcePool(request: DeleteResourcePoolRequest): Promise<DeleteResourcePoolResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteResourcePoolWithOptions(request, runtime);
  }

  async deleteResourceQueueWithOptions(request: DeleteResourceQueueRequest, runtime: $Util.RuntimeOptions): Promise<DeleteResourceQueueResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["ResourceQueueId"] = request.resourceQueueId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "DeleteResourceQueue",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeleteResourceQueueResponse>(await this.callApi(params, req, runtime), new DeleteResourceQueueResponse({}));
  }

  async deleteResourceQueue(request: DeleteResourceQueueRequest): Promise<DeleteResourceQueueResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteResourceQueueWithOptions(request, runtime);
  }

  async deleteScalingRuleWithOptions(request: DeleteScalingRuleRequest, runtime: $Util.RuntimeOptions): Promise<DeleteScalingRuleResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["HostGroupId"] = request.hostGroupId;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["ScalingRuleId"] = request.scalingRuleId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "DeleteScalingRule",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeleteScalingRuleResponse>(await this.callApi(params, req, runtime), new DeleteScalingRuleResponse({}));
  }

  async deleteScalingRule(request: DeleteScalingRuleRequest): Promise<DeleteScalingRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteScalingRuleWithOptions(request, runtime);
  }

  async deleteTagWithOptions(request: DeleteTagRequest, runtime: $Util.RuntimeOptions): Promise<DeleteTagResponse> {
    Util.validateModel(request);
    let query = { };
    query["Category"] = request.category;
    query["Description"] = request.description;
    query["Id"] = request.id;
    query["Name"] = request.name;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "DeleteTag",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeleteTagResponse>(await this.callApi(params, req, runtime), new DeleteTagResponse({}));
  }

  async deleteTag(request: DeleteTagRequest): Promise<DeleteTagResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteTagWithOptions(request, runtime);
  }

  async deleteUserWithOptions(request: DeleteUserRequest, runtime: $Util.RuntimeOptions): Promise<DeleteUserResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["Type"] = request.type;
    query["UserId"] = request.userId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "DeleteUser",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DeleteUserResponse>(await this.callApi(params, req, runtime), new DeleteUserResponse({}));
  }

  async deleteUser(request: DeleteUserRequest): Promise<DeleteUserResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteUserWithOptions(request, runtime);
  }

  async describeClusterBasicInfoWithOptions(request: DescribeClusterBasicInfoRequest, runtime: $Util.RuntimeOptions): Promise<DescribeClusterBasicInfoResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "DescribeClusterBasicInfo",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DescribeClusterBasicInfoResponse>(await this.callApi(params, req, runtime), new DescribeClusterBasicInfoResponse({}));
  }

  async describeClusterBasicInfo(request: DescribeClusterBasicInfoRequest): Promise<DescribeClusterBasicInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeClusterBasicInfoWithOptions(request, runtime);
  }

  async describeClusterMetaCollectWithOptions(request: DescribeClusterMetaCollectRequest, runtime: $Util.RuntimeOptions): Promise<DescribeClusterMetaCollectResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "DescribeClusterMetaCollect",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DescribeClusterMetaCollectResponse>(await this.callApi(params, req, runtime), new DescribeClusterMetaCollectResponse({}));
  }

  async describeClusterMetaCollect(request: DescribeClusterMetaCollectRequest): Promise<DescribeClusterMetaCollectResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeClusterMetaCollectWithOptions(request, runtime);
  }

  async describeClusterOperationHostTaskLogWithOptions(request: DescribeClusterOperationHostTaskLogRequest, runtime: $Util.RuntimeOptions): Promise<DescribeClusterOperationHostTaskLogResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["HostId"] = request.hostId;
    query["OperationId"] = request.operationId;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["Status"] = request.status;
    query["TaskId"] = request.taskId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "DescribeClusterOperationHostTaskLog",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DescribeClusterOperationHostTaskLogResponse>(await this.callApi(params, req, runtime), new DescribeClusterOperationHostTaskLogResponse({}));
  }

  async describeClusterOperationHostTaskLog(request: DescribeClusterOperationHostTaskLogRequest): Promise<DescribeClusterOperationHostTaskLogResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeClusterOperationHostTaskLogWithOptions(request, runtime);
  }

  async describeClusterResourcePoolSchedulerTypeWithOptions(request: DescribeClusterResourcePoolSchedulerTypeRequest, runtime: $Util.RuntimeOptions): Promise<DescribeClusterResourcePoolSchedulerTypeResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "DescribeClusterResourcePoolSchedulerType",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DescribeClusterResourcePoolSchedulerTypeResponse>(await this.callApi(params, req, runtime), new DescribeClusterResourcePoolSchedulerTypeResponse({}));
  }

  async describeClusterResourcePoolSchedulerType(request: DescribeClusterResourcePoolSchedulerTypeRequest): Promise<DescribeClusterResourcePoolSchedulerTypeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeClusterResourcePoolSchedulerTypeWithOptions(request, runtime);
  }

  async describeClusterServiceWithOptions(request: DescribeClusterServiceRequest, runtime: $Util.RuntimeOptions): Promise<DescribeClusterServiceResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["ServiceName"] = request.serviceName;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "DescribeClusterService",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DescribeClusterServiceResponse>(await this.callApi(params, req, runtime), new DescribeClusterServiceResponse({}));
  }

  async describeClusterService(request: DescribeClusterServiceRequest): Promise<DescribeClusterServiceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeClusterServiceWithOptions(request, runtime);
  }

  async describeClusterServiceConfigWithOptions(request: DescribeClusterServiceConfigRequest, runtime: $Util.RuntimeOptions): Promise<DescribeClusterServiceConfigResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["ConfigVersion"] = request.configVersion;
    query["GroupId"] = request.groupId;
    query["HostInstanceId"] = request.hostInstanceId;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["ServiceName"] = request.serviceName;
    query["TagValue"] = request.tagValue;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "DescribeClusterServiceConfig",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DescribeClusterServiceConfigResponse>(await this.callApi(params, req, runtime), new DescribeClusterServiceConfigResponse({}));
  }

  async describeClusterServiceConfig(request: DescribeClusterServiceConfigRequest): Promise<DescribeClusterServiceConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeClusterServiceConfigWithOptions(request, runtime);
  }

  async describeClusterServiceConfigHistoryWithOptions(request: DescribeClusterServiceConfigHistoryRequest, runtime: $Util.RuntimeOptions): Promise<DescribeClusterServiceConfigHistoryResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["ConfigVersion"] = request.configVersion;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["ServiceName"] = request.serviceName;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "DescribeClusterServiceConfigHistory",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DescribeClusterServiceConfigHistoryResponse>(await this.callApi(params, req, runtime), new DescribeClusterServiceConfigHistoryResponse({}));
  }

  async describeClusterServiceConfigHistory(request: DescribeClusterServiceConfigHistoryRequest): Promise<DescribeClusterServiceConfigHistoryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeClusterServiceConfigHistoryWithOptions(request, runtime);
  }

  async describeClusterServiceConfigTagWithOptions(request: DescribeClusterServiceConfigTagRequest, runtime: $Util.RuntimeOptions): Promise<DescribeClusterServiceConfigTagResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["ConfigTag"] = request.configTag;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["ServiceName"] = request.serviceName;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "DescribeClusterServiceConfigTag",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DescribeClusterServiceConfigTagResponse>(await this.callApi(params, req, runtime), new DescribeClusterServiceConfigTagResponse({}));
  }

  async describeClusterServiceConfigTag(request: DescribeClusterServiceConfigTagRequest): Promise<DescribeClusterServiceConfigTagResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeClusterServiceConfigTagWithOptions(request, runtime);
  }

  async describeClusterTemplateWithOptions(request: DescribeClusterTemplateRequest, runtime: $Util.RuntimeOptions): Promise<DescribeClusterTemplateResponse> {
    Util.validateModel(request);
    let query = { };
    query["BizId"] = request.bizId;
    query["ResourceGroupId"] = request.resourceGroupId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "DescribeClusterTemplate",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DescribeClusterTemplateResponse>(await this.callApi(params, req, runtime), new DescribeClusterTemplateResponse({}));
  }

  async describeClusterTemplate(request: DescribeClusterTemplateRequest): Promise<DescribeClusterTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeClusterTemplateWithOptions(request, runtime);
  }

  async describeClusterV2WithOptions(request: DescribeClusterV2Request, runtime: $Util.RuntimeOptions): Promise<DescribeClusterV2Response> {
    Util.validateModel(request);
    let query = { };
    query["Id"] = request.id;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "DescribeClusterV2",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DescribeClusterV2Response>(await this.callApi(params, req, runtime), new DescribeClusterV2Response({}));
  }

  async describeClusterV2(request: DescribeClusterV2Request): Promise<DescribeClusterV2Response> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeClusterV2WithOptions(request, runtime);
  }

  async describeDataSourceWithOptions(request: DescribeDataSourceRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDataSourceResponse> {
    Util.validateModel(request);
    let query = { };
    query["Id"] = request.id;
    query["RegionId"] = request.regionId;
    query["ResourceGroupId"] = request.resourceGroupId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDataSource",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DescribeDataSourceResponse>(await this.callApi(params, req, runtime), new DescribeDataSourceResponse({}));
  }

  async describeDataSource(request: DescribeDataSourceRequest): Promise<DescribeDataSourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDataSourceWithOptions(request, runtime);
  }

  async describeDiskOpsActivityWithOptions(request: DescribeDiskOpsActivityRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDiskOpsActivityResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["CurrentStage"] = request.currentStage;
    query["CurrentState"] = request.currentState;
    query["DiskId"] = request.diskId;
    query["EventId"] = request.eventId;
    query["InstanceId"] = request.instanceId;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDiskOpsActivity",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DescribeDiskOpsActivityResponse>(await this.callApi(params, req, runtime), new DescribeDiskOpsActivityResponse({}));
  }

  async describeDiskOpsActivity(request: DescribeDiskOpsActivityRequest): Promise<DescribeDiskOpsActivityResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDiskOpsActivityWithOptions(request, runtime);
  }

  async describeEmrMainVersionWithOptions(request: DescribeEmrMainVersionRequest, runtime: $Util.RuntimeOptions): Promise<DescribeEmrMainVersionResponse> {
    Util.validateModel(request);
    let query = { };
    query["EmrVersion"] = request.emrVersion;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "DescribeEmrMainVersion",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DescribeEmrMainVersionResponse>(await this.callApi(params, req, runtime), new DescribeEmrMainVersionResponse({}));
  }

  async describeEmrMainVersion(request: DescribeEmrMainVersionRequest): Promise<DescribeEmrMainVersionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeEmrMainVersionWithOptions(request, runtime);
  }

  async describeExecutionPlanWithOptions(request: DescribeExecutionPlanRequest, runtime: $Util.RuntimeOptions): Promise<DescribeExecutionPlanResponse> {
    Util.validateModel(request);
    let query = { };
    query["Id"] = request.id;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "DescribeExecutionPlan",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DescribeExecutionPlanResponse>(await this.callApi(params, req, runtime), new DescribeExecutionPlanResponse({}));
  }

  async describeExecutionPlan(request: DescribeExecutionPlanRequest): Promise<DescribeExecutionPlanResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeExecutionPlanWithOptions(request, runtime);
  }

  async describeFlowWithOptions(request: DescribeFlowRequest, runtime: $Util.RuntimeOptions): Promise<DescribeFlowResponse> {
    Util.validateModel(request);
    let query = { };
    query["Id"] = request.id;
    query["ProjectId"] = request.projectId;
    query["RegionId"] = request.regionId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "DescribeFlow",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DescribeFlowResponse>(await this.callApi(params, req, runtime), new DescribeFlowResponse({}));
  }

  async describeFlow(request: DescribeFlowRequest): Promise<DescribeFlowResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeFlowWithOptions(request, runtime);
  }

  async describeFlowCategoryWithOptions(request: DescribeFlowCategoryRequest, runtime: $Util.RuntimeOptions): Promise<DescribeFlowCategoryResponse> {
    Util.validateModel(request);
    let query = { };
    query["Id"] = request.id;
    query["ProjectId"] = request.projectId;
    query["RegionId"] = request.regionId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "DescribeFlowCategory",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DescribeFlowCategoryResponse>(await this.callApi(params, req, runtime), new DescribeFlowCategoryResponse({}));
  }

  async describeFlowCategory(request: DescribeFlowCategoryRequest): Promise<DescribeFlowCategoryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeFlowCategoryWithOptions(request, runtime);
  }

  async describeFlowCategoryTreeWithOptions(request: DescribeFlowCategoryTreeRequest, runtime: $Util.RuntimeOptions): Promise<DescribeFlowCategoryTreeResponse> {
    Util.validateModel(request);
    let query = { };
    query["CategoryId"] = request.categoryId;
    query["Keyword"] = request.keyword;
    query["Mode"] = request.mode;
    query["ProjectId"] = request.projectId;
    query["RegionId"] = request.regionId;
    query["Type"] = request.type;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "DescribeFlowCategoryTree",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DescribeFlowCategoryTreeResponse>(await this.callApi(params, req, runtime), new DescribeFlowCategoryTreeResponse({}));
  }

  async describeFlowCategoryTree(request: DescribeFlowCategoryTreeRequest): Promise<DescribeFlowCategoryTreeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeFlowCategoryTreeWithOptions(request, runtime);
  }

  async describeFlowInstanceWithOptions(request: DescribeFlowInstanceRequest, runtime: $Util.RuntimeOptions): Promise<DescribeFlowInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    query["Id"] = request.id;
    query["ProjectId"] = request.projectId;
    query["RegionId"] = request.regionId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "DescribeFlowInstance",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DescribeFlowInstanceResponse>(await this.callApi(params, req, runtime), new DescribeFlowInstanceResponse({}));
  }

  async describeFlowInstance(request: DescribeFlowInstanceRequest): Promise<DescribeFlowInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeFlowInstanceWithOptions(request, runtime);
  }

  async describeFlowJobWithOptions(request: DescribeFlowJobRequest, runtime: $Util.RuntimeOptions): Promise<DescribeFlowJobResponse> {
    Util.validateModel(request);
    let query = { };
    query["Id"] = request.id;
    query["ProjectId"] = request.projectId;
    query["RegionId"] = request.regionId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "DescribeFlowJob",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DescribeFlowJobResponse>(await this.callApi(params, req, runtime), new DescribeFlowJobResponse({}));
  }

  async describeFlowJob(request: DescribeFlowJobRequest): Promise<DescribeFlowJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeFlowJobWithOptions(request, runtime);
  }

  async describeFlowNodeInstanceWithOptions(request: DescribeFlowNodeInstanceRequest, runtime: $Util.RuntimeOptions): Promise<DescribeFlowNodeInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    query["Id"] = request.id;
    query["ProjectId"] = request.projectId;
    query["RegionId"] = request.regionId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "DescribeFlowNodeInstance",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DescribeFlowNodeInstanceResponse>(await this.callApi(params, req, runtime), new DescribeFlowNodeInstanceResponse({}));
  }

  async describeFlowNodeInstance(request: DescribeFlowNodeInstanceRequest): Promise<DescribeFlowNodeInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeFlowNodeInstanceWithOptions(request, runtime);
  }

  async describeFlowNodeInstanceContainerLogWithOptions(request: DescribeFlowNodeInstanceContainerLogRequest, runtime: $Util.RuntimeOptions): Promise<DescribeFlowNodeInstanceContainerLogResponse> {
    Util.validateModel(request);
    let query = { };
    query["AppId"] = request.appId;
    query["ContainerId"] = request.containerId;
    query["Length"] = request.length;
    query["LogName"] = request.logName;
    query["NodeInstanceId"] = request.nodeInstanceId;
    query["Offset"] = request.offset;
    query["ProjectId"] = request.projectId;
    query["RegionId"] = request.regionId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "DescribeFlowNodeInstanceContainerLog",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DescribeFlowNodeInstanceContainerLogResponse>(await this.callApi(params, req, runtime), new DescribeFlowNodeInstanceContainerLogResponse({}));
  }

  async describeFlowNodeInstanceContainerLog(request: DescribeFlowNodeInstanceContainerLogRequest): Promise<DescribeFlowNodeInstanceContainerLogResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeFlowNodeInstanceContainerLogWithOptions(request, runtime);
  }

  async describeFlowNodeInstanceLauncherLogWithOptions(request: DescribeFlowNodeInstanceLauncherLogRequest, runtime: $Util.RuntimeOptions): Promise<DescribeFlowNodeInstanceLauncherLogResponse> {
    Util.validateModel(request);
    let query = { };
    query["EndTime"] = request.endTime;
    query["Length"] = request.length;
    query["Lines"] = request.lines;
    query["NodeInstanceId"] = request.nodeInstanceId;
    query["Offset"] = request.offset;
    query["ProjectId"] = request.projectId;
    query["RegionId"] = request.regionId;
    query["Reverse"] = request.reverse;
    query["Start"] = request.start;
    query["StartTime"] = request.startTime;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "DescribeFlowNodeInstanceLauncherLog",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DescribeFlowNodeInstanceLauncherLogResponse>(await this.callApi(params, req, runtime), new DescribeFlowNodeInstanceLauncherLogResponse({}));
  }

  async describeFlowNodeInstanceLauncherLog(request: DescribeFlowNodeInstanceLauncherLogRequest): Promise<DescribeFlowNodeInstanceLauncherLogResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeFlowNodeInstanceLauncherLogWithOptions(request, runtime);
  }

  async describeFlowProjectWithOptions(request: DescribeFlowProjectRequest, runtime: $Util.RuntimeOptions): Promise<DescribeFlowProjectResponse> {
    Util.validateModel(request);
    let query = { };
    query["ProjectId"] = request.projectId;
    query["RegionId"] = request.regionId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "DescribeFlowProject",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DescribeFlowProjectResponse>(await this.callApi(params, req, runtime), new DescribeFlowProjectResponse({}));
  }

  async describeFlowProject(request: DescribeFlowProjectRequest): Promise<DescribeFlowProjectResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeFlowProjectWithOptions(request, runtime);
  }

  async describeFlowProjectClusterSettingWithOptions(request: DescribeFlowProjectClusterSettingRequest, runtime: $Util.RuntimeOptions): Promise<DescribeFlowProjectClusterSettingResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["ProjectId"] = request.projectId;
    query["RegionId"] = request.regionId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "DescribeFlowProjectClusterSetting",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DescribeFlowProjectClusterSettingResponse>(await this.callApi(params, req, runtime), new DescribeFlowProjectClusterSettingResponse({}));
  }

  async describeFlowProjectClusterSetting(request: DescribeFlowProjectClusterSettingRequest): Promise<DescribeFlowProjectClusterSettingResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeFlowProjectClusterSettingWithOptions(request, runtime);
  }

  async describeJobWithOptions(request: DescribeJobRequest, runtime: $Util.RuntimeOptions): Promise<DescribeJobResponse> {
    Util.validateModel(request);
    let query = { };
    query["Id"] = request.id;
    query["RegionId"] = request.regionId;
    query["ResourceGroupId"] = request.resourceGroupId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "DescribeJob",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DescribeJobResponse>(await this.callApi(params, req, runtime), new DescribeJobResponse({}));
  }

  async describeJob(request: DescribeJobRequest): Promise<DescribeJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeJobWithOptions(request, runtime);
  }

  async describeLibraryDetailWithOptions(request: DescribeLibraryDetailRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLibraryDetailResponse> {
    Util.validateModel(request);
    let query = { };
    query["LibraryBizId"] = request.libraryBizId;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLibraryDetail",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DescribeLibraryDetailResponse>(await this.callApi(params, req, runtime), new DescribeLibraryDetailResponse({}));
  }

  async describeLibraryDetail(request: DescribeLibraryDetailRequest): Promise<DescribeLibraryDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLibraryDetailWithOptions(request, runtime);
  }

  async describeLibraryInstallTaskDetailWithOptions(request: DescribeLibraryInstallTaskDetailRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLibraryInstallTaskDetailResponse> {
    Util.validateModel(request);
    let query = { };
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["TaskBizId"] = request.taskBizId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLibraryInstallTaskDetail",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DescribeLibraryInstallTaskDetailResponse>(await this.callApi(params, req, runtime), new DescribeLibraryInstallTaskDetailResponse({}));
  }

  async describeLibraryInstallTaskDetail(request: DescribeLibraryInstallTaskDetailRequest): Promise<DescribeLibraryInstallTaskDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLibraryInstallTaskDetailWithOptions(request, runtime);
  }

  async describeMetaTablePreviewTaskWithOptions(request: DescribeMetaTablePreviewTaskRequest, runtime: $Util.RuntimeOptions): Promise<DescribeMetaTablePreviewTaskResponse> {
    Util.validateModel(request);
    let query = { };
    query["RegionId"] = request.regionId;
    query["ResourceGroupId"] = request.resourceGroupId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["TaskId"] = request.taskId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "DescribeMetaTablePreviewTask",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DescribeMetaTablePreviewTaskResponse>(await this.callApi(params, req, runtime), new DescribeMetaTablePreviewTaskResponse({}));
  }

  async describeMetaTablePreviewTask(request: DescribeMetaTablePreviewTaskRequest): Promise<DescribeMetaTablePreviewTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeMetaTablePreviewTaskWithOptions(request, runtime);
  }

  async describeScalingActivityWithOptions(request: DescribeScalingActivityRequest, runtime: $Util.RuntimeOptions): Promise<DescribeScalingActivityResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["HostGroupId"] = request.hostGroupId;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["ScalingActivityId"] = request.scalingActivityId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "DescribeScalingActivity",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DescribeScalingActivityResponse>(await this.callApi(params, req, runtime), new DescribeScalingActivityResponse({}));
  }

  async describeScalingActivity(request: DescribeScalingActivityRequest): Promise<DescribeScalingActivityResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeScalingActivityWithOptions(request, runtime);
  }

  async describeScalingCommonConfigWithOptions(request: DescribeScalingCommonConfigRequest, runtime: $Util.RuntimeOptions): Promise<DescribeScalingCommonConfigResponse> {
    Util.validateModel(request);
    let query = { };
    query["RegionId"] = request.regionId;
    query["ResourceGroupId"] = request.resourceGroupId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "DescribeScalingCommonConfig",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DescribeScalingCommonConfigResponse>(await this.callApi(params, req, runtime), new DescribeScalingCommonConfigResponse({}));
  }

  async describeScalingCommonConfig(request: DescribeScalingCommonConfigRequest): Promise<DescribeScalingCommonConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeScalingCommonConfigWithOptions(request, runtime);
  }

  async describeScalingConfigItemV2WithOptions(request: DescribeScalingConfigItemV2Request, runtime: $Util.RuntimeOptions): Promise<DescribeScalingConfigItemV2Response> {
    Util.validateModel(request);
    let query = { };
    query["ConfigItemType"] = request.configItemType;
    query["RegionId"] = request.regionId;
    query["ResourceGroupId"] = request.resourceGroupId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["ScalingConfigItemId"] = request.scalingConfigItemId;
    query["ScalingGroupBizId"] = request.scalingGroupBizId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "DescribeScalingConfigItemV2",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DescribeScalingConfigItemV2Response>(await this.callApi(params, req, runtime), new DescribeScalingConfigItemV2Response({}));
  }

  async describeScalingConfigItemV2(request: DescribeScalingConfigItemV2Request): Promise<DescribeScalingConfigItemV2Response> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeScalingConfigItemV2WithOptions(request, runtime);
  }

  async describeScalingGroupInstanceV2WithOptions(request: DescribeScalingGroupInstanceV2Request, runtime: $Util.RuntimeOptions): Promise<DescribeScalingGroupInstanceV2Response> {
    Util.validateModel(request);
    let query = { };
    query["HostGroupBizId"] = request.hostGroupBizId;
    query["RegionId"] = request.regionId;
    query["ResourceGroupId"] = request.resourceGroupId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["ScalingGroupBizId"] = request.scalingGroupBizId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "DescribeScalingGroupInstanceV2",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DescribeScalingGroupInstanceV2Response>(await this.callApi(params, req, runtime), new DescribeScalingGroupInstanceV2Response({}));
  }

  async describeScalingGroupInstanceV2(request: DescribeScalingGroupInstanceV2Request): Promise<DescribeScalingGroupInstanceV2Response> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeScalingGroupInstanceV2WithOptions(request, runtime);
  }

  async describeScalingGroupV2WithOptions(request: DescribeScalingGroupV2Request, runtime: $Util.RuntimeOptions): Promise<DescribeScalingGroupV2Response> {
    Util.validateModel(request);
    let query = { };
    query["HostGroupBizId"] = request.hostGroupBizId;
    query["RegionId"] = request.regionId;
    query["ResourceGroupId"] = request.resourceGroupId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["ScalingGroupBizId"] = request.scalingGroupBizId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "DescribeScalingGroupV2",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DescribeScalingGroupV2Response>(await this.callApi(params, req, runtime), new DescribeScalingGroupV2Response({}));
  }

  async describeScalingGroupV2(request: DescribeScalingGroupV2Request): Promise<DescribeScalingGroupV2Response> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeScalingGroupV2WithOptions(request, runtime);
  }

  async describeScalingRuleWithOptions(request: DescribeScalingRuleRequest, runtime: $Util.RuntimeOptions): Promise<DescribeScalingRuleResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["HostGroupId"] = request.hostGroupId;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["ScalingRuleId"] = request.scalingRuleId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "DescribeScalingRule",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DescribeScalingRuleResponse>(await this.callApi(params, req, runtime), new DescribeScalingRuleResponse({}));
  }

  async describeScalingRule(request: DescribeScalingRuleRequest): Promise<DescribeScalingRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeScalingRuleWithOptions(request, runtime);
  }

  async describeSecurityGroupAttributeWithOptions(request: DescribeSecurityGroupAttributeRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSecurityGroupAttributeResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["RegionId"] = request.regionId;
    query["ResourceGroupId"] = request.resourceGroupId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "DescribeSecurityGroupAttribute",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DescribeSecurityGroupAttributeResponse>(await this.callApi(params, req, runtime), new DescribeSecurityGroupAttributeResponse({}));
  }

  async describeSecurityGroupAttribute(request: DescribeSecurityGroupAttributeRequest): Promise<DescribeSecurityGroupAttributeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSecurityGroupAttributeWithOptions(request, runtime);
  }

  async detachAndReleaseClusterEniWithOptions(request: DetachAndReleaseClusterEniRequest, runtime: $Util.RuntimeOptions): Promise<DetachAndReleaseClusterEniResponse> {
    Util.validateModel(request);
    let query = { };
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["TargetClusterId"] = request.targetClusterId;
    query["VswitchId"] = request.vswitchId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "DetachAndReleaseClusterEni",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<DetachAndReleaseClusterEniResponse>(await this.callApi(params, req, runtime), new DetachAndReleaseClusterEniResponse({}));
  }

  async detachAndReleaseClusterEni(request: DetachAndReleaseClusterEniRequest): Promise<DetachAndReleaseClusterEniResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.detachAndReleaseClusterEniWithOptions(request, runtime);
  }

  async getHdfsCapacityStatisticInfoWithOptions(request: GetHdfsCapacityStatisticInfoRequest, runtime: $Util.RuntimeOptions): Promise<GetHdfsCapacityStatisticInfoResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["FromDatetime"] = request.fromDatetime;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["ToDatetime"] = request.toDatetime;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "GetHdfsCapacityStatisticInfo",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetHdfsCapacityStatisticInfoResponse>(await this.callApi(params, req, runtime), new GetHdfsCapacityStatisticInfoResponse({}));
  }

  async getHdfsCapacityStatisticInfo(request: GetHdfsCapacityStatisticInfoRequest): Promise<GetHdfsCapacityStatisticInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getHdfsCapacityStatisticInfoWithOptions(request, runtime);
  }

  async getJobInputStatisticInfoWithOptions(request: GetJobInputStatisticInfoRequest, runtime: $Util.RuntimeOptions): Promise<GetJobInputStatisticInfoResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["FromDatetime"] = request.fromDatetime;
    query["PageNumber"] = request.pageNumber;
    query["PageSize"] = request.pageSize;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["ToDatetime"] = request.toDatetime;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "GetJobInputStatisticInfo",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetJobInputStatisticInfoResponse>(await this.callApi(params, req, runtime), new GetJobInputStatisticInfoResponse({}));
  }

  async getJobInputStatisticInfo(request: GetJobInputStatisticInfoRequest): Promise<GetJobInputStatisticInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getJobInputStatisticInfoWithOptions(request, runtime);
  }

  async getJobOutputStatisticInfoWithOptions(request: GetJobOutputStatisticInfoRequest, runtime: $Util.RuntimeOptions): Promise<GetJobOutputStatisticInfoResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["FromDatetime"] = request.fromDatetime;
    query["PageNumber"] = request.pageNumber;
    query["PageSize"] = request.pageSize;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["ToDatetime"] = request.toDatetime;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "GetJobOutputStatisticInfo",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetJobOutputStatisticInfoResponse>(await this.callApi(params, req, runtime), new GetJobOutputStatisticInfoResponse({}));
  }

  async getJobOutputStatisticInfo(request: GetJobOutputStatisticInfoRequest): Promise<GetJobOutputStatisticInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getJobOutputStatisticInfoWithOptions(request, runtime);
  }

  async getJobRunningTimeStatisticInfoWithOptions(request: GetJobRunningTimeStatisticInfoRequest, runtime: $Util.RuntimeOptions): Promise<GetJobRunningTimeStatisticInfoResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["FromDatetime"] = request.fromDatetime;
    query["PageNumber"] = request.pageNumber;
    query["PageSize"] = request.pageSize;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["ToDatetime"] = request.toDatetime;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "GetJobRunningTimeStatisticInfo",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetJobRunningTimeStatisticInfoResponse>(await this.callApi(params, req, runtime), new GetJobRunningTimeStatisticInfoResponse({}));
  }

  async getJobRunningTimeStatisticInfo(request: GetJobRunningTimeStatisticInfoRequest): Promise<GetJobRunningTimeStatisticInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getJobRunningTimeStatisticInfoWithOptions(request, runtime);
  }

  async getQueueInputStatisticInfoWithOptions(request: GetQueueInputStatisticInfoRequest, runtime: $Util.RuntimeOptions): Promise<GetQueueInputStatisticInfoResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["FromDatetime"] = request.fromDatetime;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["ToDatetime"] = request.toDatetime;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "GetQueueInputStatisticInfo",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetQueueInputStatisticInfoResponse>(await this.callApi(params, req, runtime), new GetQueueInputStatisticInfoResponse({}));
  }

  async getQueueInputStatisticInfo(request: GetQueueInputStatisticInfoRequest): Promise<GetQueueInputStatisticInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getQueueInputStatisticInfoWithOptions(request, runtime);
  }

  async getQueueOutputStatisticInfoWithOptions(request: GetQueueOutputStatisticInfoRequest, runtime: $Util.RuntimeOptions): Promise<GetQueueOutputStatisticInfoResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["FromDatetime"] = request.fromDatetime;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["ToDatetime"] = request.toDatetime;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "GetQueueOutputStatisticInfo",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetQueueOutputStatisticInfoResponse>(await this.callApi(params, req, runtime), new GetQueueOutputStatisticInfoResponse({}));
  }

  async getQueueOutputStatisticInfo(request: GetQueueOutputStatisticInfoRequest): Promise<GetQueueOutputStatisticInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getQueueOutputStatisticInfoWithOptions(request, runtime);
  }

  async getQueueSubmissionStatisticInfoWithOptions(request: GetQueueSubmissionStatisticInfoRequest, runtime: $Util.RuntimeOptions): Promise<GetQueueSubmissionStatisticInfoResponse> {
    Util.validateModel(request);
    let query = { };
    query["ApplicationType"] = request.applicationType;
    query["ClusterId"] = request.clusterId;
    query["FinalStatus"] = request.finalStatus;
    query["FromDatetime"] = request.fromDatetime;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["ToDatetime"] = request.toDatetime;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "GetQueueSubmissionStatisticInfo",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetQueueSubmissionStatisticInfoResponse>(await this.callApi(params, req, runtime), new GetQueueSubmissionStatisticInfoResponse({}));
  }

  async getQueueSubmissionStatisticInfo(request: GetQueueSubmissionStatisticInfoRequest): Promise<GetQueueSubmissionStatisticInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getQueueSubmissionStatisticInfoWithOptions(request, runtime);
  }

  async getUserInputStatisticInfoWithOptions(request: GetUserInputStatisticInfoRequest, runtime: $Util.RuntimeOptions): Promise<GetUserInputStatisticInfoResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["FromDatetime"] = request.fromDatetime;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["ToDatetime"] = request.toDatetime;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "GetUserInputStatisticInfo",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetUserInputStatisticInfoResponse>(await this.callApi(params, req, runtime), new GetUserInputStatisticInfoResponse({}));
  }

  async getUserInputStatisticInfo(request: GetUserInputStatisticInfoRequest): Promise<GetUserInputStatisticInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getUserInputStatisticInfoWithOptions(request, runtime);
  }

  async getUserOutputStatisticInfoWithOptions(request: GetUserOutputStatisticInfoRequest, runtime: $Util.RuntimeOptions): Promise<GetUserOutputStatisticInfoResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["FromDatetime"] = request.fromDatetime;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["ToDatetime"] = request.toDatetime;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "GetUserOutputStatisticInfo",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetUserOutputStatisticInfoResponse>(await this.callApi(params, req, runtime), new GetUserOutputStatisticInfoResponse({}));
  }

  async getUserOutputStatisticInfo(request: GetUserOutputStatisticInfoRequest): Promise<GetUserOutputStatisticInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getUserOutputStatisticInfoWithOptions(request, runtime);
  }

  async getUserSubmissionStatisticInfoWithOptions(request: GetUserSubmissionStatisticInfoRequest, runtime: $Util.RuntimeOptions): Promise<GetUserSubmissionStatisticInfoResponse> {
    Util.validateModel(request);
    let query = { };
    query["ApplicationType"] = request.applicationType;
    query["ClusterId"] = request.clusterId;
    query["FinalStatus"] = request.finalStatus;
    query["FromDatetime"] = request.fromDatetime;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["ToDatetime"] = request.toDatetime;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "GetUserSubmissionStatisticInfo",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<GetUserSubmissionStatisticInfoResponse>(await this.callApi(params, req, runtime), new GetUserSubmissionStatisticInfoResponse({}));
  }

  async getUserSubmissionStatisticInfo(request: GetUserSubmissionStatisticInfoRequest): Promise<GetUserSubmissionStatisticInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getUserSubmissionStatisticInfoWithOptions(request, runtime);
  }

  async installLibrariesWithOptions(request: InstallLibrariesRequest, runtime: $Util.RuntimeOptions): Promise<InstallLibrariesResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterBizIdList"] = request.clusterBizIdList;
    query["LibraryBizId"] = request.libraryBizId;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "InstallLibraries",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<InstallLibrariesResponse>(await this.callApi(params, req, runtime), new InstallLibrariesResponse({}));
  }

  async installLibraries(request: InstallLibrariesRequest): Promise<InstallLibrariesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.installLibrariesWithOptions(request, runtime);
  }

  async joinResourceGroupWithOptions(request: JoinResourceGroupRequest, runtime: $Util.RuntimeOptions): Promise<JoinResourceGroupResponse> {
    Util.validateModel(request);
    let query = { };
    query["RegionId"] = request.regionId;
    query["ResourceGroupId"] = request.resourceGroupId;
    query["ResourceId"] = request.resourceId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["ResourceType"] = request.resourceType;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "JoinResourceGroup",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<JoinResourceGroupResponse>(await this.callApi(params, req, runtime), new JoinResourceGroupResponse({}));
  }

  async joinResourceGroup(request: JoinResourceGroupRequest): Promise<JoinResourceGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.joinResourceGroupWithOptions(request, runtime);
  }

  async killFlowJobWithOptions(request: KillFlowJobRequest, runtime: $Util.RuntimeOptions): Promise<KillFlowJobResponse> {
    Util.validateModel(request);
    let query = { };
    query["JobInstanceId"] = request.jobInstanceId;
    query["ProjectId"] = request.projectId;
    query["RegionId"] = request.regionId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "KillFlowJob",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<KillFlowJobResponse>(await this.callApi(params, req, runtime), new KillFlowJobResponse({}));
  }

  async killFlowJob(request: KillFlowJobRequest): Promise<KillFlowJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.killFlowJobWithOptions(request, runtime);
  }

  async listAdviceActionWithOptions(request: ListAdviceActionRequest, runtime: $Util.RuntimeOptions): Promise<ListAdviceActionResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["Component"] = request.component;
    query["PageNumber"] = request.pageNumber;
    query["PageSize"] = request.pageSize;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["ServiceName"] = request.serviceName;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ListAdviceAction",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListAdviceActionResponse>(await this.callApi(params, req, runtime), new ListAdviceActionResponse({}));
  }

  async listAdviceAction(request: ListAdviceActionRequest): Promise<ListAdviceActionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listAdviceActionWithOptions(request, runtime);
  }

  async listApmApplicationWithOptions(request: ListApmApplicationRequest, runtime: $Util.RuntimeOptions): Promise<ListApmApplicationResponse> {
    Util.validateModel(request);
    let query = { };
    query["AppId"] = request.appId;
    query["ClusterId"] = request.clusterId;
    query["DiagnoseResult"] = request.diagnoseResult;
    query["EndTimeFrom"] = request.endTimeFrom;
    query["EndTimeTo"] = request.endTimeTo;
    query["FinalStatus"] = request.finalStatus;
    query["JobType"] = request.jobType;
    query["Name"] = request.name;
    query["OrderBy"] = request.orderBy;
    query["PageNumber"] = request.pageNumber;
    query["PageSize"] = request.pageSize;
    query["Queue"] = request.queue;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["StartTimeFrom"] = request.startTimeFrom;
    query["StartTimeTo"] = request.startTimeTo;
    query["State"] = request.state;
    query["User"] = request.user;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ListApmApplication",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListApmApplicationResponse>(await this.callApi(params, req, runtime), new ListApmApplicationResponse({}));
  }

  async listApmApplication(request: ListApmApplicationRequest): Promise<ListApmApplicationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listApmApplicationWithOptions(request, runtime);
  }

  async listBackupsWithOptions(request: ListBackupsRequest, runtime: $Util.RuntimeOptions): Promise<ListBackupsResponse> {
    Util.validateModel(request);
    let query = { };
    query["BackupId"] = request.backupId;
    query["BackupPlanId"] = request.backupPlanId;
    query["BizId"] = request.bizId;
    query["ClusterId"] = request.clusterId;
    query["CurrentSize"] = request.currentSize;
    query["Id"] = request.id;
    query["Limit"] = request.limit;
    query["MetadataType"] = request.metadataType;
    query["OrderMode"] = request.orderMode;
    query["PageCount"] = request.pageCount;
    query["PageNumber"] = request.pageNumber;
    query["PageSize"] = request.pageSize;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["ServiceName"] = request.serviceName;
    query["Status"] = request.status;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ListBackups",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListBackupsResponse>(await this.callApi(params, req, runtime), new ListBackupsResponse({}));
  }

  async listBackups(request: ListBackupsRequest): Promise<ListBackupsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listBackupsWithOptions(request, runtime);
  }

  async listClusterHostWithOptions(request: ListClusterHostRequest, runtime: $Util.RuntimeOptions): Promise<ListClusterHostResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["ComponentName"] = request.componentName;
    query["GroupType"] = request.groupType;
    query["HostGroupId"] = request.hostGroupId;
    query["HostInstanceId"] = request.hostInstanceId;
    query["HostName"] = request.hostName;
    query["PageNumber"] = request.pageNumber;
    query["PageSize"] = request.pageSize;
    query["PrivateIp"] = request.privateIp;
    query["PublicIp"] = request.publicIp;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["StatusList"] = request.statusList;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ListClusterHost",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListClusterHostResponse>(await this.callApi(params, req, runtime), new ListClusterHostResponse({}));
  }

  async listClusterHost(request: ListClusterHostRequest): Promise<ListClusterHostResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listClusterHostWithOptions(request, runtime);
  }

  async listClusterHostComponentWithOptions(request: ListClusterHostComponentRequest, runtime: $Util.RuntimeOptions): Promise<ListClusterHostComponentResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["ComponentName"] = request.componentName;
    query["ComponentStatus"] = request.componentStatus;
    query["HostInstanceId"] = request.hostInstanceId;
    query["HostName"] = request.hostName;
    query["HostRole"] = request.hostRole;
    query["PageNumber"] = request.pageNumber;
    query["PageSize"] = request.pageSize;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["ServiceName"] = request.serviceName;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ListClusterHostComponent",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListClusterHostComponentResponse>(await this.callApi(params, req, runtime), new ListClusterHostComponentResponse({}));
  }

  async listClusterHostComponent(request: ListClusterHostComponentRequest): Promise<ListClusterHostComponentResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listClusterHostComponentWithOptions(request, runtime);
  }

  async listClusterHostGroupWithOptions(request: ListClusterHostGroupRequest, runtime: $Util.RuntimeOptions): Promise<ListClusterHostGroupResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["HostGroupId"] = request.hostGroupId;
    query["HostGroupName"] = request.hostGroupName;
    query["HostGroupType"] = request.hostGroupType;
    query["PageNumber"] = request.pageNumber;
    query["PageSize"] = request.pageSize;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["StatusList"] = request.statusList;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ListClusterHostGroup",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListClusterHostGroupResponse>(await this.callApi(params, req, runtime), new ListClusterHostGroupResponse({}));
  }

  async listClusterHostGroup(request: ListClusterHostGroupRequest): Promise<ListClusterHostGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listClusterHostGroupWithOptions(request, runtime);
  }

  async listClusterInstalledServiceWithOptions(request: ListClusterInstalledServiceRequest, runtime: $Util.RuntimeOptions): Promise<ListClusterInstalledServiceResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["PageNumber"] = request.pageNumber;
    query["PageSize"] = request.pageSize;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ListClusterInstalledService",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListClusterInstalledServiceResponse>(await this.callApi(params, req, runtime), new ListClusterInstalledServiceResponse({}));
  }

  async listClusterInstalledService(request: ListClusterInstalledServiceRequest): Promise<ListClusterInstalledServiceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listClusterInstalledServiceWithOptions(request, runtime);
  }

  async listClusterOperationWithOptions(request: ListClusterOperationRequest, runtime: $Util.RuntimeOptions): Promise<ListClusterOperationResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["OperationId"] = request.operationId;
    query["PageNumber"] = request.pageNumber;
    query["PageSize"] = request.pageSize;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["ServiceName"] = request.serviceName;
    query["Status"] = request.status;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ListClusterOperation",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListClusterOperationResponse>(await this.callApi(params, req, runtime), new ListClusterOperationResponse({}));
  }

  async listClusterOperation(request: ListClusterOperationRequest): Promise<ListClusterOperationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listClusterOperationWithOptions(request, runtime);
  }

  async listClusterOperationHostWithOptions(request: ListClusterOperationHostRequest, runtime: $Util.RuntimeOptions): Promise<ListClusterOperationHostResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["OperationId"] = request.operationId;
    query["PageNumber"] = request.pageNumber;
    query["PageSize"] = request.pageSize;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["Status"] = request.status;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ListClusterOperationHost",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListClusterOperationHostResponse>(await this.callApi(params, req, runtime), new ListClusterOperationHostResponse({}));
  }

  async listClusterOperationHost(request: ListClusterOperationHostRequest): Promise<ListClusterOperationHostResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listClusterOperationHostWithOptions(request, runtime);
  }

  async listClusterOperationHostTaskWithOptions(request: ListClusterOperationHostTaskRequest, runtime: $Util.RuntimeOptions): Promise<ListClusterOperationHostTaskResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["HostId"] = request.hostId;
    query["OperationId"] = request.operationId;
    query["PageNumber"] = request.pageNumber;
    query["PageSize"] = request.pageSize;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["Status"] = request.status;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ListClusterOperationHostTask",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListClusterOperationHostTaskResponse>(await this.callApi(params, req, runtime), new ListClusterOperationHostTaskResponse({}));
  }

  async listClusterOperationHostTask(request: ListClusterOperationHostTaskRequest): Promise<ListClusterOperationHostTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listClusterOperationHostTaskWithOptions(request, runtime);
  }

  async listClusterOperationTaskWithOptions(request: ListClusterOperationTaskRequest, runtime: $Util.RuntimeOptions): Promise<ListClusterOperationTaskResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["OperationId"] = request.operationId;
    query["PageNumber"] = request.pageNumber;
    query["PageSize"] = request.pageSize;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["Status"] = request.status;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ListClusterOperationTask",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListClusterOperationTaskResponse>(await this.callApi(params, req, runtime), new ListClusterOperationTaskResponse({}));
  }

  async listClusterOperationTask(request: ListClusterOperationTaskRequest): Promise<ListClusterOperationTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listClusterOperationTaskWithOptions(request, runtime);
  }

  async listClusterServiceWithOptions(request: ListClusterServiceRequest, runtime: $Util.RuntimeOptions): Promise<ListClusterServiceResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["PageNumber"] = request.pageNumber;
    query["PageSize"] = request.pageSize;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ListClusterService",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListClusterServiceResponse>(await this.callApi(params, req, runtime), new ListClusterServiceResponse({}));
  }

  async listClusterService(request: ListClusterServiceRequest): Promise<ListClusterServiceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listClusterServiceWithOptions(request, runtime);
  }

  async listClusterServiceComponentWithOptions(request: ListClusterServiceComponentRequest, runtime: $Util.RuntimeOptions): Promise<ListClusterServiceComponentResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["ComponentName"] = request.componentName;
    query["ComponentStatus"] = request.componentStatus;
    query["PageNumber"] = request.pageNumber;
    query["PageSize"] = request.pageSize;
    query["PodName"] = request.podName;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["ServiceName"] = request.serviceName;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ListClusterServiceComponent",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListClusterServiceComponentResponse>(await this.callApi(params, req, runtime), new ListClusterServiceComponentResponse({}));
  }

  async listClusterServiceComponent(request: ListClusterServiceComponentRequest): Promise<ListClusterServiceComponentResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listClusterServiceComponentWithOptions(request, runtime);
  }

  async listClusterServiceComponentHealthInfoWithOptions(request: ListClusterServiceComponentHealthInfoRequest, runtime: $Util.RuntimeOptions): Promise<ListClusterServiceComponentHealthInfoResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["ComponentName"] = request.componentName;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["ServiceName"] = request.serviceName;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ListClusterServiceComponentHealthInfo",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListClusterServiceComponentHealthInfoResponse>(await this.callApi(params, req, runtime), new ListClusterServiceComponentHealthInfoResponse({}));
  }

  async listClusterServiceComponentHealthInfo(request: ListClusterServiceComponentHealthInfoRequest): Promise<ListClusterServiceComponentHealthInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listClusterServiceComponentHealthInfoWithOptions(request, runtime);
  }

  async listClusterServiceConfigHistoryWithOptions(request: ListClusterServiceConfigHistoryRequest, runtime: $Util.RuntimeOptions): Promise<ListClusterServiceConfigHistoryResponse> {
    Util.validateModel(request);
    let query = { };
    query["Author"] = request.author;
    query["ClusterId"] = request.clusterId;
    query["Comment"] = request.comment;
    query["ConfigFileName"] = request.configFileName;
    query["ConfigItemKey"] = request.configItemKey;
    query["ConfigVersion"] = request.configVersion;
    query["HostGroupId"] = request.hostGroupId;
    query["HostInstanceId"] = request.hostInstanceId;
    query["PageNumber"] = request.pageNumber;
    query["PageSize"] = request.pageSize;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["ServiceName"] = request.serviceName;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ListClusterServiceConfigHistory",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListClusterServiceConfigHistoryResponse>(await this.callApi(params, req, runtime), new ListClusterServiceConfigHistoryResponse({}));
  }

  async listClusterServiceConfigHistory(request: ListClusterServiceConfigHistoryRequest): Promise<ListClusterServiceConfigHistoryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listClusterServiceConfigHistoryWithOptions(request, runtime);
  }

  async listClusterServiceQuickLinkWithOptions(request: ListClusterServiceQuickLinkRequest, runtime: $Util.RuntimeOptions): Promise<ListClusterServiceQuickLinkResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["DirectType"] = request.directType;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["ServiceName"] = request.serviceName;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ListClusterServiceQuickLink",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListClusterServiceQuickLinkResponse>(await this.callApi(params, req, runtime), new ListClusterServiceQuickLinkResponse({}));
  }

  async listClusterServiceQuickLink(request: ListClusterServiceQuickLinkRequest): Promise<ListClusterServiceQuickLinkResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listClusterServiceQuickLinkWithOptions(request, runtime);
  }

  async listClusterTemplatesWithOptions(request: ListClusterTemplatesRequest, runtime: $Util.RuntimeOptions): Promise<ListClusterTemplatesResponse> {
    Util.validateModel(request);
    let query = { };
    query["BizId"] = request.bizId;
    query["PageNumber"] = request.pageNumber;
    query["PageSize"] = request.pageSize;
    query["ProductType"] = request.productType;
    query["RegionId"] = request.regionId;
    query["ResourceGroupId"] = request.resourceGroupId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ListClusterTemplates",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListClusterTemplatesResponse>(await this.callApi(params, req, runtime), new ListClusterTemplatesResponse({}));
  }

  async listClusterTemplates(request: ListClusterTemplatesRequest): Promise<ListClusterTemplatesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listClusterTemplatesWithOptions(request, runtime);
  }

  async listClustersWithOptions(request: ListClustersRequest, runtime: $Util.RuntimeOptions): Promise<ListClustersResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterTypeList"] = request.clusterTypeList;
    query["CreateType"] = request.createType;
    query["DefaultStatus"] = request.defaultStatus;
    query["DepositType"] = request.depositType;
    query["ExpiredTagList"] = request.expiredTagList;
    query["IsDesc"] = request.isDesc;
    query["MachineType"] = request.machineType;
    query["Name"] = request.name;
    query["PageNumber"] = request.pageNumber;
    query["PageSize"] = request.pageSize;
    query["RegionId"] = request.regionId;
    query["ResourceGroupId"] = request.resourceGroupId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["StatusList"] = request.statusList;
    query["Tag"] = request.tag;
    query["VpcId"] = request.vpcId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ListClusters",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListClustersResponse>(await this.callApi(params, req, runtime), new ListClustersResponse({}));
  }

  async listClusters(request: ListClustersRequest): Promise<ListClustersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listClustersWithOptions(request, runtime);
  }

  async listDataSourceWithOptions(request: ListDataSourceRequest, runtime: $Util.RuntimeOptions): Promise<ListDataSourceResponse> {
    Util.validateModel(request);
    let query = { };
    query["CreateFrom"] = request.createFrom;
    query["Id"] = request.id;
    query["Name"] = request.name;
    query["PageNumber"] = request.pageNumber;
    query["PageSize"] = request.pageSize;
    query["ProjectId"] = request.projectId;
    query["RegionId"] = request.regionId;
    query["ResourceGroupId"] = request.resourceGroupId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["SourceType"] = request.sourceType;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ListDataSource",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListDataSourceResponse>(await this.callApi(params, req, runtime), new ListDataSourceResponse({}));
  }

  async listDataSource(request: ListDataSourceRequest): Promise<ListDataSourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDataSourceWithOptions(request, runtime);
  }

  async listDiskOpsEventsWithOptions(request: ListDiskOpsEventsRequest, runtime: $Util.RuntimeOptions): Promise<ListDiskOpsEventsResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["EndTime"] = request.endTime;
    query["PageNumber"] = request.pageNumber;
    query["PageSize"] = request.pageSize;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["StartTime"] = request.startTime;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ListDiskOpsEvents",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListDiskOpsEventsResponse>(await this.callApi(params, req, runtime), new ListDiskOpsEventsResponse({}));
  }

  async listDiskOpsEvents(request: ListDiskOpsEventsRequest): Promise<ListDiskOpsEventsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDiskOpsEventsWithOptions(request, runtime);
  }

  async listEmrAvailableConfigWithOptions(request: ListEmrAvailableConfigRequest, runtime: $Util.RuntimeOptions): Promise<ListEmrAvailableConfigResponse> {
    Util.validateModel(request);
    let query = { };
    query["RegionId"] = request.regionId;
    query["ResourceGroupId"] = request.resourceGroupId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ListEmrAvailableConfig",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListEmrAvailableConfigResponse>(await this.callApi(params, req, runtime), new ListEmrAvailableConfigResponse({}));
  }

  async listEmrAvailableConfig(request: ListEmrAvailableConfigRequest): Promise<ListEmrAvailableConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listEmrAvailableConfigWithOptions(request, runtime);
  }

  async listEmrAvailableResourceWithOptions(request: ListEmrAvailableResourceRequest, runtime: $Util.RuntimeOptions): Promise<ListEmrAvailableResourceResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["ClusterType"] = request.clusterType;
    query["DataDiskType"] = request.dataDiskType;
    query["DepositType"] = request.depositType;
    query["DestinationResource"] = request.destinationResource;
    query["EmrVersion"] = request.emrVersion;
    query["InstanceChargeType"] = request.instanceChargeType;
    query["InstanceType"] = request.instanceType;
    query["NetType"] = request.netType;
    query["RegionId"] = request.regionId;
    query["ResourceGroupId"] = request.resourceGroupId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["SpotStrategy"] = request.spotStrategy;
    query["SystemDiskType"] = request.systemDiskType;
    query["ZoneId"] = request.zoneId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ListEmrAvailableResource",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListEmrAvailableResourceResponse>(await this.callApi(params, req, runtime), new ListEmrAvailableResourceResponse({}));
  }

  async listEmrAvailableResource(request: ListEmrAvailableResourceRequest): Promise<ListEmrAvailableResourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listEmrAvailableResourceWithOptions(request, runtime);
  }

  async listEmrMainVersionWithOptions(request: ListEmrMainVersionRequest, runtime: $Util.RuntimeOptions): Promise<ListEmrMainVersionResponse> {
    Util.validateModel(request);
    let query = { };
    query["EmrVersion"] = request.emrVersion;
    query["PageNumber"] = request.pageNumber;
    query["PageSize"] = request.pageSize;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["StackName"] = request.stackName;
    query["StackVersion"] = request.stackVersion;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ListEmrMainVersion",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListEmrMainVersionResponse>(await this.callApi(params, req, runtime), new ListEmrMainVersionResponse({}));
  }

  async listEmrMainVersion(request: ListEmrMainVersionRequest): Promise<ListEmrMainVersionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listEmrMainVersionWithOptions(request, runtime);
  }

  async listExecutionPlanInstancesWithOptions(request: ListExecutionPlanInstancesRequest, runtime: $Util.RuntimeOptions): Promise<ListExecutionPlanInstancesResponse> {
    Util.validateModel(request);
    let query = { };
    query["ExecutionPlanIdList"] = request.executionPlanIdList;
    query["IsDesc"] = request.isDesc;
    query["OnlyLastInstance"] = request.onlyLastInstance;
    query["PageNumber"] = request.pageNumber;
    query["PageSize"] = request.pageSize;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["StatusList"] = request.statusList;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ListExecutionPlanInstances",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListExecutionPlanInstancesResponse>(await this.callApi(params, req, runtime), new ListExecutionPlanInstancesResponse({}));
  }

  async listExecutionPlanInstances(request: ListExecutionPlanInstancesRequest): Promise<ListExecutionPlanInstancesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listExecutionPlanInstancesWithOptions(request, runtime);
  }

  async listFlowWithOptions(request: ListFlowRequest, runtime: $Util.RuntimeOptions): Promise<ListFlowResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["Id"] = request.id;
    query["JobId"] = request.jobId;
    query["Name"] = request.name;
    query["PageNumber"] = request.pageNumber;
    query["PageSize"] = request.pageSize;
    query["Periodic"] = request.periodic;
    query["ProjectId"] = request.projectId;
    query["RegionId"] = request.regionId;
    query["Status"] = request.status;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ListFlow",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListFlowResponse>(await this.callApi(params, req, runtime), new ListFlowResponse({}));
  }

  async listFlow(request: ListFlowRequest): Promise<ListFlowResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listFlowWithOptions(request, runtime);
  }

  async listFlowCategoryWithOptions(request: ListFlowCategoryRequest, runtime: $Util.RuntimeOptions): Promise<ListFlowCategoryResponse> {
    Util.validateModel(request);
    let query = { };
    query["PageNumber"] = request.pageNumber;
    query["PageSize"] = request.pageSize;
    query["ParentId"] = request.parentId;
    query["ProjectId"] = request.projectId;
    query["RegionId"] = request.regionId;
    query["Root"] = request.root;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ListFlowCategory",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListFlowCategoryResponse>(await this.callApi(params, req, runtime), new ListFlowCategoryResponse({}));
  }

  async listFlowCategory(request: ListFlowCategoryRequest): Promise<ListFlowCategoryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listFlowCategoryWithOptions(request, runtime);
  }

  async listFlowClusterWithOptions(request: ListFlowClusterRequest, runtime: $Util.RuntimeOptions): Promise<ListFlowClusterResponse> {
    Util.validateModel(request);
    let query = { };
    query["PageNumber"] = request.pageNumber;
    query["PageSize"] = request.pageSize;
    query["ProjectId"] = request.projectId;
    query["RegionId"] = request.regionId;
    query["ResourceGroupId"] = request.resourceGroupId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ListFlowCluster",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListFlowClusterResponse>(await this.callApi(params, req, runtime), new ListFlowClusterResponse({}));
  }

  async listFlowCluster(request: ListFlowClusterRequest): Promise<ListFlowClusterResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listFlowClusterWithOptions(request, runtime);
  }

  async listFlowClusterAllWithOptions(request: ListFlowClusterAllRequest, runtime: $Util.RuntimeOptions): Promise<ListFlowClusterAllResponse> {
    Util.validateModel(request);
    let query = { };
    query["ProductType"] = request.productType;
    query["RegionId"] = request.regionId;
    query["ResourceGroupId"] = request.resourceGroupId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ListFlowClusterAll",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListFlowClusterAllResponse>(await this.callApi(params, req, runtime), new ListFlowClusterAllResponse({}));
  }

  async listFlowClusterAll(request: ListFlowClusterAllRequest): Promise<ListFlowClusterAllResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listFlowClusterAllWithOptions(request, runtime);
  }

  async listFlowClusterAllHostsWithOptions(request: ListFlowClusterAllHostsRequest, runtime: $Util.RuntimeOptions): Promise<ListFlowClusterAllHostsResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["ProjectId"] = request.projectId;
    query["RegionId"] = request.regionId;
    query["ResourceGroupId"] = request.resourceGroupId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ListFlowClusterAllHosts",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListFlowClusterAllHostsResponse>(await this.callApi(params, req, runtime), new ListFlowClusterAllHostsResponse({}));
  }

  async listFlowClusterAllHosts(request: ListFlowClusterAllHostsRequest): Promise<ListFlowClusterAllHostsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listFlowClusterAllHostsWithOptions(request, runtime);
  }

  async listFlowClusterHostWithOptions(request: ListFlowClusterHostRequest, runtime: $Util.RuntimeOptions): Promise<ListFlowClusterHostResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["ProjectId"] = request.projectId;
    query["RegionId"] = request.regionId;
    query["ResourceGroupId"] = request.resourceGroupId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ListFlowClusterHost",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListFlowClusterHostResponse>(await this.callApi(params, req, runtime), new ListFlowClusterHostResponse({}));
  }

  async listFlowClusterHost(request: ListFlowClusterHostRequest): Promise<ListFlowClusterHostResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listFlowClusterHostWithOptions(request, runtime);
  }

  async listFlowInstanceWithOptions(request: ListFlowInstanceRequest, runtime: $Util.RuntimeOptions): Promise<ListFlowInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    query["FlowId"] = request.flowId;
    query["FlowName"] = request.flowName;
    query["Id"] = request.id;
    query["InstanceId"] = request.instanceId;
    query["NodeInstanceId"] = request.nodeInstanceId;
    query["OrderBy"] = request.orderBy;
    query["OrderType"] = request.orderType;
    query["Owner"] = request.owner;
    query["PageNumber"] = request.pageNumber;
    query["PageSize"] = request.pageSize;
    query["ProjectId"] = request.projectId;
    query["RegionId"] = request.regionId;
    query["StatusList"] = request.statusList;
    query["TimeRange"] = request.timeRange;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ListFlowInstance",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListFlowInstanceResponse>(await this.callApi(params, req, runtime), new ListFlowInstanceResponse({}));
  }

  async listFlowInstance(request: ListFlowInstanceRequest): Promise<ListFlowInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listFlowInstanceWithOptions(request, runtime);
  }

  async listFlowJobWithOptions(request: ListFlowJobRequest, runtime: $Util.RuntimeOptions): Promise<ListFlowJobResponse> {
    Util.validateModel(request);
    let query = { };
    query["Adhoc"] = request.adhoc;
    query["Id"] = request.id;
    query["Name"] = request.name;
    query["PageNumber"] = request.pageNumber;
    query["PageSize"] = request.pageSize;
    query["ProjectId"] = request.projectId;
    query["RegionId"] = request.regionId;
    query["Type"] = request.type;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ListFlowJob",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListFlowJobResponse>(await this.callApi(params, req, runtime), new ListFlowJobResponse({}));
  }

  async listFlowJob(request: ListFlowJobRequest): Promise<ListFlowJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listFlowJobWithOptions(request, runtime);
  }

  async listFlowJobHistoryWithOptions(request: ListFlowJobHistoryRequest, runtime: $Util.RuntimeOptions): Promise<ListFlowJobHistoryResponse> {
    Util.validateModel(request);
    let query = { };
    query["Id"] = request.id;
    query["InstanceId"] = request.instanceId;
    query["JobType"] = request.jobType;
    query["PageNumber"] = request.pageNumber;
    query["PageSize"] = request.pageSize;
    query["ProjectId"] = request.projectId;
    query["RegionId"] = request.regionId;
    query["StatusList"] = request.statusList;
    query["TimeRange"] = request.timeRange;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ListFlowJobHistory",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListFlowJobHistoryResponse>(await this.callApi(params, req, runtime), new ListFlowJobHistoryResponse({}));
  }

  async listFlowJobHistory(request: ListFlowJobHistoryRequest): Promise<ListFlowJobHistoryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listFlowJobHistoryWithOptions(request, runtime);
  }

  async listFlowNodeInstanceWithOptions(request: ListFlowNodeInstanceRequest, runtime: $Util.RuntimeOptions): Promise<ListFlowNodeInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    query["OrderBy"] = request.orderBy;
    query["OrderType"] = request.orderType;
    query["PageNumber"] = request.pageNumber;
    query["PageSize"] = request.pageSize;
    query["ProjectId"] = request.projectId;
    query["RegionId"] = request.regionId;
    query["ResourceGroupId"] = request.resourceGroupId;
    query["StartTime"] = request.startTime;
    query["StatusList"] = request.statusList;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ListFlowNodeInstance",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListFlowNodeInstanceResponse>(await this.callApi(params, req, runtime), new ListFlowNodeInstanceResponse({}));
  }

  async listFlowNodeInstance(request: ListFlowNodeInstanceRequest): Promise<ListFlowNodeInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listFlowNodeInstanceWithOptions(request, runtime);
  }

  async listFlowNodeInstanceContainerStatusWithOptions(request: ListFlowNodeInstanceContainerStatusRequest, runtime: $Util.RuntimeOptions): Promise<ListFlowNodeInstanceContainerStatusResponse> {
    Util.validateModel(request);
    let query = { };
    query["NodeInstanceId"] = request.nodeInstanceId;
    query["PageNumber"] = request.pageNumber;
    query["PageSize"] = request.pageSize;
    query["ProjectId"] = request.projectId;
    query["RegionId"] = request.regionId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ListFlowNodeInstanceContainerStatus",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListFlowNodeInstanceContainerStatusResponse>(await this.callApi(params, req, runtime), new ListFlowNodeInstanceContainerStatusResponse({}));
  }

  async listFlowNodeInstanceContainerStatus(request: ListFlowNodeInstanceContainerStatusRequest): Promise<ListFlowNodeInstanceContainerStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listFlowNodeInstanceContainerStatusWithOptions(request, runtime);
  }

  async listFlowNodeSqlResultWithOptions(request: ListFlowNodeSqlResultRequest, runtime: $Util.RuntimeOptions): Promise<ListFlowNodeSqlResultResponse> {
    Util.validateModel(request);
    let query = { };
    query["Length"] = request.length;
    query["NodeInstanceId"] = request.nodeInstanceId;
    query["Offset"] = request.offset;
    query["ProjectId"] = request.projectId;
    query["RegionId"] = request.regionId;
    query["SqlIndex"] = request.sqlIndex;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ListFlowNodeSqlResult",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListFlowNodeSqlResultResponse>(await this.callApi(params, req, runtime), new ListFlowNodeSqlResultResponse({}));
  }

  async listFlowNodeSqlResult(request: ListFlowNodeSqlResultRequest): Promise<ListFlowNodeSqlResultResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listFlowNodeSqlResultWithOptions(request, runtime);
  }

  async listFlowProjectWithOptions(request: ListFlowProjectRequest, runtime: $Util.RuntimeOptions): Promise<ListFlowProjectResponse> {
    Util.validateModel(request);
    let query = { };
    query["Name"] = request.name;
    query["PageNumber"] = request.pageNumber;
    query["PageSize"] = request.pageSize;
    query["ProductType"] = request.productType;
    query["ProjectId"] = request.projectId;
    query["RegionId"] = request.regionId;
    query["ResourceGroupId"] = request.resourceGroupId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ListFlowProject",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListFlowProjectResponse>(await this.callApi(params, req, runtime), new ListFlowProjectResponse({}));
  }

  async listFlowProject(request: ListFlowProjectRequest): Promise<ListFlowProjectResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listFlowProjectWithOptions(request, runtime);
  }

  async listFlowProjectClusterSettingWithOptions(request: ListFlowProjectClusterSettingRequest, runtime: $Util.RuntimeOptions): Promise<ListFlowProjectClusterSettingResponse> {
    Util.validateModel(request);
    let query = { };
    query["PageNumber"] = request.pageNumber;
    query["PageSize"] = request.pageSize;
    query["ProjectId"] = request.projectId;
    query["RegionId"] = request.regionId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ListFlowProjectClusterSetting",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListFlowProjectClusterSettingResponse>(await this.callApi(params, req, runtime), new ListFlowProjectClusterSettingResponse({}));
  }

  async listFlowProjectClusterSetting(request: ListFlowProjectClusterSettingRequest): Promise<ListFlowProjectClusterSettingResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listFlowProjectClusterSettingWithOptions(request, runtime);
  }

  async listFlowProjectUserWithOptions(request: ListFlowProjectUserRequest, runtime: $Util.RuntimeOptions): Promise<ListFlowProjectUserResponse> {
    Util.validateModel(request);
    let query = { };
    query["PageNumber"] = request.pageNumber;
    query["PageSize"] = request.pageSize;
    query["ProjectId"] = request.projectId;
    query["RegionId"] = request.regionId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ListFlowProjectUser",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListFlowProjectUserResponse>(await this.callApi(params, req, runtime), new ListFlowProjectUserResponse({}));
  }

  async listFlowProjectUser(request: ListFlowProjectUserRequest): Promise<ListFlowProjectUserResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listFlowProjectUserWithOptions(request, runtime);
  }

  async listJobExecutionInstancesWithOptions(request: ListJobExecutionInstancesRequest, runtime: $Util.RuntimeOptions): Promise<ListJobExecutionInstancesResponse> {
    Util.validateModel(request);
    let query = { };
    query["ExecutionPlanInstanceId"] = request.executionPlanInstanceId;
    query["IsDesc"] = request.isDesc;
    query["PageNumber"] = request.pageNumber;
    query["PageSize"] = request.pageSize;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ListJobExecutionInstances",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListJobExecutionInstancesResponse>(await this.callApi(params, req, runtime), new ListJobExecutionInstancesResponse({}));
  }

  async listJobExecutionInstances(request: ListJobExecutionInstancesRequest): Promise<ListJobExecutionInstancesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listJobExecutionInstancesWithOptions(request, runtime);
  }

  async listJobsWithOptions(request: ListJobsRequest, runtime: $Util.RuntimeOptions): Promise<ListJobsResponse> {
    Util.validateModel(request);
    let query = { };
    query["IsDesc"] = request.isDesc;
    query["PageNumber"] = request.pageNumber;
    query["PageSize"] = request.pageSize;
    query["QueryString"] = request.queryString;
    query["QueryType"] = request.queryType;
    query["RegionId"] = request.regionId;
    query["ResourceGroupId"] = request.resourceGroupId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ListJobs",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListJobsResponse>(await this.callApi(params, req, runtime), new ListJobsResponse({}));
  }

  async listJobs(request: ListJobsRequest): Promise<ListJobsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listJobsWithOptions(request, runtime);
  }

  async listLibrariesWithOptions(request: ListLibrariesRequest, runtime: $Util.RuntimeOptions): Promise<ListLibrariesResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterBizId"] = request.clusterBizId;
    query["CurrentSize"] = request.currentSize;
    query["Limit"] = request.limit;
    query["OrderField"] = request.orderField;
    query["OrderMode"] = request.orderMode;
    query["PageCount"] = request.pageCount;
    query["PageNumber"] = request.pageNumber;
    query["PageSize"] = request.pageSize;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ListLibraries",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListLibrariesResponse>(await this.callApi(params, req, runtime), new ListLibrariesResponse({}));
  }

  async listLibraries(request: ListLibrariesRequest): Promise<ListLibrariesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listLibrariesWithOptions(request, runtime);
  }

  async listLibraryInstallTasksWithOptions(request: ListLibraryInstallTasksRequest, runtime: $Util.RuntimeOptions): Promise<ListLibraryInstallTasksResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterBizId"] = request.clusterBizId;
    query["CurrentSize"] = request.currentSize;
    query["LibraryBizId"] = request.libraryBizId;
    query["Limit"] = request.limit;
    query["OrderField"] = request.orderField;
    query["OrderMode"] = request.orderMode;
    query["PageCount"] = request.pageCount;
    query["PageNumber"] = request.pageNumber;
    query["PageSize"] = request.pageSize;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ListLibraryInstallTasks",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListLibraryInstallTasksResponse>(await this.callApi(params, req, runtime), new ListLibraryInstallTasksResponse({}));
  }

  async listLibraryInstallTasks(request: ListLibraryInstallTasksRequest): Promise<ListLibraryInstallTasksResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listLibraryInstallTasksWithOptions(request, runtime);
  }

  async listLibraryStatusWithOptions(request: ListLibraryStatusRequest, runtime: $Util.RuntimeOptions): Promise<ListLibraryStatusResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterBizId"] = request.clusterBizId;
    query["CurrentSize"] = request.currentSize;
    query["LibraryBizId"] = request.libraryBizId;
    query["Limit"] = request.limit;
    query["OrderField"] = request.orderField;
    query["OrderMode"] = request.orderMode;
    query["PageCount"] = request.pageCount;
    query["PageNumber"] = request.pageNumber;
    query["PageSize"] = request.pageSize;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ListLibraryStatus",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListLibraryStatusResponse>(await this.callApi(params, req, runtime), new ListLibraryStatusResponse({}));
  }

  async listLibraryStatus(request: ListLibraryStatusRequest): Promise<ListLibraryStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listLibraryStatusWithOptions(request, runtime);
  }

  async listLocalDiskComponentInfoWithOptions(request: ListLocalDiskComponentInfoRequest, runtime: $Util.RuntimeOptions): Promise<ListLocalDiskComponentInfoResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["InstanceId"] = request.instanceId;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ListLocalDiskComponentInfo",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListLocalDiskComponentInfoResponse>(await this.callApi(params, req, runtime), new ListLocalDiskComponentInfoResponse({}));
  }

  async listLocalDiskComponentInfo(request: ListLocalDiskComponentInfoRequest): Promise<ListLocalDiskComponentInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listLocalDiskComponentInfoWithOptions(request, runtime);
  }

  async listResourcePoolWithOptions(request: ListResourcePoolRequest, runtime: $Util.RuntimeOptions): Promise<ListResourcePoolResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["PageNumber"] = request.pageNumber;
    query["PageSize"] = request.pageSize;
    query["PoolType"] = request.poolType;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ListResourcePool",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListResourcePoolResponse>(await this.callApi(params, req, runtime), new ListResourcePoolResponse({}));
  }

  async listResourcePool(request: ListResourcePoolRequest): Promise<ListResourcePoolResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listResourcePoolWithOptions(request, runtime);
  }

  async listRolesWithOptions(request: ListRolesRequest, runtime: $Util.RuntimeOptions): Promise<ListRolesResponse> {
    Util.validateModel(request);
    let query = { };
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["ResourceType"] = request.resourceType;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ListRoles",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListRolesResponse>(await this.callApi(params, req, runtime), new ListRolesResponse({}));
  }

  async listRoles(request: ListRolesRequest): Promise<ListRolesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listRolesWithOptions(request, runtime);
  }

  async listScalingActivityV2WithOptions(request: ListScalingActivityV2Request, runtime: $Util.RuntimeOptions): Promise<ListScalingActivityV2Response> {
    Util.validateModel(request);
    let query = { };
    query["ClusterBizId"] = request.clusterBizId;
    query["CurrentSize"] = request.currentSize;
    query["HostGroupId"] = request.hostGroupId;
    query["HostGroupName"] = request.hostGroupName;
    query["Limit"] = request.limit;
    query["OrderField"] = request.orderField;
    query["OrderMode"] = request.orderMode;
    query["PageCount"] = request.pageCount;
    query["PageNumber"] = request.pageNumber;
    query["PageSize"] = request.pageSize;
    query["RegionId"] = request.regionId;
    query["ResourceGroupId"] = request.resourceGroupId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["ScalingGroupBizId"] = request.scalingGroupBizId;
    query["ScalingRuleName"] = request.scalingRuleName;
    query["Status"] = request.status;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ListScalingActivityV2",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListScalingActivityV2Response>(await this.callApi(params, req, runtime), new ListScalingActivityV2Response({}));
  }

  async listScalingActivityV2(request: ListScalingActivityV2Request): Promise<ListScalingActivityV2Response> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listScalingActivityV2WithOptions(request, runtime);
  }

  async listScalingConfigItemV2WithOptions(request: ListScalingConfigItemV2Request, runtime: $Util.RuntimeOptions): Promise<ListScalingConfigItemV2Response> {
    Util.validateModel(request);
    let query = { };
    query["ConfigItemType"] = request.configItemType;
    query["PageNumber"] = request.pageNumber;
    query["PageSize"] = request.pageSize;
    query["RegionId"] = request.regionId;
    query["ResourceGroupId"] = request.resourceGroupId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["ScalingGroupBizId"] = request.scalingGroupBizId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ListScalingConfigItemV2",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListScalingConfigItemV2Response>(await this.callApi(params, req, runtime), new ListScalingConfigItemV2Response({}));
  }

  async listScalingConfigItemV2(request: ListScalingConfigItemV2Request): Promise<ListScalingConfigItemV2Response> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listScalingConfigItemV2WithOptions(request, runtime);
  }

  async listScalingGroupV2WithOptions(request: ListScalingGroupV2Request, runtime: $Util.RuntimeOptions): Promise<ListScalingGroupV2Response> {
    Util.validateModel(request);
    let query = { };
    query["ClusterBizId"] = request.clusterBizId;
    query["CurrentSize"] = request.currentSize;
    query["Limit"] = request.limit;
    query["OrderField"] = request.orderField;
    query["OrderMode"] = request.orderMode;
    query["PageCount"] = request.pageCount;
    query["PageNumber"] = request.pageNumber;
    query["PageSize"] = request.pageSize;
    query["RegionId"] = request.regionId;
    query["ResourceGroupId"] = request.resourceGroupId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ListScalingGroupV2",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListScalingGroupV2Response>(await this.callApi(params, req, runtime), new ListScalingGroupV2Response({}));
  }

  async listScalingGroupV2(request: ListScalingGroupV2Request): Promise<ListScalingGroupV2Response> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listScalingGroupV2WithOptions(request, runtime);
  }

  async listSecurityGroupWithOptions(request: ListSecurityGroupRequest, runtime: $Util.RuntimeOptions): Promise<ListSecurityGroupResponse> {
    Util.validateModel(request);
    let query = { };
    query["DepositType"] = request.depositType;
    query["NetType"] = request.netType;
    query["ProductType"] = request.productType;
    query["RegionId"] = request.regionId;
    query["VpcId"] = request.vpcId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ListSecurityGroup",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListSecurityGroupResponse>(await this.callApi(params, req, runtime), new ListSecurityGroupResponse({}));
  }

  async listSecurityGroup(request: ListSecurityGroupRequest): Promise<ListSecurityGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listSecurityGroupWithOptions(request, runtime);
  }

  async listStackWithOptions(request: ListStackRequest, runtime: $Util.RuntimeOptions): Promise<ListStackResponse> {
    Util.validateModel(request);
    let query = { };
    query["PageNumber"] = request.pageNumber;
    query["PageSize"] = request.pageSize;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["StackName"] = request.stackName;
    query["StackVersion"] = request.stackVersion;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ListStack",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListStackResponse>(await this.callApi(params, req, runtime), new ListStackResponse({}));
  }

  async listStack(request: ListStackRequest): Promise<ListStackResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listStackWithOptions(request, runtime);
  }

  async listTagKeysWithOptions(request: ListTagKeysRequest, runtime: $Util.RuntimeOptions): Promise<ListTagKeysResponse> {
    Util.validateModel(request);
    let query = { };
    query["Category"] = request.category;
    query["NextToken"] = request.nextToken;
    query["PageSize"] = request.pageSize;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["ResourceType"] = request.resourceType;
    query["Scope"] = request.scope;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ListTagKeys",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListTagKeysResponse>(await this.callApi(params, req, runtime), new ListTagKeysResponse({}));
  }

  async listTagKeys(request: ListTagKeysRequest): Promise<ListTagKeysResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listTagKeysWithOptions(request, runtime);
  }

  async listTagResourcesWithOptions(request: ListTagResourcesRequest, runtime: $Util.RuntimeOptions): Promise<ListTagResourcesResponse> {
    Util.validateModel(request);
    let query = { };
    query["NextToken"] = request.nextToken;
    query["RegionId"] = request.regionId;
    query["ResourceId"] = request.resourceId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["ResourceType"] = request.resourceType;
    query["Tag"] = request.tag;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ListTagResources",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListTagResourcesResponse>(await this.callApi(params, req, runtime), new ListTagResourcesResponse({}));
  }

  async listTagResources(request: ListTagResourcesRequest): Promise<ListTagResourcesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listTagResourcesWithOptions(request, runtime);
  }

  async listTagValuesWithOptions(request: ListTagValuesRequest, runtime: $Util.RuntimeOptions): Promise<ListTagValuesResponse> {
    Util.validateModel(request);
    let query = { };
    query["Key"] = request.key;
    query["NextToken"] = request.nextToken;
    query["PageSize"] = request.pageSize;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["ResourceType"] = request.resourceType;
    query["Scope"] = request.scope;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ListTagValues",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListTagValuesResponse>(await this.callApi(params, req, runtime), new ListTagValuesResponse({}));
  }

  async listTagValues(request: ListTagValuesRequest): Promise<ListTagValuesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listTagValuesWithOptions(request, runtime);
  }

  async listUsersWithOptions(request: ListUsersRequest, runtime: $Util.RuntimeOptions): Promise<ListUsersResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["Type"] = request.type;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ListUsers",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListUsersResponse>(await this.callApi(params, req, runtime), new ListUsersResponse({}));
  }

  async listUsers(request: ListUsersRequest): Promise<ListUsersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listUsersWithOptions(request, runtime);
  }

  async listVswitchWithOptions(request: ListVswitchRequest, runtime: $Util.RuntimeOptions): Promise<ListVswitchResponse> {
    Util.validateModel(request);
    let query = { };
    query["DepositType"] = request.depositType;
    query["ProductType"] = request.productType;
    query["RegionId"] = request.regionId;
    query["VpcId"] = request.vpcId;
    query["ZoneId"] = request.zoneId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ListVswitch",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ListVswitchResponse>(await this.callApi(params, req, runtime), new ListVswitchResponse({}));
  }

  async listVswitch(request: ListVswitchRequest): Promise<ListVswitchResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listVswitchWithOptions(request, runtime);
  }

  async modifyClusterBootstrapActionWithOptions(request: ModifyClusterBootstrapActionRequest, runtime: $Util.RuntimeOptions): Promise<ModifyClusterBootstrapActionResponse> {
    Util.validateModel(request);
    let query = { };
    query["BootstrapAction"] = request.bootstrapAction;
    query["ClusterId"] = request.clusterId;
    query["Id"] = request.id;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ModifyClusterBootstrapAction",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ModifyClusterBootstrapActionResponse>(await this.callApi(params, req, runtime), new ModifyClusterBootstrapActionResponse({}));
  }

  async modifyClusterBootstrapAction(request: ModifyClusterBootstrapActionRequest): Promise<ModifyClusterBootstrapActionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyClusterBootstrapActionWithOptions(request, runtime);
  }

  async modifyClusterHostGroupWithOptions(request: ModifyClusterHostGroupRequest, runtime: $Util.RuntimeOptions): Promise<ModifyClusterHostGroupResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["Comment"] = request.comment;
    query["HostGroupId"] = request.hostGroupId;
    query["HostGroupName"] = request.hostGroupName;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["SecurityGroupId"] = request.securityGroupId;
    query["VswitchId"] = request.vswitchId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ModifyClusterHostGroup",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ModifyClusterHostGroupResponse>(await this.callApi(params, req, runtime), new ModifyClusterHostGroupResponse({}));
  }

  async modifyClusterHostGroup(request: ModifyClusterHostGroupRequest): Promise<ModifyClusterHostGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyClusterHostGroupWithOptions(request, runtime);
  }

  async modifyClusterMetaCollectWithOptions(request: ModifyClusterMetaCollectRequest, runtime: $Util.RuntimeOptions): Promise<ModifyClusterMetaCollectResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["SwitchOn"] = request.switchOn;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ModifyClusterMetaCollect",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ModifyClusterMetaCollectResponse>(await this.callApi(params, req, runtime), new ModifyClusterMetaCollectResponse({}));
  }

  async modifyClusterMetaCollect(request: ModifyClusterMetaCollectRequest): Promise<ModifyClusterMetaCollectResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyClusterMetaCollectWithOptions(request, runtime);
  }

  async modifyClusterNameWithOptions(request: ModifyClusterNameRequest, runtime: $Util.RuntimeOptions): Promise<ModifyClusterNameResponse> {
    Util.validateModel(request);
    let query = { };
    query["Id"] = request.id;
    query["Name"] = request.name;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ModifyClusterName",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ModifyClusterNameResponse>(await this.callApi(params, req, runtime), new ModifyClusterNameResponse({}));
  }

  async modifyClusterName(request: ModifyClusterNameRequest): Promise<ModifyClusterNameResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyClusterNameWithOptions(request, runtime);
  }

  async modifyClusterSecurityGroupRuleWithOptions(request: ModifyClusterSecurityGroupRuleRequest, runtime: $Util.RuntimeOptions): Promise<ModifyClusterSecurityGroupRuleResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["IpProtocol"] = request.ipProtocol;
    query["ModifyType"] = request.modifyType;
    query["NicType"] = request.nicType;
    query["PortRange"] = request.portRange;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["WhiteIp"] = request.whiteIp;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ModifyClusterSecurityGroupRule",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ModifyClusterSecurityGroupRuleResponse>(await this.callApi(params, req, runtime), new ModifyClusterSecurityGroupRuleResponse({}));
  }

  async modifyClusterSecurityGroupRule(request: ModifyClusterSecurityGroupRuleRequest): Promise<ModifyClusterSecurityGroupRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyClusterSecurityGroupRuleWithOptions(request, runtime);
  }

  async modifyClusterServiceConfigWithOptions(request: ModifyClusterServiceConfigRequest, runtime: $Util.RuntimeOptions): Promise<ModifyClusterServiceConfigResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["Comment"] = request.comment;
    query["ConfigParams"] = request.configParams;
    query["ConfigType"] = request.configType;
    query["CustomConfigParams"] = request.customConfigParams;
    query["GatewayClusterIdList"] = request.gatewayClusterIdList;
    query["GroupId"] = request.groupId;
    query["HostInstanceId"] = request.hostInstanceId;
    query["RefreshHostConfig"] = request.refreshHostConfig;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["ServiceName"] = request.serviceName;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ModifyClusterServiceConfig",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ModifyClusterServiceConfigResponse>(await this.callApi(params, req, runtime), new ModifyClusterServiceConfigResponse({}));
  }

  async modifyClusterServiceConfig(request: ModifyClusterServiceConfigRequest): Promise<ModifyClusterServiceConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyClusterServiceConfigWithOptions(request, runtime);
  }

  async modifyClusterTemplateWithOptions(request: ModifyClusterTemplateRequest, runtime: $Util.RuntimeOptions): Promise<ModifyClusterTemplateResponse> {
    Util.validateModel(request);
    let query = { };
    query["AutoRenew"] = request.autoRenew;
    query["BizId"] = request.bizId;
    query["BootstrapAction"] = request.bootstrapAction;
    query["ChargeType"] = request.chargeType;
    query["ClusterType"] = request.clusterType;
    query["Config"] = request.config;
    query["Configurations"] = request.configurations;
    query["DepositType"] = request.depositType;
    query["EasEnable"] = request.easEnable;
    query["EmrVer"] = request.emrVer;
    query["HighAvailabilityEnable"] = request.highAvailabilityEnable;
    query["HostGroup"] = request.hostGroup;
    query["InitCustomHiveMetaDb"] = request.initCustomHiveMetaDb;
    query["InstanceGeneration"] = request.instanceGeneration;
    query["IoOptimized"] = request.ioOptimized;
    query["IsOpenPublicIp"] = request.isOpenPublicIp;
    query["KeyPairName"] = request.keyPairName;
    query["LogPath"] = request.logPath;
    query["MachineType"] = request.machineType;
    query["MasterPwd"] = request.masterPwd;
    query["MetaStoreConf"] = request.metaStoreConf;
    query["MetaStoreType"] = request.metaStoreType;
    query["NetType"] = request.netType;
    query["OptionSoftWareList"] = request.optionSoftWareList;
    query["Period"] = request.period;
    query["RegionId"] = request.regionId;
    query["ResourceGroupId"] = request.resourceGroupId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["SecurityGroupId"] = request.securityGroupId;
    query["SecurityGroupName"] = request.securityGroupName;
    query["SshEnable"] = request.sshEnable;
    query["Tag"] = request.tag;
    query["TemplateName"] = request.templateName;
    query["UseCustomHiveMetaDb"] = request.useCustomHiveMetaDb;
    query["UseLocalMetaDb"] = request.useLocalMetaDb;
    query["UserDefinedEmrEcsRole"] = request.userDefinedEmrEcsRole;
    query["VSwitchId"] = request.vSwitchId;
    query["VpcId"] = request.vpcId;
    query["ZoneId"] = request.zoneId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ModifyClusterTemplate",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ModifyClusterTemplateResponse>(await this.callApi(params, req, runtime), new ModifyClusterTemplateResponse({}));
  }

  async modifyClusterTemplate(request: ModifyClusterTemplateRequest): Promise<ModifyClusterTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyClusterTemplateWithOptions(request, runtime);
  }

  async modifyExecutionPlanWithOptions(request: ModifyExecutionPlanRequest, runtime: $Util.RuntimeOptions): Promise<ModifyExecutionPlanResponse> {
    Util.validateModel(request);
    let query = { };
    query["BootstrapAction"] = request.bootstrapAction;
    query["ClusterId"] = request.clusterId;
    query["ClusterName"] = request.clusterName;
    query["ClusterType"] = request.clusterType;
    query["Config"] = request.config;
    query["Configurations"] = request.configurations;
    query["CreateClusterOnDemand"] = request.createClusterOnDemand;
    query["DayOfMonth"] = request.dayOfMonth;
    query["DayOfWeek"] = request.dayOfWeek;
    query["EasEnable"] = request.easEnable;
    query["EcsOrder"] = request.ecsOrder;
    query["EmrVer"] = request.emrVer;
    query["ExecutionPlanVersion"] = request.executionPlanVersion;
    query["HighAvailabilityEnable"] = request.highAvailabilityEnable;
    query["Id"] = request.id;
    query["InitCustomHiveMetaDB"] = request.initCustomHiveMetaDB;
    query["InstanceGeneration"] = request.instanceGeneration;
    query["IoOptimized"] = request.ioOptimized;
    query["IsOpenPublicIp"] = request.isOpenPublicIp;
    query["JobIdList"] = request.jobIdList;
    query["LogEnable"] = request.logEnable;
    query["LogPath"] = request.logPath;
    query["Name"] = request.name;
    query["NetType"] = request.netType;
    query["OptionSoftWareList"] = request.optionSoftWareList;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["SecurityGroupId"] = request.securityGroupId;
    query["StartTime"] = request.startTime;
    query["Strategy"] = request.strategy;
    query["TimeInterval"] = request.timeInterval;
    query["TimeUnit"] = request.timeUnit;
    query["UseCustomHiveMetaDB"] = request.useCustomHiveMetaDB;
    query["UseLocalMetaDb"] = request.useLocalMetaDb;
    query["UserDefinedEmrEcsRole"] = request.userDefinedEmrEcsRole;
    query["VSwitchId"] = request.vSwitchId;
    query["VpcId"] = request.vpcId;
    query["WorkflowDefinition"] = request.workflowDefinition;
    query["ZoneId"] = request.zoneId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ModifyExecutionPlan",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ModifyExecutionPlanResponse>(await this.callApi(params, req, runtime), new ModifyExecutionPlanResponse({}));
  }

  async modifyExecutionPlan(request: ModifyExecutionPlanRequest): Promise<ModifyExecutionPlanResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyExecutionPlanWithOptions(request, runtime);
  }

  async modifyFlowWithOptions(request: ModifyFlowRequest, runtime: $Util.RuntimeOptions): Promise<ModifyFlowResponse> {
    Util.validateModel(request);
    let query = { };
    query["AlertConf"] = request.alertConf;
    query["AlertDingDingGroupBizId"] = request.alertDingDingGroupBizId;
    query["AlertUserGroupBizId"] = request.alertUserGroupBizId;
    query["Application"] = request.application;
    query["ClusterId"] = request.clusterId;
    query["CreateCluster"] = request.createCluster;
    query["CronExpr"] = request.cronExpr;
    query["Description"] = request.description;
    query["EndSchedule"] = request.endSchedule;
    query["HostName"] = request.hostName;
    query["Id"] = request.id;
    query["Lifecycle"] = request.lifecycle;
    query["LogArchiveLocation"] = request.logArchiveLocation;
    query["Name"] = request.name;
    query["Namespace"] = request.namespace;
    query["ParentCategory"] = request.parentCategory;
    query["ParentFlowList"] = request.parentFlowList;
    query["Periodic"] = request.periodic;
    query["ProjectId"] = request.projectId;
    query["RegionId"] = request.regionId;
    query["StartSchedule"] = request.startSchedule;
    query["Status"] = request.status;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ModifyFlow",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ModifyFlowResponse>(await this.callApi(params, req, runtime), new ModifyFlowResponse({}));
  }

  async modifyFlow(request: ModifyFlowRequest): Promise<ModifyFlowResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyFlowWithOptions(request, runtime);
  }

  async modifyFlowCategoryWithOptions(request: ModifyFlowCategoryRequest, runtime: $Util.RuntimeOptions): Promise<ModifyFlowCategoryResponse> {
    Util.validateModel(request);
    let query = { };
    query["Id"] = request.id;
    query["Name"] = request.name;
    query["ParentId"] = request.parentId;
    query["ProjectId"] = request.projectId;
    query["RegionId"] = request.regionId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ModifyFlowCategory",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ModifyFlowCategoryResponse>(await this.callApi(params, req, runtime), new ModifyFlowCategoryResponse({}));
  }

  async modifyFlowCategory(request: ModifyFlowCategoryRequest): Promise<ModifyFlowCategoryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyFlowCategoryWithOptions(request, runtime);
  }

  async modifyFlowForWebWithOptions(request: ModifyFlowForWebRequest, runtime: $Util.RuntimeOptions): Promise<ModifyFlowForWebResponse> {
    Util.validateModel(request);
    let query = { };
    query["AlertConf"] = request.alertConf;
    query["AlertDingDingGroupBizId"] = request.alertDingDingGroupBizId;
    query["AlertUserGroupBizId"] = request.alertUserGroupBizId;
    query["ClusterId"] = request.clusterId;
    query["CreateCluster"] = request.createCluster;
    query["CronExpr"] = request.cronExpr;
    query["Description"] = request.description;
    query["EndSchedule"] = request.endSchedule;
    query["Graph"] = request.graph;
    query["HostName"] = request.hostName;
    query["Id"] = request.id;
    query["Lifecycle"] = request.lifecycle;
    query["LogArchiveLocation"] = request.logArchiveLocation;
    query["Name"] = request.name;
    query["Namespace"] = request.namespace;
    query["ParentCategory"] = request.parentCategory;
    query["ParentFlowList"] = request.parentFlowList;
    query["Periodic"] = request.periodic;
    query["ProjectId"] = request.projectId;
    query["RegionId"] = request.regionId;
    query["StartSchedule"] = request.startSchedule;
    query["Status"] = request.status;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ModifyFlowForWeb",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ModifyFlowForWebResponse>(await this.callApi(params, req, runtime), new ModifyFlowForWebResponse({}));
  }

  async modifyFlowForWeb(request: ModifyFlowForWebRequest): Promise<ModifyFlowForWebResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyFlowForWebWithOptions(request, runtime);
  }

  async modifyFlowJobWithOptions(request: ModifyFlowJobRequest, runtime: $Util.RuntimeOptions): Promise<ModifyFlowJobResponse> {
    Util.validateModel(request);
    let query = { };
    query["AlertConf"] = request.alertConf;
    query["ClusterId"] = request.clusterId;
    query["CustomVariables"] = request.customVariables;
    query["Description"] = request.description;
    query["EnvConf"] = request.envConf;
    query["FailAct"] = request.failAct;
    query["Id"] = request.id;
    query["MaxRetry"] = request.maxRetry;
    query["MaxRunningTimeSec"] = request.maxRunningTimeSec;
    query["Mode"] = request.mode;
    query["MonitorConf"] = request.monitorConf;
    query["Name"] = request.name;
    query["ParamConf"] = request.paramConf;
    query["Params"] = request.params;
    query["ProjectId"] = request.projectId;
    query["RegionId"] = request.regionId;
    query["ResourceList"] = request.resourceList;
    query["RetryInterval"] = request.retryInterval;
    query["RetryPolicy"] = request.retryPolicy;
    query["RunConf"] = request.runConf;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ModifyFlowJob",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ModifyFlowJobResponse>(await this.callApi(params, req, runtime), new ModifyFlowJobResponse({}));
  }

  async modifyFlowJob(request: ModifyFlowJobRequest): Promise<ModifyFlowJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyFlowJobWithOptions(request, runtime);
  }

  async modifyFlowProjectWithOptions(request: ModifyFlowProjectRequest, runtime: $Util.RuntimeOptions): Promise<ModifyFlowProjectResponse> {
    Util.validateModel(request);
    let query = { };
    query["Description"] = request.description;
    query["Name"] = request.name;
    query["ProjectId"] = request.projectId;
    query["RegionId"] = request.regionId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ModifyFlowProject",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ModifyFlowProjectResponse>(await this.callApi(params, req, runtime), new ModifyFlowProjectResponse({}));
  }

  async modifyFlowProject(request: ModifyFlowProjectRequest): Promise<ModifyFlowProjectResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyFlowProjectWithOptions(request, runtime);
  }

  async modifyFlowProjectClusterSettingWithOptions(request: ModifyFlowProjectClusterSettingRequest, runtime: $Util.RuntimeOptions): Promise<ModifyFlowProjectClusterSettingResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["DefaultQueue"] = request.defaultQueue;
    query["DefaultUser"] = request.defaultUser;
    query["HostList"] = request.hostList;
    query["ProjectId"] = request.projectId;
    query["QueueList"] = request.queueList;
    query["RegionId"] = request.regionId;
    query["UserList"] = request.userList;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ModifyFlowProjectClusterSetting",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ModifyFlowProjectClusterSettingResponse>(await this.callApi(params, req, runtime), new ModifyFlowProjectClusterSettingResponse({}));
  }

  async modifyFlowProjectClusterSetting(request: ModifyFlowProjectClusterSettingRequest): Promise<ModifyFlowProjectClusterSettingResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyFlowProjectClusterSettingWithOptions(request, runtime);
  }

  async modifyJobWithOptions(request: ModifyJobRequest, runtime: $Util.RuntimeOptions): Promise<ModifyJobResponse> {
    Util.validateModel(request);
    let query = { };
    query["FailAct"] = request.failAct;
    query["Id"] = request.id;
    query["MaxRetry"] = request.maxRetry;
    query["Name"] = request.name;
    query["RegionId"] = request.regionId;
    query["ResourceGroupId"] = request.resourceGroupId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["RetryInterval"] = request.retryInterval;
    query["RunParameter"] = request.runParameter;
    query["Type"] = request.type;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ModifyJob",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ModifyJobResponse>(await this.callApi(params, req, runtime), new ModifyJobResponse({}));
  }

  async modifyJob(request: ModifyJobRequest): Promise<ModifyJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyJobWithOptions(request, runtime);
  }

  async modifyResourcePoolWithOptions(request: ModifyResourcePoolRequest, runtime: $Util.RuntimeOptions): Promise<ModifyResourcePoolResponse> {
    Util.validateModel(request);
    let query = { };
    query["Active"] = request.active;
    query["ClusterId"] = request.clusterId;
    query["Config"] = request.config;
    query["Id"] = request.id;
    query["Name"] = request.name;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["Yarnsiteconfig"] = request.yarnsiteconfig;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ModifyResourcePool",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ModifyResourcePoolResponse>(await this.callApi(params, req, runtime), new ModifyResourcePoolResponse({}));
  }

  async modifyResourcePool(request: ModifyResourcePoolRequest): Promise<ModifyResourcePoolResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyResourcePoolWithOptions(request, runtime);
  }

  async modifyResourcePoolSchedulerTypeWithOptions(request: ModifyResourcePoolSchedulerTypeRequest, runtime: $Util.RuntimeOptions): Promise<ModifyResourcePoolSchedulerTypeResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["SchedulerType"] = request.schedulerType;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ModifyResourcePoolSchedulerType",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ModifyResourcePoolSchedulerTypeResponse>(await this.callApi(params, req, runtime), new ModifyResourcePoolSchedulerTypeResponse({}));
  }

  async modifyResourcePoolSchedulerType(request: ModifyResourcePoolSchedulerTypeRequest): Promise<ModifyResourcePoolSchedulerTypeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyResourcePoolSchedulerTypeWithOptions(request, runtime);
  }

  async modifyResourceQueueWithOptions(request: ModifyResourceQueueRequest, runtime: $Util.RuntimeOptions): Promise<ModifyResourceQueueResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["Config"] = request.config;
    query["Id"] = request.id;
    query["Leaf"] = request.leaf;
    query["Name"] = request.name;
    query["ParentQueueId"] = request.parentQueueId;
    query["QualifiedName"] = request.qualifiedName;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["ResourcePoolId"] = request.resourcePoolId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ModifyResourceQueue",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ModifyResourceQueueResponse>(await this.callApi(params, req, runtime), new ModifyResourceQueueResponse({}));
  }

  async modifyResourceQueue(request: ModifyResourceQueueRequest): Promise<ModifyResourceQueueResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyResourceQueueWithOptions(request, runtime);
  }

  async modifyScalingConfigItemV2WithOptions(request: ModifyScalingConfigItemV2Request, runtime: $Util.RuntimeOptions): Promise<ModifyScalingConfigItemV2Response> {
    Util.validateModel(request);
    let query = { };
    query["ConfigItemBizId"] = request.configItemBizId;
    query["ConfigItemInformation"] = request.configItemInformation;
    query["ConfigItemType"] = request.configItemType;
    query["RegionId"] = request.regionId;
    query["ResourceGroupId"] = request.resourceGroupId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["ScalingGroupBizId"] = request.scalingGroupBizId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ModifyScalingConfigItemV2",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ModifyScalingConfigItemV2Response>(await this.callApi(params, req, runtime), new ModifyScalingConfigItemV2Response({}));
  }

  async modifyScalingConfigItemV2(request: ModifyScalingConfigItemV2Request): Promise<ModifyScalingConfigItemV2Response> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyScalingConfigItemV2WithOptions(request, runtime);
  }

  async modifyScalingGroupV2WithOptions(request: ModifyScalingGroupV2Request, runtime: $Util.RuntimeOptions): Promise<ModifyScalingGroupV2Response> {
    Util.validateModel(request);
    let query = { };
    query["Description"] = request.description;
    query["Name"] = request.name;
    query["RegionId"] = request.regionId;
    query["ResourceGroupId"] = request.resourceGroupId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["ScalingGroupBizId"] = request.scalingGroupBizId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ModifyScalingGroupV2",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ModifyScalingGroupV2Response>(await this.callApi(params, req, runtime), new ModifyScalingGroupV2Response({}));
  }

  async modifyScalingGroupV2(request: ModifyScalingGroupV2Request): Promise<ModifyScalingGroupV2Response> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyScalingGroupV2WithOptions(request, runtime);
  }

  async modifyScalingRuleWithOptions(request: ModifyScalingRuleRequest, runtime: $Util.RuntimeOptions): Promise<ModifyScalingRuleResponse> {
    Util.validateModel(request);
    let query = { };
    query["AdjustmentType"] = request.adjustmentType;
    query["AdjustmentValue"] = request.adjustmentValue;
    query["CloudWatchTrigger"] = request.cloudWatchTrigger;
    query["ClusterId"] = request.clusterId;
    query["Cooldown"] = request.cooldown;
    query["HostGroupId"] = request.hostGroupId;
    query["LaunchExpirationTime"] = request.launchExpirationTime;
    query["LaunchTime"] = request.launchTime;
    query["RecurrenceEndTime"] = request.recurrenceEndTime;
    query["RecurrenceType"] = request.recurrenceType;
    query["RecurrenceValue"] = request.recurrenceValue;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["RuleName"] = request.ruleName;
    query["ScalingRuleId"] = request.scalingRuleId;
    query["SchedulerTrigger"] = request.schedulerTrigger;
    query["TimeoutWithGrace"] = request.timeoutWithGrace;
    query["WithGrace"] = request.withGrace;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ModifyScalingRule",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ModifyScalingRuleResponse>(await this.callApi(params, req, runtime), new ModifyScalingRuleResponse({}));
  }

  async modifyScalingRule(request: ModifyScalingRuleRequest): Promise<ModifyScalingRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyScalingRuleWithOptions(request, runtime);
  }

  async modifyScalingTaskGroupWithOptions(request: ModifyScalingTaskGroupRequest, runtime: $Util.RuntimeOptions): Promise<ModifyScalingTaskGroupResponse> {
    Util.validateModel(request);
    let query = { };
    query["ActiveRuleCategory"] = request.activeRuleCategory;
    query["ClusterId"] = request.clusterId;
    query["DefaultCooldown"] = request.defaultCooldown;
    query["HostGroupId"] = request.hostGroupId;
    query["MaxSize"] = request.maxSize;
    query["MinSize"] = request.minSize;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["TimeoutWithGrace"] = request.timeoutWithGrace;
    query["WithGrace"] = request.withGrace;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ModifyScalingTaskGroup",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ModifyScalingTaskGroupResponse>(await this.callApi(params, req, runtime), new ModifyScalingTaskGroupResponse({}));
  }

  async modifyScalingTaskGroup(request: ModifyScalingTaskGroupRequest): Promise<ModifyScalingTaskGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyScalingTaskGroupWithOptions(request, runtime);
  }

  async queryEntityWithOptions(request: QueryEntityRequest, runtime: $Util.RuntimeOptions): Promise<QueryEntityResponse> {
    Util.validateModel(request);
    let query = { };
    query["Category"] = request.category;
    query["Description"] = request.description;
    query["Id"] = request.id;
    query["Name"] = request.name;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "QueryEntity",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<QueryEntityResponse>(await this.callApi(params, req, runtime), new QueryEntityResponse({}));
  }

  async queryEntity(request: QueryEntityRequest): Promise<QueryEntityResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryEntityWithOptions(request, runtime);
  }

  async queryTagWithOptions(request: QueryTagRequest, runtime: $Util.RuntimeOptions): Promise<QueryTagResponse> {
    Util.validateModel(request);
    let query = { };
    query["EntityId"] = request.entityId;
    query["EntityType"] = request.entityType;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["TagId"] = request.tagId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "QueryTag",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<QueryTagResponse>(await this.callApi(params, req, runtime), new QueryTagResponse({}));
  }

  async queryTag(request: QueryTagRequest): Promise<QueryTagResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryTagWithOptions(request, runtime);
  }

  async refreshClusterResourcePoolWithOptions(request: RefreshClusterResourcePoolRequest, runtime: $Util.RuntimeOptions): Promise<RefreshClusterResourcePoolResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["ResourcePoolId"] = request.resourcePoolId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "RefreshClusterResourcePool",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<RefreshClusterResourcePoolResponse>(await this.callApi(params, req, runtime), new RefreshClusterResourcePoolResponse({}));
  }

  async refreshClusterResourcePool(request: RefreshClusterResourcePoolRequest): Promise<RefreshClusterResourcePoolResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.refreshClusterResourcePoolWithOptions(request, runtime);
  }

  async releaseClusterWithOptions(request: ReleaseClusterRequest, runtime: $Util.RuntimeOptions): Promise<ReleaseClusterResponse> {
    Util.validateModel(request);
    let query = { };
    query["ForceRelease"] = request.forceRelease;
    query["Id"] = request.id;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ReleaseCluster",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ReleaseClusterResponse>(await this.callApi(params, req, runtime), new ReleaseClusterResponse({}));
  }

  async releaseCluster(request: ReleaseClusterRequest): Promise<ReleaseClusterResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.releaseClusterWithOptions(request, runtime);
  }

  async releaseClusterHostGroupWithOptions(request: ReleaseClusterHostGroupRequest, runtime: $Util.RuntimeOptions): Promise<ReleaseClusterHostGroupResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["HostGroupId"] = request.hostGroupId;
    query["InstanceIdList"] = request.instanceIdList;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ReleaseClusterHostGroup",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ReleaseClusterHostGroupResponse>(await this.callApi(params, req, runtime), new ReleaseClusterHostGroupResponse({}));
  }

  async releaseClusterHostGroup(request: ReleaseClusterHostGroupRequest): Promise<ReleaseClusterHostGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.releaseClusterHostGroupWithOptions(request, runtime);
  }

  async removeScalingConfigItemV2WithOptions(request: RemoveScalingConfigItemV2Request, runtime: $Util.RuntimeOptions): Promise<RemoveScalingConfigItemV2Response> {
    Util.validateModel(request);
    let query = { };
    query["ConfigItemBizId"] = request.configItemBizId;
    query["ConfigItemType"] = request.configItemType;
    query["RegionId"] = request.regionId;
    query["ResourceGroupId"] = request.resourceGroupId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["ScalingGroupBizId"] = request.scalingGroupBizId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "RemoveScalingConfigItemV2",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<RemoveScalingConfigItemV2Response>(await this.callApi(params, req, runtime), new RemoveScalingConfigItemV2Response({}));
  }

  async removeScalingConfigItemV2(request: RemoveScalingConfigItemV2Request): Promise<RemoveScalingConfigItemV2Response> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.removeScalingConfigItemV2WithOptions(request, runtime);
  }

  async rerunFlowWithOptions(request: RerunFlowRequest, runtime: $Util.RuntimeOptions): Promise<RerunFlowResponse> {
    Util.validateModel(request);
    let query = { };
    query["FlowInstanceId"] = request.flowInstanceId;
    query["ProjectId"] = request.projectId;
    query["ReRunFail"] = request.reRunFail;
    query["RegionId"] = request.regionId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "RerunFlow",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<RerunFlowResponse>(await this.callApi(params, req, runtime), new RerunFlowResponse({}));
  }

  async rerunFlow(request: RerunFlowRequest): Promise<RerunFlowResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.rerunFlowWithOptions(request, runtime);
  }

  async resizeClusterV2WithOptions(request: ResizeClusterV2Request, runtime: $Util.RuntimeOptions): Promise<ResizeClusterV2Response> {
    Util.validateModel(request);
    let query = { };
    query["AutoPayOrder"] = request.autoPayOrder;
    query["ClusterId"] = request.clusterId;
    query["HostComponentInfo"] = request.hostComponentInfo;
    query["HostGroup"] = request.hostGroup;
    query["IsOpenPublicIp"] = request.isOpenPublicIp;
    query["PromotionInfo"] = request.promotionInfo;
    query["RegionId"] = request.regionId;
    query["VswitchId"] = request.vswitchId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ResizeClusterV2",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ResizeClusterV2Response>(await this.callApi(params, req, runtime), new ResizeClusterV2Response({}));
  }

  async resizeClusterV2(request: ResizeClusterV2Request): Promise<ResizeClusterV2Response> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.resizeClusterV2WithOptions(request, runtime);
  }

  async resumeExecutionPlanSchedulerWithOptions(request: ResumeExecutionPlanSchedulerRequest, runtime: $Util.RuntimeOptions): Promise<ResumeExecutionPlanSchedulerResponse> {
    Util.validateModel(request);
    let query = { };
    query["Id"] = request.id;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ResumeExecutionPlanScheduler",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ResumeExecutionPlanSchedulerResponse>(await this.callApi(params, req, runtime), new ResumeExecutionPlanSchedulerResponse({}));
  }

  async resumeExecutionPlanScheduler(request: ResumeExecutionPlanSchedulerRequest): Promise<ResumeExecutionPlanSchedulerResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.resumeExecutionPlanSchedulerWithOptions(request, runtime);
  }

  async resumeFlowWithOptions(request: ResumeFlowRequest, runtime: $Util.RuntimeOptions): Promise<ResumeFlowResponse> {
    Util.validateModel(request);
    let query = { };
    query["FlowInstanceId"] = request.flowInstanceId;
    query["ProjectId"] = request.projectId;
    query["RegionId"] = request.regionId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "ResumeFlow",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<ResumeFlowResponse>(await this.callApi(params, req, runtime), new ResumeFlowResponse({}));
  }

  async resumeFlow(request: ResumeFlowRequest): Promise<ResumeFlowResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.resumeFlowWithOptions(request, runtime);
  }

  async retryOperationWithOptions(request: RetryOperationRequest, runtime: $Util.RuntimeOptions): Promise<RetryOperationResponse> {
    Util.validateModel(request);
    let query = { };
    query["OperationId"] = request.operationId;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "RetryOperation",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<RetryOperationResponse>(await this.callApi(params, req, runtime), new RetryOperationResponse({}));
  }

  async retryOperation(request: RetryOperationRequest): Promise<RetryOperationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.retryOperationWithOptions(request, runtime);
  }

  async runClusterServiceActionWithOptions(request: RunClusterServiceActionRequest, runtime: $Util.RuntimeOptions): Promise<RunClusterServiceActionResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["Comment"] = request.comment;
    query["ComponentNameList"] = request.componentNameList;
    query["CustomCommand"] = request.customCommand;
    query["CustomParams"] = request.customParams;
    query["ExecuteStrategy"] = request.executeStrategy;
    query["HostGroupIdList"] = request.hostGroupIdList;
    query["HostIdList"] = request.hostIdList;
    query["Interval"] = request.interval;
    query["IsRolling"] = request.isRolling;
    query["NodeCountPerBatch"] = request.nodeCountPerBatch;
    query["OnlyRestartStaleConfigNodes"] = request.onlyRestartStaleConfigNodes;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["ServiceActionName"] = request.serviceActionName;
    query["ServiceName"] = request.serviceName;
    query["TotlerateFailCount"] = request.totlerateFailCount;
    query["TurnOnMaintenanceMode"] = request.turnOnMaintenanceMode;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "RunClusterServiceAction",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<RunClusterServiceActionResponse>(await this.callApi(params, req, runtime), new RunClusterServiceActionResponse({}));
  }

  async runClusterServiceAction(request: RunClusterServiceActionRequest): Promise<RunClusterServiceActionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.runClusterServiceActionWithOptions(request, runtime);
  }

  async runDiskOpsActivityWithOptions(request: RunDiskOpsActivityRequest, runtime: $Util.RuntimeOptions): Promise<RunDiskOpsActivityResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["CurrentStage"] = request.currentStage;
    query["CurrentState"] = request.currentState;
    query["DiskId"] = request.diskId;
    query["EventId"] = request.eventId;
    query["InstanceId"] = request.instanceId;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "RunDiskOpsActivity",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<RunDiskOpsActivityResponse>(await this.callApi(params, req, runtime), new RunDiskOpsActivityResponse({}));
  }

  async runDiskOpsActivity(request: RunDiskOpsActivityRequest): Promise<RunDiskOpsActivityResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.runDiskOpsActivityWithOptions(request, runtime);
  }

  async runExecutionPlanWithOptions(tmpReq: RunExecutionPlanRequest, runtime: $Util.RuntimeOptions): Promise<RunExecutionPlanResponse> {
    Util.validateModel(tmpReq);
    let request = new RunExecutionPlanShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.arguments)) {
      request.argumentsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.arguments, "Arguments", "json");
    }

    let query = { };
    query["Arguments"] = request.argumentsShrink;
    query["Id"] = request.id;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "RunExecutionPlan",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<RunExecutionPlanResponse>(await this.callApi(params, req, runtime), new RunExecutionPlanResponse({}));
  }

  async runExecutionPlan(request: RunExecutionPlanRequest): Promise<RunExecutionPlanResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.runExecutionPlanWithOptions(request, runtime);
  }

  async runScalingActionV2WithOptions(request: RunScalingActionV2Request, runtime: $Util.RuntimeOptions): Promise<RunScalingActionV2Response> {
    Util.validateModel(request);
    let query = { };
    query["ActionParam"] = request.actionParam;
    query["RegionId"] = request.regionId;
    query["ResourceGroupId"] = request.resourceGroupId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["ScalingActionType"] = request.scalingActionType;
    query["ScalingGroupBizId"] = request.scalingGroupBizId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "RunScalingActionV2",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<RunScalingActionV2Response>(await this.callApi(params, req, runtime), new RunScalingActionV2Response({}));
  }

  async runScalingActionV2(request: RunScalingActionV2Request): Promise<RunScalingActionV2Response> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.runScalingActionV2WithOptions(request, runtime);
  }

  async searchLogWithOptions(request: SearchLogRequest, runtime: $Util.RuntimeOptions): Promise<SearchLogResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["FromTimestamp"] = request.fromTimestamp;
    query["HostInnerIp"] = request.hostInnerIp;
    query["HostName"] = request.hostName;
    query["Line"] = request.line;
    query["LogstoreName"] = request.logstoreName;
    query["Offset"] = request.offset;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["Reverse"] = request.reverse;
    query["SlsQueryString"] = request.slsQueryString;
    query["ToTimestamp"] = request.toTimestamp;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "SearchLog",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<SearchLogResponse>(await this.callApi(params, req, runtime), new SearchLogResponse({}));
  }

  async searchLog(request: SearchLogRequest): Promise<SearchLogResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.searchLogWithOptions(request, runtime);
  }

  async startFlowWithOptions(request: StartFlowRequest, runtime: $Util.RuntimeOptions): Promise<StartFlowResponse> {
    Util.validateModel(request);
    let query = { };
    query["FlowInstanceId"] = request.flowInstanceId;
    query["ProjectId"] = request.projectId;
    query["RegionId"] = request.regionId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "StartFlow",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<StartFlowResponse>(await this.callApi(params, req, runtime), new StartFlowResponse({}));
  }

  async startFlow(request: StartFlowRequest): Promise<StartFlowResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.startFlowWithOptions(request, runtime);
  }

  async submitFlowWithOptions(request: SubmitFlowRequest, runtime: $Util.RuntimeOptions): Promise<SubmitFlowResponse> {
    Util.validateModel(request);
    let query = { };
    query["Conf"] = request.conf;
    query["FlowId"] = request.flowId;
    query["ProjectId"] = request.projectId;
    query["RegionId"] = request.regionId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "SubmitFlow",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<SubmitFlowResponse>(await this.callApi(params, req, runtime), new SubmitFlowResponse({}));
  }

  async submitFlow(request: SubmitFlowRequest): Promise<SubmitFlowResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.submitFlowWithOptions(request, runtime);
  }

  async submitFlowJobWithOptions(request: SubmitFlowJobRequest, runtime: $Util.RuntimeOptions): Promise<SubmitFlowJobResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterId"] = request.clusterId;
    query["Conf"] = request.conf;
    query["HostName"] = request.hostName;
    query["JobId"] = request.jobId;
    query["JobInstanceId"] = request.jobInstanceId;
    query["Namespace"] = request.namespace;
    query["ProjectId"] = request.projectId;
    query["RegionId"] = request.regionId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "SubmitFlowJob",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<SubmitFlowJobResponse>(await this.callApi(params, req, runtime), new SubmitFlowJobResponse({}));
  }

  async submitFlowJob(request: SubmitFlowJobRequest): Promise<SubmitFlowJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.submitFlowJobWithOptions(request, runtime);
  }

  async suspendExecutionPlanSchedulerWithOptions(request: SuspendExecutionPlanSchedulerRequest, runtime: $Util.RuntimeOptions): Promise<SuspendExecutionPlanSchedulerResponse> {
    Util.validateModel(request);
    let query = { };
    query["Id"] = request.id;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "SuspendExecutionPlanScheduler",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<SuspendExecutionPlanSchedulerResponse>(await this.callApi(params, req, runtime), new SuspendExecutionPlanSchedulerResponse({}));
  }

  async suspendExecutionPlanScheduler(request: SuspendExecutionPlanSchedulerRequest): Promise<SuspendExecutionPlanSchedulerResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.suspendExecutionPlanSchedulerWithOptions(request, runtime);
  }

  async suspendFlowWithOptions(request: SuspendFlowRequest, runtime: $Util.RuntimeOptions): Promise<SuspendFlowResponse> {
    Util.validateModel(request);
    let query = { };
    query["FlowInstanceId"] = request.flowInstanceId;
    query["ProjectId"] = request.projectId;
    query["RegionId"] = request.regionId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "SuspendFlow",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<SuspendFlowResponse>(await this.callApi(params, req, runtime), new SuspendFlowResponse({}));
  }

  async suspendFlow(request: SuspendFlowRequest): Promise<SuspendFlowResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.suspendFlowWithOptions(request, runtime);
  }

  async tagResourcesWithOptions(request: TagResourcesRequest, runtime: $Util.RuntimeOptions): Promise<TagResourcesResponse> {
    Util.validateModel(request);
    let query = { };
    query["RegionId"] = request.regionId;
    query["ResourceId"] = request.resourceId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["ResourceType"] = request.resourceType;
    query["Tag"] = request.tag;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "TagResources",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<TagResourcesResponse>(await this.callApi(params, req, runtime), new TagResourcesResponse({}));
  }

  async tagResources(request: TagResourcesRequest): Promise<TagResourcesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.tagResourcesWithOptions(request, runtime);
  }

  async uninstallLibrariesWithOptions(request: UninstallLibrariesRequest, runtime: $Util.RuntimeOptions): Promise<UninstallLibrariesResponse> {
    Util.validateModel(request);
    let query = { };
    query["ClusterBizIdList"] = request.clusterBizIdList;
    query["LibraryBizId"] = request.libraryBizId;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "UninstallLibraries",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<UninstallLibrariesResponse>(await this.callApi(params, req, runtime), new UninstallLibrariesResponse({}));
  }

  async uninstallLibraries(request: UninstallLibrariesRequest): Promise<UninstallLibrariesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.uninstallLibrariesWithOptions(request, runtime);
  }

  async untagResourcesWithOptions(request: UntagResourcesRequest, runtime: $Util.RuntimeOptions): Promise<UntagResourcesResponse> {
    Util.validateModel(request);
    let query = { };
    query["All"] = request.all;
    query["RegionId"] = request.regionId;
    query["ResourceId"] = request.resourceId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["ResourceType"] = request.resourceType;
    query["TagKey"] = request.tagKey;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "UntagResources",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<UntagResourcesResponse>(await this.callApi(params, req, runtime), new UntagResourcesResponse({}));
  }

  async untagResources(request: UntagResourcesRequest): Promise<UntagResourcesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.untagResourcesWithOptions(request, runtime);
  }

  async updateDataSourceWithOptions(request: UpdateDataSourceRequest, runtime: $Util.RuntimeOptions): Promise<UpdateDataSourceResponse> {
    Util.validateModel(request);
    let query = { };
    query["Conf"] = request.conf;
    query["Description"] = request.description;
    query["Id"] = request.id;
    query["Name"] = request.name;
    query["RegionId"] = request.regionId;
    query["ResourceGroupId"] = request.resourceGroupId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "UpdateDataSource",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<UpdateDataSourceResponse>(await this.callApi(params, req, runtime), new UpdateDataSourceResponse({}));
  }

  async updateDataSource(request: UpdateDataSourceRequest): Promise<UpdateDataSourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateDataSourceWithOptions(request, runtime);
  }

  async updateLibraryInstallTaskStatusWithOptions(request: UpdateLibraryInstallTaskStatusRequest, runtime: $Util.RuntimeOptions): Promise<UpdateLibraryInstallTaskStatusResponse> {
    Util.validateModel(request);
    let query = { };
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["Status"] = request.status;
    query["TaskBizId"] = request.taskBizId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "UpdateLibraryInstallTaskStatus",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<UpdateLibraryInstallTaskStatusResponse>(await this.callApi(params, req, runtime), new UpdateLibraryInstallTaskStatusResponse({}));
  }

  async updateLibraryInstallTaskStatus(request: UpdateLibraryInstallTaskStatusRequest): Promise<UpdateLibraryInstallTaskStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateLibraryInstallTaskStatusWithOptions(request, runtime);
  }

  async updateTagWithOptions(request: UpdateTagRequest, runtime: $Util.RuntimeOptions): Promise<UpdateTagResponse> {
    Util.validateModel(request);
    let query = { };
    query["Category"] = request.category;
    query["Description"] = request.description;
    query["Id"] = request.id;
    query["Name"] = request.name;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "UpdateTag",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<UpdateTagResponse>(await this.callApi(params, req, runtime), new UpdateTagResponse({}));
  }

  async updateTag(request: UpdateTagRequest): Promise<UpdateTagResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateTagWithOptions(request, runtime);
  }

  async updateUserWithOptions(request: UpdateUserRequest, runtime: $Util.RuntimeOptions): Promise<UpdateUserResponse> {
    Util.validateModel(request);
    let query = { };
    query["AliyunUserId"] = request.aliyunUserId;
    query["Description"] = request.description;
    query["GroupIdList"] = request.groupIdList;
    query["RegionId"] = request.regionId;
    query["ResourceOwnerId"] = request.resourceOwnerId;
    query["RoleIdList"] = request.roleIdList;
    query["Status"] = request.status;
    query["UserAccountParamList"] = request.userAccountParamList;
    query["UserName"] = request.userName;
    query["UserType"] = request.userType;
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: Util.toMap(request),
    });
    let params = new $OpenApi.Params({
      action: "UpdateUser",
      version: "2016-04-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "json",
      bodyType: "json",
    });
    return $tea.cast<UpdateUserResponse>(await this.callApi(params, req, runtime), new UpdateUserResponse({}));
  }

  async updateUser(request: UpdateUserRequest): Promise<UpdateUserResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateUserWithOptions(request, runtime);
  }

}
