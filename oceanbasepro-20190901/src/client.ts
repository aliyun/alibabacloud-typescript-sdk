// This file is auto-generated, don't edit it
/**
 */
import Util, * as $Util from '@alicloud/tea-util';
import OpenApi, * as $OpenApi from '@alicloud/openapi-client';
import OpenApiUtil from '@alicloud/openapi-util';
import EndpointUtil from '@alicloud/endpoint-util';
import * as $tea from '@alicloud/tea-typescript';

export class DataExtraInfoSubCondsValue extends $tea.Model {
  /**
   * @example
   * tenant_name
   */
  tenantName?: string;
  /**
   * @example
   * db_name
   */
  database?: string;
  /**
   * @example
   * dest_db
   */
  destDatabase?: string;
  /**
   * @example
   * table_name
   */
  tableName?: string;
  /**
   * @example
   * dest_name
   */
  destName?: string;
  /**
   * @example
   * id>1
   */
  whereClause?: string;
  filterColumns?: string[];
  shardColumns?: string[];
  /**
   * @example
   * null
   */
  logicTableId?: string;
  /**
   * @example
   * null
   */
  sourceEndpointId?: string;
  /**
   * @example
   * null
   */
  sourceClientId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantName: 'TenantName',
      database: 'Database',
      destDatabase: 'DestDatabase',
      tableName: 'TableName',
      destName: 'DestName',
      whereClause: 'WhereClause',
      filterColumns: 'FilterColumns',
      shardColumns: 'ShardColumns',
      logicTableId: 'LogicTableId',
      sourceEndpointId: 'SourceEndpointId',
      sourceClientId: 'SourceClientId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantName: 'string',
      database: 'string',
      destDatabase: 'string',
      tableName: 'string',
      destName: 'string',
      whereClause: 'string',
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      logicTableId: 'string',
      sourceEndpointId: 'string',
      sourceClientId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DataExtraInfoSubDbsValue extends $tea.Model {
  /**
   * @example
   * cluster_name
   */
  clusterName?: string;
  /**
   * @example
   * tenant_name
   */
  tenantName?: string;
  /**
   * @example
   * null
   */
  databaseId?: string;
  /**
   * @example
   * db_name
   */
  databaseName?: string;
  /**
   * @example
   * mapped_db
   */
  mappingDatabaseName?: string;
  /**
   * @example
   * null
   */
  sourceClientId?: string;
  tables?: DataExtraInfoSubDbsValueTables[];
  static names(): { [key: string]: string } {
    return {
      clusterName: 'ClusterName',
      tenantName: 'TenantName',
      databaseId: 'DatabaseId',
      databaseName: 'DatabaseName',
      mappingDatabaseName: 'MappingDatabaseName',
      sourceClientId: 'SourceClientId',
      tables: 'Tables',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterName: 'string',
      tenantName: 'string',
      databaseId: 'string',
      databaseName: 'string',
      mappingDatabaseName: 'string',
      sourceClientId: 'string',
      tables: { 'type': 'array', 'itemType': DataExtraInfoSubDbsValueTables },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchKillProcessListRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The list of sessions to close.
   * 
   * This parameter is required.
   * 
   * @example
   * [{"ProxySessId":"752113700739156671","SessionId":3221555062,"ServerIp":"10.***.**.***"}]
   */
  sessionList?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * t33h8y08k****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      sessionList: 'SessionList',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      sessionList: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchKillProcessListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The array of the return result.
   */
  data?: BatchKillProcessListResponseBodyData[];
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': BatchKillProcessListResponseBodyData },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchKillProcessListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: BatchKillProcessListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchKillProcessListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchKillSessionListRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The list of sessions, which is concatenated with commas.
   * >The session information is obtained from the result returned by the DescribeSessionList API.
   * 
   * This parameter is required.
   * 
   * @example
   * 342,354,343
   */
  sessionList?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * t4louaeei****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      sessionList: 'SessionList',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      sessionList: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchKillSessionListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchKillSessionListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: BatchKillSessionListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchKillSessionListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelProjectModifyRecordRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 344000005
   */
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelProjectModifyRecordResponseBody extends $tea.Model {
  /**
   * @example
   * Contact the administrator.
   */
  advice?: string;
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  /**
   * @example
   * 30
   */
  cost?: string;
  /**
   * @example
   * null
   */
  data?: any;
  errorDetail?: CancelProjectModifyRecordResponseBodyErrorDetail;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 100
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      cost: 'Cost',
      data: 'Data',
      errorDetail: 'ErrorDetail',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      cost: 'string',
      data: 'any',
      errorDetail: CancelProjectModifyRecordResponseBodyErrorDetail,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelProjectModifyRecordResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CancelProjectModifyRecordResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CancelProjectModifyRecordResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateBackupSetDownloadLinkRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * bak-6f****
   */
  backupSetId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * i-bp67acfmxazb4p****
   */
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      backupSetId: 'BackupSetId',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      backupSetId: 'string',
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateBackupSetDownloadLinkResponseBody extends $tea.Model {
  /**
   * @example
   * 10000***67
   */
  downloadTaskId?: number;
  /**
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      downloadTaskId: 'DownloadTaskId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      downloadTaskId: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateBackupSetDownloadLinkResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateBackupSetDownloadLinkResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateBackupSetDownloadLinkResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDatabaseRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * 123e4567-e89b-12d3-a456-426655440000
   */
  clientToken?: string;
  /**
   * @remarks
   * The encoding standard of the database.
   * For more information, see the Charset field returned by the DescribeCharset operation.
   * 
   * @example
   * utf8mb4_general_ci
   */
  collation?: string;
  /**
   * @remarks
   * Alibaba Cloud CLI
   * 
   * This parameter is required.
   * 
   * @example
   * sms_pre
   */
  databaseName?: string;
  /**
   * @remarks
   * The operation that you want to perform.   
   * Set the value to **CreateDatabase**.
   * 
   * @example
   * this is a test database
   */
  description?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * utf8mb4
   */
  encoding?: string;
  /**
   * @remarks
   * The collation.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The name of the database.   
   * You cannot use reserved keywords, such as test and mysql.
   * 
   * This parameter is required.
   * 
   * @example
   * ob2mr3oae0****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      clientToken: 'ClientToken',
      collation: 'Collation',
      databaseName: 'DatabaseName',
      description: 'Description',
      encoding: 'Encoding',
      instanceId: 'InstanceId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clientToken: 'string',
      collation: 'string',
      databaseName: 'string',
      description: 'string',
      encoding: 'string',
      instanceId: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDatabaseResponseBody extends $tea.Model {
  /**
   * @remarks
   * CreateDatabase
   * 
   * @example
   * sms_pre
   */
  databaseName?: string;
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      databaseName: 'DatabaseName',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      databaseName: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDatabaseResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateDatabaseResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateDatabaseResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateInstanceRequest extends $tea.Model {
  /**
   * @remarks
   * Specifies whether to enable automatic renewal.   
   * This parameter is valid only when the ChargeType parameter is set to PrePaid. Valid values: 
   * - true: enables automatic renewal for the instance.   
   * - false: disables automatic renewal for the instance. This is the default value.
   * 
   * @example
   * true
   */
  autoRenew?: boolean;
  /**
   * @remarks
   * The automatic renewal period of the instance. This parameter is required when the AutoRenew parameter is set to true. Valid values:  
   * - If the PeriodUnit parameter is set to Year: "1", "2", and "3".   
   * - If the PeriodUnit parameter is set to Month: "1", "2", "3", "6", and "12".
   * 
   * @example
   * 2
   */
  autoRenewPeriod?: number;
  /**
   * @remarks
   * The billing method of the instance. Valid values:  
   * - PrePay: the subscription billing method. You must ensure that the remaining balance or credit balance of your account can cover the cost of the subscription. Otherwise, you will receive an InvalidPayMethod error. 
   * - PostPay: the pay-as-you-go billing method. This is the default value. By default, fees are charged on an hourly basis.
   * 
   * This parameter is required.
   * 
   * @example
   * PrePay
   */
  chargeType?: string;
  /**
   * @example
   * x86
   */
  cpuArch?: string;
  /**
   * @remarks
   * The size of the storage space,in GB.    
   * The limits on the storage space vary with the cluster specifications:   
   * - 8C32GB: 100 GB to 10000 GB   
   * - 14C70GB: 200 GB to 10000 GB   
   * - 30C180GB: 400 GB to 10000 GB   
   * - 62C400GB: 800 GB to 10000 GB    
   * The preceding minimum storage space sizes are the default storage space sizes of the corresponding cluster specification plans.
   * 
   * @example
   * 200
   */
  diskSize?: number;
  /**
   * @remarks
   * The type of the storage disk where the cluster is deployed. This parameter takes effect only for Standard Cluster Edition (Cloud Disk).
   * Valid values:
   * - cloud_essd_pl1: ESSD PL1.
   * - cloud_essd_pl0: ESSD PL0. Default value: cloud_essd_pl1.
   * 
   * @example
   * cloud_essd_pl1
   */
  diskType?: string;
  /**
   * @remarks
   * Specifies whether to perform only a dry run for the request. Default value: false. Valid values:
   * - true: Only a dry-run request is sent and the instance is not created. If the dry run succeeds, DryRunResult=true is returned. If the dry run fails, an error code is returned.
   * - false: The actual request is sent and no dry run is performed. The instance is created if the requirements are met. By default, the DryRunResult parameter returns false if you set DryRun to false.
   * 
   * @example
   * false
   */
  dryRun?: boolean;
  /**
   * @remarks
   * The specifications of the cluster.     
   * You can specify one of the following four plans:   
   *  - 8C32GB: indicates 8 CPU cores and 32 GB of memory.    
   *  - 14C70GB: indicates 14 CPU cores and 70 GB of memory. This is the default value.
   * - 30C180GB: indicates 30 CPU cores and 180 GB of memory.     
   * - 62C400GB: indicates 62 CPU cores and 400 GB of memory.
   * 
   * This parameter is required.
   * 
   * @example
   * 14C70GB
   */
  instanceClass?: string;
  /**
   * @remarks
   * The name of the OceanBase cluster.    
   * It must be 1 to 20 characters in length.   
   * If this parameter is not specified, the value is the instance ID of the cluster by default.
   * 
   * @example
   * amap_aos_tx_ob
   */
  instanceName?: string;
  /**
   * @remarks
   * Specifies whether to enable the control group feature.
   * Valid values:
   * - true
   * - false
   * 
   * @example
   * true
   */
  isolationOptimization?: string;
  /**
   * @remarks
   * OceanBase Server version number.
   * 
   * @example
   * 2.2.77
   */
  obVersion?: string;
  /**
   * @remarks
   * The valid duration of the purchased resources. The unit is specified by the PeriodUnit parameter.   
   * This parameter is valid and required only when the InstanceChargeType parameter is set to PrePaid.      
   * Valid values:     
   * - When the PeriodUnit parameter is set to Month: "1", "2", "3", "4", "5", "6", "7", "8", "9". 
   * - When the PeriodUnit parameter is set to Year: "1", "2", "3".
   * 
   * @example
   * 1
   */
  period?: number;
  /**
   * @remarks
   * The unit of the valid duration of the purchased resources.     
   * Valid value for subscription: Month or Year.
   * Default value: Month for subscription, and Hour for pay-as-you-go.
   * 
   * @example
   * Month
   */
  periodUnit?: string;
  /**
   * @remarks
   * Primary instance ID.
   * 
   * @example
   * ob3h8ytroxxxxx
   */
  primaryInstance?: string;
  /**
   * @remarks
   * Primary instance region.
   * 
   * @example
   * cn-hangzhou
   */
  primaryRegion?: string;
  /**
   * @remarks
   * The number of full-featured replicas.
   * - 3F: three full-featured replicas.
   * - 2F1L: two full-featured replicas and one log replica.
   * - 2F1A: two full-featured replicas and one arbitration service.
   * - ApsaraDB for OceanBase earlier than V4.1 supports 3F and 2F1L.
   * - ApsaraDB for OceanBase V4.1 or later supports 3F and 2F1A.
   * - An ApsaraDB for OceanBase instance deployed across three zones supports only 3F.
   * - An ApsaraDB for OceanBase instance deployed across two zones supports 2F1A or 2F1L, depending on the version.
   * - An ApsaraDB for OceanBase instance deployed in a single zone supports 3F, 2F1A, or 2F1L, depending on the version.
   * 
   * @example
   * 3F
   */
  replicaMode?: string;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs.
   * 
   * @example
   * rg-bp67acfmxazb4p****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The series of the OceanBase cluster. Valid values:    
   * - normal: Standard Cluster Edition (Cloud Disk). This is the default value.
   * - normal_ssd: Standard Cluster Edition (Local Disk).
   * - history: History Database Cluster Edition.
   * 
   * This parameter is required.
   * 
   * @example
   * Normal
   */
  series?: string;
  /**
   * @remarks
   * The ID of the zone to which the instance belongs.   
   * For more information about how to obtain the list of zones, see [DescribeZones](https://help.aliyun.com/document_detail/25610.html).
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou-h,cn-hangzhou-i,cn-hangzhou-j
   */
  zones?: string;
  static names(): { [key: string]: string } {
    return {
      autoRenew: 'AutoRenew',
      autoRenewPeriod: 'AutoRenewPeriod',
      chargeType: 'ChargeType',
      cpuArch: 'CpuArch',
      diskSize: 'DiskSize',
      diskType: 'DiskType',
      dryRun: 'DryRun',
      instanceClass: 'InstanceClass',
      instanceName: 'InstanceName',
      isolationOptimization: 'IsolationOptimization',
      obVersion: 'ObVersion',
      period: 'Period',
      periodUnit: 'PeriodUnit',
      primaryInstance: 'PrimaryInstance',
      primaryRegion: 'PrimaryRegion',
      replicaMode: 'ReplicaMode',
      resourceGroupId: 'ResourceGroupId',
      series: 'Series',
      zones: 'Zones',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoRenew: 'boolean',
      autoRenewPeriod: 'number',
      chargeType: 'string',
      cpuArch: 'string',
      diskSize: 'number',
      diskType: 'string',
      dryRun: 'boolean',
      instanceClass: 'string',
      instanceName: 'string',
      isolationOptimization: 'string',
      obVersion: 'string',
      period: 'number',
      periodUnit: 'string',
      primaryInstance: 'string',
      primaryRegion: 'string',
      replicaMode: 'string',
      resourceGroupId: 'string',
      series: 'string',
      zones: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateInstanceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned data.
   */
  data?: CreateInstanceResponseBodyData;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: CreateInstanceResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateInstanceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLabelRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * test
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLabelResponseBody extends $tea.Model {
  /**
   * @example
   * Contact the administrator.
   */
  advice?: string;
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  /**
   * @example
   * 1
   */
  cost?: string;
  /**
   * @example
   * l_****
   */
  data?: string;
  errorDetail?: CreateLabelResponseBodyErrorDetail;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * E3D924FB-52****B253-0C1A7EFB778C
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 24
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      cost: 'Cost',
      data: 'Data',
      errorDetail: 'ErrorDetail',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      cost: 'string',
      data: 'string',
      errorDetail: CreateLabelResponseBodyErrorDetail,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLabelResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateLabelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateLabelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMySqlDataSourceRequest extends $tea.Model {
  /**
   * @example
   * test
   */
  description?: string;
  /**
   * @example
   * dg-x****
   */
  dgInstanceId?: string;
  /**
   * @example
   * rm-t4****
   */
  instanceId?: string;
  /**
   * @example
   * xxx.xxx.xxx.1
   */
  ip?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * source_name
   */
  name?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * pass_word
   */
  password?: string;
  /**
   * @example
   * 2883
   */
  port?: number;
  /**
   * @example
   * test
   */
  schema?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * VPC
   */
  type?: string;
  useSsl?: boolean;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * user_name
   */
  userName?: string;
  /**
   * @example
   * vpc-bp1d2q3mhg9i23ofi****
   */
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      dgInstanceId: 'DgInstanceId',
      instanceId: 'InstanceId',
      ip: 'Ip',
      name: 'Name',
      password: 'Password',
      port: 'Port',
      schema: 'Schema',
      type: 'Type',
      useSsl: 'UseSsl',
      userName: 'UserName',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      dgInstanceId: 'string',
      instanceId: 'string',
      ip: 'string',
      name: 'string',
      password: 'string',
      port: 'number',
      schema: 'string',
      type: 'string',
      useSsl: 'boolean',
      userName: 'string',
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMySqlDataSourceResponseBody extends $tea.Model {
  /**
   * @example
   * Contact the administrator.
   */
  advice?: string;
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  /**
   * @example
   * 1
   */
  cost?: string;
  /**
   * @example
   * e_edz****
   */
  data?: string;
  errorDetail?: CreateMySqlDataSourceResponseBodyErrorDetail;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 24
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      cost: 'Cost',
      data: 'Data',
      errorDetail: 'ErrorDetail',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      cost: 'string',
      data: 'string',
      errorDetail: CreateMySqlDataSourceResponseBodyErrorDetail,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMySqlDataSourceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateMySqlDataSourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateMySqlDataSourceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOceanBaseDataSourceRequest extends $tea.Model {
  /**
   * @example
   * cluster_name
   */
  cluster?: string;
  /**
   * @example
   * http://xxx.xxx.xxx.2:2883/services?Action=ObRootServiceInfo&User_ID=alibaba&UID=ocpmaster&ObRegion=ob_1***29.admin
   */
  configUrl?: string;
  /**
   * @example
   * test
   */
  description?: string;
  /**
   * @example
   * pas***
   */
  drcPassword?: string;
  /**
   * @example
   * user_na***
   */
  drcUserName?: string;
  /**
   * @example
   * in***
   */
  innerDrcPassword?: string;
  /**
   * @example
   * xxx.xxx.xxx.1
   */
  ip?: string;
  /**
   * @remarks
   * LogProxy IP。
   * 
   * @example
   * null
   */
  logProxyIp?: string;
  /**
   * @example
   * null
   */
  logProxyPort?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * source_name
   */
  name?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * pass_word
   */
  password?: string;
  /**
   * @example
   * 2883
   */
  port?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * tenant_name
   */
  tenant?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * OB_MYSQL_VPC
   */
  type?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * user_name
   */
  userName?: string;
  /**
   * @example
   * vpc-bp1d2q3mhg9i23ofi****
   */
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      cluster: 'Cluster',
      configUrl: 'ConfigUrl',
      description: 'Description',
      drcPassword: 'DrcPassword',
      drcUserName: 'DrcUserName',
      innerDrcPassword: 'InnerDrcPassword',
      ip: 'Ip',
      logProxyIp: 'LogProxyIp',
      logProxyPort: 'LogProxyPort',
      name: 'Name',
      password: 'Password',
      port: 'Port',
      tenant: 'Tenant',
      type: 'Type',
      userName: 'UserName',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cluster: 'string',
      configUrl: 'string',
      description: 'string',
      drcPassword: 'string',
      drcUserName: 'string',
      innerDrcPassword: 'string',
      ip: 'string',
      logProxyIp: 'string',
      logProxyPort: 'string',
      name: 'string',
      password: 'string',
      port: 'number',
      tenant: 'string',
      type: 'string',
      userName: 'string',
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOceanBaseDataSourceResponseBody extends $tea.Model {
  /**
   * @example
   * Contact the administrator.
   */
  advice?: string;
  /**
   * @example
   * null
   */
  code?: string;
  /**
   * @example
   * 1
   */
  cost?: string;
  /**
   * @example
   * e_edz****
   */
  data?: string;
  errorDetail?: CreateOceanBaseDataSourceResponseBodyErrorDetail;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 30
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      cost: 'Cost',
      data: 'Data',
      errorDetail: 'ErrorDetail',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      cost: 'string',
      data: 'string',
      errorDetail: CreateOceanBaseDataSourceResponseBodyErrorDetail,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOceanBaseDataSourceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateOceanBaseDataSourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateOceanBaseDataSourceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOmsMysqlDataSourceRequest extends $tea.Model {
  /**
   * @remarks
   * The description of the data source.   
   * 
   * It must be 2 to 256 characters in length. The default value is null.
   * 
   * @example
   * MySQL data source for OMS testing
   */
  description?: string;
  /**
   * @remarks
   * The ID of the database gateway instance.   
   * 
   * > <br>If Type is set to DG, this parameter is required.
   * 
   * @example
   * dg-yhss6sdlaff****
   */
  dgDatabaseId?: string;
  /**
   * @remarks
   * The ID of the ECS instance of the data source.   
   * 
   * > <br>If Type is set to RDS, PolarDB, or DG, this parameter is required.
   * 
   * @example
   * pc-12ab34cd56******
   */
  instanceId?: string;
  /**
   * @remarks
   * The IP address of the data source.   
   * 
   * > <br>If Type is set to INTERNET or VPC, this parameter is required.
   * 
   * @example
   * 10.0.****
   */
  ip?: string;
  /**
   * @remarks
   * The name of the data source.   
   * It must be 2 to 128 characters in length and can contain letters, digits, underscores (_), periods (.), and hyphens (-).   
   * 
   * > <br>Invalid characters, such as slashes (/), are not allowed.
   * 
   * This parameter is required.
   * 
   * @example
   * oms-mysql
   */
  name?: string;
  /**
   * @remarks
   * The password of the username that is used to access the database. It must be Base64 encoded.   
   * For example, for the password abcd123@!, the Base64-encoded value is YWJjZDEyM0Ah.
   * 
   * This parameter is required.
   * 
   * @example
   * YWJjZDEyM0Ah
   */
  password?: string;
  /**
   * @remarks
   * The port number of the data source.   
   * 
   * > <br>If Type is set to INTERNET or VPC, this parameter is required.
   * 
   * @example
   * 3306
   */
  port?: string;
  /**
   * @remarks
   * The name of the database.   
   * 
   * > <br>If you specify this parameter, subsequent migration or synchronization operations will take effect on this database only.
   * 
   * @example
   * test
   */
  schema?: string;
  /**
   * @remarks
   * The type of the MySQL data source.   
   * Valid values: INTERNET, VPC, RDS, PolarDB, and DG.
   * 
   * This parameter is required.
   * 
   * @example
   * INTERNET
   */
  type?: string;
  /**
   * @remarks
   * The username that is used to access the database.
   * 
   * This parameter is required.
   * 
   * @example
   * omsTestUser
   */
  username?: string;
  /**
   * @remarks
   * The ID of the VPC to which the data source belongs.   
   * 
   * > <br>If Type is set to VPC, this parameter is required.
   * 
   * @example
   * vpc-12345abcde*******
   */
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      dgDatabaseId: 'DgDatabaseId',
      instanceId: 'InstanceId',
      ip: 'Ip',
      name: 'Name',
      password: 'Password',
      port: 'Port',
      schema: 'Schema',
      type: 'Type',
      username: 'Username',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      dgDatabaseId: 'string',
      instanceId: 'string',
      ip: 'string',
      name: 'string',
      password: 'string',
      port: 'string',
      schema: 'string',
      type: 'string',
      username: 'string',
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOmsMysqlDataSourceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The return result of the request.
   */
  data?: CreateOmsMysqlDataSourceResponseBodyData;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: CreateOmsMysqlDataSourceResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOmsMysqlDataSourceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateOmsMysqlDataSourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateOmsMysqlDataSourceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectRequest extends $tea.Model {
  commonTransferConfig?: CreateProjectRequestCommonTransferConfig;
  /**
   * @example
   * true
   */
  enableFullTransfer?: boolean;
  /**
   * @example
   * true
   */
  enableFullVerify?: boolean;
  /**
   * @example
   * true
   */
  enableIncrTransfer?: boolean;
  /**
   * @example
   * true
   */
  enableReverseIncrTransfer?: boolean;
  /**
   * @example
   * true
   */
  enableStructTransfer?: boolean;
  fullTransferConfig?: CreateProjectRequestFullTransferConfig;
  /**
   * @remarks
   * This parameter is required.
   */
  id?: string;
  incrTransferConfig?: CreateProjectRequestIncrTransferConfig;
  labelIds?: string[];
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * test
   */
  name?: string;
  /**
   * @example
   * open_api_create_project/oacp_xxx
   */
  ossKey?: string;
  reverseIncrTransferConfig?: CreateProjectRequestReverseIncrTransferConfig;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * e_4j0cz****
   */
  sinkEndpointId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * e_4j0c12z****
   */
  sourceEndpointId?: string;
  structTransferConfig?: CreateProjectRequestStructTransferConfig;
  /**
   * @remarks
   * This parameter is required.
   */
  transferMapping?: CreateProjectRequestTransferMapping;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * MIGRATION
   */
  type?: string;
  /**
   * @example
   * true
   */
  useOss?: boolean;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * g_abcdefj***
   */
  workerGradeId?: string;
  static names(): { [key: string]: string } {
    return {
      commonTransferConfig: 'CommonTransferConfig',
      enableFullTransfer: 'EnableFullTransfer',
      enableFullVerify: 'EnableFullVerify',
      enableIncrTransfer: 'EnableIncrTransfer',
      enableReverseIncrTransfer: 'EnableReverseIncrTransfer',
      enableStructTransfer: 'EnableStructTransfer',
      fullTransferConfig: 'FullTransferConfig',
      id: 'Id',
      incrTransferConfig: 'IncrTransferConfig',
      labelIds: 'LabelIds',
      name: 'Name',
      ossKey: 'OssKey',
      reverseIncrTransferConfig: 'ReverseIncrTransferConfig',
      sinkEndpointId: 'SinkEndpointId',
      sourceEndpointId: 'SourceEndpointId',
      structTransferConfig: 'StructTransferConfig',
      transferMapping: 'TransferMapping',
      type: 'Type',
      useOss: 'UseOss',
      workerGradeId: 'WorkerGradeId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonTransferConfig: CreateProjectRequestCommonTransferConfig,
      enableFullTransfer: 'boolean',
      enableFullVerify: 'boolean',
      enableIncrTransfer: 'boolean',
      enableReverseIncrTransfer: 'boolean',
      enableStructTransfer: 'boolean',
      fullTransferConfig: CreateProjectRequestFullTransferConfig,
      id: 'string',
      incrTransferConfig: CreateProjectRequestIncrTransferConfig,
      labelIds: { 'type': 'array', 'itemType': 'string' },
      name: 'string',
      ossKey: 'string',
      reverseIncrTransferConfig: CreateProjectRequestReverseIncrTransferConfig,
      sinkEndpointId: 'string',
      sourceEndpointId: 'string',
      structTransferConfig: CreateProjectRequestStructTransferConfig,
      transferMapping: CreateProjectRequestTransferMapping,
      type: 'string',
      useOss: 'boolean',
      workerGradeId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectShrinkRequest extends $tea.Model {
  commonTransferConfigShrink?: string;
  /**
   * @example
   * true
   */
  enableFullTransfer?: boolean;
  /**
   * @example
   * true
   */
  enableFullVerify?: boolean;
  /**
   * @example
   * true
   */
  enableIncrTransfer?: boolean;
  /**
   * @example
   * true
   */
  enableReverseIncrTransfer?: boolean;
  /**
   * @example
   * true
   */
  enableStructTransfer?: boolean;
  fullTransferConfigShrink?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  id?: string;
  incrTransferConfigShrink?: string;
  labelIdsShrink?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * test
   */
  name?: string;
  /**
   * @example
   * open_api_create_project/oacp_xxx
   */
  ossKey?: string;
  reverseIncrTransferConfigShrink?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * e_4j0cz****
   */
  sinkEndpointId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * e_4j0c12z****
   */
  sourceEndpointId?: string;
  structTransferConfigShrink?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  transferMappingShrink?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * MIGRATION
   */
  type?: string;
  /**
   * @example
   * true
   */
  useOss?: boolean;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * g_abcdefj***
   */
  workerGradeId?: string;
  static names(): { [key: string]: string } {
    return {
      commonTransferConfigShrink: 'CommonTransferConfig',
      enableFullTransfer: 'EnableFullTransfer',
      enableFullVerify: 'EnableFullVerify',
      enableIncrTransfer: 'EnableIncrTransfer',
      enableReverseIncrTransfer: 'EnableReverseIncrTransfer',
      enableStructTransfer: 'EnableStructTransfer',
      fullTransferConfigShrink: 'FullTransferConfig',
      id: 'Id',
      incrTransferConfigShrink: 'IncrTransferConfig',
      labelIdsShrink: 'LabelIds',
      name: 'Name',
      ossKey: 'OssKey',
      reverseIncrTransferConfigShrink: 'ReverseIncrTransferConfig',
      sinkEndpointId: 'SinkEndpointId',
      sourceEndpointId: 'SourceEndpointId',
      structTransferConfigShrink: 'StructTransferConfig',
      transferMappingShrink: 'TransferMapping',
      type: 'Type',
      useOss: 'UseOss',
      workerGradeId: 'WorkerGradeId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonTransferConfigShrink: 'string',
      enableFullTransfer: 'boolean',
      enableFullVerify: 'boolean',
      enableIncrTransfer: 'boolean',
      enableReverseIncrTransfer: 'boolean',
      enableStructTransfer: 'boolean',
      fullTransferConfigShrink: 'string',
      id: 'string',
      incrTransferConfigShrink: 'string',
      labelIdsShrink: 'string',
      name: 'string',
      ossKey: 'string',
      reverseIncrTransferConfigShrink: 'string',
      sinkEndpointId: 'string',
      sourceEndpointId: 'string',
      structTransferConfigShrink: 'string',
      transferMappingShrink: 'string',
      type: 'string',
      useOss: 'boolean',
      workerGradeId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectResponseBody extends $tea.Model {
  /**
   * @example
   * Contact the administrator.
   */
  advice?: string;
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  /**
   * @example
   * 27
   */
  cost?: string;
  /**
   * @example
   * np_****
   */
  data?: string;
  errorDetail?: CreateProjectResponseBodyErrorDetail;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * XCVSADG****DSGDS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 100
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      cost: 'Cost',
      data: 'Data',
      errorDetail: 'ErrorDetail',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      cost: 'string',
      data: 'string',
      errorDetail: CreateProjectResponseBodyErrorDetail,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateProjectResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateProjectResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   */
  databases?: CreateProjectModifyRecordsRequestDatabases[];
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * np_fe****
   */
  id?: string;
  static names(): { [key: string]: string } {
    return {
      databases: 'Databases',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      databases: { 'type': 'array', 'itemType': CreateProjectModifyRecordsRequestDatabases },
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   */
  databasesShrink?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * np_fe****
   */
  id?: string;
  static names(): { [key: string]: string } {
    return {
      databasesShrink: 'Databases',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      databasesShrink: 'string',
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsResponseBody extends $tea.Model {
  /**
   * @example
   * Contact the administrator.
   */
  advice?: string;
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  /**
   * @example
   * 28
   */
  cost?: string;
  /**
   * @example
   * 4
   */
  data?: number;
  errorDetail?: CreateProjectModifyRecordsResponseBodyErrorDetail;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 100
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      cost: 'Cost',
      data: 'Data',
      errorDetail: 'ErrorDetail',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      cost: 'string',
      data: 'number',
      errorDetail: CreateProjectModifyRecordsResponseBodyErrorDetail,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateProjectModifyRecordsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateProjectModifyRecordsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRdsPostgreSQLDataSourceRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * db_name
   */
  databaseName?: string;
  /**
   * @example
   * this is a test database
   */
  description?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * g_abcdefj***
   */
  instanceId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * data_name
   */
  name?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * pass_word
   */
  password?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * user_name
   */
  userName?: string;
  static names(): { [key: string]: string } {
    return {
      databaseName: 'DatabaseName',
      description: 'Description',
      instanceId: 'InstanceId',
      name: 'Name',
      password: 'Password',
      userName: 'UserName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      databaseName: 'string',
      description: 'string',
      instanceId: 'string',
      name: 'string',
      password: 'string',
      userName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRdsPostgreSQLDataSourceResponseBody extends $tea.Model {
  /**
   * @example
   * Contact the administrator.
   */
  advice?: string;
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  /**
   * @example
   * 30
   */
  cost?: string;
  /**
   * @example
   * e_5anwndq
   */
  data?: string;
  errorDetail?: CreateRdsPostgreSQLDataSourceResponseBodyErrorDetail;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 100
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      cost: 'Cost',
      data: 'Data',
      errorDetail: 'ErrorDetail',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      cost: 'string',
      data: 'string',
      errorDetail: CreateRdsPostgreSQLDataSourceResponseBodyErrorDetail,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRdsPostgreSQLDataSourceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateRdsPostgreSQLDataSourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateRdsPostgreSQLDataSourceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSecurityIpGroupRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The name of the whitelist group.
   * 
   * This parameter is required.
   * 
   * @example
   * pay_online
   */
  securityIpGroupName?: string;
  /**
   * @remarks
   * The return result of the request.
   * 
   * This parameter is required.
   * 
   * @example
   * {"192.168.1.1","192.168.0.0.1/8"}
   */
  securityIps?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      securityIpGroupName: 'SecurityIpGroupName',
      securityIps: 'SecurityIps',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      securityIpGroupName: 'string',
      securityIps: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSecurityIpGroupResponseBody extends $tea.Model {
  /**
   * @remarks
   * The IP addresses or CIDR blocks in the IP address whitelist group.   
   * The return values of SecurityIps are strings that are separated with commas (,).
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @remarks
   * The operation that you want to perform.   
   * Set the value to **CreateSecurityIpGroup**.
   */
  securityIpGroup?: CreateSecurityIpGroupResponseBodySecurityIpGroup;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      securityIpGroup: 'SecurityIpGroup',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      securityIpGroup: CreateSecurityIpGroupResponseBodySecurityIpGroup,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSecurityIpGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateSecurityIpGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateSecurityIpGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTagRequest extends $tea.Model {
  /**
   * @remarks
   * The identifier of the client.
   * 
   * @example
   * 123e4567-e89b-12d3-a456-426655440000
   */
  clientToken?: string;
  /**
   * @remarks
   * The name of the tag group.
   * 
   * This parameter is required.
   * 
   * @example
   * Tag group 1
   */
  key?: string;
  static names(): { [key: string]: string } {
    return {
      clientToken: 'ClientToken',
      key: 'Key',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clientToken: 'string',
      key: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTagResponseBody extends $tea.Model {
  /**
   * @remarks
   * The tag group creation result.
   * 
   * @example
   * Create tag success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 4C91F7BA-xxxx-xxxx-xxxx-846ECA1A9908
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTagResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateTagResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateTagResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTagValueRequest extends $tea.Model {
  /**
   * @remarks
   * The identifier of the client.
   * 
   * @example
   * 123e4567-e89b-12d3-a456-426655440000
   */
  clientToken?: string;
  /**
   * @remarks
   * The name of the tag group.
   * 
   * This parameter is required.
   * 
   * @example
   * Tag group 1
   */
  key?: string;
  /**
   * @remarks
   * The name of the tag.
   * 
   * This parameter is required.
   * 
   * @example
   * Tag 1
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      clientToken: 'ClientToken',
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clientToken: 'string',
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTagValueResponseBody extends $tea.Model {
  /**
   * @remarks
   * The tag creation result.
   * 
   * @example
   * create tag value success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 4C91F7BA-xxxx-xxxx-xxxx-846ECA1A9908
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTagValueResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateTagValueResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateTagValueResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTenantRequest extends $tea.Model {
  /**
   * @remarks
   * The character set.    
   * For more information, see [DescribeCharset](https://www.alibabacloud.com/help/en/apsaradb-for-oceanbase/latest/api-oceanbasepro-2019-09-01-describecharset).
   * 
   * This parameter is required.
   * 
   * @example
   * utf8mb4
   */
  charset?: string;
  /**
   * @remarks
   * The number of CPU cores of the tenant.   
   * 
   * > <br>The CPU specification of a single tenant cannot exceed that of the corresponding cluster. <br>For example, if the specification of the cluster is 14 CPU cores and 70 GB of memory, the CPU specification of the tenant cannot exceed 14 cores.
   * 
   * This parameter is required.
   * 
   * @example
   * 2
   */
  cpu?: number;
  createParams?: { [key: string]: string };
  /**
   * @remarks
   * The description of the database.
   * 
   * @example
   * this is a test database
   */
  description?: string;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The size of the log disk allocated to the tenant, in GB.
   * 
   * @example
   * 128
   */
  logDisk?: number;
  /**
   * @remarks
   * The memory size of the tenant, in GB.   
   * 
   * > <br>The memory size of a single tenant cannot exceed that of the corresponding cluster. <br>For example, if the specification of the cluster is 14 CPU cores and 70 GB of memory, the memory size of the tenant cannot exceed 70 GB.
   * 
   * This parameter is required.
   * 
   * @example
   * 10
   */
  memory?: number;
  /**
   * @remarks
   * The primary zone of the tenant.    
   * It is one of the zones in which the cluster is deployed.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou-h
   */
  primaryZone?: string;
  /**
   * @remarks
   * Specifies to create a read-only zone. Separate the names of multiple zones with commas (,).
   * >Notice: <br>At present, this parameter is unavailable.
   * 
   * @example
   * cn-shanghai-g-ro,cn-shanghai-h-ro
   */
  readOnlyZoneList?: string;
  /**
   * @remarks
   * The tenant mode.    
   * Valid values: Oracle and MySQL.   
   * For more information, see [DescribeInstanceTenantModes](https://www.alibabacloud.com/help/en/apsaradb-for-oceanbase/latest/api-oceanbasepro-2019-09-01-describeinstancetenantmodes).
   * 
   * This parameter is required.
   * 
   * @example
   * Oracle
   */
  tenantMode?: string;
  /**
   * @remarks
   * The name of the tenant.    
   * It must start with a letter or an underscore (_), and contain 2 to 20 characters, which can be uppercase letters, lowercase letters, digits, and underscores (_).  It cannot be set to sys.
   * 
   * This parameter is required.
   * 
   * @example
   * pay_online
   */
  tenantName?: string;
  /**
   * @remarks
   * The time zone of the tenant. For more information, see [DescribeTimeZones](https://www.alibabacloud.com/help/en/apsaradb-for-oceanbase/latest/api-oceanbasepro-2019-09-01-describetimezones).
   * 
   * This parameter is required.
   * 
   * @example
   * Asia/Shanghai
   */
  timeZone?: string;
  /**
   * @remarks
   * The number of resource distribution nodes in the tenant.    
   * The number is determined by the deployment mode of the cluster. If the cluster is deployed in 2-2-2 mode, the maximum number of resource distribution nodes is 2.
   * 
   * @example
   * 2
   */
  unitNum?: number;
  /**
   * @remarks
   * The ID of the vSwitch.    
   * If no suitable vSwitch is available, create a vSwitch as prompted.   
   * For more information, see Use a vSwitch.
   * 
   * This parameter is required.
   * 
   * @example
   * vsw-bp11k1aypnzu1l3whi****
   */
  userVSwitchId?: string;
  /**
   * @remarks
   * The ID of the VPC.   
   *  If no suitable VPC is available, create a VPC as prompted.   
   * For more information, see "What is a VPC".
   * 
   * This parameter is required.
   * 
   * @example
   * vpc-bp1d2q3mhg9i23ofi****
   */
  userVpcId?: string;
  userVpcOwnerId?: string;
  static names(): { [key: string]: string } {
    return {
      charset: 'Charset',
      cpu: 'Cpu',
      createParams: 'CreateParams',
      description: 'Description',
      instanceId: 'InstanceId',
      logDisk: 'LogDisk',
      memory: 'Memory',
      primaryZone: 'PrimaryZone',
      readOnlyZoneList: 'ReadOnlyZoneList',
      tenantMode: 'TenantMode',
      tenantName: 'TenantName',
      timeZone: 'TimeZone',
      unitNum: 'UnitNum',
      userVSwitchId: 'UserVSwitchId',
      userVpcId: 'UserVpcId',
      userVpcOwnerId: 'UserVpcOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      charset: 'string',
      cpu: 'number',
      createParams: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      description: 'string',
      instanceId: 'string',
      logDisk: 'number',
      memory: 'number',
      primaryZone: 'string',
      readOnlyZoneList: 'string',
      tenantMode: 'string',
      tenantName: 'string',
      timeZone: 'string',
      unitNum: 'number',
      userVSwitchId: 'string',
      userVpcId: 'string',
      userVpcOwnerId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTenantShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The character set.    
   * For more information, see [DescribeCharset](https://www.alibabacloud.com/help/en/apsaradb-for-oceanbase/latest/api-oceanbasepro-2019-09-01-describecharset).
   * 
   * This parameter is required.
   * 
   * @example
   * utf8mb4
   */
  charset?: string;
  /**
   * @remarks
   * The number of CPU cores of the tenant.   
   * 
   * > <br>The CPU specification of a single tenant cannot exceed that of the corresponding cluster. <br>For example, if the specification of the cluster is 14 CPU cores and 70 GB of memory, the CPU specification of the tenant cannot exceed 14 cores.
   * 
   * This parameter is required.
   * 
   * @example
   * 2
   */
  cpu?: number;
  createParamsShrink?: string;
  /**
   * @remarks
   * The description of the database.
   * 
   * @example
   * this is a test database
   */
  description?: string;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The size of the log disk allocated to the tenant, in GB.
   * 
   * @example
   * 128
   */
  logDisk?: number;
  /**
   * @remarks
   * The memory size of the tenant, in GB.   
   * 
   * > <br>The memory size of a single tenant cannot exceed that of the corresponding cluster. <br>For example, if the specification of the cluster is 14 CPU cores and 70 GB of memory, the memory size of the tenant cannot exceed 70 GB.
   * 
   * This parameter is required.
   * 
   * @example
   * 10
   */
  memory?: number;
  /**
   * @remarks
   * The primary zone of the tenant.    
   * It is one of the zones in which the cluster is deployed.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou-h
   */
  primaryZone?: string;
  /**
   * @remarks
   * Specifies to create a read-only zone. Separate the names of multiple zones with commas (,).
   * >Notice: <br>At present, this parameter is unavailable.
   * 
   * @example
   * cn-shanghai-g-ro,cn-shanghai-h-ro
   */
  readOnlyZoneList?: string;
  /**
   * @remarks
   * The tenant mode.    
   * Valid values: Oracle and MySQL.   
   * For more information, see [DescribeInstanceTenantModes](https://www.alibabacloud.com/help/en/apsaradb-for-oceanbase/latest/api-oceanbasepro-2019-09-01-describeinstancetenantmodes).
   * 
   * This parameter is required.
   * 
   * @example
   * Oracle
   */
  tenantMode?: string;
  /**
   * @remarks
   * The name of the tenant.    
   * It must start with a letter or an underscore (_), and contain 2 to 20 characters, which can be uppercase letters, lowercase letters, digits, and underscores (_).  It cannot be set to sys.
   * 
   * This parameter is required.
   * 
   * @example
   * pay_online
   */
  tenantName?: string;
  /**
   * @remarks
   * The time zone of the tenant. For more information, see [DescribeTimeZones](https://www.alibabacloud.com/help/en/apsaradb-for-oceanbase/latest/api-oceanbasepro-2019-09-01-describetimezones).
   * 
   * This parameter is required.
   * 
   * @example
   * Asia/Shanghai
   */
  timeZone?: string;
  /**
   * @remarks
   * The number of resource distribution nodes in the tenant.    
   * The number is determined by the deployment mode of the cluster. If the cluster is deployed in 2-2-2 mode, the maximum number of resource distribution nodes is 2.
   * 
   * @example
   * 2
   */
  unitNum?: number;
  /**
   * @remarks
   * The ID of the vSwitch.    
   * If no suitable vSwitch is available, create a vSwitch as prompted.   
   * For more information, see Use a vSwitch.
   * 
   * This parameter is required.
   * 
   * @example
   * vsw-bp11k1aypnzu1l3whi****
   */
  userVSwitchId?: string;
  /**
   * @remarks
   * The ID of the VPC.   
   *  If no suitable VPC is available, create a VPC as prompted.   
   * For more information, see "What is a VPC".
   * 
   * This parameter is required.
   * 
   * @example
   * vpc-bp1d2q3mhg9i23ofi****
   */
  userVpcId?: string;
  userVpcOwnerId?: string;
  static names(): { [key: string]: string } {
    return {
      charset: 'Charset',
      cpu: 'Cpu',
      createParamsShrink: 'CreateParams',
      description: 'Description',
      instanceId: 'InstanceId',
      logDisk: 'LogDisk',
      memory: 'Memory',
      primaryZone: 'PrimaryZone',
      readOnlyZoneList: 'ReadOnlyZoneList',
      tenantMode: 'TenantMode',
      tenantName: 'TenantName',
      timeZone: 'TimeZone',
      unitNum: 'UnitNum',
      userVSwitchId: 'UserVSwitchId',
      userVpcId: 'UserVpcId',
      userVpcOwnerId: 'UserVpcOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      charset: 'string',
      cpu: 'number',
      createParamsShrink: 'string',
      description: 'string',
      instanceId: 'string',
      logDisk: 'number',
      memory: 'number',
      primaryZone: 'string',
      readOnlyZoneList: 'string',
      tenantMode: 'string',
      tenantName: 'string',
      timeZone: 'string',
      unitNum: 'number',
      userVSwitchId: 'string',
      userVpcId: 'string',
      userVpcOwnerId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTenantResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * @example
   * t33h8y08k****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTenantResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateTenantResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateTenantResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTenantReadOnlyConnectionRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * ob2mr3oae0****
   */
  tenantId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * vsw-bp11k1aypnzu1l3whi****
   */
  vSwitchId?: string;
  /**
   * @example
   * vpc-bp1d2q3mhg9i23ofi****
   */
  vpcId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou-i
   */
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      tenantId: 'TenantId',
      vSwitchId: 'VSwitchId',
      vpcId: 'VpcId',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      tenantId: 'string',
      vSwitchId: 'string',
      vpcId: 'string',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTenantReadOnlyConnectionResponseBody extends $tea.Model {
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTenantReadOnlyConnectionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateTenantReadOnlyConnectionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateTenantReadOnlyConnectionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTenantSecurityIpGroupRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The group name of the whitelist group of IP addresses.
   * 
   * It starts with lowercase letters and ends with lowercase letters or numbers. It can only contain lowercase letters, numbers, and underscores, and should be 2~32 characters in length.
   * 
   * This parameter is required.
   * 
   * @example
   * paytest
   */
  securityIpGroupName?: string;
  /**
   * @remarks
   * The list of IP addresses in the whitelist group.
   * 
   * It is a JSON array. Each object in the array is an IP address or a CIDR block. You can have up to 40 whitelists.
   * 
   * This parameter is required.
   * 
   * @example
   * 192.***.*.*"
   */
  securityIps?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * t4louaeei****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      securityIpGroupName: 'SecurityIpGroupName',
      securityIps: 'SecurityIps',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      securityIpGroupName: 'string',
      securityIps: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTenantSecurityIpGroupResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @remarks
   * The information of the whitelist group.
   */
  securityIpGroup?: CreateTenantSecurityIpGroupResponseBodySecurityIpGroup;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      securityIpGroup: 'SecurityIpGroup',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      securityIpGroup: CreateTenantSecurityIpGroupResponseBodySecurityIpGroup,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTenantSecurityIpGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateTenantSecurityIpGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateTenantSecurityIpGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTenantUserRequest extends $tea.Model {
  /**
   * @remarks
   * The description of the database.
   * 
   * @example
   * this is a test database
   */
  description?: string;
  /**
   * @remarks
   * 加密方式。
   * 
   * @example
   * RAS
   */
  encryptionType?: string;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The role of the user account.  In Oracle mode, this parameter unspecified is left unspecified.  In MySQL mode, the super administrator account has ALL PRIVILEGES, and you can leave this parameter unspecified.  You need to specify the account information for a general user account. By default, the account information is a JSON array that contains the information of the role and the schema (Oracle mode) or database (MySQL mode).  Valid values: ReadWrite: a role that has the read and write privileges, namely ALL PRIVILEGES. ReadOnly: a role that has only the read-only privilege SELECT. DDL: a role that has DDL privileges such as CREATE, DROP, ALTER, SHOW VIEW, and CREATE VIEW. DML: a role that has DML privileges such as SELECT, INSERT, UPDATE, DELETE, and SHOW VIEW.
   * 
   * @example
   * [{"Database":"oceanbase1","Role":"readwrite"},{"Database":"oceanbase2","Role":"readonly"}]
   */
  roles?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * ob2mr3oae0****
   */
  tenantId?: string;
  /**
   * @remarks
   * The name of the database account.  You cannot use reserved keywords, such as SYS and root.
   * 
   * This parameter is required.
   * 
   * @example
   * pay_test
   */
  userName?: string;
  /**
   * @remarks
   * The password of the database account.  It must be 10 to 32 characters in length and contain three types of the following characters: uppercase letters, lowercase letters, digits, and special characters. The special characters are ! @ # $ % \\ ^ \\ & \\ * ( ) _ + - =
   * 
   * This parameter is required.
   * 
   * @example
   * !Aliyun4Oceanbase
   */
  userPassword?: string;
  /**
   * @remarks
   * The type of the database account. Valid values: Admin: the super administrator account. Normal: a general account.
   * 
   * This parameter is required.
   * 
   * @example
   * Normal
   */
  userType?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      encryptionType: 'EncryptionType',
      instanceId: 'InstanceId',
      roles: 'Roles',
      tenantId: 'TenantId',
      userName: 'UserName',
      userPassword: 'UserPassword',
      userType: 'UserType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      encryptionType: 'string',
      instanceId: 'string',
      roles: 'string',
      tenantId: 'string',
      userName: 'string',
      userPassword: 'string',
      userType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTenantUserResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @remarks
   * The list of database accounts in the tenant.
   */
  tenantUser?: CreateTenantUserResponseBodyTenantUser;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      tenantUser: 'TenantUser',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      tenantUser: CreateTenantUserResponseBodyTenantUser,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTenantUserResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateTenantUserResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateTenantUserResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDataSourceRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * e_5anwndq
   */
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDataSourceResponseBody extends $tea.Model {
  /**
   * @example
   * Contact the administrator.
   */
  advice?: string;
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  /**
   * @example
   * 28
   */
  cost?: string;
  /**
   * @example
   * null
   */
  data?: any;
  errorDetail?: DeleteDataSourceResponseBodyErrorDetail;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * E3D924FB-52****B253-0C1A7EFB778C
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 100
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      cost: 'Cost',
      data: 'Data',
      errorDetail: 'ErrorDetail',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      cost: 'string',
      data: 'any',
      errorDetail: DeleteDataSourceResponseBodyErrorDetail,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDataSourceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteDataSourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteDataSourceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDatabasesRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * ["sms_pre", "pay_pre"]
   */
  databaseNames?: string;
  /**
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * ob2mr3oae0****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      databaseNames: 'DatabaseNames',
      instanceId: 'InstanceId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      databaseNames: 'string',
      instanceId: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDatabasesResponseBody extends $tea.Model {
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDatabasesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteDatabasesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteDatabasesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteInstancesRequest extends $tea.Model {
  /**
   * @remarks
   * The backup retention strategy for cluster deletion. Valid values:  
   * - receive_all: retains all backup sets.   
   * - delete_all: deletes all backup sets.   
   * - receive_last: retains the last backup set.    
   * 
   * > <br>Default value: delete_all.
   * 
   * @example
   * delete_all
   */
  backupRetainMode?: string;
  /**
   * @remarks
   * Specifies whether to perform only a dry run for the request. Default value: false. Valid values:
   * - true: Only a dry-run request is sent and the instance is not deleted. If the dry run succeeds, DryRunResult=true is returned. If the dry run fails, an error code is returned.
   * - false: The actual request is sent and no dry run is performed. The instance is deleted if the requirements are met. By default, false is returned for the parameter DryRunResult if you set DryRun to false.
   * 
   * @example
   * false
   */
  dryRun?: boolean;
  /**
   * @remarks
   * The ID of the cluster to be deleted.   
   * The value is a string in the JSON format.
   * 
   * This parameter is required.
   * 
   * @example
   * [”ob ob3f6yhv9uxxxx“]
   */
  instanceIds?: string;
  static names(): { [key: string]: string } {
    return {
      backupRetainMode: 'BackupRetainMode',
      dryRun: 'DryRun',
      instanceIds: 'InstanceIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      backupRetainMode: 'string',
      dryRun: 'boolean',
      instanceIds: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteInstancesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned data.
   */
  data?: DeleteInstancesResponseBodyData;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 473469C7-****-****-B3DB-A3DC0DE3C83E
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: DeleteInstancesResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteInstancesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteInstancesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProjectRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * np_4w3a****
   */
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProjectResponseBody extends $tea.Model {
  /**
   * @example
   * Contact the administrator.
   */
  advice?: string;
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  /**
   * @example
   * 1
   */
  cost?: string;
  /**
   * @example
   * null
   */
  data?: any;
  errorDetail?: DeleteProjectResponseBodyErrorDetail;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * 473469C7-XXXX-XXX-B3DB-A3DC0DE
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 24
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      cost: 'Cost',
      data: 'Data',
      errorDetail: 'ErrorDetail',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      cost: 'string',
      data: 'any',
      errorDetail: DeleteProjectResponseBodyErrorDetail,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProjectResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteProjectResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteProjectResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSecurityIpGroupRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the IP address whitelist group.    
   * It must be 2 to 32 characters in length, start with a lowercase letter, end with a lowercase letter or digit, and contain only lowercase letters, digits, and underscores (_).
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The information of the deleted IP whitelist group.
   * 
   * This parameter is required.
   * 
   * @example
   * paytest
   */
  securityIpGroupName?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      securityIpGroupName: 'SecurityIpGroupName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      securityIpGroupName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSecurityIpGroupResponseBody extends $tea.Model {
  /**
   * @remarks
   * Example 1
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  securityIpGroup?: DeleteSecurityIpGroupResponseBodySecurityIpGroup;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      securityIpGroup: 'SecurityIpGroup',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      securityIpGroup: DeleteSecurityIpGroupResponseBodySecurityIpGroup,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSecurityIpGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteSecurityIpGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteSecurityIpGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTagRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the tag group.
   * 
   * This parameter is required.
   * 
   * @example
   * Tag group 2
   */
  key?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTagResponseBody extends $tea.Model {
  /**
   * @remarks
   * The tag group deletion result.
   * 
   * @example
   * delete tag success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 4C91F7BA-xxxx-xxxx-xxxx-846ECA1A9908
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTagResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteTagResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteTagResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTagValueRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the tag group.
   * 
   * This parameter is required.
   * 
   * @example
   * Tag group 1
   */
  key?: string;
  /**
   * @remarks
   * The name of the tag.
   * 
   * This parameter is required.
   * 
   * @example
   * Tag 2
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTagValueResponseBody extends $tea.Model {
  /**
   * @remarks
   * The tag deletion result.
   * 
   * @example
   * delete tag-value success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 4C91F7BA-xxxx-xxxx-xxxx-846ECA1A9908
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTagValueResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteTagValueResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteTagValueResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTenantSecurityIpGroupRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The group name of the whitelist group of IP addresses.
   * 
   * It starts with lowercase letters and ends with lowercase letters or numbers. It can only contain lowercase letters, numbers, and underscores, and should be 2~32 characters in length.
   * 
   * This parameter is required.
   * 
   * @example
   * paytest
   */
  securityIpGroupName?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * t4louaeei****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      securityIpGroupName: 'SecurityIpGroupName',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      securityIpGroupName: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTenantSecurityIpGroupResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @remarks
   * The information of the whitelist group.
   */
  securityIpGroup?: DeleteTenantSecurityIpGroupResponseBodySecurityIpGroup;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      securityIpGroup: 'SecurityIpGroup',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      securityIpGroup: DeleteTenantSecurityIpGroupResponseBodySecurityIpGroup,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTenantSecurityIpGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteTenantSecurityIpGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteTenantSecurityIpGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTenantUsersRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * ob2mr3oae0****
   */
  tenantId?: string;
  /**
   * @remarks
   * A list of usernames.
   * 
   * This parameter is required.
   * 
   * @example
   * ["testUser"]
   */
  users?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      tenantId: 'TenantId',
      users: 'Users',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      tenantId: 'string',
      users: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTenantUsersResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTenantUsersResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteTenantUsersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteTenantUsersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTenantsRequest extends $tea.Model {
  /**
   * @remarks
   * You can call this operation to delete one or more tenants from an OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * ```
   * http(s)://[Endpoint]/?Action=DeleteTenants
   * &TenantIds=["ob2mr3oae0****", "ob2mr3oae1****"]
   * &InstanceId=ob317v4uif****
   * &Common request parameters
   * ```
   * 
   * This parameter is required.
   * 
   * @example
   * ["ob2mr3oae0****", "ob2mr3oae1****"]
   */
  tenantIds?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      tenantIds: 'TenantIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      tenantIds: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTenantsResponseBody extends $tea.Model {
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  tenantIds?: string[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      tenantIds: 'TenantIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      tenantIds: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTenantsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteTenantsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteTenantsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAnomalySQLListRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the returned data.   
   * Default value: CN for a China site and EN for an International site.
   * 
   * @example
   * zh-CN
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * testdb
   */
  dbName?: string;
  /**
   * @remarks
   * The end time of the time range for querying suspicious SQL statements.   
   * The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
   * 
   * This parameter is required.
   * 
   * @example
   * 2021-09-13T15:40:43Z
   */
  endTime?: string;
  /**
   * @remarks
   * The filter condition.   
   * > <br> - All fields in OceanBase Database support filtering. <br> - You can write the key-value pair of a parameter in a JSON string in the JSON format to filter the parameter.
   * 
   * @example
   * {
   *   "UserName":testUser
   * }
   */
  filterCondition?: { [key: string]: any };
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * obsd23j4f****
   */
  instanceId?: string;
  /**
   * @remarks
   * The IP address of the node.
   * 
   * @example
   * i-bp19y05uq6xpacyqnlrc
   */
  nodeIp?: string;
  /**
   * @remarks
   * The number of the page to return.    
   * - Start value: 1   
   * - Default value: 1
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of rows to return on each page.    
   * - Maximum value: 100   
   * - Default value: 10
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * SQLID.
   * 
   * @example
   * 8D6E84****0B8FB1823D199E2CA1****
   */
  SQLId?: string;
  /**
   * @remarks
   * The search keyword.
   * 
   * @example
   * update
   */
  searchKeyWord?: string;
  /**
   * @remarks
   * The search parameter.
   * 
   * @example
   * cputime
   */
  searchParameter?: string;
  /**
   * @remarks
   * The search rule.   
   * Valid values: "=", ">", ">=", "<", and "<="
   * 
   * @example
   * >
   */
  searchRule?: string;
  /**
   * @remarks
   * The search value.
   * 
   * @example
   * 0.01
   */
  searchValue?: string;
  /**
   * @remarks
   * The sorted column.
   * 
   * @example
   * cputime
   */
  sortColumn?: string;
  /**
   * @remarks
   * The sorting rule.
   * 
   * @example
   * desc
   */
  sortOrder?: string;
  /**
   * @remarks
   * The start time of the time range for querying suspicious SQL statements.   
   * The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
   * 
   * This parameter is required.
   * 
   * @example
   * 2021-06-13T15:40:43Z
   */
  startTime?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * t2mr3oae0****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      dbName: 'DbName',
      endTime: 'EndTime',
      filterCondition: 'FilterCondition',
      instanceId: 'InstanceId',
      nodeIp: 'NodeIp',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      SQLId: 'SQLId',
      searchKeyWord: 'SearchKeyWord',
      searchParameter: 'SearchParameter',
      searchRule: 'SearchRule',
      searchValue: 'SearchValue',
      sortColumn: 'SortColumn',
      sortOrder: 'SortOrder',
      startTime: 'StartTime',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      dbName: 'string',
      endTime: 'string',
      filterCondition: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      instanceId: 'string',
      nodeIp: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      SQLId: 'string',
      searchKeyWord: 'string',
      searchParameter: 'string',
      searchRule: 'string',
      searchValue: 'string',
      sortColumn: 'string',
      sortOrder: 'string',
      startTime: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAnomalySQLListShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the returned data.   
   * Default value: CN for a China site and EN for an International site.
   * 
   * @example
   * zh-CN
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * testdb
   */
  dbName?: string;
  /**
   * @remarks
   * The end time of the time range for querying suspicious SQL statements.   
   * The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
   * 
   * This parameter is required.
   * 
   * @example
   * 2021-09-13T15:40:43Z
   */
  endTime?: string;
  /**
   * @remarks
   * The filter condition.   
   * > <br> - All fields in OceanBase Database support filtering. <br> - You can write the key-value pair of a parameter in a JSON string in the JSON format to filter the parameter.
   * 
   * @example
   * {
   *   "UserName":testUser
   * }
   */
  filterConditionShrink?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * obsd23j4f****
   */
  instanceId?: string;
  /**
   * @remarks
   * The IP address of the node.
   * 
   * @example
   * i-bp19y05uq6xpacyqnlrc
   */
  nodeIp?: string;
  /**
   * @remarks
   * The number of the page to return.    
   * - Start value: 1   
   * - Default value: 1
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of rows to return on each page.    
   * - Maximum value: 100   
   * - Default value: 10
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * SQLID.
   * 
   * @example
   * 8D6E84****0B8FB1823D199E2CA1****
   */
  SQLId?: string;
  /**
   * @remarks
   * The search keyword.
   * 
   * @example
   * update
   */
  searchKeyWord?: string;
  /**
   * @remarks
   * The search parameter.
   * 
   * @example
   * cputime
   */
  searchParameter?: string;
  /**
   * @remarks
   * The search rule.   
   * Valid values: "=", ">", ">=", "<", and "<="
   * 
   * @example
   * >
   */
  searchRule?: string;
  /**
   * @remarks
   * The search value.
   * 
   * @example
   * 0.01
   */
  searchValue?: string;
  /**
   * @remarks
   * The sorted column.
   * 
   * @example
   * cputime
   */
  sortColumn?: string;
  /**
   * @remarks
   * The sorting rule.
   * 
   * @example
   * desc
   */
  sortOrder?: string;
  /**
   * @remarks
   * The start time of the time range for querying suspicious SQL statements.   
   * The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
   * 
   * This parameter is required.
   * 
   * @example
   * 2021-06-13T15:40:43Z
   */
  startTime?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * t2mr3oae0****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      dbName: 'DbName',
      endTime: 'EndTime',
      filterConditionShrink: 'FilterCondition',
      instanceId: 'InstanceId',
      nodeIp: 'NodeIp',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      SQLId: 'SQLId',
      searchKeyWord: 'SearchKeyWord',
      searchParameter: 'SearchParameter',
      searchRule: 'SearchRule',
      searchValue: 'SearchValue',
      sortColumn: 'SortColumn',
      sortOrder: 'SortOrder',
      startTime: 'StartTime',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      dbName: 'string',
      endTime: 'string',
      filterConditionShrink: 'string',
      instanceId: 'string',
      nodeIp: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      SQLId: 'string',
      searchKeyWord: 'string',
      searchParameter: 'string',
      searchRule: 'string',
      searchValue: 'string',
      sortColumn: 'string',
      sortOrder: 'string',
      startTime: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAnomalySQLListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The list of suspicious SQL statements.
   */
  anomalySQLList?: DescribeAnomalySQLListResponseBodyAnomalySQLList[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E
   */
  requestId?: string;
  /**
   * @remarks
   * The total count.
   * 
   * @example
   * 2
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      anomalySQLList: 'AnomalySQLList',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      anomalySQLList: { 'type': 'array', 'itemType': DescribeAnomalySQLListResponseBodyAnomalySQLList },
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAnomalySQLListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAnomalySQLListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAnomalySQLListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAvailableCpuResourceRequest extends $tea.Model {
  /**
   * @remarks
   * The CPU resources available.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * ```
   * http(s)://[Endpoint]/?Action=DescribeAvailableCpuResource
   * &InstanceId=ob317v4uif****
   * &TenantId=ob2mr3oae0****
   * &ModifyType=update
   * &Common request parameters
   * ```
   * 
   * @example
   * update
   */
  modifyType?: string;
  /**
   * @remarks
   * The operation that you want to perform.   
   * Set the value to **DescribeAvailableCpuResource**.
   * 
   * @example
   * ob2mr3oae0****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      modifyType: 'ModifyType',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      modifyType: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAvailableCpuResourceResponseBody extends $tea.Model {
  data?: DescribeAvailableCpuResourceResponseBodyData[];
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': DescribeAvailableCpuResourceResponseBodyData },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAvailableCpuResourceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAvailableCpuResourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAvailableCpuResourceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAvailableMemResourceRequest extends $tea.Model {
  /**
   * @remarks
   * The number of CPU cores.
   * 
   * This parameter is required.
   * 
   * @example
   * 14
   */
  cpuNum?: number;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * @example
   * ob2mr3oae0****
   */
  tenantId?: string;
  /**
   * @remarks
   * The number of resource distribution nodes in the tenant.   
   * The number is determined by the deployment mode of the cluster. If the cluster is deployed in 2-2-2 mode, the maximum number of resource distribution nodes is 2.
   * 
   * This parameter is required.
   * 
   * @example
   * 2
   */
  unitNum?: number;
  static names(): { [key: string]: string } {
    return {
      cpuNum: 'CpuNum',
      instanceId: 'InstanceId',
      tenantId: 'TenantId',
      unitNum: 'UnitNum',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cpuNum: 'number',
      instanceId: 'string',
      tenantId: 'string',
      unitNum: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAvailableMemResourceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The available memory size.
   */
  data?: DescribeAvailableMemResourceResponseBodyData;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: DescribeAvailableMemResourceResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAvailableMemResourceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAvailableMemResourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAvailableMemResourceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAvailableSpecRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @example
   * oceanbase.cluster.cd8.xlarge
   */
  spec?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * upgradespec
   */
  upgradeType?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      spec: 'Spec',
      upgradeType: 'UpgradeType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      spec: 'string',
      upgradeType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAvailableSpecResponseBody extends $tea.Model {
  data?: DescribeAvailableSpecResponseBodyData;
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: DescribeAvailableSpecResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAvailableSpecResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAvailableSpecResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAvailableSpecResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAvailableZoneRequest extends $tea.Model {
  /**
   * @example
   * x86
   */
  cpuArch?: string;
  /**
   * @example
   * multiple
   */
  deployType?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * cluster
   */
  instanceType?: string;
  /**
   * @example
   * 3.2.4.4
   */
  obVersion?: string;
  /**
   * @example
   * normal
   */
  series?: string;
  /**
   * @example
   * oceanbase.cluster.cd8.xlarge
   */
  spec?: string;
  static names(): { [key: string]: string } {
    return {
      cpuArch: 'CpuArch',
      deployType: 'DeployType',
      instanceType: 'InstanceType',
      obVersion: 'ObVersion',
      series: 'Series',
      spec: 'Spec',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cpuArch: 'string',
      deployType: 'string',
      instanceType: 'string',
      obVersion: 'string',
      series: 'string',
      spec: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAvailableZoneResponseBody extends $tea.Model {
  data?: DescribeAvailableZoneResponseBodyData;
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: DescribeAvailableZoneResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAvailableZoneResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAvailableZoneResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAvailableZoneResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackupSetDownloadLinkRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the download task corresponding to the target backup set.
   * 
   * This parameter is required.
   * 
   * @example
   * 1000002
   */
  downloadTaskId?: string;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      downloadTaskId: 'DownloadTaskId',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      downloadTaskId: 'string',
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackupSetDownloadLinkResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned data.
   */
  data?: DescribeBackupSetDownloadLinkResponseBodyData;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: DescribeBackupSetDownloadLinkResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackupSetDownloadLinkResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeBackupSetDownloadLinkResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeBackupSetDownloadLinkResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCharsetRequest extends $tea.Model {
  instanceId?: string;
  /**
   * @remarks
   * 实例的系列  - normal（默认）：标准集群版（云盘）  - normal_ssd：标准集群版（本地盘） - history：历史库集群版。
   * 
   * @example
   * normal
   */
  series?: string;
  /**
   * @remarks
   * The return result of the request.
   * 
   * This parameter is required.
   * 
   * @example
   * Oracle
   */
  tenantMode?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      series: 'Series',
      tenantMode: 'TenantMode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      series: 'string',
      tenantMode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCharsetResponseBody extends $tea.Model {
  /**
   * @remarks
   * ```
   * http(s)://[Endpoint]/?Action=DescribeCharset
   * &TenantMode=Oracle
   * &Common request parameters
   * ```
   */
  charset?: DescribeCharsetResponseBodyCharset[];
  /**
   * @remarks
   * The operation that you want to perform.   
   * Set the value to **DescribeCharset**.
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      charset: 'Charset',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      charset: { 'type': 'array', 'itemType': DescribeCharsetResponseBodyCharset },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCharsetResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeCharsetResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeCharsetResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDataBackupSetRequest extends $tea.Model {
  /**
   * @example
   * tenant
   */
  backupObjectType?: string;
  /**
   * @example
   * 2023-01-06T15:59:59Z
   */
  endTime?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * 2022-12-27T16:00:00Z
   */
  startTime?: string;
  /**
   * @example
   * DONE
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      backupObjectType: 'BackupObjectType',
      endTime: 'EndTime',
      instanceId: 'InstanceId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      startTime: 'StartTime',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      backupObjectType: 'string',
      endTime: 'string',
      instanceId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      startTime: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDataBackupSetResponseBody extends $tea.Model {
  data?: DescribeDataBackupSetResponseBodyData[];
  /**
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @example
   * 2
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': DescribeDataBackupSetResponseBodyData },
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDataBackupSetResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDataBackupSetResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDataBackupSetResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDatabasesRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the database.    
   * You cannot use reserved keywords, such as test and mysql.
   * 
   * @example
   * sms_pre
   */
  databaseName?: string;
  /**
   * @remarks
   * The ID of the cluster.
   * 
   * @example
   * ob****n0abo9uo
   */
  instanceId?: string;
  /**
   * @remarks
   * The number of the page returned.  
   * - Start value: 1   
   * - Default value: 1
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of rows returned on each page.  
   * - Maximum value: 100.  
   * - Default value: 10
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The search keyword.
   * 
   * @example
   * pay
   */
  searchKey?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * @example
   * ob2mr3oae0****
   */
  tenantId?: string;
  /**
   * @remarks
   * Specifies whether to return the information about tables in the database.
   * Default value: false. 
   * > The operation may time out if the database contains a large number of tables.
   * 
   * @example
   * true
   */
  withTables?: boolean;
  static names(): { [key: string]: string } {
    return {
      databaseName: 'DatabaseName',
      instanceId: 'InstanceId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      searchKey: 'SearchKey',
      tenantId: 'TenantId',
      withTables: 'WithTables',
    };
  }

  static types(): { [key: string]: any } {
    return {
      databaseName: 'string',
      instanceId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      searchKey: 'string',
      tenantId: 'string',
      withTables: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDatabasesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The list of databases in the tenant.
   */
  databases?: DescribeDatabasesResponseBodyDatabases[];
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of databases in the tenant.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      databases: 'Databases',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      databases: { 'type': 'array', 'itemType': DescribeDatabasesResponseBodyDatabases },
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDatabasesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDatabasesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDatabasesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceRequest extends $tea.Model {
  /**
   * @remarks
   * The size of the data disk, in GB.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  maxConnectionLimit?: string;
  /**
   * @remarks
   * The information about the storage resources of the cluster.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      maxConnectionLimit: 'MaxConnectionLimit',
      pageNumber: 'PageNumber',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      maxConnectionLimit: 'string',
      pageNumber: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The log disk space of each replica node in the cluster. Unit: GB.
   */
  instance?: DescribeInstanceResponseBodyInstance;
  /**
   * @remarks
   * The total log disk space of the cluster, in GB.
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      instance: 'Instance',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instance: DescribeInstanceResponseBodyInstance,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceCreatableZoneRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the zone.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceCreatableZoneResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the cluster is deployed in the zone.
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @remarks
   * The operation that you want to perform.   
   * Set the value to **DescribeInstanceCreatableZone**.
   */
  zoneList?: DescribeInstanceCreatableZoneResponseBodyZoneList[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      zoneList: 'ZoneList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      zoneList: { 'type': 'array', 'itemType': DescribeInstanceCreatableZoneResponseBodyZoneList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceCreatableZoneResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeInstanceCreatableZoneResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeInstanceCreatableZoneResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceSSLRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceSSLResponseBody extends $tea.Model {
  instanceSSL?: DescribeInstanceSSLResponseBodyInstanceSSL;
  /**
   * @example
   * EE205C00-30E4-xxxx-xxxx-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceSSL: 'InstanceSSL',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceSSL: DescribeInstanceSSLResponseBodyInstanceSSL,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceSSLResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeInstanceSSLResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeInstanceSSLResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceSecurityConfigsRequest extends $tea.Model {
  /**
   * @remarks
   * The unique identifier of the check.
   * 
   * @example
   * xxx
   */
  checkId?: string;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      checkId: 'CheckId',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkId: 'string',
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceSecurityConfigsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The return result of the request.
   */
  instanceSecurityConfigs?: DescribeInstanceSecurityConfigsResponseBodyInstanceSecurityConfigs;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceSecurityConfigs: 'InstanceSecurityConfigs',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceSecurityConfigs: DescribeInstanceSecurityConfigsResponseBodyInstanceSecurityConfigs,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceSecurityConfigsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeInstanceSecurityConfigsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeInstanceSecurityConfigsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTagsRequest extends $tea.Model {
  /**
   * @remarks
   * The list of cluster IDs.
   * 
   * @example
   * ["ob3za5w73as8rk"]
   */
  instanceIds?: string;
  /**
   * @remarks
   * The tags.
   * 
   * @example
   * [{"Key": "xxx", "Value", "xxx"},{}]
   */
  tags?: string;
  static names(): { [key: string]: string } {
    return {
      instanceIds: 'InstanceIds',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceIds: 'string',
      tags: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTagsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @remarks
   * The list of tags.
   */
  tagResources?: DescribeInstanceTagsResponseBodyTagResources[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      tagResources: 'TagResources',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      tagResources: { 'type': 'array', 'itemType': DescribeInstanceTagsResponseBodyTagResources },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTagsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeInstanceTagsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeInstanceTagsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTenantModesRequest extends $tea.Model {
  /**
   * @remarks
   * The operation that you want to perform.   
   * Set the value to **DescribeInstanceTenantModes**.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTenantModesResponseBody extends $tea.Model {
  instanceModes?: string[];
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceModes: 'InstanceModes',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceModes: { 'type': 'array', 'itemType': 'string' },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTenantModesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeInstanceTenantModesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeInstanceTenantModesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTopologyRequest extends $tea.Model {
  /**
   * @remarks
   * The status of the node.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTopologyResponseBody extends $tea.Model {
  /**
   * @remarks
   * The number of CPU cores used by the node.
   */
  instanceTopology?: DescribeInstanceTopologyResponseBodyInstanceTopology;
  /**
   * @remarks
   * The information about the CPU resources of the node.
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceTopology: 'InstanceTopology',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceTopology: DescribeInstanceTopologyResponseBodyInstanceTopology,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTopologyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeInstanceTopologyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeInstanceTopologyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The name of the OceanBase cluster. It must be 1 to 20 characters in length. If this parameter is not specified, the value is the instance ID of the cluster by default.
   * 
   * @example
   * ob4prod
   */
  instanceName?: string;
  /**
   * @remarks
   * The number of the page to return.
   * - Pages start from page 1.
   * - Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of rows to return on each page.
   * - Maximum value: 100.
   * - Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the resource group. If you do not specify this parameter, all resources are returned.
   * 
   * @example
   * group1
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The keyword for fuzzy search, which can be an instance ID, instance name, tenant ID, or tenant name.
   * 
   * @example
   * pay
   */
  searchKey?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      resourceGroupId: 'ResourceGroupId',
      searchKey: 'SearchKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      instanceName: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      resourceGroupId: 'string',
      searchKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information of the OceanBase cluster.
   */
  instances?: DescribeInstancesResponseBodyInstances[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @remarks
   * The number of OceanBase clusters queried.
   * 
   * @example
   * 2
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      instances: 'Instances',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instances: { 'type': 'array', 'itemType': DescribeInstancesResponseBodyInstances },
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeInstancesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricsDataRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 2021-06-13T15:40:43Z
   */
  endTime?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * app,clusterId
   */
  groupByLabels?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * app:OB,clusterId:ob***
   */
  labels?: string;
  /**
   * @example
   * 5
   */
  limit?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * tps
   */
  metrics?: string;
  replicaType?: string;
  /**
   * @example
   * tps
   */
  sortMetricKey?: string;
  /**
   * @example
   * DESC
   */
  sortOrder?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 2021-06-13T15:40:43Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      groupByLabels: 'GroupByLabels',
      instanceId: 'InstanceId',
      labels: 'Labels',
      limit: 'Limit',
      metrics: 'Metrics',
      replicaType: 'ReplicaType',
      sortMetricKey: 'SortMetricKey',
      sortOrder: 'SortOrder',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      groupByLabels: 'string',
      instanceId: 'string',
      labels: 'string',
      limit: 'string',
      metrics: 'string',
      replicaType: 'string',
      sortMetricKey: 'string',
      sortOrder: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricsDataResponseBody extends $tea.Model {
  /**
   * @example
   * [
   *                 {
   *                     "sql_select_count":75.****15****1515,
   *                     "timestamp":165079****
   *                 },
   *                 ......
   *             ]
   */
  data?: string[];
  /**
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': 'string' },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricsDataResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeMetricsDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeMetricsDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNodeMetricsRequest extends $tea.Model {
  /**
   * @remarks
   * $.parameters[7].schema.description
   * 
   * This parameter is required.
   * 
   * @example
   * 2021-09-13T15:40:43Z
   */
  endTime?: string;
  /**
   * @remarks
   * The list of nodes.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * $.parameters[7].schema.enumValueTitles
   * 
   * This parameter is required.
   * 
   * @example
   * tps
   */
  metrics?: string;
  /**
   * @remarks
   * $.parameters[10].schema.description
   * 
   * @example
   * [i-bp16niirq4zdmgvm****,i-bp16n56hq4z4fgvm****]
   */
  nodeIdList?: string;
  /**
   * @remarks
   * $.parameters[8].schema.example
   * 
   * @example
   * i-bp16niirq4zdmgvm****
   */
  nodeName?: string;
  /**
   * @remarks
   * $.parameters[6].schema.description
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * $.parameters[9].schema.example
   * 
   * This parameter is required.
   * 
   * @example
   * 2021-06-13T15:40:43Z
   */
  startTime?: string;
  /**
   * @remarks
   * $.parameters[6].schema.enumValueTitles
   * 
   * @example
   * tfafd34fs****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      instanceId: 'InstanceId',
      metrics: 'Metrics',
      nodeIdList: 'NodeIdList',
      nodeName: 'NodeName',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      startTime: 'StartTime',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      instanceId: 'string',
      metrics: 'string',
      nodeIdList: 'string',
      nodeName: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      startTime: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNodeMetricsResponseBody extends $tea.Model {
  /**
   * @example
   * -
   */
  nodeMetrics?: string;
  /**
   * @remarks
   * You can call this operation to query the detailed metrics information of an OceanBase Database node.
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @remarks
   * ```
   * http(s)://[Endpoint]/?Action=DescribeNodeMetrics
   * &InstanceId=ob317v4uif****
   * &PageSize=10
   * &PageNumber=1
   * &TenantId=ob2mr3oae0****
   * &StartTime=2021-06-13 15:40:43
   * &EndTime=2021-09-13 15:40:43
   * &Metrics=tps
   * &NodeName=i-bp16niirq4zdmgvm****
   * &NodeIdList=["i-bp19y05uq6xpacyqnlrc","i-bp1blcr3htr3g3u2vqvu","i-bp1392ikhayhr3hi4fli"]
   * &Common request parameters
   * ```
   * 
   * @example
   * 9
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      nodeMetrics: 'NodeMetrics',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeMetrics: 'string',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNodeMetricsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeNodeMetricsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeNodeMetricsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOasAnomalySQLListRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * - zh: Chinese
   * - en: English
   * 
   * @example
   * zh-CN
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The current page.
   * 
   * @example
   * 1
   */
  current?: number;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * db_****
   */
  dbName?: string;
  dynamicSql?: boolean;
  /**
   * @remarks
   * The end time of the monitoring data.   
   * The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-04-12T05:38:38Z
   */
  endTime?: string;
  /**
   * @remarks
   * All parameters are referenced by the symbol @. For a list of available parameters, refer to the returned parameters in [Query performance indicators of an SQL statement](https://en.oceanbase.com/docs/community-ocp-en-10000000000840290).
   * 
   * @example
   * @avgCpuTime > 20 and @executions > 100
   */
  filterCondition?: string;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  mergeDynamicSql?: boolean;
  /**
   * @remarks
   * The node IP.
   * 
   * @example
   * i-bp19y05uq6x*********
   */
  nodeIp?: string;
  /**
   * @remarks
   * Page size.
   * - Start value: 1
   * - Default value: 1
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The search keyword.
   * 
   * @example
   * update
   */
  searchKeyWord?: string;
  /**
   * @remarks
   * The search parameter.
   * 
   * @example
   * cputime
   */
  searchParam?: string;
  /**
   * @remarks
   * The search rule.   
   * Valid values: "=", ">", ">=", "<", and "<="
   * 
   * @example
   * >
   */
  searchRule?: string;
  /**
   * @remarks
   * The search value.
   * 
   * @example
   * 0.01
   */
  searchValue?: string;
  /**
   * @remarks
   * SQL ID.
   * 
   * @example
   * 8D6E84****0B8FB1823D199E2CA1****
   */
  sqlId?: string;
  /**
   * @remarks
   * Max length of the returned SQL text.
   * 
   * @example
   * 65535
   */
  sqlTextLength?: number;
  /**
   * @remarks
   * The start time of the monitoring data.   
   * The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-04-12T04:38:38Z
   */
  startTime?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * t4louaeei****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      current: 'Current',
      dbName: 'DbName',
      dynamicSql: 'DynamicSql',
      endTime: 'EndTime',
      filterCondition: 'FilterCondition',
      instanceId: 'InstanceId',
      mergeDynamicSql: 'MergeDynamicSql',
      nodeIp: 'NodeIp',
      pageSize: 'PageSize',
      searchKeyWord: 'SearchKeyWord',
      searchParam: 'SearchParam',
      searchRule: 'SearchRule',
      searchValue: 'SearchValue',
      sqlId: 'SqlId',
      sqlTextLength: 'SqlTextLength',
      startTime: 'StartTime',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      current: 'number',
      dbName: 'string',
      dynamicSql: 'boolean',
      endTime: 'string',
      filterCondition: 'string',
      instanceId: 'string',
      mergeDynamicSql: 'boolean',
      nodeIp: 'string',
      pageSize: 'number',
      searchKeyWord: 'string',
      searchParam: 'string',
      searchRule: 'string',
      searchValue: 'string',
      sqlId: 'string',
      sqlTextLength: 'number',
      startTime: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOasAnomalySQLListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The list of suspicious SQLs.
   */
  data?: DescribeOasAnomalySQLListResponseBodyData[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 473469**-AA6F-4D**-B3DB-A***********
   */
  requestId?: string;
  /**
   * @remarks
   * The total count.
   * 
   * @example
   * 9
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': DescribeOasAnomalySQLListResponseBodyData },
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOasAnomalySQLListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeOasAnomalySQLListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeOasAnomalySQLListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOasSQLDetailsRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the database.
   * 
   * This parameter is required.
   * 
   * @example
   * test_db
   */
  dbName?: string;
  dynamicSql?: boolean;
  /**
   * @remarks
   * The end time of querying the SQL execution plan.   
   * The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-04-12T05:38:38Z
   */
  endTime?: string;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  parseTable?: boolean;
  /**
   * @remarks
   * SQL ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 8D6E84****0B8FB1823D199E2CA1****
   */
  sqlId?: string;
  /**
   * @remarks
   * The start time of querying the SQL execution plan.   
   * The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-04-12T04:38:38Z
   */
  startTime?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * t4louaeei****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      dbName: 'DbName',
      dynamicSql: 'DynamicSql',
      endTime: 'EndTime',
      instanceId: 'InstanceId',
      parseTable: 'ParseTable',
      sqlId: 'SqlId',
      startTime: 'StartTime',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbName: 'string',
      dynamicSql: 'boolean',
      endTime: 'string',
      instanceId: 'string',
      parseTable: 'boolean',
      sqlId: 'string',
      startTime: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOasSQLDetailsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The list of the SQL execution plan.
   */
  data?: DescribeOasSQLDetailsResponseBodyData;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: DescribeOasSQLDetailsResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOasSQLDetailsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeOasSQLDetailsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeOasSQLDetailsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOasSQLHistoryListRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * - zh: Chinese
   * - en: English
   * 
   * @example
   * zh-CN
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * test_db
   */
  dbName?: string;
  dynamicSql?: boolean;
  /**
   * @remarks
   * The end time of querying the execution history of the SQL statement.   
   * The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-04-12T05:38:38Z
   */
  endTime?: string;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The IP address of the node.
   * 
   * @example
   * i-bp19y05uq6x*********
   */
  nodeIp?: string;
  /**
   * @remarks
   * SQL ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 8D6E84****0B8FB1823D199E2CA1****
   */
  sqlId?: string;
  /**
   * @remarks
   * The start time of querying the execution history of the SQL statement.   
   * The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-04-12T04:38:38Z
   */
  startTime?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * t4louaeei****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      dbName: 'DbName',
      dynamicSql: 'DynamicSql',
      endTime: 'EndTime',
      instanceId: 'InstanceId',
      nodeIp: 'NodeIp',
      sqlId: 'SqlId',
      startTime: 'StartTime',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      dbName: 'string',
      dynamicSql: 'boolean',
      endTime: 'string',
      instanceId: 'string',
      nodeIp: 'string',
      sqlId: 'string',
      startTime: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOasSQLHistoryListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The list of SQL execution history.
   */
  data?: DescribeOasSQLHistoryListResponseBodyData[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': DescribeOasSQLHistoryListResponseBodyData },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOasSQLHistoryListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeOasSQLHistoryListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeOasSQLHistoryListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOasSQLPlansRequest extends $tea.Model {
  /**
   * @remarks
   * Supported language. Valid values:
   * - zh-CN: Chinese
   * - en-US: English
   * 
   * @example
   * zh-CN
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The name of the database.
   * 
   * This parameter is required.
   * 
   * @example
   * test_db
   */
  dbName?: string;
  dynamicSql?: boolean;
  /**
   * @remarks
   * The end time of querying the SQL execution plan.   
   * The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-04-12T05:38:38Z
   */
  endTime?: string;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  planUnionHash?: string;
  returnBriefInfo?: boolean;
  /**
   * @remarks
   * SQL ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 8D6E84****0B8FB1823D199E2CA1****
   */
  sqlId?: string;
  /**
   * @remarks
   * The start time of querying the SQL execution plan.   
   * The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-04-12T04:38:38Z
   */
  startTime?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * t4louaeei****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      dbName: 'DbName',
      dynamicSql: 'DynamicSql',
      endTime: 'EndTime',
      instanceId: 'InstanceId',
      planUnionHash: 'PlanUnionHash',
      returnBriefInfo: 'ReturnBriefInfo',
      sqlId: 'SqlId',
      startTime: 'StartTime',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      dbName: 'string',
      dynamicSql: 'boolean',
      endTime: 'string',
      instanceId: 'string',
      planUnionHash: 'string',
      returnBriefInfo: 'boolean',
      sqlId: 'string',
      startTime: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOasSQLPlansResponseBody extends $tea.Model {
  /**
   * @remarks
   * The list of SQL execution plan.
   */
  data?: DescribeOasSQLPlansResponseBodyData[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': DescribeOasSQLPlansResponseBodyData },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOasSQLPlansResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeOasSQLPlansResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeOasSQLPlansResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOasSlowSQLListRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response.
   * 
   * @example
   * zh-CN
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * test_db
   */
  dbName?: string;
  dynamicSql?: boolean;
  /**
   * @remarks
   * The end time of querying slow SQL historical parameters.   
   * The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-04-12T05:38:38Z
   */
  endTime?: string;
  /**
   * @remarks
   * All parameters are referenced by the symbol @. For a list of available parameters, refer to the returned parameters in [Query performance indicators of an SQL statement](https://en.oceanbase.com/docs/community-ocp-en-10000000000840290).
   * 
   * @example
   * @avgCpuTime > 20 and @executions > 100
   */
  filterCondition?: string;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  mergeDynamicSql?: boolean;
  /**
   * @remarks
   * The IP of the database node.
   * 
   * @example
   * i-bp18qljorblo8es*****
   */
  nodeIp?: string;
  /**
   * @remarks
   * The search keyword.
   * 
   * @example
   * update
   */
  searchKeyWord?: string;
  /**
   * @remarks
   * The search parameter.
   * 
   * @example
   * cputime
   */
  searchParam?: string;
  /**
   * @remarks
   * The search rule.
   * 
   * @example
   * >
   */
  searchRule?: string;
  /**
   * @remarks
   * The search value.
   * 
   * @example
   * 0.01
   */
  searchValue?: string;
  /**
   * @remarks
   * SQL ID, the unique identifier of the SQL.
   * 
   * @example
   * 8D6E84****0B8FB1823D199E2CA1****
   */
  sqlId?: string;
  /**
   * @remarks
   * Max length of the returned SQL text.
   * 
   * @example
   * 65535
   */
  sqlTextLength?: number;
  /**
   * @remarks
   * The start time of querying slow SQL historical parameters.   
   * The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-04-12T04:38:38Z
   */
  startTime?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * t4louaeei****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      dbName: 'DbName',
      dynamicSql: 'DynamicSql',
      endTime: 'EndTime',
      filterCondition: 'FilterCondition',
      instanceId: 'InstanceId',
      mergeDynamicSql: 'MergeDynamicSql',
      nodeIp: 'NodeIp',
      searchKeyWord: 'SearchKeyWord',
      searchParam: 'SearchParam',
      searchRule: 'SearchRule',
      searchValue: 'SearchValue',
      sqlId: 'SqlId',
      sqlTextLength: 'SqlTextLength',
      startTime: 'StartTime',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      dbName: 'string',
      dynamicSql: 'boolean',
      endTime: 'string',
      filterCondition: 'string',
      instanceId: 'string',
      mergeDynamicSql: 'boolean',
      nodeIp: 'string',
      searchKeyWord: 'string',
      searchParam: 'string',
      searchRule: 'string',
      searchValue: 'string',
      sqlId: 'string',
      sqlTextLength: 'number',
      startTime: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOasSlowSQLListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The list of slow queries.
   */
  data?: DescribeOasSlowSQLListResponseBodyData[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': DescribeOasSlowSQLListResponseBodyData },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOasSlowSQLListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeOasSlowSQLListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeOasSlowSQLListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOasTopSQLListRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * - zh: Chinese
   * - en: English
   * 
   * @example
   * zh-CN
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * test_db
   */
  dbName?: string;
  dynamicSql?: boolean;
  /**
   * @remarks
   * The end time of querying the TOPSQL parameter.
   * The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-04-12T05:38:38Z
   */
  endTime?: string;
  /**
   * @remarks
   * All parameters are referenced by the symbol @. For a list of available parameters, refer to the returned parameters in [Query performance indicators of an SQL statement](https://en.oceanbase.com/docs/community-ocp-en-10000000000840290).
   * 
   * @example
   * @avgCpuTime > 20 and @executions > 100
   */
  filterCondition?: string;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  mergeDynamicSql?: boolean;
  /**
   * @remarks
   * The node IP.
   * 
   * @example
   * i-bp18l4****str4uk03
   */
  nodeIp?: string;
  /**
   * @remarks
   * The search keyword.
   * 
   * @example
   * update
   */
  searchKeyWord?: string;
  /**
   * @remarks
   * The search parameter.
   * 
   * @example
   * cputime
   */
  searchParam?: string;
  /**
   * @remarks
   * The search rule.
   * 
   * @example
   * >
   */
  searchRule?: string;
  /**
   * @remarks
   * The search value.
   * 
   * @example
   * 0.01
   */
  searchValue?: string;
  /**
   * @remarks
   * SQL ID.
   * > When the SQL ID is provided, the system collects all the request data for the target SQL ID. When the SQL ID is empty, the system collects all the request data for the entire database instance.
   * 
   * @example
   * 8D6E84****0B8FB1823D199E2CA1****
   */
  sqlId?: string;
  /**
   * @remarks
   * Max length of the returned SQL text.
   * 
   * @example
   * 65535
   */
  sqlTextLength?: number;
  /**
   * @remarks
   * The start time of querying the TOPSQL parameter.   
   * The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-04-12T04:38:38Z
   */
  startTime?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * t4louaeei****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      dbName: 'DbName',
      dynamicSql: 'DynamicSql',
      endTime: 'EndTime',
      filterCondition: 'FilterCondition',
      instanceId: 'InstanceId',
      mergeDynamicSql: 'MergeDynamicSql',
      nodeIp: 'NodeIp',
      searchKeyWord: 'SearchKeyWord',
      searchParam: 'SearchParam',
      searchRule: 'SearchRule',
      searchValue: 'SearchValue',
      sqlId: 'SqlId',
      sqlTextLength: 'SqlTextLength',
      startTime: 'StartTime',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      dbName: 'string',
      dynamicSql: 'boolean',
      endTime: 'string',
      filterCondition: 'string',
      instanceId: 'string',
      mergeDynamicSql: 'boolean',
      nodeIp: 'string',
      searchKeyWord: 'string',
      searchParam: 'string',
      searchRule: 'string',
      searchValue: 'string',
      sqlId: 'string',
      sqlTextLength: 'number',
      startTime: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOasTopSQLListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The list of Top SQL.
   */
  data?: DescribeOasTopSQLListResponseBodyData[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': DescribeOasTopSQLListResponseBodyData },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOasTopSQLListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeOasTopSQLListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeOasTopSQLListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOutlineBindingRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the database.
   * 
   * This parameter is required.
   * 
   * @example
   * testdb
   */
  databaseName?: string;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * - When the value is set to True, the throttling information in the database is queried based on the SQL ID.   
   * - When the value is set to False, the bound index or execution plan in the database is queried based on the SQL ID.
   * 
   * @example
   * false
   */
  isConcurrentLimit?: boolean;
  /**
   * @remarks
   * SQLID.
   * 
   * This parameter is required.
   * 
   * @example
   * 8D6E84****0B8FB1823D199E2CA1****
   */
  SQLId?: string;
  /**
   * @remarks
   * The name of the tenant.    
   * It must start with a letter or an underscore (_), and contain 2 to 20 characters, which can be uppercase letters, lowercase letters, digits, and underscores (_). It cannot be set to SYS.
   * 
   * This parameter is required.
   * 
   * @example
   * pay_online
   */
  tableName?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * t2mr3oae0****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      databaseName: 'DatabaseName',
      instanceId: 'InstanceId',
      isConcurrentLimit: 'IsConcurrentLimit',
      SQLId: 'SQLId',
      tableName: 'TableName',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      databaseName: 'string',
      instanceId: 'string',
      isConcurrentLimit: 'boolean',
      SQLId: 'string',
      tableName: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOutlineBindingResponseBody extends $tea.Model {
  /**
   * @remarks
   * The binding information.
   */
  outlineBinding?: DescribeOutlineBindingResponseBodyOutlineBinding;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      outlineBinding: 'OutlineBinding',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      outlineBinding: DescribeOutlineBindingResponseBodyOutlineBinding,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOutlineBindingResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeOutlineBindingResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeOutlineBindingResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeParametersRequest extends $tea.Model {
  /**
   * @remarks
   * It is an online CLI tool that allows you to quickly retrieve and debug APIs. It can dynamically generate executable SDK code samples.
   * 
   * This parameter is required.
   * 
   * @example
   * TENANT
   */
  dimension?: string;
  /**
   * @remarks
   * Alibaba Cloud CLI
   * 
   * @example
   * ob2mr3oae0****
   */
  dimensionValue?: string;
  /**
   * @remarks
   * 498529
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      dimension: 'Dimension',
      dimensionValue: 'DimensionValue',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dimension: 'string',
      dimensionValue: 'string',
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeParametersResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether a restart is required for changes to the parameter to take effect. Valid values:   
   * - true: A restart is required.   
   * - false: A restart is not required.
   */
  parameters?: DescribeParametersResponseBodyParameters[];
  /**
   * @remarks
   * The return result of the request.
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      parameters: 'Parameters',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      parameters: { 'type': 'array', 'itemType': DescribeParametersResponseBodyParameters },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeParametersResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeParametersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeParametersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeParametersHistoryRequest extends $tea.Model {
  /**
   * @remarks
   * The type of the parameter.   
   * Valid values: CLUSTER and TENANT.
   * 
   * This parameter is required.
   * 
   * @example
   * TENANT
   */
  dimension?: string;
  /**
   * @remarks
   * The resource ID of the parameter type.   
   * You can leave this parameter unspecified when you call this operation to query the modification history of cluster parameters. In the case of tenant parameters, pass the tenant ID.
   * 
   * @example
   * ob2mr3oae0****
   */
  dimensionValue?: string;
  /**
   * @remarks
   * The end time for the query of parameter modification history.
   * 
   * This parameter is required.
   * 
   * @example
   * 2021-09-13 15:40:43
   */
  endTime?: string;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The number of the page to return.    
   * - Start value: 1   
   * - Default value: 1
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of rows to return on each page.   
   * - Maximum value: 100   
   * - Default value: 10
   * 
   * This parameter is required.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The start time of the time range for querying the parameter modification history.
   * 
   * This parameter is required.
   * 
   * @example
   * 2021-06-13 15:40:43
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      dimension: 'Dimension',
      dimensionValue: 'DimensionValue',
      endTime: 'EndTime',
      instanceId: 'InstanceId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dimension: 'string',
      dimensionValue: 'string',
      endTime: 'string',
      instanceId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeParametersHistoryResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @remarks
   * The list of parameter modification records.
   */
  respond?: DescribeParametersHistoryResponseBodyRespond[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      respond: 'Respond',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      respond: { 'type': 'array', 'itemType': DescribeParametersHistoryResponseBodyRespond },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeParametersHistoryResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeParametersHistoryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeParametersHistoryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProcessStatsCompositionRequest extends $tea.Model {
  /**
   * @remarks
   * The IP address of the client.
   * 
   * @example
   * 127.*.*.*
   */
  clientIp?: string;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The IP address of the server.
   * 
   * @example
   * 127.*.*.*
   */
  serverIp?: string;
  /**
   * @remarks
   * The SQL statement. It supports LIKE clauses, and you may specify only part of the clauses in the SQL statement.
   * 
   * @example
   * SELECT  ****   FROM ****   WHERE **** = ? AND **** = ?   ORDER BY **** ASC
   */
  sqlText?: string;
  /**
   * @remarks
   * The state of the session.
   * 
   * @example
   * ACTIVE
   */
  status?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * @example
   * t33h8y08k****
   */
  tenantId?: string;
  /**
   * @remarks
   * The user identifier (UID) of OceanBase Database.
   * 
   * @example
   * 139*************
   */
  UId?: string;
  /**
   * @remarks
   * The username that you use to log in to the database.
   * 
   * @example
   * test1
   */
  users?: string;
  static names(): { [key: string]: string } {
    return {
      clientIp: 'ClientIp',
      instanceId: 'InstanceId',
      serverIp: 'ServerIp',
      sqlText: 'SqlText',
      status: 'Status',
      tenantId: 'TenantId',
      UId: 'UId',
      users: 'Users',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clientIp: 'string',
      instanceId: 'string',
      serverIp: 'string',
      sqlText: 'string',
      status: 'string',
      tenantId: 'string',
      UId: 'string',
      users: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProcessStatsCompositionResponseBody extends $tea.Model {
  /**
   * @remarks
   * The return result.
   */
  data?: DescribeProcessStatsCompositionResponseBodyData;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: DescribeProcessStatsCompositionResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProcessStatsCompositionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeProcessStatsCompositionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeProcessStatsCompositionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * np_fe****
   */
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBody extends $tea.Model {
  /**
   * @example
   * Contact the administrator.
   */
  advice?: string;
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  /**
   * @example
   * 1
   */
  cost?: string;
  data?: DescribeProjectResponseBodyData;
  errorDetail?: DescribeProjectResponseBodyErrorDetail;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * 473469C7-XXXX-XXXX-B3DB-A3DC0DE3C83E
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 2
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      cost: 'Cost',
      data: 'Data',
      errorDetail: 'ErrorDetail',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      cost: 'string',
      data: DescribeProjectResponseBodyData,
      errorDetail: DescribeProjectResponseBodyErrorDetail,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeProjectResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeProjectResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectComponentsRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * np_4w3a****
   */
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectComponentsResponseBody extends $tea.Model {
  /**
   * @example
   * Contact the administrator.
   */
  advice?: string;
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  /**
   * @example
   * 48
   */
  cost?: string;
  data?: DescribeProjectComponentsResponseBodyData;
  errorDetail?: DescribeProjectComponentsResponseBodyErrorDetail;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 9
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      cost: 'Cost',
      data: 'Data',
      errorDetail: 'ErrorDetail',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      cost: 'string',
      data: DescribeProjectComponentsResponseBodyData,
      errorDetail: DescribeProjectComponentsResponseBodyErrorDetail,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectComponentsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeProjectComponentsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeProjectComponentsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectProgressRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * np_4w3a****
   */
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectProgressResponseBody extends $tea.Model {
  /**
   * @example
   * Contact the administrator.
   */
  advice?: string;
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  /**
   * @example
   * 1
   */
  cost?: string;
  data?: DescribeProjectProgressResponseBodyData;
  errorDetail?: DescribeProjectProgressResponseBodyErrorDetail;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 1
   */
  pageSize?: number;
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      cost: 'Cost',
      data: 'Data',
      errorDetail: 'ErrorDetail',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      cost: 'string',
      data: DescribeProjectProgressResponseBodyData,
      errorDetail: DescribeProjectProgressResponseBodyErrorDetail,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectProgressResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeProjectProgressResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeProjectProgressResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectStepMetricRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * AVG
   */
  aggregator?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1689244696
   */
  beginTimestamp?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1689254646
   */
  endTimestamp?: number;
  /**
   * @example
   * 6
   */
  maxPointNum?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * RPS
   */
  metricType?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * np_dr****
   */
  projectId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * FULL_TRANSFER
   */
  stepName?: string;
  static names(): { [key: string]: string } {
    return {
      aggregator: 'Aggregator',
      beginTimestamp: 'BeginTimestamp',
      endTimestamp: 'EndTimestamp',
      maxPointNum: 'MaxPointNum',
      metricType: 'MetricType',
      projectId: 'ProjectId',
      stepName: 'StepName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aggregator: 'string',
      beginTimestamp: 'number',
      endTimestamp: 'number',
      maxPointNum: 'number',
      metricType: 'string',
      projectId: 'string',
      stepName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectStepMetricResponseBody extends $tea.Model {
  /**
   * @example
   * Contact the administrator.
   */
  advice?: string;
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  /**
   * @example
   * 1
   */
  cost?: string;
  data?: DescribeProjectStepMetricResponseBodyData;
  errorDetail?: DescribeProjectStepMetricResponseBodyErrorDetail;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      cost: 'Cost',
      data: 'Data',
      errorDetail: 'ErrorDetail',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      cost: 'string',
      data: DescribeProjectStepMetricResponseBodyData,
      errorDetail: DescribeProjectStepMetricResponseBodyErrorDetail,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectStepMetricResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeProjectStepMetricResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeProjectStepMetricResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectStepsRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * np_4w3a****
   */
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectStepsResponseBody extends $tea.Model {
  /**
   * @example
   * Contact the administrator.
   */
  advice?: string;
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  /**
   * @example
   * 1
   */
  cost?: string;
  data?: DescribeProjectStepsResponseBodyData[];
  errorDetail?: DescribeProjectStepsResponseBodyErrorDetail;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 4
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      cost: 'Cost',
      data: 'Data',
      errorDetail: 'ErrorDetail',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      cost: 'string',
      data: { 'type': 'array', 'itemType': DescribeProjectStepsResponseBodyData },
      errorDetail: DescribeProjectStepsResponseBodyErrorDetail,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectStepsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeProjectStepsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeProjectStepsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRecommendIndexRequest extends $tea.Model {
  /**
   * @remarks
   * The return result of the request.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * 8D6E84****0B8FB1823D199E2CA1****
   */
  SQLId?: string;
  /**
   * @remarks
   * The index recommended for the SQL statement after calculation by the diagnostic system.   
   * - If the recommended index is the primary key, PRIMARY is returned.  
   * - If an index created by the user is recommended, the index name is returned.   
   * The system recommends only one index for an SQL statement. You can call the DescribeIndexes operation to view the indexes of a table.
   * 
   * This parameter is required.
   * 
   * @example
   * t2mr3oae0****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      SQLId: 'SQLId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      SQLId: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRecommendIndexResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the recommended index.
   */
  recommendIndex?: DescribeRecommendIndexResponseBodyRecommendIndex;
  /**
   * @remarks
   * The tenant mode.   Valid values:  
   * Oracle   
   * MySQL
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      recommendIndex: 'RecommendIndex',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      recommendIndex: DescribeRecommendIndexResponseBodyRecommendIndex,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRecommendIndexResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeRecommendIndexResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeRecommendIndexResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSQLDetailsRequest extends $tea.Model {
  /**
   * @remarks
   * The SQL text.
   * 
   * This parameter is required.
   * 
   * @example
   * 8D6E84****0B8FB1823D199E2CA1****
   */
  SQLId?: string;
  /**
   * @remarks
   * SQLID.
   * 
   * This parameter is required.
   * 
   * @example
   * t2mr3oae0****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      SQLId: 'SQLId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      SQLId: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSQLDetailsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The operation that you want to perform.   
   * Set the value to **DescribeSQLDetails**.
   * 
   * @example
   * 473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E
   */
  requestId?: string;
  /**
   * @remarks
   * ```
   * http(s)://[Endpoint]/?Action=DescribeSQLDetails
   * &TenantId=t2mr3oae0****
   * &SQLId=8D6E84****0B8FB1823D199E2CA1****
   * &Common request parameters
   * ```
   */
  SQLDetails?: DescribeSQLDetailsResponseBodySQLDetails[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      SQLDetails: 'SQLDetails',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      SQLDetails: { 'type': 'array', 'itemType': DescribeSQLDetailsResponseBodySQLDetails },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSQLDetailsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeSQLDetailsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSQLDetailsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSQLHistoryListRequest extends $tea.Model {
  /**
   * @remarks
   * The end time of the time range for querying the SQL execution history.   
   * The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
   * 
   * This parameter is required.
   * 
   * @example
   * 2021-09-13T15:40:43Z
   */
  endTime?: string;
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned on each page.   
   * Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * SQLID.
   * 
   * This parameter is required.
   * 
   * @example
   * 8D6E84****0B8FB1823D199E2CA1****
   */
  SQLId?: string;
  /**
   * @remarks
   * The start time of the time range for querying the SQL execution history.   
   * The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
   * 
   * This parameter is required.
   * 
   * @example
   * 2021-06-13T15:40:43Z
   */
  startTime?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * t2mr3oae0****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      SQLId: 'SQLId',
      startTime: 'StartTime',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      SQLId: 'string',
      startTime: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSQLHistoryListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E
   */
  requestId?: string;
  /**
   * @remarks
   * The execution history of the SQL statement.
   */
  SQLHistoryList?: DescribeSQLHistoryListResponseBodySQLHistoryList;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      SQLHistoryList: 'SQLHistoryList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      SQLHistoryList: DescribeSQLHistoryListResponseBodySQLHistoryList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSQLHistoryListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeSQLHistoryListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSQLHistoryListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSQLPlansRequest extends $tea.Model {
  /**
   * @remarks
   * SQLID.
   * 
   * This parameter is required.
   * 
   * @example
   * 8D6E84****0B8FB1823D199E2CA1****
   */
  SQLId?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * t2mr3oae0****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      SQLId: 'SQLId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      SQLId: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSQLPlansResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @remarks
   * The information about the execution plan.
   */
  SQLPlans?: DescribeSQLPlansResponseBodySQLPlans[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      SQLPlans: 'SQLPlans',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      SQLPlans: { 'type': 'array', 'itemType': DescribeSQLPlansResponseBodySQLPlans },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSQLPlansResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeSQLPlansResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSQLPlansResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSQLSamplesRequest extends $tea.Model {
  /**
   * @remarks
   * The database name.
   * 
   * This parameter is required.
   * 
   * @example
   * test_db
   */
  dbName?: string;
  /**
   * @remarks
   * The end time of querying the slow query execution.
   * The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-04-12T05:38:38Z
   */
  endTime?: string;
  /**
   * @remarks
   * The instance ID.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  returnSqlText?: boolean;
  /**
   * @remarks
   * SQL ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 8D6E84****0B8FB1823D199E2CA1****
   */
  sqlId?: string;
  /**
   * @remarks
   * The start time of querying the slow query execution.
   * The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-04-12T04:38:38Z
   */
  startTime?: string;
  /**
   * @remarks
   * The tenant ID.
   * 
   * @example
   * t4louaeei****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      dbName: 'DbName',
      endTime: 'EndTime',
      instanceId: 'InstanceId',
      returnSqlText: 'ReturnSqlText',
      sqlId: 'SqlId',
      startTime: 'StartTime',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbName: 'string',
      endTime: 'string',
      instanceId: 'string',
      returnSqlText: 'boolean',
      sqlId: 'string',
      startTime: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSQLSamplesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The list of sample data of slow query execution details.
   */
  data?: DescribeSQLSamplesResponseBodyData[];
  /**
   * @remarks
   * Request ID.
   * 
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': DescribeSQLSamplesResponseBodyData },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSQLSamplesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeSQLSamplesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSQLSamplesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSQLTuningAdvicesRequest extends $tea.Model {
  /**
   * @example
   * zh-CN
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * testdb
   */
  dbName?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 2023-04-12T05:38:38Z
   */
  endTime?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * obsdf43****
   */
  instanceId?: string;
  /**
   * @remarks
   * SqlId
   * 
   * This parameter is required.
   * 
   * @example
   * 123456
   */
  sqlId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 2023-04-12T04:38:38Z
   */
  startTime?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * tsdc2s2****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      dbName: 'DbName',
      endTime: 'EndTime',
      instanceId: 'InstanceId',
      sqlId: 'SqlId',
      startTime: 'StartTime',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      dbName: 'string',
      endTime: 'string',
      instanceId: 'string',
      sqlId: 'string',
      startTime: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSQLTuningAdvicesResponseBody extends $tea.Model {
  data?: DescribeSQLTuningAdvicesResponseBodyData[];
  /**
   * @example
   * 473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': DescribeSQLTuningAdvicesResponseBodyData },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSQLTuningAdvicesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeSQLTuningAdvicesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSQLTuningAdvicesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSampleSqlRawTextsRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * test_db
   */
  dbName?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 2023-04-12T05:38:38Z
   */
  endTime?: string;
  /**
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @example
   * 20
   */
  limit?: string;
  /**
   * @remarks
   * SQL ID。
   * 
   * This parameter is required.
   * 
   * @example
   * 8D6E84****0B8FB1823D199E2CA1****
   */
  sqlId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 2023-04-12T04:38:38Z
   */
  startTime?: string;
  /**
   * @example
   * ob2mr3oae0****
   */
  tenantId?: string;
  /**
   * @example
   * YB420A700EFB-00060D53E42D0C61-0-0
   */
  traceId?: string;
  static names(): { [key: string]: string } {
    return {
      dbName: 'DbName',
      endTime: 'EndTime',
      instanceId: 'InstanceId',
      limit: 'Limit',
      sqlId: 'SqlId',
      startTime: 'StartTime',
      tenantId: 'TenantId',
      traceId: 'TraceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbName: 'string',
      endTime: 'string',
      instanceId: 'string',
      limit: 'string',
      sqlId: 'string',
      startTime: 'string',
      tenantId: 'string',
      traceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSampleSqlRawTextsResponseBody extends $tea.Model {
  data?: DescribeSampleSqlRawTextsResponseBodyData;
  /**
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: DescribeSampleSqlRawTextsResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSampleSqlRawTextsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeSampleSqlRawTextsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSampleSqlRawTextsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSecurityIpGroupsRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * i-bp67acfmxazb4p****
   */
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSecurityIpGroupsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  securityIpGroups?: DescribeSecurityIpGroupsResponseBodySecurityIpGroups[];
  /**
   * @remarks
   * Example 1
   * 
   * @example
   * 2
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      securityIpGroups: 'SecurityIpGroups',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      securityIpGroups: { 'type': 'array', 'itemType': DescribeSecurityIpGroupsResponseBodySecurityIpGroups },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSecurityIpGroupsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeSecurityIpGroupsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSecurityIpGroupsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSessionListRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * t4louaeei****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSessionListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The object information.
   */
  data?: DescribeSessionListResponseBodyData[];
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': DescribeSessionListResponseBodyData },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSessionListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeSessionListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSessionListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSlowSQLHistoryListRequest extends $tea.Model {
  /**
   * @remarks
   * The end time of the time range for querying the execution history of the slow SQL statement.   
   * The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
   * 
   * This parameter is required.
   * 
   * @example
   * 2021-12-14T08:34:49Z
   */
  endTime?: string;
  /**
   * @remarks
   * The number of the page to return.    
   * - Start value: 1   
   * - Default value: 1
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of rows to return on each page.  
   * - Maximum value: 100   
   * - Default value: 10
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The SQL ID, which uniquely identifies an SQL statement.
   * 
   * This parameter is required.
   * 
   * @example
   * 8D6E84735C0****1823D199E2CA1****
   */
  SQLId?: string;
  /**
   * @remarks
   * The start time of the time range for querying the execution history of the slow SQL statement.   
   * The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
   * 
   * This parameter is required.
   * 
   * @example
   * 2021-12-14T02:34:49Z
   */
  startTime?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * t384tolsj****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      SQLId: 'SQLId',
      startTime: 'StartTime',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      SQLId: 'string',
      startTime: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSlowSQLHistoryListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @remarks
   * The execution history of the slow SQL statement.
   */
  slowSQLHistoryList?: DescribeSlowSQLHistoryListResponseBodySlowSQLHistoryList;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      slowSQLHistoryList: 'SlowSQLHistoryList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      slowSQLHistoryList: DescribeSlowSQLHistoryListResponseBodySlowSQLHistoryList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSlowSQLHistoryListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeSlowSQLHistoryListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSlowSQLHistoryListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSlowSQLListRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * testdb
   */
  dbName?: string;
  /**
   * @remarks
   * The end time of the time range for querying slow SQL statements.   
   * The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
   * 
   * This parameter is required.
   * 
   * @example
   * 2021-09-13T15:40:43Z
   */
  endTime?: string;
  /**
   * @remarks
   * The filter condition.
   * 
   * @example
   * [dbName:sys]
   */
  filterCondition?: { [key: string]: any };
  /**
   * @remarks
   * The IP address of the database node.
   * 
   * @example
   * i-bp18qljorblo8es*****
   */
  nodeIp?: string;
  /**
   * @remarks
   * The number of rows to return on each page.  
   * - Maximum value: 100  
   * - Default value: 10
   * 
   * @example
   * 10
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of the page to return.    
   * - Start value: 1   
   * - Default value: 1
   * 
   * @example
   * 1
   */
  pageSize?: number;
  /**
   * @remarks
   * The SQL ID, which uniquely identifies an SQL statement.
   * 
   * @example
   * 8D6E84****0B8FB1823D199E2CA1****
   */
  SQLId?: string;
  /**
   * @remarks
   * The search keyword.
   * 
   * @example
   * update
   */
  searchKeyWord?: string;
  /**
   * @remarks
   * The search parameter.
   * 
   * @example
   * cputime
   */
  searchParameter?: string;
  /**
   * @remarks
   * The search rule.
   * 
   * @example
   * >
   */
  searchRule?: string;
  /**
   * @remarks
   * The search value.
   * 
   * @example
   * 0.01
   */
  searchValue?: string;
  /**
   * @remarks
   * The sorted column.
   * 
   * @example
   * cputime
   */
  sortColumn?: string;
  /**
   * @remarks
   * The sorting rule.
   * 
   * @example
   * desc
   */
  sortOrder?: string;
  /**
   * @remarks
   * The start time of the time range for querying slow SQL statements.   
   * The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
   * 
   * This parameter is required.
   * 
   * @example
   * 2021-06-13T15:40:43Z
   */
  startTime?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * t2mr3oae0****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      dbName: 'DbName',
      endTime: 'EndTime',
      filterCondition: 'FilterCondition',
      nodeIp: 'NodeIp',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      SQLId: 'SQLId',
      searchKeyWord: 'SearchKeyWord',
      searchParameter: 'SearchParameter',
      searchRule: 'SearchRule',
      searchValue: 'SearchValue',
      sortColumn: 'SortColumn',
      sortOrder: 'SortOrder',
      startTime: 'StartTime',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbName: 'string',
      endTime: 'string',
      filterCondition: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      nodeIp: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      SQLId: 'string',
      searchKeyWord: 'string',
      searchParameter: 'string',
      searchRule: 'string',
      searchValue: 'string',
      sortColumn: 'string',
      sortOrder: 'string',
      startTime: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSlowSQLListShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * testdb
   */
  dbName?: string;
  /**
   * @remarks
   * The end time of the time range for querying slow SQL statements.   
   * The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
   * 
   * This parameter is required.
   * 
   * @example
   * 2021-09-13T15:40:43Z
   */
  endTime?: string;
  /**
   * @remarks
   * The filter condition.
   * 
   * @example
   * [dbName:sys]
   */
  filterConditionShrink?: string;
  /**
   * @remarks
   * The IP address of the database node.
   * 
   * @example
   * i-bp18qljorblo8es*****
   */
  nodeIp?: string;
  /**
   * @remarks
   * The number of rows to return on each page.  
   * - Maximum value: 100  
   * - Default value: 10
   * 
   * @example
   * 10
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of the page to return.    
   * - Start value: 1   
   * - Default value: 1
   * 
   * @example
   * 1
   */
  pageSize?: number;
  /**
   * @remarks
   * The SQL ID, which uniquely identifies an SQL statement.
   * 
   * @example
   * 8D6E84****0B8FB1823D199E2CA1****
   */
  SQLId?: string;
  /**
   * @remarks
   * The search keyword.
   * 
   * @example
   * update
   */
  searchKeyWord?: string;
  /**
   * @remarks
   * The search parameter.
   * 
   * @example
   * cputime
   */
  searchParameter?: string;
  /**
   * @remarks
   * The search rule.
   * 
   * @example
   * >
   */
  searchRule?: string;
  /**
   * @remarks
   * The search value.
   * 
   * @example
   * 0.01
   */
  searchValue?: string;
  /**
   * @remarks
   * The sorted column.
   * 
   * @example
   * cputime
   */
  sortColumn?: string;
  /**
   * @remarks
   * The sorting rule.
   * 
   * @example
   * desc
   */
  sortOrder?: string;
  /**
   * @remarks
   * The start time of the time range for querying slow SQL statements.   
   * The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
   * 
   * This parameter is required.
   * 
   * @example
   * 2021-06-13T15:40:43Z
   */
  startTime?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * t2mr3oae0****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      dbName: 'DbName',
      endTime: 'EndTime',
      filterConditionShrink: 'FilterCondition',
      nodeIp: 'NodeIp',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      SQLId: 'SQLId',
      searchKeyWord: 'SearchKeyWord',
      searchParameter: 'SearchParameter',
      searchRule: 'SearchRule',
      searchValue: 'SearchValue',
      sortColumn: 'SortColumn',
      sortOrder: 'SortOrder',
      startTime: 'StartTime',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbName: 'string',
      endTime: 'string',
      filterConditionShrink: 'string',
      nodeIp: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      SQLId: 'string',
      searchKeyWord: 'string',
      searchParameter: 'string',
      searchRule: 'string',
      searchValue: 'string',
      sortColumn: 'string',
      sortOrder: 'string',
      startTime: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSlowSQLListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E
   */
  requestId?: string;
  /**
   * @remarks
   * The list of slow SQL statements.
   */
  slowSQLList?: DescribeSlowSQLListResponseBodySlowSQLList[];
  /**
   * @remarks
   * The total count.
   * 
   * @example
   * 2
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      slowSQLList: 'SlowSQLList',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      slowSQLList: { 'type': 'array', 'itemType': DescribeSlowSQLListResponseBodySlowSQLList },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSlowSQLListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeSlowSQLListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSlowSQLListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTagValuesRequest extends $tea.Model {
  /**
   * @remarks
   * The type of the resource.
   * 
   * This parameter is required.
   * 
   * @example
   * tag
   */
  resourceType?: string;
  static names(): { [key: string]: string } {
    return {
      resourceType: 'ResourceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTagValuesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The mappings between tag groups and tags.
   * 
   * @example
   * "{\\"Tag group 2\\":[\\"Tag 2-1\\",\\"Tag 2-2\\"],\\"Tag group 1\\":[\\"Tag 1-1\\"]}"
   */
  map?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 4C91F7BA-xxxx-xxxx-xxxx-846ECA1A9908
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      map: 'Map',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      map: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTagValuesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeTagValuesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeTagValuesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantRequest extends $tea.Model {
  /**
   * @remarks
   * The status of the Internet address for accessing the tenant. Valid values:   
   * - CLOSED: The address is disabled.   
   * - ALLOCATING_INTERNET_ADDRESS: An address is being applied for.   
   * - PENDING_OFFLINE_INTERNET_ADDRESS: The address is being disabled.   
   * - ONLINE: The address is in service.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * Indicates whether to enable transaction splitting.
   * 
   * This parameter is required.
   * 
   * @example
   * ob2mr3oae0****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantResponseBody extends $tea.Model {
  /**
   * @remarks
   * The zone information of the tenant.
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @remarks
   * The ID of the zone.
   */
  tenant?: DescribeTenantResponseBodyTenant;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      tenant: 'Tenant',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      tenant: DescribeTenantResponseBodyTenant,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeTenantResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeTenantResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantEncryptionRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * t4louaeei****
   */
  tenantId?: string;
  /**
   * @example
   * forMySQLTenant
   */
  tenantName?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      tenantId: 'TenantId',
      tenantName: 'TenantName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      tenantId: 'string',
      tenantName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantEncryptionResponseBody extends $tea.Model {
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  tenantEncryptions?: DescribeTenantEncryptionResponseBodyTenantEncryptions[];
  /**
   * @example
   * 8
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      tenantEncryptions: 'TenantEncryptions',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      tenantEncryptions: { 'type': 'array', 'itemType': DescribeTenantEncryptionResponseBodyTenantEncryptions },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantEncryptionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeTenantEncryptionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeTenantEncryptionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantMetricsRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 2021-06-13T15:45:43Z
   */
  endTime?: string;
  /**
   * @remarks
   * 2021-06-13T15:40:43Z
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * {"name":"DescribeTenantMetrics","product":"OceanBasePro","version":"2019-09-01","path":"/","deprecated":0,"method":"POST|GET","protocol":"HTTP|HTTPS","hidden":0,"timeout":10000,"parameter_type":"Single","params":"[{\\"name\\":\\"Action\\",\\"position\\":\\"Query\\",\\"required\\":true,\\"checkBlank\\":false,\\"visibility\\":\\"Public\\",\\"deprecated\\":false,\\"type\\":\\"String\\",\\"description\\":\\"\\",\\"example\\":\\"DescribeTenantMetrics\\"},{\\"name\\":\\"InstanceId\\",\\"position\\":\\"Body\\",\\"required\\":true,\\"checkBlank\\":false,\\"visibility\\":\\"Public\\",\\"deprecated\\":false,\\"type\\":\\"String\\",\\"title\\":\\"\\",\\"description\\":\\"\\",\\"example\\":\\"ob317v4uif****\\"},{\\"name\\":\\"PageSize\\",\\"position\\":\\"Body\\",\\"required\\":false,\\"checkBlank\\":false,\\"visibility\\":\\"Public\\",\\"deprecated\\":false,\\"type\\":\\"Integer\\",\\"title\\":\\"\\",\\"description\\":\\"\\",\\"example\\":\\"10\\"},{\\"name\\":\\"PageNumber\\",\\"position\\":\\"Body\\",\\"required\\":false,\\"checkBlank\\":false,\\"visibility\\":\\"Public\\",\\"deprecated\\":false,\\"type\\":\\"Integer\\",\\"title\\":\\"\\",\\"description\\":\\"\\",\\"example\\":\\"1\\"},{\\"name\\":\\"TenantName\\",\\"position\\":\\"Body\\",\\"required\\":false,\\"checkBlank\\":false,\\"visibility\\":\\"Public\\",\\"deprecated\\":true,\\"type\\":\\"String\\",\\"title\\":\\"\\",\\"description\\":\\"\\",\\"example\\":\\"pay_online\\"},{\\"name\\":\\"StartTime\\",\\"position\\":\\"Body\\",\\"required\\":true,\\"checkBlank\\":false,\\"visibility\\":\\"Public\\",\\"deprecated\\":false,\\"type\\":\\"String\\",\\"title\\":\\"\\",\\"description\\":\\"\\",\\"example\\":\\"2021-06-13T15:40:43Z\\"},{\\"name\\":\\"EndTime\\",\\"position\\":\\"Body\\",\\"required\\":true,\\"checkBlank\\":false,\\"visibility\\":\\"Public\\",\\"deprecated\\":false,\\"type\\":\\"String\\",\\"title\\":\\"\\",\\"description\\":\\"\\",\\"example\\":\\"2021-06-13T15:45:43Z\\"},{\\"name\\":\\"Metrics\\",\\"position\\":\\"Body\\",\\"required\\":true,\\"checkBlank\\":false,\\"visibility\\":\\"Public\\",\\"deprecated\\":false,\\"type\\":\\"String\\",\\"title\\":\\"\\",\\"description\\":\\"\\",\\"example\\":\\"tps\\"},{\\"name\\":\\"TenantId\\",\\"position\\":\\"Body\\",\\"required\\":false,\\"checkBlank\\":false,\\"visibility\\":\\"Public\\",\\"deprecated\\":true,\\"type\\":\\"String\\",\\"title\\":\\"\\",\\"description\\":\\"\\",\\"example\\":\\"tfafd34fs****\\"},{\\"name\\":\\"TenantIdList\\",\\"position\\":\\"Body\\",\\"required\\":false,\\"checkBlank\\":false,\\"visibility\\":\\"Public\\",\\"deprecated\\":false,\\"type\\":\\"String\\",\\"title\\":\\"\\",\\"description\\":\\"\\",\\"example\\":\\"[tdak3nac****,tdakc42df****]\\"}]","response_headers":"[]","response":"{\\"type\\":\\"Object\\",\\"children\\":[{\\"name\\":\\"TotalCount\\",\\"required\\":false,\\"checkBlank\\":false,\\"visibility\\":\\"Public\\",\\"deprecated\\":false,\\"type\\":\\"Integer\\",\\"title\\":\\"\\",\\"description\\":\\"\\",\\"example\\":\\"9\\"},{\\"name\\":\\"RequestId\\",\\"required\\":false,\\"checkBlank\\":false,\\"visibility\\":\\"Public\\",\\"deprecated\\":false,\\"type\\":\\"String\\",\\"title\\":\\"\\",\\"description\\":\\"\\",\\"example\\":\\"EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C\\"},{\\"name\\":\\"TenantMetrics\\",\\"required\\":false,\\"checkBlank\\":false,\\"visibility\\":\\"Public\\",\\"deprecated\\":false,\\"type\\":\\"String\\",\\"title\\":\\"\\",\\"description\\":\\"\\",\\"example\\":\\"\\\\\\"Metrics\\\\\\":[ {\\\\\\"request_queue_rt\\\\\\":0.0,\\\\\\"TimeStamp\\\\\\":\\\\\\"2022-02-23T01:58:00Z\\\\\\"}]\\"}],\\"title\\":\\"\\",\\"description\\":\\"\\"}","errors":"{}"}
   * 
   * This parameter is required.
   * 
   * @example
   * tps
   */
  metrics?: string;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * tfafd34fs****
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * Example 1
   * 
   * This parameter is required.
   * 
   * @example
   * 2021-06-13T15:40:43Z
   */
  startTime?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * tfafd34fs****
   * 
   * @deprecated
   */
  tenantId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * [tdak3nac****,tdakc42df****]
   */
  tenantIdList?: string;
  /**
   * @remarks
   * 2021-06-13T15:45:43Z
   * 
   * @example
   * pay_online
   * 
   * @deprecated
   */
  tenantName?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      instanceId: 'InstanceId',
      metrics: 'Metrics',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      startTime: 'StartTime',
      tenantId: 'TenantId',
      tenantIdList: 'TenantIdList',
      tenantName: 'TenantName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      instanceId: 'string',
      metrics: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      startTime: 'string',
      tenantId: 'string',
      tenantIdList: 'string',
      tenantName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantMetricsResponseBody extends $tea.Model {
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @example
   * "Metrics":[ {"request_queue_rt":0.0,"TimeStamp":"2022-02-23T01:58:00Z"}]
   */
  tenantMetrics?: string;
  /**
   * @example
   * 9
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      tenantMetrics: 'TenantMetrics',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      tenantMetrics: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantMetricsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeTenantMetricsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeTenantMetricsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantReadableScnRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * t33h8y08k****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantReadableScnResponseBody extends $tea.Model {
  /**
   * @remarks
   * The data in the return result of the request.
   */
  data?: DescribeTenantReadableScnResponseBodyData;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 8442BB1E-3171-1192-B9DC-F6F4E53B2673
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: DescribeTenantReadableScnResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantReadableScnResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeTenantReadableScnResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeTenantReadableScnResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantSecurityConfigsRequest extends $tea.Model {
  /**
   * @remarks
   * The unique identifier of the security check.
   * 
   * @example
   * ****
   */
  checkId?: string;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * @example
   * t4louaeei****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      checkId: 'CheckId',
      instanceId: 'InstanceId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkId: 'string',
      instanceId: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantSecurityConfigsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The list of parameters.
   */
  configs?: DescribeTenantSecurityConfigsResponseBodyConfigs;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 523E7183-****-590D-****-12DFD316614B
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      configs: 'Configs',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configs: DescribeTenantSecurityConfigsResponseBodyConfigs,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantSecurityConfigsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeTenantSecurityConfigsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeTenantSecurityConfigsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantSecurityIpGroupsRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * t4louaeei****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantSecurityIpGroupsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 473469**-AA6F-4D**-B3DB-A***********
   */
  requestId?: string;
  /**
   * @remarks
   * The list of the whitelist groups.
   */
  securityIpGroups?: DescribeTenantSecurityIpGroupsResponseBodySecurityIpGroups[];
  /**
   * @remarks
   * The total number of the whitelist groups.
   * 
   * @example
   * 2
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      securityIpGroups: 'SecurityIpGroups',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      securityIpGroups: { 'type': 'array', 'itemType': DescribeTenantSecurityIpGroupsResponseBodySecurityIpGroups },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantSecurityIpGroupsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeTenantSecurityIpGroupsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeTenantSecurityIpGroupsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantTagsRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The tags.
   * 
   * @example
   * [{"Key": "xxx", "Value", "xxx"}]
   */
  tags?: string;
  /**
   * @remarks
   * The JSON string of the tenant ID.
   * 
   * This parameter is required.
   * 
   * @example
   * ["t5r0x2f6q****", "t33h8y08k****", "t5r41rtl7****"]
   */
  tenantIds?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      tags: 'Tags',
      tenantIds: 'TenantIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      tags: 'string',
      tenantIds: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantTagsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @remarks
   * The list of tags.
   */
  tagResources?: DescribeTenantTagsResponseBodyTagResources[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      tagResources: 'TagResources',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      tagResources: { 'type': 'array', 'itemType': DescribeTenantTagsResponseBodyTagResources },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantTagsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeTenantTagsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeTenantTagsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantUserRolesRequest extends $tea.Model {
  /**
   * @example
   * t4pnum****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantUserRolesResponseBody extends $tea.Model {
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  role?: string[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      role: 'Role',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      role: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantUserRolesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeTenantUserRolesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeTenantUserRolesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantUsersRequest extends $tea.Model {
  /**
   * @remarks
   * The database privileges of the account.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The return result of the request.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The return result of the request.
   * 
   * @example
   * pay
   */
  searchKey?: string;
  /**
   * @remarks
   * The return result of the request.
   * 
   * This parameter is required.
   * 
   * @example
   * ob2mr3oae0****
   */
  tenantId?: string;
  /**
   * @remarks
   * The operation that you want to perform.   
   * Set the value to **DescribeTenantUsers**.
   * 
   * @example
   * pay_test
   */
  userName?: string;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      searchKey: 'SearchKey',
      tenantId: 'TenantId',
      userName: 'UserName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      searchKey: 'string',
      tenantId: 'string',
      userName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantUsersResponseBody extends $tea.Model {
  /**
   * @remarks
   * The name of the database account.
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @remarks
   * The type of the database account. Valid values:    
   * - Admin: the super administrator account.   
   * - NORMAL: a general account.
   */
  tenantUsers?: DescribeTenantUsersResponseBodyTenantUsers[];
  /**
   * @remarks
   * The role of the account.   
   * In Oracle mode, a role is a schema-level role. Valid values:  
   * - ReadWrite: a role that has the read and write privileges, including: CREATE TABLE, CREATE VIEW, CREATE PROCEDURE, CREATE SYNONYM, CREATE SEQUENCE, CREATE TRIGGER, CREATE TYPE, CREATE SESSION, EXECUTE ANY PROCEDURE, CREATE ANY OUTLINE, ALTER ANY OUTLINE, DROP ANY OUTLINE, CREATE ANY PROCEDURE, ALTER ANY PROCEDURE, DROP ANY PROCEDURE, CREATE ANY SEQUENCE, ALTER ANY SEQUENCE, DROP ANY SEQUENCE, CREATE ANY TYPE, ALTER ANY TYPE, DROP ANY TYPE, SYSKM, CREATE ANY TRIGGER, ALTER ANY TRIGGER, DROP ANY TRIGGER, CREATE PROFILE, ALTER PROFILE, and DROP PROFILE.  
   * - ReadOnly: a role that has only the read-only privilege SELECT.
   * In MySQL mode, a role is a database-level role. Valid values: 
   * - ReadWrite: a role that has the read and write privileges, namely ALL PRIVILEGES.   
   * - ReadOnly: a role that has only the read-only privilege SELECT.   
   * - DDL: a role that has the DDL privileges such as CREATE, DROP, ALTER, SHOW VIEW, and CREATE VIEW.   
   * - DML: a role that has the DML privileges such as SELECT, INSERT, UPDATE, DELETE, and SHOW VIEW.   
   * 
   * > <br>By default, an Oracle account has the read and write privileges on its own schema, which are not listed here.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      tenantUsers: 'TenantUsers',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      tenantUsers: { 'type': 'array', 'itemType': DescribeTenantUsersResponseBodyTenantUsers },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantUsersResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeTenantUsersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeTenantUsersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantZonesReadRequest extends $tea.Model {
  /**
   * @remarks
   * The zone information of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The return result of the request.
   * 
   * This parameter is required.
   * 
   * @example
   * ob2mr3oae0****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantZonesReadResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether a read-only connection needs to be created for the zone.
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @remarks
   * The request ID.
   */
  tenantZones?: DescribeTenantZonesReadResponseBodyTenantZones[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      tenantZones: 'TenantZones',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      tenantZones: { 'type': 'array', 'itemType': DescribeTenantZonesReadResponseBodyTenantZones },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantZonesReadResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeTenantZonesReadResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeTenantZonesReadResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantsRequest extends $tea.Model {
  /**
   * @remarks
   * The number of used disks of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * It is an online CLI tool that allows you to quickly retrieve and debug APIs. It can dynamically generate executable SDK code samples.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * You can call this operation to query the tenants in an OceanBase cluster.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The primary zone of the tenant.
   * 
   * @example
   * pay
   */
  searchKey?: string;
  /**
   * @remarks
   * Alibaba Cloud CLI
   * 
   * @example
   * ob2mr3oae0****
   */
  tenantId?: string;
  /**
   * @remarks
   * The information of tenants.
   * 
   * @example
   * pay_online
   */
  tenantName?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      searchKey: 'SearchKey',
      tenantId: 'TenantId',
      tenantName: 'TenantName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      searchKey: 'string',
      tenantId: 'string',
      tenantName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   */
  tenants?: DescribeTenantsResponseBodyTenants[];
  /**
   * @remarks
   * The total memory size of the tenant, in GB.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      tenants: 'Tenants',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      tenants: { 'type': 'array', 'itemType': DescribeTenantsResponseBodyTenants },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeTenantsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeTenantsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTimeZonesResponseBody extends $tea.Model {
  /**
   * @remarks
   * DescribeTimeZones
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @remarks
   * The description of the time zone.
   */
  timeZones?: DescribeTimeZonesResponseBodyTimeZones;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      timeZones: 'TimeZones',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      timeZones: DescribeTimeZonesResponseBodyTimeZones,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTimeZonesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeTimeZonesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeTimeZonesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTopSQLListRequest extends $tea.Model {
  /**
   * @remarks
   * The number of block index cache hits.
   * 
   * @example
   * testdb
   */
  dbName?: string;
  /**
   * @remarks
   * The SQL type.
   * 
   * This parameter is required.
   * 
   * @example
   * 2021-09-13T15:40:43Z
   */
  endTime?: string;
  /**
   * @remarks
   * The average number of logical reads of the SQL statement during the specified period of time.   
   * The value covers the numbers of reads of different caches and the number of disk I/Os. It is an important metric for measuring the SQL filtering performance.   
   * 
   * > <br> A higher ratio of the number of logical reads to the number of returned rows indicates poorer filtering performance. General causes include non-standard content written by SQL statements, non-standard table indexes created, and non-standard SQL execution plans.
   * 
   * @example
   * [dbName:sys]
   */
  filterCondition?: { [key: string]: any };
  /**
   * @remarks
   * The number of failures.
   * 
   * @example
   * i-bp19y05uq6xpacyqnlrc
   */
  nodeIp?: string;
  /**
   * @remarks
   * The queuing time, in ms.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of row cache hits.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The I/O wait time, in ms.
   * 
   * @example
   * 8D6E84****0B8FB1823D199E2CA1****
   */
  SQLId?: string;
  /**
   * @remarks
   * The number of retries.
   * 
   * @example
   * update
   */
  searchKeyWord?: string;
  /**
   * @remarks
   * SQLID.
   * 
   * @example
   * cputime
   */
  searchParameter?: string;
  /**
   * @remarks
   * The IP address of the client.
   * 
   * @example
   * >
   */
  searchRule?: string;
  /**
   * @remarks
   * The number of Bloom filter cache hits.
   * 
   * @example
   * 0.01
   */
  searchValue?: string;
  /**
   * @remarks
   * The number of rows read from the disk.
   * 
   * @example
   * cputime
   */
  sortColumn?: string;
  /**
   * @remarks
   * The list of top SQL statements.
   * 
   * @example
   * desc
   */
  sortOrder?: string;
  /**
   * @remarks
   * The maximum response time, in ms.
   * 
   * This parameter is required.
   * 
   * @example
   * 2021-06-13T15:40:43Z
   */
  startTime?: string;
  /**
   * @remarks
   * The average CPU time, in ms.
   * 
   * This parameter is required.
   * 
   * @example
   * t2mr3oae0****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      dbName: 'DbName',
      endTime: 'EndTime',
      filterCondition: 'FilterCondition',
      nodeIp: 'NodeIp',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      SQLId: 'SQLId',
      searchKeyWord: 'SearchKeyWord',
      searchParameter: 'SearchParameter',
      searchRule: 'SearchRule',
      searchValue: 'SearchValue',
      sortColumn: 'SortColumn',
      sortOrder: 'SortOrder',
      startTime: 'StartTime',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbName: 'string',
      endTime: 'string',
      filterCondition: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      nodeIp: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      SQLId: 'string',
      searchKeyWord: 'string',
      searchParameter: 'string',
      searchRule: 'string',
      searchValue: 'string',
      sortColumn: 'string',
      sortOrder: 'string',
      startTime: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTopSQLListShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The number of block index cache hits.
   * 
   * @example
   * testdb
   */
  dbName?: string;
  /**
   * @remarks
   * The SQL type.
   * 
   * This parameter is required.
   * 
   * @example
   * 2021-09-13T15:40:43Z
   */
  endTime?: string;
  /**
   * @remarks
   * The average number of logical reads of the SQL statement during the specified period of time.   
   * The value covers the numbers of reads of different caches and the number of disk I/Os. It is an important metric for measuring the SQL filtering performance.   
   * 
   * > <br> A higher ratio of the number of logical reads to the number of returned rows indicates poorer filtering performance. General causes include non-standard content written by SQL statements, non-standard table indexes created, and non-standard SQL execution plans.
   * 
   * @example
   * [dbName:sys]
   */
  filterConditionShrink?: string;
  /**
   * @remarks
   * The number of failures.
   * 
   * @example
   * i-bp19y05uq6xpacyqnlrc
   */
  nodeIp?: string;
  /**
   * @remarks
   * The queuing time, in ms.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of row cache hits.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The I/O wait time, in ms.
   * 
   * @example
   * 8D6E84****0B8FB1823D199E2CA1****
   */
  SQLId?: string;
  /**
   * @remarks
   * The number of retries.
   * 
   * @example
   * update
   */
  searchKeyWord?: string;
  /**
   * @remarks
   * SQLID.
   * 
   * @example
   * cputime
   */
  searchParameter?: string;
  /**
   * @remarks
   * The IP address of the client.
   * 
   * @example
   * >
   */
  searchRule?: string;
  /**
   * @remarks
   * The number of Bloom filter cache hits.
   * 
   * @example
   * 0.01
   */
  searchValue?: string;
  /**
   * @remarks
   * The number of rows read from the disk.
   * 
   * @example
   * cputime
   */
  sortColumn?: string;
  /**
   * @remarks
   * The list of top SQL statements.
   * 
   * @example
   * desc
   */
  sortOrder?: string;
  /**
   * @remarks
   * The maximum response time, in ms.
   * 
   * This parameter is required.
   * 
   * @example
   * 2021-06-13T15:40:43Z
   */
  startTime?: string;
  /**
   * @remarks
   * The average CPU time, in ms.
   * 
   * This parameter is required.
   * 
   * @example
   * t2mr3oae0****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      dbName: 'DbName',
      endTime: 'EndTime',
      filterConditionShrink: 'FilterCondition',
      nodeIp: 'NodeIp',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      SQLId: 'SQLId',
      searchKeyWord: 'SearchKeyWord',
      searchParameter: 'SearchParameter',
      searchRule: 'SearchRule',
      searchValue: 'SearchValue',
      sortColumn: 'SortColumn',
      sortOrder: 'SortOrder',
      startTime: 'StartTime',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbName: 'string',
      endTime: 'string',
      filterConditionShrink: 'string',
      nodeIp: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      SQLId: 'string',
      searchKeyWord: 'string',
      searchParameter: 'string',
      searchRule: 'string',
      searchValue: 'string',
      sortColumn: 'string',
      sortOrder: 'string',
      startTime: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTopSQLListResponseBody extends $tea.Model {
  /**
   * @remarks
   * Alibaba Cloud CLI
   * 
   * @example
   * 473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E
   */
  requestId?: string;
  /**
   * @remarks
   * The I/O wait time, in ms.
   */
  topSQLList?: DescribeTopSQLListResponseBodyTopSQLList[];
  /**
   * @remarks
   * It is an online CLI tool that allows you to quickly retrieve and debug APIs. It can dynamically generate executable SDK code samples.
   * 
   * @example
   * 9
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      topSQLList: 'TopSQLList',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      topSQLList: { 'type': 'array', 'itemType': DescribeTopSQLListResponseBodyTopSQLList },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTopSQLListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeTopSQLListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeTopSQLListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeZonesRequest extends $tea.Model {
  /**
   * @example
   * x86
   */
  cpuArch?: string;
  /**
   * @remarks
   * The operation that you want to perform.   
   * Set the value to **DescribeZones**.
   * 
   * @example
   * single
   */
  deployType?: string;
  /**
   * @remarks
   * The deployment mode.
   * 
   * @example
   * NORMAL
   */
  series?: string;
  static names(): { [key: string]: string } {
    return {
      cpuArch: 'CpuArch',
      deployType: 'DeployType',
      series: 'Series',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cpuArch: 'string',
      deployType: 'string',
      series: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeZonesResponseBody extends $tea.Model {
  /**
   * @remarks
   * ```
   * http(s)://[Endpoint]/?Action=DescribeZones
   * &Series=normal
   * &DeployType=single
   * &Common request parameters
   * ```
   * 
   * @example
   * 473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E
   */
  requestId?: string;
  /**
   * @remarks
   * You can call this operation to learn of zones where a cluster can be created in an Alibaba Cloud region.
   */
  zones?: DescribeZonesResponseBodyZones[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      zones: 'Zones',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      zones: { 'type': 'array', 'itemType': DescribeZonesResponseBodyZones },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeZonesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeZonesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeZonesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUploadOssUrlRequest extends $tea.Model {
  /**
   * @example
   * 10
   */
  effectiveTimeMinutes?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * CREATE_PROJECT
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      effectiveTimeMinutes: 'EffectiveTimeMinutes',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      effectiveTimeMinutes: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUploadOssUrlResponseBody extends $tea.Model {
  /**
   * @example
   * Contact the administrator.
   */
  advice?: string;
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  /**
   * @example
   * 278
   */
  cost?: string;
  data?: GetUploadOssUrlResponseBodyData;
  errorDetail?: GetUploadOssUrlResponseBodyErrorDetail;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 11
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      cost: 'Cost',
      data: 'Data',
      errorDetail: 'ErrorDetail',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      cost: 'string',
      data: GetUploadOssUrlResponseBodyData,
      errorDetail: GetUploadOssUrlResponseBodyErrorDetail,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUploadOssUrlResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetUploadOssUrlResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetUploadOssUrlResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class KillProcessListRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The list of the sessions that need to be closed.
   * 
   * This parameter is required.
   * 
   * @example
   * [{"ServerIp":"192.168.13.119","SessionId":"3221614618"}]
   */
  sessionList?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * t4louaeei****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      sessionList: 'SessionList',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      sessionList: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class KillProcessListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The data returned.
   */
  data?: KillProcessListResponseBodyData[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': KillProcessListResponseBodyData },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class KillProcessListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: KillProcessListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: KillProcessListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAllLabelsResponseBody extends $tea.Model {
  /**
   * @example
   * Contact the administrator.
   */
  advice?: string;
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  /**
   * @example
   * 1
   */
  cost?: string;
  data?: ListAllLabelsResponseBodyData[];
  errorDetail?: ListAllLabelsResponseBodyErrorDetail;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 29
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      cost: 'Cost',
      data: 'Data',
      errorDetail: 'ErrorDetail',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      cost: 'string',
      data: { 'type': 'array', 'itemType': ListAllLabelsResponseBodyData },
      errorDetail: ListAllLabelsResponseBodyErrorDetail,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAllLabelsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListAllLabelsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListAllLabelsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataSourceRequest extends $tea.Model {
  /**
   * @example
   * descend
   */
  order?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: string;
  /**
   * @example
   * 10
   */
  pageSize?: string;
  /**
   * @example
   * GRATI****89278244
   */
  searchKey?: string;
  /**
   * @example
   * gmtCreate
   */
  sortField?: string;
  types?: string[];
  static names(): { [key: string]: string } {
    return {
      order: 'Order',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      searchKey: 'SearchKey',
      sortField: 'SortField',
      types: 'Types',
    };
  }

  static types(): { [key: string]: any } {
    return {
      order: 'string',
      pageNumber: 'string',
      pageSize: 'string',
      searchKey: 'string',
      sortField: 'string',
      types: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataSourceShrinkRequest extends $tea.Model {
  /**
   * @example
   * descend
   */
  order?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: string;
  /**
   * @example
   * 10
   */
  pageSize?: string;
  /**
   * @example
   * GRATI****89278244
   */
  searchKey?: string;
  /**
   * @example
   * gmtCreate
   */
  sortField?: string;
  typesShrink?: string;
  static names(): { [key: string]: string } {
    return {
      order: 'Order',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      searchKey: 'SearchKey',
      sortField: 'SortField',
      typesShrink: 'Types',
    };
  }

  static types(): { [key: string]: any } {
    return {
      order: 'string',
      pageNumber: 'string',
      pageSize: 'string',
      searchKey: 'string',
      sortField: 'string',
      typesShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataSourceResponseBody extends $tea.Model {
  /**
   * @example
   * Contact the administrator.
   */
  advice?: string;
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  /**
   * @example
   * 28
   */
  cost?: string;
  data?: ListDataSourceResponseBodyData[];
  errorDetail?: ListDataSourceResponseBodyErrorDetail;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 132
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      cost: 'Cost',
      data: 'Data',
      errorDetail: 'ErrorDetail',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      cost: 'string',
      data: { 'type': 'array', 'itemType': ListDataSourceResponseBodyData },
      errorDetail: ListDataSourceResponseBodyErrorDetail,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataSourceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListDataSourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListDataSourceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectFullVerifyResultRequest extends $tea.Model {
  destSchemas?: string[];
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  pageSize?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * np_4w5abs****
   */
  projectId?: string;
  sourceSchemas?: string[];
  /**
   * @example
   * FINISHED
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      destSchemas: 'DestSchemas',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      projectId: 'ProjectId',
      sourceSchemas: 'SourceSchemas',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      destSchemas: { 'type': 'array', 'itemType': 'string' },
      pageNumber: 'number',
      pageSize: 'number',
      projectId: 'string',
      sourceSchemas: { 'type': 'array', 'itemType': 'string' },
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectFullVerifyResultShrinkRequest extends $tea.Model {
  destSchemasShrink?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  pageSize?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * np_4w5abs****
   */
  projectId?: string;
  sourceSchemasShrink?: string;
  /**
   * @example
   * FINISHED
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      destSchemasShrink: 'DestSchemas',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      projectId: 'ProjectId',
      sourceSchemasShrink: 'SourceSchemas',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      destSchemasShrink: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      projectId: 'string',
      sourceSchemasShrink: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectFullVerifyResultResponseBody extends $tea.Model {
  /**
   * @example
   * Contact the administrator.
   */
  advice?: string;
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  /**
   * @example
   * 1
   */
  cost?: string;
  data?: ListProjectFullVerifyResultResponseBodyData;
  errorDetail?: ListProjectFullVerifyResultResponseBodyErrorDetail;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      cost: 'Cost',
      data: 'Data',
      errorDetail: 'ErrorDetail',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      cost: 'string',
      data: ListProjectFullVerifyResultResponseBodyData,
      errorDetail: ListProjectFullVerifyResultResponseBodyErrorDetail,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectFullVerifyResultResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListProjectFullVerifyResultResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListProjectFullVerifyResultResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectModifyRecordsRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * np_598jmu****
   */
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectModifyRecordsResponseBody extends $tea.Model {
  /**
   * @example
   * Contact the administrator.
   */
  advice?: string;
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  /**
   * @example
   * 30
   */
  cost?: string;
  data?: ListProjectModifyRecordsResponseBodyData[];
  errorDetail?: ListProjectModifyRecordsResponseBodyErrorDetail;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 100
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      cost: 'Cost',
      data: 'Data',
      errorDetail: 'ErrorDetail',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      cost: 'string',
      data: { 'type': 'array', 'itemType': ListProjectModifyRecordsResponseBodyData },
      errorDetail: ListProjectModifyRecordsResponseBodyErrorDetail,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectModifyRecordsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListProjectModifyRecordsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListProjectModifyRecordsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectsRequest extends $tea.Model {
  labelIds?: string[];
  needRelatedInfo?: boolean;
  /**
   * @example
   * descend
   */
  order?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * np_4w****
   */
  searchKey?: string;
  sinkEndpointTypes?: string[];
  /**
   * @example
   * gmtCreate
   */
  sortField?: string;
  sourceEndpointTypes?: string[];
  status?: string[];
  /**
   * @example
   * MIGRATION
   */
  type?: string;
  /**
   * @example
   * false
   */
  visibleSubProject?: boolean;
  static names(): { [key: string]: string } {
    return {
      labelIds: 'LabelIds',
      needRelatedInfo: 'NeedRelatedInfo',
      order: 'Order',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      searchKey: 'SearchKey',
      sinkEndpointTypes: 'SinkEndpointTypes',
      sortField: 'SortField',
      sourceEndpointTypes: 'SourceEndpointTypes',
      status: 'Status',
      type: 'Type',
      visibleSubProject: 'VisibleSubProject',
    };
  }

  static types(): { [key: string]: any } {
    return {
      labelIds: { 'type': 'array', 'itemType': 'string' },
      needRelatedInfo: 'boolean',
      order: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      searchKey: 'string',
      sinkEndpointTypes: { 'type': 'array', 'itemType': 'string' },
      sortField: 'string',
      sourceEndpointTypes: { 'type': 'array', 'itemType': 'string' },
      status: { 'type': 'array', 'itemType': 'string' },
      type: 'string',
      visibleSubProject: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectsShrinkRequest extends $tea.Model {
  labelIdsShrink?: string;
  needRelatedInfo?: boolean;
  /**
   * @example
   * descend
   */
  order?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * np_4w****
   */
  searchKey?: string;
  sinkEndpointTypesShrink?: string;
  /**
   * @example
   * gmtCreate
   */
  sortField?: string;
  sourceEndpointTypesShrink?: string;
  statusShrink?: string;
  /**
   * @example
   * MIGRATION
   */
  type?: string;
  /**
   * @example
   * false
   */
  visibleSubProject?: boolean;
  static names(): { [key: string]: string } {
    return {
      labelIdsShrink: 'LabelIds',
      needRelatedInfo: 'NeedRelatedInfo',
      order: 'Order',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      searchKey: 'SearchKey',
      sinkEndpointTypesShrink: 'SinkEndpointTypes',
      sortField: 'SortField',
      sourceEndpointTypesShrink: 'SourceEndpointTypes',
      statusShrink: 'Status',
      type: 'Type',
      visibleSubProject: 'VisibleSubProject',
    };
  }

  static types(): { [key: string]: any } {
    return {
      labelIdsShrink: 'string',
      needRelatedInfo: 'boolean',
      order: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      searchKey: 'string',
      sinkEndpointTypesShrink: 'string',
      sortField: 'string',
      sourceEndpointTypesShrink: 'string',
      statusShrink: 'string',
      type: 'string',
      visibleSubProject: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectsResponseBody extends $tea.Model {
  /**
   * @example
   * Contact the administrator.
   */
  advice?: string;
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  /**
   * @example
   * 1
   */
  cost?: string;
  data?: ListProjectsResponseBodyData[];
  errorDetail?: ListProjectsResponseBodyErrorDetail;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 4
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      cost: 'Cost',
      data: 'Data',
      errorDetail: 'ErrorDetail',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      cost: 'string',
      data: { 'type': 'array', 'itemType': ListProjectsResponseBodyData },
      errorDetail: ListProjectsResponseBodyErrorDetail,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListProjectsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListProjectsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkerInstancesRequest extends $tea.Model {
  /**
   * @example
   * KAFKA
   */
  destType?: string;
  /**
   * @example
   * i4katz****
   */
  instanceName?: string;
  /**
   * @example
   * true
   */
  onlyBindable?: boolean;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * OCEANBASE
   */
  sourceType?: string;
  specs?: string[];
  static names(): { [key: string]: string } {
    return {
      destType: 'DestType',
      instanceName: 'InstanceName',
      onlyBindable: 'OnlyBindable',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      sourceType: 'SourceType',
      specs: 'Specs',
    };
  }

  static types(): { [key: string]: any } {
    return {
      destType: 'string',
      instanceName: 'string',
      onlyBindable: 'boolean',
      pageNumber: 'number',
      pageSize: 'number',
      sourceType: 'string',
      specs: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkerInstancesShrinkRequest extends $tea.Model {
  /**
   * @example
   * KAFKA
   */
  destType?: string;
  /**
   * @example
   * i4katz****
   */
  instanceName?: string;
  /**
   * @example
   * true
   */
  onlyBindable?: boolean;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * OCEANBASE
   */
  sourceType?: string;
  specsShrink?: string;
  static names(): { [key: string]: string } {
    return {
      destType: 'DestType',
      instanceName: 'InstanceName',
      onlyBindable: 'OnlyBindable',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      sourceType: 'SourceType',
      specsShrink: 'Specs',
    };
  }

  static types(): { [key: string]: any } {
    return {
      destType: 'string',
      instanceName: 'string',
      onlyBindable: 'boolean',
      pageNumber: 'number',
      pageSize: 'number',
      sourceType: 'string',
      specsShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkerInstancesResponseBody extends $tea.Model {
  /**
   * @example
   * null
   */
  advice?: string;
  /**
   * @example
   * 200
   */
  code?: string;
  /**
   * @example
   * 71
   */
  cost?: string;
  data?: ListWorkerInstancesResponseBodyData[];
  errorDetail?: ListWorkerInstancesResponseBodyErrorDetail;
  /**
   * @example
   * successful
   */
  message?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 237
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      cost: 'Cost',
      data: 'Data',
      errorDetail: 'ErrorDetail',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      cost: 'string',
      data: { 'type': 'array', 'itemType': ListWorkerInstancesResponseBodyData },
      errorDetail: ListWorkerInstancesResponseBodyErrorDetail,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkerInstancesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListWorkerInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListWorkerInstancesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDatabaseDescriptionRequest extends $tea.Model {
  /**
   * @remarks
   * Example 1
   * 
   * This parameter is required.
   * 
   * @example
   * sms_pre
   */
  databaseName?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * this is a test database
   */
  description?: string;
  /**
   * @remarks
   * The description of the database.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The operation that you want to perform.   
   * Set the value to **ModifyDatabaseDescription**.
   * 
   * This parameter is required.
   * 
   * @example
   * ob2mr3oae0****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      databaseName: 'DatabaseName',
      description: 'Description',
      instanceId: 'InstanceId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      databaseName: 'string',
      description: 'string',
      instanceId: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDatabaseDescriptionResponseBody extends $tea.Model {
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDatabaseDescriptionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyDatabaseDescriptionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyDatabaseDescriptionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDatabaseUserRolesRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * sms_pre
   */
  databaseName?: string;
  /**
   * @remarks
   * The account information.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * A list of usernames and their respective roles.
   * 
   * This parameter is required.
   * 
   * @example
   * ob2mr3oae0****
   */
  tenantId?: string;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * [{"UserName":"omstest","Role":"readwrite"}]
   */
  users?: string;
  static names(): { [key: string]: string } {
    return {
      databaseName: 'DatabaseName',
      instanceId: 'InstanceId',
      tenantId: 'TenantId',
      users: 'Users',
    };
  }

  static types(): { [key: string]: any } {
    return {
      databaseName: 'string',
      instanceId: 'string',
      tenantId: 'string',
      users: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDatabaseUserRolesResponseBody extends $tea.Model {
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @remarks
   * The name of the database.
   */
  tenantUser?: ModifyDatabaseUserRolesResponseBodyTenantUser;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      tenantUser: 'TenantUser',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      tenantUser: ModifyDatabaseUserRolesResponseBodyTenantUser,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDatabaseUserRolesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyDatabaseUserRolesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyDatabaseUserRolesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceNameRequest extends $tea.Model {
  /**
   * @remarks
   * It is an Alibaba Cloud asset management and configuration tool, with which you can manage multiple Alibaba Cloud products and services by using commands. It is easy to use and a good helper in migration to cloud.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob4prod
   */
  instanceName?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      instanceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceNameResponseBody extends $tea.Model {
  /**
   * @remarks
   * The operation that you want to perform.   
   * Set the value to **ModifyInstanceName**.
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceNameResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyInstanceNameResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyInstanceNameResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceNodeNumRequest extends $tea.Model {
  /**
   * @remarks
   * Specifies whether to perform only a dry run for the request. Default value: false. Valid values:
   * - true: Only a dry-run request is sent and the number of nodes in the instance is not modified. If the dry run succeeds, DryRunResult=true is returned. If the dry run fails, an error code is returned.
   * - false: The actual request is sent and no dry run is performed. The number of nodes is changed if the requirements are met. By default, the DryRunResult parameter returns false if you set DryRun to false.
   * 
   * @example
   * true
   */
  dryRun?: boolean;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The number of nodes in the cluster. If the cluster is deployed in n-n-n mode, the number of nodes in the cluster equals n × 3.
   * 
   * This parameter is required.
   * 
   * @example
   * 6
   */
  nodeNum?: string;
  static names(): { [key: string]: string } {
    return {
      dryRun: 'DryRun',
      instanceId: 'InstanceId',
      nodeNum: 'NodeNum',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dryRun: 'boolean',
      instanceId: 'string',
      nodeNum: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceNodeNumResponseBody extends $tea.Model {
  /**
   * @remarks
   * The return result of the request.
   */
  data?: ModifyInstanceNodeNumResponseBodyData;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: ModifyInstanceNodeNumResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceNodeNumResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyInstanceNodeNumResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyInstanceNodeNumResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceSSLRequest extends $tea.Model {
  /**
   * @remarks
   * The operation to modify the SSL status. Valid values:
   * 
   * - open: Enable SSL encryption.
   * 
   * - update: Update the CA certificate.
   * 
   * - close: Disable SSL encryption.
   * 
   * This parameter is required.
   * 
   * @example
   * open
   */
  enableSSL?: string;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      enableSSL: 'EnableSSL',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enableSSL: 'string',
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceSSLResponseBody extends $tea.Model {
  /**
   * @remarks
   * The SSL setting of the OceanBase cluster instance.
   */
  instanceSSL?: ModifyInstanceSSLResponseBodyInstanceSSL;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceSSL: 'InstanceSSL',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceSSL: ModifyInstanceSSLResponseBodyInstanceSSL,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceSSLResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyInstanceSSLResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyInstanceSSLResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceSpecRequest extends $tea.Model {
  /**
   * @remarks
   * The size of the storage space, in GB. The required storage space varies based on the cluster specifications:
   * - 8C32G: 100 GB to 10 TB.
   * - 14C70G: 200 GB to 10 TB.
   * - 30C180G: 400 GB to 10 TB.
   * - 62C400G: 800 GB to 10 TB. The preceding minimum storage space sizes are the default storage space sizes of the corresponding cluster specification plans.
   * 
   * @example
   * 200
   */
  diskSize?: number;
  /**
   * @remarks
   * Disk type.
   * 
   * @example
   * cloud_essd_pl1
   */
  diskType?: string;
  /**
   * @remarks
   * Specifies whether to perform only a dry run for the request. Default value: false. Valid values:
   * - true: Only a dry-run request is sent and the instance settings are not modified. If the dry run succeeds, DryRunResult=true is returned. If the dry run fails, an error code is returned.
   * - false: If the DryRun parameter is set to false, no dry run is performed and the DryRunResult parameter returns false.
   * 
   * @example
   * false
   */
  dryRun?: boolean;
  /**
   * @remarks
   * The specifications of the cluster. You can specify one of the following four plans:
   * - 8C32GB: indicates 8 CPU cores and 32 GB of memory.
   * - 14C70GB: indicates 14 CPU cores and 70 GB of memory. This is the default value.
   * - 30C180GB: indicates 30 CPU cores and 180 GB of memory.
   * - 62C400GB: indicates 62 CPU cores and 400 GB of memory.
   * 
   * @example
   * 14C70GB
   */
  instanceClass?: string;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob3h8ytroxxxxx
   */
  instanceId?: string;
  upgradeSpecNative?: boolean;
  static names(): { [key: string]: string } {
    return {
      diskSize: 'DiskSize',
      diskType: 'DiskType',
      dryRun: 'DryRun',
      instanceClass: 'InstanceClass',
      instanceId: 'InstanceId',
      upgradeSpecNative: 'UpgradeSpecNative',
    };
  }

  static types(): { [key: string]: any } {
    return {
      diskSize: 'number',
      diskType: 'string',
      dryRun: 'boolean',
      instanceClass: 'string',
      instanceId: 'string',
      upgradeSpecNative: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceSpecResponseBody extends $tea.Model {
  /**
   * @remarks
   * The return data of the request.
   * 
   * @example
   * 1234567890
   */
  data?: ModifyInstanceSpecResponseBodyData;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: ModifyInstanceSpecResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceSpecResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyInstanceSpecResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyInstanceSpecResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceTagsRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The tags.
   * 
   * This parameter is required.
   * 
   * @example
   * [{"Key": "xxx", "Value", "xxx"},{}]
   */
  tags?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      tags: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceTagsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The tag modification result.
   * 
   * @example
   * done
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceTagsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyInstanceTagsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyInstanceTagsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceTemporaryCapacityRequest extends $tea.Model {
  /**
   * @example
   * zh-CN
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The disk size. Unit: GB.
   * 
   * @example
   * 400
   */
  diskSize?: string;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * Specification.
   * 
   * This parameter is required.
   * 
   * @example
   * oceanbase.cluster.i2.small
   */
  spec?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      diskSize: 'DiskSize',
      instanceId: 'InstanceId',
      spec: 'Spec',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      diskSize: 'string',
      instanceId: 'string',
      spec: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceTemporaryCapacityResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceTemporaryCapacityResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyInstanceTemporaryCapacityResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyInstanceTemporaryCapacityResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyParametersRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * TENANT
   */
  dimension?: string;
  /**
   * @remarks
   * The cause of the modification failure.
   * 
   * @example
   * ob2mr3oae0****
   */
  dimensionValue?: string;
  /**
   * @remarks
   * Alibaba Cloud CLI
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The resource ID of the parameter type.    
   * You can leave this parameter unspecified when you call this operation to modify cluster parameters. In the case of tenant parameters, pass the tenant ID.
   * 
   * This parameter is required.
   * 
   * @example
   * [{"Name":"connect_timeout","Value":"20"}]
   */
  parameters?: string;
  static names(): { [key: string]: string } {
    return {
      dimension: 'Dimension',
      dimensionValue: 'DimensionValue',
      instanceId: 'InstanceId',
      parameters: 'Parameters',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dimension: 'string',
      dimensionValue: 'string',
      instanceId: 'string',
      parameters: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyParametersResponseBody extends $tea.Model {
  /**
   * @remarks
   * The operation that you want to perform.   
   * Set the value to **ModifyParameters**.
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @remarks
   * Example 1
   */
  results?: ModifyParametersResponseBodyResults;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      results: 'Results',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      results: ModifyParametersResponseBodyResults,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyParametersResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyParametersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyParametersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifySecurityIpsRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The information of the IP address whitelist group.
   * 
   * @example
   * paytest
   */
  securityIpGroupName?: string;
  /**
   * @remarks
   * The list of IP addresses and CIDR blocks in the whitelist.   
   * It is a JSON array. Each object in the array is an IP address or CIDR block. You can specify at most 40 IP addresses or CIDR blocks.
   * 
   * @example
   * ["192.168.0.0/20","192.169.1.1"]
   */
  securityIps?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      securityIpGroupName: 'SecurityIpGroupName',
      securityIps: 'SecurityIps',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      securityIpGroupName: 'string',
      securityIps: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifySecurityIpsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @remarks
   * Example 1
   */
  securityIpGroup?: ModifySecurityIpsResponseBodySecurityIpGroup;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      securityIpGroup: 'SecurityIpGroup',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      securityIpGroup: ModifySecurityIpsResponseBodySecurityIpGroup,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifySecurityIpsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifySecurityIpsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifySecurityIpsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTagNameRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the tag group.
   * 
   * This parameter is required.
   * 
   * @example
   * Tag group 1
   */
  key?: string;
  /**
   * @remarks
   * The new name of the tag group.
   * 
   * This parameter is required.
   * 
   * @example
   * Tag group 2
   */
  newKey?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      newKey: 'NewKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      newKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTagNameResponseBody extends $tea.Model {
  /**
   * @remarks
   * The tag group renaming result.
   * 
   * @example
   * update tag name success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 4C91F7BA-xxxx-xxxx-xxxx-846ECA1A9908
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTagNameResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyTagNameResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyTagNameResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTagValueNameRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the tag group.
   * 
   * This parameter is required.
   * 
   * @example
   * Tag group 1
   */
  key?: string;
  /**
   * @remarks
   * The new name of the tag.
   * 
   * This parameter is required.
   * 
   * @example
   * Tag 2
   */
  newValue?: string;
  /**
   * @remarks
   * The name of the tag.
   * 
   * This parameter is required.
   * 
   * @example
   * Tag 1
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      newValue: 'NewValue',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      newValue: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTagValueNameResponseBody extends $tea.Model {
  /**
   * @remarks
   * The tag renaming result.
   * 
   * @example
   * update tag-value name success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 4C91F7BA-xxxx-xxxx-xxxx-846ECA1A9908
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTagValueNameResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyTagValueNameResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyTagValueNameResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantEncryptionRequest extends $tea.Model {
  /**
   * @example
   * key-shh322****470h8v0-g2ll85****
   */
  encryptionKeyId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * EncryptionKey
   */
  encryptionType?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * ob2mr3oae0****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      encryptionKeyId: 'EncryptionKeyId',
      encryptionType: 'EncryptionType',
      instanceId: 'InstanceId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      encryptionKeyId: 'string',
      encryptionType: 'string',
      instanceId: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantEncryptionResponseBody extends $tea.Model {
  /**
   * @remarks
   * Id of the request
   * 
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @remarks
   * job
   */
  tenantEncryption?: ModifyTenantEncryptionResponseBodyTenantEncryption;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      tenantEncryption: 'TenantEncryption',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      tenantEncryption: ModifyTenantEncryptionResponseBodyTenantEncryption,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantEncryptionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyTenantEncryptionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyTenantEncryptionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantPrimaryZoneRequest extends $tea.Model {
  /**
   * @remarks
   * The primary zone of the tenant.    
   * It is one of the zones in which the cluster is deployed.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * ```
   * http(s)://[Endpoint]/?Action=ModifyTenantPrimaryZone
   * &TenantId=ob2mr3oae0****
   * &InstanceId=ob317v4uif****
   * &PrimaryZone=cn-hangzhou-h
   * &Common request parameters
   * ```
   * 
   * @example
   * cn-hangzhou-h
   */
  masterIntranetAddressZone?: string;
  /**
   * @remarks
   * The ID of the vSwitch.
   * 
   * @example
   * cn-hangzhou-h
   */
  primaryZone?: string;
  tenantEndpointDirectId?: string;
  /**
   * @example
   * obe-4tw51gp7****
   */
  tenantEndpointId?: string;
  /**
   * @remarks
   * The return result of the request.
   * 
   * This parameter is required.
   * 
   * @example
   * ob2mr3oae0****
   */
  tenantId?: string;
  userDirectVSwitchId?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * vsw-xxx
   */
  userVSwitchId?: string;
  userVpcOwnerId?: string;
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      masterIntranetAddressZone: 'MasterIntranetAddressZone',
      primaryZone: 'PrimaryZone',
      tenantEndpointDirectId: 'TenantEndpointDirectId',
      tenantEndpointId: 'TenantEndpointId',
      tenantId: 'TenantId',
      userDirectVSwitchId: 'UserDirectVSwitchId',
      userVSwitchId: 'UserVSwitchId',
      userVpcOwnerId: 'UserVpcOwnerId',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      masterIntranetAddressZone: 'string',
      primaryZone: 'string',
      tenantEndpointDirectId: 'string',
      tenantEndpointId: 'string',
      tenantId: 'string',
      userDirectVSwitchId: 'string',
      userVSwitchId: 'string',
      userVpcOwnerId: 'string',
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantPrimaryZoneResponseBody extends $tea.Model {
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantPrimaryZoneResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyTenantPrimaryZoneResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyTenantPrimaryZoneResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantResourceRequest extends $tea.Model {
  /**
   * @remarks
   * The information about the CPU resources of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * 2
   */
  cpu?: number;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The size of the log disk allocated to the tenant, in GB.
   * 
   * @example
   * 128
   */
  logDisk?: number;
  /**
   * @remarks
   * The memory size of the tenant, in GB.
   * 
   * This parameter is required.
   * 
   * @example
   * 2
   */
  memory?: number;
  /**
   * @remarks
   * Specifies to create a read-only zone. Separate the names of multiple zones with commas (,).
   * 
   * @example
   * cn-shanghai-g-ro,cn-shanghai-h-ro
   * 
   * @deprecated
   */
  readOnlyZoneList?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * ob2mr3oae0****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      cpu: 'Cpu',
      instanceId: 'InstanceId',
      logDisk: 'LogDisk',
      memory: 'Memory',
      readOnlyZoneList: 'ReadOnlyZoneList',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cpu: 'number',
      instanceId: 'string',
      logDisk: 'number',
      memory: 'number',
      readOnlyZoneList: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantResourceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * @example
   * t33h8y08k****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantResourceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyTenantResourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyTenantResourceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantSecurityIpGroupRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The group name of the whitelist group of IP addresses.
   * 
   * It starts with lowercase letters and ends with lowercase letters or numbers. It can only contain lowercase letters, numbers, and underscores, and should be 2~32 characters in length.
   * 
   * This parameter is required.
   * 
   * @example
   * paytest
   */
  securityIpGroupName?: string;
  /**
   * @remarks
   * The list of IP addresses in the whitelist group.
   * 
   * It is a JSON array. Each object in the array is an IP address or a CIDR block. You can have up to 40 whitelists.
   * 
   * This parameter is required.
   * 
   * @example
   * 192.***.*.*"
   */
  securityIps?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * t4louaeei****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      securityIpGroupName: 'SecurityIpGroupName',
      securityIps: 'SecurityIps',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      securityIpGroupName: 'string',
      securityIps: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantSecurityIpGroupResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @remarks
   * The information of the IP address whitelist group.
   */
  securityIpGroup?: ModifyTenantSecurityIpGroupResponseBodySecurityIpGroup;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      securityIpGroup: 'SecurityIpGroup',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      securityIpGroup: ModifyTenantSecurityIpGroupResponseBodySecurityIpGroup,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantSecurityIpGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyTenantSecurityIpGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyTenantSecurityIpGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantTagsRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The tags.
   * 
   * This parameter is required.
   * 
   * @example
   * [{"Key": "xxx", "Value", "xxx"}]
   */
  tags?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * t33h8y08k****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      tags: 'Tags',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      tags: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantTagsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The tag modification result.
   * 
   * @example
   * done
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantTagsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyTenantTagsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyTenantTagsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantUserDescriptionRequest extends $tea.Model {
  /**
   * @remarks
   * The operation that you want to perform.   
   * Set the value to **ModifyTenantUserDescription**.
   * 
   * This parameter is required.
   * 
   * @example
   * this is a test database
   */
  description?: string;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * ob2mr3oae0****
   */
  tenantId?: string;
  /**
   * @remarks
   * The description of the database.
   * 
   * This parameter is required.
   * 
   * @example
   * pay_test
   */
  userName?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      instanceId: 'InstanceId',
      tenantId: 'TenantId',
      userName: 'UserName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      instanceId: 'string',
      tenantId: 'string',
      userName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantUserDescriptionResponseBody extends $tea.Model {
  /**
   * @remarks
   * You can call this operation to modify the description of a specified account in a tenant.
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantUserDescriptionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyTenantUserDescriptionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyTenantUserDescriptionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantUserPasswordRequest extends $tea.Model {
  /**
   * @remarks
   * 加密方式。
   * 
   * @example
   * RSA
   */
  encryptionType?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * ```
   * http(s)://[Endpoint]/?Action=ModifyTenantUserPassword
   * &UserName=pay_test
   * &TenantId=ob2mr3oae0****
   * &UserPassword=!Aliyun4Oceanbase
   * &InstanceId=ob317v4uif****
   * &Common request parameters
   * ```
   * 
   * This parameter is required.
   * 
   * @example
   * ob2mr3oae0****
   */
  tenantId?: string;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * pay_test
   */
  userName?: string;
  /**
   * @remarks
   * You can call this operation to change the logon password of a specified account in a tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * !Aliyun4Oceanbase
   */
  userPassword?: string;
  static names(): { [key: string]: string } {
    return {
      encryptionType: 'EncryptionType',
      instanceId: 'InstanceId',
      tenantId: 'TenantId',
      userName: 'UserName',
      userPassword: 'UserPassword',
    };
  }

  static types(): { [key: string]: any } {
    return {
      encryptionType: 'string',
      instanceId: 'string',
      tenantId: 'string',
      userName: 'string',
      userPassword: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantUserPasswordResponseBody extends $tea.Model {
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantUserPasswordResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyTenantUserPasswordResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyTenantUserPasswordResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantUserRolesRequest extends $tea.Model {
  /**
   * @remarks
   * The type of the privilege modification operation.   
   * Valid values:  
   * update: updates all privileges. This is the default value.  
   * add: adds a privilege.  
   * delete: deletes a privilege.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The name of the table.
   * 
   * @example
   * update
   */
  modifyType?: string;
  /**
   * @remarks
   * The operation that you want to perform.   
   * Set the value to **ModifyTenantUserRoles**.
   * 
   * This parameter is required.
   * 
   * @example
   * ob2mr3oae0****
   */
  tenantId?: string;
  /**
   * @remarks
   * The role of the database account.
   * 
   * This parameter is required.
   * 
   * @example
   * pay_test
   */
  userName?: string;
  /**
   * @remarks
   * The type of the account. Valid values:   
   * - Admin: the super administrator account.   
   * - Normal: a general account.
   * 
   * This parameter is required.
   * 
   * @example
   * [{"Database":"20210824160559","Role":"readwrite"}]
   */
  userRole?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      modifyType: 'ModifyType',
      tenantId: 'TenantId',
      userName: 'UserName',
      userRole: 'UserRole',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      modifyType: 'string',
      tenantId: 'string',
      userName: 'string',
      userRole: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantUserRolesResponseBody extends $tea.Model {
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @remarks
   * The ID of the tenant.
   */
  tenantUser?: ModifyTenantUserRolesResponseBodyTenantUser;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      tenantUser: 'TenantUser',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      tenantUser: ModifyTenantUserRolesResponseBodyTenantUser,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantUserRolesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyTenantUserRolesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyTenantUserRolesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantUserStatusRequest extends $tea.Model {
  /**
   * @remarks
   * The operation that you want to perform.   
   * Set the value to **ModifyTenantUserStatus**.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * ob2mr3oae0****
   */
  tenantId?: string;
  /**
   * @remarks
   * The list of database accounts in the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * pay_test
   */
  userName?: string;
  /**
   * @remarks
   * The status of the database account. Valid values:   
   * - Locked: The account is locked. 
   * - Online: The account is unlocked.
   * 
   * This parameter is required.
   * 
   * @example
   * The ID of the tenant.
   */
  userStatus?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      tenantId: 'TenantId',
      userName: 'UserName',
      userStatus: 'UserStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      tenantId: 'string',
      userName: 'string',
      userStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantUserStatusResponseBody extends $tea.Model {
  /**
   * @remarks
   * Example 1
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  tenantUser?: ModifyTenantUserStatusResponseBodyTenantUser[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      tenantUser: 'TenantUser',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      tenantUser: { 'type': 'array', 'itemType': ModifyTenantUserStatusResponseBodyTenantUser },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantUserStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyTenantUserStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyTenantUserStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleaseProjectRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * np_4w3a****
   */
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleaseProjectResponseBody extends $tea.Model {
  /**
   * @example
   * Contact the administrator.
   */
  advice?: string;
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  /**
   * @example
   * 1
   */
  cost?: string;
  /**
   * @example
   * null
   */
  data?: any;
  errorDetail?: ReleaseProjectResponseBodyErrorDetail;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 50
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      cost: 'Cost',
      data: 'Data',
      errorDetail: 'ErrorDetail',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      cost: 'string',
      data: 'any',
      errorDetail: ReleaseProjectResponseBodyErrorDetail,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleaseProjectResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ReleaseProjectResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ReleaseProjectResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleaseWorkerInstanceRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * g_abcdefj***
   */
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleaseWorkerInstanceResponseBody extends $tea.Model {
  /**
   * @example
   * Contact the administrator.
   */
  advice?: string;
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  /**
   * @example
   * 30
   */
  cost?: string;
  /**
   * @example
   * null
   */
  data?: string;
  errorDetail?: ReleaseWorkerInstanceResponseBodyErrorDetail;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 100
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      cost: 'Cost',
      data: 'Data',
      errorDetail: 'ErrorDetail',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      cost: 'string',
      data: 'string',
      errorDetail: ReleaseWorkerInstanceResponseBodyErrorDetail,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleaseWorkerInstanceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ReleaseWorkerInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ReleaseWorkerInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResumeProjectRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * np_4w3a****
   */
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResumeProjectResponseBody extends $tea.Model {
  /**
   * @example
   * Contact the administrator.
   */
  advice?: string;
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  /**
   * @example
   * 1
   */
  cost?: string;
  /**
   * @example
   * null
   */
  data?: any;
  errorDetail?: ResumeProjectResponseBodyErrorDetail;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 50
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      cost: 'Cost',
      data: 'Data',
      errorDetail: 'ErrorDetail',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      cost: 'string',
      data: 'any',
      errorDetail: ResumeProjectResponseBodyErrorDetail,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResumeProjectResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ResumeProjectResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ResumeProjectResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RetryProjectModifyRecordsRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 344000005
   */
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RetryProjectModifyRecordsResponseBody extends $tea.Model {
  /**
   * @example
   * Contact the administrator.
   */
  advice?: string;
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  /**
   * @example
   * 30
   */
  cost?: string;
  /**
   * @example
   * null
   */
  data?: any;
  errorDetail?: RetryProjectModifyRecordsResponseBodyErrorDetail;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 100
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      cost: 'Cost',
      data: 'Data',
      errorDetail: 'ErrorDetail',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      cost: 'string',
      data: 'any',
      errorDetail: RetryProjectModifyRecordsResponseBodyErrorDetail,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RetryProjectModifyRecordsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RetryProjectModifyRecordsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RetryProjectModifyRecordsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartProjectRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * np_4w3a****
   */
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartProjectResponseBody extends $tea.Model {
  /**
   * @example
   * Contact the administrator.
   */
  advice?: string;
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  /**
   * @example
   * 1
   */
  cost?: string;
  /**
   * @example
   * null
   */
  data?: string;
  errorDetail?: StartProjectResponseBodyErrorDetail;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * XCVSADG****DSGDS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 100
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      cost: 'Cost',
      data: 'Data',
      errorDetail: 'ErrorDetail',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      cost: 'string',
      data: 'string',
      errorDetail: StartProjectResponseBodyErrorDetail,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartProjectResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: StartProjectResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StartProjectResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartProjectsByLabelRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * l_****
   */
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartProjectsByLabelResponseBody extends $tea.Model {
  /**
   * @example
   * Contact the administrator.
   */
  advice?: string;
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  /**
   * @example
   * 1
   */
  cost?: string;
  data?: StartProjectsByLabelResponseBodyData;
  errorDetail?: StartProjectsByLabelResponseBodyErrorDetail;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 79
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      cost: 'Cost',
      data: 'Data',
      errorDetail: 'ErrorDetail',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      cost: 'string',
      data: StartProjectsByLabelResponseBodyData,
      errorDetail: StartProjectsByLabelResponseBodyErrorDetail,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartProjectsByLabelResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: StartProjectsByLabelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StartProjectsByLabelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopProjectRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * np_4w3a****
   */
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopProjectResponseBody extends $tea.Model {
  /**
   * @example
   * Contact the administrator.
   */
  advice?: string;
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  /**
   * @example
   * 27 ms
   */
  cost?: string;
  /**
   * @example
   * null
   */
  data?: string;
  errorDetail?: StopProjectResponseBodyErrorDetail;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * 473469**-AA6F-4D**-B3DB-A***********
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 100
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      cost: 'Cost',
      data: 'Data',
      errorDetail: 'ErrorDetail',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      cost: 'string',
      data: 'string',
      errorDetail: StopProjectResponseBodyErrorDetail,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopProjectResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: StopProjectResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StopProjectResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopProjectModifyRecordsRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 344000005
   */
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopProjectModifyRecordsResponseBody extends $tea.Model {
  /**
   * @example
   * Contact the administrator.
   */
  advice?: string;
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  /**
   * @example
   * 30
   */
  cost?: string;
  /**
   * @example
   * null
   */
  data?: any;
  errorDetail?: StopProjectModifyRecordsResponseBodyErrorDetail;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 100
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      cost: 'Cost',
      data: 'Data',
      errorDetail: 'ErrorDetail',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      cost: 'string',
      data: 'any',
      errorDetail: StopProjectModifyRecordsResponseBodyErrorDetail,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopProjectModifyRecordsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: StopProjectModifyRecordsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StopProjectModifyRecordsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopProjectsByLabelRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * l_****
   */
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopProjectsByLabelResponseBody extends $tea.Model {
  /**
   * @example
   * Contact the administrator.
   */
  advice?: string;
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  /**
   * @example
   * 1
   */
  cost?: string;
  data?: StopProjectsByLabelResponseBodyData;
  errorDetail?: StopProjectsByLabelResponseBodyErrorDetail;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * A595F34C-XXXX-5D0C-8DA8-B3ED76
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 140
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      cost: 'Cost',
      data: 'Data',
      errorDetail: 'ErrorDetail',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      cost: 'string',
      data: StopProjectsByLabelResponseBodyData,
      errorDetail: StopProjectsByLabelResponseBodyErrorDetail,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopProjectsByLabelResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: StopProjectsByLabelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StopProjectsByLabelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SwitchoverInstanceRequest extends $tea.Model {
  /**
   * @remarks
   * Whether to force the switchover.
   * - true: Force the switchover.
   * - false: Do not force the switchover.
   * 
   * @example
   * true
   */
  forced?: boolean;
  /**
   * @remarks
   * The instance ID of the primary/standby instance. You can set the default value to the instance ID of the instance to be switched to the primary instance.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The instance ID of the instance to be switched to the primary instance.
   * 
   * This parameter is required.
   * 
   * @example
   * ob4bv8o7sp****
   */
  targetInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      forced: 'Forced',
      instanceId: 'InstanceId',
      targetInstanceId: 'TargetInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      forced: 'boolean',
      instanceId: 'string',
      targetInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SwitchoverInstanceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The list of data for the switchover.
   */
  data?: SwitchoverInstanceResponseBodyData;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 473469**-AA6F-4D**-B3DB-A***********
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: SwitchoverInstanceResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SwitchoverInstanceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SwitchoverInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SwitchoverInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProjectConfigRequest extends $tea.Model {
  commonTransferConfig?: UpdateProjectConfigRequestCommonTransferConfig;
  fullTransferConfig?: UpdateProjectConfigRequestFullTransferConfig;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * np_fe****
   */
  id?: string;
  incrTransferConfig?: UpdateProjectConfigRequestIncrTransferConfig;
  reverseIncrTransferConfig?: UpdateProjectConfigRequestReverseIncrTransferConfig;
  static names(): { [key: string]: string } {
    return {
      commonTransferConfig: 'CommonTransferConfig',
      fullTransferConfig: 'FullTransferConfig',
      id: 'Id',
      incrTransferConfig: 'IncrTransferConfig',
      reverseIncrTransferConfig: 'ReverseIncrTransferConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonTransferConfig: UpdateProjectConfigRequestCommonTransferConfig,
      fullTransferConfig: UpdateProjectConfigRequestFullTransferConfig,
      id: 'string',
      incrTransferConfig: UpdateProjectConfigRequestIncrTransferConfig,
      reverseIncrTransferConfig: UpdateProjectConfigRequestReverseIncrTransferConfig,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProjectConfigShrinkRequest extends $tea.Model {
  commonTransferConfigShrink?: string;
  fullTransferConfigShrink?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * np_fe****
   */
  id?: string;
  incrTransferConfigShrink?: string;
  reverseIncrTransferConfigShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonTransferConfigShrink: 'CommonTransferConfig',
      fullTransferConfigShrink: 'FullTransferConfig',
      id: 'Id',
      incrTransferConfigShrink: 'IncrTransferConfig',
      reverseIncrTransferConfigShrink: 'ReverseIncrTransferConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonTransferConfigShrink: 'string',
      fullTransferConfigShrink: 'string',
      id: 'string',
      incrTransferConfigShrink: 'string',
      reverseIncrTransferConfigShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProjectConfigResponseBody extends $tea.Model {
  /**
   * @example
   * Contact the administrator.
   */
  advice?: string;
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  /**
   * @example
   * 1
   */
  cost?: string;
  /**
   * @example
   * null
   */
  data?: string;
  errorDetail?: UpdateProjectConfigResponseBodyErrorDetail;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 100
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      cost: 'Cost',
      data: 'Data',
      errorDetail: 'ErrorDetail',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      cost: 'string',
      data: 'string',
      errorDetail: UpdateProjectConfigResponseBodyErrorDetail,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProjectConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateProjectConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateProjectConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DataExtraInfoSubDbsValueTablesColumns extends $tea.Model {
  /**
   * @example
   * null
   */
  columnName?: string;
  /**
   * @example
   * null
   */
  position?: number;
  /**
   * @example
   * null
   */
  columnType?: string;
  /**
   * @example
   * null
   */
  recordFieldType?: string;
  /**
   * @example
   * null
   */
  rawColumnType?: string;
  /**
   * @example
   * null
   */
  columnKey?: string;
  /**
   * @example
   * true
   */
  nullable?: boolean;
  /**
   * @example
   * null
   */
  defaultValue?: string;
  /**
   * @example
   * null
   */
  dataLength?: number;
  /**
   * @example
   * 64
   */
  dataPrecision?: number;
  /**
   * @example
   * null
   */
  dataScale?: number;
  /**
   * @example
   * utf8
   */
  encoding?: string;
  /**
   * @example
   * comments
   */
  columnComment?: string;
  /**
   * @example
   * false
   */
  isGenerateField?: boolean;
  static names(): { [key: string]: string } {
    return {
      columnName: 'ColumnName',
      position: 'Position',
      columnType: 'ColumnType',
      recordFieldType: 'RecordFieldType',
      rawColumnType: 'RawColumnType',
      columnKey: 'ColumnKey',
      nullable: 'Nullable',
      defaultValue: 'DefaultValue',
      dataLength: 'DataLength',
      dataPrecision: 'DataPrecision',
      dataScale: 'DataScale',
      encoding: 'Encoding',
      columnComment: 'ColumnComment',
      isGenerateField: 'IsGenerateField',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnName: 'string',
      position: 'number',
      columnType: 'string',
      recordFieldType: 'string',
      rawColumnType: 'string',
      columnKey: 'string',
      nullable: 'boolean',
      defaultValue: 'string',
      dataLength: 'number',
      dataPrecision: 'number',
      dataScale: 'number',
      encoding: 'string',
      columnComment: 'string',
      isGenerateField: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DataExtraInfoSubDbsValueTables extends $tea.Model {
  /**
   * @example
   * fexg***
   */
  tableId?: string;
  /**
   * @example
   * db_name
   */
  database?: string;
  /**
   * @example
   * table_name
   */
  tableName?: string;
  /**
   * @example
   * mapped_table
   */
  mappingTableName?: string;
  /**
   * @example
   * g_i4kat***
   */
  instance?: string;
  columns?: DataExtraInfoSubDbsValueTablesColumns[];
  static names(): { [key: string]: string } {
    return {
      tableId: 'TableId',
      database: 'Database',
      tableName: 'TableName',
      mappingTableName: 'MappingTableName',
      instance: 'Instance',
      columns: 'Columns',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tableId: 'string',
      database: 'string',
      tableName: 'string',
      mappingTableName: 'string',
      instance: 'string',
      columns: { 'type': 'array', 'itemType': DataExtraInfoSubDbsValueTablesColumns },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchKillProcessListResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the calling is successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelProjectModifyRecordResponseBodyErrorDetail extends $tea.Model {
  /**
   * @example
   * 200
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * Contact the administrator.
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateInstanceResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The result of the dry-run request.
   * 
   * If the DryRun parameter is set to true and the dry run succeeds, the DryRunResult parameter returns true. Otherwise, an error code is returned.
   * If the DryRun parameter is set to false, no dry run is performed and the DryRunResult parameter returns false.
   * 
   * @example
   * true
   */
  dryRunResult?: boolean;
  /**
   * @remarks
   * Instance ID.
   * 
   * @example
   * i-bp67acfmxazb4p****
   */
  instanceId?: string;
  /**
   * @remarks
   * Order ID. The ID of the order that you have placed.
   * This parameter returns a value after you create a pre-paid or post-paid cluster.
   * 
   * @example
   * 1234567890
   */
  orderId?: string;
  /**
   * @remarks
   * Resource group ID.
   * 
   * @example
   * rg-***************
   */
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      dryRunResult: 'DryRunResult',
      instanceId: 'InstanceId',
      orderId: 'OrderId',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dryRunResult: 'boolean',
      instanceId: 'string',
      orderId: 'string',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLabelResponseBodyErrorDetail extends $tea.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * null
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMySqlDataSourceResponseBodyErrorDetail extends $tea.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * null
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * Contact the administrator.
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOceanBaseDataSourceResponseBodyErrorDetail extends $tea.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * null
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOmsMysqlDataSourceResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The ID of the data source record.
   * 
   * @example
   * e_1234abcd*****
   */
  endpointId?: string;
  static names(): { [key: string]: string } {
    return {
      endpointId: 'EndpointId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endpointId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectRequestCommonTransferConfigCustomColumns extends $tea.Model {
  columnName?: string;
  expression?: string;
  static names(): { [key: string]: string } {
    return {
      columnName: 'ColumnName',
      expression: 'Expression',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnName: 'string',
      expression: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectRequestCommonTransferConfig extends $tea.Model {
  /**
   * @example
   * false
   */
  activeActive?: boolean;
  customColumns?: CreateProjectRequestCommonTransferConfigCustomColumns[];
  /**
   * @example
   * null
   */
  dataWorksBusinessName?: string;
  /**
   * @example
   * TUPLE
   */
  datahubTopicType?: string;
  /**
   * @example
   * 0
   */
  mqPartition?: number;
  /**
   * @example
   * ONE
   */
  mqPartitionMode?: string;
  /**
   * @example
   * DEFAULT
   */
  mqSerializerType?: string;
  /**
   * @example
   * false
   */
  rocketMqEnableMsgTrace?: boolean;
  /**
   * @example
   * default_tag
   */
  rocketMqMsgTags?: string;
  /**
   * @example
   * OMS
   */
  rocketMqProducerGroup?: string;
  /**
   * @example
   * null
   */
  rocketMqSendMsgTimeout?: number;
  sinkStoreFormat?: string;
  sourceStoreFormat?: string;
  syncSchema?: boolean;
  syncSchemaColumnName?: string;
  /**
   * @example
   * ALL
   */
  tableCategory?: string;
  static names(): { [key: string]: string } {
    return {
      activeActive: 'ActiveActive',
      customColumns: 'CustomColumns',
      dataWorksBusinessName: 'DataWorksBusinessName',
      datahubTopicType: 'DatahubTopicType',
      mqPartition: 'MqPartition',
      mqPartitionMode: 'MqPartitionMode',
      mqSerializerType: 'MqSerializerType',
      rocketMqEnableMsgTrace: 'RocketMqEnableMsgTrace',
      rocketMqMsgTags: 'RocketMqMsgTags',
      rocketMqProducerGroup: 'RocketMqProducerGroup',
      rocketMqSendMsgTimeout: 'RocketMqSendMsgTimeout',
      sinkStoreFormat: 'SinkStoreFormat',
      sourceStoreFormat: 'SourceStoreFormat',
      syncSchema: 'SyncSchema',
      syncSchemaColumnName: 'SyncSchemaColumnName',
      tableCategory: 'TableCategory',
    };
  }

  static types(): { [key: string]: any } {
    return {
      activeActive: 'boolean',
      customColumns: { 'type': 'array', 'itemType': CreateProjectRequestCommonTransferConfigCustomColumns },
      dataWorksBusinessName: 'string',
      datahubTopicType: 'string',
      mqPartition: 'number',
      mqPartitionMode: 'string',
      mqSerializerType: 'string',
      rocketMqEnableMsgTrace: 'boolean',
      rocketMqMsgTags: 'string',
      rocketMqProducerGroup: 'string',
      rocketMqSendMsgTimeout: 'number',
      sinkStoreFormat: 'string',
      sourceStoreFormat: 'string',
      syncSchema: 'boolean',
      syncSchemaColumnName: 'string',
      tableCategory: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectRequestFullTransferConfig extends $tea.Model {
  /**
   * @example
   * true
   */
  allowDestTableNotEmpty?: boolean;
  /**
   * @example
   * NORMAL
   */
  fullTransferSpeedMode?: string;
  /**
   * @example
   * NORMAL
   */
  fullVerifySpeedMode?: string;
  /**
   * @example
   * true
   */
  nonePkUkTruncateDstTable?: boolean;
  readWorkerNum?: number;
  throttleIOPS?: number;
  throttleRps?: number;
  writeWorkerNum?: number;
  static names(): { [key: string]: string } {
    return {
      allowDestTableNotEmpty: 'AllowDestTableNotEmpty',
      fullTransferSpeedMode: 'FullTransferSpeedMode',
      fullVerifySpeedMode: 'FullVerifySpeedMode',
      nonePkUkTruncateDstTable: 'NonePkUkTruncateDstTable',
      readWorkerNum: 'ReadWorkerNum',
      throttleIOPS: 'ThrottleIOPS',
      throttleRps: 'ThrottleRps',
      writeWorkerNum: 'WriteWorkerNum',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allowDestTableNotEmpty: 'boolean',
      fullTransferSpeedMode: 'string',
      fullVerifySpeedMode: 'string',
      nonePkUkTruncateDstTable: 'boolean',
      readWorkerNum: 'number',
      throttleIOPS: 'number',
      throttleRps: 'number',
      writeWorkerNum: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectRequestIncrTransferConfig extends $tea.Model {
  /**
   * @example
   * true
   */
  enableIncrSyncStatistics?: boolean;
  /**
   * @example
   * true
   */
  enableSequencingWithinTxn?: boolean;
  /**
   * @example
   * 64
   */
  incrSyncConcurrency?: number;
  recordTypeWhiteList?: string[];
  /**
   * @example
   * 1689201369
   */
  startTimestamp?: string;
  /**
   * @example
   * 24
   */
  storeLogKeptHour?: number;
  supportDDLTypes?: string[];
  throttleIOPS?: number;
  throttleRps?: number;
  static names(): { [key: string]: string } {
    return {
      enableIncrSyncStatistics: 'EnableIncrSyncStatistics',
      enableSequencingWithinTxn: 'EnableSequencingWithinTxn',
      incrSyncConcurrency: 'IncrSyncConcurrency',
      recordTypeWhiteList: 'RecordTypeWhiteList',
      startTimestamp: 'StartTimestamp',
      storeLogKeptHour: 'StoreLogKeptHour',
      supportDDLTypes: 'SupportDDLTypes',
      throttleIOPS: 'ThrottleIOPS',
      throttleRps: 'ThrottleRps',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enableIncrSyncStatistics: 'boolean',
      enableSequencingWithinTxn: 'boolean',
      incrSyncConcurrency: 'number',
      recordTypeWhiteList: { 'type': 'array', 'itemType': 'string' },
      startTimestamp: 'string',
      storeLogKeptHour: 'number',
      supportDDLTypes: { 'type': 'array', 'itemType': 'string' },
      throttleIOPS: 'number',
      throttleRps: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectRequestReverseIncrTransferConfig extends $tea.Model {
  enableIncrSyncStatistics?: boolean;
  enableSequencingWithinTxn?: boolean;
  incrSyncConcurrency?: number;
  recordTypeWhiteList?: string[];
  startTimestamp?: string;
  storeLogKeptHour?: number;
  supportDDLTypes?: string[];
  throttleIOPS?: number;
  throttleRps?: number;
  static names(): { [key: string]: string } {
    return {
      enableIncrSyncStatistics: 'EnableIncrSyncStatistics',
      enableSequencingWithinTxn: 'EnableSequencingWithinTxn',
      incrSyncConcurrency: 'IncrSyncConcurrency',
      recordTypeWhiteList: 'RecordTypeWhiteList',
      startTimestamp: 'StartTimestamp',
      storeLogKeptHour: 'StoreLogKeptHour',
      supportDDLTypes: 'SupportDDLTypes',
      throttleIOPS: 'ThrottleIOPS',
      throttleRps: 'ThrottleRps',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enableIncrSyncStatistics: 'boolean',
      enableSequencingWithinTxn: 'boolean',
      incrSyncConcurrency: 'number',
      recordTypeWhiteList: { 'type': 'array', 'itemType': 'string' },
      startTimestamp: 'string',
      storeLogKeptHour: 'number',
      supportDDLTypes: { 'type': 'array', 'itemType': 'string' },
      throttleIOPS: 'number',
      throttleRps: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectRequestStructTransferConfig extends $tea.Model {
  /**
   * @example
   * DO_NOTHING_IF_BYTE_USED
   */
  byteCharConvertStrategy?: string;
  /**
   * @example
   * true
   */
  deferIndexCreation?: boolean;
  static names(): { [key: string]: string } {
    return {
      byteCharConvertStrategy: 'ByteCharConvertStrategy',
      deferIndexCreation: 'DeferIndexCreation',
    };
  }

  static types(): { [key: string]: any } {
    return {
      byteCharConvertStrategy: 'string',
      deferIndexCreation: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectRequestTransferMappingDatabasesSpecificTablesAdbTableSchema extends $tea.Model {
  distributedKeys?: string[];
  /**
   * @example
   * 30
   */
  partitionLifeCycle?: string;
  /**
   * @example
   * PARTITION BY VALUE(\\"id\\")
   */
  partitionStatement?: string;
  primaryKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      distributedKeys: 'DistributedKeys',
      partitionLifeCycle: 'PartitionLifeCycle',
      partitionStatement: 'PartitionStatement',
      primaryKeys: 'PrimaryKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      distributedKeys: { 'type': 'array', 'itemType': 'string' },
      partitionLifeCycle: 'string',
      partitionStatement: 'string',
      primaryKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectRequestTransferMappingDatabasesSpecificTables extends $tea.Model {
  adbTableSchema?: CreateProjectRequestTransferMappingDatabasesSpecificTablesAdbTableSchema;
  filterColumns?: string[];
  /**
   * @example
   * e_4azdil4lu7***
   */
  id?: string;
  /**
   * @example
   * mapped_table
   */
  mappedName?: string;
  /**
   * @example
   * table_name
   */
  name?: string;
  shardColumns?: string[];
  /**
   * @example
   * id<5
   */
  whereClause?: string;
  static names(): { [key: string]: string } {
    return {
      adbTableSchema: 'AdbTableSchema',
      filterColumns: 'FilterColumns',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      shardColumns: 'ShardColumns',
      whereClause: 'WhereClause',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adbTableSchema: CreateProjectRequestTransferMappingDatabasesSpecificTablesAdbTableSchema,
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      mappedName: 'string',
      name: 'string',
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      whereClause: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectRequestTransferMappingDatabasesSpecificViewsAdbTableSchema extends $tea.Model {
  distributedKeys?: string[];
  /**
   * @example
   * 30
   */
  partitionLifeCycle?: string;
  /**
   * @example
   * PARTITION BY VALUE(\\"id\\")
   */
  partitionStatement?: string;
  primaryKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      distributedKeys: 'DistributedKeys',
      partitionLifeCycle: 'PartitionLifeCycle',
      partitionStatement: 'PartitionStatement',
      primaryKeys: 'PrimaryKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      distributedKeys: { 'type': 'array', 'itemType': 'string' },
      partitionLifeCycle: 'string',
      partitionStatement: 'string',
      primaryKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectRequestTransferMappingDatabasesSpecificViews extends $tea.Model {
  adbTableSchema?: CreateProjectRequestTransferMappingDatabasesSpecificViewsAdbTableSchema;
  filterColumns?: string[];
  /**
   * @example
   * e_3wsmjv49a***
   */
  id?: string;
  /**
   * @example
   * mapped_view
   */
  mappedName?: string;
  /**
   * @example
   * view_name
   */
  name?: string;
  shardColumns?: string[];
  /**
   * @example
   * id<5
   */
  whereClause?: string;
  static names(): { [key: string]: string } {
    return {
      adbTableSchema: 'AdbTableSchema',
      filterColumns: 'FilterColumns',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      shardColumns: 'ShardColumns',
      whereClause: 'WhereClause',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adbTableSchema: CreateProjectRequestTransferMappingDatabasesSpecificViewsAdbTableSchema,
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      mappedName: 'string',
      name: 'string',
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      whereClause: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectRequestTransferMappingDatabasesTablesAdbTableSchema extends $tea.Model {
  distributedKeys?: string[];
  /**
   * @example
   * 30
   */
  partitionLifeCycle?: string;
  /**
   * @example
   * PARTITION BY VALUE(\\"id\\")
   */
  partitionStatement?: string;
  primaryKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      distributedKeys: 'DistributedKeys',
      partitionLifeCycle: 'PartitionLifeCycle',
      partitionStatement: 'PartitionStatement',
      primaryKeys: 'PrimaryKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      distributedKeys: { 'type': 'array', 'itemType': 'string' },
      partitionLifeCycle: 'string',
      partitionStatement: 'string',
      primaryKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectRequestTransferMappingDatabasesTables extends $tea.Model {
  adbTableSchema?: CreateProjectRequestTransferMappingDatabasesTablesAdbTableSchema;
  filterColumns?: string[];
  /**
   * @example
   * e_4l085bu7***
   */
  id?: string;
  /**
   * @example
   * mapped_table
   */
  mappedName?: string;
  /**
   * @example
   * table_name
   */
  name?: string;
  shardColumns?: string[];
  /**
   * @example
   * id > 1
   */
  whereClause?: string;
  static names(): { [key: string]: string } {
    return {
      adbTableSchema: 'AdbTableSchema',
      filterColumns: 'FilterColumns',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      shardColumns: 'ShardColumns',
      whereClause: 'WhereClause',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adbTableSchema: CreateProjectRequestTransferMappingDatabasesTablesAdbTableSchema,
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      mappedName: 'string',
      name: 'string',
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      whereClause: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectRequestTransferMappingDatabasesViewsAdbTableSchema extends $tea.Model {
  distributedKeys?: string[];
  /**
   * @example
   * 30
   */
  partitionLifeCycle?: string;
  /**
   * @example
   * PARTITION BY VALUE(\\"id\\")
   */
  partitionStatement?: string;
  primaryKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      distributedKeys: 'DistributedKeys',
      partitionLifeCycle: 'PartitionLifeCycle',
      partitionStatement: 'PartitionStatement',
      primaryKeys: 'PrimaryKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      distributedKeys: { 'type': 'array', 'itemType': 'string' },
      partitionLifeCycle: 'string',
      partitionStatement: 'string',
      primaryKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectRequestTransferMappingDatabasesViews extends $tea.Model {
  adbTableSchema?: CreateProjectRequestTransferMappingDatabasesViewsAdbTableSchema;
  filterColumns?: string[];
  /**
   * @example
   * e_4himpq4z***
   */
  id?: string;
  /**
   * @example
   * mapped_view
   */
  mappedName?: string;
  /**
   * @example
   * view_name
   */
  name?: string;
  shardColumns?: string[];
  /**
   * @example
   * id>1
   */
  whereClause?: string;
  static names(): { [key: string]: string } {
    return {
      adbTableSchema: 'AdbTableSchema',
      filterColumns: 'FilterColumns',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      shardColumns: 'ShardColumns',
      whereClause: 'WhereClause',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adbTableSchema: CreateProjectRequestTransferMappingDatabasesViewsAdbTableSchema,
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      mappedName: 'string',
      name: 'string',
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      whereClause: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectRequestTransferMappingDatabases extends $tea.Model {
  /**
   * @example
   * cluster_name
   */
  clusterName?: string;
  /**
   * @example
   * gez3***
   */
  id?: string;
  /**
   * @example
   * mapped_db
   */
  mappedName?: string;
  /**
   * @example
   * db_name
   */
  name?: string;
  specificTables?: CreateProjectRequestTransferMappingDatabasesSpecificTables[];
  specificViews?: CreateProjectRequestTransferMappingDatabasesSpecificViews[];
  tables?: CreateProjectRequestTransferMappingDatabasesTables[];
  /**
   * @example
   * tenant_name
   */
  tenantName?: string;
  views?: CreateProjectRequestTransferMappingDatabasesViews[];
  static names(): { [key: string]: string } {
    return {
      clusterName: 'ClusterName',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      specificTables: 'SpecificTables',
      specificViews: 'SpecificViews',
      tables: 'Tables',
      tenantName: 'TenantName',
      views: 'Views',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterName: 'string',
      id: 'string',
      mappedName: 'string',
      name: 'string',
      specificTables: { 'type': 'array', 'itemType': CreateProjectRequestTransferMappingDatabasesSpecificTables },
      specificViews: { 'type': 'array', 'itemType': CreateProjectRequestTransferMappingDatabasesSpecificViews },
      tables: { 'type': 'array', 'itemType': CreateProjectRequestTransferMappingDatabasesTables },
      tenantName: 'string',
      views: { 'type': 'array', 'itemType': CreateProjectRequestTransferMappingDatabasesViews },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectRequestTransferMappingDatabasesBlackSpecificTablesAdbTableSchema extends $tea.Model {
  distributedKeys?: string[];
  /**
   * @example
   * 30
   */
  partitionLifeCycle?: string;
  /**
   * @example
   * PARTITION BY VALUE(\\"id\\")
   */
  partitionStatement?: string;
  primaryKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      distributedKeys: 'DistributedKeys',
      partitionLifeCycle: 'PartitionLifeCycle',
      partitionStatement: 'PartitionStatement',
      primaryKeys: 'PrimaryKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      distributedKeys: { 'type': 'array', 'itemType': 'string' },
      partitionLifeCycle: 'string',
      partitionStatement: 'string',
      primaryKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectRequestTransferMappingDatabasesBlackSpecificTables extends $tea.Model {
  adbTableSchema?: CreateProjectRequestTransferMappingDatabasesBlackSpecificTablesAdbTableSchema;
  filterColumns?: string[];
  /**
   * @example
   * e_4himpq4zf***
   */
  id?: string;
  /**
   * @example
   * mapped_table
   */
  mappedName?: string;
  /**
   * @example
   * table_name
   */
  name?: string;
  shardColumns?: string[];
  /**
   * @example
   * id<1
   */
  whereClause?: string;
  static names(): { [key: string]: string } {
    return {
      adbTableSchema: 'AdbTableSchema',
      filterColumns: 'FilterColumns',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      shardColumns: 'ShardColumns',
      whereClause: 'WhereClause',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adbTableSchema: CreateProjectRequestTransferMappingDatabasesBlackSpecificTablesAdbTableSchema,
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      mappedName: 'string',
      name: 'string',
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      whereClause: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectRequestTransferMappingDatabasesBlackSpecificViewsAdbTableSchema extends $tea.Model {
  distributedKeys?: string[];
  /**
   * @example
   * 30
   */
  partitionLifeCycle?: string;
  /**
   * @example
   * PARTITION BY VALUE(\\"id\\")
   */
  partitionStatement?: string;
  primaryKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      distributedKeys: 'DistributedKeys',
      partitionLifeCycle: 'PartitionLifeCycle',
      partitionStatement: 'PartitionStatement',
      primaryKeys: 'PrimaryKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      distributedKeys: { 'type': 'array', 'itemType': 'string' },
      partitionLifeCycle: 'string',
      partitionStatement: 'string',
      primaryKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectRequestTransferMappingDatabasesBlackSpecificViews extends $tea.Model {
  adbTableSchema?: CreateProjectRequestTransferMappingDatabasesBlackSpecificViewsAdbTableSchema;
  filterColumns?: string[];
  /**
   * @example
   * e_474hmh5iqo***
   */
  id?: string;
  /**
   * @example
   * mapped_table
   */
  mappedName?: string;
  /**
   * @example
   * table_name
   */
  name?: string;
  shardColumns?: string[];
  /**
   * @example
   * id<1
   */
  whereClause?: string;
  static names(): { [key: string]: string } {
    return {
      adbTableSchema: 'AdbTableSchema',
      filterColumns: 'FilterColumns',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      shardColumns: 'ShardColumns',
      whereClause: 'WhereClause',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adbTableSchema: CreateProjectRequestTransferMappingDatabasesBlackSpecificViewsAdbTableSchema,
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      mappedName: 'string',
      name: 'string',
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      whereClause: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectRequestTransferMappingDatabasesBlackTablesAdbTableSchema extends $tea.Model {
  distributedKeys?: string[];
  /**
   * @example
   * 30
   */
  partitionLifeCycle?: string;
  /**
   * @example
   * PARTITION BY VALUE(\\"id\\")
   */
  partitionStatement?: string;
  primaryKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      distributedKeys: 'DistributedKeys',
      partitionLifeCycle: 'PartitionLifeCycle',
      partitionStatement: 'PartitionStatement',
      primaryKeys: 'PrimaryKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      distributedKeys: { 'type': 'array', 'itemType': 'string' },
      partitionLifeCycle: 'string',
      partitionStatement: 'string',
      primaryKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectRequestTransferMappingDatabasesBlackTables extends $tea.Model {
  adbTableSchema?: CreateProjectRequestTransferMappingDatabasesBlackTablesAdbTableSchema;
  filterColumns?: string[];
  /**
   * @example
   * e_474hmh5iqo***
   */
  id?: string;
  /**
   * @example
   * mapped_table
   */
  mappedName?: string;
  /**
   * @example
   * table_name
   */
  name?: string;
  shardColumns?: string[];
  /**
   * @example
   * id<1
   */
  whereClause?: string;
  static names(): { [key: string]: string } {
    return {
      adbTableSchema: 'AdbTableSchema',
      filterColumns: 'FilterColumns',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      shardColumns: 'ShardColumns',
      whereClause: 'WhereClause',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adbTableSchema: CreateProjectRequestTransferMappingDatabasesBlackTablesAdbTableSchema,
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      mappedName: 'string',
      name: 'string',
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      whereClause: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectRequestTransferMappingDatabasesBlackViewsAdbTableSchema extends $tea.Model {
  distributedKeys?: string[];
  /**
   * @example
   * 30
   */
  partitionLifeCycle?: string;
  /**
   * @example
   * PARTITION BY VALUE(\\"id\\")
   */
  partitionStatement?: string;
  primaryKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      distributedKeys: 'DistributedKeys',
      partitionLifeCycle: 'PartitionLifeCycle',
      partitionStatement: 'PartitionStatement',
      primaryKeys: 'PrimaryKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      distributedKeys: { 'type': 'array', 'itemType': 'string' },
      partitionLifeCycle: 'string',
      partitionStatement: 'string',
      primaryKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectRequestTransferMappingDatabasesBlackViews extends $tea.Model {
  adbTableSchema?: CreateProjectRequestTransferMappingDatabasesBlackViewsAdbTableSchema;
  filterColumns?: string[];
  /**
   * @example
   * e_4azdil4lu7mo
   */
  id?: string;
  /**
   * @example
   * mapped_view
   */
  mappedName?: string;
  /**
   * @example
   * view_name
   */
  name?: string;
  shardColumns?: string[];
  /**
   * @example
   * id<5
   */
  whereClause?: string;
  static names(): { [key: string]: string } {
    return {
      adbTableSchema: 'AdbTableSchema',
      filterColumns: 'FilterColumns',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      shardColumns: 'ShardColumns',
      whereClause: 'WhereClause',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adbTableSchema: CreateProjectRequestTransferMappingDatabasesBlackViewsAdbTableSchema,
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      mappedName: 'string',
      name: 'string',
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      whereClause: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectRequestTransferMappingDatabasesBlack extends $tea.Model {
  /**
   * @example
   * cluster_name
   */
  clusterName?: string;
  /**
   * @example
   * e_3y6v5v1x94f4
   */
  id?: string;
  /**
   * @example
   * mapped_db
   */
  mappedName?: string;
  /**
   * @example
   * db_name
   */
  name?: string;
  specificTables?: CreateProjectRequestTransferMappingDatabasesBlackSpecificTables[];
  specificViews?: CreateProjectRequestTransferMappingDatabasesBlackSpecificViews[];
  tables?: CreateProjectRequestTransferMappingDatabasesBlackTables[];
  /**
   * @example
   * tenant_name
   */
  tenantName?: string;
  views?: CreateProjectRequestTransferMappingDatabasesBlackViews[];
  static names(): { [key: string]: string } {
    return {
      clusterName: 'ClusterName',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      specificTables: 'SpecificTables',
      specificViews: 'SpecificViews',
      tables: 'Tables',
      tenantName: 'TenantName',
      views: 'Views',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterName: 'string',
      id: 'string',
      mappedName: 'string',
      name: 'string',
      specificTables: { 'type': 'array', 'itemType': CreateProjectRequestTransferMappingDatabasesBlackSpecificTables },
      specificViews: { 'type': 'array', 'itemType': CreateProjectRequestTransferMappingDatabasesBlackSpecificViews },
      tables: { 'type': 'array', 'itemType': CreateProjectRequestTransferMappingDatabasesBlackTables },
      tenantName: 'string',
      views: { 'type': 'array', 'itemType': CreateProjectRequestTransferMappingDatabasesBlackViews },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectRequestTransferMapping extends $tea.Model {
  databases?: CreateProjectRequestTransferMappingDatabases[];
  databasesBlack?: CreateProjectRequestTransferMappingDatabasesBlack[];
  /**
   * @example
   * SPCEIFIC
   */
  mode?: string;
  tableAndViewBlackList?: string[];
  tableAndViewWhiteList?: string[];
  static names(): { [key: string]: string } {
    return {
      databases: 'Databases',
      databasesBlack: 'DatabasesBlack',
      mode: 'Mode',
      tableAndViewBlackList: 'TableAndViewBlackList',
      tableAndViewWhiteList: 'TableAndViewWhiteList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      databases: { 'type': 'array', 'itemType': CreateProjectRequestTransferMappingDatabases },
      databasesBlack: { 'type': 'array', 'itemType': CreateProjectRequestTransferMappingDatabasesBlack },
      mode: 'string',
      tableAndViewBlackList: { 'type': 'array', 'itemType': 'string' },
      tableAndViewWhiteList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectResponseBodyErrorDetail extends $tea.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * Contact the administrator.
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequestDatabasesSpecificTablesAdbTableSchema extends $tea.Model {
  distributedKeys?: string[];
  /**
   * @example
   * 30
   */
  partitionLifeCycle?: string;
  /**
   * @example
   * PARTITION BY VALUE(\\"id\\")
   */
  partitionStatement?: string;
  primaryKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      distributedKeys: 'DistributedKeys',
      partitionLifeCycle: 'PartitionLifeCycle',
      partitionStatement: 'PartitionStatement',
      primaryKeys: 'PrimaryKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      distributedKeys: { 'type': 'array', 'itemType': 'string' },
      partitionLifeCycle: 'string',
      partitionStatement: 'string',
      primaryKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequestDatabasesSpecificTables extends $tea.Model {
  adbTableSchema?: CreateProjectModifyRecordsRequestDatabasesSpecificTablesAdbTableSchema;
  filterColumns?: string[];
  /**
   * @example
   * table_id
   */
  id?: string;
  /**
   * @example
   * mapped_table
   */
  mappedName?: string;
  /**
   * @example
   * table_name
   */
  name?: string;
  shardColumns?: string[];
  /**
   * @example
   * id<1
   */
  whereClause?: string;
  static names(): { [key: string]: string } {
    return {
      adbTableSchema: 'AdbTableSchema',
      filterColumns: 'FilterColumns',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      shardColumns: 'ShardColumns',
      whereClause: 'WhereClause',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adbTableSchema: CreateProjectModifyRecordsRequestDatabasesSpecificTablesAdbTableSchema,
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      mappedName: 'string',
      name: 'string',
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      whereClause: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequestDatabasesSpecificViewsAdbTableSchema extends $tea.Model {
  distributedKeys?: string[];
  /**
   * @example
   * 30
   */
  partitionLifeCycle?: string;
  /**
   * @example
   * PARTITION BY VALUE(\\"id\\")
   */
  partitionStatement?: string;
  primaryKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      distributedKeys: 'DistributedKeys',
      partitionLifeCycle: 'PartitionLifeCycle',
      partitionStatement: 'PartitionStatement',
      primaryKeys: 'PrimaryKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      distributedKeys: { 'type': 'array', 'itemType': 'string' },
      partitionLifeCycle: 'string',
      partitionStatement: 'string',
      primaryKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequestDatabasesSpecificViews extends $tea.Model {
  adbTableSchema?: CreateProjectModifyRecordsRequestDatabasesSpecificViewsAdbTableSchema;
  filterColumns?: string[];
  /**
   * @example
   * view_id
   */
  id?: string;
  /**
   * @example
   * mapped_view
   */
  mappedName?: string;
  /**
   * @example
   * view_name
   */
  name?: string;
  shardColumns?: string[];
  /**
   * @example
   * id <1
   */
  whereClause?: string;
  static names(): { [key: string]: string } {
    return {
      adbTableSchema: 'AdbTableSchema',
      filterColumns: 'FilterColumns',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      shardColumns: 'ShardColumns',
      whereClause: 'WhereClause',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adbTableSchema: CreateProjectModifyRecordsRequestDatabasesSpecificViewsAdbTableSchema,
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      mappedName: 'string',
      name: 'string',
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      whereClause: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequestDatabasesTablesAdbTableSchema extends $tea.Model {
  distributedKeys?: string[];
  /**
   * @example
   * 30
   */
  partitionLifeCycle?: string;
  /**
   * @example
   * PARTITION BY VALUE(\\"id\\")
   */
  partitionStatement?: string;
  primaryKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      distributedKeys: 'DistributedKeys',
      partitionLifeCycle: 'PartitionLifeCycle',
      partitionStatement: 'PartitionStatement',
      primaryKeys: 'PrimaryKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      distributedKeys: { 'type': 'array', 'itemType': 'string' },
      partitionLifeCycle: 'string',
      partitionStatement: 'string',
      primaryKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequestDatabasesTables extends $tea.Model {
  adbTableSchema?: CreateProjectModifyRecordsRequestDatabasesTablesAdbTableSchema;
  filterColumns?: string[];
  /**
   * @example
   * table_id
   */
  id?: string;
  /**
   * @example
   * mapped_table
   */
  mappedName?: string;
  /**
   * @example
   * table_name
   */
  name?: string;
  shardColumns?: string[];
  /**
   * @example
   * id<1
   */
  whereClause?: string;
  static names(): { [key: string]: string } {
    return {
      adbTableSchema: 'AdbTableSchema',
      filterColumns: 'FilterColumns',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      shardColumns: 'ShardColumns',
      whereClause: 'WhereClause',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adbTableSchema: CreateProjectModifyRecordsRequestDatabasesTablesAdbTableSchema,
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      mappedName: 'string',
      name: 'string',
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      whereClause: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequestDatabasesViewsAdbTableSchema extends $tea.Model {
  distributedKeys?: string[];
  /**
   * @example
   * 30
   */
  partitionLifeCycle?: string;
  /**
   * @example
   * PARTITION BY VALUE(\\"id\\")
   */
  partitionStatement?: string;
  primaryKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      distributedKeys: 'DistributedKeys',
      partitionLifeCycle: 'PartitionLifeCycle',
      partitionStatement: 'PartitionStatement',
      primaryKeys: 'PrimaryKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      distributedKeys: { 'type': 'array', 'itemType': 'string' },
      partitionLifeCycle: 'string',
      partitionStatement: 'string',
      primaryKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequestDatabasesViews extends $tea.Model {
  adbTableSchema?: CreateProjectModifyRecordsRequestDatabasesViewsAdbTableSchema;
  filterColumns?: string[];
  /**
   * @example
   * view_id
   */
  id?: string;
  /**
   * @example
   * mapped_view
   */
  mappedName?: string;
  /**
   * @example
   * view_name
   */
  name?: string;
  shardColumns?: string[];
  /**
   * @example
   * id<1
   */
  whereClause?: string;
  static names(): { [key: string]: string } {
    return {
      adbTableSchema: 'AdbTableSchema',
      filterColumns: 'FilterColumns',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      shardColumns: 'ShardColumns',
      whereClause: 'WhereClause',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adbTableSchema: CreateProjectModifyRecordsRequestDatabasesViewsAdbTableSchema,
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      mappedName: 'string',
      name: 'string',
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      whereClause: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequestDatabases extends $tea.Model {
  /**
   * @example
   * db_id
   */
  id?: string;
  /**
   * @example
   * mapped_db
   */
  mappedName?: string;
  /**
   * @example
   * db_name
   */
  name?: string;
  specificTables?: CreateProjectModifyRecordsRequestDatabasesSpecificTables[];
  specificViews?: CreateProjectModifyRecordsRequestDatabasesSpecificViews[];
  tables?: CreateProjectModifyRecordsRequestDatabasesTables[];
  views?: CreateProjectModifyRecordsRequestDatabasesViews[];
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      specificTables: 'SpecificTables',
      specificViews: 'SpecificViews',
      tables: 'Tables',
      views: 'Views',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      mappedName: 'string',
      name: 'string',
      specificTables: { 'type': 'array', 'itemType': CreateProjectModifyRecordsRequestDatabasesSpecificTables },
      specificViews: { 'type': 'array', 'itemType': CreateProjectModifyRecordsRequestDatabasesSpecificViews },
      tables: { 'type': 'array', 'itemType': CreateProjectModifyRecordsRequestDatabasesTables },
      views: { 'type': 'array', 'itemType': CreateProjectModifyRecordsRequestDatabasesViews },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsResponseBodyErrorDetail extends $tea.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * Contact the administrator.
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRdsPostgreSQLDataSourceResponseBodyErrorDetail extends $tea.Model {
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * null
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSecurityIpGroupResponseBodySecurityIpGroup extends $tea.Model {
  /**
   * @remarks
   * ```
   * http(s)://[Endpoint]/?Action=CreateSecurityIpGroup
   * &InstanceId=ob317v4uif****
   * &SecurityIps=192.168.1.1,192.168.0.0.1/8
   * &SecurityIpGroupName=pay_online
   * &Common request parameters
   * ```
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * You can call this operation to create an IP address whitelist group.
   * 
   * @example
   * pay_online
   */
  securityIpGroupName?: string;
  /**
   * @example
   * 192.168.1.1,192.168.0.0.1/8
   */
  securityIps?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      securityIpGroupName: 'SecurityIpGroupName',
      securityIps: 'SecurityIps',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      securityIpGroupName: 'string',
      securityIps: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTenantSecurityIpGroupResponseBodySecurityIpGroup extends $tea.Model {
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The name of the whitelist group.
   * 
   * @example
   * paytest
   */
  securityIpGroupName?: string;
  /**
   * @remarks
   * The list of IP addresses in the IP address whitelist group.   
   * 
   * It is a string separated by commas, and each object is an IP address or CIDR block.
   * 
   * @example
   * 192.***.*.*
   */
  securityIps?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * @example
   * t4louaeei****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      securityIpGroupName: 'SecurityIpGroupName',
      securityIps: 'SecurityIps',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      securityIpGroupName: 'string',
      securityIps: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTenantUserResponseBodyTenantUserRoles extends $tea.Model {
  /**
   * @example
   * db_pay1
   */
  database?: string;
  /**
   * @example
   * ReadOnly
   */
  role?: string;
  static names(): { [key: string]: string } {
    return {
      database: 'Database',
      role: 'Role',
    };
  }

  static types(): { [key: string]: any } {
    return {
      database: 'string',
      role: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTenantUserResponseBodyTenantUser extends $tea.Model {
  roles?: CreateTenantUserResponseBodyTenantUserRoles[];
  /**
   * @example
   * pay_test
   */
  userName?: string;
  /**
   * @example
   * ONLINE
   */
  userStatus?: string;
  userType?: string;
  static names(): { [key: string]: string } {
    return {
      roles: 'Roles',
      userName: 'UserName',
      userStatus: 'UserStatus',
      userType: 'UserType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      roles: { 'type': 'array', 'itemType': CreateTenantUserResponseBodyTenantUserRoles },
      userName: 'string',
      userStatus: 'string',
      userType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDataSourceResponseBodyErrorDetail extends $tea.Model {
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * Contact the administrator.
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteInstancesResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The result of the dry-run request.
   * - If the DryRun parameter is set to true and the dry run succeeds, the DryRunResult parameter returns true. Otherwise, an error code is returned.
   * - If the DryRun parameter is set to false, no dry run is performed and the DryRunResult parameter returns false.
   * 
   * @example
   * false
   */
  dryRunResult?: boolean;
  static names(): { [key: string]: string } {
    return {
      dryRunResult: 'DryRunResult',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dryRunResult: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProjectResponseBodyErrorDetail extends $tea.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * Contact the administrator.
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSecurityIpGroupResponseBodySecurityIpGroup extends $tea.Model {
  /**
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @example
   * paytest
   */
  securityIpGroupName?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      securityIpGroupName: 'SecurityIpGroupName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      securityIpGroupName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTenantSecurityIpGroupResponseBodySecurityIpGroup extends $tea.Model {
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The name of the whitelist group.
   * 
   * @example
   * paytest
   */
  securityIpGroupName?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * @example
   * t4louaeei****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      securityIpGroupName: 'SecurityIpGroupName',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      securityIpGroupName: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAnomalySQLListResponseBodyAnomalySQLList extends $tea.Model {
  /**
   * @remarks
   * The average CPU time, in ms.
   * 
   * @example
   * 50.13
   */
  cpuTime?: number;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * database1
   */
  dbName?: string;
  /**
   * @remarks
   * The diagnosis information.
   * 
   * @example
   * Total number of executions = 80199, Average CPU time = 6.8 ms, Overall CPU utilization = 87%
   */
  diagnosis?: string;
  /**
   * @remarks
   * The diagnostic rule.
   * 
   * @example
   * Utilization above threshold
   */
  diagnosisRule?: string;
  /**
   * @remarks
   * The number of executions.
   * 
   * @example
   * 89043
   */
  executions?: number;
  /**
   * @remarks
   * The sequence number of the returned SQL statement.
   * 
   * @example
   * 1
   */
  key?: number;
  /**
   * @remarks
   * The request time, in ms.
   * 
   * @example
   * 50.00
   */
  requestTime?: number;
  /**
   * @remarks
   * The request time in UTC +0.
   * 
   * @example
   * 2022-01-11T07:08:00Z
   */
  requestTimeUTCString?: string;
  /**
   * @remarks
   * SQLID.
   * 
   * @example
   * 99E9D3BF****B486239E6C7BC79B****
   */
  SQLId?: string;
  /**
   * @remarks
   * The SQL text.
   * 
   * @example
   * SELECT  ****   FROM ****   WHERE **** = ? AND **** = ?   ORDER BY **** ASC
   */
  SQLText?: string;
  /**
   * @remarks
   * The suggestions.
   * 
   * @example
   * Check your business scenarios, data distribution changes, request surges, and execution plan changes.
   */
  suggestion?: string;
  /**
   * @remarks
   * The username.
   * 
   * @example
   * tester
   */
  userName?: string;
  static names(): { [key: string]: string } {
    return {
      cpuTime: 'CpuTime',
      dbName: 'DbName',
      diagnosis: 'Diagnosis',
      diagnosisRule: 'DiagnosisRule',
      executions: 'Executions',
      key: 'Key',
      requestTime: 'RequestTime',
      requestTimeUTCString: 'RequestTimeUTCString',
      SQLId: 'SQLId',
      SQLText: 'SQLText',
      suggestion: 'Suggestion',
      userName: 'UserName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cpuTime: 'number',
      dbName: 'string',
      diagnosis: 'string',
      diagnosisRule: 'string',
      executions: 'number',
      key: 'number',
      requestTime: 'number',
      requestTimeUTCString: 'string',
      SQLId: 'string',
      SQLText: 'string',
      suggestion: 'string',
      userName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAvailableCpuResourceResponseBodyData extends $tea.Model {
  /**
   * @example
   * UnitNum.RejectComment.Storage
   */
  comment?: string;
  /**
   * @example
   * 10
   */
  maxCpu?: number;
  /**
   * @example
   * 2
   */
  minCpu?: number;
  /**
   * @example
   * UnitNum.Change.Accept
   */
  reviewCode?: string;
  /**
   * @example
   * 2
   */
  unitNum?: number;
  static names(): { [key: string]: string } {
    return {
      comment: 'Comment',
      maxCpu: 'MaxCpu',
      minCpu: 'MinCpu',
      reviewCode: 'ReviewCode',
      unitNum: 'UnitNum',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comment: 'string',
      maxCpu: 'number',
      minCpu: 'number',
      reviewCode: 'string',
      unitNum: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAvailableMemResourceResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The maximum memory size for each resource unit, in GB.
   * 
   * @example
   * 10
   */
  maxMem?: number;
  /**
   * @remarks
   * The minimum memory size required for each resource unit, in GB.
   * 
   * @example
   * 5
   */
  minMem?: number;
  /**
   * @remarks
   * The maximum allowed memory usage, in GB.
   * 
   * @example
   * 10.0
   */
  safeMem?: string;
  /**
   * @remarks
   * The number of resource units in the tenant.
   * 
   * @example
   * 2
   */
  usedMem?: number;
  static names(): { [key: string]: string } {
    return {
      maxMem: 'MaxMem',
      minMem: 'MinMem',
      safeMem: 'SafeMem',
      usedMem: 'UsedMem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxMem: 'number',
      minMem: 'number',
      safeMem: 'string',
      usedMem: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAvailableSpecResponseBodyDataAvailableSpecificationsDiskSizeRange extends $tea.Model {
  /**
   * @example
   * 40000
   */
  max?: number;
  /**
   * @example
   * 1000
   */
  min?: number;
  /**
   * @example
   * 5
   */
  step?: number;
  static names(): { [key: string]: string } {
    return {
      max: 'Max',
      min: 'Min',
      step: 'Step',
    };
  }

  static types(): { [key: string]: any } {
    return {
      max: 'number',
      min: 'number',
      step: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAvailableSpecResponseBodyDataAvailableSpecificationsLogDiskSizeRange extends $tea.Model {
  /**
   * @example
   * 4000
   */
  max?: number;
  /**
   * @example
   * 100
   */
  min?: number;
  /**
   * @example
   * 5
   */
  step?: number;
  static names(): { [key: string]: string } {
    return {
      max: 'Max',
      min: 'Min',
      step: 'Step',
    };
  }

  static types(): { [key: string]: any } {
    return {
      max: 'number',
      min: 'number',
      step: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAvailableSpecResponseBodyDataAvailableSpecifications extends $tea.Model {
  diskSizeRange?: DescribeAvailableSpecResponseBodyDataAvailableSpecificationsDiskSizeRange;
  diskTypes?: string[];
  /**
   * @example
   * 4C16GB
   */
  instanceClass?: string;
  logDiskSizeRange?: DescribeAvailableSpecResponseBodyDataAvailableSpecificationsLogDiskSizeRange;
  nodeNum?: number[];
  /**
   * @example
   * oceanbase.cluster.cd8.xlarge
   */
  spec?: string;
  static names(): { [key: string]: string } {
    return {
      diskSizeRange: 'DiskSizeRange',
      diskTypes: 'DiskTypes',
      instanceClass: 'InstanceClass',
      logDiskSizeRange: 'LogDiskSizeRange',
      nodeNum: 'NodeNum',
      spec: 'Spec',
    };
  }

  static types(): { [key: string]: any } {
    return {
      diskSizeRange: DescribeAvailableSpecResponseBodyDataAvailableSpecificationsDiskSizeRange,
      diskTypes: { 'type': 'array', 'itemType': 'string' },
      instanceClass: 'string',
      logDiskSizeRange: DescribeAvailableSpecResponseBodyDataAvailableSpecificationsLogDiskSizeRange,
      nodeNum: { 'type': 'array', 'itemType': 'number' },
      spec: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAvailableSpecResponseBodyData extends $tea.Model {
  availableSpecifications?: DescribeAvailableSpecResponseBodyDataAvailableSpecifications[];
  static names(): { [key: string]: string } {
    return {
      availableSpecifications: 'AvailableSpecifications',
    };
  }

  static types(): { [key: string]: any } {
    return {
      availableSpecifications: { 'type': 'array', 'itemType': DescribeAvailableSpecResponseBodyDataAvailableSpecifications },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAvailableZoneResponseBodyDataAvailableZonesSupportSpecificationsDiskSizeRange extends $tea.Model {
  /**
   * @example
   * 40000
   */
  max?: number;
  /**
   * @example
   * 1000
   */
  min?: number;
  /**
   * @example
   * 5
   */
  step?: number;
  static names(): { [key: string]: string } {
    return {
      max: 'Max',
      min: 'Min',
      step: 'Step',
    };
  }

  static types(): { [key: string]: any } {
    return {
      max: 'number',
      min: 'number',
      step: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAvailableZoneResponseBodyDataAvailableZonesSupportSpecificationsSupportEngineVersions extends $tea.Model {
  /**
   * @example
   * 3.2.4.4
   */
  obVersion?: string;
  /**
   * @example
   * true
   */
  supportIsolationOptimization?: boolean;
  supportReplicaModes?: string[];
  static names(): { [key: string]: string } {
    return {
      obVersion: 'ObVersion',
      supportIsolationOptimization: 'SupportIsolationOptimization',
      supportReplicaModes: 'SupportReplicaModes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      obVersion: 'string',
      supportIsolationOptimization: 'boolean',
      supportReplicaModes: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAvailableZoneResponseBodyDataAvailableZonesSupportSpecifications extends $tea.Model {
  diskSizeRange?: DescribeAvailableZoneResponseBodyDataAvailableZonesSupportSpecificationsDiskSizeRange;
  diskTypes?: string[];
  /**
   * @example
   * 4C16GB
   */
  instanceClass?: string;
  /**
   * @example
   * oceanbase.cluster.cd8.xlarge
   */
  spec?: string;
  supportEngineVersions?: DescribeAvailableZoneResponseBodyDataAvailableZonesSupportSpecificationsSupportEngineVersions[];
  static names(): { [key: string]: string } {
    return {
      diskSizeRange: 'DiskSizeRange',
      diskTypes: 'DiskTypes',
      instanceClass: 'InstanceClass',
      spec: 'Spec',
      supportEngineVersions: 'SupportEngineVersions',
    };
  }

  static types(): { [key: string]: any } {
    return {
      diskSizeRange: DescribeAvailableZoneResponseBodyDataAvailableZonesSupportSpecificationsDiskSizeRange,
      diskTypes: { 'type': 'array', 'itemType': 'string' },
      instanceClass: 'string',
      spec: 'string',
      supportEngineVersions: { 'type': 'array', 'itemType': DescribeAvailableZoneResponseBodyDataAvailableZonesSupportSpecificationsSupportEngineVersions },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAvailableZoneResponseBodyDataAvailableZones extends $tea.Model {
  /**
   * @example
   * PUBLIC
   */
  channel?: string;
  /**
   * @example
   * x86
   */
  cpuArch?: string;
  /**
   * @example
   * multiple
   */
  deployType?: string;
  /**
   * @example
   * cluster
   */
  instanceType?: string;
  /**
   * @example
   * cn-hangzhou
   */
  region?: string;
  /**
   * @example
   * normal
   */
  series?: string;
  supportSpecifications?: DescribeAvailableZoneResponseBodyDataAvailableZonesSupportSpecifications[];
  /**
   * @example
   * cn-hangzhou-h,cn-hangzhou-i,cn-hangzhou-j
   */
  zones?: string;
  static names(): { [key: string]: string } {
    return {
      channel: 'Channel',
      cpuArch: 'CpuArch',
      deployType: 'DeployType',
      instanceType: 'InstanceType',
      region: 'Region',
      series: 'Series',
      supportSpecifications: 'SupportSpecifications',
      zones: 'Zones',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channel: 'string',
      cpuArch: 'string',
      deployType: 'string',
      instanceType: 'string',
      region: 'string',
      series: 'string',
      supportSpecifications: { 'type': 'array', 'itemType': DescribeAvailableZoneResponseBodyDataAvailableZonesSupportSpecifications },
      zones: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAvailableZoneResponseBodyData extends $tea.Model {
  availableZones?: DescribeAvailableZoneResponseBodyDataAvailableZones[];
  static names(): { [key: string]: string } {
    return {
      availableZones: 'AvailableZones',
    };
  }

  static types(): { [key: string]: any } {
    return {
      availableZones: { 'type': 'array', 'itemType': DescribeAvailableZoneResponseBodyDataAvailableZones },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackupSetDownloadLinkResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The restorable time of the backup set.
   * 
   * @example
   * yyyy-MM-dd HH:mm:ss
   */
  backupRestorableTime?: string;
  /**
   * @remarks
   * The ID of the target backup set.
   * 
   * @example
   * bak-4n****gacpa8
   */
  backupSetId?: string;
  /**
   * @remarks
   * The time when the download task corresponding to the target backup set was created.
   * 
   * @example
   * 2020-05-22T17:04:18
   */
  downloadTaskCreateTime?: string;
  /**
   * @remarks
   * The ID of the download task corresponding to the target backup set.
   * 
   * @example
   * 1000002
   */
  downloadTaskId?: number;
  /**
   * @remarks
   * The status of the download task corresponding to the target backup set.
   * 
   * @example
   * RUNNING
   */
  downloadTaskStatus?: string;
  /**
   * @remarks
   * The internal URL.
   * 
   * @example
   * http://bucket.oss-region-internal.aliyuncs.com/xxxxx
   */
  internalUrl?: string;
  /**
   * @remarks
   * The validity period of the URL, in seconds.
   * 
   * @example
   * 3600
   */
  urlAliveTime?: number;
  /**
   * @remarks
   * The expiration time of the URL.
   * 
   * @example
   * 2024-01-04 17:39:49
   */
  urlExpiredTime?: string;
  static names(): { [key: string]: string } {
    return {
      backupRestorableTime: 'BackupRestorableTime',
      backupSetId: 'BackupSetId',
      downloadTaskCreateTime: 'DownloadTaskCreateTime',
      downloadTaskId: 'DownloadTaskId',
      downloadTaskStatus: 'DownloadTaskStatus',
      internalUrl: 'InternalUrl',
      urlAliveTime: 'UrlAliveTime',
      urlExpiredTime: 'UrlExpiredTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      backupRestorableTime: 'string',
      backupSetId: 'string',
      downloadTaskCreateTime: 'string',
      downloadTaskId: 'number',
      downloadTaskStatus: 'string',
      internalUrl: 'string',
      urlAliveTime: 'number',
      urlExpiredTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCharsetResponseBodyCharset extends $tea.Model {
  /**
   * @remarks
   * DescribeCharset
   * 
   * @example
   * utf8
   */
  charset?: string;
  collations?: string[];
  static names(): { [key: string]: string } {
    return {
      charset: 'Charset',
      collations: 'Collations',
    };
  }

  static types(): { [key: string]: any } {
    return {
      charset: 'string',
      collations: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDataBackupSetResponseBodyDataBackupObjectsDatabaseTablesList extends $tea.Model {
  /**
   * @example
   * sms_pre
   */
  database?: string;
  tables?: string[];
  static names(): { [key: string]: string } {
    return {
      database: 'Database',
      tables: 'Tables',
    };
  }

  static types(): { [key: string]: any } {
    return {
      database: 'string',
      tables: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDataBackupSetResponseBodyDataBackupObjects extends $tea.Model {
  /**
   * @example
   * test-****way
   */
  clusterName?: string;
  databaseTablesList?: DescribeDataBackupSetResponseBodyDataBackupObjectsDatabaseTablesList[];
  /**
   * @example
   * ob2mr3oae0****
   */
  tenantName?: string;
  static names(): { [key: string]: string } {
    return {
      clusterName: 'ClusterName',
      databaseTablesList: 'DatabaseTablesList',
      tenantName: 'TenantName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterName: 'string',
      databaseTablesList: { 'type': 'array', 'itemType': DescribeDataBackupSetResponseBodyDataBackupObjectsDatabaseTablesList },
      tenantName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDataBackupSetResponseBodyDataBackupResultsTableBackupResults extends $tea.Model {
  /**
   * @example
   * order_ce****_online
   */
  database?: string;
  /**
   * @example
   * Create tag success
   */
  message?: string;
  /**
   * @example
   * RUNNING
   */
  status?: string;
  /**
   * @example
   * tr_sale_order_****
   */
  table?: string;
  static names(): { [key: string]: string } {
    return {
      database: 'Database',
      message: 'Message',
      status: 'Status',
      table: 'Table',
    };
  }

  static types(): { [key: string]: any } {
    return {
      database: 'string',
      message: 'string',
      status: 'string',
      table: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDataBackupSetResponseBodyDataBackupResults extends $tea.Model {
  /**
   * @example
   * container-opa-****-02
   */
  clusterName?: string;
  tableBackupResults?: DescribeDataBackupSetResponseBodyDataBackupResultsTableBackupResults[];
  /**
   * @example
   * ob2mr3oae0****
   */
  tenantName?: string;
  static names(): { [key: string]: string } {
    return {
      clusterName: 'ClusterName',
      tableBackupResults: 'TableBackupResults',
      tenantName: 'TenantName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterName: 'string',
      tableBackupResults: { 'type': 'array', 'itemType': DescribeDataBackupSetResponseBodyDataBackupResultsTableBackupResults },
      tenantName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDataBackupSetResponseBodyData extends $tea.Model {
  /**
   * @example
   * cluster
   */
  backupObjectType?: string;
  backupObjects?: DescribeDataBackupSetResponseBodyDataBackupObjects[];
  backupResults?: DescribeDataBackupSetResponseBodyDataBackupResults[];
  /**
   * @example
   * 2023-05-15T07:11:08Z
   */
  checkpoint?: string;
  /**
   * @example
   * 31457280
   */
  dataSize?: number;
  /**
   * @example
   * 1678847020352
   */
  dataVersion?: number;
  /**
   * @example
   * 100***012
   */
  downloadTaskId?: number;
  /**
   * @example
   * not_exist
   */
  downloadTaskStatus?: string;
  /**
   * @example
   * 2023-04-13T03:38:10Z
   */
  endTime?: string;
  /**
   * @example
   * logical
   */
  method?: string;
  /**
   * @example
   * automated
   */
  policy?: string;
  /**
   * @example
   * 52
   */
  progress?: string;
  /**
   * @example
   * imm-test-set-cb****ee-b7d7-11ed-956f-****3e10bd70
   */
  setId?: number;
  /**
   * @example
   * 2020-05-22T17:04:18
   */
  startTime?: string;
  /**
   * @example
   * RUNNING
   */
  status?: string;
  /**
   * @example
   * standard
   */
  storageClass?: string;
  /**
   * @example
   * manual
   */
  type?: string;
  /**
   * @example
   * VALID
   */
  validity?: string;
  static names(): { [key: string]: string } {
    return {
      backupObjectType: 'BackupObjectType',
      backupObjects: 'BackupObjects',
      backupResults: 'BackupResults',
      checkpoint: 'Checkpoint',
      dataSize: 'DataSize',
      dataVersion: 'DataVersion',
      downloadTaskId: 'DownloadTaskId',
      downloadTaskStatus: 'DownloadTaskStatus',
      endTime: 'EndTime',
      method: 'Method',
      policy: 'Policy',
      progress: 'Progress',
      setId: 'SetId',
      startTime: 'StartTime',
      status: 'Status',
      storageClass: 'StorageClass',
      type: 'Type',
      validity: 'Validity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      backupObjectType: 'string',
      backupObjects: { 'type': 'array', 'itemType': DescribeDataBackupSetResponseBodyDataBackupObjects },
      backupResults: { 'type': 'array', 'itemType': DescribeDataBackupSetResponseBodyDataBackupResults },
      checkpoint: 'string',
      dataSize: 'number',
      dataVersion: 'number',
      downloadTaskId: 'number',
      downloadTaskStatus: 'string',
      endTime: 'string',
      method: 'string',
      policy: 'string',
      progress: 'string',
      setId: 'number',
      startTime: 'string',
      status: 'string',
      storageClass: 'string',
      type: 'string',
      validity: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDatabasesResponseBodyDatabasesTables extends $tea.Model {
  /**
   * @remarks
   * The name of the database table.
   * 
   * @example
   * testTables
   */
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDatabasesResponseBodyDatabasesUsers extends $tea.Model {
  /**
   * @remarks
   * If you have granted custom privileges on the database, this parameter indicates the custom privileges, separated by commas (,). Otherwise, no data is returned for this parameter.
   * 
   * @example
   * select,delete,update
   */
  privileges?: string;
  /**
   * @remarks
   * The role of the account.    
   * In MySQL mode, a role is a database-level role. Valid values:  
   * - ReadWrite: a role that has the read and write privileges, namely ALL PRIVILEGES.  
   * - ReadOnly: a role that has only the read-only privilege SELECT.   
   * - DDL: a role that has the DDL privileges such as CREATE, DROP, ALTER, SHOW VIEW, and CREATE VIEW.   
   * - DML: a role that has the DML privileges such as SELECT, INSERT, UPDATE, DELETE, and SHOW VIEW.
   * 
   * @example
   * ReadOnly
   */
  role?: string;
  /**
   * @remarks
   * The name of the account.
   * 
   * @example
   * user_pay_ro
   */
  userName?: string;
  /**
   * @remarks
   * The type of the account. Valid values:  
   * - Admin: the super administrator account. 
   * - Normal: a general account.
   * 
   * @example
   * Normal
   */
  userType?: string;
  static names(): { [key: string]: string } {
    return {
      privileges: 'Privileges',
      role: 'Role',
      userName: 'UserName',
      userType: 'UserType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      privileges: 'string',
      role: 'string',
      userName: 'string',
      userType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDatabasesResponseBodyDatabases extends $tea.Model {
  /**
   * @remarks
   * The collation.
   * 
   * @example
   * utf8mb4_general_ci
   */
  collation?: string;
  /**
   * @remarks
   * The time when the database was created.
   * 
   * @example
   * 2022-02-21 15:41:06
   */
  createTime?: string;
  /**
   * @remarks
   * The actual data size, in GB. 
   * >Notice: This parameter is no longer used in later versions. RequiredSize is used instead.
   * 
   * @example
   * 5.67 GB
   */
  dataSize?: number;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * sms_pre
   */
  databaseName?: string;
  /**
   * @remarks
   * The database type.
   * 
   * @example
   * mysql
   */
  dbType?: string;
  /**
   * @remarks
   * The description of the database.
   * 
   * @example
   * test db
   */
  description?: string;
  /**
   * @remarks
   * The encoding standard of the database. Encoding standards such as utf8mb4 and GBK are supported.
   * 
   * @example
   * utf8mb4
   */
  encoding?: string;
  /**
   * @remarks
   * The ID of the cluster to which the tenant belongs.
   * 
   * @example
   * obsdh2f****
   */
  instanceId?: string;
  /**
   * @remarks
   * The storage space required, in GB.
   * 
   * @example
   * 5.67 GB
   */
  requiredSize?: number;
  /**
   * @remarks
   * The status of the database. Valid values:    
   * - ONLINE: The database is running.  
   * - DELETING: The database is being deleted.
   * 
   * @example
   * ONLINE
   */
  status?: string;
  /**
   * @remarks
   * The list of database tables.
   */
  tables?: DescribeDatabasesResponseBodyDatabasesTables[];
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * @example
   * t33h8y08k****
   */
  tenantId?: string;
  /**
   * @remarks
   * The name of the tenant.
   * 
   * @example
   * tenantABC
   */
  tenantName?: string;
  /**
   * @remarks
   * The list of accounts that are granted privileges on this database.
   */
  users?: DescribeDatabasesResponseBodyDatabasesUsers[];
  static names(): { [key: string]: string } {
    return {
      collation: 'Collation',
      createTime: 'CreateTime',
      dataSize: 'DataSize',
      databaseName: 'DatabaseName',
      dbType: 'DbType',
      description: 'Description',
      encoding: 'Encoding',
      instanceId: 'InstanceId',
      requiredSize: 'RequiredSize',
      status: 'Status',
      tables: 'Tables',
      tenantId: 'TenantId',
      tenantName: 'TenantName',
      users: 'Users',
    };
  }

  static types(): { [key: string]: any } {
    return {
      collation: 'string',
      createTime: 'string',
      dataSize: 'number',
      databaseName: 'string',
      dbType: 'string',
      description: 'string',
      encoding: 'string',
      instanceId: 'string',
      requiredSize: 'number',
      status: 'string',
      tables: { 'type': 'array', 'itemType': DescribeDatabasesResponseBodyDatabasesTables },
      tenantId: 'string',
      tenantName: 'string',
      users: { 'type': 'array', 'itemType': DescribeDatabasesResponseBodyDatabasesUsers },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceResponseBodyInstanceDataDiskAutoScaleConfig extends $tea.Model {
  autoScale?: boolean;
  maxDiskSize?: number;
  scaleStepInMerge?: number;
  scaleStepInNormal?: number;
  upperMergeThreshold?: number;
  upperScaleStep?: string;
  upperScaleStrategy?: string;
  upperThreshold?: number;
  upperbound?: number;
  static names(): { [key: string]: string } {
    return {
      autoScale: 'AutoScale',
      maxDiskSize: 'MaxDiskSize',
      scaleStepInMerge: 'ScaleStepInMerge',
      scaleStepInNormal: 'ScaleStepInNormal',
      upperMergeThreshold: 'UpperMergeThreshold',
      upperScaleStep: 'UpperScaleStep',
      upperScaleStrategy: 'UpperScaleStrategy',
      upperThreshold: 'UpperThreshold',
      upperbound: 'Upperbound',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoScale: 'boolean',
      maxDiskSize: 'number',
      scaleStepInMerge: 'number',
      scaleStepInNormal: 'number',
      upperMergeThreshold: 'number',
      upperScaleStep: 'string',
      upperScaleStrategy: 'string',
      upperThreshold: 'number',
      upperbound: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceResponseBodyInstanceReadOnlyResourceCapacityUnit extends $tea.Model {
  maxCapacityUnit?: number;
  minCapacityUnit?: number;
  usedCapacityUnit?: string;
  static names(): { [key: string]: string } {
    return {
      maxCapacityUnit: 'MaxCapacityUnit',
      minCapacityUnit: 'MinCapacityUnit',
      usedCapacityUnit: 'UsedCapacityUnit',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxCapacityUnit: 'number',
      minCapacityUnit: 'number',
      usedCapacityUnit: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceResponseBodyInstanceReadOnlyResourceCpu extends $tea.Model {
  /**
   * @example
   * 14
   */
  originalTotalCpu?: number;
  /**
   * @example
   * 14
   */
  totalCpu?: number;
  /**
   * @example
   * 10
   */
  unitCpu?: number;
  /**
   * @example
   * 10
   */
  usedCpu?: number;
  static names(): { [key: string]: string } {
    return {
      originalTotalCpu: 'OriginalTotalCpu',
      totalCpu: 'TotalCpu',
      unitCpu: 'UnitCpu',
      usedCpu: 'UsedCpu',
    };
  }

  static types(): { [key: string]: any } {
    return {
      originalTotalCpu: 'number',
      totalCpu: 'number',
      unitCpu: 'number',
      usedCpu: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceResponseBodyInstanceReadOnlyResourceDiskSize extends $tea.Model {
  dataUsedSize?: number;
  maxDiskSize?: number;
  maxDiskUsedObServer?: string[];
  maxDiskUsedPercent?: number;
  /**
   * @example
   * 200
   */
  originalTotalDiskSize?: number;
  /**
   * @example
   * 200
   */
  totalDiskSize?: number;
  /**
   * @example
   * 200
   */
  unitDiskSize?: number;
  /**
   * @example
   * 100
   */
  usedDiskSize?: number;
  static names(): { [key: string]: string } {
    return {
      dataUsedSize: 'DataUsedSize',
      maxDiskSize: 'MaxDiskSize',
      maxDiskUsedObServer: 'MaxDiskUsedObServer',
      maxDiskUsedPercent: 'MaxDiskUsedPercent',
      originalTotalDiskSize: 'OriginalTotalDiskSize',
      totalDiskSize: 'TotalDiskSize',
      unitDiskSize: 'UnitDiskSize',
      usedDiskSize: 'UsedDiskSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataUsedSize: 'number',
      maxDiskSize: 'number',
      maxDiskUsedObServer: { 'type': 'array', 'itemType': 'string' },
      maxDiskUsedPercent: 'number',
      originalTotalDiskSize: 'number',
      totalDiskSize: 'number',
      unitDiskSize: 'number',
      usedDiskSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceResponseBodyInstanceReadOnlyResourceLogDiskSize extends $tea.Model {
  logAssignedSize?: string;
  maxLogAssignedObServer?: string[];
  maxLogAssignedPercent?: string;
  /**
   * @example
   * 400
   */
  totalDiskSize?: number;
  /**
   * @example
   * 200
   */
  unitDiskSize?: number;
  static names(): { [key: string]: string } {
    return {
      logAssignedSize: 'LogAssignedSize',
      maxLogAssignedObServer: 'MaxLogAssignedObServer',
      maxLogAssignedPercent: 'MaxLogAssignedPercent',
      totalDiskSize: 'TotalDiskSize',
      unitDiskSize: 'UnitDiskSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logAssignedSize: 'string',
      maxLogAssignedObServer: { 'type': 'array', 'itemType': 'string' },
      maxLogAssignedPercent: 'string',
      totalDiskSize: 'number',
      unitDiskSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceResponseBodyInstanceReadOnlyResourceMemory extends $tea.Model {
  /**
   * @example
   * 72
   */
  originalTotalMemory?: number;
  /**
   * @example
   * 70
   */
  totalMemory?: number;
  /**
   * @example
   * 10
   */
  unitMemory?: number;
  /**
   * @example
   * 10
   */
  usedMemory?: number;
  static names(): { [key: string]: string } {
    return {
      originalTotalMemory: 'OriginalTotalMemory',
      totalMemory: 'TotalMemory',
      unitMemory: 'UnitMemory',
      usedMemory: 'UsedMemory',
    };
  }

  static types(): { [key: string]: any } {
    return {
      originalTotalMemory: 'number',
      totalMemory: 'number',
      unitMemory: 'number',
      usedMemory: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceResponseBodyInstanceReadOnlyResource extends $tea.Model {
  capacityUnit?: DescribeInstanceResponseBodyInstanceReadOnlyResourceCapacityUnit;
  cpu?: DescribeInstanceResponseBodyInstanceReadOnlyResourceCpu;
  diskSize?: DescribeInstanceResponseBodyInstanceReadOnlyResourceDiskSize;
  logDiskSize?: DescribeInstanceResponseBodyInstanceReadOnlyResourceLogDiskSize;
  memory?: DescribeInstanceResponseBodyInstanceReadOnlyResourceMemory;
  /**
   * @example
   * 1
   */
  unitCount?: number;
  static names(): { [key: string]: string } {
    return {
      capacityUnit: 'CapacityUnit',
      cpu: 'Cpu',
      diskSize: 'DiskSize',
      logDiskSize: 'LogDiskSize',
      memory: 'Memory',
      unitCount: 'UnitCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      capacityUnit: DescribeInstanceResponseBodyInstanceReadOnlyResourceCapacityUnit,
      cpu: DescribeInstanceResponseBodyInstanceReadOnlyResourceCpu,
      diskSize: DescribeInstanceResponseBodyInstanceReadOnlyResourceDiskSize,
      logDiskSize: DescribeInstanceResponseBodyInstanceReadOnlyResourceLogDiskSize,
      memory: DescribeInstanceResponseBodyInstanceReadOnlyResourceMemory,
      unitCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceResponseBodyInstanceResourceCapacityUnit extends $tea.Model {
  maxCapacityUnit?: number;
  minCapacityUnit?: number;
  usedCapacityUnit?: string;
  static names(): { [key: string]: string } {
    return {
      maxCapacityUnit: 'MaxCapacityUnit',
      minCapacityUnit: 'MinCapacityUnit',
      usedCapacityUnit: 'UsedCapacityUnit',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxCapacityUnit: 'number',
      minCapacityUnit: 'number',
      usedCapacityUnit: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceResponseBodyInstanceResourceCpu extends $tea.Model {
  /**
   * @example
   * 14
   */
  originalTotalCpu?: number;
  /**
   * @remarks
   * The series of the OceanBase cluster. Valid values:   
   * - NORMAL: the high availability edition.   
   * - BASIC: the basic edition.
   * 
   * @example
   * 14
   */
  totalCpu?: number;
  /**
   * @remarks
   * The type of the storage disk where the cluster is deployed. 
   * 
   * The default value is cloud_essd_pl1, which indicates an ESSD cloud disk.
   * 
   * @example
   * 10
   */
  unitCpu?: number;
  /**
   * @remarks
   * Indicates whether automatic upgrade of the OBServer version is enabled.
   * 
   * @example
   * 10
   */
  usedCpu?: number;
  static names(): { [key: string]: string } {
    return {
      originalTotalCpu: 'OriginalTotalCpu',
      totalCpu: 'TotalCpu',
      unitCpu: 'UnitCpu',
      usedCpu: 'UsedCpu',
    };
  }

  static types(): { [key: string]: any } {
    return {
      originalTotalCpu: 'number',
      totalCpu: 'number',
      unitCpu: 'number',
      usedCpu: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceResponseBodyInstanceResourceDiskSize extends $tea.Model {
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * @example
   * 200
   */
  dataUsedSize?: number;
  maxDiskSize?: number;
  /**
   * @remarks
   * The time in UTC when the cluster expires.
   */
  maxDiskUsedObServer?: string[];
  /**
   * @remarks
   * The maximum disk usage, in percentage.
   * 
   * @example
   * 0.14
   */
  maxDiskUsedPercent?: number;
  /**
   * @example
   * 200
   */
  originalTotalDiskSize?: number;
  /**
   * @remarks
   * The data replica distribution mode of the cluster. Valid values: 
   * - n: indicates the single-IDC mode. 
   * - n-n: indicates the dual-IDC mode. 
   * - n-n-n: indicates the multi-IDC mode. 
   * 
   * > <br>The integer n represents the number of OBServer nodes in each IDC.
   * 
   * @example
   * 200
   */
  totalDiskSize?: number;
  /**
   * @remarks
   * The list of zones.
   * 
   * @example
   * 200
   */
  unitDiskSize?: number;
  /**
   * @remarks
   * The specifications of the cluster.  You can specify one of the following four plans:    
   * - 8C32G: indicates 8 CPU cores and 32 GB of memory. 
   * - 14C70G: indicates 14 CPU cores and 70 GB of memory. 
   * - 30C180G: indicates 30 CPU cores and 180 GB of memory. 
   * - 62C400G: indicates 62 CPU cores and 400 GB of memory.
   * 
   * @example
   * 100
   */
  usedDiskSize?: number;
  static names(): { [key: string]: string } {
    return {
      dataUsedSize: 'DataUsedSize',
      maxDiskSize: 'MaxDiskSize',
      maxDiskUsedObServer: 'MaxDiskUsedObServer',
      maxDiskUsedPercent: 'MaxDiskUsedPercent',
      originalTotalDiskSize: 'OriginalTotalDiskSize',
      totalDiskSize: 'TotalDiskSize',
      unitDiskSize: 'UnitDiskSize',
      usedDiskSize: 'UsedDiskSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataUsedSize: 'number',
      maxDiskSize: 'number',
      maxDiskUsedObServer: { 'type': 'array', 'itemType': 'string' },
      maxDiskUsedPercent: 'number',
      originalTotalDiskSize: 'number',
      totalDiskSize: 'number',
      unitDiskSize: 'number',
      usedDiskSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceResponseBodyInstanceResourceLogDiskSize extends $tea.Model {
  logAssignedSize?: string;
  maxLogAssignedObServer?: string[];
  maxLogAssignedPercent?: string;
  originalTotalDiskSize?: number;
  /**
   * @remarks
   * The ID of the region.
   * 
   * @example
   * 400
   */
  totalDiskSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 200
   */
  unitDiskSize?: number;
  static names(): { [key: string]: string } {
    return {
      logAssignedSize: 'LogAssignedSize',
      maxLogAssignedObServer: 'MaxLogAssignedObServer',
      maxLogAssignedPercent: 'MaxLogAssignedPercent',
      originalTotalDiskSize: 'OriginalTotalDiskSize',
      totalDiskSize: 'TotalDiskSize',
      unitDiskSize: 'UnitDiskSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logAssignedSize: 'string',
      maxLogAssignedObServer: { 'type': 'array', 'itemType': 'string' },
      maxLogAssignedPercent: 'string',
      originalTotalDiskSize: 'number',
      totalDiskSize: 'number',
      unitDiskSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceResponseBodyInstanceResourceMemory extends $tea.Model {
  /**
   * @example
   * 72
   */
  originalTotalMemory?: number;
  /**
   * @remarks
   * Indicates whether trusted ECS instances are used.
   * 
   * @example
   * 70
   */
  totalMemory?: number;
  /**
   * @remarks
   * The log disk space of each replica node in the cluster. Unit: GB.
   * 
   * @example
   * 10
   */
  unitMemory?: number;
  /**
   * @remarks
   * The time in UTC when the cluster was created.
   * 
   * @example
   * 10
   */
  usedMemory?: number;
  static names(): { [key: string]: string } {
    return {
      originalTotalMemory: 'OriginalTotalMemory',
      totalMemory: 'TotalMemory',
      unitMemory: 'UnitMemory',
      usedMemory: 'UsedMemory',
    };
  }

  static types(): { [key: string]: any } {
    return {
      originalTotalMemory: 'number',
      totalMemory: 'number',
      unitMemory: 'number',
      usedMemory: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceResponseBodyInstanceResource extends $tea.Model {
  capacityUnit?: DescribeInstanceResponseBodyInstanceResourceCapacityUnit;
  /**
   * @remarks
   * The information of the OceanBase cluster.
   */
  cpu?: DescribeInstanceResponseBodyInstanceResourceCpu;
  /**
   * @remarks
   * The number of the page to return. 
   * - Start value: 1  
   * - Default value: 1
   */
  diskSize?: DescribeInstanceResponseBodyInstanceResourceDiskSize;
  /**
   * @remarks
   * The server with the highest disk usage.
   */
  logDiskSize?: DescribeInstanceResponseBodyInstanceResourceLogDiskSize;
  /**
   * @remarks
   * The name of the OceanBase cluster.
   */
  memory?: DescribeInstanceResponseBodyInstanceResourceMemory;
  /**
   * @remarks
   * The number of CPU cores used in the cluster.
   * 
   * @example
   * 1
   */
  unitCount?: number;
  static names(): { [key: string]: string } {
    return {
      capacityUnit: 'CapacityUnit',
      cpu: 'Cpu',
      diskSize: 'DiskSize',
      logDiskSize: 'LogDiskSize',
      memory: 'Memory',
      unitCount: 'UnitCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      capacityUnit: DescribeInstanceResponseBodyInstanceResourceCapacityUnit,
      cpu: DescribeInstanceResponseBodyInstanceResourceCpu,
      diskSize: DescribeInstanceResponseBodyInstanceResourceDiskSize,
      logDiskSize: DescribeInstanceResponseBodyInstanceResourceLogDiskSize,
      memory: DescribeInstanceResponseBodyInstanceResourceMemory,
      unitCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceResponseBodyInstanceTenantCreatable extends $tea.Model {
  /**
   * @example
   * CPU_NOT_ENOUGH、 MEMORY_NOT_ENOUGH、TENANT_COUNT_EXCEEDS_LIMIT
   */
  disableCreateTenantReason?: string;
  enableCreateTenant?: boolean;
  static names(): { [key: string]: string } {
    return {
      disableCreateTenantReason: 'DisableCreateTenantReason',
      enableCreateTenant: 'EnableCreateTenant',
    };
  }

  static types(): { [key: string]: any } {
    return {
      disableCreateTenantReason: 'string',
      enableCreateTenant: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceResponseBodyInstance extends $tea.Model {
  allowCreateProxySqlFirewallRule?: boolean;
  allowModifyInternetAddressConnectionLimit?: boolean;
  /**
   * @remarks
   * The operation that you want to perform. <br>Set the value to **DescribeInstance**.
   * 
   * @example
   * true
   */
  autoRenewal?: boolean;
  /**
   * @remarks
   * Example 1
   * 
   * @example
   * true
   */
  autoUpgradeObVersion?: boolean;
  availableZones?: string[];
  /**
   * @example
   * X86
   */
  cpuArchitecture?: string;
  /**
   * @remarks
   * Indicates whether the log disk specifications can be upgraded.
   * 
   * @example
   * 2021-10-19T07:13:41Z
   */
  createTime?: string;
  dataDiskAutoScale?: boolean;
  dataDiskAutoScaleConfig?: DescribeInstanceResponseBodyInstanceDataDiskAutoScaleConfig;
  /**
   * @remarks
   * The total number of CPU cores of the cluster.
   * 
   * @example
   * 02:00
   */
  dataMergeTime?: string;
  /**
   * @remarks
   * Alibaba Cloud CLI
   * 
   * @example
   * 1-1-1
   */
  deployMode?: string;
  /**
   * @remarks
   * It is an online CLI tool that allows you to quickly retrieve and debug APIs. It can dynamically generate executable SDK code samples.
   * 
   * @example
   * multiple
   */
  deployType?: string;
  /**
   * @remarks
   * The total storage space of the cluster, in GB.
   * 
   * @example
   * cloud_essd_pl1
   */
  diskType?: string;
  enableIsolationOptimization?: boolean;
  enableProxyService?: boolean;
  enableReadOnlyReplica?: boolean;
  enableReadOnlyReplicaManagement?: boolean;
  /**
   * @example
   * false
   */
  enableUpgradeLogDisk?: boolean;
  exclusiveUnitNumLimit?: number;
  /**
   * @remarks
   * The information of the OceanBase cluster.
   * 
   * @example
   * 2021-10-17T16:00:00Z
   */
  expireTime?: string;
  inTempCapacityStatus?: boolean;
  /**
   * @remarks
   * The detailed information of the OBServer version.
   * 
   * @example
   * 14C70G
   */
  instanceClass?: string;
  /**
   * @remarks
   * The information about the log disk space of the cluster.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * Indicates whether automatic upgrade of the OBServer version is enabled.
   * 
   * @example
   * ob4test
   */
  instanceName?: string;
  /**
   * @example
   * NORMAL
   */
  instanceRole?: string;
  /**
   * @example
   * true
   */
  isLatestObVersion?: boolean;
  /**
   * @remarks
   * The information about the CPU resources of the cluster.
   * 
   * @example
   * true
   */
  isTrustEcs?: boolean;
  isolationOptimization?: boolean;
  /**
   * @remarks
   * The time when the major compaction of cluster data is performed.
   * 
   * @example
   * 19:00Z-20:00Z
   */
  maintainTime?: string;
  /**
   * @example
   * 6
   */
  nodeNum?: string;
  /**
   * @example
   * 2.2.77-20210526202046
   */
  obRpmVersion?: string;
  /**
   * @remarks
   * The list of zones.
   * 
   * @example
   * PREPAY
   */
  payType?: string;
  /**
   * @example
   * ob3h8ytroxxxxx
   */
  primaryInstance?: string;
  /**
   * @example
   * cn-hangzhou
   */
  primaryRegion?: string;
  proxyClusterId?: string;
  proxyServiceStatus?: string;
  readOnlyResource?: DescribeInstanceResponseBodyInstanceReadOnlyResource;
  replicaMode?: string;
  /**
   * @remarks
   * The size of used memory in the cluster, in GB.
   */
  resource?: DescribeInstanceResponseBodyInstanceResource;
  /**
   * @remarks
   * Indicates whether the OBServer version is the latest.
   * 
   * @example
   * Indicates whether the OBServer version is the latest.
   */
  series?: string;
  sharedUnitNumLimit?: number;
  specType?: string;
  /**
   * @remarks
   * The information about cluster resources.
   * 
   * @example
   * ONLINE
   */
  status?: string;
  tenantCreatable?: DescribeInstanceResponseBodyInstanceTenantCreatable;
  unitSpec?: string;
  /**
   * @remarks
   * You can call this operation to query the detailed information of an OceanBase cluster.
   * 
   * @example
   * 2.2.77
   */
  version?: string;
  zones?: string[];
  static names(): { [key: string]: string } {
    return {
      allowCreateProxySqlFirewallRule: 'AllowCreateProxySqlFirewallRule',
      allowModifyInternetAddressConnectionLimit: 'AllowModifyInternetAddressConnectionLimit',
      autoRenewal: 'AutoRenewal',
      autoUpgradeObVersion: 'AutoUpgradeObVersion',
      availableZones: 'AvailableZones',
      cpuArchitecture: 'CpuArchitecture',
      createTime: 'CreateTime',
      dataDiskAutoScale: 'DataDiskAutoScale',
      dataDiskAutoScaleConfig: 'DataDiskAutoScaleConfig',
      dataMergeTime: 'DataMergeTime',
      deployMode: 'DeployMode',
      deployType: 'DeployType',
      diskType: 'DiskType',
      enableIsolationOptimization: 'EnableIsolationOptimization',
      enableProxyService: 'EnableProxyService',
      enableReadOnlyReplica: 'EnableReadOnlyReplica',
      enableReadOnlyReplicaManagement: 'EnableReadOnlyReplicaManagement',
      enableUpgradeLogDisk: 'EnableUpgradeLogDisk',
      exclusiveUnitNumLimit: 'ExclusiveUnitNumLimit',
      expireTime: 'ExpireTime',
      inTempCapacityStatus: 'InTempCapacityStatus',
      instanceClass: 'InstanceClass',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      instanceRole: 'InstanceRole',
      isLatestObVersion: 'IsLatestObVersion',
      isTrustEcs: 'IsTrustEcs',
      isolationOptimization: 'IsolationOptimization',
      maintainTime: 'MaintainTime',
      nodeNum: 'NodeNum',
      obRpmVersion: 'ObRpmVersion',
      payType: 'PayType',
      primaryInstance: 'PrimaryInstance',
      primaryRegion: 'PrimaryRegion',
      proxyClusterId: 'ProxyClusterId',
      proxyServiceStatus: 'ProxyServiceStatus',
      readOnlyResource: 'ReadOnlyResource',
      replicaMode: 'ReplicaMode',
      resource: 'Resource',
      series: 'Series',
      sharedUnitNumLimit: 'SharedUnitNumLimit',
      specType: 'SpecType',
      status: 'Status',
      tenantCreatable: 'TenantCreatable',
      unitSpec: 'UnitSpec',
      version: 'Version',
      zones: 'Zones',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allowCreateProxySqlFirewallRule: 'boolean',
      allowModifyInternetAddressConnectionLimit: 'boolean',
      autoRenewal: 'boolean',
      autoUpgradeObVersion: 'boolean',
      availableZones: { 'type': 'array', 'itemType': 'string' },
      cpuArchitecture: 'string',
      createTime: 'string',
      dataDiskAutoScale: 'boolean',
      dataDiskAutoScaleConfig: DescribeInstanceResponseBodyInstanceDataDiskAutoScaleConfig,
      dataMergeTime: 'string',
      deployMode: 'string',
      deployType: 'string',
      diskType: 'string',
      enableIsolationOptimization: 'boolean',
      enableProxyService: 'boolean',
      enableReadOnlyReplica: 'boolean',
      enableReadOnlyReplicaManagement: 'boolean',
      enableUpgradeLogDisk: 'boolean',
      exclusiveUnitNumLimit: 'number',
      expireTime: 'string',
      inTempCapacityStatus: 'boolean',
      instanceClass: 'string',
      instanceId: 'string',
      instanceName: 'string',
      instanceRole: 'string',
      isLatestObVersion: 'boolean',
      isTrustEcs: 'boolean',
      isolationOptimization: 'boolean',
      maintainTime: 'string',
      nodeNum: 'string',
      obRpmVersion: 'string',
      payType: 'string',
      primaryInstance: 'string',
      primaryRegion: 'string',
      proxyClusterId: 'string',
      proxyServiceStatus: 'string',
      readOnlyResource: DescribeInstanceResponseBodyInstanceReadOnlyResource,
      replicaMode: 'string',
      resource: DescribeInstanceResponseBodyInstanceResource,
      series: 'string',
      sharedUnitNumLimit: 'number',
      specType: 'string',
      status: 'string',
      tenantCreatable: DescribeInstanceResponseBodyInstanceTenantCreatable,
      unitSpec: 'string',
      version: 'string',
      zones: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceCreatableZoneResponseBodyZoneList extends $tea.Model {
  /**
   * @example
   * true
   */
  isInCluster?: boolean;
  /**
   * @remarks
   * DescribeInstanceCreatableZone
   * 
   * @example
   * cn-hangzhou-i
   */
  zone?: string;
  static names(): { [key: string]: string } {
    return {
      isInCluster: 'IsInCluster',
      zone: 'Zone',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isInCluster: 'boolean',
      zone: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceSSLResponseBodyInstanceSSL extends $tea.Model {
  /**
   * @example
   * https://xxxx
   */
  caUrl?: string;
  /**
   * @example
   * OPEN
   */
  enableSSL?: string;
  /**
   * @example
   * CLOSE
   */
  forceSSL?: string;
  /**
   * @example
   * false
   */
  forceSSLSupport?: boolean;
  /**
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @example
   * RUNNING
   */
  status?: string;
  /**
   * @example
   * 2024-09-20 07:55:03.0
   */
  validPeriod?: string;
  static names(): { [key: string]: string } {
    return {
      caUrl: 'CaUrl',
      enableSSL: 'EnableSSL',
      forceSSL: 'ForceSSL',
      forceSSLSupport: 'ForceSSLSupport',
      instanceId: 'InstanceId',
      status: 'Status',
      validPeriod: 'ValidPeriod',
    };
  }

  static types(): { [key: string]: any } {
    return {
      caUrl: 'string',
      enableSSL: 'string',
      forceSSL: 'string',
      forceSSLSupport: 'boolean',
      instanceId: 'string',
      status: 'string',
      validPeriod: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceSecurityConfigsResponseBodyInstanceSecurityConfigsSecurityConfigs extends $tea.Model {
  /**
   * @remarks
   * The name of the check item.
   * 
   * @example
   * Check whether the scope of the cluster allowlist is too big
   */
  configDescription?: string;
  /**
   * @remarks
   * The group of the check.
   * 
   * @example
   * WHITELIST
   */
  configGroup?: string;
  /**
   * @remarks
   * The name of the specific check item.
   * 
   * @example
   * xxx
   */
  configName?: string;
  /**
   * @remarks
   * Specifies whether a risk is detected.
   * 
   * @example
   * true
   */
  risk?: boolean;
  /**
   * @remarks
   * Security recommendations.
   * 
   * @example
   * xxx
   */
  riskDescription?: string;
  static names(): { [key: string]: string } {
    return {
      configDescription: 'ConfigDescription',
      configGroup: 'ConfigGroup',
      configName: 'ConfigName',
      risk: 'Risk',
      riskDescription: 'RiskDescription',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configDescription: 'string',
      configGroup: 'string',
      configName: 'string',
      risk: 'boolean',
      riskDescription: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceSecurityConfigsResponseBodyInstanceSecurityConfigs extends $tea.Model {
  /**
   * @remarks
   * The unique identifier of the check.
   * 
   * @example
   * xxx
   */
  checkId?: string;
  /**
   * @remarks
   * The time when the check was performed.
   * 
   * @example
   * 2023-08-07 15:30:00
   */
  checkTime?: string;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The list of check items.
   */
  securityConfigs?: DescribeInstanceSecurityConfigsResponseBodyInstanceSecurityConfigsSecurityConfigs[];
  /**
   * @remarks
   * The total number of security check items for the cluster.
   * 
   * @example
   * 5
   */
  totalCheckCount?: number;
  /**
   * @remarks
   * The total number of detected cluster security risks.
   * 
   * @example
   * 0
   */
  totalRiskCount?: number;
  static names(): { [key: string]: string } {
    return {
      checkId: 'CheckId',
      checkTime: 'CheckTime',
      instanceId: 'InstanceId',
      securityConfigs: 'SecurityConfigs',
      totalCheckCount: 'TotalCheckCount',
      totalRiskCount: 'TotalRiskCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkId: 'string',
      checkTime: 'string',
      instanceId: 'string',
      securityConfigs: { 'type': 'array', 'itemType': DescribeInstanceSecurityConfigsResponseBodyInstanceSecurityConfigsSecurityConfigs },
      totalCheckCount: 'number',
      totalRiskCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTagsResponseBodyTagResources extends $tea.Model {
  /**
   * @remarks
   * The resource ID.
   * 
   * @example
   * ob317v4uif****
   */
  resourceId?: string;
  /**
   * @remarks
   * The type of the resource.
   * 
   * @example
   * instance
   */
  resourceType?: string;
  /**
   * @remarks
   * The tag of the resource.
   * 
   * @example
   * [{"Key": "xxx", "Value", "xxx"},{}]
   */
  tag?: string;
  static names(): { [key: string]: string } {
    return {
      resourceId: 'ResourceId',
      resourceType: 'ResourceType',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceId: 'string',
      resourceType: 'string',
      tag: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTopologyResponseBodyInstanceTopologyReplicasReplicaResourceCpu extends $tea.Model {
  totalCpu?: number;
  usedCpu?: number;
  static names(): { [key: string]: string } {
    return {
      totalCpu: 'TotalCpu',
      usedCpu: 'UsedCpu',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCpu: 'number',
      usedCpu: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTopologyResponseBodyInstanceTopologyReplicasReplicaResourceDiskSize extends $tea.Model {
  totalDiskSize?: number;
  usedDiskSize?: number;
  static names(): { [key: string]: string } {
    return {
      totalDiskSize: 'TotalDiskSize',
      usedDiskSize: 'UsedDiskSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalDiskSize: 'number',
      usedDiskSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTopologyResponseBodyInstanceTopologyReplicasReplicaResourceMemory extends $tea.Model {
  totalMemory?: number;
  usedMemory?: number;
  static names(): { [key: string]: string } {
    return {
      totalMemory: 'TotalMemory',
      usedMemory: 'UsedMemory',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalMemory: 'number',
      usedMemory: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTopologyResponseBodyInstanceTopologyReplicasReplicaResource extends $tea.Model {
  cpu?: DescribeInstanceTopologyResponseBodyInstanceTopologyReplicasReplicaResourceCpu;
  diskSize?: DescribeInstanceTopologyResponseBodyInstanceTopologyReplicasReplicaResourceDiskSize;
  memory?: DescribeInstanceTopologyResponseBodyInstanceTopologyReplicasReplicaResourceMemory;
  static names(): { [key: string]: string } {
    return {
      cpu: 'Cpu',
      diskSize: 'DiskSize',
      memory: 'Memory',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cpu: DescribeInstanceTopologyResponseBodyInstanceTopologyReplicasReplicaResourceCpu,
      diskSize: DescribeInstanceTopologyResponseBodyInstanceTopologyReplicasReplicaResourceDiskSize,
      memory: DescribeInstanceTopologyResponseBodyInstanceTopologyReplicasReplicaResourceMemory,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTopologyResponseBodyInstanceTopologyReplicas extends $tea.Model {
  logicalZone?: string;
  nodeNum?: number;
  replicaResource?: DescribeInstanceTopologyResponseBodyInstanceTopologyReplicasReplicaResource;
  replicaType?: string;
  status?: string;
  zoneLogicalId?: number;
  zoneLogicalName?: string;
  zoneRegionName?: string;
  static names(): { [key: string]: string } {
    return {
      logicalZone: 'LogicalZone',
      nodeNum: 'NodeNum',
      replicaResource: 'ReplicaResource',
      replicaType: 'ReplicaType',
      status: 'Status',
      zoneLogicalId: 'ZoneLogicalId',
      zoneLogicalName: 'ZoneLogicalName',
      zoneRegionName: 'ZoneRegionName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logicalZone: 'string',
      nodeNum: 'number',
      replicaResource: DescribeInstanceTopologyResponseBodyInstanceTopologyReplicasReplicaResource,
      replicaType: 'string',
      status: 'string',
      zoneLogicalId: 'number',
      zoneLogicalName: 'string',
      zoneRegionName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTopologyResponseBodyInstanceTopologyTenantsTenantZonesUnits extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the migration can be canceled.   
   * This field is valid only for units that are being manually immigrated or emigrated.
   * 
   * @example
   * true
   */
  enableCancelMigrateUnit?: boolean;
  /**
   * @remarks
   * The return result of the request.
   * 
   * @example
   * true
   */
  enableMigrateUnit?: boolean;
  /**
   * @remarks
   * The return result of the request.
   * 
   * @example
   * true
   */
  manualMigrate?: boolean;
  /**
   * @remarks
   * It is an online CLI tool that allows you to quickly retrieve and debug APIs. It can dynamically generate executable SDK code samples.
   * 
   * @example
   * i-bp16niirq4zdmgvm****
   */
  nodeId?: string;
  replicaType?: string;
  /**
   * @remarks
   * Alibaba Cloud CLI
   * 
   * @example
   * 2
   */
  unitCpu?: number;
  /**
   * @remarks
   * The operation that you want to perform.   
   * Set the value to **DescribeInstanceTopology**.
   * 
   * @example
   * 10
   */
  unitDataSize?: number;
  /**
   * @remarks
   * The topology of the cluster.
   * 
   * @example
   * 1002
   */
  unitId?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * @example
   * 10
   */
  unitMemory?: number;
  /**
   * @remarks
   * You can call this operation to query the topology of an OceanBase cluster.
   * 
   * @example
   * ONLINE
   */
  unitStatus?: string;
  static names(): { [key: string]: string } {
    return {
      enableCancelMigrateUnit: 'EnableCancelMigrateUnit',
      enableMigrateUnit: 'EnableMigrateUnit',
      manualMigrate: 'ManualMigrate',
      nodeId: 'NodeId',
      replicaType: 'ReplicaType',
      unitCpu: 'UnitCpu',
      unitDataSize: 'UnitDataSize',
      unitId: 'UnitId',
      unitMemory: 'UnitMemory',
      unitStatus: 'UnitStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enableCancelMigrateUnit: 'boolean',
      enableMigrateUnit: 'boolean',
      manualMigrate: 'boolean',
      nodeId: 'string',
      replicaType: 'string',
      unitCpu: 'number',
      unitDataSize: 'number',
      unitId: 'string',
      unitMemory: 'number',
      unitStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTopologyResponseBodyInstanceTopologyTenantsTenantZones extends $tea.Model {
  /**
   * @remarks
   * The maximum disk usage, in percentage.
   * 
   * @example
   * true
   */
  isPrimaryTenantZone?: boolean;
  logicalZone?: string;
  replicaType?: string;
  /**
   * @remarks
   * The server with the highest disk usage.
   * 
   * @example
   * cn-hangzhou-h
   */
  tenantZoneId?: string;
  /**
   * @remarks
   * The information of zones.
   * 
   * @example
   * ReadWrite
   */
  tenantZoneRole?: string;
  /**
   * @remarks
   * The information about the storage resources.
   */
  units?: DescribeInstanceTopologyResponseBodyInstanceTopologyTenantsTenantZonesUnits[];
  static names(): { [key: string]: string } {
    return {
      isPrimaryTenantZone: 'IsPrimaryTenantZone',
      logicalZone: 'LogicalZone',
      replicaType: 'ReplicaType',
      tenantZoneId: 'TenantZoneId',
      tenantZoneRole: 'TenantZoneRole',
      units: 'Units',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isPrimaryTenantZone: 'boolean',
      logicalZone: 'string',
      replicaType: 'string',
      tenantZoneId: 'string',
      tenantZoneRole: 'string',
      units: { 'type': 'array', 'itemType': DescribeInstanceTopologyResponseBodyInstanceTopologyTenantsTenantZonesUnits },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTopologyResponseBodyInstanceTopologyTenants extends $tea.Model {
  /**
   * @remarks
   * The server with the highest disk usage.
   * 
   * @example
   * RANDOM
   */
  primaryZoneDeployType?: string;
  /**
   * @remarks
   * The information about the memory resources of the node.
   * 
   * @example
   * 2
   */
  tenantCpu?: number;
  /**
   * @remarks
   * The name of the tenant.
   * 
   * @example
   * multiple
   */
  tenantDeployType?: string;
  tenantDiskSize?: number;
  /**
   * @remarks
   * The size of used memory of the node, in GB.
   * 
   * @example
   * t33h8y08k****
   */
  tenantId?: string;
  /**
   * @remarks
   * The total storage space of the node, in GB.
   * 
   * @example
   * 10
   */
  tenantMemory?: number;
  /**
   * @remarks
   * The size of used storage space of the node, in GB.
   * 
   * @example
   * Oracle
   */
  tenantMode?: string;
  /**
   * @remarks
   * The total memory size of the node, in GB.
   * 
   * @example
   * pay_online
   */
  tenantName?: string;
  /**
   * @remarks
   * The size of used memory of the node, in GB.
   * 
   * @example
   * ONLINE
   */
  tenantStatus?: string;
  tenantUnitCpu?: number;
  tenantUnitMemory?: number;
  /**
   * @remarks
   * The number of CPU cores of the tenant.
   * 
   * @example
   * 1
   */
  tenantUnitNum?: number;
  /**
   * @remarks
   * The information about the storage resources of the node.
   */
  tenantZones?: DescribeInstanceTopologyResponseBodyInstanceTopologyTenantsTenantZones[];
  static names(): { [key: string]: string } {
    return {
      primaryZoneDeployType: 'PrimaryZoneDeployType',
      tenantCpu: 'TenantCpu',
      tenantDeployType: 'TenantDeployType',
      tenantDiskSize: 'TenantDiskSize',
      tenantId: 'TenantId',
      tenantMemory: 'TenantMemory',
      tenantMode: 'TenantMode',
      tenantName: 'TenantName',
      tenantStatus: 'TenantStatus',
      tenantUnitCpu: 'TenantUnitCpu',
      tenantUnitMemory: 'TenantUnitMemory',
      tenantUnitNum: 'TenantUnitNum',
      tenantZones: 'TenantZones',
    };
  }

  static types(): { [key: string]: any } {
    return {
      primaryZoneDeployType: 'string',
      tenantCpu: 'number',
      tenantDeployType: 'string',
      tenantDiskSize: 'number',
      tenantId: 'string',
      tenantMemory: 'number',
      tenantMode: 'string',
      tenantName: 'string',
      tenantStatus: 'string',
      tenantUnitCpu: 'number',
      tenantUnitMemory: 'number',
      tenantUnitNum: 'number',
      tenantZones: { 'type': 'array', 'itemType': DescribeInstanceTopologyResponseBodyInstanceTopologyTenantsTenantZones },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResourceCpu extends $tea.Model {
  /**
   * @example
   * 14
   */
  totalCpu?: number;
  /**
   * @example
   * 4
   */
  usedCpu?: number;
  static names(): { [key: string]: string } {
    return {
      totalCpu: 'TotalCpu',
      usedCpu: 'UsedCpu',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCpu: 'number',
      usedCpu: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResourceDiskSize extends $tea.Model {
  totalDiskSize?: number;
  usedDiskSize?: number;
  static names(): { [key: string]: string } {
    return {
      totalDiskSize: 'TotalDiskSize',
      usedDiskSize: 'UsedDiskSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalDiskSize: 'number',
      usedDiskSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResourceMemory extends $tea.Model {
  /**
   * @example
   * 70
   */
  totalMemory?: number;
  /**
   * @example
   * 10
   */
  usedMemory?: number;
  static names(): { [key: string]: string } {
    return {
      totalMemory: 'TotalMemory',
      usedMemory: 'UsedMemory',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalMemory: 'number',
      usedMemory: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResource extends $tea.Model {
  cpu?: DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResourceCpu;
  diskSize?: DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResourceDiskSize;
  memory?: DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResourceMemory;
  static names(): { [key: string]: string } {
    return {
      cpu: 'Cpu',
      diskSize: 'DiskSize',
      memory: 'Memory',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cpu: DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResourceCpu,
      diskSize: DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResourceDiskSize,
      memory: DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResourceMemory,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodes extends $tea.Model {
  fullCopyId?: number;
  logicalZone?: string;
  /**
   * @remarks
   * The information of zones.
   * 
   * @example
   * 1
   */
  nodeCopyId?: number;
  /**
   * @remarks
   * The ID of the resource unit.
   * 
   * @example
   * i-bp16niirq4zdmgvm****
   */
  nodeId?: string;
  /**
   * @remarks
   * The ID of the node.
   */
  nodeResource?: DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResource;
  /**
   * @remarks
   * The ID of the OBServer where the resource unit resides.
   * 
   * @example
   * ONLINE
   */
  nodeStatus?: string;
  readOnlyCopyId?: number;
  replicaType?: string;
  static names(): { [key: string]: string } {
    return {
      fullCopyId: 'FullCopyId',
      logicalZone: 'LogicalZone',
      nodeCopyId: 'NodeCopyId',
      nodeId: 'NodeId',
      nodeResource: 'NodeResource',
      nodeStatus: 'NodeStatus',
      readOnlyCopyId: 'ReadOnlyCopyId',
      replicaType: 'ReplicaType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fullCopyId: 'number',
      logicalZone: 'string',
      nodeCopyId: 'number',
      nodeId: 'string',
      nodeResource: DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResource,
      nodeStatus: 'string',
      readOnlyCopyId: 'number',
      replicaType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTopologyResponseBodyInstanceTopologyZonesZoneResourceDiskSize extends $tea.Model {
  maxDiskUsedObServer?: string[];
  /**
   * @remarks
   * DescribeInstanceTopology
   * 
   * @example
   * 0.14
   */
  maxDiskUsedPercent?: number;
  static names(): { [key: string]: string } {
    return {
      maxDiskUsedObServer: 'MaxDiskUsedObServer',
      maxDiskUsedPercent: 'MaxDiskUsedPercent',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxDiskUsedObServer: { 'type': 'array', 'itemType': 'string' },
      maxDiskUsedPercent: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTopologyResponseBodyInstanceTopologyZonesZoneResource extends $tea.Model {
  diskSize?: DescribeInstanceTopologyResponseBodyInstanceTopologyZonesZoneResourceDiskSize;
  static names(): { [key: string]: string } {
    return {
      diskSize: 'DiskSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      diskSize: DescribeInstanceTopologyResponseBodyInstanceTopologyZonesZoneResourceDiskSize,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTopologyResponseBodyInstanceTopologyZones extends $tea.Model {
  /**
   * @remarks
   * The ID of the region.
   */
  nodes?: DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodes[];
  /**
   * @remarks
   * The zone information of the cluster.
   * 
   * @example
   * cn-hangzhou
   */
  region?: string;
  /**
   * @remarks
   * The information about the memory resources of the node.
   * 
   * @example
   * 200 GB
   */
  zoneDisk?: string;
  /**
   * @remarks
   * The information of the tenant.
   * 
   * @example
   * cn-hangzhou-i
   */
  zoneId?: string;
  /**
   * @remarks
   * Example 1
   */
  zoneResource?: DescribeInstanceTopologyResponseBodyInstanceTopologyZonesZoneResource;
  static names(): { [key: string]: string } {
    return {
      nodes: 'Nodes',
      region: 'Region',
      zoneDisk: 'ZoneDisk',
      zoneId: 'ZoneId',
      zoneResource: 'ZoneResource',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodes: { 'type': 'array', 'itemType': DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodes },
      region: 'string',
      zoneDisk: 'string',
      zoneId: 'string',
      zoneResource: DescribeInstanceTopologyResponseBodyInstanceTopologyZonesZoneResource,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTopologyResponseBodyInstanceTopology extends $tea.Model {
  replicas?: DescribeInstanceTopologyResponseBodyInstanceTopologyReplicas[];
  /**
   * @remarks
   * The total number of CPU cores for the node.
   */
  tenants?: DescribeInstanceTopologyResponseBodyInstanceTopologyTenants[];
  /**
   * @remarks
   * The information about resource units.
   */
  zones?: DescribeInstanceTopologyResponseBodyInstanceTopologyZones[];
  static names(): { [key: string]: string } {
    return {
      replicas: 'Replicas',
      tenants: 'Tenants',
      zones: 'Zones',
    };
  }

  static types(): { [key: string]: any } {
    return {
      replicas: { 'type': 'array', 'itemType': DescribeInstanceTopologyResponseBodyInstanceTopologyReplicas },
      tenants: { 'type': 'array', 'itemType': DescribeInstanceTopologyResponseBodyInstanceTopologyTenants },
      zones: { 'type': 'array', 'itemType': DescribeInstanceTopologyResponseBodyInstanceTopologyZones },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesResponseBodyInstancesDataDiskAutoScaleConfig extends $tea.Model {
  /**
   * @remarks
   * Specifies whether to enable the automatic scaling of the data disk.
   * 
   * @example
   * true
   */
  autoScale?: boolean;
  /**
   * @remarks
   * The maximum size of the disk, in GB.
   * 
   * @example
   * 80000
   */
  maxDiskSize?: number;
  /**
   * @remarks
   * The size of scaling step during a major compaction.
   * 
   * @example
   * 100
   */
  scaleStepInMerge?: number;
  /**
   * @remarks
   * The size of scaling step during daily use.
   * 
   * @example
   * 50
   */
  scaleStepInNormal?: number;
  /**
   * @remarks
   * The maximum usage of the data disk, in percentage, that triggers the scaling of the data disk for major compactions.
   * 
   * @example
   * 90
   */
  upperMergeThreshold?: number;
  /**
   * @remarks
   * The scale-out strategy. Valid values: RAW and PERCENTAGE.
   * 
   * @example
   * RAW
   */
  upperScaleStrategy?: string;
  /**
   * @remarks
   * The maximum usage of the data disk, in percentage, that triggers the scaling of the data disk for daily use.
   * 
   * @example
   * 80
   */
  upperThreshold?: number;
  /**
   * @remarks
   * The maximum space, in GB, to which the data disk can be scaled.
   * 
   * @example
   * 16
   */
  upperbound?: number;
  static names(): { [key: string]: string } {
    return {
      autoScale: 'AutoScale',
      maxDiskSize: 'MaxDiskSize',
      scaleStepInMerge: 'ScaleStepInMerge',
      scaleStepInNormal: 'ScaleStepInNormal',
      upperMergeThreshold: 'UpperMergeThreshold',
      upperScaleStrategy: 'UpperScaleStrategy',
      upperThreshold: 'UpperThreshold',
      upperbound: 'Upperbound',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoScale: 'boolean',
      maxDiskSize: 'number',
      scaleStepInMerge: 'number',
      scaleStepInNormal: 'number',
      upperMergeThreshold: 'number',
      upperScaleStrategy: 'string',
      upperThreshold: 'number',
      upperbound: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesResponseBodyInstancesResourceCapacityUnit extends $tea.Model {
  /**
   * @remarks
   * The maximum number of capacity units.
   * 
   * @example
   * 4
   */
  maxCapacityUnit?: number;
  /**
   * @remarks
   * The minimum number of capacity units.
   * 
   * @example
   * 1
   */
  minCapacityUnit?: number;
  /**
   * @remarks
   * The number of used capacity units.
   * 
   * @example
   * 2
   */
  usedCapacityUnit?: number;
  static names(): { [key: string]: string } {
    return {
      maxCapacityUnit: 'MaxCapacityUnit',
      minCapacityUnit: 'MinCapacityUnit',
      usedCapacityUnit: 'UsedCapacityUnit',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxCapacityUnit: 'number',
      minCapacityUnit: 'number',
      usedCapacityUnit: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesResponseBodyInstancesResourceCpu extends $tea.Model {
  /**
   * @remarks
   * The number of original CPU cores in the cluster.
   * 
   * @example
   * 14
   */
  originalTotalCpu?: number;
  /**
   * @remarks
   * The total number of CPU cores of the cluster.
   * 
   * @example
   * 14
   */
  totalCpu?: number;
  /**
   * @remarks
   * The number of CPU cores of each replica node in the cluster.
   * 
   * @example
   * 10
   */
  unitCpu?: number;
  /**
   * @remarks
   * The number of CPU cores used in the cluster.
   * 
   * @example
   * 10
   */
  usedCpu?: number;
  static names(): { [key: string]: string } {
    return {
      originalTotalCpu: 'OriginalTotalCpu',
      totalCpu: 'TotalCpu',
      unitCpu: 'UnitCpu',
      usedCpu: 'UsedCpu',
    };
  }

  static types(): { [key: string]: any } {
    return {
      originalTotalCpu: 'number',
      totalCpu: 'number',
      unitCpu: 'number',
      usedCpu: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesResponseBodyInstancesResourceDiskSize extends $tea.Model {
  /**
   * @remarks
   * The original size of the disk.
   * 
   * @example
   * 200
   */
  originalTotalDiskSize?: number;
  /**
   * @remarks
   * The total storage space of the cluster, in GB.
   * 
   * @example
   * 200
   */
  totalDiskSize?: number;
  /**
   * @remarks
   * The storage space of each replica node in the cluster, in GB.
   * 
   * @example
   * 200
   */
  unitDiskSize?: number;
  /**
   * @remarks
   * The size of used storage space of the cluster, in GB.
   * 
   * @example
   * 100
   */
  usedDiskSize?: number;
  static names(): { [key: string]: string } {
    return {
      originalTotalDiskSize: 'OriginalTotalDiskSize',
      totalDiskSize: 'TotalDiskSize',
      unitDiskSize: 'UnitDiskSize',
      usedDiskSize: 'UsedDiskSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      originalTotalDiskSize: 'number',
      totalDiskSize: 'number',
      unitDiskSize: 'number',
      usedDiskSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesResponseBodyInstancesResourceMemory extends $tea.Model {
  /**
   * @remarks
   * The original memory size of the cluster, in GB.
   * 
   * @example
   * 72
   */
  originalTotalMemory?: number;
  /**
   * @remarks
   * The total memory size of the cluster, in GB.
   * 
   * @example
   * 70
   */
  totalMemory?: number;
  /**
   * @remarks
   * The memory size of each replica node in the cluster, in GB.
   * 
   * @example
   * 10
   */
  unitMemory?: number;
  /**
   * @remarks
   * The size of used memory in the cluster, in GB.
   * 
   * @example
   * 10
   */
  usedMemory?: number;
  static names(): { [key: string]: string } {
    return {
      originalTotalMemory: 'OriginalTotalMemory',
      totalMemory: 'TotalMemory',
      unitMemory: 'UnitMemory',
      usedMemory: 'UsedMemory',
    };
  }

  static types(): { [key: string]: any } {
    return {
      originalTotalMemory: 'number',
      totalMemory: 'number',
      unitMemory: 'number',
      usedMemory: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesResponseBodyInstancesResource extends $tea.Model {
  /**
   * @remarks
   * The information about capacity units.
   */
  capacityUnit?: DescribeInstancesResponseBodyInstancesResourceCapacityUnit;
  /**
   * @remarks
   * The information about the CPU resources of the cluster.
   */
  cpu?: DescribeInstancesResponseBodyInstancesResourceCpu;
  /**
   * @remarks
   * The information about the storage resources of the cluster.
   */
  diskSize?: DescribeInstancesResponseBodyInstancesResourceDiskSize;
  /**
   * @remarks
   * The information about the memory resources of the cluster.
   */
  memory?: DescribeInstancesResponseBodyInstancesResourceMemory;
  /**
   * @remarks
   * The number of resource units in the cluster.
   * 
   * @example
   * 1
   */
  unitCount?: number;
  static names(): { [key: string]: string } {
    return {
      capacityUnit: 'CapacityUnit',
      cpu: 'Cpu',
      diskSize: 'DiskSize',
      memory: 'Memory',
      unitCount: 'UnitCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      capacityUnit: DescribeInstancesResponseBodyInstancesResourceCapacityUnit,
      cpu: DescribeInstancesResponseBodyInstancesResourceCpu,
      diskSize: DescribeInstancesResponseBodyInstancesResourceDiskSize,
      memory: DescribeInstancesResponseBodyInstancesResourceMemory,
      unitCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesResponseBodyInstances extends $tea.Model {
  /**
   * @remarks
   * The information about the zone in which the cluster is deployed.
   */
  availableZones?: string[];
  /**
   * @remarks
   * The product code of the OceanBase cluster.   
   * - oceanbase_oceanbasepre_public_cn: indicates an OceanBase cluster that is billed based on the subscription plan and that is deployed in a China site.  
   * - oceanbase_oceanbasepost_public_cn: indicates an OceanBase cluster that is billed based on the pay-as-you-go plan and that is deployed in a China site.  
   * - oceanbase_obpre_public_intl: indicates an OceanBase cluster that is billed based on the subscription plan and that is deployed in an international site.
   * 
   * @example
   * oceanbase_oceanbasepost_public_cn
   */
  commodityCode?: string;
  /**
   * @remarks
   * The number of CPU cores of the cluster.
   * 
   * @example
   * 14
   */
  cpu?: number;
  /**
   * @remarks
   * The CPU architecture of the cluster.
   * 
   * @example
   * X86_64, AARCH64
   */
  cpuArchitecture?: string;
  /**
   * @remarks
   * The time in UTC when the cluster was created.
   * 
   * @example
   * 2021-10-19T07:13:41Z
   */
  createTime?: string;
  /**
   * @remarks
   * Specifies parameters for the automatic scaling of the data disk.
   */
  dataDiskAutoScaleConfig?: DescribeInstancesResponseBodyInstancesDataDiskAutoScaleConfig;
  /**
   * @remarks
   * The data replica distribution mode of the cluster. The value is in the n-n-n format, where n is the number of OBServer nodes in each IDC.
   * 
   * @example
   * 1-1-1
   */
  deployMode?: string;
  /**
   * @remarks
   * The deployment type of the cluster. Valid values:   
   * - multiple: multi-IDC deployment  
   * - single: single-IDC deployment  
   * - dual: dual-IDC deployment
   * 
   * @example
   * multiple
   */
  deployType?: string;
  /**
   * @remarks
   * The size of the storage space, in GB.
   * 
   * @example
   * 200
   */
  diskSize?: string;
  /**
   * @remarks
   * The type of the storage disk where the cluster is deployed.   
   * The default value is cloud_essd_pl1, which indicates an ESSD cloud disk.
   * 
   * @example
   * cloud_essd_pl1
   */
  diskType?: string;
  /**
   * @remarks
   * Indicates whether the cluster supports read-only replicas.
   * 
   * @example
   * yes
   */
  enableReadOnlyReplicaManagement?: boolean;
  /**
   * @remarks
   * Indicates whether new nodes can be added.
   * 
   * @example
   * true
   */
  enableUpgradeNodes?: boolean;
  /**
   * @remarks
   * The time elapsed since the expiration of the cluster, in seconds. 
   * > In subscription mode, if the cluster has not expired, this parameter indicates the remaining validity period of the cluster. If the cluster has expired, this parameter indicates the time elapsed since the expiration.
   * 
   * @example
   * 2606682
   */
  expireSeconds?: number;
  /**
   * @remarks
   * The time in UTC when the cluster expires. 
   * > This parameter is valid only for subscription instances.
   * 
   * @example
   * 2021-10-17T16:00:00Z
   */
  expireTime?: string;
  /**
   * @remarks
   * Specifies whether to indicate the temporary status of the capacity.
   * 
   * @example
   * false
   */
  inTempCapacityStatus?: boolean;
  /**
   * @remarks
   * The specifications of the cluster.  You can specify one of the following four plans:  
   * - 8C32G: indicates 8 CPU cores and 32 GB of memory.  
   * - 14C70G: indicates 14 CPU cores and 70 GB of memory.  
   * - 30C180G: indicates 30 CPU cores and 180 GB of memory.  
   * - 62C400G: indicates 62 CPU cores and 400 GB of memory.
   * 
   * @example
   * 14C70G
   */
  instanceClass?: string;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The name of the OceanBase cluster.
   * 
   * @example
   * ob4test
   */
  instanceName?: string;
  /**
   * @remarks
   * The role of the instance.
   * 
   * @example
   * NORMAL
   */
  instanceRole?: string;
  /**
   * @remarks
   * The instance type.
   * - cluster: indicates a cluster instance.
   * - mtenant: indicates a tenant instance in MySQL mode.
   * - mtenant_serverless: indicates a serverless instance in MySQL mode.
   * 
   * @example
   * CLUSTER
   */
  instanceType?: string;
  /**
   * @remarks
   * The time period in UTC for the daily routine maintenance of the cluster.
   * 
   * @example
   * 2021-10-19T07:13:41Z
   */
  maintainTime?: string;
  /**
   * @remarks
   * The memory size of the instance, in GB.
   * 
   * @example
   * 70
   */
  mem?: number;
  /**
   * @remarks
   * The billing method for the OceanBase cluster. Valid values:  
   * - PREPAY: the subscription billing method.  
   * - POSTPAY: the pay-as-you-go billing method.
   * 
   * @example
   * PREPAY
   */
  payType?: string;
  /**
   * @remarks
   * The information about cluster resources.
   */
  resource?: DescribeInstancesResponseBodyInstancesResource;
  /**
   * @remarks
   * The ID of the resource group.
   * 
   * @example
   * group1
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The series of the OceanBase cluster. Valid values:   
   * - NORMAL: the high availability edition.   
   * - BASIC: the basic edition.
   * 
   * @example
   * NORMAL
   */
  series?: string;
  specType?: string;
  /**
   * @remarks
   * The status of the cluster. Valid values:   
   * - ONLINE: The cluster is running.  
   * - PENDING_CREATE: The cluster is being created.  
   * - ARREARS_CLOSED("arrears_closed"): The cluster is suspended due to insufficient balance.
   * - PREPAID_EXPIRE_CLOSED("prepaid_expire_closed"): The cluster is suspended because the subscription has expired.
   * - WHITE_LIST_MODIFYING("white_list_modifying"): The allowlist of the cluster is being modified.
   * - SSL_MODIFYING("ssl_modifying"): The Secure Sockets Layer (SSL) settings of the cluster are being modified.
   * - PARAMETER_MODIFYING("parameter_modifying"): Parameters of the cluster are being modified.
   * - TENANT_CREATING("tenant_creating"): A tenant is being created in the cluster.
   * - TENANT_SPEC_MODIFYING("tenant_spec_modifying"): The specifications of a tenant in the cluster are being modified.
   * - EXPANDING("expanding"): Nodes are being added to the cluster.
   * - REDUCING("reducing"): Nodes are being removed from the cluster.
   * - ZONE_CHANGING("zone_changing"): Zones of the cluster are being modified.
   * - SPEC_UPGRADING: The service plan is being upgraded.
   * - SPEC_DOWNGRADING("spec_downgrading"): The plan specification is being downgraded.
   * - DISK_UPGRADING: The storage space is being expanded.
   * - UPGRADING("upgrading"): The version of the cluster is being upgraded.
   * - PENDING_DELETE("pending_delete"): The cluster is being deleted.
   * - DELETED("deleted"): The cluster has been deleted.
   * - ABNORMAL("abnormal"): The cluster is abnormal.
   * - OFFLINE("offline"): The cluster is offline.
   * - STANDBY_CREATING("standby_creating"): A standby cluster is being created for the cluster.
   * - STANDBY_DELETING("standby_deleting"): A standby cluster of the cluster is being deleted.
   * - SWITCHOVER_SWITCHING("switchover_switching"): The cluster is undergoing a primary/standby switchover.
   * - STANDBY_DISCONNECTING("standby_disconnecting"): The cluster is being decoupled from its standby cluster.
   * - LOG_DISK_UPGRADING("log_disk_upgrading"): The log disk of the cluster is being scaled out.
   * - ISOLATION_OPTIMIZATION_MODIFYING("isolation_optimization_modifying"): The isolation optimization settings of the cluster are being modified.
   * - DISKTYPE_MODIFYING("disktype_modifying"): The data disk type of the cluster is being modified.
   * - PROXY_SERVICE_CREATING("proxy_service_creating"): The proxy service is being enabled for the cluster.
   * - PROXY_SERVICE_DELETING("proxy_service_deleting"): The proxy service is being disabled for the cluster.
   * - PROXY_SERVICE_SPEC_MODIFYING("proxy_service_spec_modifying"): The proxy service specification is being modified for the cluster.
   * - READONLY_ADD_NODE("readonly_add_node"): A read-only node is being added to the cluster.
   * - READONLY_REDUCE_NODE("readonly_reduce_node"): A read-only node is being removed from the cluster.
   * - READONLY_REDUCE_ZONE("readonly_reduce_zone"): A read-only zone is being removed from the cluster.
   * - READONLY_ADD_ZONE("readonly_add_zone"): A read-only zone is being added to the cluster.
   * - READONLY_UPGRADE_SPEC("readonly_upgrade_spec"): The specification of read-only replicas is being upgraded.
   * - READONLY_UPGRADE_DISK("readonly_upgrade_disk"): The disk space of read-only replicas is being scaled out.
   * - READONLY_DOWNGRADE_SPEC("readonly_downgrade_spec"): The specification of read-only replicas is being downgraded.
   * - READONLY_DOWNGRADE_DISK("readonly_downgrade_disk"): The disk space of read-only replicas is being scaled in.
   * - CREATING_TENANT_READONLY_REPLICA("creating_tenant_readonly_replica"): A read-only replica is being created for a tenant in the cluster.
   * - DELETING_TENANT_READONLY_REPLICA("deleting_tenant_readonly_replica"): A read-only replica is being deleted for a tenant in the cluster.
   * - DISK_DOWNGRADING("disk_downgrading"): The disk space of the cluster is being scaled in.
   * - DEPLOY_MODE_MODIFYING("deploy_mode_modifying"): The deployment mode of the cluster is being modified.
   * > Generally, the cluster is in the ONLINE state.
   * 
   * @example
   * ONLINE
   */
  state?: string;
  /**
   * @remarks
   * The size of used storage space of the cluster, in GB.
   * 
   * @example
   * 20
   */
  usedDiskSize?: number;
  /**
   * @remarks
   * The OBServer version.
   * 
   * @example
   * 2.2.77
   */
  version?: string;
  /**
   * @remarks
   * vpcId
   * 
   * @example
   * vpc-8vb8qjrixzovjpy******
   */
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      availableZones: 'AvailableZones',
      commodityCode: 'CommodityCode',
      cpu: 'Cpu',
      cpuArchitecture: 'CpuArchitecture',
      createTime: 'CreateTime',
      dataDiskAutoScaleConfig: 'DataDiskAutoScaleConfig',
      deployMode: 'DeployMode',
      deployType: 'DeployType',
      diskSize: 'DiskSize',
      diskType: 'DiskType',
      enableReadOnlyReplicaManagement: 'EnableReadOnlyReplicaManagement',
      enableUpgradeNodes: 'EnableUpgradeNodes',
      expireSeconds: 'ExpireSeconds',
      expireTime: 'ExpireTime',
      inTempCapacityStatus: 'InTempCapacityStatus',
      instanceClass: 'InstanceClass',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      instanceRole: 'InstanceRole',
      instanceType: 'InstanceType',
      maintainTime: 'MaintainTime',
      mem: 'Mem',
      payType: 'PayType',
      resource: 'Resource',
      resourceGroupId: 'ResourceGroupId',
      series: 'Series',
      specType: 'SpecType',
      state: 'State',
      usedDiskSize: 'UsedDiskSize',
      version: 'Version',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      availableZones: { 'type': 'array', 'itemType': 'string' },
      commodityCode: 'string',
      cpu: 'number',
      cpuArchitecture: 'string',
      createTime: 'string',
      dataDiskAutoScaleConfig: DescribeInstancesResponseBodyInstancesDataDiskAutoScaleConfig,
      deployMode: 'string',
      deployType: 'string',
      diskSize: 'string',
      diskType: 'string',
      enableReadOnlyReplicaManagement: 'boolean',
      enableUpgradeNodes: 'boolean',
      expireSeconds: 'number',
      expireTime: 'string',
      inTempCapacityStatus: 'boolean',
      instanceClass: 'string',
      instanceId: 'string',
      instanceName: 'string',
      instanceRole: 'string',
      instanceType: 'string',
      maintainTime: 'string',
      mem: 'number',
      payType: 'string',
      resource: DescribeInstancesResponseBodyInstancesResource,
      resourceGroupId: 'string',
      series: 'string',
      specType: 'string',
      state: 'string',
      usedDiskSize: 'number',
      version: 'string',
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOasAnomalySQLListResponseBodyDataSqlList extends $tea.Model {
  avgCpuTime?: number;
  avgDbTime?: number;
  avgElapsedTime?: number;
  avgGetPlanTime?: number;
  avgLogicalReads?: number;
  avgRetryCount?: number;
  cpuTime?: number;
  dbName?: string;
  diagTypes?: string[];
  diagnosis?: string;
  executions?: number;
  lastExecutedTime?: number;
  riskLevel?: string;
  sqlId?: string;
  sqlTextShort?: string;
  suggestion?: string;
  sumDbTime?: number;
  sumElapsedTime?: string;
  sumRetryCount?: number;
  userName?: string;
  static names(): { [key: string]: string } {
    return {
      avgCpuTime: 'AvgCpuTime',
      avgDbTime: 'AvgDbTime',
      avgElapsedTime: 'AvgElapsedTime',
      avgGetPlanTime: 'AvgGetPlanTime',
      avgLogicalReads: 'AvgLogicalReads',
      avgRetryCount: 'AvgRetryCount',
      cpuTime: 'CpuTime',
      dbName: 'DbName',
      diagTypes: 'DiagTypes',
      diagnosis: 'Diagnosis',
      executions: 'Executions',
      lastExecutedTime: 'LastExecutedTime',
      riskLevel: 'RiskLevel',
      sqlId: 'SqlId',
      sqlTextShort: 'SqlTextShort',
      suggestion: 'Suggestion',
      sumDbTime: 'SumDbTime',
      sumElapsedTime: 'SumElapsedTime',
      sumRetryCount: 'SumRetryCount',
      userName: 'UserName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avgCpuTime: 'number',
      avgDbTime: 'number',
      avgElapsedTime: 'number',
      avgGetPlanTime: 'number',
      avgLogicalReads: 'number',
      avgRetryCount: 'number',
      cpuTime: 'number',
      dbName: 'string',
      diagTypes: { 'type': 'array', 'itemType': 'string' },
      diagnosis: 'string',
      executions: 'number',
      lastExecutedTime: 'number',
      riskLevel: 'string',
      sqlId: 'string',
      sqlTextShort: 'string',
      suggestion: 'string',
      sumDbTime: 'number',
      sumElapsedTime: 'string',
      sumRetryCount: 'number',
      userName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOasAnomalySQLListResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * Average CPU time of the suspicious SQL.
   * 
   * @example
   * 100.24
   */
  avgCpuTime?: number;
  avgDbTime?: number;
  /**
   * @remarks
   * Average response time of the suspicious SQL.
   * 
   * @example
   * 100.28
   */
  avgElapsedTime?: number;
  /**
   * @remarks
   * Average time to obtain the execution plan of the suspicious SQL.
   * 
   * @example
   * 0
   */
  avgGetPlanTime?: number;
  avgLogicalReads?: number;
  avgRetryCount?: number;
  /**
   * @remarks
   * CPU time of the suspicious SQL.
   * 
   * @example
   * 100.23
   */
  cpuTime?: number;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * db_***
   */
  dbName?: string;
  /**
   * @remarks
   * The type of the diagnosis.
   */
  diagTypes?: string[];
  /**
   * @remarks
   * The details of diagnosis.
   */
  diagnosis?: string;
  dynamicSql?: boolean;
  /**
   * @remarks
   * Total execution count of the suspicious SQL.
   * 
   * @example
   * 1
   */
  executions?: number;
  /**
   * @remarks
   * Last execution time of the suspicious SQL.
   * 
   * @example
   * 2023-04-12T04:38:38Z
   */
  lastExecutedTime?: number;
  /**
   * @remarks
   * Risk level.
   * 
   * @example
   * high
   */
  riskLevel?: string;
  /**
   * @remarks
   * SQL ID.
   * 
   * @example
   * 8D6E84****0B8FB1823D199E2CA1****
   */
  sqlId?: string;
  sqlList?: DescribeOasAnomalySQLListResponseBodyDataSqlList[];
  /**
   * @remarks
   * Prefix of the SQL text.
   */
  sqlTextShort?: string;
  /**
   * @remarks
   * Suggestion for the suspicious SQL.
   * 
   * @example
   * review
   */
  suggestion?: string;
  sumDbTime?: number;
  /**
   * @remarks
   * Total response time of the suspicious SQL.
   * 
   * @example
   * 11452126.36
   */
  sumElapsedTime?: string;
  sumRetryCount?: number;
  /**
   * @remarks
   * Username.
   * 
   * @example
   * test_user
   */
  userName?: string;
  static names(): { [key: string]: string } {
    return {
      avgCpuTime: 'AvgCpuTime',
      avgDbTime: 'AvgDbTime',
      avgElapsedTime: 'AvgElapsedTime',
      avgGetPlanTime: 'AvgGetPlanTime',
      avgLogicalReads: 'AvgLogicalReads',
      avgRetryCount: 'AvgRetryCount',
      cpuTime: 'CpuTime',
      dbName: 'DbName',
      diagTypes: 'DiagTypes',
      diagnosis: 'Diagnosis',
      dynamicSql: 'DynamicSql',
      executions: 'Executions',
      lastExecutedTime: 'LastExecutedTime',
      riskLevel: 'RiskLevel',
      sqlId: 'SqlId',
      sqlList: 'SqlList',
      sqlTextShort: 'SqlTextShort',
      suggestion: 'Suggestion',
      sumDbTime: 'SumDbTime',
      sumElapsedTime: 'SumElapsedTime',
      sumRetryCount: 'SumRetryCount',
      userName: 'UserName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avgCpuTime: 'number',
      avgDbTime: 'number',
      avgElapsedTime: 'number',
      avgGetPlanTime: 'number',
      avgLogicalReads: 'number',
      avgRetryCount: 'number',
      cpuTime: 'number',
      dbName: 'string',
      diagTypes: { 'type': 'array', 'itemType': 'string' },
      diagnosis: 'string',
      dynamicSql: 'boolean',
      executions: 'number',
      lastExecutedTime: 'number',
      riskLevel: 'string',
      sqlId: 'string',
      sqlList: { 'type': 'array', 'itemType': DescribeOasAnomalySQLListResponseBodyDataSqlList },
      sqlTextShort: 'string',
      suggestion: 'string',
      sumDbTime: 'number',
      sumElapsedTime: 'string',
      sumRetryCount: 'number',
      userName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOasSQLDetailsResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * test_db
   */
  dbName?: string;
  /**
   * @remarks
   * SQL text.
   * 
   * @example
   * select a from b
   */
  fulltext?: string;
  /**
   * @remarks
   * Parameterized text.
   * 
   * @example
   * select a from b
   */
  statement?: string;
  /**
   * @remarks
   * The table name related to the SQL.
   */
  tables?: string[];
  /**
   * @remarks
   * The username.
   * 
   * @example
   * test_user
   */
  userName?: string;
  static names(): { [key: string]: string } {
    return {
      dbName: 'DbName',
      fulltext: 'Fulltext',
      statement: 'Statement',
      tables: 'Tables',
      userName: 'UserName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbName: 'string',
      fulltext: 'string',
      statement: 'string',
      tables: { 'type': 'array', 'itemType': 'string' },
      userName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOasSQLHistoryListResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * Average updated rows during the execution period.
   * 
   * @example
   * 9978.75
   */
  avgAffectedRows?: number;
  /**
   * @remarks
   * Average Application event wait time (in milliseconds) during the client waiting period.
   * 
   * @example
   * 0.0
   */
  avgApplicationWaitTime?: number;
  /**
   * @remarks
   * Average BlockCache hit count during the execution period.
   * 
   * @example
   * 0.0
   */
  avgBlockCacheHit?: number;
  /**
   * @remarks
   * Average BlockIndexCache hit count during the execution period.
   * 
   * @example
   * 0.0
   */
  avgBlockIndexCacheHit?: number;
  /**
   * @remarks
   * Average BloomFilterCache hit count during the execution period.
   * 
   * @example
   * 0.0
   */
  avgBloomFilterCacheHit?: number;
  /**
   * @remarks
   * Average Concurrency event wait time (in milliseconds) during the execution period.
   * 
   * @example
   * 0.0
   */
  avgConcurrencyWaitTime?: number;
  /**
   * @remarks
   * Average CPU time (in milliseconds) during the execution period.
   * 
   * @example
   * 1875.34
   */
  avgCpuTime?: number;
  avgDbTime?: number;
  /**
   * @remarks
   * Average syntax parsing time (in milliseconds) during the execution period.
   * 
   * @example
   * 0.0
   */
  avgDecodeTime?: number;
  /**
   * @remarks
   * Average physical read count during the execution period.
   * 
   * @example
   * 0.0
   */
  avgDiskReads?: number;
  /**
   * @remarks
   * Average response time (in milliseconds) during the execution period.
   * 
   * @example
   * 1876.78
   */
  avgElapsedTime?: number;
  /**
   * @remarks
   * Average plan execution time (in milliseconds) during the execution period.
   * 
   * @example
   * 1895.7
   */
  avgExecuteTime?: number;
  /**
   * @remarks
   * Average number of RPC requests executed during the execution period.
   * 
   * @example
   * 0
   */
  avgExecutorRpcCount?: number;
  /**
   * @remarks
   * Average degree of parallelism during the execution period.
   * 
   * @example
   * 3
   */
  avgExpectedWorkerCount?: number;
  /**
   * @remarks
   * Average plan generation time (in milliseconds) during the execution period.
   * 
   * @example
   * 0.0
   */
  avgGetPlanTime?: number;
  /**
   * @remarks
   * Average logical reads during the execution period.
   * 
   * @example
   * 0.0
   */
  avgLogicalReads?: number;
  /**
   * @remarks
   * Average Memstore read rows during the execution period.
   * 
   * @example
   * 0.0
   */
  avgMemstoreReadRows?: number;
  /**
   * @remarks
   * Average network transmission time (in milliseconds) during the execution period.
   * 
   * @example
   * 8
   */
  avgNetTime?: number;
  /**
   * @remarks
   * Average network enqueue time (in milliseconds) during the network waiting period.
   * 
   * @example
   * 0.0
   */
  avgNetWaitTime?: number;
  /**
   * @remarks
   * Average number of partition accessed during the execution period.
   * 
   * @example
   * 1
   */
  avgPartitionCount?: number;
  /**
   * @remarks
   * Average queueing time (in milliseconds) during the execution period.
   * 
   * @example
   * 0.01
   */
  avgQueueTime?: number;
  /**
   * @remarks
   * Average number of rows returned during the execution period.
   * 
   * @example
   * 0.0
   */
  avgReturnRows?: number;
  /**
   * @remarks
   * Average RowCache hit count during the execution period.
   * 
   * @example
   * 0.0
   */
  avgRowCacheHit?: number;
  /**
   * @remarks
   * Average number of RPC sent during the execution.
   * 
   * @example
   * 8.0
   */
  avgRpcCount?: number;
  /**
   * @remarks
   * Average Schedule event wait time (in milliseconds) during the scheduling period.
   * 
   * @example
   * 0.0
   */
  avgScheduleTime?: number;
  /**
   * @remarks
   * Average Ssstore read rows during the execution period.
   * 
   * @example
   * 0.0
   */
  avgSsstoreReadRows?: number;
  /**
   * @remarks
   * Average number of threads used of the SQL during the execution period.
   * 
   * @example
   * 3
   */
  avgUsedWorkerCount?: number;
  /**
   * @remarks
   * Average UserIO event wait time (in milliseconds) during the execution period.
   * 
   * @example
   * 0.0
   */
  avgUserIoWaitTime?: number;
  /**
   * @remarks
   * Average number of waits during the execution period.
   * 
   * @example
   * 0
   */
  avgWaitCount?: number;
  /**
   * @remarks
   * Average wait time (in milliseconds) during the execution period.
   * 
   * @example
   * 1442.49
   */
  avgWaitTime?: number;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * test_db
   */
  dbName?: string;
  /**
   * @remarks
   * Distributed plan percentage during the execution period.
   * 
   * @example
   * 100
   */
  distPlanPercentage?: number;
  /**
   * @remarks
   * Average execution count per second during the execution period.
   * 
   * @example
   * 0.31
   */
  execPs?: number;
  /**
   * @remarks
   * Total number of executions during the execution period.
   * 
   * @example
   * 1
   */
  executions?: number;
  /**
   * @remarks
   * The total number of errors during the execution period.
   * 
   * @example
   * 0
   */
  failCount?: number;
  /**
   * @remarks
   * Error percentage during the execution period.
   * 
   * @example
   * 0
   */
  failPercentage?: number;
  /**
   * @remarks
   * Local plan percentage during the execution period.
   * 
   * @example
   * 0
   */
  localPlanPercentage?: number;
  /**
   * @remarks
   * Max updated rows during the execution period.
   * 
   * @example
   * 10000
   */
  maxAffectedRows?: number;
  /**
   * @remarks
   * Max Application event wait time (in milliseconds) during the execution period
   * 
   * @example
   * 0
   */
  maxApplicationWaitTime?: number;
  /**
   * @remarks
   * Max Concurrency event wait time (in milliseconds) during the execution period
   * 
   * @example
   * 0
   */
  maxConcurrencyWaitTime?: number;
  /**
   * @remarks
   * Max CPU time.
   * 
   * @example
   * 13641.9
   */
  maxCpuTime?: number;
  /**
   * @remarks
   * Max physical read count during the execution period.
   * 
   * @example
   * 0
   */
  maxDiskReads?: number;
  /**
   * @remarks
   * Max response time.
   * 
   * @example
   * 13643.3
   */
  maxElapsedTime?: number;
  /**
   * @remarks
   * Max returned rows during the execution period.
   * 
   * @example
   * 0
   */
  maxReturnRows?: number;
  /**
   * @remarks
   * Max UserIO event wait time (in milliseconds) during the execution period
   * 
   * @example
   * 0
   */
  maxUserIoWaitTime?: number;
  /**
   * @remarks
   * Max wait time (in milliseconds) during the execution period.
   * 
   * @example
   * 3.4
   */
  maxWaitTime?: number;
  /**
   * @remarks
   * Plan hit rage during the execution period.
   * 
   * @example
   * 0
   */
  missPlanPercentage?: number;
  /**
   * @remarks
   * Missed plan count.
   * 
   * @example
   * 0
   */
  missPlans?: number;
  /**
   * @remarks
   * Remote plan percentage during the execution period.
   * 
   * @example
   * 0
   */
  remotePlanPercentage?: number;
  /**
   * @remarks
   * Remote plan count.
   * 
   * @example
   * 0
   */
  remotePlans?: number;
  /**
   * @remarks
   * Number of occurrences of code 4012 during the execution period.
   * 
   * @example
   * 0
   */
  retCode4012Count?: number;
  /**
   * @remarks
   * Number of occurrences of code 4013 during the execution period.
   * 
   * @example
   * 0
   */
  retCode4013Count?: number;
  /**
   * @remarks
   * Number of occurrences of code 5001 during the execution period.
   * 
   * @example
   * 0
   */
  retCode5001Count?: number;
  /**
   * @remarks
   * Number of occurrences of code 5024 during the execution period.
   * 
   * @example
   * 0
   */
  retCode5024Count?: number;
  /**
   * @remarks
   * Number of occurrences of code 5167 during the execution period.
   * 
   * @example
   * 0
   */
  retCode5167Count?: number;
  /**
   * @remarks
   * Number of occurrences of code 5217 during the execution period.
   * 
   * @example
   * 0
   */
  retCode5217Count?: number;
  /**
   * @remarks
   * Number of occurrences of code 6002 during the execution period.
   * 
   * @example
   * 0
   */
  retCode6002Count?: number;
  /**
   * @remarks
   * Total number of retries during the execution period.
   * 
   * @example
   * 0
   */
  retryCount?: number;
  /**
   * @remarks
   * SQL ID.
   * 
   * @example
   * 8D6E84****0B8FB1823D199E2CA1****
   */
  SQLId?: string;
  /**
   * @remarks
   * The server where the SQL is executed.
   * 
   * @example
   * i-bp1db1****8uemejio
   */
  server?: string;
  /**
   * @remarks
   * Strong consistent transaction percentage during the execution period.
   * 
   * @example
   * 100
   */
  strongConsistencyPercentage?: number;
  sumDbTime?: number;
  /**
   * @remarks
   * Total response time (in milliseconds) during the execution period.
   * 
   * @example
   * 11452126.36
   */
  sumElapsedTime?: number;
  /**
   * @remarks
   * Total logical reads.
   * 
   * @example
   * 0
   */
  sumLogicalReads?: number;
  /**
   * @remarks
   * The total wait time (in milliseconds) during the internal waiting period.
   * 
   * @example
   * 9421.73
   */
  sumWaitTime?: number;
  /**
   * @remarks
   * Table scan percentage during the execution period.
   * 
   * @example
   * 0
   */
  tableScanPercentage?: number;
  /**
   * @remarks
   * Timestamp for the sample.
   * 
   * @example
   * 2023-04-12T04:46:38Z
   */
  timestamp?: string;
  /**
   * @remarks
   * Username.
   * 
   * @example
   * test_user
   */
  userName?: string;
  /**
   * @remarks
   * Eventually consistent transaction percentage during the execution period.
   * 
   * @example
   * 0
   */
  weakConsistencyPercentage?: number;
  static names(): { [key: string]: string } {
    return {
      avgAffectedRows: 'AvgAffectedRows',
      avgApplicationWaitTime: 'AvgApplicationWaitTime',
      avgBlockCacheHit: 'AvgBlockCacheHit',
      avgBlockIndexCacheHit: 'AvgBlockIndexCacheHit',
      avgBloomFilterCacheHit: 'AvgBloomFilterCacheHit',
      avgConcurrencyWaitTime: 'AvgConcurrencyWaitTime',
      avgCpuTime: 'AvgCpuTime',
      avgDbTime: 'AvgDbTime',
      avgDecodeTime: 'AvgDecodeTime',
      avgDiskReads: 'AvgDiskReads',
      avgElapsedTime: 'AvgElapsedTime',
      avgExecuteTime: 'AvgExecuteTime',
      avgExecutorRpcCount: 'AvgExecutorRpcCount',
      avgExpectedWorkerCount: 'AvgExpectedWorkerCount',
      avgGetPlanTime: 'AvgGetPlanTime',
      avgLogicalReads: 'AvgLogicalReads',
      avgMemstoreReadRows: 'AvgMemstoreReadRows',
      avgNetTime: 'AvgNetTime',
      avgNetWaitTime: 'AvgNetWaitTime',
      avgPartitionCount: 'AvgPartitionCount',
      avgQueueTime: 'AvgQueueTime',
      avgReturnRows: 'AvgReturnRows',
      avgRowCacheHit: 'AvgRowCacheHit',
      avgRpcCount: 'AvgRpcCount',
      avgScheduleTime: 'AvgScheduleTime',
      avgSsstoreReadRows: 'AvgSsstoreReadRows',
      avgUsedWorkerCount: 'AvgUsedWorkerCount',
      avgUserIoWaitTime: 'AvgUserIoWaitTime',
      avgWaitCount: 'AvgWaitCount',
      avgWaitTime: 'AvgWaitTime',
      dbName: 'DbName',
      distPlanPercentage: 'DistPlanPercentage',
      execPs: 'ExecPs',
      executions: 'Executions',
      failCount: 'FailCount',
      failPercentage: 'FailPercentage',
      localPlanPercentage: 'LocalPlanPercentage',
      maxAffectedRows: 'MaxAffectedRows',
      maxApplicationWaitTime: 'MaxApplicationWaitTime',
      maxConcurrencyWaitTime: 'MaxConcurrencyWaitTime',
      maxCpuTime: 'MaxCpuTime',
      maxDiskReads: 'MaxDiskReads',
      maxElapsedTime: 'MaxElapsedTime',
      maxReturnRows: 'MaxReturnRows',
      maxUserIoWaitTime: 'MaxUserIoWaitTime',
      maxWaitTime: 'MaxWaitTime',
      missPlanPercentage: 'MissPlanPercentage',
      missPlans: 'MissPlans',
      remotePlanPercentage: 'RemotePlanPercentage',
      remotePlans: 'RemotePlans',
      retCode4012Count: 'RetCode4012Count',
      retCode4013Count: 'RetCode4013Count',
      retCode5001Count: 'RetCode5001Count',
      retCode5024Count: 'RetCode5024Count',
      retCode5167Count: 'RetCode5167Count',
      retCode5217Count: 'RetCode5217Count',
      retCode6002Count: 'RetCode6002Count',
      retryCount: 'RetryCount',
      SQLId: 'SQLId',
      server: 'Server',
      strongConsistencyPercentage: 'StrongConsistencyPercentage',
      sumDbTime: 'SumDbTime',
      sumElapsedTime: 'SumElapsedTime',
      sumLogicalReads: 'SumLogicalReads',
      sumWaitTime: 'SumWaitTime',
      tableScanPercentage: 'TableScanPercentage',
      timestamp: 'Timestamp',
      userName: 'UserName',
      weakConsistencyPercentage: 'WeakConsistencyPercentage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avgAffectedRows: 'number',
      avgApplicationWaitTime: 'number',
      avgBlockCacheHit: 'number',
      avgBlockIndexCacheHit: 'number',
      avgBloomFilterCacheHit: 'number',
      avgConcurrencyWaitTime: 'number',
      avgCpuTime: 'number',
      avgDbTime: 'number',
      avgDecodeTime: 'number',
      avgDiskReads: 'number',
      avgElapsedTime: 'number',
      avgExecuteTime: 'number',
      avgExecutorRpcCount: 'number',
      avgExpectedWorkerCount: 'number',
      avgGetPlanTime: 'number',
      avgLogicalReads: 'number',
      avgMemstoreReadRows: 'number',
      avgNetTime: 'number',
      avgNetWaitTime: 'number',
      avgPartitionCount: 'number',
      avgQueueTime: 'number',
      avgReturnRows: 'number',
      avgRowCacheHit: 'number',
      avgRpcCount: 'number',
      avgScheduleTime: 'number',
      avgSsstoreReadRows: 'number',
      avgUsedWorkerCount: 'number',
      avgUserIoWaitTime: 'number',
      avgWaitCount: 'number',
      avgWaitTime: 'number',
      dbName: 'string',
      distPlanPercentage: 'number',
      execPs: 'number',
      executions: 'number',
      failCount: 'number',
      failPercentage: 'number',
      localPlanPercentage: 'number',
      maxAffectedRows: 'number',
      maxApplicationWaitTime: 'number',
      maxConcurrencyWaitTime: 'number',
      maxCpuTime: 'number',
      maxDiskReads: 'number',
      maxElapsedTime: 'number',
      maxReturnRows: 'number',
      maxUserIoWaitTime: 'number',
      maxWaitTime: 'number',
      missPlanPercentage: 'number',
      missPlans: 'number',
      remotePlanPercentage: 'number',
      remotePlans: 'number',
      retCode4012Count: 'number',
      retCode4013Count: 'number',
      retCode5001Count: 'number',
      retCode5024Count: 'number',
      retCode5167Count: 'number',
      retCode5217Count: 'number',
      retCode6002Count: 'number',
      retryCount: 'number',
      SQLId: 'string',
      server: 'string',
      strongConsistencyPercentage: 'number',
      sumDbTime: 'number',
      sumElapsedTime: 'number',
      sumLogicalReads: 'number',
      sumWaitTime: 'number',
      tableScanPercentage: 'number',
      timestamp: 'string',
      userName: 'string',
      weakConsistencyPercentage: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOasSQLPlansResponseBodyDataPlanExplain extends $tea.Model {
  /**
   * @remarks
   * JSON string of the SQL execution plan.
   * 
   * @example
   * {\\"RootOperations\\":[{\\"Children\\
   */
  planJsonString?: string;
  static names(): { [key: string]: string } {
    return {
      planJsonString: 'PlanJsonString',
    };
  }

  static types(): { [key: string]: any } {
    return {
      planJsonString: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOasSQLPlansResponseBodyDataPlans extends $tea.Model {
  /**
   * @remarks
   * Average Application event waiting time (in milliseconds) during the execution period.
   * 
   * @example
   * 0.0
   */
  avgApplicationWaitTime?: number;
  /**
   * @remarks
   * Average cache read count during the execution period.
   * 
   * @example
   * 30137.03
   */
  avgBufferGets?: number;
  /**
   * @remarks
   * Average Concurrency event waiting time (in milliseconds) during the execution period.
   * 
   * @example
   * 0.0
   */
  avgConcurrencyWaitTime?: number;
  /**
   * @remarks
   * Average CPU time (in milliseconds) during the execution period.
   * 
   * @example
   * 1875.34
   */
  avgCpuTime?: number;
  /**
   * @remarks
   * The average physical read count during the execution period.
   * 
   * @example
   * 0.0
   */
  avgDiskReads?: number;
  /**
   * @remarks
   * The average physical write count during the execution period.
   * 
   * @example
   * 0.0
   */
  avgDiskWrites?: number;
  /**
   * @remarks
   * Average interval waiting time (in milliseconds) during the execution period.
   * 
   * @example
   * 1876.78
   */
  avgElapsedTime?: number;
  /**
   * @remarks
   * Average row processing waiting time (in milliseconds) during the execution period.
   * 
   * @example
   * 1.0
   */
  avgRowProcessed?: number;
  /**
   * @remarks
   * Average UserIo event waiting time (in milliseconds) during the execution period.
   * 
   * @example
   * 0.0
   */
  avgUserIoWaitTime?: number;
  /**
   * @remarks
   * Collection time.
   * 
   * @example
   * 1684368****00000
   */
  collectTimeUs?: number;
  /**
   * @remarks
   * Percentage of delayed long-running queries.
   * 
   * @example
   * 0.0
   */
  delayedLargeQueryPercentage?: number;
  /**
   * @remarks
   * The average execution count per second during the execution period.
   * 
   * @example
   * 0.31
   */
  execPs?: number;
  /**
   * @remarks
   * The total number of executions during the execution period.
   * 
   * @example
   * 1
   */
  executions?: number;
  /**
   * @remarks
   * First time to load the plan.
   * 
   * @example
   * 2023-04-12T04:46:38Z
   */
  firstLoadTime?: string;
  /**
   * @remarks
   * First loading time.
   * 
   * @example
   * 1684****03289441
   */
  firstLoadTimeUs?: number;
  /**
   * @remarks
   * Whether to hit the diagnosis.
   * 
   * @example
   * false
   */
  hitDiagnosis?: boolean;
  /**
   * @remarks
   * Hit rate.
   * 
   * @example
   * 100.0
   */
  hitPercentage?: number;
  /**
   * @remarks
   * Percentage of completed long-running queries.
   * 
   * @example
   * 0.0
   */
  largeQueryPercentage?: number;
  /**
   * @remarks
   * Merge version.
   * 
   * @example
   * 513
   */
  mergedVersion?: number;
  /**
   * @remarks
   * Database ID.
   * 
   * @example
   * 11006****828
   */
  obDbId?: number;
  /**
   * @remarks
   * Server ID.
   * 
   * @example
   * 2
   */
  obServerId?: number;
  /**
   * @remarks
   * The outline_data parameter of the SQL execution plan.
   * 
   * @example
   * /*+ BEGIN_OUTLINE_DATA INDEX(@\\"SEL$1\\
   */
  outlineData?: string;
  /**
   * @remarks
   * Outline ID.
   * 
   * @example
   * -1
   */
  outlineId?: number;
  /**
   * @remarks
   * The internal identifier of the SQL execution plan in the diagnostic system.
   * 
   * @example
   * -86290582****886880
   */
  planHash?: string;
  /**
   * @remarks
   * The ID of the plan.
   * 
   * @example
   * 590****
   */
  planId?: number;
  /**
   * @remarks
   * Plan size.
   * 
   * @example
   * 10****
   */
  planSize?: number;
  /**
   * @remarks
   * Plan type, including LOCAL, REMOTE, DIST.
   * 
   * @example
   * LOCAL
   */
  planType?: string;
  /**
   * @remarks
   * The internal unique identifier of the SQL execution plan in the diagnostic system.
   * 
   * @example
   * "52c7c53****53e61b3f7586b17****ad"
   */
  planUnionHash?: string;
  /**
   * @remarks
   * Schema version.
   * 
   * @example
   * 16838****3550464
   */
  schemaVersion?: number;
  /**
   * @remarks
   * The server where the SQL is executed.
   * 
   * @example
   * i-bp1db1a9us038****jio
   */
  server?: string;
  /**
   * @remarks
   * The ID of the backend server instance.
   * 
   * @example
   * 2
   */
  serverId?: number;
  sqlId?: string;
  /**
   * @remarks
   * Whether a full table scan is performed.
   * 
   * @example
   * false
   */
  tableScan?: boolean;
  /**
   * @remarks
   * Percentage of timeouts.
   * 
   * @example
   * 0.0
   */
  timeoutPercentage?: number;
  /**
   * @remarks
   * The unique identifier of the plan.
   * 
   * @example
   * AAAAAAAAAAI****AAFoT2QAF--7W****
   */
  uid?: string;
  static names(): { [key: string]: string } {
    return {
      avgApplicationWaitTime: 'AvgApplicationWaitTime',
      avgBufferGets: 'AvgBufferGets',
      avgConcurrencyWaitTime: 'AvgConcurrencyWaitTime',
      avgCpuTime: 'AvgCpuTime',
      avgDiskReads: 'AvgDiskReads',
      avgDiskWrites: 'AvgDiskWrites',
      avgElapsedTime: 'AvgElapsedTime',
      avgRowProcessed: 'AvgRowProcessed',
      avgUserIoWaitTime: 'AvgUserIoWaitTime',
      collectTimeUs: 'CollectTimeUs',
      delayedLargeQueryPercentage: 'DelayedLargeQueryPercentage',
      execPs: 'ExecPs',
      executions: 'Executions',
      firstLoadTime: 'FirstLoadTime',
      firstLoadTimeUs: 'FirstLoadTimeUs',
      hitDiagnosis: 'HitDiagnosis',
      hitPercentage: 'HitPercentage',
      largeQueryPercentage: 'LargeQueryPercentage',
      mergedVersion: 'MergedVersion',
      obDbId: 'ObDbId',
      obServerId: 'ObServerId',
      outlineData: 'OutlineData',
      outlineId: 'OutlineId',
      planHash: 'PlanHash',
      planId: 'PlanId',
      planSize: 'PlanSize',
      planType: 'PlanType',
      planUnionHash: 'PlanUnionHash',
      schemaVersion: 'SchemaVersion',
      server: 'Server',
      serverId: 'ServerId',
      sqlId: 'SqlId',
      tableScan: 'TableScan',
      timeoutPercentage: 'TimeoutPercentage',
      uid: 'Uid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avgApplicationWaitTime: 'number',
      avgBufferGets: 'number',
      avgConcurrencyWaitTime: 'number',
      avgCpuTime: 'number',
      avgDiskReads: 'number',
      avgDiskWrites: 'number',
      avgElapsedTime: 'number',
      avgRowProcessed: 'number',
      avgUserIoWaitTime: 'number',
      collectTimeUs: 'number',
      delayedLargeQueryPercentage: 'number',
      execPs: 'number',
      executions: 'number',
      firstLoadTime: 'string',
      firstLoadTimeUs: 'number',
      hitDiagnosis: 'boolean',
      hitPercentage: 'number',
      largeQueryPercentage: 'number',
      mergedVersion: 'number',
      obDbId: 'number',
      obServerId: 'number',
      outlineData: 'string',
      outlineId: 'number',
      planHash: 'string',
      planId: 'number',
      planSize: 'number',
      planType: 'string',
      planUnionHash: 'string',
      schemaVersion: 'number',
      server: 'string',
      serverId: 'number',
      sqlId: 'string',
      tableScan: 'boolean',
      timeoutPercentage: 'number',
      uid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOasSQLPlansResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * Average CPU time (in milliseconds) during the execution period.
   * 
   * @example
   * 1875.34
   */
  avgCpuTime?: number;
  /**
   * @remarks
   * Whether to bind the execution plan.
   * 
   * @example
   * false
   */
  bounded?: boolean;
  /**
   * @remarks
   * Execution count.
   * 
   * @example
   * 1
   */
  executions?: number;
  /**
   * @remarks
   * First loading time.
   * 
   * @example
   * 2023-04-12T04:46:38Z
   */
  firstLoadTime?: string;
  /**
   * @remarks
   * Whether to hit the diagnosis.
   * 
   * @example
   * false
   */
  hitDiagnosis?: boolean;
  /**
   * @remarks
   * Hit rate.
   * 
   * @example
   * 100.0
   */
  hitPercentage?: number;
  /**
   * @remarks
   * Merge version.
   * 
   * @example
   * 513
   */
  mergedVersion?: number;
  outlineId?: string;
  outlineStatus?: string;
  /**
   * @remarks
   * Execution plan.
   */
  planExplain?: DescribeOasSQLPlansResponseBodyDataPlanExplain;
  /**
   * @remarks
   * The internal identifier of the SQL execution plan in the diagnostic system.
   * 
   * @example
   * 1758****24913166****
   */
  planHash?: string;
  /**
   * @remarks
   * Execution plan type.
   * 
   * @example
   * LOCAL
   */
  planType?: string;
  /**
   * @remarks
   * The internal unique identifier of the SQL execution plan in the diagnostic system.
   * 
   * @example
   * "52c7c53****53e61b3f7586b17****ad"
   */
  planUnionHash?: string;
  /**
   * @remarks
   * The list of the execution plan.
   */
  plans?: DescribeOasSQLPlansResponseBodyDataPlans[];
  /**
   * @remarks
   * The SQL for the query.
   * 
   * @example
   * "select 1 from t"
   */
  querySql?: string;
  tableScan?: boolean;
  static names(): { [key: string]: string } {
    return {
      avgCpuTime: 'AvgCpuTime',
      bounded: 'Bounded',
      executions: 'Executions',
      firstLoadTime: 'FirstLoadTime',
      hitDiagnosis: 'HitDiagnosis',
      hitPercentage: 'HitPercentage',
      mergedVersion: 'MergedVersion',
      outlineId: 'OutlineId',
      outlineStatus: 'OutlineStatus',
      planExplain: 'PlanExplain',
      planHash: 'PlanHash',
      planType: 'PlanType',
      planUnionHash: 'PlanUnionHash',
      plans: 'Plans',
      querySql: 'QuerySql',
      tableScan: 'TableScan',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avgCpuTime: 'number',
      bounded: 'boolean',
      executions: 'number',
      firstLoadTime: 'string',
      hitDiagnosis: 'boolean',
      hitPercentage: 'number',
      mergedVersion: 'number',
      outlineId: 'string',
      outlineStatus: 'string',
      planExplain: DescribeOasSQLPlansResponseBodyDataPlanExplain,
      planHash: 'string',
      planType: 'string',
      planUnionHash: 'string',
      plans: { 'type': 'array', 'itemType': DescribeOasSQLPlansResponseBodyDataPlans },
      querySql: 'string',
      tableScan: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOasSlowSQLListResponseBodyDataSqlList extends $tea.Model {
  avgAffectedRows?: number;
  avgApplicationWaitTime?: number;
  avgBlockCacheHit?: number;
  avgBlockIndexCacheHit?: number;
  avgBloomFilterCacheHit?: number;
  avgConcurrencyWaitTime?: number;
  avgCpuTime?: number;
  avgDbTime?: number;
  avgDecodeTime?: number;
  avgDiskReads?: number;
  avgElapsedTime?: number;
  avgExecuteTime?: number;
  avgExecutorRpcCount?: number;
  avgExpectedWorkerCount?: number;
  avgGetPlanTime?: number;
  avgLogicalReads?: number;
  avgMemstoreReadRows?: number;
  avgNetTime?: number;
  avgNetWaitTime?: number;
  avgPartitionCount?: number;
  avgQueueTime?: number;
  avgReturnRows?: number;
  avgRowCacheHit?: number;
  avgRpcCount?: number;
  avgScheduleTime?: number;
  avgSsstoreReadRows?: number;
  avgUsedWorkerCount?: number;
  avgUserIoWaitTime?: number;
  avgWaitCount?: number;
  avgWaitTime?: number;
  clientIp?: string;
  dbName?: string;
  distPlanPercentage?: number;
  execPs?: number;
  executions?: number;
  failCount?: number;
  failPercentage?: number;
  inner?: boolean;
  localPlanPercentage?: number;
  maxAffectedRows?: number;
  maxApplicationWaitTime?: number;
  maxConcurrencyWaitTime?: number;
  maxCpuTime?: number;
  maxDiskReads?: number;
  maxElapsedTime?: number;
  maxReturnRows?: number;
  maxUserIoWaitTime?: number;
  maxWaitTime?: number;
  missPlanPercentage?: number;
  missPlans?: number;
  remotePlanPercentage?: number;
  remotePlans?: number;
  retCode4012Count?: number;
  retCode4013Count?: number;
  retCode5001Count?: number;
  retCode5024Count?: number;
  retCode5167Count?: number;
  retCode5217Count?: number;
  retCode6002Count?: number;
  retryCount?: number;
  rpcCount?: number;
  server?: string;
  serverIp?: string;
  serverPort?: number;
  sqlId?: string;
  sqlTextShort?: string;
  sqlType?: string;
  strongConsistencyPercentage?: number;
  sumDbTime?: number;
  sumElapsedTime?: number;
  sumLogicalReads?: number;
  sumWaitTime?: number;
  tableScanPercentage?: number;
  totalWaitTime?: number;
  userName?: string;
  waitEvent?: string;
  weakConsistencyPercentage?: number;
  static names(): { [key: string]: string } {
    return {
      avgAffectedRows: 'AvgAffectedRows',
      avgApplicationWaitTime: 'AvgApplicationWaitTime',
      avgBlockCacheHit: 'AvgBlockCacheHit',
      avgBlockIndexCacheHit: 'AvgBlockIndexCacheHit',
      avgBloomFilterCacheHit: 'AvgBloomFilterCacheHit',
      avgConcurrencyWaitTime: 'AvgConcurrencyWaitTime',
      avgCpuTime: 'AvgCpuTime',
      avgDbTime: 'AvgDbTime',
      avgDecodeTime: 'AvgDecodeTime',
      avgDiskReads: 'AvgDiskReads',
      avgElapsedTime: 'AvgElapsedTime',
      avgExecuteTime: 'AvgExecuteTime',
      avgExecutorRpcCount: 'AvgExecutorRpcCount',
      avgExpectedWorkerCount: 'AvgExpectedWorkerCount',
      avgGetPlanTime: 'AvgGetPlanTime',
      avgLogicalReads: 'AvgLogicalReads',
      avgMemstoreReadRows: 'AvgMemstoreReadRows',
      avgNetTime: 'AvgNetTime',
      avgNetWaitTime: 'AvgNetWaitTime',
      avgPartitionCount: 'AvgPartitionCount',
      avgQueueTime: 'AvgQueueTime',
      avgReturnRows: 'AvgReturnRows',
      avgRowCacheHit: 'AvgRowCacheHit',
      avgRpcCount: 'AvgRpcCount',
      avgScheduleTime: 'AvgScheduleTime',
      avgSsstoreReadRows: 'AvgSsstoreReadRows',
      avgUsedWorkerCount: 'AvgUsedWorkerCount',
      avgUserIoWaitTime: 'AvgUserIoWaitTime',
      avgWaitCount: 'AvgWaitCount',
      avgWaitTime: 'AvgWaitTime',
      clientIp: 'ClientIp',
      dbName: 'DbName',
      distPlanPercentage: 'DistPlanPercentage',
      execPs: 'ExecPs',
      executions: 'Executions',
      failCount: 'FailCount',
      failPercentage: 'FailPercentage',
      inner: 'Inner',
      localPlanPercentage: 'LocalPlanPercentage',
      maxAffectedRows: 'MaxAffectedRows',
      maxApplicationWaitTime: 'MaxApplicationWaitTime',
      maxConcurrencyWaitTime: 'MaxConcurrencyWaitTime',
      maxCpuTime: 'MaxCpuTime',
      maxDiskReads: 'MaxDiskReads',
      maxElapsedTime: 'MaxElapsedTime',
      maxReturnRows: 'MaxReturnRows',
      maxUserIoWaitTime: 'MaxUserIoWaitTime',
      maxWaitTime: 'MaxWaitTime',
      missPlanPercentage: 'MissPlanPercentage',
      missPlans: 'MissPlans',
      remotePlanPercentage: 'RemotePlanPercentage',
      remotePlans: 'RemotePlans',
      retCode4012Count: 'RetCode4012Count',
      retCode4013Count: 'RetCode4013Count',
      retCode5001Count: 'RetCode5001Count',
      retCode5024Count: 'RetCode5024Count',
      retCode5167Count: 'RetCode5167Count',
      retCode5217Count: 'RetCode5217Count',
      retCode6002Count: 'RetCode6002Count',
      retryCount: 'RetryCount',
      rpcCount: 'RpcCount',
      server: 'Server',
      serverIp: 'ServerIp',
      serverPort: 'ServerPort',
      sqlId: 'SqlId',
      sqlTextShort: 'SqlTextShort',
      sqlType: 'SqlType',
      strongConsistencyPercentage: 'StrongConsistencyPercentage',
      sumDbTime: 'SumDbTime',
      sumElapsedTime: 'SumElapsedTime',
      sumLogicalReads: 'SumLogicalReads',
      sumWaitTime: 'SumWaitTime',
      tableScanPercentage: 'TableScanPercentage',
      totalWaitTime: 'TotalWaitTime',
      userName: 'UserName',
      waitEvent: 'WaitEvent',
      weakConsistencyPercentage: 'WeakConsistencyPercentage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avgAffectedRows: 'number',
      avgApplicationWaitTime: 'number',
      avgBlockCacheHit: 'number',
      avgBlockIndexCacheHit: 'number',
      avgBloomFilterCacheHit: 'number',
      avgConcurrencyWaitTime: 'number',
      avgCpuTime: 'number',
      avgDbTime: 'number',
      avgDecodeTime: 'number',
      avgDiskReads: 'number',
      avgElapsedTime: 'number',
      avgExecuteTime: 'number',
      avgExecutorRpcCount: 'number',
      avgExpectedWorkerCount: 'number',
      avgGetPlanTime: 'number',
      avgLogicalReads: 'number',
      avgMemstoreReadRows: 'number',
      avgNetTime: 'number',
      avgNetWaitTime: 'number',
      avgPartitionCount: 'number',
      avgQueueTime: 'number',
      avgReturnRows: 'number',
      avgRowCacheHit: 'number',
      avgRpcCount: 'number',
      avgScheduleTime: 'number',
      avgSsstoreReadRows: 'number',
      avgUsedWorkerCount: 'number',
      avgUserIoWaitTime: 'number',
      avgWaitCount: 'number',
      avgWaitTime: 'number',
      clientIp: 'string',
      dbName: 'string',
      distPlanPercentage: 'number',
      execPs: 'number',
      executions: 'number',
      failCount: 'number',
      failPercentage: 'number',
      inner: 'boolean',
      localPlanPercentage: 'number',
      maxAffectedRows: 'number',
      maxApplicationWaitTime: 'number',
      maxConcurrencyWaitTime: 'number',
      maxCpuTime: 'number',
      maxDiskReads: 'number',
      maxElapsedTime: 'number',
      maxReturnRows: 'number',
      maxUserIoWaitTime: 'number',
      maxWaitTime: 'number',
      missPlanPercentage: 'number',
      missPlans: 'number',
      remotePlanPercentage: 'number',
      remotePlans: 'number',
      retCode4012Count: 'number',
      retCode4013Count: 'number',
      retCode5001Count: 'number',
      retCode5024Count: 'number',
      retCode5167Count: 'number',
      retCode5217Count: 'number',
      retCode6002Count: 'number',
      retryCount: 'number',
      rpcCount: 'number',
      server: 'string',
      serverIp: 'string',
      serverPort: 'number',
      sqlId: 'string',
      sqlTextShort: 'string',
      sqlType: 'string',
      strongConsistencyPercentage: 'number',
      sumDbTime: 'number',
      sumElapsedTime: 'number',
      sumLogicalReads: 'number',
      sumWaitTime: 'number',
      tableScanPercentage: 'number',
      totalWaitTime: 'number',
      userName: 'string',
      waitEvent: 'string',
      weakConsistencyPercentage: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOasSlowSQLListResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * Average updated rows during the execution period.
   * 
   * @example
   * 9978.75
   */
  avgAffectedRows?: number;
  /**
   * @remarks
   * Average Application event wait time (in milliseconds) during the client waiting period.
   * 
   * @example
   * 0.0
   */
  avgApplicationWaitTime?: number;
  /**
   * @remarks
   * Average BlockCache hit count during the execution period.
   * 
   * @example
   * 0.0
   */
  avgBlockCacheHit?: number;
  /**
   * @remarks
   * Average BlockIndexCache hit count during the execution period.
   * 
   * @example
   * 0.0
   */
  avgBlockIndexCacheHit?: number;
  /**
   * @remarks
   * Average BloomFilterCache hit count during the execution period.
   * 
   * @example
   * 0.0
   */
  avgBloomFilterCacheHit?: number;
  /**
   * @remarks
   * Average Concurrency event wait time (in milliseconds) during the execution period.
   * 
   * @example
   * 0.0
   */
  avgConcurrencyWaitTime?: number;
  /**
   * @remarks
   * Average CPU time (in milliseconds) during the execution period.
   * 
   * @example
   * 1875.34
   */
  avgCpuTime?: number;
  avgDbTime?: number;
  /**
   * @remarks
   * Average syntax parsing time (in milliseconds) during the execution period.
   * 
   * @example
   * 0.0
   */
  avgDecodeTime?: number;
  /**
   * @remarks
   * Average physical read count during the execution period.
   * 
   * @example
   * 0.0
   */
  avgDiskReads?: number;
  /**
   * @remarks
   * Average response time (in milliseconds) during the execution period.
   * 
   * @example
   * 1876.78
   */
  avgElapsedTime?: number;
  /**
   * @remarks
   * Average plan execution time (in milliseconds) during the execution period.
   * 
   * @example
   * 1895.7
   */
  avgExecuteTime?: number;
  /**
   * @remarks
   * Average number of RPC requests executed during the execution period.
   * 
   * @example
   * 0.0
   */
  avgExecutorRpcCount?: number;
  /**
   * @remarks
   * Average degree of parallelism during the execution period.
   * 
   * @example
   * 3
   */
  avgExpectedWorkerCount?: number;
  /**
   * @remarks
   * Average plan generation time (in milliseconds) during the execution period.
   * 
   * @example
   * 0.0
   */
  avgGetPlanTime?: number;
  /**
   * @remarks
   * Average logical reads of the SQL during the execution period.
   * 
   * @example
   * 0.0
   */
  avgLogicalReads?: number;
  /**
   * @remarks
   * Strong consistent transaction percentage during the execution period.
   * 
   * @example
   * 0.0
   */
  avgMemstoreReadRows?: number;
  /**
   * @remarks
   * Average network transmission time (in milliseconds) during the execution period.
   * 
   * @example
   * 0.0
   */
  avgNetTime?: number;
  /**
   * @remarks
   * Average network enqueue time (in milliseconds) during the network waiting period.
   * 
   * @example
   * 0.0
   */
  avgNetWaitTime?: number;
  /**
   * @remarks
   * Average number of partition accessed during the execution period.
   * 
   * @example
   * 1.0
   */
  avgPartitionCount?: number;
  /**
   * @remarks
   * Average queueing time (in milliseconds) during the execution period.
   * 
   * @example
   * 0.01
   */
  avgQueueTime?: number;
  /**
   * @remarks
   * Average number of rows returned during the execution period.
   * 
   * @example
   * 0.0
   */
  avgReturnRows?: number;
  /**
   * @remarks
   * Average RowCache hit count during the execution period.
   * 
   * @example
   * 0.0
   */
  avgRowCacheHit?: number;
  /**
   * @remarks
   * Average number of RPC sent during the execution.
   * 
   * @example
   * 8.0
   */
  avgRpcCount?: number;
  /**
   * @remarks
   * Average Schedule event wait time (in milliseconds) during the scheduling period.
   * 
   * @example
   * 0.0
   */
  avgScheduleTime?: number;
  /**
   * @remarks
   * Eventually consistent transaction percentage during the execution period.
   * 
   * @example
   * 0.0
   */
  avgSsstoreReadRows?: number;
  /**
   * @remarks
   * Average number of threads used of the SQL during the execution period.
   * 
   * @example
   * 3
   */
  avgUsedWorkerCount?: number;
  /**
   * @remarks
   * Average UserIO event wait time (in milliseconds) during the execution period.
   * 
   * @example
   * 0.0
   */
  avgUserIoWaitTime?: number;
  /**
   * @remarks
   * Average number of waits during the execution period.
   * 
   * @example
   * 0.0
   */
  avgWaitCount?: number;
  /**
   * @remarks
   * Average wait time (in milliseconds) during the execution period.
   * 
   * @example
   * 1.42
   */
  avgWaitTime?: number;
  /**
   * @remarks
   * Client IP.
   * 
   * @example
   * 1*2.***.1*3.***
   */
  clientIp?: string;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * test_db
   */
  dbName?: string;
  /**
   * @remarks
   * Distributed plan percentage during the execution period.
   * 
   * @example
   * 100.0
   */
  distPlanPercentage?: number;
  dynamicSql?: boolean;
  /**
   * @remarks
   * Average execution count per second during the execution period.
   * 
   * @example
   * 0.31
   */
  execPs?: number;
  /**
   * @remarks
   * Total number of executions during the execution period.
   * 
   * @example
   * 1
   */
  executions?: number;
  /**
   * @remarks
   * Average number of partition accessed during the execution period.
   * 
   * @example
   * 0
   */
  failCount?: number;
  /**
   * @remarks
   * Error percentage during the execution period.
   * 
   * @example
   * 0.0
   */
  failPercentage?: number;
  /**
   * @remarks
   * Whether an internal SQL.
   * 
   * @example
   * false
   */
  inner?: boolean;
  /**
   * @remarks
   * Local plan percentage during the execution period.
   * 
   * @example
   * 0.0
   */
  localPlanPercentage?: number;
  /**
   * @remarks
   * Max affected rows during the execution period.
   * 
   * @example
   * 10000.0
   */
  maxAffectedRows?: number;
  /**
   * @remarks
   * Max Application event wait time (in milliseconds) during the execution period
   * 
   * @example
   * 0.0
   */
  maxApplicationWaitTime?: number;
  /**
   * @remarks
   * Max Concurrency event wait time (in milliseconds) during the execution period
   * 
   * @example
   * 0.0
   */
  maxConcurrencyWaitTime?: number;
  /**
   * @remarks
   * Max CPU time.
   * 
   * @example
   * 257.967
   */
  maxCpuTime?: number;
  /**
   * @remarks
   * Max physical read count during the execution period.
   * 
   * @example
   * 0.0
   */
  maxDiskReads?: number;
  /**
   * @remarks
   * Max response time during the execution period.
   * 
   * @example
   * 260.044
   */
  maxElapsedTime?: number;
  /**
   * @remarks
   * Max returned rows during the execution period.
   * 
   * @example
   * 0.0
   */
  maxReturnRows?: number;
  /**
   * @remarks
   * Max UserIO event wait time (in milliseconds) during the execution period.
   * 
   * @example
   * 0.0
   */
  maxUserIoWaitTime?: number;
  /**
   * @remarks
   * Max wait time (in milliseconds) during the execution period.
   * 
   * @example
   * 3.4
   */
  maxWaitTime?: number;
  /**
   * @remarks
   * Plan hit rage during the execution period.
   * 
   * @example
   * 0.0
   */
  missPlanPercentage?: number;
  /**
   * @remarks
   * Missed hit count of the execution plan during the execution period.
   * 
   * @example
   * 0
   */
  missPlans?: number;
  /**
   * @remarks
   * Remote plan percentage during the execution period.
   * 
   * @example
   * 0.0
   */
  remotePlanPercentage?: number;
  /**
   * @remarks
   * Remote execution count during the execution period.
   * 
   * @example
   * 0
   */
  remotePlans?: number;
  /**
   * @remarks
   * Number of occurrences of code 4012 during the execution period.
   * 
   * @example
   * 0
   */
  retCode4012Count?: number;
  /**
   * @remarks
   * Number of occurrences of code 4013 during the execution period.
   * 
   * @example
   * 0
   */
  retCode4013Count?: number;
  /**
   * @remarks
   * Number of occurrences of code 5001 during the execution period.
   * 
   * @example
   * 0
   */
  retCode5001Count?: number;
  /**
   * @remarks
   * Number of occurrences of code 5024 during the execution period.
   * 
   * @example
   * 0
   */
  retCode5024Count?: number;
  /**
   * @remarks
   * Number of occurrences of code 5167 during the execution period.
   * 
   * @example
   * 0
   */
  retCode5167Count?: number;
  /**
   * @remarks
   * Number of occurrences of code 5217 during the execution period.
   * 
   * @example
   * 0
   */
  retCode5217Count?: number;
  /**
   * @remarks
   * Number of occurrences of code 6002 during the execution period.
   * 
   * @example
   * 0
   */
  retCode6002Count?: number;
  /**
   * @remarks
   * Total number of retries during the execution period.
   * 
   * @example
   * 5
   */
  retryCount?: number;
  /**
   * @remarks
   * RPC count during the execution period.
   * 
   * @example
   * 0
   */
  rpcCount?: number;
  /**
   * @remarks
   * The server where the SQL is executed.
   * 
   * @example
   * i-bp1db1a**s038**mej**
   */
  server?: string;
  /**
   * @remarks
   * The IP address of the server.
   * 
   * @example
   * i-bp1db1a**s038**mej**
   */
  serverIp?: string;
  /**
   * @remarks
   * The server port where the SQL is executed.
   * 
   * @example
   * 10110
   */
  serverPort?: number;
  /**
   * @remarks
   * SQL ID.
   * 
   * @example
   * 8D6E84****0B8FB1823D199E2CA1****
   */
  sqlId?: string;
  sqlList?: DescribeOasSlowSQLListResponseBodyDataSqlList[];
  /**
   * @remarks
   * SQL text (the first 100 characters).
   * 
   * @example
   * select a from b where
   */
  sqlTextShort?: string;
  /**
   * @remarks
   * SQL type.
   * 
   * @example
   * select
   */
  sqlType?: string;
  /**
   * @remarks
   * Strong consistent transaction percentage during the execution period.
   * 
   * @example
   * 100.0
   */
  strongConsistencyPercentage?: number;
  sumDbTime?: number;
  /**
   * @remarks
   * Total response time (in milliseconds) during the execution period.
   * 
   * @example
   * 11452126.36
   */
  sumElapsedTime?: number;
  /**
   * @remarks
   * Total logical reads of the SQL during the execution period.
   * 
   * @example
   * 0.0
   */
  sumLogicalReads?: number;
  /**
   * @remarks
   * The total wait time (in milliseconds) during the internal waiting period.
   * 
   * @example
   * 9421.73
   */
  sumWaitTime?: number;
  /**
   * @remarks
   * Table scan percentage during the execution period.
   * 
   * @example
   * 0.0
   */
  tableScanPercentage?: number;
  /**
   * @remarks
   * Total wait time during the execution period.
   * 
   * @example
   * 10.966
   */
  totalWaitTime?: number;
  /**
   * @remarks
   * Username.
   * 
   * @example
   * test_user
   */
  userName?: string;
  /**
   * @remarks
   * Longest wait event during the execution period.
   * 
   * @example
   * none
   */
  waitEvent?: string;
  /**
   * @remarks
   * Eventually consistent transaction percentage during the execution period.
   * 
   * @example
   * 0.0
   */
  weakConsistencyPercentage?: number;
  static names(): { [key: string]: string } {
    return {
      avgAffectedRows: 'AvgAffectedRows',
      avgApplicationWaitTime: 'AvgApplicationWaitTime',
      avgBlockCacheHit: 'AvgBlockCacheHit',
      avgBlockIndexCacheHit: 'AvgBlockIndexCacheHit',
      avgBloomFilterCacheHit: 'AvgBloomFilterCacheHit',
      avgConcurrencyWaitTime: 'AvgConcurrencyWaitTime',
      avgCpuTime: 'AvgCpuTime',
      avgDbTime: 'AvgDbTime',
      avgDecodeTime: 'AvgDecodeTime',
      avgDiskReads: 'AvgDiskReads',
      avgElapsedTime: 'AvgElapsedTime',
      avgExecuteTime: 'AvgExecuteTime',
      avgExecutorRpcCount: 'AvgExecutorRpcCount',
      avgExpectedWorkerCount: 'AvgExpectedWorkerCount',
      avgGetPlanTime: 'AvgGetPlanTime',
      avgLogicalReads: 'AvgLogicalReads',
      avgMemstoreReadRows: 'AvgMemstoreReadRows',
      avgNetTime: 'AvgNetTime',
      avgNetWaitTime: 'AvgNetWaitTime',
      avgPartitionCount: 'AvgPartitionCount',
      avgQueueTime: 'AvgQueueTime',
      avgReturnRows: 'AvgReturnRows',
      avgRowCacheHit: 'AvgRowCacheHit',
      avgRpcCount: 'AvgRpcCount',
      avgScheduleTime: 'AvgScheduleTime',
      avgSsstoreReadRows: 'AvgSsstoreReadRows',
      avgUsedWorkerCount: 'AvgUsedWorkerCount',
      avgUserIoWaitTime: 'AvgUserIoWaitTime',
      avgWaitCount: 'AvgWaitCount',
      avgWaitTime: 'AvgWaitTime',
      clientIp: 'ClientIp',
      dbName: 'DbName',
      distPlanPercentage: 'DistPlanPercentage',
      dynamicSql: 'DynamicSql',
      execPs: 'ExecPs',
      executions: 'Executions',
      failCount: 'FailCount',
      failPercentage: 'FailPercentage',
      inner: 'Inner',
      localPlanPercentage: 'LocalPlanPercentage',
      maxAffectedRows: 'MaxAffectedRows',
      maxApplicationWaitTime: 'MaxApplicationWaitTime',
      maxConcurrencyWaitTime: 'MaxConcurrencyWaitTime',
      maxCpuTime: 'MaxCpuTime',
      maxDiskReads: 'MaxDiskReads',
      maxElapsedTime: 'MaxElapsedTime',
      maxReturnRows: 'MaxReturnRows',
      maxUserIoWaitTime: 'MaxUserIoWaitTime',
      maxWaitTime: 'MaxWaitTime',
      missPlanPercentage: 'MissPlanPercentage',
      missPlans: 'MissPlans',
      remotePlanPercentage: 'RemotePlanPercentage',
      remotePlans: 'RemotePlans',
      retCode4012Count: 'RetCode4012Count',
      retCode4013Count: 'RetCode4013Count',
      retCode5001Count: 'RetCode5001Count',
      retCode5024Count: 'RetCode5024Count',
      retCode5167Count: 'RetCode5167Count',
      retCode5217Count: 'RetCode5217Count',
      retCode6002Count: 'RetCode6002Count',
      retryCount: 'RetryCount',
      rpcCount: 'RpcCount',
      server: 'Server',
      serverIp: 'ServerIp',
      serverPort: 'ServerPort',
      sqlId: 'SqlId',
      sqlList: 'SqlList',
      sqlTextShort: 'SqlTextShort',
      sqlType: 'SqlType',
      strongConsistencyPercentage: 'StrongConsistencyPercentage',
      sumDbTime: 'SumDbTime',
      sumElapsedTime: 'SumElapsedTime',
      sumLogicalReads: 'SumLogicalReads',
      sumWaitTime: 'SumWaitTime',
      tableScanPercentage: 'TableScanPercentage',
      totalWaitTime: 'TotalWaitTime',
      userName: 'UserName',
      waitEvent: 'WaitEvent',
      weakConsistencyPercentage: 'WeakConsistencyPercentage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avgAffectedRows: 'number',
      avgApplicationWaitTime: 'number',
      avgBlockCacheHit: 'number',
      avgBlockIndexCacheHit: 'number',
      avgBloomFilterCacheHit: 'number',
      avgConcurrencyWaitTime: 'number',
      avgCpuTime: 'number',
      avgDbTime: 'number',
      avgDecodeTime: 'number',
      avgDiskReads: 'number',
      avgElapsedTime: 'number',
      avgExecuteTime: 'number',
      avgExecutorRpcCount: 'number',
      avgExpectedWorkerCount: 'number',
      avgGetPlanTime: 'number',
      avgLogicalReads: 'number',
      avgMemstoreReadRows: 'number',
      avgNetTime: 'number',
      avgNetWaitTime: 'number',
      avgPartitionCount: 'number',
      avgQueueTime: 'number',
      avgReturnRows: 'number',
      avgRowCacheHit: 'number',
      avgRpcCount: 'number',
      avgScheduleTime: 'number',
      avgSsstoreReadRows: 'number',
      avgUsedWorkerCount: 'number',
      avgUserIoWaitTime: 'number',
      avgWaitCount: 'number',
      avgWaitTime: 'number',
      clientIp: 'string',
      dbName: 'string',
      distPlanPercentage: 'number',
      dynamicSql: 'boolean',
      execPs: 'number',
      executions: 'number',
      failCount: 'number',
      failPercentage: 'number',
      inner: 'boolean',
      localPlanPercentage: 'number',
      maxAffectedRows: 'number',
      maxApplicationWaitTime: 'number',
      maxConcurrencyWaitTime: 'number',
      maxCpuTime: 'number',
      maxDiskReads: 'number',
      maxElapsedTime: 'number',
      maxReturnRows: 'number',
      maxUserIoWaitTime: 'number',
      maxWaitTime: 'number',
      missPlanPercentage: 'number',
      missPlans: 'number',
      remotePlanPercentage: 'number',
      remotePlans: 'number',
      retCode4012Count: 'number',
      retCode4013Count: 'number',
      retCode5001Count: 'number',
      retCode5024Count: 'number',
      retCode5167Count: 'number',
      retCode5217Count: 'number',
      retCode6002Count: 'number',
      retryCount: 'number',
      rpcCount: 'number',
      server: 'string',
      serverIp: 'string',
      serverPort: 'number',
      sqlId: 'string',
      sqlList: { 'type': 'array', 'itemType': DescribeOasSlowSQLListResponseBodyDataSqlList },
      sqlTextShort: 'string',
      sqlType: 'string',
      strongConsistencyPercentage: 'number',
      sumDbTime: 'number',
      sumElapsedTime: 'number',
      sumLogicalReads: 'number',
      sumWaitTime: 'number',
      tableScanPercentage: 'number',
      totalWaitTime: 'number',
      userName: 'string',
      waitEvent: 'string',
      weakConsistencyPercentage: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOasTopSQLListResponseBodyDataSqlList extends $tea.Model {
  avgAffectedRows?: number;
  avgApplicationWaitTime?: number;
  avgBlockCacheHit?: number;
  avgBlockIndexCacheHit?: number;
  avgBloomFilterCacheHit?: number;
  avgConcurrencyWaitTime?: number;
  avgCpuTime?: number;
  avgDbTime?: number;
  avgDecodeTime?: number;
  avgDiskReads?: number;
  avgElapsedTime?: number;
  avgExecuteTime?: number;
  avgExecutorRpcCount?: number;
  avgExpectedWorkerCount?: number;
  avgGetPlanTime?: number;
  avgLogicalReads?: number;
  avgMemstoreReadRows?: number;
  avgNetTime?: number;
  avgNetWaitTime?: number;
  avgPartitionCount?: number;
  avgQueueTime?: number;
  avgReturnRows?: number;
  avgRowCacheHit?: number;
  avgRpcCount?: number;
  avgScheduleTime?: number;
  avgSsstoreReadRows?: number;
  avgUsedWorkerCount?: number;
  avgUserIoWaitTime?: number;
  avgWaitCount?: number;
  avgWaitTime?: number;
  clientIp?: string;
  cpuPercentage?: number;
  dbName?: string;
  distPlanPercentage?: number;
  execPs?: number;
  executions?: number;
  failCount?: number;
  failPercentage?: number;
  inner?: boolean;
  localPlanPercentage?: number;
  maxAffectedRows?: number;
  maxApplicationWaitTime?: number;
  maxConcurrencyWaitTime?: number;
  maxCpuTime?: number;
  maxDiskReads?: number;
  maxElapsedTime?: number;
  maxReturnRows?: number;
  maxUserIoWaitTime?: number;
  maxWaitTime?: number;
  missPlanPercentage?: number;
  missPlans?: number;
  remotePlanPercentage?: number;
  remotePlans?: number;
  retCode4012Count?: number;
  retCode4013Count?: number;
  retCode5001Count?: number;
  retCode5024Count?: number;
  retCode5167Count?: number;
  retCode5217Count?: number;
  retCode6002Count?: number;
  retryCount?: number;
  rpcCount?: number;
  server?: string;
  serverIp?: string;
  serverPort?: number;
  sqlId?: string;
  sqlTextShort?: string;
  sqlType?: string;
  strongConsistencyPercentage?: number;
  sumDbTime?: number;
  sumElapsedTime?: number;
  sumLogicalReads?: number;
  sumWaitTime?: number;
  tableScanPercentage?: number;
  totalWaitTime?: number;
  userName?: string;
  waitEvent?: string;
  weakConsistencyPercentage?: number;
  static names(): { [key: string]: string } {
    return {
      avgAffectedRows: 'AvgAffectedRows',
      avgApplicationWaitTime: 'AvgApplicationWaitTime',
      avgBlockCacheHit: 'AvgBlockCacheHit',
      avgBlockIndexCacheHit: 'AvgBlockIndexCacheHit',
      avgBloomFilterCacheHit: 'AvgBloomFilterCacheHit',
      avgConcurrencyWaitTime: 'AvgConcurrencyWaitTime',
      avgCpuTime: 'AvgCpuTime',
      avgDbTime: 'AvgDbTime',
      avgDecodeTime: 'AvgDecodeTime',
      avgDiskReads: 'AvgDiskReads',
      avgElapsedTime: 'AvgElapsedTime',
      avgExecuteTime: 'AvgExecuteTime',
      avgExecutorRpcCount: 'AvgExecutorRpcCount',
      avgExpectedWorkerCount: 'AvgExpectedWorkerCount',
      avgGetPlanTime: 'AvgGetPlanTime',
      avgLogicalReads: 'AvgLogicalReads',
      avgMemstoreReadRows: 'AvgMemstoreReadRows',
      avgNetTime: 'AvgNetTime',
      avgNetWaitTime: 'AvgNetWaitTime',
      avgPartitionCount: 'AvgPartitionCount',
      avgQueueTime: 'AvgQueueTime',
      avgReturnRows: 'AvgReturnRows',
      avgRowCacheHit: 'AvgRowCacheHit',
      avgRpcCount: 'AvgRpcCount',
      avgScheduleTime: 'AvgScheduleTime',
      avgSsstoreReadRows: 'AvgSsstoreReadRows',
      avgUsedWorkerCount: 'AvgUsedWorkerCount',
      avgUserIoWaitTime: 'AvgUserIoWaitTime',
      avgWaitCount: 'AvgWaitCount',
      avgWaitTime: 'AvgWaitTime',
      clientIp: 'ClientIp',
      cpuPercentage: 'CpuPercentage',
      dbName: 'DbName',
      distPlanPercentage: 'DistPlanPercentage',
      execPs: 'ExecPs',
      executions: 'Executions',
      failCount: 'FailCount',
      failPercentage: 'FailPercentage',
      inner: 'Inner',
      localPlanPercentage: 'LocalPlanPercentage',
      maxAffectedRows: 'MaxAffectedRows',
      maxApplicationWaitTime: 'MaxApplicationWaitTime',
      maxConcurrencyWaitTime: 'MaxConcurrencyWaitTime',
      maxCpuTime: 'MaxCpuTime',
      maxDiskReads: 'MaxDiskReads',
      maxElapsedTime: 'MaxElapsedTime',
      maxReturnRows: 'MaxReturnRows',
      maxUserIoWaitTime: 'MaxUserIoWaitTime',
      maxWaitTime: 'MaxWaitTime',
      missPlanPercentage: 'MissPlanPercentage',
      missPlans: 'MissPlans',
      remotePlanPercentage: 'RemotePlanPercentage',
      remotePlans: 'RemotePlans',
      retCode4012Count: 'RetCode4012Count',
      retCode4013Count: 'RetCode4013Count',
      retCode5001Count: 'RetCode5001Count',
      retCode5024Count: 'RetCode5024Count',
      retCode5167Count: 'RetCode5167Count',
      retCode5217Count: 'RetCode5217Count',
      retCode6002Count: 'RetCode6002Count',
      retryCount: 'RetryCount',
      rpcCount: 'RpcCount',
      server: 'Server',
      serverIp: 'ServerIp',
      serverPort: 'ServerPort',
      sqlId: 'SqlId',
      sqlTextShort: 'SqlTextShort',
      sqlType: 'SqlType',
      strongConsistencyPercentage: 'StrongConsistencyPercentage',
      sumDbTime: 'SumDbTime',
      sumElapsedTime: 'SumElapsedTime',
      sumLogicalReads: 'SumLogicalReads',
      sumWaitTime: 'SumWaitTime',
      tableScanPercentage: 'TableScanPercentage',
      totalWaitTime: 'TotalWaitTime',
      userName: 'UserName',
      waitEvent: 'WaitEvent',
      weakConsistencyPercentage: 'WeakConsistencyPercentage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avgAffectedRows: 'number',
      avgApplicationWaitTime: 'number',
      avgBlockCacheHit: 'number',
      avgBlockIndexCacheHit: 'number',
      avgBloomFilterCacheHit: 'number',
      avgConcurrencyWaitTime: 'number',
      avgCpuTime: 'number',
      avgDbTime: 'number',
      avgDecodeTime: 'number',
      avgDiskReads: 'number',
      avgElapsedTime: 'number',
      avgExecuteTime: 'number',
      avgExecutorRpcCount: 'number',
      avgExpectedWorkerCount: 'number',
      avgGetPlanTime: 'number',
      avgLogicalReads: 'number',
      avgMemstoreReadRows: 'number',
      avgNetTime: 'number',
      avgNetWaitTime: 'number',
      avgPartitionCount: 'number',
      avgQueueTime: 'number',
      avgReturnRows: 'number',
      avgRowCacheHit: 'number',
      avgRpcCount: 'number',
      avgScheduleTime: 'number',
      avgSsstoreReadRows: 'number',
      avgUsedWorkerCount: 'number',
      avgUserIoWaitTime: 'number',
      avgWaitCount: 'number',
      avgWaitTime: 'number',
      clientIp: 'string',
      cpuPercentage: 'number',
      dbName: 'string',
      distPlanPercentage: 'number',
      execPs: 'number',
      executions: 'number',
      failCount: 'number',
      failPercentage: 'number',
      inner: 'boolean',
      localPlanPercentage: 'number',
      maxAffectedRows: 'number',
      maxApplicationWaitTime: 'number',
      maxConcurrencyWaitTime: 'number',
      maxCpuTime: 'number',
      maxDiskReads: 'number',
      maxElapsedTime: 'number',
      maxReturnRows: 'number',
      maxUserIoWaitTime: 'number',
      maxWaitTime: 'number',
      missPlanPercentage: 'number',
      missPlans: 'number',
      remotePlanPercentage: 'number',
      remotePlans: 'number',
      retCode4012Count: 'number',
      retCode4013Count: 'number',
      retCode5001Count: 'number',
      retCode5024Count: 'number',
      retCode5167Count: 'number',
      retCode5217Count: 'number',
      retCode6002Count: 'number',
      retryCount: 'number',
      rpcCount: 'number',
      server: 'string',
      serverIp: 'string',
      serverPort: 'number',
      sqlId: 'string',
      sqlTextShort: 'string',
      sqlType: 'string',
      strongConsistencyPercentage: 'number',
      sumDbTime: 'number',
      sumElapsedTime: 'number',
      sumLogicalReads: 'number',
      sumWaitTime: 'number',
      tableScanPercentage: 'number',
      totalWaitTime: 'number',
      userName: 'string',
      waitEvent: 'string',
      weakConsistencyPercentage: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOasTopSQLListResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * Average updated rows during the execution period.
   * 
   * @example
   * 9978.75
   */
  avgAffectedRows?: number;
  /**
   * @remarks
   * Average Application event wait time (in milliseconds) during the execution period.
   * 
   * @example
   * 0.0
   */
  avgApplicationWaitTime?: number;
  /**
   * @remarks
   * Average BlockCache hit count during the execution period.
   * 
   * @example
   * 0.0
   */
  avgBlockCacheHit?: number;
  /**
   * @remarks
   * Average BlockIndexCache hit count during the execution period.
   * 
   * @example
   * 0.0
   */
  avgBlockIndexCacheHit?: number;
  /**
   * @remarks
   * Average BloomFilterCache hit count during the execution period.
   * 
   * @example
   * 0.0
   */
  avgBloomFilterCacheHit?: number;
  /**
   * @remarks
   * Average Concurrency event wait time (in milliseconds) during the execution period.
   * 
   * @example
   * 0.0
   */
  avgConcurrencyWaitTime?: number;
  /**
   * @remarks
   * Average CPU time (in milliseconds) during the execution period.
   * 
   * @example
   * 1875.34
   */
  avgCpuTime?: number;
  avgDbTime?: number;
  /**
   * @remarks
   * Average syntax parsing time (in milliseconds) during the execution period.
   * 
   * @example
   * 0.0
   */
  avgDecodeTime?: number;
  /**
   * @remarks
   * Average physical read count during the execution period.
   * 
   * @example
   * 0.0
   */
  avgDiskReads?: number;
  /**
   * @remarks
   * Average response time (in milliseconds) during the execution period.
   * 
   * @example
   * 903.29
   */
  avgElapsedTime?: number;
  /**
   * @remarks
   * Average plan execution time (in milliseconds) during the execution period.
   * 
   * @example
   * 1895.7
   */
  avgExecuteTime?: number;
  /**
   * @remarks
   * Average number of RPC requests executed during the execution period.
   * 
   * @example
   * 0.0
   */
  avgExecutorRpcCount?: number;
  /**
   * @remarks
   * Average degree of parallelism during the execution period.
   * 
   * @example
   * 3
   */
  avgExpectedWorkerCount?: number;
  /**
   * @remarks
   * Average plan generation time (in milliseconds) during the execution period.
   * 
   * @example
   * 0.0
   */
  avgGetPlanTime?: number;
  /**
   * @remarks
   * Average logical reads of the SQL during the execution period.
   * 
   * @example
   * 0.0
   */
  avgLogicalReads?: number;
  /**
   * @remarks
   * Strong consistent transaction percentage during the execution period.
   * 
   * @example
   * 0.0
   */
  avgMemstoreReadRows?: number;
  /**
   * @remarks
   * Average network transmission time (in milliseconds) during the execution period.
   * 
   * @example
   * 0.0
   */
  avgNetTime?: number;
  /**
   * @remarks
   * Average network enqueue time (in milliseconds) during the execution period.
   * 
   * @example
   * 0.0
   */
  avgNetWaitTime?: number;
  /**
   * @remarks
   * Average number of partition accessed during the execution period.
   * 
   * @example
   * 1.0
   */
  avgPartitionCount?: number;
  /**
   * @remarks
   * Average queueing time (in milliseconds) during the execution period.
   * 
   * @example
   * 0.01
   */
  avgQueueTime?: number;
  /**
   * @remarks
   * Average returned rows during the execution period.
   * 
   * @example
   * 0.0
   */
  avgReturnRows?: number;
  /**
   * @remarks
   * Average RowCache hit count during the execution period.
   * 
   * @example
   * 0.0
   */
  avgRowCacheHit?: number;
  /**
   * @remarks
   * Average count of RPC sent during the execution period.
   * 
   * @example
   * 8.0
   */
  avgRpcCount?: number;
  /**
   * @remarks
   * Average Schedule event wait time (in milliseconds) during the execution period.
   * 
   * @example
   * 0.0
   */
  avgScheduleTime?: number;
  /**
   * @remarks
   * Eventually consistent transaction percentage during the execution period.
   * 
   * @example
   * 0.0
   */
  avgSsstoreReadRows?: number;
  /**
   * @remarks
   * Average number of threads used of the SQL during the execution period.
   * 
   * @example
   * 3
   */
  avgUsedWorkerCount?: number;
  /**
   * @remarks
   * Average UserIO event wait time (in milliseconds) during the execution period.
   * 
   * @example
   * 0.0
   */
  avgUserIoWaitTime?: number;
  /**
   * @remarks
   * Average wait count during the execution period.
   * 
   * @example
   * 0.0
   */
  avgWaitCount?: number;
  /**
   * @remarks
   * Average wait time (in milliseconds) during the execution period.
   * 
   * @example
   * 1442.49
   */
  avgWaitTime?: number;
  /**
   * @remarks
   * Client IP.
   * 
   * @example
   * i-bp1db****38uemejio
   */
  clientIp?: string;
  /**
   * @remarks
   * CPU percentage.
   * 
   * @example
   * 100.0
   */
  cpuPercentage?: number;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * test_db
   */
  dbName?: string;
  /**
   * @remarks
   * Distributed plan percentage during the execution period.
   * 
   * @example
   * 100.0
   */
  distPlanPercentage?: number;
  dynamicSql?: boolean;
  /**
   * @remarks
   * Average execution count per second during the execution period.
   * 
   * @example
   * 0.31
   */
  execPs?: number;
  /**
   * @remarks
   * Total number of executions during the execution period.
   * 
   * @example
   * 1
   */
  executions?: number;
  /**
   * @remarks
   * Average number of partition accessed during the execution period.
   * 
   * @example
   * 0
   */
  failCount?: number;
  /**
   * @remarks
   * Error percentage during the execution period.
   * 
   * @example
   * 0.0
   */
  failPercentage?: number;
  /**
   * @remarks
   * Whether a internal SQL.
   * 
   * @example
   * false
   */
  inner?: boolean;
  lastFailCode?: number;
  /**
   * @remarks
   * Local plan percentage during the execution period.
   * 
   * @example
   * 0.0
   */
  localPlanPercentage?: number;
  /**
   * @remarks
   * Max affected rows during the execution period.
   * 
   * @example
   * 10000.0
   */
  maxAffectedRows?: number;
  /**
   * @remarks
   * Max Application event wait time (in milliseconds) during the execution period.
   * 
   * @example
   * 0.0
   */
  maxApplicationWaitTime?: number;
  /**
   * @remarks
   * Max Concurrency event wait time (in milliseconds) during the execution period.
   * 
   * @example
   * 0.0
   */
  maxConcurrencyWaitTime?: number;
  /**
   * @remarks
   * Max CPU time (in milliseconds).
   * 
   * @example
   * 13641.9
   */
  maxCpuTime?: number;
  /**
   * @remarks
   * Max physical read count during the execution period.
   * 
   * @example
   * 0.0
   */
  maxDiskReads?: number;
  /**
   * @remarks
   * Max response time during the execution period.
   * 
   * @example
   * 13643.3
   */
  maxElapsedTime?: number;
  /**
   * @remarks
   * Max returned rows during the execution period.
   * 
   * @example
   * 0.0
   */
  maxReturnRows?: number;
  /**
   * @remarks
   * Max UserIO event wait time (in milliseconds) during the execution period.
   * 
   * @example
   * 0.0
   */
  maxUserIoWaitTime?: number;
  /**
   * @remarks
   * Max wait time (in milliseconds) during the execution period.
   * 
   * @example
   * 3.4
   */
  maxWaitTime?: number;
  /**
   * @remarks
   * Plan hit rage during the execution period.
   * 
   * @example
   * 0.0
   */
  missPlanPercentage?: number;
  /**
   * @remarks
   * Missed hit count of the execution plan during the execution period.
   * 
   * @example
   * 0
   */
  missPlans?: number;
  /**
   * @remarks
   * Remote plan percentage during the execution period.
   * 
   * @example
   * 0.0
   */
  remotePlanPercentage?: number;
  /**
   * @remarks
   * Remote execution count during the execution period.
   * 
   * @example
   * 0
   */
  remotePlans?: number;
  /**
   * @remarks
   * Number of occurrences of the code 4012 during the execution period.
   * 
   * @example
   * 0
   */
  retCode4012Count?: number;
  /**
   * @remarks
   * Number of occurrences of the code 4013 during the execution period.
   * 
   * @example
   * 0
   */
  retCode4013Count?: number;
  /**
   * @remarks
   * Number of occurrences of the code 5001 during the execution period.
   * 
   * @example
   * 0
   */
  retCode5001Count?: number;
  /**
   * @remarks
   * Number of occurrences of the code 5024 during the execution period.
   * 
   * @example
   * 0
   */
  retCode5024Count?: number;
  /**
   * @remarks
   * Number of occurrences of the code 5167 during the execution period.
   * 
   * @example
   * 0
   */
  retCode5167Count?: number;
  /**
   * @remarks
   * Number of occurrences of the code 5217 during the execution period.
   * 
   * @example
   * 0
   */
  retCode5217Count?: number;
  /**
   * @remarks
   * Number of occurrences of the code 6002 during the execution period.
   * 
   * @example
   * 0
   */
  retCode6002Count?: number;
  /**
   * @remarks
   * Total retry count during the execution period.
   * 
   * @example
   * 0
   */
  retryCount?: number;
  /**
   * @remarks
   * RPC count during the execution period.
   * 
   * @example
   * 0.0
   */
  rpcCount?: number;
  /**
   * @remarks
   * The server where the SQL is executed.
   * 
   * @example
   * i-bp1db1****8uemejio
   */
  server?: string;
  /**
   * @remarks
   * The server IP where the SQL is executed.
   * 
   * @example
   * i-bp1db1****8uemejio
   */
  serverIp?: string;
  /**
   * @remarks
   * The server port where the SQL is executed.
   * 
   * @example
   * 389
   */
  serverPort?: number;
  /**
   * @remarks
   * SQL ID.
   * 
   * @example
   * 8D6E84****0B8FB1823D199E2CA1****
   */
  sqlId?: string;
  sqlList?: DescribeOasTopSQLListResponseBodyDataSqlList[];
  /**
   * @remarks
   * SQL text (the first 100 characters).
   */
  sqlTextShort?: string;
  /**
   * @remarks
   * SQL type.
   * 
   * @example
   * select
   */
  sqlType?: string;
  /**
   * @remarks
   * Strong consistent transaction percentage during the execution period.
   * 
   * @example
   * 100.0
   */
  strongConsistencyPercentage?: number;
  sumDbTime?: number;
  /**
   * @remarks
   * Total response time (in milliseconds) during the execution period.
   * 
   * @example
   * 11452126.36
   */
  sumElapsedTime?: number;
  /**
   * @remarks
   * Total logical reads.
   * 
   * @example
   * 0.0
   */
  sumLogicalReads?: number;
  /**
   * @remarks
   * Total wait time (in milliseconds) during the execution period.
   * 
   * @example
   * 9421.73
   */
  sumWaitTime?: number;
  /**
   * @remarks
   * Table scan percentage during the execution period.
   * 
   * @example
   * 0.0
   */
  tableScanPercentage?: number;
  /**
   * @remarks
   * Total wait time (in milliseconds) during the execution period.
   * 
   * @example
   * 10.966
   */
  totalWaitTime?: number;
  /**
   * @remarks
   * Username.
   * 
   * @example
   * test_user
   */
  userName?: string;
  /**
   * @remarks
   * Longest wait event during the execution period.
   * 
   * @example
   * none
   */
  waitEvent?: string;
  /**
   * @remarks
   * Eventually consistent transaction percentage during the execution period.
   * 
   * @example
   * 0.0
   */
  weakConsistencyPercentage?: number;
  static names(): { [key: string]: string } {
    return {
      avgAffectedRows: 'AvgAffectedRows',
      avgApplicationWaitTime: 'AvgApplicationWaitTime',
      avgBlockCacheHit: 'AvgBlockCacheHit',
      avgBlockIndexCacheHit: 'AvgBlockIndexCacheHit',
      avgBloomFilterCacheHit: 'AvgBloomFilterCacheHit',
      avgConcurrencyWaitTime: 'AvgConcurrencyWaitTime',
      avgCpuTime: 'AvgCpuTime',
      avgDbTime: 'AvgDbTime',
      avgDecodeTime: 'AvgDecodeTime',
      avgDiskReads: 'AvgDiskReads',
      avgElapsedTime: 'AvgElapsedTime',
      avgExecuteTime: 'AvgExecuteTime',
      avgExecutorRpcCount: 'AvgExecutorRpcCount',
      avgExpectedWorkerCount: 'AvgExpectedWorkerCount',
      avgGetPlanTime: 'AvgGetPlanTime',
      avgLogicalReads: 'AvgLogicalReads',
      avgMemstoreReadRows: 'AvgMemstoreReadRows',
      avgNetTime: 'AvgNetTime',
      avgNetWaitTime: 'AvgNetWaitTime',
      avgPartitionCount: 'AvgPartitionCount',
      avgQueueTime: 'AvgQueueTime',
      avgReturnRows: 'AvgReturnRows',
      avgRowCacheHit: 'AvgRowCacheHit',
      avgRpcCount: 'AvgRpcCount',
      avgScheduleTime: 'AvgScheduleTime',
      avgSsstoreReadRows: 'AvgSsstoreReadRows',
      avgUsedWorkerCount: 'AvgUsedWorkerCount',
      avgUserIoWaitTime: 'AvgUserIoWaitTime',
      avgWaitCount: 'AvgWaitCount',
      avgWaitTime: 'AvgWaitTime',
      clientIp: 'ClientIp',
      cpuPercentage: 'CpuPercentage',
      dbName: 'DbName',
      distPlanPercentage: 'DistPlanPercentage',
      dynamicSql: 'DynamicSql',
      execPs: 'ExecPs',
      executions: 'Executions',
      failCount: 'FailCount',
      failPercentage: 'FailPercentage',
      inner: 'Inner',
      lastFailCode: 'LastFailCode',
      localPlanPercentage: 'LocalPlanPercentage',
      maxAffectedRows: 'MaxAffectedRows',
      maxApplicationWaitTime: 'MaxApplicationWaitTime',
      maxConcurrencyWaitTime: 'MaxConcurrencyWaitTime',
      maxCpuTime: 'MaxCpuTime',
      maxDiskReads: 'MaxDiskReads',
      maxElapsedTime: 'MaxElapsedTime',
      maxReturnRows: 'MaxReturnRows',
      maxUserIoWaitTime: 'MaxUserIoWaitTime',
      maxWaitTime: 'MaxWaitTime',
      missPlanPercentage: 'MissPlanPercentage',
      missPlans: 'MissPlans',
      remotePlanPercentage: 'RemotePlanPercentage',
      remotePlans: 'RemotePlans',
      retCode4012Count: 'RetCode4012Count',
      retCode4013Count: 'RetCode4013Count',
      retCode5001Count: 'RetCode5001Count',
      retCode5024Count: 'RetCode5024Count',
      retCode5167Count: 'RetCode5167Count',
      retCode5217Count: 'RetCode5217Count',
      retCode6002Count: 'RetCode6002Count',
      retryCount: 'RetryCount',
      rpcCount: 'RpcCount',
      server: 'Server',
      serverIp: 'ServerIp',
      serverPort: 'ServerPort',
      sqlId: 'SqlId',
      sqlList: 'SqlList',
      sqlTextShort: 'SqlTextShort',
      sqlType: 'SqlType',
      strongConsistencyPercentage: 'StrongConsistencyPercentage',
      sumDbTime: 'SumDbTime',
      sumElapsedTime: 'SumElapsedTime',
      sumLogicalReads: 'SumLogicalReads',
      sumWaitTime: 'SumWaitTime',
      tableScanPercentage: 'TableScanPercentage',
      totalWaitTime: 'TotalWaitTime',
      userName: 'UserName',
      waitEvent: 'WaitEvent',
      weakConsistencyPercentage: 'WeakConsistencyPercentage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avgAffectedRows: 'number',
      avgApplicationWaitTime: 'number',
      avgBlockCacheHit: 'number',
      avgBlockIndexCacheHit: 'number',
      avgBloomFilterCacheHit: 'number',
      avgConcurrencyWaitTime: 'number',
      avgCpuTime: 'number',
      avgDbTime: 'number',
      avgDecodeTime: 'number',
      avgDiskReads: 'number',
      avgElapsedTime: 'number',
      avgExecuteTime: 'number',
      avgExecutorRpcCount: 'number',
      avgExpectedWorkerCount: 'number',
      avgGetPlanTime: 'number',
      avgLogicalReads: 'number',
      avgMemstoreReadRows: 'number',
      avgNetTime: 'number',
      avgNetWaitTime: 'number',
      avgPartitionCount: 'number',
      avgQueueTime: 'number',
      avgReturnRows: 'number',
      avgRowCacheHit: 'number',
      avgRpcCount: 'number',
      avgScheduleTime: 'number',
      avgSsstoreReadRows: 'number',
      avgUsedWorkerCount: 'number',
      avgUserIoWaitTime: 'number',
      avgWaitCount: 'number',
      avgWaitTime: 'number',
      clientIp: 'string',
      cpuPercentage: 'number',
      dbName: 'string',
      distPlanPercentage: 'number',
      dynamicSql: 'boolean',
      execPs: 'number',
      executions: 'number',
      failCount: 'number',
      failPercentage: 'number',
      inner: 'boolean',
      lastFailCode: 'number',
      localPlanPercentage: 'number',
      maxAffectedRows: 'number',
      maxApplicationWaitTime: 'number',
      maxConcurrencyWaitTime: 'number',
      maxCpuTime: 'number',
      maxDiskReads: 'number',
      maxElapsedTime: 'number',
      maxReturnRows: 'number',
      maxUserIoWaitTime: 'number',
      maxWaitTime: 'number',
      missPlanPercentage: 'number',
      missPlans: 'number',
      remotePlanPercentage: 'number',
      remotePlans: 'number',
      retCode4012Count: 'number',
      retCode4013Count: 'number',
      retCode5001Count: 'number',
      retCode5024Count: 'number',
      retCode5167Count: 'number',
      retCode5217Count: 'number',
      retCode6002Count: 'number',
      retryCount: 'number',
      rpcCount: 'number',
      server: 'string',
      serverIp: 'string',
      serverPort: 'number',
      sqlId: 'string',
      sqlList: { 'type': 'array', 'itemType': DescribeOasTopSQLListResponseBodyDataSqlList },
      sqlTextShort: 'string',
      sqlType: 'string',
      strongConsistencyPercentage: 'number',
      sumDbTime: 'number',
      sumElapsedTime: 'number',
      sumLogicalReads: 'number',
      sumWaitTime: 'number',
      tableScanPercentage: 'number',
      totalWaitTime: 'number',
      userName: 'string',
      waitEvent: 'string',
      weakConsistencyPercentage: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOutlineBindingResponseBodyOutlineBinding extends $tea.Model {
  /**
   * @remarks
   * The bound index.
   * 
   * @example
   * PRIMARY
   */
  bindIndex?: string;
  /**
   * @remarks
   * The bound plan.
   * 
   * @example
   * PHY_TABLE_SCAN | bmsql_order_line | 40 ******
   */
  bindPlan?: string;
  /**
   * @remarks
   * The maximum number of concurrent tasks.
   * 
   * @example
   * 2
   */
  maxConcurrent?: number;
  /**
   * @remarks
   * OutlineID.
   * 
   * @example
   * -1
   */
  outlineId?: number;
  /**
   * @remarks
   * 表名称
   */
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      bindIndex: 'BindIndex',
      bindPlan: 'BindPlan',
      maxConcurrent: 'MaxConcurrent',
      outlineId: 'OutlineId',
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bindIndex: 'string',
      bindPlan: 'string',
      maxConcurrent: 'number',
      outlineId: 'number',
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeParametersResponseBodyParameters extends $tea.Model {
  /**
   * @remarks
   * DescribeParameters
   */
  acceptableValue?: string[];
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * @example
   * 600
   */
  currentValue?: string;
  /**
   * @remarks
   * ```
   * http(s)://[Endpoint]/?Action=DescribeParameters
   * &InstanceId=ob317v4uif****
   * &Dimension=TENANT
   * &DimensionValue=ob2mr3oae0****
   * &Common request parameters
   * ```
   * 
   * @example
   * 600s
   */
  defaultValue?: string;
  /**
   * @remarks
   * The description of the parameter.
   * 
   * @example
   * The operation that you want to perform.   
   * Set the value to **DescribeParameters**.
   */
  description?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * connect_timeout
   */
  name?: string;
  /**
   * @remarks
   * The name of the parameter.
   * 
   * @example
   * false
   */
  needReboot?: boolean;
  /**
   * @remarks
   * 参数是否只读
   */
  readonly?: boolean;
  /**
   * @remarks
   * {
   *     "RequestId": "EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C",
   *     "Parameters": [
   *         {
   *             "Description": "The maximum delay allowed in weak-consistency reads.",
   *             "ValueType": "CAPACITY",
   *             "CurrentValue": "600",
   *             "NeedReboot": false,
   *             "Name": "connect_timeout",
   *             "DefaultValue": "600s",
   *             "RejectedValue": [
   *                 "1s"
   *             ],
   *             "AcceptableValue": [
   *                 "1s"
   *             ]
   *         }
   *     ]
   * }
   */
  rejectedValue?: string[];
  /**
   * @example
   * s
   */
  unit?: string;
  /**
   * @remarks
   * The invalid value range of the parameter.    
   * It is an array with two string elements, which represents a range. The first element represents the minimum value and the second element represents the maximum value.
   * 
   * @example
   * CAPACITY
   */
  valueType?: string;
  static names(): { [key: string]: string } {
    return {
      acceptableValue: 'AcceptableValue',
      currentValue: 'CurrentValue',
      defaultValue: 'DefaultValue',
      description: 'Description',
      name: 'Name',
      needReboot: 'NeedReboot',
      readonly: 'Readonly',
      rejectedValue: 'RejectedValue',
      unit: 'Unit',
      valueType: 'ValueType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptableValue: { 'type': 'array', 'itemType': 'string' },
      currentValue: 'string',
      defaultValue: 'string',
      description: 'string',
      name: 'string',
      needReboot: 'boolean',
      readonly: 'boolean',
      rejectedValue: { 'type': 'array', 'itemType': 'string' },
      unit: 'string',
      valueType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeParametersHistoryResponseBodyRespondParameters extends $tea.Model {
  /**
   * @remarks
   * The time when the parameter modification was initiated.
   * 
   * @example
   * 2021-09-14 10:57:44
   */
  createTime?: string;
  /**
   * @remarks
   * The resource ID of the parameter type.    
   * - When you called this operation to query the modification history of cluster parameters, the value is DEFAULT_DIMENSION_VALUE.   
   * - When you called this operation to query the modification history of tenant parameters, the value is the tenant ID.
   * 
   * @example
   * DEFAULT_DIMENSION_VALUE
   */
  dimensionValue?: string;
  /**
   * @remarks
   * The name of the parameter.
   * 
   * @example
   * connect_timeout
   */
  name?: string;
  /**
   * @remarks
   * The value of the parameter after the modification.
   * 
   * @example
   * 200
   */
  newValue?: string;
  /**
   * @remarks
   * The parameter value before modification.
   * 
   * @example
   * 300
   */
  oldValue?: string;
  /**
   * @remarks
   * The modification status. Valid values:    
   * - APPLIED: The modification was successful.   
   * - SCHEDULING: The modification was to be made.
   * 
   * @example
   * APPLIED
   */
  status?: string;
  /**
   * @remarks
   * The time when the parameter modification took effect.
   * 
   * @example
   * 2021-09-14 10:57:44
   */
  updateTime?: string;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      dimensionValue: 'DimensionValue',
      name: 'Name',
      newValue: 'NewValue',
      oldValue: 'OldValue',
      status: 'Status',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'string',
      dimensionValue: 'string',
      name: 'string',
      newValue: 'string',
      oldValue: 'string',
      status: 'string',
      updateTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeParametersHistoryResponseBodyRespond extends $tea.Model {
  /**
   * @remarks
   * The number of returned entries on each page.
   * 
   * @example
   * Default value: 10.
   */
  pageNumber?: number;
  /**
   * @remarks
   * The parameter modification history.
   */
  parameters?: DescribeParametersHistoryResponseBodyRespondParameters[];
  /**
   * @remarks
   * The number of parameter modification records.
   * 
   * @example
   * 2
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      parameters: 'Parameters',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      parameters: { 'type': 'array', 'itemType': DescribeParametersHistoryResponseBodyRespondParameters },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProcessStatsCompositionResponseBodyDataAllProcessList extends $tea.Model {
  clientIp?: string;
  command?: string;
  cpuTime?: number;
  database?: string;
  executeTime?: number;
  planId?: string;
  proxySessId?: string;
  serverIp?: string;
  sessionId?: number;
  sqlId?: string;
  sqlText?: string;
  status?: string;
  tenantId?: string;
  traceId?: string;
  user?: string;
  static names(): { [key: string]: string } {
    return {
      clientIp: 'ClientIp',
      command: 'Command',
      cpuTime: 'CpuTime',
      database: 'Database',
      executeTime: 'ExecuteTime',
      planId: 'PlanId',
      proxySessId: 'ProxySessId',
      serverIp: 'ServerIp',
      sessionId: 'SessionId',
      sqlId: 'SqlId',
      sqlText: 'SqlText',
      status: 'Status',
      tenantId: 'TenantId',
      traceId: 'TraceId',
      user: 'User',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clientIp: 'string',
      command: 'string',
      cpuTime: 'number',
      database: 'string',
      executeTime: 'number',
      planId: 'string',
      proxySessId: 'string',
      serverIp: 'string',
      sessionId: 'number',
      sqlId: 'string',
      sqlText: 'string',
      status: 'string',
      tenantId: 'string',
      traceId: 'string',
      user: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProcessStatsCompositionResponseBodyDataSessionStatisticsDataBaseStatistics extends $tea.Model {
  activeCount?: number;
  metricValue?: string;
  totalCount?: number;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      activeCount: 'ActiveCount',
      metricValue: 'MetricValue',
      totalCount: 'TotalCount',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      activeCount: 'number',
      metricValue: 'string',
      totalCount: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProcessStatsCompositionResponseBodyDataSessionStatisticsSourceStatistics extends $tea.Model {
  activeCount?: number;
  metricValue?: string;
  totalCount?: number;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      activeCount: 'ActiveCount',
      metricValue: 'MetricValue',
      totalCount: 'TotalCount',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      activeCount: 'number',
      metricValue: 'string',
      totalCount: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProcessStatsCompositionResponseBodyDataSessionStatisticsUserStatistics extends $tea.Model {
  activeCount?: number;
  metricValue?: string;
  totalCount?: number;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      activeCount: 'ActiveCount',
      metricValue: 'MetricValue',
      totalCount: 'TotalCount',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      activeCount: 'number',
      metricValue: 'string',
      totalCount: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProcessStatsCompositionResponseBodyDataSessionStatistics extends $tea.Model {
  dataBaseStatistics?: DescribeProcessStatsCompositionResponseBodyDataSessionStatisticsDataBaseStatistics[];
  sourceStatistics?: DescribeProcessStatsCompositionResponseBodyDataSessionStatisticsSourceStatistics[];
  userStatistics?: DescribeProcessStatsCompositionResponseBodyDataSessionStatisticsUserStatistics[];
  static names(): { [key: string]: string } {
    return {
      dataBaseStatistics: 'DataBaseStatistics',
      sourceStatistics: 'SourceStatistics',
      userStatistics: 'UserStatistics',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataBaseStatistics: { 'type': 'array', 'itemType': DescribeProcessStatsCompositionResponseBodyDataSessionStatisticsDataBaseStatistics },
      sourceStatistics: { 'type': 'array', 'itemType': DescribeProcessStatsCompositionResponseBodyDataSessionStatisticsSourceStatistics },
      userStatistics: { 'type': 'array', 'itemType': DescribeProcessStatsCompositionResponseBodyDataSessionStatisticsUserStatistics },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProcessStatsCompositionResponseBodyData extends $tea.Model {
  activeSessionCount?: number;
  allProcessList?: DescribeProcessStatsCompositionResponseBodyDataAllProcessList[];
  idleSessionCount?: number;
  obVersion?: string;
  sessionStatistics?: DescribeProcessStatsCompositionResponseBodyDataSessionStatistics;
  totalSessionCount?: number;
  static names(): { [key: string]: string } {
    return {
      activeSessionCount: 'ActiveSessionCount',
      allProcessList: 'AllProcessList',
      idleSessionCount: 'IdleSessionCount',
      obVersion: 'ObVersion',
      sessionStatistics: 'SessionStatistics',
      totalSessionCount: 'TotalSessionCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      activeSessionCount: 'number',
      allProcessList: { 'type': 'array', 'itemType': DescribeProcessStatsCompositionResponseBodyDataAllProcessList },
      idleSessionCount: 'number',
      obVersion: 'string',
      sessionStatistics: DescribeProcessStatsCompositionResponseBodyDataSessionStatistics,
      totalSessionCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataAlarmStats extends $tea.Model {
  /**
   * @example
   * null
   */
  alarmContent?: string;
  /**
   * @example
   * false
   */
  alarming?: boolean;
  /**
   * @example
   * true
   */
  openMonitor?: boolean;
  /**
   * @example
   * 0
   */
  recentlyTriggerCount?: number;
  ruleToRecentlyTriggerCount?: { [key: string]: number };
  /**
   * @example
   * null
   */
  target?: string;
  static names(): { [key: string]: string } {
    return {
      alarmContent: 'AlarmContent',
      alarming: 'Alarming',
      openMonitor: 'OpenMonitor',
      recentlyTriggerCount: 'RecentlyTriggerCount',
      ruleToRecentlyTriggerCount: 'RuleToRecentlyTriggerCount',
      target: 'Target',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alarmContent: 'string',
      alarming: 'boolean',
      openMonitor: 'boolean',
      recentlyTriggerCount: 'number',
      ruleToRecentlyTriggerCount: { 'type': 'map', 'keyType': 'string', 'valueType': 'number' },
      target: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataCommonTransferConfig extends $tea.Model {
  /**
   * @example
   * true
   */
  activeActive?: boolean;
  /**
   * @example
   * null
   */
  dataWorksBusinessName?: string;
  /**
   * @example
   * TUPLE
   */
  datahubTopicType?: string;
  /**
   * @example
   * 0
   */
  mqPartition?: number;
  /**
   * @example
   * ONE
   */
  mqPartitionMode?: string;
  /**
   * @example
   * DEFAULT
   */
  mqSerializerType?: string;
  /**
   * @example
   * true
   */
  rocketMqEnableMsgTrace?: boolean;
  /**
   * @example
   * default_tag
   */
  rocketMqMsgTags?: string;
  /**
   * @example
   * OMS
   */
  rocketMqProducerGroup?: string;
  /**
   * @example
   * null
   */
  rocketMqSendMsgTimeout?: number;
  sinkStoreFormat?: string;
  sourceStoreFormat?: string;
  /**
   * @example
   * ALL
   */
  tableCategory?: string;
  static names(): { [key: string]: string } {
    return {
      activeActive: 'ActiveActive',
      dataWorksBusinessName: 'DataWorksBusinessName',
      datahubTopicType: 'DatahubTopicType',
      mqPartition: 'MqPartition',
      mqPartitionMode: 'MqPartitionMode',
      mqSerializerType: 'MqSerializerType',
      rocketMqEnableMsgTrace: 'RocketMqEnableMsgTrace',
      rocketMqMsgTags: 'RocketMqMsgTags',
      rocketMqProducerGroup: 'RocketMqProducerGroup',
      rocketMqSendMsgTimeout: 'RocketMqSendMsgTimeout',
      sinkStoreFormat: 'SinkStoreFormat',
      sourceStoreFormat: 'SourceStoreFormat',
      tableCategory: 'TableCategory',
    };
  }

  static types(): { [key: string]: any } {
    return {
      activeActive: 'boolean',
      dataWorksBusinessName: 'string',
      datahubTopicType: 'string',
      mqPartition: 'number',
      mqPartitionMode: 'string',
      mqSerializerType: 'string',
      rocketMqEnableMsgTrace: 'boolean',
      rocketMqMsgTags: 'string',
      rocketMqProducerGroup: 'string',
      rocketMqSendMsgTimeout: 'number',
      sinkStoreFormat: 'string',
      sourceStoreFormat: 'string',
      tableCategory: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataExtraInfo extends $tea.Model {
  /**
   * @example
   * true
   */
  accessObSource?: boolean;
  /**
   * @example
   * false
   */
  ignoreUnsupportDdl?: boolean;
  /**
   * @example
   * 1689244596
   */
  incrSyncTimestamp?: number;
  /**
   * @example
   * 1689214358
   */
  logServiceStartCheckpoint?: number;
  /**
   * @example
   * -1
   */
  maxConnectorCount?: number;
  /**
   * @example
   * true
   */
  monitoringIncr?: boolean;
  /**
   * @example
   * true
   */
  overwriteConfig?: boolean;
  reverseSubtopics?: string[];
  /**
   * @example
   * 90
   */
  runningProgress?: number;
  /**
   * @example
   * PRE-CHECK
   */
  runningStep?: string;
  /**
   * @example
   * 24
   */
  sourceStoreKeptHour?: number;
  /**
   * @example
   * true
   */
  storeIncr?: boolean;
  subConds?: { [key: string]: DataExtraInfoSubCondsValue[] };
  subDbs?: { [key: string]: DataExtraInfoSubDbsValue[] };
  subIds?: { [key: string]: string };
  subtopics?: string[];
  /**
   * @example
   * null
   */
  syncDelay?: number;
  /**
   * @example
   * 1689214358
   */
  syncDelaySampleTimestamp?: number;
  static names(): { [key: string]: string } {
    return {
      accessObSource: 'AccessObSource',
      ignoreUnsupportDdl: 'IgnoreUnsupportDdl',
      incrSyncTimestamp: 'IncrSyncTimestamp',
      logServiceStartCheckpoint: 'LogServiceStartCheckpoint',
      maxConnectorCount: 'MaxConnectorCount',
      monitoringIncr: 'MonitoringIncr',
      overwriteConfig: 'OverwriteConfig',
      reverseSubtopics: 'ReverseSubtopics',
      runningProgress: 'RunningProgress',
      runningStep: 'RunningStep',
      sourceStoreKeptHour: 'SourceStoreKeptHour',
      storeIncr: 'StoreIncr',
      subConds: 'SubConds',
      subDbs: 'SubDbs',
      subIds: 'SubIds',
      subtopics: 'Subtopics',
      syncDelay: 'SyncDelay',
      syncDelaySampleTimestamp: 'SyncDelaySampleTimestamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessObSource: 'boolean',
      ignoreUnsupportDdl: 'boolean',
      incrSyncTimestamp: 'number',
      logServiceStartCheckpoint: 'number',
      maxConnectorCount: 'number',
      monitoringIncr: 'boolean',
      overwriteConfig: 'boolean',
      reverseSubtopics: { 'type': 'array', 'itemType': 'string' },
      runningProgress: 'number',
      runningStep: 'string',
      sourceStoreKeptHour: 'number',
      storeIncr: 'boolean',
      subConds: { 'type': 'map', 'keyType': 'string', 'valueType': { 'type': 'array', 'itemType': DataExtraInfoSubCondsValue } },
      subDbs: { 'type': 'map', 'keyType': 'string', 'valueType': { 'type': 'array', 'itemType': DataExtraInfoSubDbsValue } },
      subIds: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      subtopics: { 'type': 'array', 'itemType': 'string' },
      syncDelay: 'number',
      syncDelaySampleTimestamp: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataFullTransferConfig extends $tea.Model {
  /**
   * @example
   * true
   */
  allowDestTableNotEmpty?: boolean;
  /**
   * @example
   * FAST
   */
  fullTransferSpeedMode?: string;
  /**
   * @example
   * FAST
   */
  fullVerifySpeedMode?: string;
  /**
   * @example
   * false
   */
  nonePkUkTruncateDstTable?: boolean;
  readWorkerNum?: number;
  throttleIOPS?: number;
  throttleRps?: number;
  writeWorkerNum?: number;
  static names(): { [key: string]: string } {
    return {
      allowDestTableNotEmpty: 'AllowDestTableNotEmpty',
      fullTransferSpeedMode: 'FullTransferSpeedMode',
      fullVerifySpeedMode: 'FullVerifySpeedMode',
      nonePkUkTruncateDstTable: 'NonePkUkTruncateDstTable',
      readWorkerNum: 'ReadWorkerNum',
      throttleIOPS: 'ThrottleIOPS',
      throttleRps: 'ThrottleRps',
      writeWorkerNum: 'WriteWorkerNum',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allowDestTableNotEmpty: 'boolean',
      fullTransferSpeedMode: 'string',
      fullVerifySpeedMode: 'string',
      nonePkUkTruncateDstTable: 'boolean',
      readWorkerNum: 'number',
      throttleIOPS: 'number',
      throttleRps: 'number',
      writeWorkerNum: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataIncrTransferConfig extends $tea.Model {
  /**
   * @example
   * true
   */
  enableIncrSyncStatistics?: boolean;
  /**
   * @example
   * false
   */
  enableSequencingWithinTxn?: boolean;
  /**
   * @example
   * 64
   */
  incrSyncConcurrency?: number;
  recordTypeWhiteList?: string[];
  /**
   * @example
   * 1667286900
   */
  startTimestamp?: number;
  /**
   * @example
   * 24
   */
  storeLogKeptHour?: number;
  supportDDLTypes?: string[];
  throttleIOPS?: number;
  throttleRps?: number;
  static names(): { [key: string]: string } {
    return {
      enableIncrSyncStatistics: 'EnableIncrSyncStatistics',
      enableSequencingWithinTxn: 'EnableSequencingWithinTxn',
      incrSyncConcurrency: 'IncrSyncConcurrency',
      recordTypeWhiteList: 'RecordTypeWhiteList',
      startTimestamp: 'StartTimestamp',
      storeLogKeptHour: 'StoreLogKeptHour',
      supportDDLTypes: 'SupportDDLTypes',
      throttleIOPS: 'ThrottleIOPS',
      throttleRps: 'ThrottleRps',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enableIncrSyncStatistics: 'boolean',
      enableSequencingWithinTxn: 'boolean',
      incrSyncConcurrency: 'number',
      recordTypeWhiteList: { 'type': 'array', 'itemType': 'string' },
      startTimestamp: 'number',
      storeLogKeptHour: 'number',
      supportDDLTypes: { 'type': 'array', 'itemType': 'string' },
      throttleIOPS: 'number',
      throttleRps: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataLabels extends $tea.Model {
  /**
   * @example
   * l_dr****
   */
  id?: string;
  /**
   * @example
   * test_tag
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataReverseIncrTransferConfig extends $tea.Model {
  enableIncrSyncStatistics?: boolean;
  enableSequencingWithinTxn?: boolean;
  incrSyncConcurrency?: number;
  recordTypeWhiteList?: string[];
  startTimestamp?: number;
  storeLogKeptHour?: number;
  supportDDLTypes?: string[];
  throttleIOPS?: number;
  throttleRps?: number;
  static names(): { [key: string]: string } {
    return {
      enableIncrSyncStatistics: 'EnableIncrSyncStatistics',
      enableSequencingWithinTxn: 'EnableSequencingWithinTxn',
      incrSyncConcurrency: 'IncrSyncConcurrency',
      recordTypeWhiteList: 'RecordTypeWhiteList',
      startTimestamp: 'StartTimestamp',
      storeLogKeptHour: 'StoreLogKeptHour',
      supportDDLTypes: 'SupportDDLTypes',
      throttleIOPS: 'ThrottleIOPS',
      throttleRps: 'ThrottleRps',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enableIncrSyncStatistics: 'boolean',
      enableSequencingWithinTxn: 'boolean',
      incrSyncConcurrency: 'number',
      recordTypeWhiteList: { 'type': 'array', 'itemType': 'string' },
      startTimestamp: 'number',
      storeLogKeptHour: 'number',
      supportDDLTypes: { 'type': 'array', 'itemType': 'string' },
      throttleIOPS: 'number',
      throttleRps: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataSinkConnectInfo extends $tea.Model {
  /**
   * @example
   * utf8mb4
   */
  charset?: string;
  /**
   * @example
   * null
   */
  connExtraAttributes?: any;
  /**
   * @example
   * null
   */
  connectionInfo?: string;
  /**
   * @example
   * MYSQL_PUBLIC
   */
  dbEngine?: string;
  /**
   * @example
   * e_4w1q****
   */
  endpointId?: string;
  /**
   * @example
   * RATION12948*****
   */
  endpointName?: string;
  /**
   * @example
   * sink
   */
  endpointSide?: string;
  /**
   * @example
   * xxx.xxx.xxx.1
   */
  host?: string;
  /**
   * @example
   * e_4lgzuzi9znr4
   */
  id?: string;
  /**
   * @example
   * null
   */
  nlsLengthSemantics?: string;
  /**
   * @example
   * null
   */
  ocpName?: string;
  /**
   * @example
   * Linux
   */
  operatingSystem?: string;
  /**
   * @remarks
   * Owner。
   * 
   * @example
   * oms_test
   */
  owner?: string;
  /**
   * @example
   * 2883
   */
  port?: number;
  /**
   * @example
   * cn-hangzhou
   */
  region?: string;
  /**
   * @example
   * 1325847***
   */
  resourceOwner?: string;
  /**
   * @example
   * +08:00
   */
  timezone?: string;
  /**
   * @example
   * oms2027obmysql@oms_***
   */
  username?: string;
  /**
   * @example
   * 2.2.77
   */
  version?: string;
  static names(): { [key: string]: string } {
    return {
      charset: 'Charset',
      connExtraAttributes: 'ConnExtraAttributes',
      connectionInfo: 'ConnectionInfo',
      dbEngine: 'DbEngine',
      endpointId: 'EndpointId',
      endpointName: 'EndpointName',
      endpointSide: 'EndpointSide',
      host: 'Host',
      id: 'Id',
      nlsLengthSemantics: 'NlsLengthSemantics',
      ocpName: 'OcpName',
      operatingSystem: 'OperatingSystem',
      owner: 'Owner',
      port: 'Port',
      region: 'Region',
      resourceOwner: 'ResourceOwner',
      timezone: 'Timezone',
      username: 'Username',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      charset: 'string',
      connExtraAttributes: 'any',
      connectionInfo: 'string',
      dbEngine: 'string',
      endpointId: 'string',
      endpointName: 'string',
      endpointSide: 'string',
      host: 'string',
      id: 'string',
      nlsLengthSemantics: 'string',
      ocpName: 'string',
      operatingSystem: 'string',
      owner: 'string',
      port: 'number',
      region: 'string',
      resourceOwner: 'string',
      timezone: 'string',
      username: 'string',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataSourceConnectInfo extends $tea.Model {
  /**
   * @example
   * utf8mb4
   */
  charset?: string;
  /**
   * @example
   * null
   */
  connExtraAttributes?: any;
  /**
   * @example
   * null
   */
  connectionInfo?: string;
  /**
   * @example
   * OB_MYSQL_PUBLIC
   */
  dbEngine?: string;
  /**
   * @example
   * e_3kx5i***1s
   */
  endpointId?: string;
  /**
   * @example
   * migon****
   */
  endpointName?: string;
  /**
   * @example
   * source
   */
  endpointSide?: string;
  /**
   * @example
   * xxx.xxx.xxx.1
   */
  host?: string;
  /**
   * @example
   * c_feg****
   */
  id?: string;
  /**
   * @example
   * null
   */
  nlsLengthSemantics?: string;
  /**
   * @example
   * null
   */
  ocpName?: string;
  /**
   * @example
   * Linux
   */
  operatingSystem?: string;
  /**
   * @remarks
   * Owner。
   * 
   * @example
   * oms_test
   */
  owner?: string;
  /**
   * @example
   * 2883
   */
  port?: number;
  /**
   * @example
   * cn-shanghai
   */
  region?: string;
  /**
   * @example
   * 1325847***
   */
  resourceOwner?: string;
  /**
   * @example
   * +08:00
   */
  timezone?: string;
  /**
   * @example
   * oms2027obmysql@oms_***
   */
  username?: string;
  /**
   * @example
   * 2.2.77
   */
  version?: string;
  static names(): { [key: string]: string } {
    return {
      charset: 'Charset',
      connExtraAttributes: 'ConnExtraAttributes',
      connectionInfo: 'ConnectionInfo',
      dbEngine: 'DbEngine',
      endpointId: 'EndpointId',
      endpointName: 'EndpointName',
      endpointSide: 'EndpointSide',
      host: 'Host',
      id: 'Id',
      nlsLengthSemantics: 'NlsLengthSemantics',
      ocpName: 'OcpName',
      operatingSystem: 'OperatingSystem',
      owner: 'Owner',
      port: 'Port',
      region: 'Region',
      resourceOwner: 'ResourceOwner',
      timezone: 'Timezone',
      username: 'Username',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      charset: 'string',
      connExtraAttributes: 'any',
      connectionInfo: 'string',
      dbEngine: 'string',
      endpointId: 'string',
      endpointName: 'string',
      endpointSide: 'string',
      host: 'string',
      id: 'string',
      nlsLengthSemantics: 'string',
      ocpName: 'string',
      operatingSystem: 'string',
      owner: 'string',
      port: 'number',
      region: 'string',
      resourceOwner: 'string',
      timezone: 'string',
      username: 'string',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataStepsExtraInfoErrorDetails extends $tea.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @remarks
   * FATAL, ERROR, WARNING, CRITICAL
   * 
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * Contact the administrator.
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataStepsExtraInfo extends $tea.Model {
  /**
   * @example
   * INNER_ERROR
   */
  errorCode?: string;
  errorDetails?: DescribeProjectResponseBodyDataStepsExtraInfoErrorDetails[];
  /**
   * @example
   * A system error occurred.
   */
  errorMsg?: string;
  errorParam?: { [key: string]: string };
  /**
   * @example
   * null
   */
  failedTime?: string;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorDetails: 'ErrorDetails',
      errorMsg: 'ErrorMsg',
      errorParam: 'ErrorParam',
      failedTime: 'FailedTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorDetails: { 'type': 'array', 'itemType': DescribeProjectResponseBodyDataStepsExtraInfoErrorDetails },
      errorMsg: 'string',
      errorParam: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      failedTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataSteps extends $tea.Model {
  description?: string;
  extraInfo?: DescribeProjectResponseBodyDataStepsExtraInfo;
  /**
   * @example
   * 2020-05-22T17:04:18
   */
  finishTime?: string;
  /**
   * @example
   * PRE_CHECK
   */
  name?: string;
  /**
   * @example
   * 1
   */
  order?: number;
  /**
   * @example
   * 90
   */
  progress?: number;
  /**
   * @example
   * 2020-05-22T17:04:18
   */
  startTime?: string;
  /**
   * @example
   * RUNNING
   */
  status?: string;
  stepInfo?: { [key: string]: any };
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      extraInfo: 'ExtraInfo',
      finishTime: 'FinishTime',
      name: 'Name',
      order: 'Order',
      progress: 'Progress',
      startTime: 'StartTime',
      status: 'Status',
      stepInfo: 'StepInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      extraInfo: DescribeProjectResponseBodyDataStepsExtraInfo,
      finishTime: 'string',
      name: 'string',
      order: 'number',
      progress: 'number',
      startTime: 'string',
      status: 'string',
      stepInfo: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataStructTransferConfig extends $tea.Model {
  /**
   * @example
   * DO_NOTHING_IF_BYTE_USED
   */
  byteCharConvertStrategy?: string;
  /**
   * @example
   * true
   */
  deferIndexCreation?: boolean;
  static names(): { [key: string]: string } {
    return {
      byteCharConvertStrategy: 'ByteCharConvertStrategy',
      deferIndexCreation: 'DeferIndexCreation',
    };
  }

  static types(): { [key: string]: any } {
    return {
      byteCharConvertStrategy: 'string',
      deferIndexCreation: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificTablesAdbTableSchema extends $tea.Model {
  distributedKeys?: string[];
  /**
   * @example
   * 30
   */
  partitionLifeCycle?: string;
  /**
   * @example
   * PARTITION BY VALUE(\\"id\\")
   */
  partitionStatement?: string;
  primaryKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      distributedKeys: 'DistributedKeys',
      partitionLifeCycle: 'PartitionLifeCycle',
      partitionStatement: 'PartitionStatement',
      primaryKeys: 'PrimaryKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      distributedKeys: { 'type': 'array', 'itemType': 'string' },
      partitionLifeCycle: 'string',
      partitionStatement: 'string',
      primaryKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificTables extends $tea.Model {
  adbTableSchema?: DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificTablesAdbTableSchema;
  filterColumns?: string[];
  /**
   * @example
   * table_id
   */
  id?: string;
  /**
   * @example
   * mapped_table
   */
  mappedName?: string;
  /**
   * @example
   * table_name
   */
  name?: string;
  shardColumns?: string[];
  /**
   * @example
   * id>1
   */
  whereClause?: string;
  static names(): { [key: string]: string } {
    return {
      adbTableSchema: 'AdbTableSchema',
      filterColumns: 'FilterColumns',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      shardColumns: 'ShardColumns',
      whereClause: 'WhereClause',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adbTableSchema: DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificTablesAdbTableSchema,
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      mappedName: 'string',
      name: 'string',
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      whereClause: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificViewsAdbTableSchema extends $tea.Model {
  distributedKeys?: string[];
  /**
   * @example
   * 30
   */
  partitionLifeCycle?: string;
  /**
   * @example
   * PARTITION BY VALUE(\\"id\\")
   */
  partitionStatement?: string;
  primaryKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      distributedKeys: 'DistributedKeys',
      partitionLifeCycle: 'PartitionLifeCycle',
      partitionStatement: 'PartitionStatement',
      primaryKeys: 'PrimaryKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      distributedKeys: { 'type': 'array', 'itemType': 'string' },
      partitionLifeCycle: 'string',
      partitionStatement: 'string',
      primaryKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificViews extends $tea.Model {
  adbTableSchema?: DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificViewsAdbTableSchema;
  filterColumns?: string[];
  /**
   * @example
   * view_id
   */
  id?: string;
  /**
   * @example
   * mapped_name
   */
  mappedName?: string;
  /**
   * @example
   * view_name
   */
  name?: string;
  shardColumns?: string[];
  /**
   * @example
   * id<3
   */
  whereClause?: string;
  static names(): { [key: string]: string } {
    return {
      adbTableSchema: 'AdbTableSchema',
      filterColumns: 'FilterColumns',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      shardColumns: 'ShardColumns',
      whereClause: 'WhereClause',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adbTableSchema: DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificViewsAdbTableSchema,
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      mappedName: 'string',
      name: 'string',
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      whereClause: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataTransferMappingDatabasesTablesAdbTableSchema extends $tea.Model {
  distributedKeys?: string[];
  /**
   * @example
   * 30
   */
  partitionLifeCycle?: string;
  /**
   * @example
   * PARTITION BY VALUE(\\"id\\")
   */
  partitionStatement?: string;
  primaryKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      distributedKeys: 'DistributedKeys',
      partitionLifeCycle: 'PartitionLifeCycle',
      partitionStatement: 'PartitionStatement',
      primaryKeys: 'PrimaryKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      distributedKeys: { 'type': 'array', 'itemType': 'string' },
      partitionLifeCycle: 'string',
      partitionStatement: 'string',
      primaryKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataTransferMappingDatabasesTables extends $tea.Model {
  adbTableSchema?: DescribeProjectResponseBodyDataTransferMappingDatabasesTablesAdbTableSchema;
  filterColumns?: string[];
  /**
   * @example
   * table_id
   */
  id?: string;
  /**
   * @example
   * mapped_table
   */
  mappedName?: string;
  /**
   * @example
   * table_name
   */
  name?: string;
  shardColumns?: string[];
  /**
   * @example
   * id > 1
   */
  whereClause?: string;
  static names(): { [key: string]: string } {
    return {
      adbTableSchema: 'AdbTableSchema',
      filterColumns: 'FilterColumns',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      shardColumns: 'ShardColumns',
      whereClause: 'WhereClause',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adbTableSchema: DescribeProjectResponseBodyDataTransferMappingDatabasesTablesAdbTableSchema,
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      mappedName: 'string',
      name: 'string',
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      whereClause: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataTransferMappingDatabasesViewsAdbTableSchema extends $tea.Model {
  distributedKeys?: string[];
  /**
   * @example
   * 30
   */
  partitionLifeCycle?: string;
  /**
   * @example
   * PARTITION BY VALUE(\\"id\\")
   */
  partitionStatement?: string;
  primaryKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      distributedKeys: 'DistributedKeys',
      partitionLifeCycle: 'PartitionLifeCycle',
      partitionStatement: 'PartitionStatement',
      primaryKeys: 'PrimaryKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      distributedKeys: { 'type': 'array', 'itemType': 'string' },
      partitionLifeCycle: 'string',
      partitionStatement: 'string',
      primaryKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataTransferMappingDatabasesViews extends $tea.Model {
  adbTableSchema?: DescribeProjectResponseBodyDataTransferMappingDatabasesViewsAdbTableSchema;
  filterColumns?: string[];
  /**
   * @example
   * fexdg***
   */
  id?: string;
  /**
   * @example
   * mapped_view
   */
  mappedName?: string;
  /**
   * @example
   * view_name
   */
  name?: string;
  shardColumns?: string[];
  /**
   * @example
   * id < 1
   */
  whereClause?: string;
  static names(): { [key: string]: string } {
    return {
      adbTableSchema: 'AdbTableSchema',
      filterColumns: 'FilterColumns',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      shardColumns: 'ShardColumns',
      whereClause: 'WhereClause',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adbTableSchema: DescribeProjectResponseBodyDataTransferMappingDatabasesViewsAdbTableSchema,
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      mappedName: 'string',
      name: 'string',
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      whereClause: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataTransferMappingDatabases extends $tea.Model {
  /**
   * @example
   * db_id
   */
  id?: string;
  /**
   * @example
   * mapped_db
   */
  mappedName?: string;
  /**
   * @example
   * db_name
   */
  name?: string;
  specificTables?: DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificTables[];
  specificViews?: DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificViews[];
  tables?: DescribeProjectResponseBodyDataTransferMappingDatabasesTables[];
  /**
   * @example
   * tenant_name
   */
  tenantName?: string;
  /**
   * @example
   * MYSQL
   */
  type?: string;
  views?: DescribeProjectResponseBodyDataTransferMappingDatabasesViews[];
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      specificTables: 'SpecificTables',
      specificViews: 'SpecificViews',
      tables: 'Tables',
      tenantName: 'TenantName',
      type: 'Type',
      views: 'Views',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      mappedName: 'string',
      name: 'string',
      specificTables: { 'type': 'array', 'itemType': DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificTables },
      specificViews: { 'type': 'array', 'itemType': DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificViews },
      tables: { 'type': 'array', 'itemType': DescribeProjectResponseBodyDataTransferMappingDatabasesTables },
      tenantName: 'string',
      type: 'string',
      views: { 'type': 'array', 'itemType': DescribeProjectResponseBodyDataTransferMappingDatabasesViews },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificTablesAdbTableSchema extends $tea.Model {
  distributedKeys?: string[];
  /**
   * @example
   * 30
   */
  partitionLifeCycle?: string;
  /**
   * @example
   * PARTITION BY VALUE(\\"id\\")
   */
  partitionStatement?: string;
  primaryKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      distributedKeys: 'DistributedKeys',
      partitionLifeCycle: 'PartitionLifeCycle',
      partitionStatement: 'PartitionStatement',
      primaryKeys: 'PrimaryKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      distributedKeys: { 'type': 'array', 'itemType': 'string' },
      partitionLifeCycle: 'string',
      partitionStatement: 'string',
      primaryKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificTables extends $tea.Model {
  adbTableSchema?: DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificTablesAdbTableSchema;
  filterColumns?: string[];
  /**
   * @example
   * table_id
   */
  id?: string;
  /**
   * @example
   * mapped_table
   */
  mappedName?: string;
  /**
   * @example
   * table_name
   */
  name?: string;
  shardColumns?: string[];
  /**
   * @example
   * id<3
   */
  whereClause?: string;
  static names(): { [key: string]: string } {
    return {
      adbTableSchema: 'AdbTableSchema',
      filterColumns: 'FilterColumns',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      shardColumns: 'ShardColumns',
      whereClause: 'WhereClause',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adbTableSchema: DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificTablesAdbTableSchema,
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      mappedName: 'string',
      name: 'string',
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      whereClause: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificViewsAdbTableSchema extends $tea.Model {
  distributedKeys?: string[];
  /**
   * @example
   * 30
   */
  partitionLifeCycle?: string;
  /**
   * @example
   * PARTITION BY VALUE(\\"id\\")
   */
  partitionStatement?: string;
  primaryKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      distributedKeys: 'DistributedKeys',
      partitionLifeCycle: 'PartitionLifeCycle',
      partitionStatement: 'PartitionStatement',
      primaryKeys: 'PrimaryKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      distributedKeys: { 'type': 'array', 'itemType': 'string' },
      partitionLifeCycle: 'string',
      partitionStatement: 'string',
      primaryKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificViews extends $tea.Model {
  adbTableSchema?: DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificViewsAdbTableSchema;
  filterColumns?: string[];
  /**
   * @example
   * view_id
   */
  id?: string;
  /**
   * @example
   * mapped_view
   */
  mappedName?: string;
  /**
   * @example
   * view_name
   */
  name?: string;
  shardColumns?: string[];
  /**
   * @example
   * id>2
   */
  whereClause?: string;
  static names(): { [key: string]: string } {
    return {
      adbTableSchema: 'AdbTableSchema',
      filterColumns: 'FilterColumns',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      shardColumns: 'ShardColumns',
      whereClause: 'WhereClause',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adbTableSchema: DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificViewsAdbTableSchema,
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      mappedName: 'string',
      name: 'string',
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      whereClause: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataTransferMappingDatabasesBlackTablesAdbTableSchema extends $tea.Model {
  distributedKeys?: string[];
  /**
   * @example
   * 30
   */
  partitionLifeCycle?: string;
  /**
   * @example
   * PARTITION BY VALUE(\\"id\\")
   */
  partitionStatement?: string;
  primaryKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      distributedKeys: 'DistributedKeys',
      partitionLifeCycle: 'PartitionLifeCycle',
      partitionStatement: 'PartitionStatement',
      primaryKeys: 'PrimaryKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      distributedKeys: { 'type': 'array', 'itemType': 'string' },
      partitionLifeCycle: 'string',
      partitionStatement: 'string',
      primaryKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataTransferMappingDatabasesBlackTables extends $tea.Model {
  adbTableSchema?: DescribeProjectResponseBodyDataTransferMappingDatabasesBlackTablesAdbTableSchema;
  filterColumns?: string[];
  /**
   * @example
   * table_id
   */
  id?: string;
  /**
   * @example
   * mapped_table
   */
  mappedName?: string;
  /**
   * @example
   * table_name
   */
  name?: string;
  shardColumns?: string[];
  /**
   * @example
   * id>1
   */
  whereClause?: string;
  static names(): { [key: string]: string } {
    return {
      adbTableSchema: 'AdbTableSchema',
      filterColumns: 'FilterColumns',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      shardColumns: 'ShardColumns',
      whereClause: 'WhereClause',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adbTableSchema: DescribeProjectResponseBodyDataTransferMappingDatabasesBlackTablesAdbTableSchema,
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      mappedName: 'string',
      name: 'string',
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      whereClause: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataTransferMappingDatabasesBlackViewsAdbTableSchema extends $tea.Model {
  distributedKeys?: string[];
  /**
   * @example
   * 30
   */
  partitionLifeCycle?: string;
  /**
   * @example
   * PARTITION BY VALUE(\\"id\\")
   */
  partitionStatement?: string;
  primaryKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      distributedKeys: 'DistributedKeys',
      partitionLifeCycle: 'PartitionLifeCycle',
      partitionStatement: 'PartitionStatement',
      primaryKeys: 'PrimaryKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      distributedKeys: { 'type': 'array', 'itemType': 'string' },
      partitionLifeCycle: 'string',
      partitionStatement: 'string',
      primaryKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataTransferMappingDatabasesBlackViews extends $tea.Model {
  adbTableSchema?: DescribeProjectResponseBodyDataTransferMappingDatabasesBlackViewsAdbTableSchema;
  filterColumns?: string[];
  /**
   * @example
   * view_id
   */
  id?: string;
  /**
   * @example
   * mapped_name
   */
  mappedName?: string;
  /**
   * @example
   * view_name
   */
  name?: string;
  shardColumns?: string[];
  /**
   * @example
   * id>2
   */
  whereClause?: string;
  static names(): { [key: string]: string } {
    return {
      adbTableSchema: 'AdbTableSchema',
      filterColumns: 'FilterColumns',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      shardColumns: 'ShardColumns',
      whereClause: 'WhereClause',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adbTableSchema: DescribeProjectResponseBodyDataTransferMappingDatabasesBlackViewsAdbTableSchema,
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      mappedName: 'string',
      name: 'string',
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      whereClause: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataTransferMappingDatabasesBlack extends $tea.Model {
  /**
   * @example
   * db_id
   */
  id?: string;
  /**
   * @example
   * mapped_db
   */
  mappedName?: string;
  /**
   * @example
   * db_name
   */
  name?: string;
  specificTables?: DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificTables[];
  specificViews?: DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificViews[];
  tables?: DescribeProjectResponseBodyDataTransferMappingDatabasesBlackTables[];
  /**
   * @example
   * mapped_tenant
   */
  tenantName?: string;
  /**
   * @example
   * DATABASE
   */
  type?: string;
  views?: DescribeProjectResponseBodyDataTransferMappingDatabasesBlackViews[];
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      specificTables: 'SpecificTables',
      specificViews: 'SpecificViews',
      tables: 'Tables',
      tenantName: 'TenantName',
      type: 'Type',
      views: 'Views',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      mappedName: 'string',
      name: 'string',
      specificTables: { 'type': 'array', 'itemType': DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificTables },
      specificViews: { 'type': 'array', 'itemType': DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificViews },
      tables: { 'type': 'array', 'itemType': DescribeProjectResponseBodyDataTransferMappingDatabasesBlackTables },
      tenantName: 'string',
      type: 'string',
      views: { 'type': 'array', 'itemType': DescribeProjectResponseBodyDataTransferMappingDatabasesBlackViews },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataTransferMapping extends $tea.Model {
  databases?: DescribeProjectResponseBodyDataTransferMappingDatabases[];
  databasesBlack?: DescribeProjectResponseBodyDataTransferMappingDatabasesBlack[];
  /**
   * @example
   * SPECIFIC
   */
  mode?: string;
  tableAndViewBlackList?: string[];
  tableAndViewWhiteList?: string[];
  static names(): { [key: string]: string } {
    return {
      databases: 'Databases',
      databasesBlack: 'DatabasesBlack',
      mode: 'Mode',
      tableAndViewBlackList: 'TableAndViewBlackList',
      tableAndViewWhiteList: 'TableAndViewWhiteList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      databases: { 'type': 'array', 'itemType': DescribeProjectResponseBodyDataTransferMappingDatabases },
      databasesBlack: { 'type': 'array', 'itemType': DescribeProjectResponseBodyDataTransferMappingDatabasesBlack },
      mode: 'string',
      tableAndViewBlackList: { 'type': 'array', 'itemType': 'string' },
      tableAndViewWhiteList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataWorkerGradeInfo extends $tea.Model {
  autoRenewal?: boolean;
  chargeType?: string;
  destRegion?: string;
  destType?: string;
  endTime?: string;
  expired?: boolean;
  gmtCreate?: string;
  grade?: string;
  id?: string;
  name?: string;
  sourceRegion?: string;
  sourceType?: string;
  spec?: string;
  specName?: string;
  static names(): { [key: string]: string } {
    return {
      autoRenewal: 'AutoRenewal',
      chargeType: 'ChargeType',
      destRegion: 'DestRegion',
      destType: 'DestType',
      endTime: 'EndTime',
      expired: 'Expired',
      gmtCreate: 'GmtCreate',
      grade: 'Grade',
      id: 'Id',
      name: 'Name',
      sourceRegion: 'SourceRegion',
      sourceType: 'SourceType',
      spec: 'Spec',
      specName: 'SpecName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoRenewal: 'boolean',
      chargeType: 'string',
      destRegion: 'string',
      destType: 'string',
      endTime: 'string',
      expired: 'boolean',
      gmtCreate: 'string',
      grade: 'string',
      id: 'string',
      name: 'string',
      sourceRegion: 'string',
      sourceType: 'string',
      spec: 'string',
      specName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyData extends $tea.Model {
  alarmStats?: DescribeProjectResponseBodyDataAlarmStats;
  commonTransferConfig?: DescribeProjectResponseBodyDataCommonTransferConfig;
  /**
   * @example
   * c_deg***
   */
  destConnId?: string;
  /**
   * @example
   * true
   */
  enableFullTransfer?: boolean;
  /**
   * @example
   * true
   */
  enableFullVerify?: boolean;
  /**
   * @example
   * true
   */
  enableIncrTransfer?: boolean;
  /**
   * @example
   * true
   */
  enableIncrVerify?: boolean;
  /**
   * @example
   * true
   */
  enableReverseIncrTransfer?: boolean;
  /**
   * @example
   * true
   */
  enableStructTransfer?: boolean;
  extraInfo?: DescribeProjectResponseBodyDataExtraInfo;
  fullTransferConfig?: DescribeProjectResponseBodyDataFullTransferConfig;
  /**
   * @example
   * 2023-07-13T06:26:15
   */
  gmtCreate?: string;
  /**
   * @example
   * 2023-07-13T07:02:27
   */
  gmtFinish?: string;
  /**
   * @example
   * 2023-07-13T06:26:15
   */
  gmtModified?: string;
  /**
   * @example
   * 2023-07-13T07:02:27
   */
  gmtStart?: string;
  /**
   * @example
   * np_fe****
   */
  id?: string;
  /**
   * @example
   * HIGH
   */
  importance?: string;
  incrTransferConfig?: DescribeProjectResponseBodyDataIncrTransferConfig;
  /**
   * @example
   * false
   */
  isMerging?: boolean;
  /**
   * @example
   * false
   */
  isModifying?: boolean;
  /**
   * @example
   * false
   */
  isSubProject?: boolean;
  labels?: DescribeProjectResponseBodyDataLabels[];
  /**
   * @example
   * test
   */
  name?: string;
  /**
   * @example
   * omsefry***
   */
  owner?: string;
  reverseIncrTransferConfig?: DescribeProjectResponseBodyDataReverseIncrTransferConfig;
  sinkConnectInfo?: DescribeProjectResponseBodyDataSinkConnectInfo;
  /**
   * @example
   * MYSQL
   */
  sinkEndpointType?: string;
  sourceConnectInfo?: DescribeProjectResponseBodyDataSourceConnectInfo;
  /**
   * @example
   * OB_MYSQL
   */
  sourceEndpointType?: string;
  /**
   * @example
   * RUNNING
   */
  status?: string;
  steps?: DescribeProjectResponseBodyDataSteps[];
  structTransferConfig?: DescribeProjectResponseBodyDataStructTransferConfig;
  transferMapping?: DescribeProjectResponseBodyDataTransferMapping;
  /**
   * @example
   * SYNC
   */
  type?: string;
  /**
   * @example
   * g_i4wa7XXX
   */
  workerGradeId?: string;
  workerGradeInfo?: DescribeProjectResponseBodyDataWorkerGradeInfo;
  static names(): { [key: string]: string } {
    return {
      alarmStats: 'AlarmStats',
      commonTransferConfig: 'CommonTransferConfig',
      destConnId: 'DestConnId',
      enableFullTransfer: 'EnableFullTransfer',
      enableFullVerify: 'EnableFullVerify',
      enableIncrTransfer: 'EnableIncrTransfer',
      enableIncrVerify: 'EnableIncrVerify',
      enableReverseIncrTransfer: 'EnableReverseIncrTransfer',
      enableStructTransfer: 'EnableStructTransfer',
      extraInfo: 'ExtraInfo',
      fullTransferConfig: 'FullTransferConfig',
      gmtCreate: 'GmtCreate',
      gmtFinish: 'GmtFinish',
      gmtModified: 'GmtModified',
      gmtStart: 'GmtStart',
      id: 'Id',
      importance: 'Importance',
      incrTransferConfig: 'IncrTransferConfig',
      isMerging: 'IsMerging',
      isModifying: 'IsModifying',
      isSubProject: 'IsSubProject',
      labels: 'Labels',
      name: 'Name',
      owner: 'Owner',
      reverseIncrTransferConfig: 'ReverseIncrTransferConfig',
      sinkConnectInfo: 'SinkConnectInfo',
      sinkEndpointType: 'SinkEndpointType',
      sourceConnectInfo: 'SourceConnectInfo',
      sourceEndpointType: 'SourceEndpointType',
      status: 'Status',
      steps: 'Steps',
      structTransferConfig: 'StructTransferConfig',
      transferMapping: 'TransferMapping',
      type: 'Type',
      workerGradeId: 'WorkerGradeId',
      workerGradeInfo: 'WorkerGradeInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alarmStats: DescribeProjectResponseBodyDataAlarmStats,
      commonTransferConfig: DescribeProjectResponseBodyDataCommonTransferConfig,
      destConnId: 'string',
      enableFullTransfer: 'boolean',
      enableFullVerify: 'boolean',
      enableIncrTransfer: 'boolean',
      enableIncrVerify: 'boolean',
      enableReverseIncrTransfer: 'boolean',
      enableStructTransfer: 'boolean',
      extraInfo: DescribeProjectResponseBodyDataExtraInfo,
      fullTransferConfig: DescribeProjectResponseBodyDataFullTransferConfig,
      gmtCreate: 'string',
      gmtFinish: 'string',
      gmtModified: 'string',
      gmtStart: 'string',
      id: 'string',
      importance: 'string',
      incrTransferConfig: DescribeProjectResponseBodyDataIncrTransferConfig,
      isMerging: 'boolean',
      isModifying: 'boolean',
      isSubProject: 'boolean',
      labels: { 'type': 'array', 'itemType': DescribeProjectResponseBodyDataLabels },
      name: 'string',
      owner: 'string',
      reverseIncrTransferConfig: DescribeProjectResponseBodyDataReverseIncrTransferConfig,
      sinkConnectInfo: DescribeProjectResponseBodyDataSinkConnectInfo,
      sinkEndpointType: 'string',
      sourceConnectInfo: DescribeProjectResponseBodyDataSourceConnectInfo,
      sourceEndpointType: 'string',
      status: 'string',
      steps: { 'type': 'array', 'itemType': DescribeProjectResponseBodyDataSteps },
      structTransferConfig: DescribeProjectResponseBodyDataStructTransferConfig,
      transferMapping: DescribeProjectResponseBodyDataTransferMapping,
      type: 'string',
      workerGradeId: 'string',
      workerGradeInfo: DescribeProjectResponseBodyDataWorkerGradeInfo,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyErrorDetail extends $tea.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * null
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectComponentsResponseBodyDataFullImportComponentsErrorDetails extends $tea.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * null
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectComponentsResponseBodyDataFullImportComponents extends $tea.Model {
  errorDetails?: DescribeProjectComponentsResponseBodyDataFullImportComponentsErrorDetails[];
  /**
   * @example
   * 2023-07-13T18:04:36
   */
  gmtCreate?: string;
  /**
   * @example
   * 2023-07-13T18:04:36
   */
  gmtModify?: string;
  /**
   * @example
   * p_4w8v****
   */
  identity?: string;
  /**
   * @example
   * xxx.xxx.xxx.1
   */
  ip?: string;
  /**
   * @example
   * xxx.xxx.xxx.1-9000:connector_v2:np_4w8v****c-full_trans-1-0:0000000276
   */
  name?: string;
  /**
   * @example
   * 90
   */
  progress?: number;
  /**
   * @example
   * cn-hangzhou
   */
  region?: string;
  /**
   * @example
   * RUNNING
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      errorDetails: 'ErrorDetails',
      gmtCreate: 'GmtCreate',
      gmtModify: 'GmtModify',
      identity: 'Identity',
      ip: 'Ip',
      name: 'Name',
      progress: 'Progress',
      region: 'Region',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorDetails: { 'type': 'array', 'itemType': DescribeProjectComponentsResponseBodyDataFullImportComponentsErrorDetails },
      gmtCreate: 'string',
      gmtModify: 'string',
      identity: 'string',
      ip: 'string',
      name: 'string',
      progress: 'number',
      region: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectComponentsResponseBodyDataFullVerifyComponentsErrorDetails extends $tea.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * null
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectComponentsResponseBodyDataFullVerifyComponents extends $tea.Model {
  /**
   * @example
   * 100
   */
  consistentQuantity?: number;
  errorDetails?: DescribeProjectComponentsResponseBodyDataFullVerifyComponentsErrorDetails[];
  /**
   * @example
   * 0
   */
  inconsistentQuantity?: number;
  /**
   * @example
   * xxx.xxx.xxx.1
   */
  ip?: string;
  /**
   * @example
   * xxx.xxx.xxx.1-9000:90247:0000000033
   */
  name?: string;
  /**
   * @example
   * 100
   */
  progress?: string;
  /**
   * @example
   * 100
   */
  recordProgress?: number;
  /**
   * @example
   * cn-beijing
   */
  region?: string;
  /**
   * @example
   * RUNNING
   */
  status?: string;
  /**
   * @example
   * 1345***
   */
  taskId?: number;
  static names(): { [key: string]: string } {
    return {
      consistentQuantity: 'ConsistentQuantity',
      errorDetails: 'ErrorDetails',
      inconsistentQuantity: 'InconsistentQuantity',
      ip: 'Ip',
      name: 'Name',
      progress: 'Progress',
      recordProgress: 'RecordProgress',
      region: 'Region',
      status: 'Status',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consistentQuantity: 'number',
      errorDetails: { 'type': 'array', 'itemType': DescribeProjectComponentsResponseBodyDataFullVerifyComponentsErrorDetails },
      inconsistentQuantity: 'number',
      ip: 'string',
      name: 'string',
      progress: 'string',
      recordProgress: 'number',
      region: 'string',
      status: 'string',
      taskId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectComponentsResponseBodyDataIncrSyncComponentsErrorDetails extends $tea.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * null
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectComponentsResponseBodyDataIncrSyncComponents extends $tea.Model {
  /**
   * @example
   * 2023-07-13T09:19:53
   */
  checkpoint?: string;
  /**
   * @example
   * 1689250071
   */
  checkpointSampleTimestamp?: number;
  /**
   * @example
   * 1
   */
  delay?: number;
  errorDetails?: DescribeProjectComponentsResponseBodyDataIncrSyncComponentsErrorDetails[];
  /**
   * @example
   * 2023-07-13T18:04:36
   */
  gmtCreate?: string;
  /**
   * @example
   * 2023-07-13T18:04:36
   */
  gmtModify?: string;
  /**
   * @example
   * np_4w***
   */
  identity?: string;
  /**
   * @example
   * xxx.xxx.xxx.1
   */
  ip?: string;
  /**
   * @example
   * xxx.xxx.xxx.1-9000:connector_v2:np_4w****jxc-incr_trans-1-0:0000000277
   */
  name?: string;
  /**
   * @example
   * cn-zhangjiakou
   */
  region?: string;
  /**
   * @example
   * RUNNING
   */
  status?: string;
  subtopics?: string[];
  /**
   * @example
   * 1
   */
  tps?: number;
  static names(): { [key: string]: string } {
    return {
      checkpoint: 'Checkpoint',
      checkpointSampleTimestamp: 'CheckpointSampleTimestamp',
      delay: 'Delay',
      errorDetails: 'ErrorDetails',
      gmtCreate: 'GmtCreate',
      gmtModify: 'GmtModify',
      identity: 'Identity',
      ip: 'Ip',
      name: 'Name',
      region: 'Region',
      status: 'Status',
      subtopics: 'Subtopics',
      tps: 'Tps',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkpoint: 'string',
      checkpointSampleTimestamp: 'number',
      delay: 'number',
      errorDetails: { 'type': 'array', 'itemType': DescribeProjectComponentsResponseBodyDataIncrSyncComponentsErrorDetails },
      gmtCreate: 'string',
      gmtModify: 'string',
      identity: 'string',
      ip: 'string',
      name: 'string',
      region: 'string',
      status: 'string',
      subtopics: { 'type': 'array', 'itemType': 'string' },
      tps: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectComponentsResponseBodyDataReverseIncrSyncComponentsErrorDetails extends $tea.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * null
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectComponentsResponseBodyDataReverseIncrSyncComponents extends $tea.Model {
  /**
   * @example
   * 2023-07-13T09:19:53
   */
  checkpoint?: string;
  /**
   * @example
   * 1689250049
   */
  checkpointSampleTimestamp?: number;
  /**
   * @example
   * 1
   */
  delay?: number;
  errorDetails?: DescribeProjectComponentsResponseBodyDataReverseIncrSyncComponentsErrorDetails[];
  /**
   * @example
   * 2023-07-13T18:04:36
   */
  gmtCreate?: string;
  /**
   * @example
   * 2023-07-13T18:04:36
   */
  gmtModify?: string;
  /**
   * @example
   * np_4w8****
   */
  identity?: string;
  /**
   * @example
   * xxx.xxx.xxx.1
   */
  ip?: string;
  /**
   * @example
   * xxx.xxx.xxx.1-9000:connector_v2:np_4w8****9jxc-incr_trans-1-0:0000000277
   */
  name?: string;
  /**
   * @example
   * cn-shanghai
   */
  region?: string;
  /**
   * @example
   * RUNNING
   */
  status?: string;
  subtopics?: string[];
  /**
   * @example
   * 1
   */
  tps?: number;
  static names(): { [key: string]: string } {
    return {
      checkpoint: 'Checkpoint',
      checkpointSampleTimestamp: 'CheckpointSampleTimestamp',
      delay: 'Delay',
      errorDetails: 'ErrorDetails',
      gmtCreate: 'GmtCreate',
      gmtModify: 'GmtModify',
      identity: 'Identity',
      ip: 'Ip',
      name: 'Name',
      region: 'Region',
      status: 'Status',
      subtopics: 'Subtopics',
      tps: 'Tps',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkpoint: 'string',
      checkpointSampleTimestamp: 'number',
      delay: 'number',
      errorDetails: { 'type': 'array', 'itemType': DescribeProjectComponentsResponseBodyDataReverseIncrSyncComponentsErrorDetails },
      gmtCreate: 'string',
      gmtModify: 'string',
      identity: 'string',
      ip: 'string',
      name: 'string',
      region: 'string',
      status: 'string',
      subtopics: { 'type': 'array', 'itemType': 'string' },
      tps: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectComponentsResponseBodyDataReverseStoreListErrorDetails extends $tea.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * null
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectComponentsResponseBodyDataReverseStoreList extends $tea.Model {
  /**
   * @example
   * 2023-07-13T09:19:53
   */
  beginCheckpoint?: string;
  /**
   * @example
   * 1
   */
  conn?: number;
  /**
   * @example
   * 1
   */
  delay?: number;
  /**
   * @example
   * 2023-07-13T09:19:53
   */
  endCheckpoint?: string;
  /**
   * @example
   * null
   */
  errMsg?: string;
  errorDetails?: DescribeProjectComponentsResponseBodyDataReverseStoreListErrorDetails[];
  /**
   * @example
   * 1689250071
   */
  gmt?: number;
  /**
   * @example
   * 2023-07-13T18:04:36
   */
  gmtCreate?: string;
  /**
   * @example
   * 2023-07-13T18:04:36
   */
  gmtModified?: string;
  /**
   * @example
   * xxx.xxx.xxx.1
   */
  ip?: string;
  /**
   * @example
   * 1689250071
   */
  latelyHeartbeatTimeSec?: number;
  /**
   * @example
   * xxx.xxx.xxx.1-9000:connector_v2:np_4w****9jxc-incr_trans-1-0:0000000277
   */
  name?: string;
  /**
   * @example
   * 2883
   */
  port?: number;
  /**
   * @example
   * cn-shenzhen
   */
  region?: string;
  /**
   * @example
   * EXCEPTION
   */
  status?: string;
  /**
   * @example
   * 2882
   */
  storePort?: number;
  /**
   * @remarks
   * SubTopic。
   * 
   * @example
   * null
   */
  subtopic?: string;
  /**
   * @example
   * false
   */
  toSwitch?: boolean;
  /**
   * @remarks
   * Topic。
   * 
   * @example
   * null
   */
  topic?: string;
  /**
   * @example
   * 1
   */
  tps?: number;
  static names(): { [key: string]: string } {
    return {
      beginCheckpoint: 'BeginCheckpoint',
      conn: 'Conn',
      delay: 'Delay',
      endCheckpoint: 'EndCheckpoint',
      errMsg: 'ErrMsg',
      errorDetails: 'ErrorDetails',
      gmt: 'Gmt',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      ip: 'Ip',
      latelyHeartbeatTimeSec: 'LatelyHeartbeatTimeSec',
      name: 'Name',
      port: 'Port',
      region: 'Region',
      status: 'Status',
      storePort: 'StorePort',
      subtopic: 'Subtopic',
      toSwitch: 'ToSwitch',
      topic: 'Topic',
      tps: 'Tps',
    };
  }

  static types(): { [key: string]: any } {
    return {
      beginCheckpoint: 'string',
      conn: 'number',
      delay: 'number',
      endCheckpoint: 'string',
      errMsg: 'string',
      errorDetails: { 'type': 'array', 'itemType': DescribeProjectComponentsResponseBodyDataReverseStoreListErrorDetails },
      gmt: 'number',
      gmtCreate: 'string',
      gmtModified: 'string',
      ip: 'string',
      latelyHeartbeatTimeSec: 'number',
      name: 'string',
      port: 'number',
      region: 'string',
      status: 'string',
      storePort: 'number',
      subtopic: 'string',
      toSwitch: 'boolean',
      topic: 'string',
      tps: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectComponentsResponseBodyDataStoreListErrorDetails extends $tea.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * null
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectComponentsResponseBodyDataStoreList extends $tea.Model {
  /**
   * @example
   * 2023-07-13T09:19:53
   */
  beginCheckpoint?: string;
  /**
   * @example
   * 1
   */
  conn?: number;
  /**
   * @example
   * 24
   */
  delay?: number;
  /**
   * @example
   * 2023-07-13T09:19:53
   */
  endCheckpoint?: string;
  /**
   * @example
   * null
   */
  errMsg?: string;
  errorDetails?: DescribeProjectComponentsResponseBodyDataStoreListErrorDetails[];
  /**
   * @example
   * 1689250049
   */
  gmt?: number;
  /**
   * @example
   * 2023-07-13T17:29:54
   */
  gmtCreate?: string;
  /**
   * @example
   * 2023-07-13T17:29:54
   */
  gmtModified?: string;
  /**
   * @example
   * xxx.xxx.xxx.1
   */
  ip?: string;
  /**
   * @example
   * 1689250071
   */
  latelyHeartbeatTimeSec?: number;
  /**
   * @example
   * xxx.xxx.xxx.1-7145:OB_ORACLE_np_4w3r***_4w:0000***97
   */
  name?: string;
  /**
   * @example
   * 2883
   */
  port?: number;
  /**
   * @example
   * cn-shanghai
   */
  region?: string;
  /**
   * @example
   * EXCEPTION
   */
  status?: string;
  /**
   * @example
   * 2882
   */
  storePort?: number;
  /**
   * @remarks
   * SubTopic。
   * 
   * @example
   * OB_ORACLE_np_4w3***c_4w3**-0
   */
  subtopic?: string;
  /**
   * @example
   * false
   */
  toSwitch?: boolean;
  /**
   * @remarks
   * Topic。
   * 
   * @example
   * OB_ORACLE_np_4w3r29c_4w3****
   */
  topic?: string;
  /**
   * @example
   * 0
   */
  tps?: number;
  static names(): { [key: string]: string } {
    return {
      beginCheckpoint: 'BeginCheckpoint',
      conn: 'Conn',
      delay: 'Delay',
      endCheckpoint: 'EndCheckpoint',
      errMsg: 'ErrMsg',
      errorDetails: 'ErrorDetails',
      gmt: 'Gmt',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      ip: 'Ip',
      latelyHeartbeatTimeSec: 'LatelyHeartbeatTimeSec',
      name: 'Name',
      port: 'Port',
      region: 'Region',
      status: 'Status',
      storePort: 'StorePort',
      subtopic: 'Subtopic',
      toSwitch: 'ToSwitch',
      topic: 'Topic',
      tps: 'Tps',
    };
  }

  static types(): { [key: string]: any } {
    return {
      beginCheckpoint: 'string',
      conn: 'number',
      delay: 'number',
      endCheckpoint: 'string',
      errMsg: 'string',
      errorDetails: { 'type': 'array', 'itemType': DescribeProjectComponentsResponseBodyDataStoreListErrorDetails },
      gmt: 'number',
      gmtCreate: 'string',
      gmtModified: 'string',
      ip: 'string',
      latelyHeartbeatTimeSec: 'number',
      name: 'string',
      port: 'number',
      region: 'string',
      status: 'string',
      storePort: 'number',
      subtopic: 'string',
      toSwitch: 'boolean',
      topic: 'string',
      tps: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectComponentsResponseBodyData extends $tea.Model {
  fullImportComponents?: DescribeProjectComponentsResponseBodyDataFullImportComponents[];
  fullVerifyComponents?: DescribeProjectComponentsResponseBodyDataFullVerifyComponents[];
  incrSyncComponents?: DescribeProjectComponentsResponseBodyDataIncrSyncComponents[];
  reverseIncrSyncComponents?: DescribeProjectComponentsResponseBodyDataReverseIncrSyncComponents[];
  reverseStoreList?: DescribeProjectComponentsResponseBodyDataReverseStoreList[];
  storeList?: DescribeProjectComponentsResponseBodyDataStoreList[];
  static names(): { [key: string]: string } {
    return {
      fullImportComponents: 'FullImportComponents',
      fullVerifyComponents: 'FullVerifyComponents',
      incrSyncComponents: 'IncrSyncComponents',
      reverseIncrSyncComponents: 'ReverseIncrSyncComponents',
      reverseStoreList: 'ReverseStoreList',
      storeList: 'StoreList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fullImportComponents: { 'type': 'array', 'itemType': DescribeProjectComponentsResponseBodyDataFullImportComponents },
      fullVerifyComponents: { 'type': 'array', 'itemType': DescribeProjectComponentsResponseBodyDataFullVerifyComponents },
      incrSyncComponents: { 'type': 'array', 'itemType': DescribeProjectComponentsResponseBodyDataIncrSyncComponents },
      reverseIncrSyncComponents: { 'type': 'array', 'itemType': DescribeProjectComponentsResponseBodyDataReverseIncrSyncComponents },
      reverseStoreList: { 'type': 'array', 'itemType': DescribeProjectComponentsResponseBodyDataReverseStoreList },
      storeList: { 'type': 'array', 'itemType': DescribeProjectComponentsResponseBodyDataStoreList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectComponentsResponseBodyErrorDetail extends $tea.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * null
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectProgressResponseBodyData extends $tea.Model {
  /**
   * @example
   * MEDIUM
   */
  alarmLevel?: string;
  /**
   * @example
   * PRE_CHECK
   */
  currentStep?: string;
  /**
   * @example
   * true
   */
  enableFullTransfer?: boolean;
  /**
   * @example
   * true
   */
  enableIncrSync?: boolean;
  /**
   * @example
   * true
   */
  enableReverseIncrTransfer?: boolean;
  /**
   * @example
   * true
   */
  enableStructTransfer?: boolean;
  /**
   * @example
   * 100
   */
  fullTransferProgress?: number;
  /**
   * @example
   * 1689248064
   */
  incrSyncCheckpoint?: number;
  /**
   * @example
   * np_fe****
   */
  projectId?: string;
  /**
   * @example
   * 1689248075
   */
  reverseIncrTransferCheckpoint?: number;
  /**
   * @example
   * RUNNING
   */
  status?: string;
  /**
   * @example
   * 100
   */
  structTransferProgress?: number;
  static names(): { [key: string]: string } {
    return {
      alarmLevel: 'AlarmLevel',
      currentStep: 'CurrentStep',
      enableFullTransfer: 'EnableFullTransfer',
      enableIncrSync: 'EnableIncrSync',
      enableReverseIncrTransfer: 'EnableReverseIncrTransfer',
      enableStructTransfer: 'EnableStructTransfer',
      fullTransferProgress: 'FullTransferProgress',
      incrSyncCheckpoint: 'IncrSyncCheckpoint',
      projectId: 'ProjectId',
      reverseIncrTransferCheckpoint: 'ReverseIncrTransferCheckpoint',
      status: 'Status',
      structTransferProgress: 'StructTransferProgress',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alarmLevel: 'string',
      currentStep: 'string',
      enableFullTransfer: 'boolean',
      enableIncrSync: 'boolean',
      enableReverseIncrTransfer: 'boolean',
      enableStructTransfer: 'boolean',
      fullTransferProgress: 'number',
      incrSyncCheckpoint: 'number',
      projectId: 'string',
      reverseIncrTransferCheckpoint: 'number',
      status: 'string',
      structTransferProgress: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectProgressResponseBodyErrorDetail extends $tea.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * null
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectStepMetricResponseBodyDataMetricsDataPoints extends $tea.Model {
  /**
   * @example
   * 1689244696
   */
  timestamp?: number;
  /**
   * @example
   * 0
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      timestamp: 'Timestamp',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timestamp: 'number',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectStepMetricResponseBodyDataMetrics extends $tea.Model {
  dataPoints?: DescribeProjectStepMetricResponseBodyDataMetricsDataPoints[];
  /**
   * @example
   * metric_name
   */
  name?: string;
  tags?: { [key: string]: string };
  static names(): { [key: string]: string } {
    return {
      dataPoints: 'DataPoints',
      name: 'Name',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataPoints: { 'type': 'array', 'itemType': DescribeProjectStepMetricResponseBodyDataMetricsDataPoints },
      name: 'string',
      tags: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectStepMetricResponseBodyData extends $tea.Model {
  /**
   * @example
   * AVG
   */
  aggregator?: string;
  metrics?: DescribeProjectStepMetricResponseBodyDataMetrics[];
  /**
   * @example
   * null
   */
  referenceValue?: number;
  static names(): { [key: string]: string } {
    return {
      aggregator: 'Aggregator',
      metrics: 'Metrics',
      referenceValue: 'ReferenceValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aggregator: 'string',
      metrics: { 'type': 'array', 'itemType': DescribeProjectStepMetricResponseBodyDataMetrics },
      referenceValue: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectStepMetricResponseBodyErrorDetail extends $tea.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * null
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectStepsResponseBodyDataExtraInfoErrorDetails extends $tea.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * null
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectStepsResponseBodyDataExtraInfo extends $tea.Model {
  /**
   * @example
   * INNER_ERROR
   */
  errorCode?: string;
  errorDetails?: DescribeProjectStepsResponseBodyDataExtraInfoErrorDetails[];
  /**
   * @example
   * The ResourceDirectoryId is invalid.
   */
  errorMsg?: string;
  errorParam?: { [key: string]: string };
  /**
   * @example
   * null
   */
  failedTime?: string;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorDetails: 'ErrorDetails',
      errorMsg: 'ErrorMsg',
      errorParam: 'ErrorParam',
      failedTime: 'FailedTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorDetails: { 'type': 'array', 'itemType': DescribeProjectStepsResponseBodyDataExtraInfoErrorDetails },
      errorMsg: 'string',
      errorParam: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      failedTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectStepsResponseBodyData extends $tea.Model {
  description?: string;
  extraInfo?: DescribeProjectStepsResponseBodyDataExtraInfo;
  /**
   * @example
   * 2020-05-22T17:04:18
   */
  finishTime?: string;
  /**
   * @example
   * PRE_CHECK
   */
  name?: string;
  /**
   * @example
   * 1
   */
  order?: number;
  /**
   * @example
   * 100
   */
  progress?: number;
  /**
   * @example
   * 2020-05-22T17:04:18
   */
  startTime?: string;
  /**
   * @example
   * RUNNING
   */
  status?: string;
  /**
   * @example
   * null
   */
  stepInfo?: { [key: string]: any };
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      extraInfo: 'ExtraInfo',
      finishTime: 'FinishTime',
      name: 'Name',
      order: 'Order',
      progress: 'Progress',
      startTime: 'StartTime',
      status: 'Status',
      stepInfo: 'StepInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      extraInfo: DescribeProjectStepsResponseBodyDataExtraInfo,
      finishTime: 'string',
      name: 'string',
      order: 'number',
      progress: 'number',
      startTime: 'string',
      status: 'string',
      stepInfo: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectStepsResponseBodyErrorDetail extends $tea.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * Contact the administrator.
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRecommendIndexResponseBodyRecommendIndex extends $tea.Model {
  /**
   * @remarks
   * Example 1
   * 
   * @example
   * PRIMARY
   */
  suggestIndex?: string;
  /**
   * @example
   * testtable
   */
  tableList?: string;
  /**
   * @example
   * mysql
   */
  tenantMode?: string;
  static names(): { [key: string]: string } {
    return {
      suggestIndex: 'SuggestIndex',
      tableList: 'TableList',
      tenantMode: 'TenantMode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      suggestIndex: 'string',
      tableList: 'string',
      tenantMode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSQLDetailsResponseBodySQLDetails extends $tea.Model {
  /**
   * @example
   * testdb
   */
  dbName?: string;
  /**
   * @remarks
   * {"name":"DescribeSQLDetails","product":"OceanBasePro","version":"2019-09-01","path":"/","deprecated":0,"method":"POST|GET","protocol":"HTTP|HTTPS","hidden":0,"timeout":10000,"parameter_type":"Single","params":"[{\\"name\\":\\"Action\\",\\"position\\":\\"Query\\",\\"required\\":true,\\"checkBlank\\":false,\\"visibility\\":\\"Public\\",\\"deprecated\\":false,\\"type\\":\\"String\\",\\"description\\":\\"\\",\\"example\\":\\"DescribeSQLDetails\\"},{\\"name\\":\\"TenantId\\",\\"position\\":\\"Body\\",\\"required\\":true,\\"checkBlank\\":false,\\"visibility\\":\\"Public\\",\\"deprecated\\":false,\\"type\\":\\"String\\",\\"title\\":\\"\\",\\"description\\":\\"\\",\\"example\\":\\"t2mr3oae0****\\"},{\\"name\\":\\"SQLId\\",\\"position\\":\\"Body\\",\\"required\\":true,\\"checkBlank\\":false,\\"visibility\\":\\"Public\\",\\"deprecated\\":false,\\"type\\":\\"String\\",\\"title\\":\\"SQLID\\",\\"description\\":\\"SQLID。\\",\\"example\\":\\"8D6E84****0B8FB1823D199E2CA1****\\"}]","response_headers":"[]","response":"{\\"type\\":\\"Object\\",\\"children\\":[{\\"name\\":\\"RequestId\\",\\"required\\":false,\\"checkBlank\\":false,\\"visibility\\":\\"Public\\",\\"deprecated\\":false,\\"type\\":\\"String\\",\\"title\\":\\"\\",\\"description\\":\\"\\",\\"example\\":\\"473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E\\"},{\\"name\\":\\"SQLDetails\\",\\"required\\":false,\\"checkBlank\\":false,\\"visibility\\":\\"Public\\",\\"deprecated\\":false,\\"type\\":\\"Array\\",\\"subType\\":\\"Object\\",\\"description\\":\\"  \\",\\"children\\":[{\\"name\\":\\"SQLText\\",\\"required\\":false,\\"checkBlank\\":false,\\"visibility\\":\\"Public\\",\\"deprecated\\":false,\\"type\\":\\"String\\",\\"title\\":\\"\\",\\"description\\":\\"\\",\\"example\\":\\"SELECT  ****   FROM ****   WHERE **** = ? AND **** = ?   ORDER BY **** ASC\\"},{\\"name\\":\\"DbName\\",\\"required\\":false,\\"checkBlank\\":false,\\"visibility\\":\\"Public\\",\\"deprecated\\":false,\\"type\\":\\"String\\",\\"title\\":\\"\\",\\"description\\":\\"\\",\\"example\\":\\"testdb\\"},{\\"name\\":\\"UserName\\",\\"required\\":false,\\"checkBlank\\":false,\\"visibility\\":\\"Public\\",\\"deprecated\\":false,\\"type\\":\\"String\\",\\"title\\":\\"\\",\\"description\\":\\"\\",\\"example\\":\\"tester\\"}],\\"title\\":\\"\\"}],\\"title\\":\\"\\",\\"description\\":\\"\\"}","errors":"{}"}
   * 
   * @example
   * SELECT  ****   FROM ****   WHERE **** = ? AND **** = ?   ORDER BY **** ASC
   */
  SQLText?: string;
  /**
   * @example
   * tester
   */
  userName?: string;
  static names(): { [key: string]: string } {
    return {
      dbName: 'DbName',
      SQLText: 'SQLText',
      userName: 'UserName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbName: 'string',
      SQLText: 'string',
      userName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSQLHistoryListResponseBodySQLHistoryListList extends $tea.Model {
  /**
   * @remarks
   * The number of rows affected.
   * 
   * @example
   * 0
   */
  affectedRows?: number;
  /**
   * @remarks
   * The wait time of the client.
   * 
   * @example
   * 0.0
   */
  appWaitTime?: number;
  /**
   * @remarks
   * The number of block cache hits.
   * 
   * @example
   * 14
   */
  blockCacheHit?: number;
  /**
   * @remarks
   * The number of block index cache hits.
   * 
   * @example
   * 4
   */
  blockIndexCacheHit?: number;
  /**
   * @remarks
   * The number of Bloom filter cache hits.
   * 
   * @example
   * 0
   */
  bloomFilterCacheHit?: number;
  /**
   * @remarks
   * The IP address of the client.
   * 
   * @example
   * 1*2.***.1*3.***
   */
  clientIp?: string;
  /**
   * @remarks
   * The wait time in concurrent execution.
   * 
   * @example
   * 0.0
   */
  concurrencyWaitTime?: number;
  /**
   * @remarks
   * The average CPU time.
   * 
   * @example
   * 50.13
   */
  cpuTime?: number;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * testdb
   */
  dbName?: string;
  /**
   * @remarks
   * The time to wait for decoding.
   * 
   * @example
   * 0.0
   */
  decodeTime?: number;
  /**
   * @remarks
   * The number of physical reads.
   * 
   * @example
   * 0
   */
  diskRead?: number;
  /**
   * @remarks
   * The average response time.
   * 
   * @example
   * 76.382
   */
  elapsedTime?: number;
  /**
   * @remarks
   * The end time.
   * 
   * @example
   * 2021-12-28T02:08:18Z
   */
  endTime?: number;
  /**
   * @remarks
   * The end time in UTC +0.
   * 
   * @example
   * 2021-12-28T02:08:18Z
   */
  endTimeUTCString?: string;
  /**
   * @remarks
   * The wait event.
   * 
   * @example
   * mysql response wait client
   */
  event?: string;
  /**
   * @remarks
   * The number of executions per second.
   * 
   * @example
   * 163.0
   */
  execPerSecond?: number;
  /**
   * @remarks
   * The internal execution time.
   * 
   * @example
   * 61.044
   */
  executeTime?: number;
  /**
   * @remarks
   * The number of executions.
   * 
   * @example
   * 89403
   */
  executions?: number;
  /**
   * @remarks
   * The number of failures.
   * 
   * @example
   * 0
   */
  failTimes?: number;
  /**
   * @remarks
   * The time spent in hard parsing.
   * 
   * @example
   * 0.052
   */
  getPlanTime?: number;
  /**
   * @remarks
   * The I/O wait time.
   * 
   * @example
   * 0.0
   */
  IOWaitTime?: number;
  /**
   * @remarks
   * The number of logical reads.
   * 
   * @example
   * 19
   */
  logicalRead?: number;
  /**
   * @remarks
   * The maximum CPU time.
   * 
   * @example
   * 257.967
   */
  maxCpuTime?: number;
  /**
   * @remarks
   * The maximum response time.
   * 
   * @example
   * 260.44
   */
  maxElapsedTime?: number;
  /**
   * @remarks
   * The number of rows read from the memory.
   * 
   * @example
   * 527
   */
  memstoreReadRowCount?: number;
  /**
   * @remarks
   * The number of plan misses.
   * 
   * @example
   * 0
   */
  missPlans?: number;
  /**
   * @remarks
   * The network latency.
   * 
   * @example
   * 0.0
   */
  netWaitTime?: number;
  /**
   * @remarks
   * The IP address of the node.
   * 
   * @example
   * i-bp18qljorblo8es*****
   */
  nodeIp?: string;
  /**
   * @remarks
   * The queuing time.
   * 
   * @example
   * 15.275
   */
  queueTime?: number;
  /**
   * @remarks
   * The number of RPCs.
   * 
   * @example
   * 0
   */
  RPCCount?: number;
  /**
   * @remarks
   * The number of remote plans.
   * 
   * @example
   * 0
   */
  remotePlans?: number;
  /**
   * @remarks
   * The number of retries.
   * 
   * @example
   * 0
   */
  retryCount?: number;
  /**
   * @remarks
   * The number of rows returned.
   * 
   * @example
   * 1
   */
  returnRows?: number;
  /**
   * @remarks
   * The number of row cache hits.
   * 
   * @example
   * 0
   */
  rowCacheHit?: number;
  /**
   * @remarks
   * The scheduling duration.
   * 
   * @example
   * 0.0
   */
  scheduleTime?: number;
  /**
   * @remarks
   * The number of rows read from the disk.
   * 
   * @example
   * 43086
   */
  ssstoreReadRowCount?: number;
  /**
   * @remarks
   * The internal wait time.
   * 
   * @example
   * 10.966
   */
  totalWaitTime?: number;
  /**
   * @remarks
   * The username.
   * 
   * @example
   * tester
   */
  userName?: string;
  static names(): { [key: string]: string } {
    return {
      affectedRows: 'AffectedRows',
      appWaitTime: 'AppWaitTime',
      blockCacheHit: 'BlockCacheHit',
      blockIndexCacheHit: 'BlockIndexCacheHit',
      bloomFilterCacheHit: 'BloomFilterCacheHit',
      clientIp: 'ClientIp',
      concurrencyWaitTime: 'ConcurrencyWaitTime',
      cpuTime: 'CpuTime',
      dbName: 'DbName',
      decodeTime: 'DecodeTime',
      diskRead: 'DiskRead',
      elapsedTime: 'ElapsedTime',
      endTime: 'EndTime',
      endTimeUTCString: 'EndTimeUTCString',
      event: 'Event',
      execPerSecond: 'ExecPerSecond',
      executeTime: 'ExecuteTime',
      executions: 'Executions',
      failTimes: 'FailTimes',
      getPlanTime: 'GetPlanTime',
      IOWaitTime: 'IOWaitTime',
      logicalRead: 'LogicalRead',
      maxCpuTime: 'MaxCpuTime',
      maxElapsedTime: 'MaxElapsedTime',
      memstoreReadRowCount: 'MemstoreReadRowCount',
      missPlans: 'MissPlans',
      netWaitTime: 'NetWaitTime',
      nodeIp: 'NodeIp',
      queueTime: 'QueueTime',
      RPCCount: 'RPCCount',
      remotePlans: 'RemotePlans',
      retryCount: 'RetryCount',
      returnRows: 'ReturnRows',
      rowCacheHit: 'RowCacheHit',
      scheduleTime: 'ScheduleTime',
      ssstoreReadRowCount: 'SsstoreReadRowCount',
      totalWaitTime: 'TotalWaitTime',
      userName: 'UserName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      affectedRows: 'number',
      appWaitTime: 'number',
      blockCacheHit: 'number',
      blockIndexCacheHit: 'number',
      bloomFilterCacheHit: 'number',
      clientIp: 'string',
      concurrencyWaitTime: 'number',
      cpuTime: 'number',
      dbName: 'string',
      decodeTime: 'number',
      diskRead: 'number',
      elapsedTime: 'number',
      endTime: 'number',
      endTimeUTCString: 'string',
      event: 'string',
      execPerSecond: 'number',
      executeTime: 'number',
      executions: 'number',
      failTimes: 'number',
      getPlanTime: 'number',
      IOWaitTime: 'number',
      logicalRead: 'number',
      maxCpuTime: 'number',
      maxElapsedTime: 'number',
      memstoreReadRowCount: 'number',
      missPlans: 'number',
      netWaitTime: 'number',
      nodeIp: 'string',
      queueTime: 'number',
      RPCCount: 'number',
      remotePlans: 'number',
      retryCount: 'number',
      returnRows: 'number',
      rowCacheHit: 'number',
      scheduleTime: 'number',
      ssstoreReadRowCount: 'number',
      totalWaitTime: 'number',
      userName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSQLHistoryListResponseBodySQLHistoryList extends $tea.Model {
  /**
   * @remarks
   * The quantity.
   * 
   * @example
   * 1
   */
  count?: number;
  list?: DescribeSQLHistoryListResponseBodySQLHistoryListList[];
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      list: 'List',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      list: { 'type': 'array', 'itemType': DescribeSQLHistoryListResponseBodySQLHistoryListList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSQLPlansResponseBodySQLPlans extends $tea.Model {
  /**
   * @remarks
   * The average execution duration, in ms.
   * 
   * @example
   * 1
   */
  avgExecutionMS?: number;
  /**
   * @remarks
   * The average execution duration when the database uses this execution plan, in ms.
   * 
   * @example
   * 288
   */
  avgExecutionTimeMS?: number;
  /**
   * @remarks
   * The time when the plan was loaded for the first time, .
   * 
   * @example
   * 1641492303000
   */
  firstLoadTime?: number;
  /**
   * @remarks
   * The time when the plan was loaded for the first time, in UTC +0.
   * 
   * @example
   * 2022-01-06T18:05:03Z
   */
  firstLoadTimeUTCString?: string;
  /**
   * @remarks
   * The number of hits.
   * 
   * @example
   * 3
   */
  hitCount?: number;
  /**
   * @remarks
   * The major compaction version.
   * 
   * @example
   * 132
   */
  mergedVersion?: number;
  /**
   * @remarks
   * The IP address of the node.
   * 
   * @example
   * i-bp16niirq4zdmgvm****
   */
  nodeIp?: string;
  /**
   * @remarks
   * The outline data.
   */
  outlineData?: string;
  /**
   * @remarks
   * OutlineID.
   * 
   * @example
   * -1
   */
  outlineId?: number;
  /**
   * @remarks
   * The time when the plan was bound.
   * 
   * @example
   * 1641492303000
   */
  outlineTime?: number;
  /**
   * @remarks
   * The time when the plan was bound, in UTC +0.
   * 
   * @example
   * 2022-01-06T18:05:03Z
   */
  outlineTimeUTCString?: string;
  /**
   * @remarks
   * The complete execution plan of the SQL statement.
   * 
   * @example
   * PHY_TABLE_SCAN | bmsql_order_line | 40 ******
   */
  planFull?: string;
  /**
   * @remarks
   * The ID of the SQL execution plan in the database.
   * 
   * @example
   * 9114
   */
  planId?: number;
  /**
   * @remarks
   * The information about the plan.
   * 
   * @example
   * PHY_TABLE_SCAN
   */
  planInfo?: string;
  /**
   * @remarks
   * The unique identifier of the SQL execution plan in the diagnostic system.
   * 
   * @example
   * 859ef7ee****b23ac98cdeb2476f****
   */
  planUnionHash?: string;
  /**
   * @remarks
   * The query SQL statement.
   * 
   * @example
   * SELECT ol_i_id, ***, *** FROM aaa
   */
  querySQL?: string;
  static names(): { [key: string]: string } {
    return {
      avgExecutionMS: 'AvgExecutionMS',
      avgExecutionTimeMS: 'AvgExecutionTimeMS',
      firstLoadTime: 'FirstLoadTime',
      firstLoadTimeUTCString: 'FirstLoadTimeUTCString',
      hitCount: 'HitCount',
      mergedVersion: 'MergedVersion',
      nodeIp: 'NodeIp',
      outlineData: 'OutlineData',
      outlineId: 'OutlineId',
      outlineTime: 'OutlineTime',
      outlineTimeUTCString: 'OutlineTimeUTCString',
      planFull: 'PlanFull',
      planId: 'PlanId',
      planInfo: 'PlanInfo',
      planUnionHash: 'PlanUnionHash',
      querySQL: 'QuerySQL',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avgExecutionMS: 'number',
      avgExecutionTimeMS: 'number',
      firstLoadTime: 'number',
      firstLoadTimeUTCString: 'string',
      hitCount: 'number',
      mergedVersion: 'number',
      nodeIp: 'string',
      outlineData: 'string',
      outlineId: 'number',
      outlineTime: 'number',
      outlineTimeUTCString: 'string',
      planFull: 'string',
      planId: 'number',
      planInfo: 'string',
      planUnionHash: 'string',
      querySQL: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSQLSamplesResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * Average updated rows during the execution period.
   * 
   * @example
   * 10000.0
   */
  affectedRows?: number;
  /**
   * @remarks
   * Application event waiting time (in milliseconds).
   * 
   * @example
   * 0.0
   */
  applicationWaitTime?: number;
  /**
   * @remarks
   * BlockCache hit count
   * 
   * @example
   * 99279.0
   */
  blockCacheHit?: number;
  /**
   * @remarks
   * BlockIndexCache hit count
   * 
   * @example
   * 142514.0
   */
  blockIndexCacheHit?: number;
  /**
   * @remarks
   * BloomFilterCache hit count.
   * 
   * @example
   * 0.0
   */
  bloomFilterCacheHit?: number;
  /**
   * @remarks
   * Client IP.
   * 
   * @example
   * i-bp1db****38uemejio
   */
  clientIp?: string;
  /**
   * @remarks
   * Client port.
   * 
   * @example
   * 4****
   */
  clientPort?: string;
  /**
   * @remarks
   * Concurrency event waiting time (in milliseconds).
   * 
   * @example
   * 0.0
   */
  concurrencyWaitTime?: number;
  /**
   * @remarks
   * Consistency level.
   * 
   * @example
   * 3
   */
  consistencyLevel?: string;
  /**
   * @remarks
   * CPU time (in milliseconds).
   * 
   * @example
   * 3377.57
   */
  cpuTime?: number;
  /**
   * @remarks
   * Database name.
   * 
   * @example
   * test_db
   */
  dbName?: string;
  /**
   * @remarks
   * Syntax parsing time (in milliseconds).
   * 
   * @example
   * 0.0
   */
  decodeTime?: number;
  /**
   * @remarks
   * Disk read count.
   * 
   * @example
   * 96972.0
   */
  diskReads?: number;
  /**
   * @remarks
   * Response time (in milliseconds).
   * 
   * @example
   * 2182.66
   */
  elapsedTime?: number;
  /**
   * @remarks
   * Plan execution time (in milliseconds).
   * 
   * @example
   * 8262.01
   */
  executeTime?: number;
  /**
   * @remarks
   * Whether to initiate RPC.
   * 
   * @example
   * 0.0
   */
  executorRpc?: boolean;
  /**
   * @remarks
   * Degree of parallelism.
   * 
   * @example
   * 0
   */
  expectedWorkerCount?: number;
  fullSqlText?: string;
  /**
   * @remarks
   * Plan generation time (in milliseconds).
   * 
   * @example
   * 0.19
   */
  getPlanTime?: number;
  /**
   * @remarks
   * Whether to hit the execution plan.
   * 
   * @example
   * true
   */
  hitPlan?: boolean;
  /**
   * @remarks
   * Whether an internal SQL.
   * 
   * @example
   * false
   */
  inner?: boolean;
  /**
   * @remarks
   * Memstore read row count.
   * 
   * @example
   * 0
   */
  memstoreReadRows?: number;
  /**
   * @remarks
   * Network transmission time (in milliseconds).
   * 
   * @example
   * 0.0
   */
  netTime?: number;
  /**
   * @remarks
   * Network enqueue time (in milliseconds).
   * 
   * @example
   * 0.0
   */
  netWaitTime?: number;
  /**
   * @remarks
   * Database ID.
   * 
   * @example
   * 11006111****4828
   */
  obDbId?: number;
  /**
   * @remarks
   * Server  ID.
   * 
   * @example
   * 2
   */
  obServerId?: number;
  /**
   * @remarks
   * User ID.
   * 
   * @example
   * 100010
   */
  obUserId?: number;
  paramsValue?: string;
  /**
   * @remarks
   * Average number of partition accessed during the execution period.
   * 
   * @example
   * 1.0
   */
  partitionCount?: number;
  /**
   * @remarks
   * The execution plan ID.
   * 
   * @example
   * 590****
   */
  planId?: number;
  /**
   * @remarks
   * Plan type.
   * 
   * @example
   * LOCAL
   */
  planType?: string;
  /**
   * @remarks
   * Queueing time (in milliseconds).
   * 
   * @example
   * 0.02
   */
  queueTime?: number;
  /**
   * @remarks
   * Request ID.
   * 
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @remarks
   * SQL request time.
   * 
   * @example
   * 2023-04-12T04:46:38Z
   */
  requestTime?: string;
  /**
   * @remarks
   * Result code.
   * 
   * @example
   * 0
   */
  retCode?: number;
  /**
   * @remarks
   * Retry count.
   * 
   * @example
   * 0
   */
  retryCount?: number;
  /**
   * @remarks
   * Average returned rows during the execution period.
   * 
   * @example
   * 0.0
   */
  returnRows?: number;
  /**
   * @remarks
   * RowCache hit count.
   * 
   * @example
   * 498.0
   */
  rowCacheHit?: number;
  /**
   * @remarks
   * Number of RPC sent.
   * 
   * @example
   * 8.0
   */
  rpcCount?: number;
  /**
   * @remarks
   * Schedule event waiting time (in milliseconds).
   * 
   * @example
   * 0.0
   */
  scheduleTime?: number;
  /**
   * @remarks
   * The server where the SQL is executed.
   * 
   * @example
   * i-bp1db1****8uemejio
   */
  server?: string;
  sqlText?: string;
  /**
   * @remarks
   * SQL type.
   * 
   * @example
   * select
   */
  sqlType?: string;
  /**
   * @remarks
   * Ssstore read row count.
   * 
   * @example
   * 986190
   */
  ssstoreReadRows?: number;
  /**
   * @remarks
   * Parameterized SQL text.
   * 
   * @example
   * select a from b
   */
  statement?: string;
  /**
   * @remarks
   * Whether to perform full table scan.
   * 
   * @example
   * false
   */
  tableScan?: boolean;
  /**
   * @remarks
   * Trace ID.
   * 
   * @example
   * YB42C****-0005E303D1****-0-0
   */
  traceId?: string;
  /**
   * @remarks
   * Transaction hash.
   * 
   * @example
   * 1219****927****73791
   */
  transHash?: string;
  /**
   * @remarks
   * Actual number of SQL execution threads.
   * 
   * @example
   * 0
   */
  usedWorkerCount?: number;
  /**
   * @remarks
   * UserIO event waiting time (in milliseconds).
   * 
   * @example
   * 0.0
   */
  userIoWaitTime?: number;
  /**
   * @remarks
   * Username.
   * 
   * @example
   * test_user
   */
  userName?: string;
  /**
   * @remarks
   * Wait count.
   * 
   * @example
   * 0.0
   */
  waitCount?: number;
  /**
   * @remarks
   * Longest wait event during the execution period.
   * 
   * @example
   * none
   */
  waitEvent?: string;
  /**
   * @remarks
   * Wait time (in milliseconds).
   * 
   * @example
   * 0.0
   */
  waitTime?: number;
  static names(): { [key: string]: string } {
    return {
      affectedRows: 'AffectedRows',
      applicationWaitTime: 'ApplicationWaitTime',
      blockCacheHit: 'BlockCacheHit',
      blockIndexCacheHit: 'BlockIndexCacheHit',
      bloomFilterCacheHit: 'BloomFilterCacheHit',
      clientIp: 'ClientIp',
      clientPort: 'ClientPort',
      concurrencyWaitTime: 'ConcurrencyWaitTime',
      consistencyLevel: 'ConsistencyLevel',
      cpuTime: 'CpuTime',
      dbName: 'DbName',
      decodeTime: 'DecodeTime',
      diskReads: 'DiskReads',
      elapsedTime: 'ElapsedTime',
      executeTime: 'ExecuteTime',
      executorRpc: 'ExecutorRpc',
      expectedWorkerCount: 'ExpectedWorkerCount',
      fullSqlText: 'FullSqlText',
      getPlanTime: 'GetPlanTime',
      hitPlan: 'HitPlan',
      inner: 'Inner',
      memstoreReadRows: 'MemstoreReadRows',
      netTime: 'NetTime',
      netWaitTime: 'NetWaitTime',
      obDbId: 'ObDbId',
      obServerId: 'ObServerId',
      obUserId: 'ObUserId',
      paramsValue: 'ParamsValue',
      partitionCount: 'PartitionCount',
      planId: 'PlanId',
      planType: 'PlanType',
      queueTime: 'QueueTime',
      requestId: 'RequestId',
      requestTime: 'RequestTime',
      retCode: 'RetCode',
      retryCount: 'RetryCount',
      returnRows: 'ReturnRows',
      rowCacheHit: 'RowCacheHit',
      rpcCount: 'RpcCount',
      scheduleTime: 'ScheduleTime',
      server: 'Server',
      sqlText: 'SqlText',
      sqlType: 'SqlType',
      ssstoreReadRows: 'SsstoreReadRows',
      statement: 'Statement',
      tableScan: 'TableScan',
      traceId: 'TraceId',
      transHash: 'TransHash',
      usedWorkerCount: 'UsedWorkerCount',
      userIoWaitTime: 'UserIoWaitTime',
      userName: 'UserName',
      waitCount: 'WaitCount',
      waitEvent: 'WaitEvent',
      waitTime: 'WaitTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      affectedRows: 'number',
      applicationWaitTime: 'number',
      blockCacheHit: 'number',
      blockIndexCacheHit: 'number',
      bloomFilterCacheHit: 'number',
      clientIp: 'string',
      clientPort: 'string',
      concurrencyWaitTime: 'number',
      consistencyLevel: 'string',
      cpuTime: 'number',
      dbName: 'string',
      decodeTime: 'number',
      diskReads: 'number',
      elapsedTime: 'number',
      executeTime: 'number',
      executorRpc: 'boolean',
      expectedWorkerCount: 'number',
      fullSqlText: 'string',
      getPlanTime: 'number',
      hitPlan: 'boolean',
      inner: 'boolean',
      memstoreReadRows: 'number',
      netTime: 'number',
      netWaitTime: 'number',
      obDbId: 'number',
      obServerId: 'number',
      obUserId: 'number',
      paramsValue: 'string',
      partitionCount: 'number',
      planId: 'number',
      planType: 'string',
      queueTime: 'number',
      requestId: 'string',
      requestTime: 'string',
      retCode: 'number',
      retryCount: 'number',
      returnRows: 'number',
      rowCacheHit: 'number',
      rpcCount: 'number',
      scheduleTime: 'number',
      server: 'string',
      sqlText: 'string',
      sqlType: 'string',
      ssstoreReadRows: 'number',
      statement: 'string',
      tableScan: 'boolean',
      traceId: 'string',
      transHash: 'string',
      usedWorkerCount: 'number',
      userIoWaitTime: 'number',
      userName: 'string',
      waitCount: 'number',
      waitEvent: 'string',
      waitTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSQLTuningAdvicesResponseBodyDataColumns extends $tea.Model {
  /**
   * @example
   * xxxx
   */
  columnName?: string;
  /**
   * @example
   * 100
   */
  maxValue?: string;
  /**
   * @example
   * 1
   */
  minValue?: string;
  /**
   * @remarks
   * NDV
   * 
   * @example
   * 100
   */
  ndv?: number;
  static names(): { [key: string]: string } {
    return {
      columnName: 'ColumnName',
      maxValue: 'MaxValue',
      minValue: 'MinValue',
      ndv: 'Ndv',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnName: 'string',
      maxValue: 'string',
      minValue: 'string',
      ndv: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSQLTuningAdvicesResponseBodyDataPlan extends $tea.Model {
  /**
   * @example
   * 0
   */
  avgApplicationWaitTime?: number;
  /**
   * @example
   * 0
   */
  avgBufferGets?: number;
  /**
   * @example
   * 0
   */
  avgConcurrencyWaitTime?: number;
  /**
   * @example
   * 100.36
   */
  avgCpuTime?: number;
  /**
   * @example
   * 0
   */
  avgDiskReads?: number;
  /**
   * @example
   * 0
   */
  avgDiskWrites?: number;
  /**
   * @example
   * 713.62
   */
  avgElapsedTime?: number;
  /**
   * @example
   * 1
   */
  avgRowProcessed?: number;
  /**
   * @example
   * 0
   */
  avgUserIoWaitTime?: number;
  /**
   * @example
   * 1672358400000000
   */
  collectTimeUs?: number;
  /**
   * @example
   * 0
   */
  delayedLargeQueryPercentage?: number;
  /**
   * @example
   * 1.45
   */
  execPs?: number;
  /**
   * @example
   * 2062
   */
  executions?: number;
  /**
   * @example
   * 2022-12-30T02:25:30.576Z
   */
  firstLoadTime?: string;
  /**
   * @example
   * 1672367130576163
   */
  firstLoadTimeUs?: number;
  /**
   * @example
   * false
   */
  hitDiagnosis?: boolean;
  /**
   * @example
   * 66.8
   */
  hitPercentage?: number;
  /**
   * @example
   * 0
   */
  largeQueryPercentage?: number;
  /**
   * @example
   * 3
   */
  mergedVersion?: number;
  /**
   * @example
   * 1108307720799259
   */
  obDbId?: number;
  /**
   * @remarks
   * server  ID。
   * 
   * @example
   * 1
   */
  obServerId?: number;
  /**
   * @example
   * xxxxx
   */
  outlineData?: string;
  /**
   * @remarks
   * Outline ID。
   * 
   * @example
   * 1
   */
  outlineId?: number;
  /**
   * @example
   * -86290582****886880
   */
  planHash?: string;
  /**
   * @example
   * 818
   */
  planId?: number;
  /**
   * @example
   * 49216
   */
  planSize?: number;
  /**
   * @example
   * LOCAL
   */
  planType?: string;
  /**
   * @example
   * 1672367130529680
   */
  schemaVersion?: number;
  /**
   * @example
   * i-bp1*****sw64dhb*****
   */
  serverSn?: string;
  /**
   * @example
   * false
   */
  tableScan?: boolean;
  /**
   * @example
   * 0
   */
  timeoutPercentage?: number;
  /**
   * @example
   * AAAAAAAAAAEAAAAAAAADMgAF8QJQwIUj
   */
  uid?: string;
  static names(): { [key: string]: string } {
    return {
      avgApplicationWaitTime: 'AvgApplicationWaitTime',
      avgBufferGets: 'AvgBufferGets',
      avgConcurrencyWaitTime: 'AvgConcurrencyWaitTime',
      avgCpuTime: 'AvgCpuTime',
      avgDiskReads: 'AvgDiskReads',
      avgDiskWrites: 'AvgDiskWrites',
      avgElapsedTime: 'AvgElapsedTime',
      avgRowProcessed: 'AvgRowProcessed',
      avgUserIoWaitTime: 'AvgUserIoWaitTime',
      collectTimeUs: 'CollectTimeUs',
      delayedLargeQueryPercentage: 'DelayedLargeQueryPercentage',
      execPs: 'ExecPs',
      executions: 'Executions',
      firstLoadTime: 'FirstLoadTime',
      firstLoadTimeUs: 'FirstLoadTimeUs',
      hitDiagnosis: 'HitDiagnosis',
      hitPercentage: 'HitPercentage',
      largeQueryPercentage: 'LargeQueryPercentage',
      mergedVersion: 'MergedVersion',
      obDbId: 'ObDbId',
      obServerId: 'ObServerId',
      outlineData: 'OutlineData',
      outlineId: 'OutlineId',
      planHash: 'PlanHash',
      planId: 'PlanId',
      planSize: 'PlanSize',
      planType: 'PlanType',
      schemaVersion: 'SchemaVersion',
      serverSn: 'ServerSn',
      tableScan: 'TableScan',
      timeoutPercentage: 'TimeoutPercentage',
      uid: 'Uid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avgApplicationWaitTime: 'number',
      avgBufferGets: 'number',
      avgConcurrencyWaitTime: 'number',
      avgCpuTime: 'number',
      avgDiskReads: 'number',
      avgDiskWrites: 'number',
      avgElapsedTime: 'number',
      avgRowProcessed: 'number',
      avgUserIoWaitTime: 'number',
      collectTimeUs: 'number',
      delayedLargeQueryPercentage: 'number',
      execPs: 'number',
      executions: 'number',
      firstLoadTime: 'string',
      firstLoadTimeUs: 'number',
      hitDiagnosis: 'boolean',
      hitPercentage: 'number',
      largeQueryPercentage: 'number',
      mergedVersion: 'number',
      obDbId: 'number',
      obServerId: 'number',
      outlineData: 'string',
      outlineId: 'number',
      planHash: 'string',
      planId: 'number',
      planSize: 'number',
      planType: 'string',
      schemaVersion: 'number',
      serverSn: 'string',
      tableScan: 'boolean',
      timeoutPercentage: 'number',
      uid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSQLTuningAdvicesResponseBodyData extends $tea.Model {
  /**
   * @example
   * c1;c2;c3
   */
  columnNames?: string;
  columns?: DescribeSQLTuningAdvicesResponseBodyDataColumns[];
  /**
   * @example
   * test_db
   */
  dbName?: string;
  /**
   * @example
   * Local/Global
   */
  localityType?: string;
  plan?: DescribeSQLTuningAdvicesResponseBodyDataPlan;
  /**
   * @example
   * test_table
   */
  table?: string;
  /**
   * @example
   * PLAN_BINDING/INDEX_CREATION
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      columnNames: 'ColumnNames',
      columns: 'Columns',
      dbName: 'DbName',
      localityType: 'LocalityType',
      plan: 'Plan',
      table: 'Table',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnNames: 'string',
      columns: { 'type': 'array', 'itemType': DescribeSQLTuningAdvicesResponseBodyDataColumns },
      dbName: 'string',
      localityType: 'string',
      plan: DescribeSQLTuningAdvicesResponseBodyDataPlan,
      table: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSampleSqlRawTextsResponseBodyData extends $tea.Model {
  sqlText?: string[];
  static names(): { [key: string]: string } {
    return {
      sqlText: 'SqlText',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sqlText: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSecurityIpGroupsResponseBodySecurityIpGroups extends $tea.Model {
  /**
   * @example
   * online_paycore
   */
  securityIpGroupName?: string;
  /**
   * @example
   * 121.41.106.33,100.104.7.0/26
   */
  securityIps?: string;
  static names(): { [key: string]: string } {
    return {
      securityIpGroupName: 'SecurityIpGroupName',
      securityIps: 'SecurityIps',
    };
  }

  static types(): { [key: string]: any } {
    return {
      securityIpGroupName: 'string',
      securityIps: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSessionListResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The address of the client, with the format ip:port.
   * 
   * @example
   * 192.***.**.100:80
   */
  host?: string;
  /**
   * @remarks
   * The session ID of the proxy service.
   * 
   * @example
   * d2c90ad0-bc54-410f-bb89-2dcf14aa3c6d
   */
  sessionId?: string;
  static names(): { [key: string]: string } {
    return {
      host: 'Host',
      sessionId: 'SessionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      host: 'string',
      sessionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSlowSQLHistoryListResponseBodySlowSQLHistoryListList extends $tea.Model {
  /**
   * @remarks
   * The number of rows affected.
   * 
   * @example
   * 0
   */
  affectedRows?: number;
  /**
   * @remarks
   * The wait time of the client.
   * 
   * @example
   * 0.0
   */
  appWaitTime?: number;
  /**
   * @remarks
   * The number of block cache hits.
   * 
   * @example
   * 14
   */
  blockCacheHit?: number;
  /**
   * @remarks
   * The number of block index cache hits.
   * 
   * @example
   * 4
   */
  blockIndexCacheHit?: number;
  /**
   * @remarks
   * The number of Bloom filter cache hits.
   * 
   * @example
   * 0
   */
  bloomFilterCacheHit?: number;
  /**
   * @remarks
   * The IP address of the client.
   * 
   * @example
   * 1*2.***.1*3.***
   */
  clientIp?: string;
  /**
   * @remarks
   * The wait time in concurrent execution.
   * 
   * @example
   * 0.0
   */
  concurrencyWaitTime?: number;
  /**
   * @remarks
   * The average CPU time.
   * 
   * @example
   * 50.13
   */
  cpuTime?: number;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * testdb
   */
  dbName?: string;
  /**
   * @remarks
   * The time to wait for decoding.
   * 
   * @example
   * 0.0
   */
  decodeTime?: number;
  /**
   * @remarks
   * The number of physical reads.
   * 
   * @example
   * 0
   */
  diskRead?: number;
  /**
   * @remarks
   * The average response time.
   * 
   * @example
   * 76.382
   */
  elapsedTime?: number;
  /**
   * @remarks
   * The end time.
   * 
   * @example
   * 2021-12-28T02:08:18Z
   */
  endTimeUTCString?: string;
  /**
   * @remarks
   * The wait event.
   * 
   * @example
   * mysql response wait client
   */
  event?: string;
  /**
   * @remarks
   * The number of executions per second.
   * 
   * @example
   * 163.0
   */
  execPerSecond?: number;
  /**
   * @remarks
   * The internal execution time.
   * 
   * @example
   * 61.044
   */
  executeTime?: number;
  /**
   * @remarks
   * The number of executions.
   * 
   * @example
   * 89403
   */
  executions?: number;
  /**
   * @remarks
   * The number of failures.
   * 
   * @example
   * 0
   */
  failTimes?: number;
  /**
   * @remarks
   * Hard parsing time.
   * 
   * @example
   * 0.052
   */
  getPlanTime?: number;
  /**
   * @remarks
   * The I/O wait time.
   * 
   * @example
   * 0.0
   */
  IOWaitTime?: number;
  /**
   * @remarks
   * The number of logical reads.
   * 
   * @example
   * 19
   */
  logicalRead?: number;
  /**
   * @remarks
   * The maximum CPU time.
   * 
   * @example
   * 257.967
   */
  maxCpuTime?: number;
  /**
   * @remarks
   * The maximum response time.
   * 
   * @example
   * 260.044
   */
  maxElapsedTime?: number;
  /**
   * @remarks
   * The number of rows read from the memory.
   * 
   * @example
   * 527
   */
  memstoreReadRowCount?: number;
  /**
   * @remarks
   * The number of plan misses.
   * 
   * @example
   * 0
   */
  missPlans?: number;
  /**
   * @remarks
   * The wait time for network.
   * 
   * @example
   * 0.0
   */
  netWaitTime?: number;
  /**
   * @remarks
   * The IP address of the node.
   * 
   * @example
   * i-bp18qljorblo8es*****
   */
  nodeIp?: string;
  /**
   * @remarks
   * The queuing time.
   * 
   * @example
   * 15.275
   */
  queueTime?: number;
  /**
   * @remarks
   * The number of RPCs.
   * 
   * @example
   * 0
   */
  RPCCount?: number;
  /**
   * @remarks
   * The number of remote plans.
   * 
   * @example
   * 0
   */
  remotePlans?: number;
  /**
   * @remarks
   * The number of retries.
   * 
   * @example
   * 0
   */
  retryCount?: number;
  /**
   * @remarks
   * The number of rows returned.
   * 
   * @example
   * 1
   */
  returnRows?: number;
  /**
   * @remarks
   * The number of row cache hits.
   * 
   * @example
   * 0
   */
  rowCacheHit?: number;
  /**
   * @remarks
   * The scheduling duration.
   * 
   * @example
   * 0.0
   */
  scheduleTime?: number;
  /**
   * @remarks
   * SQLID.
   * 
   * @example
   * 8D6E84****0B8FB1823D199E2CA1****
   */
  sqlId?: string;
  /**
   * @remarks
   * The SQL type.
   * 
   * @example
   * 1
   */
  sqlType?: string;
  /**
   * @remarks
   * The number of rows read from the disk.
   * 
   * @example
   * 43086
   */
  ssstoreReadRowCount?: number;
  /**
   * @remarks
   * The name of the tenant.
   * 
   * @example
   * pay_online
   */
  tenantName?: string;
  /**
   * @remarks
   * The internal wait time.
   * 
   * @example
   * 10.966
   */
  totalWaitTime?: number;
  /**
   * @remarks
   * The username.
   * 
   * @example
   * tester
   */
  userName?: string;
  static names(): { [key: string]: string } {
    return {
      affectedRows: 'AffectedRows',
      appWaitTime: 'AppWaitTime',
      blockCacheHit: 'BlockCacheHit',
      blockIndexCacheHit: 'BlockIndexCacheHit',
      bloomFilterCacheHit: 'BloomFilterCacheHit',
      clientIp: 'ClientIp',
      concurrencyWaitTime: 'ConcurrencyWaitTime',
      cpuTime: 'CpuTime',
      dbName: 'DbName',
      decodeTime: 'DecodeTime',
      diskRead: 'DiskRead',
      elapsedTime: 'ElapsedTime',
      endTimeUTCString: 'EndTimeUTCString',
      event: 'Event',
      execPerSecond: 'ExecPerSecond',
      executeTime: 'ExecuteTime',
      executions: 'Executions',
      failTimes: 'FailTimes',
      getPlanTime: 'GetPlanTime',
      IOWaitTime: 'IOWaitTime',
      logicalRead: 'LogicalRead',
      maxCpuTime: 'MaxCpuTime',
      maxElapsedTime: 'MaxElapsedTime',
      memstoreReadRowCount: 'MemstoreReadRowCount',
      missPlans: 'MissPlans',
      netWaitTime: 'NetWaitTime',
      nodeIp: 'NodeIp',
      queueTime: 'QueueTime',
      RPCCount: 'RPCCount',
      remotePlans: 'RemotePlans',
      retryCount: 'RetryCount',
      returnRows: 'ReturnRows',
      rowCacheHit: 'RowCacheHit',
      scheduleTime: 'ScheduleTime',
      sqlId: 'SqlId',
      sqlType: 'SqlType',
      ssstoreReadRowCount: 'SsstoreReadRowCount',
      tenantName: 'TenantName',
      totalWaitTime: 'TotalWaitTime',
      userName: 'UserName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      affectedRows: 'number',
      appWaitTime: 'number',
      blockCacheHit: 'number',
      blockIndexCacheHit: 'number',
      bloomFilterCacheHit: 'number',
      clientIp: 'string',
      concurrencyWaitTime: 'number',
      cpuTime: 'number',
      dbName: 'string',
      decodeTime: 'number',
      diskRead: 'number',
      elapsedTime: 'number',
      endTimeUTCString: 'string',
      event: 'string',
      execPerSecond: 'number',
      executeTime: 'number',
      executions: 'number',
      failTimes: 'number',
      getPlanTime: 'number',
      IOWaitTime: 'number',
      logicalRead: 'number',
      maxCpuTime: 'number',
      maxElapsedTime: 'number',
      memstoreReadRowCount: 'number',
      missPlans: 'number',
      netWaitTime: 'number',
      nodeIp: 'string',
      queueTime: 'number',
      RPCCount: 'number',
      remotePlans: 'number',
      retryCount: 'number',
      returnRows: 'number',
      rowCacheHit: 'number',
      scheduleTime: 'number',
      sqlId: 'string',
      sqlType: 'string',
      ssstoreReadRowCount: 'number',
      tenantName: 'string',
      totalWaitTime: 'number',
      userName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSlowSQLHistoryListResponseBodySlowSQLHistoryList extends $tea.Model {
  /**
   * @remarks
   * The quantity.
   * 
   * @example
   * 1
   */
  count?: number;
  /**
   * @remarks
   * The return result of the request.
   */
  list?: DescribeSlowSQLHistoryListResponseBodySlowSQLHistoryListList[];
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      list: 'List',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      list: { 'type': 'array', 'itemType': DescribeSlowSQLHistoryListResponseBodySlowSQLHistoryListList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSlowSQLListResponseBodySlowSQLList extends $tea.Model {
  /**
   * @remarks
   * The number of rows affected.
   * 
   * @example
   * 0
   */
  affectedRows?: number;
  /**
   * @remarks
   * The wait time of the client.
   * 
   * @example
   * 0.0
   */
  appWaitTime?: number;
  /**
   * @remarks
   * The number of block cache hits.
   * 
   * @example
   * 14
   */
  blockCacheHit?: number;
  /**
   * @remarks
   * The number of block index cache hits.
   * 
   * @example
   * 4
   */
  blockIndexCacheHit?: number;
  /**
   * @remarks
   * The number of Bloom filter cache hits.
   * 
   * @example
   * 0
   */
  bloomFilterCacheHit?: number;
  /**
   * @remarks
   * The IP address of the client.
   * 
   * @example
   * 1*2.***.1*3.***
   */
  clientIp?: string;
  /**
   * @remarks
   * The wait time in concurrent execution.
   * 
   * @example
   * 0.0
   */
  concurrencyWaitTime?: number;
  /**
   * @remarks
   * The average CPU time.
   * 
   * @example
   * 50.13
   */
  cpuTime?: number;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * testdb
   */
  dbName?: string;
  /**
   * @remarks
   * The time to wait for decoding.
   * 
   * @example
   * 0.0
   */
  decodeTime?: number;
  /**
   * @remarks
   * The number of physical reads.
   * 
   * @example
   * 0
   */
  diskRead?: number;
  /**
   * @remarks
   * The average response time.
   * 
   * @example
   * 76.382
   */
  elapsedTime?: number;
  /**
   * @remarks
   * The wait event.
   * 
   * @example
   * mysql response wait client
   */
  event?: string;
  /**
   * @remarks
   * The number of executions per second.
   * 
   * @example
   * 163.0
   */
  execPerSecond?: number;
  /**
   * @remarks
   * The internal execution time.
   * 
   * @example
   * 61.044
   */
  executeTime?: number;
  /**
   * @remarks
   * The number of executions.
   * 
   * @example
   * 89403
   */
  executions?: number;
  /**
   * @remarks
   * The number of failures.
   * 
   * @example
   * 0
   */
  failTimes?: number;
  /**
   * @remarks
   * The time spent in hard parsing.
   * 
   * @example
   * 0.052
   */
  getPlanTime?: number;
  /**
   * @remarks
   * The I/O wait time.
   * 
   * @example
   * 0.0
   */
  IOWaitTime?: number;
  /**
   * @remarks
   * The sequence number of the returned SQL statement.
   * 
   * @example
   * 1
   */
  key?: number;
  /**
   * @remarks
   * The number of logical reads.
   * 
   * @example
   * 19
   */
  logicalRead?: number;
  /**
   * @remarks
   * The maximum CPU time.
   * 
   * @example
   * 257.967
   */
  maxCpuTime?: number;
  /**
   * @remarks
   * The maximum response time.
   * 
   * @example
   * 260.044
   */
  maxElapsedTime?: number;
  /**
   * @remarks
   * The number of rows read from the memory.
   * 
   * @example
   * 527
   */
  memstoreReadRowCount?: number;
  /**
   * @remarks
   * The number of plan misses.
   * 
   * @example
   * 0
   */
  missPlans?: number;
  /**
   * @remarks
   * The network latency.
   * 
   * @example
   * 0.0
   */
  netWaitTime?: number;
  /**
   * @remarks
   * The IP address of the node.
   * 
   * @example
   * i-bp18qljorblo8es*****
   */
  nodeIp?: string;
  /**
   * @remarks
   * The queuing time.
   * 
   * @example
   * 15.275
   */
  queueTime?: number;
  /**
   * @remarks
   * The number of RPCs.
   * 
   * @example
   * 0
   */
  RPCCount?: number;
  /**
   * @remarks
   * The number of remote plans.
   * 
   * @example
   * 0
   */
  remotePlans?: number;
  /**
   * @remarks
   * The number of retries.
   * 
   * @example
   * 0
   */
  retryCount?: number;
  /**
   * @remarks
   * The number of rows returned.
   * 
   * @example
   * 1
   */
  returnRows?: number;
  /**
   * @remarks
   * The number of row cache hits.
   * 
   * @example
   * 0
   */
  rowCacheHit?: number;
  /**
   * @remarks
   * SQLID.
   * 
   * @example
   * 8D6E84****0B8FB1823D199E2CA1****
   */
  SQLId?: string;
  /**
   * @remarks
   * The SQL text.
   * 
   * @example
   * SELECT  ****   FROM ****   WHERE **** = ? AND **** = ?   ORDER BY **** ASC
   */
  SQLText?: string;
  /**
   * @remarks
   * The SQL type.
   * 
   * @example
   * 1
   */
  SQLType?: number;
  /**
   * @remarks
   * The scheduling duration.
   * 
   * @example
   * 0.0
   */
  scheduleTime?: number;
  /**
   * @remarks
   * The number of rows read from the disk.
   * 
   * @example
   * 43086
   */
  ssstoreReadRowCount?: number;
  /**
   * @remarks
   * The internal wait time.
   * 
   * @example
   * 10.966
   */
  totalWaitTime?: number;
  /**
   * @remarks
   * The username.
   * 
   * @example
   * tester
   */
  userName?: string;
  static names(): { [key: string]: string } {
    return {
      affectedRows: 'AffectedRows',
      appWaitTime: 'AppWaitTime',
      blockCacheHit: 'BlockCacheHit',
      blockIndexCacheHit: 'BlockIndexCacheHit',
      bloomFilterCacheHit: 'BloomFilterCacheHit',
      clientIp: 'ClientIp',
      concurrencyWaitTime: 'ConcurrencyWaitTime',
      cpuTime: 'CpuTime',
      dbName: 'DbName',
      decodeTime: 'DecodeTime',
      diskRead: 'DiskRead',
      elapsedTime: 'ElapsedTime',
      event: 'Event',
      execPerSecond: 'ExecPerSecond',
      executeTime: 'ExecuteTime',
      executions: 'Executions',
      failTimes: 'FailTimes',
      getPlanTime: 'GetPlanTime',
      IOWaitTime: 'IOWaitTime',
      key: 'Key',
      logicalRead: 'LogicalRead',
      maxCpuTime: 'MaxCpuTime',
      maxElapsedTime: 'MaxElapsedTime',
      memstoreReadRowCount: 'MemstoreReadRowCount',
      missPlans: 'MissPlans',
      netWaitTime: 'NetWaitTime',
      nodeIp: 'NodeIp',
      queueTime: 'QueueTime',
      RPCCount: 'RPCCount',
      remotePlans: 'RemotePlans',
      retryCount: 'RetryCount',
      returnRows: 'ReturnRows',
      rowCacheHit: 'RowCacheHit',
      SQLId: 'SQLId',
      SQLText: 'SQLText',
      SQLType: 'SQLType',
      scheduleTime: 'ScheduleTime',
      ssstoreReadRowCount: 'SsstoreReadRowCount',
      totalWaitTime: 'TotalWaitTime',
      userName: 'UserName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      affectedRows: 'number',
      appWaitTime: 'number',
      blockCacheHit: 'number',
      blockIndexCacheHit: 'number',
      bloomFilterCacheHit: 'number',
      clientIp: 'string',
      concurrencyWaitTime: 'number',
      cpuTime: 'number',
      dbName: 'string',
      decodeTime: 'number',
      diskRead: 'number',
      elapsedTime: 'number',
      event: 'string',
      execPerSecond: 'number',
      executeTime: 'number',
      executions: 'number',
      failTimes: 'number',
      getPlanTime: 'number',
      IOWaitTime: 'number',
      key: 'number',
      logicalRead: 'number',
      maxCpuTime: 'number',
      maxElapsedTime: 'number',
      memstoreReadRowCount: 'number',
      missPlans: 'number',
      netWaitTime: 'number',
      nodeIp: 'string',
      queueTime: 'number',
      RPCCount: 'number',
      remotePlans: 'number',
      retryCount: 'number',
      returnRows: 'number',
      rowCacheHit: 'number',
      SQLId: 'string',
      SQLText: 'string',
      SQLType: 'number',
      scheduleTime: 'number',
      ssstoreReadRowCount: 'number',
      totalWaitTime: 'number',
      userName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantResponseBodyTenantReadOnlyResourceCapacityUnit extends $tea.Model {
  maxCapacityUnit?: number;
  minCapacityUnit?: number;
  usedCapacit?: number;
  static names(): { [key: string]: string } {
    return {
      maxCapacityUnit: 'MaxCapacityUnit',
      minCapacityUnit: 'MinCapacityUnit',
      usedCapacit: 'UsedCapacit',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxCapacityUnit: 'number',
      minCapacityUnit: 'number',
      usedCapacit: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantResponseBodyTenantReadOnlyResourceCpu extends $tea.Model {
  /**
   * @example
   * 10
   */
  totalCpu?: number;
  /**
   * @example
   * 8
   */
  unitCpu?: number;
  usedCpu?: number;
  static names(): { [key: string]: string } {
    return {
      totalCpu: 'TotalCpu',
      unitCpu: 'UnitCpu',
      usedCpu: 'UsedCpu',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCpu: 'number',
      unitCpu: 'number',
      usedCpu: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantResponseBodyTenantReadOnlyResourceDiskSize extends $tea.Model {
  /**
   * @example
   * 86
   */
  usedDiskSize?: number;
  static names(): { [key: string]: string } {
    return {
      usedDiskSize: 'UsedDiskSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      usedDiskSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantResponseBodyTenantReadOnlyResourceLogDiskSize extends $tea.Model {
  totalLogDisk?: number;
  unitLogDisk?: number;
  static names(): { [key: string]: string } {
    return {
      totalLogDisk: 'TotalLogDisk',
      unitLogDisk: 'UnitLogDisk',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalLogDisk: 'number',
      unitLogDisk: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantResponseBodyTenantReadOnlyResourceMemory extends $tea.Model {
  /**
   * @example
   * 64
   */
  totalMemory?: number;
  /**
   * @example
   * 32
   */
  unitMemory?: number;
  /**
   * @example
   * 30
   */
  usedMemory?: number;
  static names(): { [key: string]: string } {
    return {
      totalMemory: 'TotalMemory',
      unitMemory: 'UnitMemory',
      usedMemory: 'UsedMemory',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalMemory: 'number',
      unitMemory: 'number',
      usedMemory: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantResponseBodyTenantReadOnlyResource extends $tea.Model {
  capacityUnit?: DescribeTenantResponseBodyTenantReadOnlyResourceCapacityUnit;
  cpu?: DescribeTenantResponseBodyTenantReadOnlyResourceCpu;
  diskSize?: DescribeTenantResponseBodyTenantReadOnlyResourceDiskSize;
  logDiskSize?: DescribeTenantResponseBodyTenantReadOnlyResourceLogDiskSize;
  memory?: DescribeTenantResponseBodyTenantReadOnlyResourceMemory;
  unitNum?: number;
  static names(): { [key: string]: string } {
    return {
      capacityUnit: 'CapacityUnit',
      cpu: 'Cpu',
      diskSize: 'DiskSize',
      logDiskSize: 'LogDiskSize',
      memory: 'Memory',
      unitNum: 'UnitNum',
    };
  }

  static types(): { [key: string]: any } {
    return {
      capacityUnit: DescribeTenantResponseBodyTenantReadOnlyResourceCapacityUnit,
      cpu: DescribeTenantResponseBodyTenantReadOnlyResourceCpu,
      diskSize: DescribeTenantResponseBodyTenantReadOnlyResourceDiskSize,
      logDiskSize: DescribeTenantResponseBodyTenantReadOnlyResourceLogDiskSize,
      memory: DescribeTenantResponseBodyTenantReadOnlyResourceMemory,
      unitNum: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantResponseBodyTenantTenantConnections extends $tea.Model {
  /**
   * @remarks
   * The primary zone of the tenant.
   * 
   * @example
   * MASTER
   */
  addressType?: string;
  connectionLogicalZones?: string[];
  connectionReplicaType?: string;
  /**
   * @remarks
   * The Internet address for accessing the tenant.
   * 
   * @example
   * ["cn-hangzhou-i", "cn-hangzhou-j"]
   */
  connectionZones?: string[];
  enableTransactionSplit?: boolean;
  /**
   * @remarks
   * The ID of the VPC.
   * 
   * @example
   * t32a7ru5u****mo.oceanbase.aliyuncs.com
   */
  internetAddress?: string;
  /**
   * @remarks
   * 实例系列
   * 
   * @example
   * CLOSED
   */
  internetAddressStatus?: string;
  internetMaxConnectionLimit?: number;
  internetMaxConnectionNum?: number;
  /**
   * @remarks
   * 实例类型
   * 
   * @example
   * 3306
   */
  internetPort?: number;
  internetRpcPort?: number;
  /**
   * @remarks
   * The deployment type of the cluster. Valid values:  
   * - multiple: multi-IDC deployment   
   * - single: single-IDC deployment   
   * - dual: dual-IDC deployment
   * 
   * @example
   * t32a7ru5u****.oceanbase.aliyuncs.com
   */
  intranetAddress?: string;
  /**
   * @remarks
   * PayCore business database
   * 
   * @example
   * cn-hangzhou-i
   */
  intranetAddressMasterZoneId?: string;
  /**
   * @remarks
   * The total number of CPU cores of the tenant.
   * 
   * @example
   * cn-hangzhou-j
   */
  intranetAddressSlaveZoneId?: string;
  /**
   * @remarks
   * 付费类型
   * 
   * @example
   * ONLINE
   */
  intranetAddressStatus?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * @example
   * 3306
   */
  intranetPort?: number;
  intranetRpcPort?: number;
  intranetSqlPort?: number;
  maxConnectionLimit?: number;
  /**
   * @example
   * 5000
   */
  maxConnectionNum?: number;
  odpVersion?: string;
  parallelQueryDegree?: number;
  proxyClusterId?: string;
  /**
   * @example
   * obe-4tw51gp7****
   */
  tenantEndpointId?: string;
  /**
   * @remarks
   * The primary zone corresponding to the address for accessing the tenant.
   * 
   * @example
   * true
   */
  transactionSplit?: boolean;
  /**
   * @remarks
   * The connection access information of the tenant.
   * 
   * @example
   * vsw-bp11k1aypnzu1l3whi****
   */
  vSwitchId?: string;
  /**
   * @remarks
   * The service mode of the connection address. Valid values:  
   * ReadWrite: provides strong-consistency read and write services.   
   * ReadOnly: provides the read-only service to ensure ultimate consistency of data.   
   * Clog: provides transaction log services.
   * 
   * @example
   * vpc-bp1qiail1asmfe23t****
   */
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      addressType: 'AddressType',
      connectionLogicalZones: 'ConnectionLogicalZones',
      connectionReplicaType: 'ConnectionReplicaType',
      connectionZones: 'ConnectionZones',
      enableTransactionSplit: 'EnableTransactionSplit',
      internetAddress: 'InternetAddress',
      internetAddressStatus: 'InternetAddressStatus',
      internetMaxConnectionLimit: 'InternetMaxConnectionLimit',
      internetMaxConnectionNum: 'InternetMaxConnectionNum',
      internetPort: 'InternetPort',
      internetRpcPort: 'InternetRpcPort',
      intranetAddress: 'IntranetAddress',
      intranetAddressMasterZoneId: 'IntranetAddressMasterZoneId',
      intranetAddressSlaveZoneId: 'IntranetAddressSlaveZoneId',
      intranetAddressStatus: 'IntranetAddressStatus',
      intranetPort: 'IntranetPort',
      intranetRpcPort: 'IntranetRpcPort',
      intranetSqlPort: 'IntranetSqlPort',
      maxConnectionLimit: 'MaxConnectionLimit',
      maxConnectionNum: 'MaxConnectionNum',
      odpVersion: 'OdpVersion',
      parallelQueryDegree: 'ParallelQueryDegree',
      proxyClusterId: 'ProxyClusterId',
      tenantEndpointId: 'TenantEndpointId',
      transactionSplit: 'TransactionSplit',
      vSwitchId: 'VSwitchId',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addressType: 'string',
      connectionLogicalZones: { 'type': 'array', 'itemType': 'string' },
      connectionReplicaType: 'string',
      connectionZones: { 'type': 'array', 'itemType': 'string' },
      enableTransactionSplit: 'boolean',
      internetAddress: 'string',
      internetAddressStatus: 'string',
      internetMaxConnectionLimit: 'number',
      internetMaxConnectionNum: 'number',
      internetPort: 'number',
      internetRpcPort: 'number',
      intranetAddress: 'string',
      intranetAddressMasterZoneId: 'string',
      intranetAddressSlaveZoneId: 'string',
      intranetAddressStatus: 'string',
      intranetPort: 'number',
      intranetRpcPort: 'number',
      intranetSqlPort: 'number',
      maxConnectionLimit: 'number',
      maxConnectionNum: 'number',
      odpVersion: 'string',
      parallelQueryDegree: 'number',
      proxyClusterId: 'string',
      tenantEndpointId: 'string',
      transactionSplit: 'boolean',
      vSwitchId: 'string',
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantResponseBodyTenantTenantResourceCapacityUnit extends $tea.Model {
  maxCapacityUnit?: number;
  minCapacityUnit?: number;
  usedCapacit?: number;
  static names(): { [key: string]: string } {
    return {
      maxCapacityUnit: 'MaxCapacityUnit',
      minCapacityUnit: 'MinCapacityUnit',
      usedCapacit: 'UsedCapacit',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxCapacityUnit: 'number',
      minCapacityUnit: 'number',
      usedCapacit: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantResponseBodyTenantTenantResourceCpu extends $tea.Model {
  /**
   * @remarks
   * The data replica distribution mode of the tenant.    
   * 
   * - For the high availability version, N-N-N indicates the three-zone mode, and N-N indicates the dual-zone or single-zone mode.
   * - For the basic version, N indicates the single-zone mode. 
   * 
   * > <br>N represents the number of nodes in a single zone.
   * 
   * @example
   * 10
   */
  totalCpu?: number;
  /**
   * @remarks
   * The zone corresponding to the tenant connection.
   * 
   * @example
   * 8
   */
  unitCpu?: number;
  /**
   * @remarks
   * The tenant mode.   
   * Valid values: 
   * Oracle   
   * MySQL
   * 
   * @example
   * 8
   */
  usedCpu?: number;
  static names(): { [key: string]: string } {
    return {
      totalCpu: 'TotalCpu',
      unitCpu: 'UnitCpu',
      usedCpu: 'UsedCpu',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCpu: 'number',
      unitCpu: 'number',
      usedCpu: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantResponseBodyTenantTenantResourceDiskSize extends $tea.Model {
  /**
   * @remarks
   * The total memory size of the tenant, in GB.
   * 
   * @example
   * 86
   */
  usedDiskSize?: number;
  static names(): { [key: string]: string } {
    return {
      usedDiskSize: 'UsedDiskSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      usedDiskSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantResponseBodyTenantTenantResourceLogDiskSize extends $tea.Model {
  totalLogDisk?: number;
  unitLogDisk?: number;
  static names(): { [key: string]: string } {
    return {
      totalLogDisk: 'TotalLogDisk',
      unitLogDisk: 'UnitLogDisk',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalLogDisk: 'number',
      unitLogDisk: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantResponseBodyTenantTenantResourceMemory extends $tea.Model {
  /**
   * @remarks
   * The information about the memory resources of the tenant.
   * 
   * @example
   * 64
   */
  totalMemory?: number;
  /**
   * @remarks
   * The time when the tenant was created.
   * 
   * @example
   * 32
   */
  unitMemory?: number;
  /**
   * @remarks
   * The status of the Internet address for accessing the tenant. Valid values:   
   * Closed: The address is disabled.   
   * - ALLOCATING_INTERNET_ADDRESS: An address is being applied for.   
   * - PENDING_OFFLINE_INTERNET_ADDRESS: The address is being disabled.   
   * - ONLINE: The address is in service.
   * 
   * @example
   * 30
   */
  usedMemory?: number;
  static names(): { [key: string]: string } {
    return {
      totalMemory: 'TotalMemory',
      unitMemory: 'UnitMemory',
      usedMemory: 'UsedMemory',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalMemory: 'number',
      unitMemory: 'number',
      usedMemory: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantResponseBodyTenantTenantResource extends $tea.Model {
  capacityUnit?: DescribeTenantResponseBodyTenantTenantResourceCapacityUnit;
  /**
   * @remarks
   * The enabling status of the Clog service.  
   * CLOSED: The Clog service is disabled.  
   * - ONLINE: The Clog service is running.
   */
  cpu?: DescribeTenantResponseBodyTenantTenantResourceCpu;
  /**
   * @remarks
   * The status of the intranet address for accessing the tenant.  
   * The value ONLINE indicates that the address is in service.
   */
  diskSize?: DescribeTenantResponseBodyTenantTenantResourceDiskSize;
  logDiskSize?: DescribeTenantResponseBodyTenantTenantResourceLogDiskSize;
  /**
   * @remarks
   * The description of the tenant.
   */
  memory?: DescribeTenantResponseBodyTenantTenantResourceMemory;
  /**
   * @remarks
   * Alibaba Cloud CLI
   * 
   * @example
   * 1
   */
  unitNum?: number;
  static names(): { [key: string]: string } {
    return {
      capacityUnit: 'CapacityUnit',
      cpu: 'Cpu',
      diskSize: 'DiskSize',
      logDiskSize: 'LogDiskSize',
      memory: 'Memory',
      unitNum: 'UnitNum',
    };
  }

  static types(): { [key: string]: any } {
    return {
      capacityUnit: DescribeTenantResponseBodyTenantTenantResourceCapacityUnit,
      cpu: DescribeTenantResponseBodyTenantTenantResourceCpu,
      diskSize: DescribeTenantResponseBodyTenantTenantResourceDiskSize,
      logDiskSize: DescribeTenantResponseBodyTenantTenantResourceLogDiskSize,
      memory: DescribeTenantResponseBodyTenantTenantResourceMemory,
      unitNum: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantResponseBodyTenantTenantZonesTenantZoneReplicas extends $tea.Model {
  fullCopyId?: number;
  logicZoneName?: string;
  readOnlyCopyId?: string;
  zoneCopyId?: number;
  zoneNodes?: string;
  zoneReplicaType?: string;
  static names(): { [key: string]: string } {
    return {
      fullCopyId: 'FullCopyId',
      logicZoneName: 'LogicZoneName',
      readOnlyCopyId: 'ReadOnlyCopyId',
      zoneCopyId: 'ZoneCopyId',
      zoneNodes: 'ZoneNodes',
      zoneReplicaType: 'ZoneReplicaType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fullCopyId: 'number',
      logicZoneName: 'string',
      readOnlyCopyId: 'string',
      zoneCopyId: 'number',
      zoneNodes: 'string',
      zoneReplicaType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantResponseBodyTenantTenantZones extends $tea.Model {
  /**
   * @remarks
   * 是否允许开启读写分离地址
   * 
   * @example
   * cn-hangzhou
   */
  region?: string;
  /**
   * @remarks
   * The intranet port for accessing the tenant.
   * 
   * @example
   * cn-hangzhou-i
   */
  tenantZoneId?: string;
  tenantZoneReplicas?: DescribeTenantResponseBodyTenantTenantZonesTenantZoneReplicas[];
  /**
   * @remarks
   * The character set.
   * 
   * @example
   * ReadOnly
   */
  tenantZoneRole?: string;
  static names(): { [key: string]: string } {
    return {
      region: 'Region',
      tenantZoneId: 'TenantZoneId',
      tenantZoneReplicas: 'TenantZoneReplicas',
      tenantZoneRole: 'TenantZoneRole',
    };
  }

  static types(): { [key: string]: any } {
    return {
      region: 'string',
      tenantZoneId: 'string',
      tenantZoneReplicas: { 'type': 'array', 'itemType': DescribeTenantResponseBodyTenantTenantZonesTenantZoneReplicas },
      tenantZoneRole: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantResponseBodyTenant extends $tea.Model {
  /**
   * @remarks
   * DescribeTenant
   */
  availableZones?: string[];
  /**
   * @remarks
   * The number of CPU cores in each resource unit of the tenant.
   * 
   * @example
   * utf8mb4
   */
  charset?: string;
  /**
   * @remarks
   * 地址类型
   * 
   * @example
   * CLOSED
   */
  clogServiceStatus?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * utf8mb4_general_ci
   */
  collation?: string;
  /**
   * @remarks
   * You can call this operation to create a single tenant in a specific cluster.
   * 
   * @example
   * 2021-09-17 15:52:17
   */
  createTime?: string;
  dataMergeTime?: string;
  /**
   * @remarks
   * The list of zones.
   * 
   * @example
   * 1-1-1
   */
  deployMode?: string;
  /**
   * @remarks
   * The series of the instance.
   * 
   * @example
   * multiple
   */
  deployType?: string;
  /**
   * @remarks
   * Indicates whether to enable read/write splitting endpoint.
   * 
   * @example
   * The information of the tenant.
   */
  description?: string;
  /**
   * @remarks
   * You can call this operation to query the information of a specific tenant in a specific cluster.
   * 
   * @example
   * cloud_essd_pl1
   */
  diskType?: string;
  /**
   * @remarks
   * 是否可以申请Binlog服务
   */
  enableBinlogService?: boolean;
  /**
   * @remarks
   * The intranet address for accessing the tenant.
   * 
   * @example
   * false
   */
  enableClogService?: boolean;
  /**
   * @remarks
   * The deployment type of the primary zone.
   * 
   * @example
   * true
   */
  enableInternetAddressService?: boolean;
  enableParallelQuery?: boolean;
  enableReadOnlyReplica?: boolean;
  /**
   * @example
   * false
   */
  enableReadWriteSplit?: boolean;
  /**
   * @remarks
   * {
   *     "RequestId": "EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C",
   *     "Tenant": {
   *         "TenantId": "t33h8y08k****",
   *         "TenantName": "pay_online",
   *         "TenantMode": "Oracle",
   *         "VpcId": "vpc-bp1d2q3mhg9i23ofi****",
   *         "Status": "ONLINE",
   *         "PrimaryZone": "cn-hangzhou-i",
   *         "DeployType": "multiple",
   *         "DeployMode": "1-1-1",
   *         "Description": "PayCore business database",
   *         "CreateTime": "2021-09-17 15:52:17",
   *         "TenantResource": {
   *             "UnitNum": 1,
   *             "Cpu": {
   *                 "UsedCpu": 8,
   *                 "TotalCpu": 10,
   *                 "UnitCpu": 8
   *             },
   *             "Memory": {
   *                 "UsedMemory": 30,
   *                 "TotalMemory": 64,
   *                 "UnitMemory": 32
   *             },
   *             "DiskSize": {
   *                 "UsedDiskSize": 86
   *             }
   *         },
   *         "TenantConnections": [
   *             {
   *                 "ConnectionRole": "ReadWrite",
   *                 "IntranetAddress": "t32a7ru5u****.oceanbase.aliyuncs.com",
   *                 "IntranetPort": 3306,
   *                 "InternetAddress": "t32a7ru5u****mo.oceanbase.aliyuncs.com",
   *                 "InternetPort": 3306,
   *                 "VpcId": "vpc-bp1qiail1asmfe23t****",
   *                 "VSwitchId": "vsw-bp11k1aypnzu1l3whi****",
   *                 "IntranetAddressMasterZoneId": "cn-hangzhou-i",
   *                 "IntranetAddressSlaveZoneId": "cn-hangzhou-j",
   *                 "IntranetAddressStatus": "ONLINE",
   *                 "ConnectionZones": [
   *                     "cn-hangzhou-i"
   *                 ],
   *                 "InternetAddressStatus": "CLOSED"
   *             }
   *         ],
   *         "TenantZones": [
   *             {
   *                 "TenantZoneId": "cn-hangzhou-i",
   *                 "Region": "cn-hangzhou",
   *                 "TenantZoneRole": "ReadOnly"
   *             }
   *         ],
   *         "ClogServiceStatus": "CLOSED"
   *     }
   * }
   * 
   * @example
   * KAFKA_PUBLIC
   */
  instanceType?: string;
  lowerCaseTableNames?: number;
  /**
   * @remarks
   * ```
   * http(s)://[Endpoint]/?Action=DescribeTenant
   * &InstanceId=ob317v4uif****
   * &TenantId=ob2mr3oae0****
   * &Common request parameters
   * ```
   * 
   * @example
   * cn-hangzhou-h
   */
  masterIntranetAddressZone?: string;
  /**
   * @example
   * 32
   */
  maxParallelQueryDegree?: number;
  odpVersion?: string;
  /**
   * @example
   * POSTPAY
   */
  payType?: string;
  /**
   * @remarks
   * The type of the payment.
   * 
   * @example
   * cn-hangzhou-i
   */
  primaryZone?: string;
  /**
   * @remarks
   * Example 1
   * 
   * @example
   * RANDOM
   */
  primaryZoneDeployType?: string;
  readOnlyResource?: DescribeTenantResponseBodyTenantReadOnlyResource;
  recycleBinStatus?: string;
  /**
   * @remarks
   * <DescribeTenantResponse>
   *     <RequestId>EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C</RequestId>
   *     <Tenant>
   *         <TenantId>t33h8y08k****</TenantId>
   *         <TenantName>pay_online</TenantName>
   *         <TenantMode>Oracle</TenantMode>
   *         <VpcId>vpc-bp1d2q3mhg9i23ofi****</VpcId>
   *         <Status>ONLINE</Status>
   *         <PrimaryZone>cn-hangzhou-i</PrimaryZone>
   *         <DeployType>multiple</DeployType>
   *         <DeployMode>1-1-1</DeployMode>
   *         <Description>PayCore business database</Description>
   *         <CreateTime>2021-09-17 15:52:17</CreateTime>
   *         <TenantResource>
   *             <UnitNum>1</UnitNum>
   *             <Cpu>
   *                 <UsedCpu>8</UsedCpu>
   *                 <TotalCpu>10</TotalCpu>
   *                 <UnitCpu>8</UnitCpu>
   *             </Cpu>
   *             <Memory>
   *                 <UsedMemory>30</UsedMemory>
   *                 <TotalMemory>64</TotalMemory>
   *                 <UnitMemory>32</UnitMemory>
   *             </Memory>
   *             <DiskSize>
   *                 <UsedDiskSize>86</UsedDiskSize>
   *             </DiskSize>
   *         </TenantResource>
   *         <TenantConnections>
   *             <ConnectionRole>ReadWrite</ConnectionRole>
   *             <IntranetAddress>t32a7ru5u****.oceanbase.aliyuncs.com</IntranetAddress>
   *             <IntranetPort>3306</IntranetPort>
   *             <InternetAddress>t32a7ru5u****mo.oceanbase.aliyuncs.com</InternetAddress>
   *             <InternetPort>3306</InternetPort>
   *             <VpcId>vpc-bp1qiail1asmfe23t****</VpcId>
   *             <VSwitchId>vsw-bp11k1aypnzu1l3whi****</VSwitchId>
   *             <IntranetAddressMasterZoneId>cn-hangzhou-i</IntranetAddressMasterZoneId>
   *             <IntranetAddressSlaveZoneId>cn-hangzhou-j</IntranetAddressSlaveZoneId>
   *             <IntranetAddressStatus>ONLINE</IntranetAddressStatus>
   *             <ConnectionZones>cn-hangzhou-i</ConnectionZones>
   *             <InternetAddressStatus>CLOSED</InternetAddressStatus>
   *         </TenantConnections>
   *         <TenantZones>
   *             <TenantZoneId>cn-hangzhou-i</TenantZoneId>
   *             <Region>cn-hangzhou</Region>
   *             <TenantZoneRole>ReadOnly</TenantZoneRole>
   *         </TenantZones>
   *         <ClogServiceStatus>CLOSED</ClogServiceStatus>
   *     </Tenant>
   * </DescribeTenantResponse>
   * 
   * @example
   * normal
   */
  series?: string;
  /**
   * @remarks
   * The character set.
   * 
   * @example
   * ONLINE
   */
  status?: string;
  /**
   * @remarks
   * The status of the tenant.   
   * - PENDING_CREATE: The tenant is being created.   
   * - RESTORE: The tenant is being recovered.   
   * - ONLINE: The tenant is running.   
   * - SPEC_MODIFYING: The specification of the tenant is being modified.   
   * - ALLOCATING_INTERNET_ADDRESS: An Internet address is being allocated.  
   * - PENDING_OFFLINE_INTERNET_ADDRESS: The Internet address is being disabled.  
   * - PRIMARY_ZONE_MODIFYING: The tenant is switching to a new primary zone.  
   * - PARAMETER_MODIFYING: Parameters are being modified.   
   * - WHITE_LIST_MODIFYING: The whitelist is being modified.
   */
  tenantConnections?: DescribeTenantResponseBodyTenantTenantConnections[];
  /**
   * @remarks
   * The region where the zone of the tenant resides.
   * 
   * @example
   * t33h8y08k****
   */
  tenantId?: string;
  /**
   * @remarks
   * The enabling status of the clog service.  
   * - CLOSED: The clog service is disabled.  
   * - ONLINE: The clog service is running.
   * 
   * @example
   * Oracle
   */
  tenantMode?: string;
  /**
   * @remarks
   * The request type of the zone of the tenant.  ReadWrite: The zone supports data reads and writes. ReadOnly: The zone supports only data reads. For a high availability cluster with multiple IDCs, the primary zone provides ReadWrite services, and the standby zone provides ReadOnly services. For a high availability cluster with a single IDC, all zones provide ReadWrite services.
   * 
   * @example
   * pay_online
   */
  tenantName?: string;
  /**
   * @remarks
   * It is an online CLI tool that allows you to quickly retrieve and debug APIs. It can dynamically generate executable SDK code samples.
   */
  tenantResource?: DescribeTenantResponseBodyTenantTenantResource;
  /**
   * @remarks
   * The standby zone corresponding to the address for accessing the tenant.
   */
  tenantZones?: DescribeTenantResponseBodyTenantTenantZones[];
  timeZone?: string;
  version?: string;
  /**
   * @remarks
   * Indicates whether the clog service is available. To enable the clog service, submit a ticket.
   * 
   * @example
   * vpc-bp1d2q3mhg9i23ofi****
   */
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      availableZones: 'AvailableZones',
      charset: 'Charset',
      clogServiceStatus: 'ClogServiceStatus',
      collation: 'Collation',
      createTime: 'CreateTime',
      dataMergeTime: 'DataMergeTime',
      deployMode: 'DeployMode',
      deployType: 'DeployType',
      description: 'Description',
      diskType: 'DiskType',
      enableBinlogService: 'EnableBinlogService',
      enableClogService: 'EnableClogService',
      enableInternetAddressService: 'EnableInternetAddressService',
      enableParallelQuery: 'EnableParallelQuery',
      enableReadOnlyReplica: 'EnableReadOnlyReplica',
      enableReadWriteSplit: 'EnableReadWriteSplit',
      instanceType: 'InstanceType',
      lowerCaseTableNames: 'LowerCaseTableNames',
      masterIntranetAddressZone: 'MasterIntranetAddressZone',
      maxParallelQueryDegree: 'MaxParallelQueryDegree',
      odpVersion: 'OdpVersion',
      payType: 'PayType',
      primaryZone: 'PrimaryZone',
      primaryZoneDeployType: 'PrimaryZoneDeployType',
      readOnlyResource: 'ReadOnlyResource',
      recycleBinStatus: 'RecycleBinStatus',
      series: 'Series',
      status: 'Status',
      tenantConnections: 'TenantConnections',
      tenantId: 'TenantId',
      tenantMode: 'TenantMode',
      tenantName: 'TenantName',
      tenantResource: 'TenantResource',
      tenantZones: 'TenantZones',
      timeZone: 'TimeZone',
      version: 'Version',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      availableZones: { 'type': 'array', 'itemType': 'string' },
      charset: 'string',
      clogServiceStatus: 'string',
      collation: 'string',
      createTime: 'string',
      dataMergeTime: 'string',
      deployMode: 'string',
      deployType: 'string',
      description: 'string',
      diskType: 'string',
      enableBinlogService: 'boolean',
      enableClogService: 'boolean',
      enableInternetAddressService: 'boolean',
      enableParallelQuery: 'boolean',
      enableReadOnlyReplica: 'boolean',
      enableReadWriteSplit: 'boolean',
      instanceType: 'string',
      lowerCaseTableNames: 'number',
      masterIntranetAddressZone: 'string',
      maxParallelQueryDegree: 'number',
      odpVersion: 'string',
      payType: 'string',
      primaryZone: 'string',
      primaryZoneDeployType: 'string',
      readOnlyResource: DescribeTenantResponseBodyTenantReadOnlyResource,
      recycleBinStatus: 'string',
      series: 'string',
      status: 'string',
      tenantConnections: { 'type': 'array', 'itemType': DescribeTenantResponseBodyTenantTenantConnections },
      tenantId: 'string',
      tenantMode: 'string',
      tenantName: 'string',
      tenantResource: DescribeTenantResponseBodyTenantTenantResource,
      tenantZones: { 'type': 'array', 'itemType': DescribeTenantResponseBodyTenantTenantZones },
      timeZone: 'string',
      version: 'string',
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantEncryptionResponseBodyTenantEncryptions extends $tea.Model {
  /**
   * @example
   * false
   */
  enableEncryption?: boolean;
  /**
   * @example
   * xxx
   */
  encryptionKeyId?: string;
  /**
   * @example
   * INTERNAL
   */
  encryptionType?: string;
  /**
   * @example
   * OPEN
   */
  status?: string;
  /**
   * @example
   * t4louaeei****
   */
  tenantId?: string;
  /**
   * @example
   * MySQL
   */
  tenantMode?: string;
  /**
   * @example
   * forMySQLTenant
   */
  tenantName?: string;
  /**
   * @example
   * ONLINE
   */
  tenantStatus?: string;
  static names(): { [key: string]: string } {
    return {
      enableEncryption: 'EnableEncryption',
      encryptionKeyId: 'EncryptionKeyId',
      encryptionType: 'EncryptionType',
      status: 'Status',
      tenantId: 'TenantId',
      tenantMode: 'TenantMode',
      tenantName: 'TenantName',
      tenantStatus: 'TenantStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enableEncryption: 'boolean',
      encryptionKeyId: 'string',
      encryptionType: 'string',
      status: 'string',
      tenantId: 'string',
      tenantMode: 'string',
      tenantName: 'string',
      tenantStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantReadableScnResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The maximum readable timestamp.
   * 
   * @example
   * 1715329164977
   */
  readableScn?: number;
  static names(): { [key: string]: string } {
    return {
      readableScn: 'ReadableScn',
    };
  }

  static types(): { [key: string]: any } {
    return {
      readableScn: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantSecurityConfigsResponseBodyConfigsTenantSecurityConfigsSecurityConfigs extends $tea.Model {
  /**
   * @remarks
   * The name of the check item.
   * 
   * @example
   * Check whether the scope of the cluster allowlist is too big
   */
  configDescription?: string;
  /**
   * @remarks
   * The group of the risk.
   * 
   * @example
   * WHITELIST
   */
  configGroup?: string;
  /**
   * @remarks
   * The name of the risk.
   * 
   * @example
   * WHITELIST_RANGE_LARGE
   */
  configName?: string;
  /**
   * @remarks
   * Indicates whether the risk causes security issues.
   * 
   * @example
   * true
   */
  risk?: boolean;
  /**
   * @remarks
   * The description of the risk.
   * 
   * @example
   * The scope of the allowlist is too big.
   */
  riskDescription?: string;
  static names(): { [key: string]: string } {
    return {
      configDescription: 'ConfigDescription',
      configGroup: 'ConfigGroup',
      configName: 'ConfigName',
      risk: 'Risk',
      riskDescription: 'RiskDescription',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configDescription: 'string',
      configGroup: 'string',
      configName: 'string',
      risk: 'boolean',
      riskDescription: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantSecurityConfigsResponseBodyConfigsTenantSecurityConfigs extends $tea.Model {
  /**
   * @remarks
   * The number of detected tenant security risks.
   * 
   * @example
   * 0
   */
  riskCount?: number;
  /**
   * @remarks
   * The list of risks.
   */
  securityConfigs?: DescribeTenantSecurityConfigsResponseBodyConfigsTenantSecurityConfigsSecurityConfigs[];
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * @example
   * xxx
   */
  tenantId?: string;
  /**
   * @remarks
   * The name of the tenant.
   * 
   * @example
   * xxx
   */
  tenantName?: string;
  static names(): { [key: string]: string } {
    return {
      riskCount: 'RiskCount',
      securityConfigs: 'SecurityConfigs',
      tenantId: 'TenantId',
      tenantName: 'TenantName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      riskCount: 'number',
      securityConfigs: { 'type': 'array', 'itemType': DescribeTenantSecurityConfigsResponseBodyConfigsTenantSecurityConfigsSecurityConfigs },
      tenantId: 'string',
      tenantName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantSecurityConfigsResponseBodyConfigs extends $tea.Model {
  /**
   * @remarks
   * The unique identifier of the check.
   * 
   * @example
   * xxx
   */
  checkId?: string;
  /**
   * @remarks
   * The time when the check was performed.
   * 
   * @example
   * 2023-08-07 15:30:00
   */
  checkTime?: string;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The check result.
   */
  tenantSecurityConfigs?: DescribeTenantSecurityConfigsResponseBodyConfigsTenantSecurityConfigs[];
  /**
   * @remarks
   * The total number of security check items.
   * 
   * @example
   * 4
   */
  totalCheckCount?: number;
  /**
   * @remarks
   * The total number of detected security risks.
   * 
   * @example
   * 0
   */
  totalRiskCount?: number;
  static names(): { [key: string]: string } {
    return {
      checkId: 'CheckId',
      checkTime: 'CheckTime',
      instanceId: 'InstanceId',
      tenantSecurityConfigs: 'TenantSecurityConfigs',
      totalCheckCount: 'TotalCheckCount',
      totalRiskCount: 'TotalRiskCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkId: 'string',
      checkTime: 'string',
      instanceId: 'string',
      tenantSecurityConfigs: { 'type': 'array', 'itemType': DescribeTenantSecurityConfigsResponseBodyConfigsTenantSecurityConfigs },
      totalCheckCount: 'number',
      totalRiskCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantSecurityIpGroupsResponseBodySecurityIpGroups extends $tea.Model {
  /**
   * @remarks
   * The group name.
   * 
   * @example
   * test1
   */
  securityIpGroupName?: string;
  /**
   * @remarks
   * The whitelist group type.
   * - instance: the whitelist group from the cluster.
   * - tenant: the whitelist group of the current tenant.
   * 
   * @example
   * tenant
   */
  securityIpGroupType?: string;
  /**
   * @remarks
   * The whitelist of IP addresses. It is a string separated by commas, and each object is an IP string or a CIDR block.
   * 
   * @example
   * 192.***.*.*"
   */
  securityIps?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * @example
   * t4louaeei****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      securityIpGroupName: 'SecurityIpGroupName',
      securityIpGroupType: 'SecurityIpGroupType',
      securityIps: 'SecurityIps',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      securityIpGroupName: 'string',
      securityIpGroupType: 'string',
      securityIps: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantTagsResponseBodyTagResources extends $tea.Model {
  /**
   * @remarks
   * The ID of the resource.
   * 
   * @example
   * ob317v4uif****
   */
  resourceId?: string;
  /**
   * @remarks
   * The type of the resource.
   * 
   * @example
   * instance
   */
  resourceType?: string;
  /**
   * @remarks
   * The tag of the resource.
   * 
   * @example
   * [{"Key": "xxx", "Value", "xxx"},{}]
   */
  tag?: string;
  static names(): { [key: string]: string } {
    return {
      resourceId: 'ResourceId',
      resourceType: 'ResourceType',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceId: 'string',
      resourceType: 'string',
      tag: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantUsersResponseBodyTenantUsersDatabases extends $tea.Model {
  /**
   * @example
   * db_pay1
   */
  database?: string;
  privileges?: string;
  /**
   * @example
   * ReadOnly
   */
  role?: string;
  /**
   * @example
   * tbl_pay1
   */
  table?: string;
  static names(): { [key: string]: string } {
    return {
      database: 'Database',
      privileges: 'Privileges',
      role: 'Role',
      table: 'Table',
    };
  }

  static types(): { [key: string]: any } {
    return {
      database: 'string',
      privileges: 'string',
      role: 'string',
      table: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantUsersResponseBodyTenantUsers extends $tea.Model {
  databases?: DescribeTenantUsersResponseBodyTenantUsersDatabases[];
  /**
   * @example
   * use for test
   */
  description?: string;
  /**
   * @remarks
   * 所属集群Id
   * 
   * @example
   * obshc32****
   */
  instanceId?: string;
  /**
   * @remarks
   * 所属租户Id
   * 
   * @example
   * tshfs3****
   */
  tenantId?: string;
  /**
   * @example
   * pay_test
   */
  userName?: string;
  /**
   * @example
   * NORMAL
   */
  userStatus?: string;
  /**
   * @example
   * NORMAL
   */
  userType?: string;
  static names(): { [key: string]: string } {
    return {
      databases: 'Databases',
      description: 'Description',
      instanceId: 'InstanceId',
      tenantId: 'TenantId',
      userName: 'UserName',
      userStatus: 'UserStatus',
      userType: 'UserType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      databases: { 'type': 'array', 'itemType': DescribeTenantUsersResponseBodyTenantUsersDatabases },
      description: 'string',
      instanceId: 'string',
      tenantId: 'string',
      userName: 'string',
      userStatus: 'string',
      userType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantZonesReadResponseBodyTenantZones extends $tea.Model {
  /**
   * @remarks
   * Example 1
   * 
   * @example
   * true
   */
  isElectable?: boolean;
  /**
   * @example
   * true
   */
  isPrimary?: boolean;
  /**
   * @example
   * true
   */
  isReadable?: string;
  /**
   * @example
   * cn-hangzhou-i
   */
  zone?: string;
  static names(): { [key: string]: string } {
    return {
      isElectable: 'IsElectable',
      isPrimary: 'IsPrimary',
      isReadable: 'IsReadable',
      zone: 'Zone',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isElectable: 'boolean',
      isPrimary: 'boolean',
      isReadable: 'string',
      zone: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantsResponseBodyTenants extends $tea.Model {
  /**
   * @example
   * utf8mb4
   */
  charset?: string;
  /**
   * @example
   * utf8mb4_general_ci
   */
  collation?: string;
  /**
   * @remarks
   * The total number of CPU cores of the tenant.
   * 
   * @example
   * 10
   */
  cpu?: number;
  /**
   * @remarks
   * The number of CPU cores in each resource unit of the tenant.
   * 
   * @example
   * 2021-09-17 15:52:17.0
   */
  createTime?: string;
  /**
   * @remarks
   * The search keyword.
   * 
   * @example
   * 1-1-1
   */
  deployMode?: string;
  /**
   * @remarks
   * The name of the tenant.   
   * It must start with a letter or an underscore (_), and contain 2 to 20 characters, which can be uppercase letters, lowercase letters, digits, and underscores (_).  It cannot be set to sys.
   * 
   * @example
   * multiple
   */
  deployType?: string;
  /**
   * @remarks
   * Example 1
   * 
   * @example
   * ```
   * http(s)://[Endpoint]/?Action=DescribeTenants
   * &InstanceId=ob317v4uif****
   * &TenantName=pay_online
   * &PageSize=10
   * &PageNumber=1
   * &TenantId=ob2mr3oae0****
   * &SearchKey=pay
   * &Common request parameters
   * ```
   */
  description?: string;
  enableReadOnlyReplica?: boolean;
  /**
   * @remarks
   * The number of the page to return.   
   * Start value: 1
   * - Default value: 1
   * 
   * @example
   * 20
   */
  mem?: number;
  /**
   * @remarks
   * The return result of the request.
   * 
   * @example
   * cn-hangzhou-i
   */
  primaryZone?: string;
  /**
   * @remarks
   * The status of the tenant.  <br>
   * - PENDING_CREATE: The tenant is being created.
   * - RESTORE: The tenant is being recovered.
   * - ONLINE: The tenant is running.
   * - SPEC_MODIFYING: The specification of the tenant is being modified.
   * ALLOCATING_INTERNET_ADDRESS: An Internet address is being allocated.
   * PENDING_OFFLINE_INTERNET_ADDRESS: The Internet address is being disabled.
   * - PRIMARY_ZONE_MODIFYING: The tenant is switching to a new primary zone.
   * - PARAMETER_MODIFYING: Parameters are being modified.
   * - WHITE_LIST_MODIFYING: The whitelist is being modified.
   * 
   * @example
   * ONLINE
   */
  status?: string;
  /**
   * @remarks
   * You can call this operation to query the tenants in an OceanBase cluster.
   * 
   * @example
   * t33h8y08k****
   */
  tenantId?: string;
  /**
   * @remarks
   * {
   *     "TotalCount": 1,
   *     "RequestId": "EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C",
   *     "Tenants": [
   *         {
   *             "VpcId": "vpc-bp1d2q3mhg9i23ofi****",
   *             "Status": "ONLINE",
   *             "PrimaryZone": "cn-hangzhou-i",
   *             "DeployType": "multiple",
   *             "DeployMode": "1-1-1",
   *             "CreateTime": "2021-09-17 15:52:17.0",
   *             "TenantName": "pay_online",
   *             "Mem": 20,
   *             "Cpu": 10,
   *             "Description": "PayCore business database",
   *             "TenantMode": "Oracle",
   *             "TenantId": "t33h8y08k****",
   *             "UnitCpu": 5,
   *             "UnitMem": 10,
   *             "UnitNum": 2,
   *             "UsedDiskSize": 10
   *         }
   *     ]
   * }
   * 
   * @example
   * Oracle
   */
  tenantMode?: string;
  /**
   * @remarks
   * The information of tenants.
   * 
   * @example
   * pay_online
   */
  tenantName?: string;
  /**
   * @example
   * 5
   */
  unitCpu?: number;
  /**
   * @example
   * 10
   */
  unitMem?: number;
  /**
   * @example
   * 2
   */
  unitNum?: number;
  /**
   * @example
   * 10
   */
  usedDiskSize?: number;
  /**
   * @remarks
   * The time when the tenant was created.
   * 
   * @example
   * vpc-bp1d2q3mhg9i23ofi****
   */
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      charset: 'Charset',
      collation: 'Collation',
      cpu: 'Cpu',
      createTime: 'CreateTime',
      deployMode: 'DeployMode',
      deployType: 'DeployType',
      description: 'Description',
      enableReadOnlyReplica: 'EnableReadOnlyReplica',
      mem: 'Mem',
      primaryZone: 'PrimaryZone',
      status: 'Status',
      tenantId: 'TenantId',
      tenantMode: 'TenantMode',
      tenantName: 'TenantName',
      unitCpu: 'UnitCpu',
      unitMem: 'UnitMem',
      unitNum: 'UnitNum',
      usedDiskSize: 'UsedDiskSize',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      charset: 'string',
      collation: 'string',
      cpu: 'number',
      createTime: 'string',
      deployMode: 'string',
      deployType: 'string',
      description: 'string',
      enableReadOnlyReplica: 'boolean',
      mem: 'number',
      primaryZone: 'string',
      status: 'string',
      tenantId: 'string',
      tenantMode: 'string',
      tenantName: 'string',
      unitCpu: 'number',
      unitMem: 'number',
      unitNum: 'number',
      usedDiskSize: 'number',
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTimeZonesResponseBodyTimeZonesList extends $tea.Model {
  /**
   * @remarks
   * Example 1
   * 
   * @example
   * (GMT+8:00) Asia/Shanghai
   */
  description?: string;
  /**
   * @remarks
   * The operation that you want to perform.   
   * Set the value to **DescribeTimeZones**.
   * 
   * @example
   * Asia/Shanghai
   */
  timeZone?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      timeZone: 'TimeZone',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      timeZone: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTimeZonesResponseBodyTimeZones extends $tea.Model {
  /**
   * @example
   * Asia/Shanghai
   */
  default?: string;
  /**
   * @remarks
   * The list of time zones.
   */
  list?: DescribeTimeZonesResponseBodyTimeZonesList[];
  static names(): { [key: string]: string } {
    return {
      default: 'Default',
      list: 'List',
    };
  }

  static types(): { [key: string]: any } {
    return {
      default: 'string',
      list: { 'type': 'array', 'itemType': DescribeTimeZonesResponseBodyTimeZonesList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTopSQLListResponseBodyTopSQLList extends $tea.Model {
  /**
   * @remarks
   * The internal wait time, in ms.
   * 
   * @example
   * 0
   */
  affectedRows?: number;
  /**
   * @remarks
   * The wait time in concurrent execution, in ms.
   * 
   * @example
   * 0.0
   */
  appWaitTime?: number;
  /**
   * @remarks
   * The average CPU time, in ms.
   * 
   * @example
   * 14
   */
  blockCacheHit?: number;
  /**
   * @remarks
   * $.parameters[16].schema.example
   * 
   * @example
   * 4
   */
  blockIndexCacheHit?: number;
  /**
   * @remarks
   * $.parameters[14].schema.enumValueTitles
   * 
   * @example
   * 0
   */
  bloomFilterCacheHit?: number;
  /**
   * @remarks
   * $.parameters[14].schema.description
   * 
   * @example
   * 1*2.***.1*3.***
   */
  clientIp?: string;
  /**
   * @remarks
   * The number of rows returned.
   * 
   * @example
   * 0.0
   */
  concurrencyWaitTime?: number;
  /**
   * @remarks
   * The maximum CPU time, in ms.
   * 
   * @example
   * 50.13
   */
  cpuTime?: number;
  /**
   * @remarks
   * The number of remote plans.
   * 
   * @example
   * testdb
   */
  dbName?: string;
  /**
   * @remarks
   * The number of rows to return on each page.   
   * - Maximum value: 100   
   * - Default value: 10
   * 
   * @example
   * 0.0
   */
  decodeTime?: number;
  /**
   * @remarks
   * The IP address of the client.
   * 
   * @example
   * 0
   */
  diskRead?: number;
  /**
   * @remarks
   * The sorting rule.
   * 
   * @example
   * 76.382
   */
  elapsedTime?: number;
  /**
   * @remarks
   * The number of rows read from the disk.
   * 
   * @example
   * mysql response wait client
   */
  event?: string;
  /**
   * @remarks
   * The operation that you want to perform.   
   * Set the value to **DescribeTopSQLList**.
   * 
   * @example
   * 163.0
   */
  execPerSecond?: number;
  /**
   * @remarks
   * The number of rows read from the memory.
   * 
   * @example
   * 61.044
   */
  executeTime?: number;
  /**
   * @remarks
   * The number of executions per second.
   * 
   * @example
   * 89403
   */
  executions?: number;
  /**
   * @remarks
   * $.parameters[12].schema.description
   * 
   * @example
   * 0
   */
  failTimes?: number;
  /**
   * @remarks
   * The queuing time, in ms.
   * 
   * @example
   * 0.052
   */
  getPlanTime?: number;
  /**
   * @remarks
   * $.parameters[15].schema.example
   * 
   * @example
   * 0.0
   */
  IOWaitTime?: number;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * 1
   */
  key?: number;
  /**
   * @remarks
   * You can call this operation to query SQL execution performance data collected by the diagnostic system.
   * 
   * @example
   * 19
   */
  logicalRead?: number;
  /**
   * @remarks
   * SQLID.
   * 
   * @example
   * 257.967
   */
  maxCpuTime?: number;
  /**
   * @remarks
   * The sequence number of the returned SQL statement.
   * 
   * @example
   * 260.044
   */
  maxElapsedTime?: number;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * 527
   */
  memstoreReadRowCount?: number;
  /**
   * @remarks
   * The total count.
   * 
   * @example
   * 0
   */
  missPlans?: number;
  /**
   * @remarks
   * The end time of the time range for querying TOP SQL statements.   
   * The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
   * 
   * @example
   * 0.0
   */
  netWaitTime?: number;
  /**
   * @remarks
   * The username.
   * 
   * @example
   * i-bp18qljorblo8es*****
   */
  nodeIp?: string;
  /**
   * @remarks
   * $.parameters[12].schema.enumValueTitles
   * 
   * @example
   * 15.275
   */
  queueTime?: number;
  /**
   * @remarks
   * The start time of the time range for querying TOP SQL statements.   
   * The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
   * 
   * @example
   * 0
   */
  RPCCount?: number;
  /**
   * @remarks
   * The return result of the request.
   * 
   * @example
   * 0
   */
  remotePlans?: number;
  /**
   * @remarks
   * $.parameters[13].schema.description
   * 
   * @example
   * 0
   */
  retryCount?: number;
  /**
   * @remarks
   * The wait event.
   * 
   * @example
   * 1
   */
  returnRows?: number;
  /**
   * @remarks
   * ```
   * http(s)://[Endpoint]/?Action=DescribeTopSQLList
   * &TenantId=t2mr3oae0****
   * &StartTime=2021-06-13 15:40:43
   * &EndTime=2021-09-13 15:40:43
   * &DbName=testdb
   * &SearchKeyWord=update
   * &SearchParameter=cputime
   * &SearchRule=>
   * &SearchValue=0.01
   * &SQLId=8D6E84****0B8FB1823D199E2CA1****
   * &NodeIp=i-bp19y05uq6xpacyqnlrc
   * &PageNumber=1
   * &PageSize=10
   * &SortColumn=cputime
   * &SortOrder=desc
   * &Common request parameters
   * ```
   * 
   * @example
   * 0
   */
  rowCacheHit?: number;
  /**
   * @remarks
   * $.parameters[13].schema.example
   * 
   * @example
   * 8D6E84****0B8FB1823D199E2CA1****
   */
  SQLId?: string;
  /**
   * @remarks
   * The list of top SQL statements.
   * 
   * @example
   * SELECT  ****   FROM ****   WHERE **** = ? AND **** = ?   ORDER BY **** ASC
   */
  SQLText?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 1
   */
  SQLType?: number;
  /**
   * @remarks
   * The search keyword.
   * 
   * @example
   * 0.0
   */
  scheduleTime?: number;
  /**
   * @example
   * 43086
   */
  ssstoreReadRowCount?: number;
  /**
   * @remarks
   * -
   * 
   * @example
   * 10.966
   */
  totalWaitTime?: number;
  /**
   * @remarks
   * The number of Bloom filter cache hits.
   * 
   * @example
   * tester
   */
  userName?: string;
  static names(): { [key: string]: string } {
    return {
      affectedRows: 'AffectedRows',
      appWaitTime: 'AppWaitTime',
      blockCacheHit: 'BlockCacheHit',
      blockIndexCacheHit: 'BlockIndexCacheHit',
      bloomFilterCacheHit: 'BloomFilterCacheHit',
      clientIp: 'ClientIp',
      concurrencyWaitTime: 'ConcurrencyWaitTime',
      cpuTime: 'CpuTime',
      dbName: 'DbName',
      decodeTime: 'DecodeTime',
      diskRead: 'DiskRead',
      elapsedTime: 'ElapsedTime',
      event: 'Event',
      execPerSecond: 'ExecPerSecond',
      executeTime: 'ExecuteTime',
      executions: 'Executions',
      failTimes: 'FailTimes',
      getPlanTime: 'GetPlanTime',
      IOWaitTime: 'IOWaitTime',
      key: 'Key',
      logicalRead: 'LogicalRead',
      maxCpuTime: 'MaxCpuTime',
      maxElapsedTime: 'MaxElapsedTime',
      memstoreReadRowCount: 'MemstoreReadRowCount',
      missPlans: 'MissPlans',
      netWaitTime: 'NetWaitTime',
      nodeIp: 'NodeIp',
      queueTime: 'QueueTime',
      RPCCount: 'RPCCount',
      remotePlans: 'RemotePlans',
      retryCount: 'RetryCount',
      returnRows: 'ReturnRows',
      rowCacheHit: 'RowCacheHit',
      SQLId: 'SQLId',
      SQLText: 'SQLText',
      SQLType: 'SQLType',
      scheduleTime: 'ScheduleTime',
      ssstoreReadRowCount: 'SsstoreReadRowCount',
      totalWaitTime: 'TotalWaitTime',
      userName: 'UserName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      affectedRows: 'number',
      appWaitTime: 'number',
      blockCacheHit: 'number',
      blockIndexCacheHit: 'number',
      bloomFilterCacheHit: 'number',
      clientIp: 'string',
      concurrencyWaitTime: 'number',
      cpuTime: 'number',
      dbName: 'string',
      decodeTime: 'number',
      diskRead: 'number',
      elapsedTime: 'number',
      event: 'string',
      execPerSecond: 'number',
      executeTime: 'number',
      executions: 'number',
      failTimes: 'number',
      getPlanTime: 'number',
      IOWaitTime: 'number',
      key: 'number',
      logicalRead: 'number',
      maxCpuTime: 'number',
      maxElapsedTime: 'number',
      memstoreReadRowCount: 'number',
      missPlans: 'number',
      netWaitTime: 'number',
      nodeIp: 'string',
      queueTime: 'number',
      RPCCount: 'number',
      remotePlans: 'number',
      retryCount: 'number',
      returnRows: 'number',
      rowCacheHit: 'number',
      SQLId: 'string',
      SQLText: 'string',
      SQLType: 'number',
      scheduleTime: 'number',
      ssstoreReadRowCount: 'number',
      totalWaitTime: 'number',
      userName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeZonesResponseBodyZones extends $tea.Model {
  /**
   * @example
   * 1-1-1
   */
  deployType?: string;
  /**
   * @example
   * NORMAL
   */
  series?: string;
  /**
   * @example
   * cn-hangzhou-i,cn-hangzhou-j,cn-hangzhou-h
   */
  zoneId?: string;
  /**
   * @example
   * H/I/J
   */
  zoneName?: string;
  static names(): { [key: string]: string } {
    return {
      deployType: 'DeployType',
      series: 'Series',
      zoneId: 'ZoneId',
      zoneName: 'ZoneName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deployType: 'string',
      series: 'string',
      zoneId: 'string',
      zoneName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUploadOssUrlResponseBodyData extends $tea.Model {
  /**
   * @example
   * 2023-07-26T06:33:11.175
   */
  expectedExpirationTime?: string;
  /**
   * @example
   * open_api_create_project/oacp_4xd****vk
   */
  ossKey?: string;
  /**
   * @example
   * https://cn-hangzhou-pre-omsstore.oss-cn-hangzhou.aliyuncs.com/open_api_create_project/oacp_4x****pvk?Expires=169031&OSSAccessKeyId=LTAI5tMN52D***TBf&Signature=XdDFPz%2BXKC***%2B
   */
  ossUrl?: string;
  static names(): { [key: string]: string } {
    return {
      expectedExpirationTime: 'ExpectedExpirationTime',
      ossKey: 'OssKey',
      ossUrl: 'OssUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      expectedExpirationTime: 'string',
      ossKey: 'string',
      ossUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUploadOssUrlResponseBodyErrorDetail extends $tea.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * null
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * null
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class KillProcessListResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The client IP address.
   * 
   * @example
   * 127.0.0.1
   */
  clientIp?: string;
  /**
   * @remarks
   * The start command for the container of the application.
   * 
   * @example
   * select 1
   */
  command?: string;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * test
   */
  database?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * Instance not found.
   */
  errorMessage?: string;
  /**
   * @remarks
   * Execution time (UTC+8). If it is left empty, it means to execute immediately.
   * 
   * @example
   * 142
   */
  executeTime?: string;
  /**
   * @remarks
   * The IP address of the server.
   * 
   * @example
   * 127.0.0.1
   */
  serverIp?: string;
  /**
   * @remarks
   * The ID of the session.
   * 
   * @example
   * 1123
   */
  sessionId?: number;
  /**
   * @remarks
   * The SQL statement.
   * 
   * @example
   * :
   */
  sqlText?: string;
  /**
   * @remarks
   * The status of the task.
   * 
   * @example
   * SLEEP
   */
  status?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * @example
   * t3ogqv07a56n4
   */
  tenantId?: string;
  /**
   * @remarks
   * The database username.
   * 
   * @example
   * oas
   */
  user?: string;
  static names(): { [key: string]: string } {
    return {
      clientIp: 'ClientIp',
      command: 'Command',
      database: 'Database',
      errorMessage: 'ErrorMessage',
      executeTime: 'ExecuteTime',
      serverIp: 'ServerIp',
      sessionId: 'SessionId',
      sqlText: 'SqlText',
      status: 'Status',
      tenantId: 'TenantId',
      user: 'User',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clientIp: 'string',
      command: 'string',
      database: 'string',
      errorMessage: 'string',
      executeTime: 'string',
      serverIp: 'string',
      sessionId: 'number',
      sqlText: 'string',
      status: 'string',
      tenantId: 'string',
      user: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAllLabelsResponseBodyData extends $tea.Model {
  /**
   * @example
   * l_4w6r0***
   */
  id?: string;
  /**
   * @example
   * test
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAllLabelsResponseBodyErrorDetail extends $tea.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * Contact the administrator.
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataSourceResponseBodyData extends $tea.Model {
  /**
   * @example
   * utf8mb4
   */
  charset?: string;
  /**
   * @example
   * cluster_name
   */
  cluster?: string;
  /**
   * @example
   * null
   */
  connExtraAttributes?: any;
  /**
   * @example
   * test
   */
  description?: string;
  /**
   * @example
   * 2023-07-13T20:27:28.000+00:00
   */
  gmtCreate?: string;
  /**
   * @example
   * 2023-07-13T20:37:28.000+00:00
   */
  gmtModified?: string;
  /**
   * @example
   * e_4w****v
   */
  id?: string;
  /**
   * @example
   * xxx.xxx.xxx.1
   */
  ip?: string;
  /**
   * @example
   * RATION***1DBUTF11
   */
  name?: string;
  /**
   * @example
   * Linux
   */
  operatingSystem?: string;
  /**
   * @example
   * null
   */
  oracleNlsLengthSemantics?: string;
  /**
   * @example
   * null
   */
  oracleSid?: string;
  /**
   * @example
   * admin
   */
  owner?: string;
  /**
   * @example
   * null
   */
  partnerId?: string;
  /**
   * @example
   * 2883
   */
  port?: number;
  /**
   * @example
   * cn-beijing
   */
  region?: string;
  /**
   * @example
   * 178641****05809
   */
  resourceOwner?: string;
  /**
   * @example
   * MASTER
   */
  role?: string;
  /**
   * @example
   * schema_name
   */
  schema?: string;
  /**
   * @example
   * tenant_name
   */
  tenant?: string;
  /**
   * @example
   * +08:00
   */
  timezone?: string;
  /**
   * @example
   * MYSQL_PUBLIC
   */
  type?: string;
  /**
   * @example
   * user_name
   */
  userName?: string;
  /**
   * @example
   * 4.1.0
   */
  version?: string;
  /**
   * @example
   * vpc_t4***
   */
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      charset: 'Charset',
      cluster: 'Cluster',
      connExtraAttributes: 'ConnExtraAttributes',
      description: 'Description',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      id: 'Id',
      ip: 'Ip',
      name: 'Name',
      operatingSystem: 'OperatingSystem',
      oracleNlsLengthSemantics: 'OracleNlsLengthSemantics',
      oracleSid: 'OracleSid',
      owner: 'Owner',
      partnerId: 'PartnerId',
      port: 'Port',
      region: 'Region',
      resourceOwner: 'ResourceOwner',
      role: 'Role',
      schema: 'Schema',
      tenant: 'Tenant',
      timezone: 'Timezone',
      type: 'Type',
      userName: 'UserName',
      version: 'Version',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      charset: 'string',
      cluster: 'string',
      connExtraAttributes: 'any',
      description: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      id: 'string',
      ip: 'string',
      name: 'string',
      operatingSystem: 'string',
      oracleNlsLengthSemantics: 'string',
      oracleSid: 'string',
      owner: 'string',
      partnerId: 'string',
      port: 'number',
      region: 'string',
      resourceOwner: 'string',
      role: 'string',
      schema: 'string',
      tenant: 'string',
      timezone: 'string',
      type: 'string',
      userName: 'string',
      version: 'string',
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataSourceResponseBodyErrorDetail extends $tea.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * null
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectFullVerifyResultResponseBodyDataFullVerifyTableStatisticsErrorDetails extends $tea.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * null
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * null
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectFullVerifyResultResponseBodyDataFullVerifyTableStatistics extends $tea.Model {
  /**
   * @example
   * 200
   */
  consistentCount?: number;
  /**
   * @example
   * 0
   */
  destOnlyCount?: number;
  /**
   * @example
   * dest_db
   */
  destSchemaName?: string;
  errorDetails?: ListProjectFullVerifyResultResponseBodyDataFullVerifyTableStatisticsErrorDetails[];
  /**
   * @example
   * null
   */
  message?: string;
  /**
   * @example
   * 0
   */
  mismatchedCount?: number;
  /**
   * @example
   * 80
   */
  progress?: string;
  /**
   * @example
   * desc
   */
  resultDesc?: string;
  /**
   * @example
   * RUNNING
   */
  resultType?: string;
  /**
   * @example
   * 0
   */
  sourceOnlyCount?: number;
  /**
   * @example
   * source_db
   */
  sourceSchemaName?: string;
  /**
   * @example
   * source_table
   */
  sourceTableName?: string;
  /**
   * @example
   * RUNNING
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      consistentCount: 'ConsistentCount',
      destOnlyCount: 'DestOnlyCount',
      destSchemaName: 'DestSchemaName',
      errorDetails: 'ErrorDetails',
      message: 'Message',
      mismatchedCount: 'MismatchedCount',
      progress: 'Progress',
      resultDesc: 'ResultDesc',
      resultType: 'ResultType',
      sourceOnlyCount: 'SourceOnlyCount',
      sourceSchemaName: 'SourceSchemaName',
      sourceTableName: 'SourceTableName',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consistentCount: 'number',
      destOnlyCount: 'number',
      destSchemaName: 'string',
      errorDetails: { 'type': 'array', 'itemType': ListProjectFullVerifyResultResponseBodyDataFullVerifyTableStatisticsErrorDetails },
      message: 'string',
      mismatchedCount: 'number',
      progress: 'string',
      resultDesc: 'string',
      resultType: 'string',
      sourceOnlyCount: 'number',
      sourceSchemaName: 'string',
      sourceTableName: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectFullVerifyResultResponseBodyData extends $tea.Model {
  /**
   * @example
   * 11
   */
  differentNumber?: number;
  fullVerifyTableStatistics?: ListProjectFullVerifyResultResponseBodyDataFullVerifyTableStatistics[];
  static names(): { [key: string]: string } {
    return {
      differentNumber: 'DifferentNumber',
      fullVerifyTableStatistics: 'FullVerifyTableStatistics',
    };
  }

  static types(): { [key: string]: any } {
    return {
      differentNumber: 'number',
      fullVerifyTableStatistics: { 'type': 'array', 'itemType': ListProjectFullVerifyResultResponseBodyDataFullVerifyTableStatistics },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectFullVerifyResultResponseBodyErrorDetail extends $tea.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * null
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectModifyRecordsResponseBodyDataDatabasesSpecificTablesAdbTableSchema extends $tea.Model {
  distributedKeys?: string[];
  /**
   * @example
   * 30
   */
  partitionLifeCycle?: number;
  /**
   * @example
   * PARTITION BY VALUE(\\"id\\")
   */
  partitionStatement?: string;
  primaryKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      distributedKeys: 'DistributedKeys',
      partitionLifeCycle: 'PartitionLifeCycle',
      partitionStatement: 'PartitionStatement',
      primaryKeys: 'PrimaryKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      distributedKeys: { 'type': 'array', 'itemType': 'string' },
      partitionLifeCycle: 'number',
      partitionStatement: 'string',
      primaryKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectModifyRecordsResponseBodyDataDatabasesSpecificTablesColumns extends $tea.Model {
  /**
   * @example
   * comments
   */
  columnComment?: string;
  /**
   * @example
   * PRI
   */
  columnKey?: string;
  /**
   * @example
   * col_name
   */
  columnName?: string;
  /**
   * @example
   * FLOAT
   */
  columnType?: string;
  /**
   * @example
   * null
   */
  dataLength?: number;
  /**
   * @example
   * 64
   */
  dataPrecision?: number;
  /**
   * @example
   * null
   */
  dataScale?: number;
  /**
   * @example
   * null
   */
  defaultValue?: string;
  /**
   * @example
   * utf16
   */
  encoding?: string;
  /**
   * @example
   * false
   */
  isGenerateField?: boolean;
  /**
   * @example
   * mapped_name
   */
  mappedName?: string;
  /**
   * @example
   * false
   */
  nullable?: boolean;
  /**
   * @example
   * null
   */
  position?: number;
  /**
   * @example
   * null
   */
  rawColumnType?: string;
  /**
   * @example
   * INT8
   */
  recordFieldType?: string;
  /**
   * @example
   * DATABASE
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      columnComment: 'ColumnComment',
      columnKey: 'ColumnKey',
      columnName: 'ColumnName',
      columnType: 'ColumnType',
      dataLength: 'DataLength',
      dataPrecision: 'DataPrecision',
      dataScale: 'DataScale',
      defaultValue: 'DefaultValue',
      encoding: 'Encoding',
      isGenerateField: 'IsGenerateField',
      mappedName: 'MappedName',
      nullable: 'Nullable',
      position: 'Position',
      rawColumnType: 'RawColumnType',
      recordFieldType: 'RecordFieldType',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnComment: 'string',
      columnKey: 'string',
      columnName: 'string',
      columnType: 'string',
      dataLength: 'number',
      dataPrecision: 'number',
      dataScale: 'number',
      defaultValue: 'string',
      encoding: 'string',
      isGenerateField: 'boolean',
      mappedName: 'string',
      nullable: 'boolean',
      position: 'number',
      rawColumnType: 'string',
      recordFieldType: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectModifyRecordsResponseBodyDataDatabasesSpecificTables extends $tea.Model {
  adbTableSchema?: ListProjectModifyRecordsResponseBodyDataDatabasesSpecificTablesAdbTableSchema;
  columns?: ListProjectModifyRecordsResponseBodyDataDatabasesSpecificTablesColumns[];
  filterColumns?: string[];
  /**
   * @example
   * table_id
   */
  id?: string;
  /**
   * @example
   * mapped_name
   */
  mappedName?: string;
  /**
   * @example
   * table_name
   */
  name?: string;
  shardColumns?: string[];
  /**
   * @example
   * id<3
   */
  whereClause?: string;
  static names(): { [key: string]: string } {
    return {
      adbTableSchema: 'AdbTableSchema',
      columns: 'Columns',
      filterColumns: 'FilterColumns',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      shardColumns: 'ShardColumns',
      whereClause: 'WhereClause',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adbTableSchema: ListProjectModifyRecordsResponseBodyDataDatabasesSpecificTablesAdbTableSchema,
      columns: { 'type': 'array', 'itemType': ListProjectModifyRecordsResponseBodyDataDatabasesSpecificTablesColumns },
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      mappedName: 'string',
      name: 'string',
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      whereClause: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectModifyRecordsResponseBodyDataDatabasesSpecificViewsAdbTableSchema extends $tea.Model {
  distributedKeys?: string[];
  /**
   * @example
   * 30
   */
  partitionLifeCycle?: number;
  /**
   * @example
   * PARTITION BY VALUE(\\"id\\")
   */
  partitionStatement?: string;
  primaryKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      distributedKeys: 'DistributedKeys',
      partitionLifeCycle: 'PartitionLifeCycle',
      partitionStatement: 'PartitionStatement',
      primaryKeys: 'PrimaryKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      distributedKeys: { 'type': 'array', 'itemType': 'string' },
      partitionLifeCycle: 'number',
      partitionStatement: 'string',
      primaryKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectModifyRecordsResponseBodyDataDatabasesSpecificViewsColumns extends $tea.Model {
  /**
   * @example
   * comments
   */
  columnComment?: string;
  /**
   * @example
   * PRI
   */
  columnKey?: string;
  /**
   * @example
   * col_name
   */
  columnName?: string;
  /**
   * @example
   * FLOAT
   */
  columnType?: string;
  /**
   * @example
   * null
   */
  dataLength?: number;
  /**
   * @example
   * 64
   */
  dataPrecision?: number;
  /**
   * @example
   * null
   */
  dataScale?: number;
  /**
   * @example
   * null
   */
  defaultValue?: string;
  /**
   * @example
   * utf16
   */
  encoding?: string;
  /**
   * @example
   * false
   */
  isGenerateField?: boolean;
  /**
   * @example
   * mapped_name
   */
  mappedName?: string;
  /**
   * @example
   * true
   */
  nullable?: boolean;
  /**
   * @example
   * null
   */
  position?: number;
  /**
   * @example
   * null
   */
  rawColumnType?: string;
  /**
   * @example
   * INT8
   */
  recordFieldType?: string;
  /**
   * @example
   * DATABASE
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      columnComment: 'ColumnComment',
      columnKey: 'ColumnKey',
      columnName: 'ColumnName',
      columnType: 'ColumnType',
      dataLength: 'DataLength',
      dataPrecision: 'DataPrecision',
      dataScale: 'DataScale',
      defaultValue: 'DefaultValue',
      encoding: 'Encoding',
      isGenerateField: 'IsGenerateField',
      mappedName: 'MappedName',
      nullable: 'Nullable',
      position: 'Position',
      rawColumnType: 'RawColumnType',
      recordFieldType: 'RecordFieldType',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnComment: 'string',
      columnKey: 'string',
      columnName: 'string',
      columnType: 'string',
      dataLength: 'number',
      dataPrecision: 'number',
      dataScale: 'number',
      defaultValue: 'string',
      encoding: 'string',
      isGenerateField: 'boolean',
      mappedName: 'string',
      nullable: 'boolean',
      position: 'number',
      rawColumnType: 'string',
      recordFieldType: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectModifyRecordsResponseBodyDataDatabasesSpecificViews extends $tea.Model {
  adbTableSchema?: ListProjectModifyRecordsResponseBodyDataDatabasesSpecificViewsAdbTableSchema;
  columns?: ListProjectModifyRecordsResponseBodyDataDatabasesSpecificViewsColumns[];
  filterColumns?: string[];
  /**
   * @example
   * table_id
   */
  id?: string;
  /**
   * @example
   * mapped_name
   */
  mappedName?: string;
  /**
   * @example
   * table_name
   */
  name?: string;
  shardColumns?: string[];
  /**
   * @example
   * id < 1
   */
  whereClause?: string;
  static names(): { [key: string]: string } {
    return {
      adbTableSchema: 'AdbTableSchema',
      columns: 'Columns',
      filterColumns: 'FilterColumns',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      shardColumns: 'ShardColumns',
      whereClause: 'WhereClause',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adbTableSchema: ListProjectModifyRecordsResponseBodyDataDatabasesSpecificViewsAdbTableSchema,
      columns: { 'type': 'array', 'itemType': ListProjectModifyRecordsResponseBodyDataDatabasesSpecificViewsColumns },
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      mappedName: 'string',
      name: 'string',
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      whereClause: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectModifyRecordsResponseBodyDataDatabasesTablesAdbTableSchema extends $tea.Model {
  distributedKeys?: string[];
  /**
   * @example
   * 30
   */
  partitionLifeCycle?: number;
  /**
   * @example
   * PARTITION BY VALUE(\\"id\\")
   */
  partitionStatement?: string;
  primaryKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      distributedKeys: 'DistributedKeys',
      partitionLifeCycle: 'PartitionLifeCycle',
      partitionStatement: 'PartitionStatement',
      primaryKeys: 'PrimaryKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      distributedKeys: { 'type': 'array', 'itemType': 'string' },
      partitionLifeCycle: 'number',
      partitionStatement: 'string',
      primaryKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectModifyRecordsResponseBodyDataDatabasesTablesColumns extends $tea.Model {
  /**
   * @example
   * comments
   */
  columnComment?: string;
  /**
   * @example
   * PRI
   */
  columnKey?: string;
  /**
   * @example
   * col_name
   */
  columnName?: string;
  /**
   * @example
   * FLOAT
   */
  columnType?: string;
  /**
   * @example
   * null
   */
  dataLength?: number;
  /**
   * @example
   * 64
   */
  dataPrecision?: number;
  /**
   * @example
   * null
   */
  dataScale?: number;
  /**
   * @example
   * null
   */
  defaultValue?: string;
  /**
   * @example
   * utf8
   */
  encoding?: string;
  /**
   * @example
   * false
   */
  isGenerateField?: boolean;
  /**
   * @example
   * mapped_col
   */
  mappedName?: string;
  /**
   * @example
   * true
   */
  nullable?: boolean;
  /**
   * @example
   * null
   */
  position?: number;
  /**
   * @example
   * null
   */
  rawColumnType?: string;
  /**
   * @example
   * INT8
   */
  recordFieldType?: string;
  /**
   * @example
   * DATABASE
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      columnComment: 'ColumnComment',
      columnKey: 'ColumnKey',
      columnName: 'ColumnName',
      columnType: 'ColumnType',
      dataLength: 'DataLength',
      dataPrecision: 'DataPrecision',
      dataScale: 'DataScale',
      defaultValue: 'DefaultValue',
      encoding: 'Encoding',
      isGenerateField: 'IsGenerateField',
      mappedName: 'MappedName',
      nullable: 'Nullable',
      position: 'Position',
      rawColumnType: 'RawColumnType',
      recordFieldType: 'RecordFieldType',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnComment: 'string',
      columnKey: 'string',
      columnName: 'string',
      columnType: 'string',
      dataLength: 'number',
      dataPrecision: 'number',
      dataScale: 'number',
      defaultValue: 'string',
      encoding: 'string',
      isGenerateField: 'boolean',
      mappedName: 'string',
      nullable: 'boolean',
      position: 'number',
      rawColumnType: 'string',
      recordFieldType: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectModifyRecordsResponseBodyDataDatabasesTables extends $tea.Model {
  adbTableSchema?: ListProjectModifyRecordsResponseBodyDataDatabasesTablesAdbTableSchema;
  columns?: ListProjectModifyRecordsResponseBodyDataDatabasesTablesColumns[];
  filterColumns?: string[];
  /**
   * @example
   * table_id
   */
  id?: string;
  /**
   * @example
   * mapped_name
   */
  mappedName?: string;
  /**
   * @example
   * table_name
   */
  name?: string;
  shardColumns?: string[];
  /**
   * @example
   * id < 1
   */
  whereClause?: string;
  static names(): { [key: string]: string } {
    return {
      adbTableSchema: 'AdbTableSchema',
      columns: 'Columns',
      filterColumns: 'FilterColumns',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      shardColumns: 'ShardColumns',
      whereClause: 'WhereClause',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adbTableSchema: ListProjectModifyRecordsResponseBodyDataDatabasesTablesAdbTableSchema,
      columns: { 'type': 'array', 'itemType': ListProjectModifyRecordsResponseBodyDataDatabasesTablesColumns },
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      mappedName: 'string',
      name: 'string',
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      whereClause: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectModifyRecordsResponseBodyDataDatabasesViewsAdbTableSchema extends $tea.Model {
  distributedKeys?: string[];
  /**
   * @example
   * 30
   */
  partitionLifeCycle?: number;
  /**
   * @example
   * PARTITION BY VALUE(\\"id\\")
   */
  partitionStatement?: string;
  primaryKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      distributedKeys: 'DistributedKeys',
      partitionLifeCycle: 'PartitionLifeCycle',
      partitionStatement: 'PartitionStatement',
      primaryKeys: 'PrimaryKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      distributedKeys: { 'type': 'array', 'itemType': 'string' },
      partitionLifeCycle: 'number',
      partitionStatement: 'string',
      primaryKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectModifyRecordsResponseBodyDataDatabasesViewsColumns extends $tea.Model {
  /**
   * @example
   * comments
   */
  columnComment?: string;
  /**
   * @example
   * PRI
   */
  columnKey?: string;
  /**
   * @example
   * col_name
   */
  columnName?: string;
  /**
   * @example
   * FLOAT
   */
  columnType?: string;
  /**
   * @example
   * null
   */
  dataLength?: number;
  /**
   * @example
   * 64
   */
  dataPrecision?: number;
  /**
   * @example
   * null
   */
  dataScale?: number;
  /**
   * @example
   * null
   */
  defaultValue?: string;
  /**
   * @example
   * utf16
   */
  encoding?: string;
  /**
   * @example
   * false
   */
  isGenerateField?: boolean;
  /**
   * @example
   * mapped_name
   */
  mappedName?: string;
  /**
   * @example
   * false
   */
  nullable?: boolean;
  /**
   * @example
   * null
   */
  position?: number;
  /**
   * @example
   * null
   */
  rawColumnType?: string;
  /**
   * @example
   * INT8
   */
  recordFieldType?: string;
  /**
   * @example
   * DATABASE
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      columnComment: 'ColumnComment',
      columnKey: 'ColumnKey',
      columnName: 'ColumnName',
      columnType: 'ColumnType',
      dataLength: 'DataLength',
      dataPrecision: 'DataPrecision',
      dataScale: 'DataScale',
      defaultValue: 'DefaultValue',
      encoding: 'Encoding',
      isGenerateField: 'IsGenerateField',
      mappedName: 'MappedName',
      nullable: 'Nullable',
      position: 'Position',
      rawColumnType: 'RawColumnType',
      recordFieldType: 'RecordFieldType',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnComment: 'string',
      columnKey: 'string',
      columnName: 'string',
      columnType: 'string',
      dataLength: 'number',
      dataPrecision: 'number',
      dataScale: 'number',
      defaultValue: 'string',
      encoding: 'string',
      isGenerateField: 'boolean',
      mappedName: 'string',
      nullable: 'boolean',
      position: 'number',
      rawColumnType: 'string',
      recordFieldType: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectModifyRecordsResponseBodyDataDatabasesViews extends $tea.Model {
  adbTableSchema?: ListProjectModifyRecordsResponseBodyDataDatabasesViewsAdbTableSchema;
  columns?: ListProjectModifyRecordsResponseBodyDataDatabasesViewsColumns[];
  filterColumns?: string[];
  /**
   * @example
   * table_id
   */
  id?: string;
  /**
   * @example
   * mapped_view
   */
  mappedName?: string;
  /**
   * @example
   * table_name
   */
  name?: string;
  shardColumns?: string[];
  /**
   * @example
   * id<1
   */
  whereClause?: string;
  static names(): { [key: string]: string } {
    return {
      adbTableSchema: 'AdbTableSchema',
      columns: 'Columns',
      filterColumns: 'FilterColumns',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      shardColumns: 'ShardColumns',
      whereClause: 'WhereClause',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adbTableSchema: ListProjectModifyRecordsResponseBodyDataDatabasesViewsAdbTableSchema,
      columns: { 'type': 'array', 'itemType': ListProjectModifyRecordsResponseBodyDataDatabasesViewsColumns },
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      mappedName: 'string',
      name: 'string',
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      whereClause: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectModifyRecordsResponseBodyDataDatabases extends $tea.Model {
  /**
   * @example
   * db_id
   */
  id?: string;
  /**
   * @example
   * mapped_db
   */
  mappedName?: string;
  /**
   * @example
   * db_name
   */
  name?: string;
  specificTables?: ListProjectModifyRecordsResponseBodyDataDatabasesSpecificTables[];
  specificViews?: ListProjectModifyRecordsResponseBodyDataDatabasesSpecificViews[];
  tables?: ListProjectModifyRecordsResponseBodyDataDatabasesTables[];
  views?: ListProjectModifyRecordsResponseBodyDataDatabasesViews[];
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      specificTables: 'SpecificTables',
      specificViews: 'SpecificViews',
      tables: 'Tables',
      views: 'Views',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      mappedName: 'string',
      name: 'string',
      specificTables: { 'type': 'array', 'itemType': ListProjectModifyRecordsResponseBodyDataDatabasesSpecificTables },
      specificViews: { 'type': 'array', 'itemType': ListProjectModifyRecordsResponseBodyDataDatabasesSpecificViews },
      tables: { 'type': 'array', 'itemType': ListProjectModifyRecordsResponseBodyDataDatabasesTables },
      views: { 'type': 'array', 'itemType': ListProjectModifyRecordsResponseBodyDataDatabasesViews },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectModifyRecordsResponseBodyDataErrorDetail extends $tea.Model {
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * null
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfoTables extends $tea.Model {
  /**
   * @example
   * table_name
   */
  name?: string;
  /**
   * @example
   * schema_name
   */
  schema?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      schema: 'Schema',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      schema: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfoTablesBlack extends $tea.Model {
  /**
   * @example
   * table_name
   */
  name?: string;
  /**
   * @example
   * schema_name
   */
  schema?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      schema: 'Schema',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      schema: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfoViews extends $tea.Model {
  /**
   * @example
   * view_name
   */
  name?: string;
  /**
   * @example
   * schema_name
   */
  schema?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      schema: 'Schema',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      schema: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfoViewsBlack extends $tea.Model {
  /**
   * @example
   * view_name
   */
  name?: string;
  /**
   * @example
   * schema_name
   */
  schema?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      schema: 'Schema',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      schema: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfo extends $tea.Model {
  tables?: ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfoTables[];
  tablesBlack?: ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfoTablesBlack[];
  views?: ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfoViews[];
  viewsBlack?: ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfoViewsBlack[];
  /**
   * @example
   * true
   */
  wildcardMode?: boolean;
  static names(): { [key: string]: string } {
    return {
      tables: 'Tables',
      tablesBlack: 'TablesBlack',
      views: 'Views',
      viewsBlack: 'ViewsBlack',
      wildcardMode: 'WildcardMode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tables: { 'type': 'array', 'itemType': ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfoTables },
      tablesBlack: { 'type': 'array', 'itemType': ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfoTablesBlack },
      views: { 'type': 'array', 'itemType': ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfoViews },
      viewsBlack: { 'type': 'array', 'itemType': ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfoViewsBlack },
      wildcardMode: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfoColumnMappings extends $tea.Model {
  /**
   * @example
   * dest_name
   */
  destName?: string;
  /**
   * @example
   * source_name
   */
  sourceName?: string;
  /**
   * @example
   * source_schema
   */
  sourceSchema?: string;
  /**
   * @example
   * source_table
   */
  sourceTable?: string;
  static names(): { [key: string]: string } {
    return {
      destName: 'DestName',
      sourceName: 'SourceName',
      sourceSchema: 'SourceSchema',
      sourceTable: 'SourceTable',
    };
  }

  static types(): { [key: string]: any } {
    return {
      destName: 'string',
      sourceName: 'string',
      sourceSchema: 'string',
      sourceTable: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfoSchemaMappings extends $tea.Model {
  /**
   * @example
   * mapped_schema
   */
  destName?: string;
  /**
   * @example
   * source_name
   */
  sourceName?: string;
  static names(): { [key: string]: string } {
    return {
      destName: 'DestName',
      sourceName: 'SourceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      destName: 'string',
      sourceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfoTableMappings extends $tea.Model {
  /**
   * @example
   * dest_name
   */
  destName?: string;
  /**
   * @example
   * source_name
   */
  sourceName?: string;
  /**
   * @example
   * source_schema
   */
  sourceSchema?: string;
  static names(): { [key: string]: string } {
    return {
      destName: 'DestName',
      sourceName: 'SourceName',
      sourceSchema: 'SourceSchema',
    };
  }

  static types(): { [key: string]: any } {
    return {
      destName: 'string',
      sourceName: 'string',
      sourceSchema: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfoViewMappings extends $tea.Model {
  /**
   * @example
   * dest_name
   */
  destName?: string;
  /**
   * @example
   * source_name
   */
  sourceName?: string;
  /**
   * @example
   * schema_name
   */
  sourceSchema?: string;
  static names(): { [key: string]: string } {
    return {
      destName: 'DestName',
      sourceName: 'SourceName',
      sourceSchema: 'SourceSchema',
    };
  }

  static types(): { [key: string]: any } {
    return {
      destName: 'string',
      sourceName: 'string',
      sourceSchema: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfo extends $tea.Model {
  columnMappings?: ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfoColumnMappings[];
  schemaMappings?: ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfoSchemaMappings[];
  tableMappings?: ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfoTableMappings[];
  viewMappings?: ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfoViewMappings[];
  static names(): { [key: string]: string } {
    return {
      columnMappings: 'ColumnMappings',
      schemaMappings: 'SchemaMappings',
      tableMappings: 'TableMappings',
      viewMappings: 'ViewMappings',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnMappings: { 'type': 'array', 'itemType': ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfoColumnMappings },
      schemaMappings: { 'type': 'array', 'itemType': ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfoSchemaMappings },
      tableMappings: { 'type': 'array', 'itemType': ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfoTableMappings },
      viewMappings: { 'type': 'array', 'itemType': ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfoViewMappings },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectModifyRecordsResponseBodyDataTableEtlList extends $tea.Model {
  /**
   * @example
   * db_name
   */
  database?: string;
  /**
   * @example
   * dest_db
   */
  destDatabase?: string;
  /**
   * @example
   * dest_name
   */
  destName?: string;
  filterColumns?: string[];
  /**
   * @example
   * null
   */
  logicTableId?: string;
  shardColumns?: string[];
  /**
   * @example
   * null
   */
  sourceEndpointId?: string;
  /**
   * @example
   * table_name
   */
  tableName?: string;
  /**
   * @example
   * tenant_name
   */
  tenantName?: string;
  /**
   * @example
   * id>1
   */
  whereClause?: string;
  static names(): { [key: string]: string } {
    return {
      database: 'Database',
      destDatabase: 'DestDatabase',
      destName: 'DestName',
      filterColumns: 'FilterColumns',
      logicTableId: 'LogicTableId',
      shardColumns: 'ShardColumns',
      sourceEndpointId: 'SourceEndpointId',
      tableName: 'TableName',
      tenantName: 'TenantName',
      whereClause: 'WhereClause',
    };
  }

  static types(): { [key: string]: any } {
    return {
      database: 'string',
      destDatabase: 'string',
      destName: 'string',
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      logicTableId: 'string',
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      sourceEndpointId: 'string',
      tableName: 'string',
      tenantName: 'string',
      whereClause: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectModifyRecordsResponseBodyData extends $tea.Model {
  databases?: ListProjectModifyRecordsResponseBodyDataDatabases[];
  errorDetail?: ListProjectModifyRecordsResponseBodyDataErrorDetail;
  /**
   * @example
   * 2023-07-13T06:26:15
   */
  gmtModified?: string;
  /**
   * @example
   * 344000005
   */
  id?: number;
  /**
   * @example
   * id
   */
  mergeRequestId?: number;
  migrationObjectsInfo?: ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfo;
  omsProjectMappingInfo?: ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfo;
  /**
   * @example
   * PENDING
   */
  status?: string;
  /**
   * @example
   * np_598qm***
   */
  subProjectId?: string;
  tableEtlList?: ListProjectModifyRecordsResponseBodyDataTableEtlList[];
  /**
   * @example
   * INCREASE_OBJECT
   */
  type?: string;
  /**
   * @example
   * id
   */
  updateRequestId?: number;
  static names(): { [key: string]: string } {
    return {
      databases: 'Databases',
      errorDetail: 'ErrorDetail',
      gmtModified: 'GmtModified',
      id: 'Id',
      mergeRequestId: 'MergeRequestId',
      migrationObjectsInfo: 'MigrationObjectsInfo',
      omsProjectMappingInfo: 'OmsProjectMappingInfo',
      status: 'Status',
      subProjectId: 'SubProjectId',
      tableEtlList: 'TableEtlList',
      type: 'Type',
      updateRequestId: 'UpdateRequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      databases: { 'type': 'array', 'itemType': ListProjectModifyRecordsResponseBodyDataDatabases },
      errorDetail: ListProjectModifyRecordsResponseBodyDataErrorDetail,
      gmtModified: 'string',
      id: 'number',
      mergeRequestId: 'number',
      migrationObjectsInfo: ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfo,
      omsProjectMappingInfo: ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfo,
      status: 'string',
      subProjectId: 'string',
      tableEtlList: { 'type': 'array', 'itemType': ListProjectModifyRecordsResponseBodyDataTableEtlList },
      type: 'string',
      updateRequestId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectModifyRecordsResponseBodyErrorDetail extends $tea.Model {
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * Contact the administrator.
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectsResponseBodyDataAlarmStats extends $tea.Model {
  /**
   * @example
   * null
   */
  alarmContent?: string;
  /**
   * @example
   * false
   */
  alarming?: boolean;
  /**
   * @example
   * true
   */
  openMonitor?: boolean;
  /**
   * @example
   * 0
   */
  recentlyTriggerCount?: number;
  ruleToRecentlyTriggerCount?: { [key: string]: number };
  /**
   * @example
   * null
   */
  target?: string;
  static names(): { [key: string]: string } {
    return {
      alarmContent: 'AlarmContent',
      alarming: 'Alarming',
      openMonitor: 'OpenMonitor',
      recentlyTriggerCount: 'RecentlyTriggerCount',
      ruleToRecentlyTriggerCount: 'RuleToRecentlyTriggerCount',
      target: 'Target',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alarmContent: 'string',
      alarming: 'boolean',
      openMonitor: 'boolean',
      recentlyTriggerCount: 'number',
      ruleToRecentlyTriggerCount: { 'type': 'map', 'keyType': 'string', 'valueType': 'number' },
      target: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectsResponseBodyDataCommonTransferConfig extends $tea.Model {
  /**
   * @example
   * false
   */
  activeActive?: boolean;
  /**
   * @example
   * null
   */
  dataWorksBusinessName?: string;
  /**
   * @example
   * TUPLE
   */
  datahubTopicType?: string;
  /**
   * @example
   * 0
   */
  mqPartition?: number;
  /**
   * @example
   * ONE
   */
  mqPartitionMode?: string;
  /**
   * @example
   * DEFAULT
   */
  mqSerializerType?: string;
  /**
   * @example
   * false
   */
  rocketMqEnableMsgTrace?: boolean;
  /**
   * @example
   * default_tag
   */
  rocketMqMsgTags?: string;
  /**
   * @example
   * OMS
   */
  rocketMqProducerGroup?: string;
  /**
   * @example
   * null
   */
  rocketMqSendMsgTimeout?: number;
  /**
   * @example
   * ALL
   */
  tableCategory?: string;
  static names(): { [key: string]: string } {
    return {
      activeActive: 'ActiveActive',
      dataWorksBusinessName: 'DataWorksBusinessName',
      datahubTopicType: 'DatahubTopicType',
      mqPartition: 'MqPartition',
      mqPartitionMode: 'MqPartitionMode',
      mqSerializerType: 'MqSerializerType',
      rocketMqEnableMsgTrace: 'RocketMqEnableMsgTrace',
      rocketMqMsgTags: 'RocketMqMsgTags',
      rocketMqProducerGroup: 'RocketMqProducerGroup',
      rocketMqSendMsgTimeout: 'RocketMqSendMsgTimeout',
      tableCategory: 'TableCategory',
    };
  }

  static types(): { [key: string]: any } {
    return {
      activeActive: 'boolean',
      dataWorksBusinessName: 'string',
      datahubTopicType: 'string',
      mqPartition: 'number',
      mqPartitionMode: 'string',
      mqSerializerType: 'string',
      rocketMqEnableMsgTrace: 'boolean',
      rocketMqMsgTags: 'string',
      rocketMqProducerGroup: 'string',
      rocketMqSendMsgTimeout: 'number',
      tableCategory: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectsResponseBodyDataExtraInfo extends $tea.Model {
  /**
   * @example
   * true
   */
  accessObSource?: boolean;
  /**
   * @example
   * true
   */
  ignoreUnsupportDdl?: boolean;
  /**
   * @example
   * 1689244596
   */
  incrSyncTimestamp?: number;
  /**
   * @example
   * 1689214358
   */
  logServiceStartCheckpoint?: number;
  /**
   * @example
   * -1
   */
  maxConnectorCount?: number;
  /**
   * @example
   * true
   */
  monitoringIncr?: boolean;
  /**
   * @example
   * true
   */
  overwriteConfig?: boolean;
  reverseSubtopics?: string[];
  /**
   * @example
   * 90
   */
  runningProgress?: number;
  /**
   * @example
   * TRANSFER_PRECHECK
   */
  runningStep?: string;
  /**
   * @example
   * 24
   */
  sourceStoreKeptHour?: number;
  /**
   * @example
   * true
   */
  storeIncr?: boolean;
  subConds?: { [key: string]: DataExtraInfoSubCondsValue[] };
  subDbs?: { [key: string]: DataExtraInfoSubDbsValue[] };
  subIds?: { [key: string]: string };
  subtopics?: string[];
  /**
   * @example
   * null
   */
  syncDelay?: number;
  /**
   * @example
   * 1689214358
   */
  syncDelaySampleTimestamp?: number;
  static names(): { [key: string]: string } {
    return {
      accessObSource: 'AccessObSource',
      ignoreUnsupportDdl: 'IgnoreUnsupportDdl',
      incrSyncTimestamp: 'IncrSyncTimestamp',
      logServiceStartCheckpoint: 'LogServiceStartCheckpoint',
      maxConnectorCount: 'MaxConnectorCount',
      monitoringIncr: 'MonitoringIncr',
      overwriteConfig: 'OverwriteConfig',
      reverseSubtopics: 'ReverseSubtopics',
      runningProgress: 'RunningProgress',
      runningStep: 'RunningStep',
      sourceStoreKeptHour: 'SourceStoreKeptHour',
      storeIncr: 'StoreIncr',
      subConds: 'SubConds',
      subDbs: 'SubDbs',
      subIds: 'SubIds',
      subtopics: 'Subtopics',
      syncDelay: 'SyncDelay',
      syncDelaySampleTimestamp: 'SyncDelaySampleTimestamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessObSource: 'boolean',
      ignoreUnsupportDdl: 'boolean',
      incrSyncTimestamp: 'number',
      logServiceStartCheckpoint: 'number',
      maxConnectorCount: 'number',
      monitoringIncr: 'boolean',
      overwriteConfig: 'boolean',
      reverseSubtopics: { 'type': 'array', 'itemType': 'string' },
      runningProgress: 'number',
      runningStep: 'string',
      sourceStoreKeptHour: 'number',
      storeIncr: 'boolean',
      subConds: { 'type': 'map', 'keyType': 'string', 'valueType': { 'type': 'array', 'itemType': DataExtraInfoSubCondsValue } },
      subDbs: { 'type': 'map', 'keyType': 'string', 'valueType': { 'type': 'array', 'itemType': DataExtraInfoSubDbsValue } },
      subIds: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      subtopics: { 'type': 'array', 'itemType': 'string' },
      syncDelay: 'number',
      syncDelaySampleTimestamp: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectsResponseBodyDataFullTransferConfig extends $tea.Model {
  /**
   * @example
   * false
   */
  allowDestTableNotEmpty?: boolean;
  /**
   * @example
   * NORMAL
   */
  fullTransferSpeedMode?: string;
  /**
   * @example
   * NORMAL
   */
  fullVerifySpeedMode?: string;
  /**
   * @example
   * false
   */
  nonePkUkTruncateDstTable?: boolean;
  static names(): { [key: string]: string } {
    return {
      allowDestTableNotEmpty: 'AllowDestTableNotEmpty',
      fullTransferSpeedMode: 'FullTransferSpeedMode',
      fullVerifySpeedMode: 'FullVerifySpeedMode',
      nonePkUkTruncateDstTable: 'NonePkUkTruncateDstTable',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allowDestTableNotEmpty: 'boolean',
      fullTransferSpeedMode: 'string',
      fullVerifySpeedMode: 'string',
      nonePkUkTruncateDstTable: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectsResponseBodyDataIncrTransferConfig extends $tea.Model {
  /**
   * @example
   * true
   */
  enableIncrSyncStatistics?: boolean;
  /**
   * @example
   * true
   */
  enableSequencingWithinTxn?: boolean;
  /**
   * @example
   * 64
   */
  incrSyncConcurrency?: number;
  recordTypeWhiteList?: string[];
  /**
   * @example
   * 1681004708
   */
  startTimestamp?: number;
  /**
   * @example
   * 24
   */
  storeLogKeptHour?: number;
  static names(): { [key: string]: string } {
    return {
      enableIncrSyncStatistics: 'EnableIncrSyncStatistics',
      enableSequencingWithinTxn: 'EnableSequencingWithinTxn',
      incrSyncConcurrency: 'IncrSyncConcurrency',
      recordTypeWhiteList: 'RecordTypeWhiteList',
      startTimestamp: 'StartTimestamp',
      storeLogKeptHour: 'StoreLogKeptHour',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enableIncrSyncStatistics: 'boolean',
      enableSequencingWithinTxn: 'boolean',
      incrSyncConcurrency: 'number',
      recordTypeWhiteList: { 'type': 'array', 'itemType': 'string' },
      startTimestamp: 'number',
      storeLogKeptHour: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectsResponseBodyDataLabels extends $tea.Model {
  /**
   * @example
   * 2
   */
  count?: number;
  /**
   * @example
   * admin
   */
  creator?: string;
  /**
   * @example
   * l_dfe****
   */
  id?: string;
  /**
   * @example
   * label_name
   */
  name?: string;
  /**
   * @example
   * 1
   */
  type?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      creator: 'Creator',
      id: 'Id',
      name: 'Name',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      creator: 'string',
      id: 'string',
      name: 'string',
      type: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectsResponseBodyDataSinkConnectInfo extends $tea.Model {
  /**
   * @example
   * utf8mb4
   */
  charset?: string;
  /**
   * @example
   * null
   */
  connExtraAttributes?: any;
  /**
   * @example
   * null
   */
  connectionInfo?: string;
  /**
   * @example
   * MYSQL_PUBLIC
   */
  dbEngine?: string;
  /**
   * @example
   * e_4w3aic***
   */
  endpointId?: string;
  /**
   * @example
   * ation129***9apimysql5616****
   */
  endpointName?: string;
  /**
   * @example
   * sink
   */
  endpointSide?: string;
  /**
   * @example
   * xxx.xxx.xxx.1
   */
  host?: string;
  /**
   * @example
   * c_4w3akx***
   */
  id?: string;
  /**
   * @example
   * null
   */
  nlsLengthSemantics?: string;
  /**
   * @example
   * null
   */
  ocpName?: string;
  /**
   * @example
   * Linux
   */
  operatingSystem?: string;
  /**
   * @remarks
   * Owner。
   * 
   * @example
   * admin
   */
  owner?: string;
  /**
   * @example
   * 2883
   */
  port?: number;
  /**
   * @example
   * cn-hangzhou
   */
  region?: string;
  /**
   * @example
   * 1325847***
   */
  resourceOwner?: string;
  /**
   * @example
   * +08:00
   */
  timezone?: string;
  /**
   * @example
   * oms**obmys**
   */
  username?: string;
  /**
   * @example
   * 2.2.77
   */
  version?: string;
  static names(): { [key: string]: string } {
    return {
      charset: 'Charset',
      connExtraAttributes: 'ConnExtraAttributes',
      connectionInfo: 'ConnectionInfo',
      dbEngine: 'DbEngine',
      endpointId: 'EndpointId',
      endpointName: 'EndpointName',
      endpointSide: 'EndpointSide',
      host: 'Host',
      id: 'Id',
      nlsLengthSemantics: 'NlsLengthSemantics',
      ocpName: 'OcpName',
      operatingSystem: 'OperatingSystem',
      owner: 'Owner',
      port: 'Port',
      region: 'Region',
      resourceOwner: 'ResourceOwner',
      timezone: 'Timezone',
      username: 'Username',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      charset: 'string',
      connExtraAttributes: 'any',
      connectionInfo: 'string',
      dbEngine: 'string',
      endpointId: 'string',
      endpointName: 'string',
      endpointSide: 'string',
      host: 'string',
      id: 'string',
      nlsLengthSemantics: 'string',
      ocpName: 'string',
      operatingSystem: 'string',
      owner: 'string',
      port: 'number',
      region: 'string',
      resourceOwner: 'string',
      timezone: 'string',
      username: 'string',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectsResponseBodyDataSourceConnectInfo extends $tea.Model {
  /**
   * @example
   * utf8mb4
   */
  charset?: string;
  /**
   * @example
   * null
   */
  connExtraAttributes?: any;
  /**
   * @example
   * null
   */
  connectionInfo?: string;
  /**
   * @example
   * OB_MYSQL_PUBLIC
   */
  dbEngine?: string;
  /**
   * @example
   * e_4w3al***
   */
  endpointId?: string;
  /**
   * @example
   * ration12****0obmysql4116892***
   */
  endpointName?: string;
  /**
   * @example
   * source
   */
  endpointSide?: string;
  /**
   * @example
   * xxx.xxx.xxx.1
   */
  host?: string;
  /**
   * @example
   * c_4w3aq****
   */
  id?: string;
  /**
   * @example
   * null
   */
  nlsLengthSemantics?: string;
  /**
   * @example
   * null
   */
  ocpName?: string;
  /**
   * @example
   * Linux
   */
  operatingSystem?: string;
  /**
   * @remarks
   * Owner。
   * 
   * @example
   * admin
   */
  owner?: string;
  /**
   * @example
   * 2883
   */
  port?: number;
  /**
   * @example
   * cn-hangzhou
   */
  region?: string;
  /**
   * @example
   * 1325847***
   */
  resourceOwner?: string;
  /**
   * @example
   * UTC
   */
  timezone?: string;
  /**
   * @example
   * oms931mys**
   */
  username?: string;
  /**
   * @example
   * 5.7.27
   */
  version?: string;
  static names(): { [key: string]: string } {
    return {
      charset: 'Charset',
      connExtraAttributes: 'ConnExtraAttributes',
      connectionInfo: 'ConnectionInfo',
      dbEngine: 'DbEngine',
      endpointId: 'EndpointId',
      endpointName: 'EndpointName',
      endpointSide: 'EndpointSide',
      host: 'Host',
      id: 'Id',
      nlsLengthSemantics: 'NlsLengthSemantics',
      ocpName: 'OcpName',
      operatingSystem: 'OperatingSystem',
      owner: 'Owner',
      port: 'Port',
      region: 'Region',
      resourceOwner: 'ResourceOwner',
      timezone: 'Timezone',
      username: 'Username',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      charset: 'string',
      connExtraAttributes: 'any',
      connectionInfo: 'string',
      dbEngine: 'string',
      endpointId: 'string',
      endpointName: 'string',
      endpointSide: 'string',
      host: 'string',
      id: 'string',
      nlsLengthSemantics: 'string',
      ocpName: 'string',
      operatingSystem: 'string',
      owner: 'string',
      port: 'number',
      region: 'string',
      resourceOwner: 'string',
      timezone: 'string',
      username: 'string',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectsResponseBodyDataStepsExtraInfoErrorDetails extends $tea.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * Contact the administrator.
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectsResponseBodyDataStepsExtraInfo extends $tea.Model {
  /**
   * @example
   * INNER_ERROR
   */
  errorCode?: string;
  errorDetails?: ListProjectsResponseBodyDataStepsExtraInfoErrorDetails[];
  /**
   * @example
   * A system error occurred.
   */
  errorMsg?: string;
  errorParam?: { [key: string]: string };
  /**
   * @example
   * null
   */
  failedTime?: string;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorDetails: 'ErrorDetails',
      errorMsg: 'ErrorMsg',
      errorParam: 'ErrorParam',
      failedTime: 'FailedTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorDetails: { 'type': 'array', 'itemType': ListProjectsResponseBodyDataStepsExtraInfoErrorDetails },
      errorMsg: 'string',
      errorParam: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      failedTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectsResponseBodyDataSteps extends $tea.Model {
  description?: string;
  extraInfo?: ListProjectsResponseBodyDataStepsExtraInfo;
  /**
   * @example
   * 2020-05-22T17:05:18
   */
  finishTime?: string;
  /**
   * @example
   * TRANSFER_PRECHECK
   */
  name?: string;
  /**
   * @example
   * 1
   */
  order?: number;
  /**
   * @example
   * 100
   */
  progress?: number;
  /**
   * @example
   * 2020-05-22T17:04:18
   */
  startTime?: string;
  /**
   * @example
   * RUNNING
   */
  status?: string;
  /**
   * @example
   * null
   */
  stepInfo?: { [key: string]: any };
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      extraInfo: 'ExtraInfo',
      finishTime: 'FinishTime',
      name: 'Name',
      order: 'Order',
      progress: 'Progress',
      startTime: 'StartTime',
      status: 'Status',
      stepInfo: 'StepInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      extraInfo: ListProjectsResponseBodyDataStepsExtraInfo,
      finishTime: 'string',
      name: 'string',
      order: 'number',
      progress: 'number',
      startTime: 'string',
      status: 'string',
      stepInfo: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectsResponseBodyDataStructTransferConfig extends $tea.Model {
  /**
   * @example
   * DO_NOTHING_IF_BYTE_USED
   */
  byteCharConvertStrategy?: string;
  /**
   * @example
   * false
   */
  deferIndexCreation?: boolean;
  static names(): { [key: string]: string } {
    return {
      byteCharConvertStrategy: 'ByteCharConvertStrategy',
      deferIndexCreation: 'DeferIndexCreation',
    };
  }

  static types(): { [key: string]: any } {
    return {
      byteCharConvertStrategy: 'string',
      deferIndexCreation: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectsResponseBodyDataTransferMapping extends $tea.Model {
  /**
   * @example
   * SPECIFIC
   */
  mode?: string;
  static names(): { [key: string]: string } {
    return {
      mode: 'Mode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      mode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectsResponseBodyDataWorkerGradeInfo extends $tea.Model {
  autoRenewal?: boolean;
  chargeType?: string;
  destRegion?: string;
  destType?: string;
  endTime?: string;
  expired?: boolean;
  gmtCreate?: string;
  grade?: string;
  id?: string;
  name?: string;
  sourceRegion?: string;
  sourceType?: string;
  spec?: string;
  specName?: string;
  static names(): { [key: string]: string } {
    return {
      autoRenewal: 'AutoRenewal',
      chargeType: 'ChargeType',
      destRegion: 'DestRegion',
      destType: 'DestType',
      endTime: 'EndTime',
      expired: 'Expired',
      gmtCreate: 'GmtCreate',
      grade: 'Grade',
      id: 'Id',
      name: 'Name',
      sourceRegion: 'SourceRegion',
      sourceType: 'SourceType',
      spec: 'Spec',
      specName: 'SpecName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoRenewal: 'boolean',
      chargeType: 'string',
      destRegion: 'string',
      destType: 'string',
      endTime: 'string',
      expired: 'boolean',
      gmtCreate: 'string',
      grade: 'string',
      id: 'string',
      name: 'string',
      sourceRegion: 'string',
      sourceType: 'string',
      spec: 'string',
      specName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectsResponseBodyData extends $tea.Model {
  alarmStats?: ListProjectsResponseBodyDataAlarmStats;
  commonTransferConfig?: ListProjectsResponseBodyDataCommonTransferConfig;
  /**
   * @example
   * null
   */
  destConnId?: string;
  /**
   * @example
   * true
   */
  enableFullTransfer?: boolean;
  /**
   * @example
   * true
   */
  enableFullVerify?: boolean;
  /**
   * @example
   * true
   */
  enableIncrTransfer?: boolean;
  /**
   * @example
   * true
   */
  enableIncrVerify?: boolean;
  /**
   * @example
   * true
   */
  enableReverseIncrTransfer?: boolean;
  /**
   * @example
   * true
   */
  enableStructTransfer?: boolean;
  extraInfo?: ListProjectsResponseBodyDataExtraInfo;
  fullTransferConfig?: ListProjectsResponseBodyDataFullTransferConfig;
  /**
   * @example
   * 2023-07-13T06:26:15
   */
  gmtCreate?: string;
  /**
   * @example
   * 2023-07-13T08:01:27
   */
  gmtFinish?: string;
  /**
   * @example
   * 2023-07-13T07:01:27
   */
  gmtModified?: string;
  /**
   * @example
   * 2023-07-13T07:02:27
   */
  gmtStart?: string;
  /**
   * @example
   * np_4w****
   */
  id?: string;
  /**
   * @example
   * MEDIUM
   */
  importance?: string;
  incrTransferConfig?: ListProjectsResponseBodyDataIncrTransferConfig;
  /**
   * @example
   * false
   */
  isMerging?: boolean;
  /**
   * @example
   * false
   */
  isModifying?: boolean;
  /**
   * @example
   * false
   */
  isSubProject?: boolean;
  labels?: ListProjectsResponseBodyDataLabels[];
  /**
   * @example
   * project_name
   */
  name?: string;
  /**
   * @example
   * admin
   */
  owner?: string;
  sinkConnectInfo?: ListProjectsResponseBodyDataSinkConnectInfo;
  /**
   * @example
   * OB_MYSQL
   */
  sinkEndpointType?: string;
  sourceConnectInfo?: ListProjectsResponseBodyDataSourceConnectInfo;
  /**
   * @example
   * MYSQL
   */
  sourceEndpointType?: string;
  /**
   * @example
   * RUNNING
   */
  status?: string;
  steps?: ListProjectsResponseBodyDataSteps[];
  structTransferConfig?: ListProjectsResponseBodyDataStructTransferConfig;
  transferMapping?: ListProjectsResponseBodyDataTransferMapping;
  /**
   * @example
   * MIGRATION
   */
  type?: string;
  /**
   * @example
   * g_i4wa7XXX
   */
  workerGradeId?: string;
  workerGradeInfo?: ListProjectsResponseBodyDataWorkerGradeInfo;
  static names(): { [key: string]: string } {
    return {
      alarmStats: 'AlarmStats',
      commonTransferConfig: 'CommonTransferConfig',
      destConnId: 'DestConnId',
      enableFullTransfer: 'EnableFullTransfer',
      enableFullVerify: 'EnableFullVerify',
      enableIncrTransfer: 'EnableIncrTransfer',
      enableIncrVerify: 'EnableIncrVerify',
      enableReverseIncrTransfer: 'EnableReverseIncrTransfer',
      enableStructTransfer: 'EnableStructTransfer',
      extraInfo: 'ExtraInfo',
      fullTransferConfig: 'FullTransferConfig',
      gmtCreate: 'GmtCreate',
      gmtFinish: 'GmtFinish',
      gmtModified: 'GmtModified',
      gmtStart: 'GmtStart',
      id: 'Id',
      importance: 'Importance',
      incrTransferConfig: 'IncrTransferConfig',
      isMerging: 'IsMerging',
      isModifying: 'IsModifying',
      isSubProject: 'IsSubProject',
      labels: 'Labels',
      name: 'Name',
      owner: 'Owner',
      sinkConnectInfo: 'SinkConnectInfo',
      sinkEndpointType: 'SinkEndpointType',
      sourceConnectInfo: 'SourceConnectInfo',
      sourceEndpointType: 'SourceEndpointType',
      status: 'Status',
      steps: 'Steps',
      structTransferConfig: 'StructTransferConfig',
      transferMapping: 'TransferMapping',
      type: 'Type',
      workerGradeId: 'WorkerGradeId',
      workerGradeInfo: 'WorkerGradeInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alarmStats: ListProjectsResponseBodyDataAlarmStats,
      commonTransferConfig: ListProjectsResponseBodyDataCommonTransferConfig,
      destConnId: 'string',
      enableFullTransfer: 'boolean',
      enableFullVerify: 'boolean',
      enableIncrTransfer: 'boolean',
      enableIncrVerify: 'boolean',
      enableReverseIncrTransfer: 'boolean',
      enableStructTransfer: 'boolean',
      extraInfo: ListProjectsResponseBodyDataExtraInfo,
      fullTransferConfig: ListProjectsResponseBodyDataFullTransferConfig,
      gmtCreate: 'string',
      gmtFinish: 'string',
      gmtModified: 'string',
      gmtStart: 'string',
      id: 'string',
      importance: 'string',
      incrTransferConfig: ListProjectsResponseBodyDataIncrTransferConfig,
      isMerging: 'boolean',
      isModifying: 'boolean',
      isSubProject: 'boolean',
      labels: { 'type': 'array', 'itemType': ListProjectsResponseBodyDataLabels },
      name: 'string',
      owner: 'string',
      sinkConnectInfo: ListProjectsResponseBodyDataSinkConnectInfo,
      sinkEndpointType: 'string',
      sourceConnectInfo: ListProjectsResponseBodyDataSourceConnectInfo,
      sourceEndpointType: 'string',
      status: 'string',
      steps: { 'type': 'array', 'itemType': ListProjectsResponseBodyDataSteps },
      structTransferConfig: ListProjectsResponseBodyDataStructTransferConfig,
      transferMapping: ListProjectsResponseBodyDataTransferMapping,
      type: 'string',
      workerGradeId: 'string',
      workerGradeInfo: ListProjectsResponseBodyDataWorkerGradeInfo,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectsResponseBodyErrorDetail extends $tea.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * Contact the administrator.
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkerInstancesResponseBodyData extends $tea.Model {
  /**
   * @example
   * 2023-07-14T20:49:53
   */
  gmtCreate?: string;
  /**
   * @example
   * g_i4katzv***
   */
  id?: string;
  /**
   * @example
   * i4wa71k****
   */
  name?: string;
  /**
   * @example
   * np_4kb18w****
   */
  projectId?: string;
  /**
   * @example
   * j_migration_cloud-kafkavpc-ob
   */
  projectName?: string;
  /**
   * @example
   * MIGRATION
   */
  projectType?: string;
  /**
   * @example
   * null
   */
  region?: string;
  /**
   * @example
   * oms.g2m.small
   */
  spec?: string;
  /**
   * @example
   * ONLINE
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      gmtCreate: 'GmtCreate',
      id: 'Id',
      name: 'Name',
      projectId: 'ProjectId',
      projectName: 'ProjectName',
      projectType: 'ProjectType',
      region: 'Region',
      spec: 'Spec',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gmtCreate: 'string',
      id: 'string',
      name: 'string',
      projectId: 'string',
      projectName: 'string',
      projectType: 'string',
      region: 'string',
      spec: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkerInstancesResponseBodyErrorDetail extends $tea.Model {
  /**
   * @example
   * 200
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * FATAL
   */
  level?: string;
  /**
   * @example
   * successful
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * null
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDatabaseUserRolesResponseBodyTenantUserUsers extends $tea.Model {
  /**
   * @example
   * ReadOnly
   */
  role?: string;
  /**
   * @example
   * user_pay_ro
   */
  userName?: string;
  static names(): { [key: string]: string } {
    return {
      role: 'Role',
      userName: 'UserName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      role: 'string',
      userName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDatabaseUserRolesResponseBodyTenantUser extends $tea.Model {
  /**
   * @remarks
   * Example 1
   * 
   * @example
   * sms_pre
   */
  databaseName?: string;
  /**
   * @example
   * t33h8y08k****
   */
  tenantId?: string;
  users?: ModifyDatabaseUserRolesResponseBodyTenantUserUsers[];
  static names(): { [key: string]: string } {
    return {
      databaseName: 'DatabaseName',
      tenantId: 'TenantId',
      users: 'Users',
    };
  }

  static types(): { [key: string]: any } {
    return {
      databaseName: 'string',
      tenantId: 'string',
      users: { 'type': 'array', 'itemType': ModifyDatabaseUserRolesResponseBodyTenantUserUsers },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceNodeNumResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The result of the dry-run request.
   * - If the DryRun parameter is set to true and the dry run succeeds, the DryRunResult parameter returns true. Otherwise, an error code is returned.
   * - If the DryRun parameter is set to false, no dry run is performed and the DryRunResult parameter returns false.
   * 
   * @example
   * false
   */
  dryRunResult?: boolean;
  /**
   * @remarks
   * The ID of the order.
   * 
   * @example
   * 2132903*********
   */
  orderId?: string;
  static names(): { [key: string]: string } {
    return {
      dryRunResult: 'DryRunResult',
      orderId: 'OrderId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dryRunResult: 'boolean',
      orderId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceSSLResponseBodyInstanceSSL extends $tea.Model {
  /**
   * @remarks
   * The operation to modify the SSL status. Valid values:
   * 
   * - open: Enable SSL encryption.
   * 
   * - update: Update the CA certificate.
   * 
   * - close: Disable SSL encryption.
   * 
   * @example
   * open
   */
  enableSSL?: string;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      enableSSL: 'EnableSSL',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enableSSL: 'string',
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceSpecResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The result of the dry-run request.
   * - If the DryRun parameter is set to true and the dry run succeeds, the DryRunResult parameter returns true. Otherwise, an error code is returned.
   * - If the DryRun parameter is set to false, no dry run is performed and the DryRunResult parameter returns false.
   * 
   * @example
   * false
   */
  dryRunResult?: boolean;
  /**
   * @remarks
   * The ID of the order that you have placed.
   * 
   * @example
   * 213290*********
   */
  orderId?: string;
  static names(): { [key: string]: string } {
    return {
      dryRunResult: 'DryRunResult',
      orderId: 'OrderId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dryRunResult: 'boolean',
      orderId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyParametersResponseBodyResults extends $tea.Model {
  /**
   * @example
   * schedule timeout.
   */
  message?: string;
  /**
   * @example
   * false
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      message: 'Message',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      message: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifySecurityIpsResponseBodySecurityIpGroup extends $tea.Model {
  /**
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @example
   * online_paycore
   */
  securityIpGroupName?: string;
  /**
   * @example
   * 121.41.106.33,100.104.7.0/26
   */
  securityIps?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      securityIpGroupName: 'SecurityIpGroupName',
      securityIps: 'SecurityIps',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      securityIpGroupName: 'string',
      securityIps: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantEncryptionResponseBodyTenantEncryption extends $tea.Model {
  /**
   * @example
   * EncryptionKey
   */
  encryptionType?: string;
  /**
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @example
   * ob2mr3oae0****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      encryptionType: 'EncryptionType',
      instanceId: 'InstanceId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      encryptionType: 'string',
      instanceId: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantSecurityIpGroupResponseBodySecurityIpGroup extends $tea.Model {
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The name of the whitelist group.
   * 
   * @example
   * paytest
   */
  securityIpGroupName?: string;
  /**
   * @remarks
   * The list of IP addresses in the IP address whitelist group.
   * 
   * It is a string separated by commas, and each object is an IP address or a CIDR block.
   * 
   * @example
   * 192.***.*.*
   */
  securityIps?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * @example
   * t4louaeei****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      securityIpGroupName: 'SecurityIpGroupName',
      securityIps: 'SecurityIps',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      securityIpGroupName: 'string',
      securityIps: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantUserRolesResponseBodyTenantUserUserRole extends $tea.Model {
  /**
   * @remarks
   * ```
   * http(s)://[Endpoint]/?Action=ModifyTenantUserRoles
   * &UserName=pay_test
   * &TenantId=ob2mr3oae0****
   * &UserRole=[{"Database":"20210824160559","Role":"readwrite"}]
   * &InstanceId=ob317v4uif****
   * &ModifyType=update
   * &Common request parameters
   * ```
   * 
   * @example
   * db_pay1
   */
  database?: string;
  /**
   * @example
   * true
   */
  isSuccess?: boolean;
  /**
   * @remarks
   * You can call this operation to modify the database privileges of a specified account in a tenant.
   * 
   * @example
   * ReadOnly
   */
  role?: string;
  /**
   * @example
   * tbl_pay1
   */
  table?: string;
  static names(): { [key: string]: string } {
    return {
      database: 'Database',
      isSuccess: 'IsSuccess',
      role: 'Role',
      table: 'Table',
    };
  }

  static types(): { [key: string]: any } {
    return {
      database: 'string',
      isSuccess: 'boolean',
      role: 'string',
      table: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantUserRolesResponseBodyTenantUser extends $tea.Model {
  /**
   * @example
   * t33h8y08k****
   */
  tenantId?: string;
  /**
   * @example
   * pay_test
   */
  userName?: string;
  /**
   * @remarks
   * The name of the database (MySQL mode) or schema (Oracle mode).
   * 
   * @example
   * 账号具备的数据库权限信息列表。
   */
  userRole?: ModifyTenantUserRolesResponseBodyTenantUserUserRole[];
  static names(): { [key: string]: string } {
    return {
      tenantId: 'TenantId',
      userName: 'UserName',
      userRole: 'UserRole',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
      userName: 'string',
      userRole: { 'type': 'array', 'itemType': ModifyTenantUserRolesResponseBodyTenantUserUserRole },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantUserStatusResponseBodyTenantUser extends $tea.Model {
  /**
   * @example
   * t33h8y08k****
   */
  tenantId?: string;
  /**
   * @example
   * pay_test
   */
  userName?: string;
  /**
   * @example
   * LOCKED
   */
  userStatus?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'TenantId',
      userName: 'UserName',
      userStatus: 'UserStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
      userName: 'string',
      userStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleaseProjectResponseBodyErrorDetail extends $tea.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * Contact the administrator.
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleaseWorkerInstanceResponseBodyErrorDetail extends $tea.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * Contact the administrator.
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResumeProjectResponseBodyErrorDetail extends $tea.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * Contact the administrator.
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RetryProjectModifyRecordsResponseBodyErrorDetail extends $tea.Model {
  /**
   * @example
   * 200
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * Contact the administrator.
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartProjectResponseBodyErrorDetail extends $tea.Model {
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * Contact the administrator.
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartProjectsByLabelResponseBodyData extends $tea.Model {
  failedProjectIds?: string[];
  succeedProjectIds?: string[];
  /**
   * @example
   * 20
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      failedProjectIds: 'FailedProjectIds',
      succeedProjectIds: 'SucceedProjectIds',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failedProjectIds: { 'type': 'array', 'itemType': 'string' },
      succeedProjectIds: { 'type': 'array', 'itemType': 'string' },
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartProjectsByLabelResponseBodyErrorDetail extends $tea.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * null
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopProjectResponseBodyErrorDetail extends $tea.Model {
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * Contact the administrator.
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopProjectModifyRecordsResponseBodyErrorDetail extends $tea.Model {
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * Contact the administrator.
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopProjectsByLabelResponseBodyData extends $tea.Model {
  failedProjectIds?: string[];
  succeedProjectIds?: string[];
  /**
   * @example
   * 16
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      failedProjectIds: 'FailedProjectIds',
      succeedProjectIds: 'SucceedProjectIds',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failedProjectIds: { 'type': 'array', 'itemType': 'string' },
      succeedProjectIds: { 'type': 'array', 'itemType': 'string' },
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopProjectsByLabelResponseBodyErrorDetail extends $tea.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * Contact the administrator.
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SwitchoverInstanceResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The message of the switchover.
   * 
   * @example
   * delete tag-value success
   */
  message?: string;
  /**
   * @remarks
   * Whether the switchover is successful.
   * - true: the switchover succeeded.
   * - false: the switchover failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      message: 'Message',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      message: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProjectConfigRequestCommonTransferConfig extends $tea.Model {
  sinkStoreFormat?: string;
  sourceStoreFormat?: string;
  static names(): { [key: string]: string } {
    return {
      sinkStoreFormat: 'SinkStoreFormat',
      sourceStoreFormat: 'SourceStoreFormat',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sinkStoreFormat: 'string',
      sourceStoreFormat: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProjectConfigRequestFullTransferConfig extends $tea.Model {
  /**
   * @example
   * 64
   */
  readWorkerNum?: number;
  /**
   * @example
   * null
   */
  throttleIOPS?: number;
  /**
   * @example
   * null
   */
  throttleRps?: number;
  /**
   * @example
   * 64
   */
  writeWorkerNum?: number;
  static names(): { [key: string]: string } {
    return {
      readWorkerNum: 'ReadWorkerNum',
      throttleIOPS: 'ThrottleIOPS',
      throttleRps: 'ThrottleRps',
      writeWorkerNum: 'WriteWorkerNum',
    };
  }

  static types(): { [key: string]: any } {
    return {
      readWorkerNum: 'number',
      throttleIOPS: 'number',
      throttleRps: 'number',
      writeWorkerNum: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProjectConfigRequestIncrTransferConfig extends $tea.Model {
  /**
   * @example
   * 64
   */
  incrSyncThreadCount?: number;
  recordTypeWhiteList?: string[];
  supportDDLTypes?: string[];
  /**
   * @example
   * null
   */
  throttleIOPS?: number;
  /**
   * @example
   * null
   */
  throttleRps?: number;
  static names(): { [key: string]: string } {
    return {
      incrSyncThreadCount: 'IncrSyncThreadCount',
      recordTypeWhiteList: 'RecordTypeWhiteList',
      supportDDLTypes: 'SupportDDLTypes',
      throttleIOPS: 'ThrottleIOPS',
      throttleRps: 'ThrottleRps',
    };
  }

  static types(): { [key: string]: any } {
    return {
      incrSyncThreadCount: 'number',
      recordTypeWhiteList: { 'type': 'array', 'itemType': 'string' },
      supportDDLTypes: { 'type': 'array', 'itemType': 'string' },
      throttleIOPS: 'number',
      throttleRps: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProjectConfigRequestReverseIncrTransferConfig extends $tea.Model {
  /**
   * @example
   * 64
   */
  incrSyncThreadCount?: number;
  recordTypeWhiteList?: string[];
  supportDDLTypes?: string[];
  /**
   * @example
   * null
   */
  throttleIOPS?: number;
  /**
   * @example
   * null
   */
  throttleRps?: number;
  static names(): { [key: string]: string } {
    return {
      incrSyncThreadCount: 'IncrSyncThreadCount',
      recordTypeWhiteList: 'RecordTypeWhiteList',
      supportDDLTypes: 'SupportDDLTypes',
      throttleIOPS: 'ThrottleIOPS',
      throttleRps: 'ThrottleRps',
    };
  }

  static types(): { [key: string]: any } {
    return {
      incrSyncThreadCount: 'number',
      recordTypeWhiteList: { 'type': 'array', 'itemType': 'string' },
      supportDDLTypes: { 'type': 'array', 'itemType': 'string' },
      throttleIOPS: 'number',
      throttleRps: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProjectConfigResponseBodyErrorDetail extends $tea.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * WARN
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}


export default class Client extends OpenApi {

  constructor(config: $OpenApi.Config) {
    super(config);
    this._endpointRule = "regional";
    this.checkConfig(config);
    this._endpoint = this.getEndpoint("oceanbasepro", this._regionId, this._endpointRule, this._network, this._suffix, this._endpointMap, this._endpoint);
  }


  getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: {[key: string ]: string}, endpoint: string): string {
    if (!Util.empty(endpoint)) {
      return endpoint;
    }

    if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
      return endpointMap[regionId];
    }

    return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
  }

  /**
   * You can call this operation to close sessions in batches. Please note that this operation is executed asynchronously. After calling this operation, you need to verify it by calling DescribeProcessStatsComposition.
   * 
   * @param request - BatchKillProcessListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns BatchKillProcessListResponse
   */
  async batchKillProcessListWithOptions(request: BatchKillProcessListRequest, runtime: $Util.RuntimeOptions): Promise<BatchKillProcessListResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.sessionList)) {
      body["SessionList"] = request.sessionList;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "BatchKillProcessList",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchKillProcessListResponse>(await this.callApi(params, req, runtime), new BatchKillProcessListResponse({}));
  }

  /**
   * You can call this operation to close sessions in batches. Please note that this operation is executed asynchronously. After calling this operation, you need to verify it by calling DescribeProcessStatsComposition.
   * 
   * @param request - BatchKillProcessListRequest
   * @returns BatchKillProcessListResponse
   */
  async batchKillProcessList(request: BatchKillProcessListRequest): Promise<BatchKillProcessListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchKillProcessListWithOptions(request, runtime);
  }

  /**
   * You can call this operation to close sessions between the ApsaraDB for OceanBase and the application in batches. Please note that this operation is executed asynchronously. After calling this operation, you need to verify it by calling DescribeSessionList.
   * 
   * @param request - BatchKillSessionListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns BatchKillSessionListResponse
   */
  async batchKillSessionListWithOptions(request: BatchKillSessionListRequest, runtime: $Util.RuntimeOptions): Promise<BatchKillSessionListResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.sessionList)) {
      body["SessionList"] = request.sessionList;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "BatchKillSessionList",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchKillSessionListResponse>(await this.callApi(params, req, runtime), new BatchKillSessionListResponse({}));
  }

  /**
   * You can call this operation to close sessions between the ApsaraDB for OceanBase and the application in batches. Please note that this operation is executed asynchronously. After calling this operation, you need to verify it by calling DescribeSessionList.
   * 
   * @param request - BatchKillSessionListRequest
   * @returns BatchKillSessionListResponse
   */
  async batchKillSessionList(request: BatchKillSessionListRequest): Promise<BatchKillSessionListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchKillSessionListWithOptions(request, runtime);
  }

  /**
   * 根据记录id取消修改操作 （仅支持处于 PENDING 状态的修改记录）
   * 
   * @param request - CancelProjectModifyRecordRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CancelProjectModifyRecordResponse
   */
  async cancelProjectModifyRecordWithOptions(request: CancelProjectModifyRecordRequest, runtime: $Util.RuntimeOptions): Promise<CancelProjectModifyRecordResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.id)) {
      body["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CancelProjectModifyRecord",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CancelProjectModifyRecordResponse>(await this.callApi(params, req, runtime), new CancelProjectModifyRecordResponse({}));
  }

  /**
   * 根据记录id取消修改操作 （仅支持处于 PENDING 状态的修改记录）
   * 
   * @param request - CancelProjectModifyRecordRequest
   * @returns CancelProjectModifyRecordResponse
   */
  async cancelProjectModifyRecord(request: CancelProjectModifyRecordRequest): Promise<CancelProjectModifyRecordResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.cancelProjectModifyRecordWithOptions(request, runtime);
  }

  /**
   * 创建备份任务下载链接
   * 
   * @param request - CreateBackupSetDownloadLinkRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateBackupSetDownloadLinkResponse
   */
  async createBackupSetDownloadLinkWithOptions(request: CreateBackupSetDownloadLinkRequest, runtime: $Util.RuntimeOptions): Promise<CreateBackupSetDownloadLinkResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.backupSetId)) {
      body["BackupSetId"] = request.backupSetId;
    }

    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateBackupSetDownloadLink",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateBackupSetDownloadLinkResponse>(await this.callApi(params, req, runtime), new CreateBackupSetDownloadLinkResponse({}));
  }

  /**
   * 创建备份任务下载链接
   * 
   * @param request - CreateBackupSetDownloadLinkRequest
   * @returns CreateBackupSetDownloadLinkResponse
   */
  async createBackupSetDownloadLink(request: CreateBackupSetDownloadLinkRequest): Promise<CreateBackupSetDownloadLinkResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createBackupSetDownloadLinkWithOptions(request, runtime);
  }

  /**
   * The request ID.
   * 
   * @param request - CreateDatabaseRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateDatabaseResponse
   */
  async createDatabaseWithOptions(request: CreateDatabaseRequest, runtime: $Util.RuntimeOptions): Promise<CreateDatabaseResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.clientToken)) {
      body["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.collation)) {
      body["Collation"] = request.collation;
    }

    if (!Util.isUnset(request.databaseName)) {
      body["DatabaseName"] = request.databaseName;
    }

    if (!Util.isUnset(request.description)) {
      body["Description"] = request.description;
    }

    if (!Util.isUnset(request.encoding)) {
      body["Encoding"] = request.encoding;
    }

    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateDatabase",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateDatabaseResponse>(await this.callApi(params, req, runtime), new CreateDatabaseResponse({}));
  }

  /**
   * The request ID.
   * 
   * @param request - CreateDatabaseRequest
   * @returns CreateDatabaseResponse
   */
  async createDatabase(request: CreateDatabaseRequest): Promise<CreateDatabaseResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDatabaseWithOptions(request, runtime);
  }

  /**
   * You can call this operation to create an OceanBase cluster.
   * 
   * @param request - CreateInstanceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateInstanceResponse
   */
  async createInstanceWithOptions(request: CreateInstanceRequest, runtime: $Util.RuntimeOptions): Promise<CreateInstanceResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.autoRenew)) {
      body["AutoRenew"] = request.autoRenew;
    }

    if (!Util.isUnset(request.autoRenewPeriod)) {
      body["AutoRenewPeriod"] = request.autoRenewPeriod;
    }

    if (!Util.isUnset(request.chargeType)) {
      body["ChargeType"] = request.chargeType;
    }

    if (!Util.isUnset(request.cpuArch)) {
      body["CpuArch"] = request.cpuArch;
    }

    if (!Util.isUnset(request.diskSize)) {
      body["DiskSize"] = request.diskSize;
    }

    if (!Util.isUnset(request.diskType)) {
      body["DiskType"] = request.diskType;
    }

    if (!Util.isUnset(request.dryRun)) {
      body["DryRun"] = request.dryRun;
    }

    if (!Util.isUnset(request.instanceClass)) {
      body["InstanceClass"] = request.instanceClass;
    }

    if (!Util.isUnset(request.instanceName)) {
      body["InstanceName"] = request.instanceName;
    }

    if (!Util.isUnset(request.isolationOptimization)) {
      body["IsolationOptimization"] = request.isolationOptimization;
    }

    if (!Util.isUnset(request.obVersion)) {
      body["ObVersion"] = request.obVersion;
    }

    if (!Util.isUnset(request.period)) {
      body["Period"] = request.period;
    }

    if (!Util.isUnset(request.periodUnit)) {
      body["PeriodUnit"] = request.periodUnit;
    }

    if (!Util.isUnset(request.primaryInstance)) {
      body["PrimaryInstance"] = request.primaryInstance;
    }

    if (!Util.isUnset(request.primaryRegion)) {
      body["PrimaryRegion"] = request.primaryRegion;
    }

    if (!Util.isUnset(request.replicaMode)) {
      body["ReplicaMode"] = request.replicaMode;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      body["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.series)) {
      body["Series"] = request.series;
    }

    if (!Util.isUnset(request.zones)) {
      body["Zones"] = request.zones;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateInstance",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateInstanceResponse>(await this.callApi(params, req, runtime), new CreateInstanceResponse({}));
  }

  /**
   * You can call this operation to create an OceanBase cluster.
   * 
   * @param request - CreateInstanceRequest
   * @returns CreateInstanceResponse
   */
  async createInstance(request: CreateInstanceRequest): Promise<CreateInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createInstanceWithOptions(request, runtime);
  }

  /**
   * 创建标签
   * 
   * @param request - CreateLabelRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateLabelResponse
   */
  async createLabelWithOptions(request: CreateLabelRequest, runtime: $Util.RuntimeOptions): Promise<CreateLabelResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateLabel",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateLabelResponse>(await this.callApi(params, req, runtime), new CreateLabelResponse({}));
  }

  /**
   * 创建标签
   * 
   * @param request - CreateLabelRequest
   * @returns CreateLabelResponse
   */
  async createLabel(request: CreateLabelRequest): Promise<CreateLabelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createLabelWithOptions(request, runtime);
  }

  /**
   * 创建 MySQL 数据源
   * 
   * @param request - CreateMySqlDataSourceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateMySqlDataSourceResponse
   */
  async createMySqlDataSourceWithOptions(request: CreateMySqlDataSourceRequest, runtime: $Util.RuntimeOptions): Promise<CreateMySqlDataSourceResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.description)) {
      body["Description"] = request.description;
    }

    if (!Util.isUnset(request.dgInstanceId)) {
      body["DgInstanceId"] = request.dgInstanceId;
    }

    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.ip)) {
      body["Ip"] = request.ip;
    }

    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    if (!Util.isUnset(request.password)) {
      body["Password"] = request.password;
    }

    if (!Util.isUnset(request.port)) {
      body["Port"] = request.port;
    }

    if (!Util.isUnset(request.schema)) {
      body["Schema"] = request.schema;
    }

    if (!Util.isUnset(request.type)) {
      body["Type"] = request.type;
    }

    if (!Util.isUnset(request.useSsl)) {
      body["UseSsl"] = request.useSsl;
    }

    if (!Util.isUnset(request.userName)) {
      body["UserName"] = request.userName;
    }

    if (!Util.isUnset(request.vpcId)) {
      body["VpcId"] = request.vpcId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateMySqlDataSource",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateMySqlDataSourceResponse>(await this.callApi(params, req, runtime), new CreateMySqlDataSourceResponse({}));
  }

  /**
   * 创建 MySQL 数据源
   * 
   * @param request - CreateMySqlDataSourceRequest
   * @returns CreateMySqlDataSourceResponse
   */
  async createMySqlDataSource(request: CreateMySqlDataSourceRequest): Promise<CreateMySqlDataSourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createMySqlDataSourceWithOptions(request, runtime);
  }

  /**
   * 创建 OceanBase 数据源
   * 
   * @param request - CreateOceanBaseDataSourceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateOceanBaseDataSourceResponse
   */
  async createOceanBaseDataSourceWithOptions(request: CreateOceanBaseDataSourceRequest, runtime: $Util.RuntimeOptions): Promise<CreateOceanBaseDataSourceResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.cluster)) {
      body["Cluster"] = request.cluster;
    }

    if (!Util.isUnset(request.configUrl)) {
      body["ConfigUrl"] = request.configUrl;
    }

    if (!Util.isUnset(request.description)) {
      body["Description"] = request.description;
    }

    if (!Util.isUnset(request.drcPassword)) {
      body["DrcPassword"] = request.drcPassword;
    }

    if (!Util.isUnset(request.drcUserName)) {
      body["DrcUserName"] = request.drcUserName;
    }

    if (!Util.isUnset(request.innerDrcPassword)) {
      body["InnerDrcPassword"] = request.innerDrcPassword;
    }

    if (!Util.isUnset(request.ip)) {
      body["Ip"] = request.ip;
    }

    if (!Util.isUnset(request.logProxyIp)) {
      body["LogProxyIp"] = request.logProxyIp;
    }

    if (!Util.isUnset(request.logProxyPort)) {
      body["LogProxyPort"] = request.logProxyPort;
    }

    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    if (!Util.isUnset(request.password)) {
      body["Password"] = request.password;
    }

    if (!Util.isUnset(request.port)) {
      body["Port"] = request.port;
    }

    if (!Util.isUnset(request.tenant)) {
      body["Tenant"] = request.tenant;
    }

    if (!Util.isUnset(request.type)) {
      body["Type"] = request.type;
    }

    if (!Util.isUnset(request.userName)) {
      body["UserName"] = request.userName;
    }

    if (!Util.isUnset(request.vpcId)) {
      body["VpcId"] = request.vpcId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateOceanBaseDataSource",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateOceanBaseDataSourceResponse>(await this.callApi(params, req, runtime), new CreateOceanBaseDataSourceResponse({}));
  }

  /**
   * 创建 OceanBase 数据源
   * 
   * @param request - CreateOceanBaseDataSourceRequest
   * @returns CreateOceanBaseDataSourceResponse
   */
  async createOceanBaseDataSource(request: CreateOceanBaseDataSourceRequest): Promise<CreateOceanBaseDataSourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createOceanBaseDataSourceWithOptions(request, runtime);
  }

  /**
   * You can call this operation to create a MySQL data source.
   * 
   * @remarks
   * To call this operation, you must add the IP address of the OceanBase Migration Service (OMS) server to the whitelist of the Alibaba Cloud database instance, the security rules of the ECS instance, or the security settings of your self-managed database (usually the firewall of your self-managed database) to ensure that OMS can successfully access your database instance. To obtain the IP address of the OMS server, go to the OMS data source management page in the OMS console.
   * 
   * @param request - CreateOmsMysqlDataSourceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateOmsMysqlDataSourceResponse
   */
  async createOmsMysqlDataSourceWithOptions(request: CreateOmsMysqlDataSourceRequest, runtime: $Util.RuntimeOptions): Promise<CreateOmsMysqlDataSourceResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.description)) {
      body["Description"] = request.description;
    }

    if (!Util.isUnset(request.dgDatabaseId)) {
      body["DgDatabaseId"] = request.dgDatabaseId;
    }

    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.ip)) {
      body["Ip"] = request.ip;
    }

    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    if (!Util.isUnset(request.password)) {
      body["Password"] = request.password;
    }

    if (!Util.isUnset(request.port)) {
      body["Port"] = request.port;
    }

    if (!Util.isUnset(request.schema)) {
      body["Schema"] = request.schema;
    }

    if (!Util.isUnset(request.type)) {
      body["Type"] = request.type;
    }

    if (!Util.isUnset(request.username)) {
      body["Username"] = request.username;
    }

    if (!Util.isUnset(request.vpcId)) {
      body["VpcId"] = request.vpcId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateOmsMysqlDataSource",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateOmsMysqlDataSourceResponse>(await this.callApi(params, req, runtime), new CreateOmsMysqlDataSourceResponse({}));
  }

  /**
   * You can call this operation to create a MySQL data source.
   * 
   * @remarks
   * To call this operation, you must add the IP address of the OceanBase Migration Service (OMS) server to the whitelist of the Alibaba Cloud database instance, the security rules of the ECS instance, or the security settings of your self-managed database (usually the firewall of your self-managed database) to ensure that OMS can successfully access your database instance. To obtain the IP address of the OMS server, go to the OMS data source management page in the OMS console.
   * 
   * @param request - CreateOmsMysqlDataSourceRequest
   * @returns CreateOmsMysqlDataSourceResponse
   */
  async createOmsMysqlDataSource(request: CreateOmsMysqlDataSourceRequest): Promise<CreateOmsMysqlDataSourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createOmsMysqlDataSourceWithOptions(request, runtime);
  }

  /**
   * 创建项目
   * 
   * @param tmpReq - CreateProjectRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateProjectResponse
   */
  async createProjectWithOptions(tmpReq: CreateProjectRequest, runtime: $Util.RuntimeOptions): Promise<CreateProjectResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateProjectShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.commonTransferConfig)) {
      request.commonTransferConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.commonTransferConfig, "CommonTransferConfig", "json");
    }

    if (!Util.isUnset(tmpReq.fullTransferConfig)) {
      request.fullTransferConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.fullTransferConfig, "FullTransferConfig", "json");
    }

    if (!Util.isUnset(tmpReq.incrTransferConfig)) {
      request.incrTransferConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.incrTransferConfig, "IncrTransferConfig", "json");
    }

    if (!Util.isUnset(tmpReq.labelIds)) {
      request.labelIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.labelIds, "LabelIds", "json");
    }

    if (!Util.isUnset(tmpReq.reverseIncrTransferConfig)) {
      request.reverseIncrTransferConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.reverseIncrTransferConfig, "ReverseIncrTransferConfig", "json");
    }

    if (!Util.isUnset(tmpReq.structTransferConfig)) {
      request.structTransferConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.structTransferConfig, "StructTransferConfig", "json");
    }

    if (!Util.isUnset(tmpReq.transferMapping)) {
      request.transferMappingShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.transferMapping, "TransferMapping", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.commonTransferConfigShrink)) {
      body["CommonTransferConfig"] = request.commonTransferConfigShrink;
    }

    if (!Util.isUnset(request.enableFullTransfer)) {
      body["EnableFullTransfer"] = request.enableFullTransfer;
    }

    if (!Util.isUnset(request.enableFullVerify)) {
      body["EnableFullVerify"] = request.enableFullVerify;
    }

    if (!Util.isUnset(request.enableIncrTransfer)) {
      body["EnableIncrTransfer"] = request.enableIncrTransfer;
    }

    if (!Util.isUnset(request.enableReverseIncrTransfer)) {
      body["EnableReverseIncrTransfer"] = request.enableReverseIncrTransfer;
    }

    if (!Util.isUnset(request.enableStructTransfer)) {
      body["EnableStructTransfer"] = request.enableStructTransfer;
    }

    if (!Util.isUnset(request.fullTransferConfigShrink)) {
      body["FullTransferConfig"] = request.fullTransferConfigShrink;
    }

    if (!Util.isUnset(request.id)) {
      body["Id"] = request.id;
    }

    if (!Util.isUnset(request.incrTransferConfigShrink)) {
      body["IncrTransferConfig"] = request.incrTransferConfigShrink;
    }

    if (!Util.isUnset(request.labelIdsShrink)) {
      body["LabelIds"] = request.labelIdsShrink;
    }

    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    if (!Util.isUnset(request.ossKey)) {
      body["OssKey"] = request.ossKey;
    }

    if (!Util.isUnset(request.reverseIncrTransferConfigShrink)) {
      body["ReverseIncrTransferConfig"] = request.reverseIncrTransferConfigShrink;
    }

    if (!Util.isUnset(request.sinkEndpointId)) {
      body["SinkEndpointId"] = request.sinkEndpointId;
    }

    if (!Util.isUnset(request.sourceEndpointId)) {
      body["SourceEndpointId"] = request.sourceEndpointId;
    }

    if (!Util.isUnset(request.structTransferConfigShrink)) {
      body["StructTransferConfig"] = request.structTransferConfigShrink;
    }

    if (!Util.isUnset(request.transferMappingShrink)) {
      body["TransferMapping"] = request.transferMappingShrink;
    }

    if (!Util.isUnset(request.type)) {
      body["Type"] = request.type;
    }

    if (!Util.isUnset(request.useOss)) {
      body["UseOss"] = request.useOss;
    }

    if (!Util.isUnset(request.workerGradeId)) {
      body["WorkerGradeId"] = request.workerGradeId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateProject",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateProjectResponse>(await this.callApi(params, req, runtime), new CreateProjectResponse({}));
  }

  /**
   * 创建项目
   * 
   * @param request - CreateProjectRequest
   * @returns CreateProjectResponse
   */
  async createProject(request: CreateProjectRequest): Promise<CreateProjectResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createProjectWithOptions(request, runtime);
  }

  /**
   * 修改传输对象（加减表）(仅支持处于 RUNNING/FAILED/SUSPEND 状态的项目)
   * 
   * @param tmpReq - CreateProjectModifyRecordsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateProjectModifyRecordsResponse
   */
  async createProjectModifyRecordsWithOptions(tmpReq: CreateProjectModifyRecordsRequest, runtime: $Util.RuntimeOptions): Promise<CreateProjectModifyRecordsResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateProjectModifyRecordsShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.databases)) {
      request.databasesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.databases, "Databases", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.databasesShrink)) {
      body["Databases"] = request.databasesShrink;
    }

    if (!Util.isUnset(request.id)) {
      body["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateProjectModifyRecords",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateProjectModifyRecordsResponse>(await this.callApi(params, req, runtime), new CreateProjectModifyRecordsResponse({}));
  }

  /**
   * 修改传输对象（加减表）(仅支持处于 RUNNING/FAILED/SUSPEND 状态的项目)
   * 
   * @param request - CreateProjectModifyRecordsRequest
   * @returns CreateProjectModifyRecordsResponse
   */
  async createProjectModifyRecords(request: CreateProjectModifyRecordsRequest): Promise<CreateProjectModifyRecordsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createProjectModifyRecordsWithOptions(request, runtime);
  }

  /**
   * 创建RDS PG 数据源
   * 
   * @param request - CreateRdsPostgreSQLDataSourceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateRdsPostgreSQLDataSourceResponse
   */
  async createRdsPostgreSQLDataSourceWithOptions(request: CreateRdsPostgreSQLDataSourceRequest, runtime: $Util.RuntimeOptions): Promise<CreateRdsPostgreSQLDataSourceResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.databaseName)) {
      body["DatabaseName"] = request.databaseName;
    }

    if (!Util.isUnset(request.description)) {
      body["Description"] = request.description;
    }

    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    if (!Util.isUnset(request.password)) {
      body["Password"] = request.password;
    }

    if (!Util.isUnset(request.userName)) {
      body["UserName"] = request.userName;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateRdsPostgreSQLDataSource",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateRdsPostgreSQLDataSourceResponse>(await this.callApi(params, req, runtime), new CreateRdsPostgreSQLDataSourceResponse({}));
  }

  /**
   * 创建RDS PG 数据源
   * 
   * @param request - CreateRdsPostgreSQLDataSourceRequest
   * @returns CreateRdsPostgreSQLDataSourceResponse
   */
  async createRdsPostgreSQLDataSource(request: CreateRdsPostgreSQLDataSourceRequest): Promise<CreateRdsPostgreSQLDataSourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createRdsPostgreSQLDataSourceWithOptions(request, runtime);
  }

  /**
   * The name of the whitelist group.
   * 
   * @param request - CreateSecurityIpGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateSecurityIpGroupResponse
   */
  async createSecurityIpGroupWithOptions(request: CreateSecurityIpGroupRequest, runtime: $Util.RuntimeOptions): Promise<CreateSecurityIpGroupResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.securityIpGroupName)) {
      body["SecurityIpGroupName"] = request.securityIpGroupName;
    }

    if (!Util.isUnset(request.securityIps)) {
      body["SecurityIps"] = request.securityIps;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateSecurityIpGroup",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateSecurityIpGroupResponse>(await this.callApi(params, req, runtime), new CreateSecurityIpGroupResponse({}));
  }

  /**
   * The name of the whitelist group.
   * 
   * @param request - CreateSecurityIpGroupRequest
   * @returns CreateSecurityIpGroupResponse
   */
  async createSecurityIpGroup(request: CreateSecurityIpGroupRequest): Promise<CreateSecurityIpGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createSecurityIpGroupWithOptions(request, runtime);
  }

  /**
   * You can call this operation to create a tag group.
   * 
   * @param request - CreateTagRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateTagResponse
   */
  async createTagWithOptions(request: CreateTagRequest, runtime: $Util.RuntimeOptions): Promise<CreateTagResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.clientToken)) {
      body["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.key)) {
      body["Key"] = request.key;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateTag",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateTagResponse>(await this.callApi(params, req, runtime), new CreateTagResponse({}));
  }

  /**
   * You can call this operation to create a tag group.
   * 
   * @param request - CreateTagRequest
   * @returns CreateTagResponse
   */
  async createTag(request: CreateTagRequest): Promise<CreateTagResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createTagWithOptions(request, runtime);
  }

  /**
   * You can call this operation to create a tag.
   * 
   * @param request - CreateTagValueRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateTagValueResponse
   */
  async createTagValueWithOptions(request: CreateTagValueRequest, runtime: $Util.RuntimeOptions): Promise<CreateTagValueResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.clientToken)) {
      body["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.key)) {
      body["Key"] = request.key;
    }

    if (!Util.isUnset(request.value)) {
      body["Value"] = request.value;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateTagValue",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateTagValueResponse>(await this.callApi(params, req, runtime), new CreateTagValueResponse({}));
  }

  /**
   * You can call this operation to create a tag.
   * 
   * @param request - CreateTagValueRequest
   * @returns CreateTagValueResponse
   */
  async createTagValue(request: CreateTagValueRequest): Promise<CreateTagValueResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createTagValueWithOptions(request, runtime);
  }

  /**
   * You can call this operation to create a tenant.
   * 
   * @param tmpReq - CreateTenantRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateTenantResponse
   */
  async createTenantWithOptions(tmpReq: CreateTenantRequest, runtime: $Util.RuntimeOptions): Promise<CreateTenantResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateTenantShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.createParams)) {
      request.createParamsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.createParams, "CreateParams", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.charset)) {
      body["Charset"] = request.charset;
    }

    if (!Util.isUnset(request.cpu)) {
      body["Cpu"] = request.cpu;
    }

    if (!Util.isUnset(request.createParamsShrink)) {
      body["CreateParams"] = request.createParamsShrink;
    }

    if (!Util.isUnset(request.description)) {
      body["Description"] = request.description;
    }

    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.logDisk)) {
      body["LogDisk"] = request.logDisk;
    }

    if (!Util.isUnset(request.memory)) {
      body["Memory"] = request.memory;
    }

    if (!Util.isUnset(request.primaryZone)) {
      body["PrimaryZone"] = request.primaryZone;
    }

    if (!Util.isUnset(request.readOnlyZoneList)) {
      body["ReadOnlyZoneList"] = request.readOnlyZoneList;
    }

    if (!Util.isUnset(request.tenantMode)) {
      body["TenantMode"] = request.tenantMode;
    }

    if (!Util.isUnset(request.tenantName)) {
      body["TenantName"] = request.tenantName;
    }

    if (!Util.isUnset(request.timeZone)) {
      body["TimeZone"] = request.timeZone;
    }

    if (!Util.isUnset(request.unitNum)) {
      body["UnitNum"] = request.unitNum;
    }

    if (!Util.isUnset(request.userVSwitchId)) {
      body["UserVSwitchId"] = request.userVSwitchId;
    }

    if (!Util.isUnset(request.userVpcId)) {
      body["UserVpcId"] = request.userVpcId;
    }

    if (!Util.isUnset(request.userVpcOwnerId)) {
      body["UserVpcOwnerId"] = request.userVpcOwnerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateTenant",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateTenantResponse>(await this.callApi(params, req, runtime), new CreateTenantResponse({}));
  }

  /**
   * You can call this operation to create a tenant.
   * 
   * @param request - CreateTenantRequest
   * @returns CreateTenantResponse
   */
  async createTenant(request: CreateTenantRequest): Promise<CreateTenantResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createTenantWithOptions(request, runtime);
  }

  /**
   * The request ID.
   * 
   * @param request - CreateTenantReadOnlyConnectionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateTenantReadOnlyConnectionResponse
   */
  async createTenantReadOnlyConnectionWithOptions(request: CreateTenantReadOnlyConnectionRequest, runtime: $Util.RuntimeOptions): Promise<CreateTenantReadOnlyConnectionResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    if (!Util.isUnset(request.vSwitchId)) {
      body["VSwitchId"] = request.vSwitchId;
    }

    if (!Util.isUnset(request.vpcId)) {
      body["VpcId"] = request.vpcId;
    }

    if (!Util.isUnset(request.zoneId)) {
      body["ZoneId"] = request.zoneId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateTenantReadOnlyConnection",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateTenantReadOnlyConnectionResponse>(await this.callApi(params, req, runtime), new CreateTenantReadOnlyConnectionResponse({}));
  }

  /**
   * The request ID.
   * 
   * @param request - CreateTenantReadOnlyConnectionRequest
   * @returns CreateTenantReadOnlyConnectionResponse
   */
  async createTenantReadOnlyConnection(request: CreateTenantReadOnlyConnectionRequest): Promise<CreateTenantReadOnlyConnectionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createTenantReadOnlyConnectionWithOptions(request, runtime);
  }

  /**
   * You can call this operation to create the security whitelist for the tenant.
   * 
   * @param request - CreateTenantSecurityIpGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateTenantSecurityIpGroupResponse
   */
  async createTenantSecurityIpGroupWithOptions(request: CreateTenantSecurityIpGroupRequest, runtime: $Util.RuntimeOptions): Promise<CreateTenantSecurityIpGroupResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.securityIpGroupName)) {
      body["SecurityIpGroupName"] = request.securityIpGroupName;
    }

    if (!Util.isUnset(request.securityIps)) {
      body["SecurityIps"] = request.securityIps;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateTenantSecurityIpGroup",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateTenantSecurityIpGroupResponse>(await this.callApi(params, req, runtime), new CreateTenantSecurityIpGroupResponse({}));
  }

  /**
   * You can call this operation to create the security whitelist for the tenant.
   * 
   * @param request - CreateTenantSecurityIpGroupRequest
   * @returns CreateTenantSecurityIpGroupResponse
   */
  async createTenantSecurityIpGroup(request: CreateTenantSecurityIpGroupRequest): Promise<CreateTenantSecurityIpGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createTenantSecurityIpGroupWithOptions(request, runtime);
  }

  /**
   * CreateTenantUser
   * 
   * @param request - CreateTenantUserRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateTenantUserResponse
   */
  async createTenantUserWithOptions(request: CreateTenantUserRequest, runtime: $Util.RuntimeOptions): Promise<CreateTenantUserResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.description)) {
      body["Description"] = request.description;
    }

    if (!Util.isUnset(request.encryptionType)) {
      body["EncryptionType"] = request.encryptionType;
    }

    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.roles)) {
      body["Roles"] = request.roles;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    if (!Util.isUnset(request.userName)) {
      body["UserName"] = request.userName;
    }

    if (!Util.isUnset(request.userPassword)) {
      body["UserPassword"] = request.userPassword;
    }

    if (!Util.isUnset(request.userType)) {
      body["UserType"] = request.userType;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateTenantUser",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateTenantUserResponse>(await this.callApi(params, req, runtime), new CreateTenantUserResponse({}));
  }

  /**
   * CreateTenantUser
   * 
   * @param request - CreateTenantUserRequest
   * @returns CreateTenantUserResponse
   */
  async createTenantUser(request: CreateTenantUserRequest): Promise<CreateTenantUserResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createTenantUserWithOptions(request, runtime);
  }

  /**
   * 删除数据源
   * 
   * @param request - DeleteDataSourceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteDataSourceResponse
   */
  async deleteDataSourceWithOptions(request: DeleteDataSourceRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDataSourceResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.id)) {
      body["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteDataSource",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteDataSourceResponse>(await this.callApi(params, req, runtime), new DeleteDataSourceResponse({}));
  }

  /**
   * 删除数据源
   * 
   * @param request - DeleteDataSourceRequest
   * @returns DeleteDataSourceResponse
   */
  async deleteDataSource(request: DeleteDataSourceRequest): Promise<DeleteDataSourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDataSourceWithOptions(request, runtime);
  }

  /**
   * The request ID.
   * 
   * @param request - DeleteDatabasesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteDatabasesResponse
   */
  async deleteDatabasesWithOptions(request: DeleteDatabasesRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDatabasesResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.databaseNames)) {
      body["DatabaseNames"] = request.databaseNames;
    }

    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteDatabases",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteDatabasesResponse>(await this.callApi(params, req, runtime), new DeleteDatabasesResponse({}));
  }

  /**
   * The request ID.
   * 
   * @param request - DeleteDatabasesRequest
   * @returns DeleteDatabasesResponse
   */
  async deleteDatabases(request: DeleteDatabasesRequest): Promise<DeleteDatabasesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDatabasesWithOptions(request, runtime);
  }

  /**
   * You can call this operation to release an OceanBase cluster.
   * 
   * @remarks
   * Before you call this operation, ensure that the following requirements are met:
   * - The cluster is in the Running state.
   * - The cluster is a primary cluster and the billing method is pay-as-you-go.
   * 
   * @param request - DeleteInstancesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteInstancesResponse
   */
  async deleteInstancesWithOptions(request: DeleteInstancesRequest, runtime: $Util.RuntimeOptions): Promise<DeleteInstancesResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.backupRetainMode)) {
      body["BackupRetainMode"] = request.backupRetainMode;
    }

    if (!Util.isUnset(request.dryRun)) {
      body["DryRun"] = request.dryRun;
    }

    if (!Util.isUnset(request.instanceIds)) {
      body["InstanceIds"] = request.instanceIds;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteInstances",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteInstancesResponse>(await this.callApi(params, req, runtime), new DeleteInstancesResponse({}));
  }

  /**
   * You can call this operation to release an OceanBase cluster.
   * 
   * @remarks
   * Before you call this operation, ensure that the following requirements are met:
   * - The cluster is in the Running state.
   * - The cluster is a primary cluster and the billing method is pay-as-you-go.
   * 
   * @param request - DeleteInstancesRequest
   * @returns DeleteInstancesResponse
   */
  async deleteInstances(request: DeleteInstancesRequest): Promise<DeleteInstancesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteInstancesWithOptions(request, runtime);
  }

  /**
   * 删除项目
   * 
   * @param request - DeleteProjectRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteProjectResponse
   */
  async deleteProjectWithOptions(request: DeleteProjectRequest, runtime: $Util.RuntimeOptions): Promise<DeleteProjectResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.id)) {
      body["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteProject",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteProjectResponse>(await this.callApi(params, req, runtime), new DeleteProjectResponse({}));
  }

  /**
   * 删除项目
   * 
   * @param request - DeleteProjectRequest
   * @returns DeleteProjectResponse
   */
  async deleteProject(request: DeleteProjectRequest): Promise<DeleteProjectResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteProjectWithOptions(request, runtime);
  }

  /**
   * The name of the deleted IP address whitelist group.
   * 
   * @param request - DeleteSecurityIpGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteSecurityIpGroupResponse
   */
  async deleteSecurityIpGroupWithOptions(request: DeleteSecurityIpGroupRequest, runtime: $Util.RuntimeOptions): Promise<DeleteSecurityIpGroupResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.securityIpGroupName)) {
      body["SecurityIpGroupName"] = request.securityIpGroupName;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteSecurityIpGroup",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteSecurityIpGroupResponse>(await this.callApi(params, req, runtime), new DeleteSecurityIpGroupResponse({}));
  }

  /**
   * The name of the deleted IP address whitelist group.
   * 
   * @param request - DeleteSecurityIpGroupRequest
   * @returns DeleteSecurityIpGroupResponse
   */
  async deleteSecurityIpGroup(request: DeleteSecurityIpGroupRequest): Promise<DeleteSecurityIpGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteSecurityIpGroupWithOptions(request, runtime);
  }

  /**
   * You can call this operation to delete a tag group.
   * 
   * @param request - DeleteTagRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteTagResponse
   */
  async deleteTagWithOptions(request: DeleteTagRequest, runtime: $Util.RuntimeOptions): Promise<DeleteTagResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.key)) {
      body["Key"] = request.key;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteTag",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteTagResponse>(await this.callApi(params, req, runtime), new DeleteTagResponse({}));
  }

  /**
   * You can call this operation to delete a tag group.
   * 
   * @param request - DeleteTagRequest
   * @returns DeleteTagResponse
   */
  async deleteTag(request: DeleteTagRequest): Promise<DeleteTagResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteTagWithOptions(request, runtime);
  }

  /**
   * You can call this operation to delete a tag from a tag group.
   * 
   * @param request - DeleteTagValueRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteTagValueResponse
   */
  async deleteTagValueWithOptions(request: DeleteTagValueRequest, runtime: $Util.RuntimeOptions): Promise<DeleteTagValueResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.key)) {
      body["Key"] = request.key;
    }

    if (!Util.isUnset(request.value)) {
      body["Value"] = request.value;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteTagValue",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteTagValueResponse>(await this.callApi(params, req, runtime), new DeleteTagValueResponse({}));
  }

  /**
   * You can call this operation to delete a tag from a tag group.
   * 
   * @param request - DeleteTagValueRequest
   * @returns DeleteTagValueResponse
   */
  async deleteTagValue(request: DeleteTagValueRequest): Promise<DeleteTagValueResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteTagValueWithOptions(request, runtime);
  }

  /**
   * You can call this operation to delete the information on the whitelist group of the tenant.
   * 
   * @param request - DeleteTenantSecurityIpGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteTenantSecurityIpGroupResponse
   */
  async deleteTenantSecurityIpGroupWithOptions(request: DeleteTenantSecurityIpGroupRequest, runtime: $Util.RuntimeOptions): Promise<DeleteTenantSecurityIpGroupResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.securityIpGroupName)) {
      body["SecurityIpGroupName"] = request.securityIpGroupName;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteTenantSecurityIpGroup",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteTenantSecurityIpGroupResponse>(await this.callApi(params, req, runtime), new DeleteTenantSecurityIpGroupResponse({}));
  }

  /**
   * You can call this operation to delete the information on the whitelist group of the tenant.
   * 
   * @param request - DeleteTenantSecurityIpGroupRequest
   * @returns DeleteTenantSecurityIpGroupResponse
   */
  async deleteTenantSecurityIpGroup(request: DeleteTenantSecurityIpGroupRequest): Promise<DeleteTenantSecurityIpGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteTenantSecurityIpGroupWithOptions(request, runtime);
  }

  /**
   * You can call this operation to delete one or more database accounts.
   * 
   * @param request - DeleteTenantUsersRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteTenantUsersResponse
   */
  async deleteTenantUsersWithOptions(request: DeleteTenantUsersRequest, runtime: $Util.RuntimeOptions): Promise<DeleteTenantUsersResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    if (!Util.isUnset(request.users)) {
      body["Users"] = request.users;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteTenantUsers",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteTenantUsersResponse>(await this.callApi(params, req, runtime), new DeleteTenantUsersResponse({}));
  }

  /**
   * You can call this operation to delete one or more database accounts.
   * 
   * @param request - DeleteTenantUsersRequest
   * @returns DeleteTenantUsersResponse
   */
  async deleteTenantUsers(request: DeleteTenantUsersRequest): Promise<DeleteTenantUsersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteTenantUsersWithOptions(request, runtime);
  }

  /**
   * The return result of the request.
   * 
   * @param request - DeleteTenantsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteTenantsResponse
   */
  async deleteTenantsWithOptions(request: DeleteTenantsRequest, runtime: $Util.RuntimeOptions): Promise<DeleteTenantsResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.tenantIds)) {
      body["TenantIds"] = request.tenantIds;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteTenants",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteTenantsResponse>(await this.callApi(params, req, runtime), new DeleteTenantsResponse({}));
  }

  /**
   * The return result of the request.
   * 
   * @param request - DeleteTenantsRequest
   * @returns DeleteTenantsResponse
   */
  async deleteTenants(request: DeleteTenantsRequest): Promise<DeleteTenantsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteTenantsWithOptions(request, runtime);
  }

  /**
   * You can call this operation to obtain the list of SQL statements that may have performance problems according to the diagnostic system.
   * 
   * @param tmpReq - DescribeAnomalySQLListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeAnomalySQLListResponse
   */
  async describeAnomalySQLListWithOptions(tmpReq: DescribeAnomalySQLListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAnomalySQLListResponse> {
    Util.validateModel(tmpReq);
    let request = new DescribeAnomalySQLListShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.filterCondition)) {
      request.filterConditionShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.filterCondition, "FilterCondition", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      body["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.dbName)) {
      body["DbName"] = request.dbName;
    }

    if (!Util.isUnset(request.endTime)) {
      body["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.filterConditionShrink)) {
      body["FilterCondition"] = request.filterConditionShrink;
    }

    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.nodeIp)) {
      body["NodeIp"] = request.nodeIp;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.SQLId)) {
      body["SQLId"] = request.SQLId;
    }

    if (!Util.isUnset(request.searchKeyWord)) {
      body["SearchKeyWord"] = request.searchKeyWord;
    }

    if (!Util.isUnset(request.searchParameter)) {
      body["SearchParameter"] = request.searchParameter;
    }

    if (!Util.isUnset(request.searchRule)) {
      body["SearchRule"] = request.searchRule;
    }

    if (!Util.isUnset(request.searchValue)) {
      body["SearchValue"] = request.searchValue;
    }

    if (!Util.isUnset(request.sortColumn)) {
      body["SortColumn"] = request.sortColumn;
    }

    if (!Util.isUnset(request.sortOrder)) {
      body["SortOrder"] = request.sortOrder;
    }

    if (!Util.isUnset(request.startTime)) {
      body["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAnomalySQLList",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAnomalySQLListResponse>(await this.callApi(params, req, runtime), new DescribeAnomalySQLListResponse({}));
  }

  /**
   * You can call this operation to obtain the list of SQL statements that may have performance problems according to the diagnostic system.
   * 
   * @param request - DescribeAnomalySQLListRequest
   * @returns DescribeAnomalySQLListResponse
   */
  async describeAnomalySQLList(request: DescribeAnomalySQLListRequest): Promise<DescribeAnomalySQLListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAnomalySQLListWithOptions(request, runtime);
  }

  /**
   * The maximum number of CPU cores per resource unit.
   * 
   * @param request - DescribeAvailableCpuResourceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeAvailableCpuResourceResponse
   */
  async describeAvailableCpuResourceWithOptions(request: DescribeAvailableCpuResourceRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAvailableCpuResourceResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.modifyType)) {
      body["ModifyType"] = request.modifyType;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAvailableCpuResource",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAvailableCpuResourceResponse>(await this.callApi(params, req, runtime), new DescribeAvailableCpuResourceResponse({}));
  }

  /**
   * The maximum number of CPU cores per resource unit.
   * 
   * @param request - DescribeAvailableCpuResourceRequest
   * @returns DescribeAvailableCpuResourceResponse
   */
  async describeAvailableCpuResource(request: DescribeAvailableCpuResourceRequest): Promise<DescribeAvailableCpuResourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAvailableCpuResourceWithOptions(request, runtime);
  }

  /**
   * You can call this operation to query the available memory resource of an OceanBase Database tenant.
   * 
   * @param request - DescribeAvailableMemResourceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeAvailableMemResourceResponse
   */
  async describeAvailableMemResourceWithOptions(request: DescribeAvailableMemResourceRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAvailableMemResourceResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.cpuNum)) {
      body["CpuNum"] = request.cpuNum;
    }

    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    if (!Util.isUnset(request.unitNum)) {
      body["UnitNum"] = request.unitNum;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAvailableMemResource",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAvailableMemResourceResponse>(await this.callApi(params, req, runtime), new DescribeAvailableMemResourceResponse({}));
  }

  /**
   * You can call this operation to query the available memory resource of an OceanBase Database tenant.
   * 
   * @param request - DescribeAvailableMemResourceRequest
   * @returns DescribeAvailableMemResourceResponse
   */
  async describeAvailableMemResource(request: DescribeAvailableMemResourceRequest): Promise<DescribeAvailableMemResourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAvailableMemResourceWithOptions(request, runtime);
  }

  /**
   * 获取集群变配页可选配置
   * 
   * @param request - DescribeAvailableSpecRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeAvailableSpecResponse
   */
  async describeAvailableSpecWithOptions(request: DescribeAvailableSpecRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAvailableSpecResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.spec)) {
      body["Spec"] = request.spec;
    }

    if (!Util.isUnset(request.upgradeType)) {
      body["UpgradeType"] = request.upgradeType;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAvailableSpec",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAvailableSpecResponse>(await this.callApi(params, req, runtime), new DescribeAvailableSpecResponse({}));
  }

  /**
   * 获取集群变配页可选配置
   * 
   * @param request - DescribeAvailableSpecRequest
   * @returns DescribeAvailableSpecResponse
   */
  async describeAvailableSpec(request: DescribeAvailableSpecRequest): Promise<DescribeAvailableSpecResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAvailableSpecWithOptions(request, runtime);
  }

  /**
   * 获取集群售卖页可选配置
   * 
   * @param request - DescribeAvailableZoneRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeAvailableZoneResponse
   */
  async describeAvailableZoneWithOptions(request: DescribeAvailableZoneRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAvailableZoneResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.cpuArch)) {
      body["CpuArch"] = request.cpuArch;
    }

    if (!Util.isUnset(request.deployType)) {
      body["DeployType"] = request.deployType;
    }

    if (!Util.isUnset(request.instanceType)) {
      body["InstanceType"] = request.instanceType;
    }

    if (!Util.isUnset(request.obVersion)) {
      body["ObVersion"] = request.obVersion;
    }

    if (!Util.isUnset(request.series)) {
      body["Series"] = request.series;
    }

    if (!Util.isUnset(request.spec)) {
      body["Spec"] = request.spec;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAvailableZone",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAvailableZoneResponse>(await this.callApi(params, req, runtime), new DescribeAvailableZoneResponse({}));
  }

  /**
   * 获取集群售卖页可选配置
   * 
   * @param request - DescribeAvailableZoneRequest
   * @returns DescribeAvailableZoneResponse
   */
  async describeAvailableZone(request: DescribeAvailableZoneRequest): Promise<DescribeAvailableZoneResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAvailableZoneWithOptions(request, runtime);
  }

  /**
   * You can call this operation to query the link for downloading a backup set of OceanBase Database.
   * 
   * @param request - DescribeBackupSetDownloadLinkRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeBackupSetDownloadLinkResponse
   */
  async describeBackupSetDownloadLinkWithOptions(request: DescribeBackupSetDownloadLinkRequest, runtime: $Util.RuntimeOptions): Promise<DescribeBackupSetDownloadLinkResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.downloadTaskId)) {
      body["DownloadTaskId"] = request.downloadTaskId;
    }

    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeBackupSetDownloadLink",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeBackupSetDownloadLinkResponse>(await this.callApi(params, req, runtime), new DescribeBackupSetDownloadLinkResponse({}));
  }

  /**
   * You can call this operation to query the link for downloading a backup set of OceanBase Database.
   * 
   * @param request - DescribeBackupSetDownloadLinkRequest
   * @returns DescribeBackupSetDownloadLinkResponse
   */
  async describeBackupSetDownloadLink(request: DescribeBackupSetDownloadLinkRequest): Promise<DescribeBackupSetDownloadLinkResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeBackupSetDownloadLinkWithOptions(request, runtime);
  }

  /**
   * You can call this operation to query the character sets of an OceanBase Database tenant.
   * 
   * @param request - DescribeCharsetRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeCharsetResponse
   */
  async describeCharsetWithOptions(request: DescribeCharsetRequest, runtime: $Util.RuntimeOptions): Promise<DescribeCharsetResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.series)) {
      body["Series"] = request.series;
    }

    if (!Util.isUnset(request.tenantMode)) {
      body["TenantMode"] = request.tenantMode;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeCharset",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeCharsetResponse>(await this.callApi(params, req, runtime), new DescribeCharsetResponse({}));
  }

  /**
   * You can call this operation to query the character sets of an OceanBase Database tenant.
   * 
   * @param request - DescribeCharsetRequest
   * @returns DescribeCharsetResponse
   */
  async describeCharset(request: DescribeCharsetRequest): Promise<DescribeCharsetResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeCharsetWithOptions(request, runtime);
  }

  /**
   * 查询备份集信息
   * 
   * @param request - DescribeDataBackupSetRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDataBackupSetResponse
   */
  async describeDataBackupSetWithOptions(request: DescribeDataBackupSetRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDataBackupSetResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.backupObjectType)) {
      body["BackupObjectType"] = request.backupObjectType;
    }

    if (!Util.isUnset(request.endTime)) {
      body["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.startTime)) {
      body["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.status)) {
      body["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDataBackupSet",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDataBackupSetResponse>(await this.callApi(params, req, runtime), new DescribeDataBackupSetResponse({}));
  }

  /**
   * 查询备份集信息
   * 
   * @param request - DescribeDataBackupSetRequest
   * @returns DescribeDataBackupSetResponse
   */
  async describeDataBackupSet(request: DescribeDataBackupSetRequest): Promise<DescribeDataBackupSetResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDataBackupSetWithOptions(request, runtime);
  }

  /**
   * You can call this operation to query databases in a tenant.
   * 
   * @param request - DescribeDatabasesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDatabasesResponse
   */
  async describeDatabasesWithOptions(request: DescribeDatabasesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDatabasesResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.databaseName)) {
      body["DatabaseName"] = request.databaseName;
    }

    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.searchKey)) {
      body["SearchKey"] = request.searchKey;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    if (!Util.isUnset(request.withTables)) {
      body["WithTables"] = request.withTables;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDatabases",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDatabasesResponse>(await this.callApi(params, req, runtime), new DescribeDatabasesResponse({}));
  }

  /**
   * You can call this operation to query databases in a tenant.
   * 
   * @param request - DescribeDatabasesRequest
   * @returns DescribeDatabasesResponse
   */
  async describeDatabases(request: DescribeDatabasesRequest): Promise<DescribeDatabasesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDatabasesWithOptions(request, runtime);
  }

  /**
   * The size of used memory in the cluster, in GB.
   * 
   * @param request - DescribeInstanceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeInstanceResponse
   */
  async describeInstanceWithOptions(request: DescribeInstanceRequest, runtime: $Util.RuntimeOptions): Promise<DescribeInstanceResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.maxConnectionLimit)) {
      body["MaxConnectionLimit"] = request.maxConnectionLimit;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeInstance",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeInstanceResponse>(await this.callApi(params, req, runtime), new DescribeInstanceResponse({}));
  }

  /**
   * The size of used memory in the cluster, in GB.
   * 
   * @param request - DescribeInstanceRequest
   * @returns DescribeInstanceResponse
   */
  async describeInstance(request: DescribeInstanceRequest): Promise<DescribeInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeInstanceWithOptions(request, runtime);
  }

  /**
   * The ID of the zone.
   * 
   * @param request - DescribeInstanceCreatableZoneRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeInstanceCreatableZoneResponse
   */
  async describeInstanceCreatableZoneWithOptions(request: DescribeInstanceCreatableZoneRequest, runtime: $Util.RuntimeOptions): Promise<DescribeInstanceCreatableZoneResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeInstanceCreatableZone",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeInstanceCreatableZoneResponse>(await this.callApi(params, req, runtime), new DescribeInstanceCreatableZoneResponse({}));
  }

  /**
   * The ID of the zone.
   * 
   * @param request - DescribeInstanceCreatableZoneRequest
   * @returns DescribeInstanceCreatableZoneResponse
   */
  async describeInstanceCreatableZone(request: DescribeInstanceCreatableZoneRequest): Promise<DescribeInstanceCreatableZoneResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeInstanceCreatableZoneWithOptions(request, runtime);
  }

  /**
   * 查询集群SSL配置
   * 
   * @param request - DescribeInstanceSSLRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeInstanceSSLResponse
   */
  async describeInstanceSSLWithOptions(request: DescribeInstanceSSLRequest, runtime: $Util.RuntimeOptions): Promise<DescribeInstanceSSLResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeInstanceSSL",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeInstanceSSLResponse>(await this.callApi(params, req, runtime), new DescribeInstanceSSLResponse({}));
  }

  /**
   * 查询集群SSL配置
   * 
   * @param request - DescribeInstanceSSLRequest
   * @returns DescribeInstanceSSLResponse
   */
  async describeInstanceSSL(request: DescribeInstanceSSLRequest): Promise<DescribeInstanceSSLResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeInstanceSSLWithOptions(request, runtime);
  }

  /**
   * You can call this operation to query security check items of an OceanBase cluster.
   * 
   * @param request - DescribeInstanceSecurityConfigsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeInstanceSecurityConfigsResponse
   */
  async describeInstanceSecurityConfigsWithOptions(request: DescribeInstanceSecurityConfigsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeInstanceSecurityConfigsResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.checkId)) {
      body["CheckId"] = request.checkId;
    }

    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeInstanceSecurityConfigs",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeInstanceSecurityConfigsResponse>(await this.callApi(params, req, runtime), new DescribeInstanceSecurityConfigsResponse({}));
  }

  /**
   * You can call this operation to query security check items of an OceanBase cluster.
   * 
   * @param request - DescribeInstanceSecurityConfigsRequest
   * @returns DescribeInstanceSecurityConfigsResponse
   */
  async describeInstanceSecurityConfigs(request: DescribeInstanceSecurityConfigsRequest): Promise<DescribeInstanceSecurityConfigsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeInstanceSecurityConfigsWithOptions(request, runtime);
  }

  /**
   * You can call this operation to query the tags of clusters.
   * 
   * @param request - DescribeInstanceTagsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeInstanceTagsResponse
   */
  async describeInstanceTagsWithOptions(request: DescribeInstanceTagsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeInstanceTagsResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.instanceIds)) {
      body["InstanceIds"] = request.instanceIds;
    }

    if (!Util.isUnset(request.tags)) {
      body["Tags"] = request.tags;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeInstanceTags",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeInstanceTagsResponse>(await this.callApi(params, req, runtime), new DescribeInstanceTagsResponse({}));
  }

  /**
   * You can call this operation to query the tags of clusters.
   * 
   * @param request - DescribeInstanceTagsRequest
   * @returns DescribeInstanceTagsResponse
   */
  async describeInstanceTags(request: DescribeInstanceTagsRequest): Promise<DescribeInstanceTagsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeInstanceTagsWithOptions(request, runtime);
  }

  /**
   * The return result of the request.
   * 
   * @param request - DescribeInstanceTenantModesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeInstanceTenantModesResponse
   */
  async describeInstanceTenantModesWithOptions(request: DescribeInstanceTenantModesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeInstanceTenantModesResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeInstanceTenantModes",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeInstanceTenantModesResponse>(await this.callApi(params, req, runtime), new DescribeInstanceTenantModesResponse({}));
  }

  /**
   * The return result of the request.
   * 
   * @param request - DescribeInstanceTenantModesRequest
   * @returns DescribeInstanceTenantModesResponse
   */
  async describeInstanceTenantModes(request: DescribeInstanceTenantModesRequest): Promise<DescribeInstanceTenantModesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeInstanceTenantModesWithOptions(request, runtime);
  }

  /**
   * The ID of the zone.
   * 
   * @param request - DescribeInstanceTopologyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeInstanceTopologyResponse
   */
  async describeInstanceTopologyWithOptions(request: DescribeInstanceTopologyRequest, runtime: $Util.RuntimeOptions): Promise<DescribeInstanceTopologyResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeInstanceTopology",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeInstanceTopologyResponse>(await this.callApi(params, req, runtime), new DescribeInstanceTopologyResponse({}));
  }

  /**
   * The ID of the zone.
   * 
   * @param request - DescribeInstanceTopologyRequest
   * @returns DescribeInstanceTopologyResponse
   */
  async describeInstanceTopology(request: DescribeInstanceTopologyRequest): Promise<DescribeInstanceTopologyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeInstanceTopologyWithOptions(request, runtime);
  }

  /**
   * You can call this operation to obtain the list of OceanBase clusters.
   * 
   * @param request - DescribeInstancesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeInstancesResponse
   */
  async describeInstancesWithOptions(request: DescribeInstancesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeInstancesResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.instanceName)) {
      body["InstanceName"] = request.instanceName;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      body["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.searchKey)) {
      body["SearchKey"] = request.searchKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeInstances",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeInstancesResponse>(await this.callApi(params, req, runtime), new DescribeInstancesResponse({}));
  }

  /**
   * You can call this operation to obtain the list of OceanBase clusters.
   * 
   * @param request - DescribeInstancesRequest
   * @returns DescribeInstancesResponse
   */
  async describeInstances(request: DescribeInstancesRequest): Promise<DescribeInstancesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeInstancesWithOptions(request, runtime);
  }

  /**
   * 查询监控指标数据
   * 
   * @param request - DescribeMetricsDataRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeMetricsDataResponse
   */
  async describeMetricsDataWithOptions(request: DescribeMetricsDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeMetricsDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.groupByLabels)) {
      query["GroupByLabels"] = request.groupByLabels;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.labels)) {
      query["Labels"] = request.labels;
    }

    if (!Util.isUnset(request.limit)) {
      query["Limit"] = request.limit;
    }

    if (!Util.isUnset(request.metrics)) {
      query["Metrics"] = request.metrics;
    }

    if (!Util.isUnset(request.sortMetricKey)) {
      query["SortMetricKey"] = request.sortMetricKey;
    }

    if (!Util.isUnset(request.sortOrder)) {
      query["SortOrder"] = request.sortOrder;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.replicaType)) {
      body["ReplicaType"] = request.replicaType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeMetricsData",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeMetricsDataResponse>(await this.callApi(params, req, runtime), new DescribeMetricsDataResponse({}));
  }

  /**
   * 查询监控指标数据
   * 
   * @param request - DescribeMetricsDataRequest
   * @returns DescribeMetricsDataResponse
   */
  async describeMetricsData(request: DescribeMetricsDataRequest): Promise<DescribeMetricsDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeMetricsDataWithOptions(request, runtime);
  }

  /**
   * The list of nodes.
   * 
   * @param request - DescribeNodeMetricsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeNodeMetricsResponse
   */
  async describeNodeMetricsWithOptions(request: DescribeNodeMetricsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeNodeMetricsResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.endTime)) {
      body["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.metrics)) {
      body["Metrics"] = request.metrics;
    }

    if (!Util.isUnset(request.nodeIdList)) {
      body["NodeIdList"] = request.nodeIdList;
    }

    if (!Util.isUnset(request.nodeName)) {
      body["NodeName"] = request.nodeName;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.startTime)) {
      body["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeNodeMetrics",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeNodeMetricsResponse>(await this.callApi(params, req, runtime), new DescribeNodeMetricsResponse({}));
  }

  /**
   * The list of nodes.
   * 
   * @param request - DescribeNodeMetricsRequest
   * @returns DescribeNodeMetricsResponse
   */
  async describeNodeMetrics(request: DescribeNodeMetricsRequest): Promise<DescribeNodeMetricsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeNodeMetricsWithOptions(request, runtime);
  }

  /**
   * You can call this API to view the list of SQL statements that are identified as having performance issues by the diagnostic system.
   * 
   * @param request - DescribeOasAnomalySQLListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeOasAnomalySQLListResponse
   */
  async describeOasAnomalySQLListWithOptions(request: DescribeOasAnomalySQLListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeOasAnomalySQLListResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      body["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.current)) {
      body["Current"] = request.current;
    }

    if (!Util.isUnset(request.dbName)) {
      body["DbName"] = request.dbName;
    }

    if (!Util.isUnset(request.dynamicSql)) {
      body["DynamicSql"] = request.dynamicSql;
    }

    if (!Util.isUnset(request.endTime)) {
      body["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.filterCondition)) {
      body["FilterCondition"] = request.filterCondition;
    }

    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.mergeDynamicSql)) {
      body["MergeDynamicSql"] = request.mergeDynamicSql;
    }

    if (!Util.isUnset(request.nodeIp)) {
      body["NodeIp"] = request.nodeIp;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.searchKeyWord)) {
      body["SearchKeyWord"] = request.searchKeyWord;
    }

    if (!Util.isUnset(request.searchParam)) {
      body["SearchParam"] = request.searchParam;
    }

    if (!Util.isUnset(request.searchRule)) {
      body["SearchRule"] = request.searchRule;
    }

    if (!Util.isUnset(request.searchValue)) {
      body["SearchValue"] = request.searchValue;
    }

    if (!Util.isUnset(request.sqlId)) {
      body["SqlId"] = request.sqlId;
    }

    if (!Util.isUnset(request.sqlTextLength)) {
      body["SqlTextLength"] = request.sqlTextLength;
    }

    if (!Util.isUnset(request.startTime)) {
      body["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeOasAnomalySQLList",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeOasAnomalySQLListResponse>(await this.callApi(params, req, runtime), new DescribeOasAnomalySQLListResponse({}));
  }

  /**
   * You can call this API to view the list of SQL statements that are identified as having performance issues by the diagnostic system.
   * 
   * @param request - DescribeOasAnomalySQLListRequest
   * @returns DescribeOasAnomalySQLListResponse
   */
  async describeOasAnomalySQLList(request: DescribeOasAnomalySQLListRequest): Promise<DescribeOasAnomalySQLListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeOasAnomalySQLListWithOptions(request, runtime);
  }

  /**
   * You can call this API to query detailed information about the SQL, including the SQL text, related table names, and so on.
   * 
   * @param request - DescribeOasSQLDetailsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeOasSQLDetailsResponse
   */
  async describeOasSQLDetailsWithOptions(request: DescribeOasSQLDetailsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeOasSQLDetailsResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.dbName)) {
      body["DbName"] = request.dbName;
    }

    if (!Util.isUnset(request.dynamicSql)) {
      body["DynamicSql"] = request.dynamicSql;
    }

    if (!Util.isUnset(request.endTime)) {
      body["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.parseTable)) {
      body["ParseTable"] = request.parseTable;
    }

    if (!Util.isUnset(request.sqlId)) {
      body["SqlId"] = request.sqlId;
    }

    if (!Util.isUnset(request.startTime)) {
      body["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeOasSQLDetails",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeOasSQLDetailsResponse>(await this.callApi(params, req, runtime), new DescribeOasSQLDetailsResponse({}));
  }

  /**
   * You can call this API to query detailed information about the SQL, including the SQL text, related table names, and so on.
   * 
   * @param request - DescribeOasSQLDetailsRequest
   * @returns DescribeOasSQLDetailsResponse
   */
  async describeOasSQLDetails(request: DescribeOasSQLDetailsRequest): Promise<DescribeOasSQLDetailsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeOasSQLDetailsWithOptions(request, runtime);
  }

  /**
   * You can call this API to view the SQL execution history.
   * 
   * @param request - DescribeOasSQLHistoryListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeOasSQLHistoryListResponse
   */
  async describeOasSQLHistoryListWithOptions(request: DescribeOasSQLHistoryListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeOasSQLHistoryListResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      body["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.dbName)) {
      body["DbName"] = request.dbName;
    }

    if (!Util.isUnset(request.dynamicSql)) {
      body["DynamicSql"] = request.dynamicSql;
    }

    if (!Util.isUnset(request.endTime)) {
      body["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.nodeIp)) {
      body["NodeIp"] = request.nodeIp;
    }

    if (!Util.isUnset(request.sqlId)) {
      body["SqlId"] = request.sqlId;
    }

    if (!Util.isUnset(request.startTime)) {
      body["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeOasSQLHistoryList",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeOasSQLHistoryListResponse>(await this.callApi(params, req, runtime), new DescribeOasSQLHistoryListResponse({}));
  }

  /**
   * You can call this API to view the SQL execution history.
   * 
   * @param request - DescribeOasSQLHistoryListRequest
   * @returns DescribeOasSQLHistoryListResponse
   */
  async describeOasSQLHistoryList(request: DescribeOasSQLHistoryListRequest): Promise<DescribeOasSQLHistoryListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeOasSQLHistoryListWithOptions(request, runtime);
  }

  /**
   * You can call this API to retrieve information about the SQL execution plan stored in the diagnostic system based on the SQL ID.
   * 
   * @param request - DescribeOasSQLPlansRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeOasSQLPlansResponse
   */
  async describeOasSQLPlansWithOptions(request: DescribeOasSQLPlansRequest, runtime: $Util.RuntimeOptions): Promise<DescribeOasSQLPlansResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      body["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.dbName)) {
      body["DbName"] = request.dbName;
    }

    if (!Util.isUnset(request.dynamicSql)) {
      body["DynamicSql"] = request.dynamicSql;
    }

    if (!Util.isUnset(request.endTime)) {
      body["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.planUnionHash)) {
      body["PlanUnionHash"] = request.planUnionHash;
    }

    if (!Util.isUnset(request.returnBriefInfo)) {
      body["ReturnBriefInfo"] = request.returnBriefInfo;
    }

    if (!Util.isUnset(request.sqlId)) {
      body["SqlId"] = request.sqlId;
    }

    if (!Util.isUnset(request.startTime)) {
      body["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeOasSQLPlans",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeOasSQLPlansResponse>(await this.callApi(params, req, runtime), new DescribeOasSQLPlansResponse({}));
  }

  /**
   * You can call this API to retrieve information about the SQL execution plan stored in the diagnostic system based on the SQL ID.
   * 
   * @param request - DescribeOasSQLPlansRequest
   * @returns DescribeOasSQLPlansResponse
   */
  async describeOasSQLPlans(request: DescribeOasSQLPlansRequest): Promise<DescribeOasSQLPlansResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeOasSQLPlansWithOptions(request, runtime);
  }

  /**
   * You can call this API to view a list of slow queries.
   * 
   * @param request - DescribeOasSlowSQLListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeOasSlowSQLListResponse
   */
  async describeOasSlowSQLListWithOptions(request: DescribeOasSlowSQLListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeOasSlowSQLListResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      body["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.dbName)) {
      body["DbName"] = request.dbName;
    }

    if (!Util.isUnset(request.dynamicSql)) {
      body["DynamicSql"] = request.dynamicSql;
    }

    if (!Util.isUnset(request.endTime)) {
      body["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.filterCondition)) {
      body["FilterCondition"] = request.filterCondition;
    }

    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.mergeDynamicSql)) {
      body["MergeDynamicSql"] = request.mergeDynamicSql;
    }

    if (!Util.isUnset(request.nodeIp)) {
      body["NodeIp"] = request.nodeIp;
    }

    if (!Util.isUnset(request.searchKeyWord)) {
      body["SearchKeyWord"] = request.searchKeyWord;
    }

    if (!Util.isUnset(request.searchParam)) {
      body["SearchParam"] = request.searchParam;
    }

    if (!Util.isUnset(request.searchRule)) {
      body["SearchRule"] = request.searchRule;
    }

    if (!Util.isUnset(request.searchValue)) {
      body["SearchValue"] = request.searchValue;
    }

    if (!Util.isUnset(request.sqlId)) {
      body["SqlId"] = request.sqlId;
    }

    if (!Util.isUnset(request.sqlTextLength)) {
      body["SqlTextLength"] = request.sqlTextLength;
    }

    if (!Util.isUnset(request.startTime)) {
      body["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeOasSlowSQLList",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeOasSlowSQLListResponse>(await this.callApi(params, req, runtime), new DescribeOasSlowSQLListResponse({}));
  }

  /**
   * You can call this API to view a list of slow queries.
   * 
   * @param request - DescribeOasSlowSQLListRequest
   * @returns DescribeOasSlowSQLListResponse
   */
  async describeOasSlowSQLList(request: DescribeOasSlowSQLListRequest): Promise<DescribeOasSlowSQLListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeOasSlowSQLListWithOptions(request, runtime);
  }

  /**
   * You can call this API to retrieve the list of data on the SQL execution performance collected by the diagnostic system.
   * 
   * @param request - DescribeOasTopSQLListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeOasTopSQLListResponse
   */
  async describeOasTopSQLListWithOptions(request: DescribeOasTopSQLListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeOasTopSQLListResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      body["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.dbName)) {
      body["DbName"] = request.dbName;
    }

    if (!Util.isUnset(request.dynamicSql)) {
      body["DynamicSql"] = request.dynamicSql;
    }

    if (!Util.isUnset(request.endTime)) {
      body["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.filterCondition)) {
      body["FilterCondition"] = request.filterCondition;
    }

    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.mergeDynamicSql)) {
      body["MergeDynamicSql"] = request.mergeDynamicSql;
    }

    if (!Util.isUnset(request.nodeIp)) {
      body["NodeIp"] = request.nodeIp;
    }

    if (!Util.isUnset(request.searchKeyWord)) {
      body["SearchKeyWord"] = request.searchKeyWord;
    }

    if (!Util.isUnset(request.searchParam)) {
      body["SearchParam"] = request.searchParam;
    }

    if (!Util.isUnset(request.searchRule)) {
      body["SearchRule"] = request.searchRule;
    }

    if (!Util.isUnset(request.searchValue)) {
      body["SearchValue"] = request.searchValue;
    }

    if (!Util.isUnset(request.sqlId)) {
      body["SqlId"] = request.sqlId;
    }

    if (!Util.isUnset(request.sqlTextLength)) {
      body["SqlTextLength"] = request.sqlTextLength;
    }

    if (!Util.isUnset(request.startTime)) {
      body["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeOasTopSQLList",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeOasTopSQLListResponse>(await this.callApi(params, req, runtime), new DescribeOasTopSQLListResponse({}));
  }

  /**
   * You can call this API to retrieve the list of data on the SQL execution performance collected by the diagnostic system.
   * 
   * @param request - DescribeOasTopSQLListRequest
   * @returns DescribeOasTopSQLListResponse
   */
  async describeOasTopSQLList(request: DescribeOasTopSQLListRequest): Promise<DescribeOasTopSQLListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeOasTopSQLListWithOptions(request, runtime);
  }

  /**
   * You can call this operation to query the outline binding information or throttling information of an SQL statement in the database based on an SQLID.
   * 
   * @param request - DescribeOutlineBindingRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeOutlineBindingResponse
   */
  async describeOutlineBindingWithOptions(request: DescribeOutlineBindingRequest, runtime: $Util.RuntimeOptions): Promise<DescribeOutlineBindingResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.databaseName)) {
      body["DatabaseName"] = request.databaseName;
    }

    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.isConcurrentLimit)) {
      body["IsConcurrentLimit"] = request.isConcurrentLimit;
    }

    if (!Util.isUnset(request.SQLId)) {
      body["SQLId"] = request.SQLId;
    }

    if (!Util.isUnset(request.tableName)) {
      body["TableName"] = request.tableName;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeOutlineBinding",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeOutlineBindingResponse>(await this.callApi(params, req, runtime), new DescribeOutlineBindingResponse({}));
  }

  /**
   * You can call this operation to query the outline binding information or throttling information of an SQL statement in the database based on an SQLID.
   * 
   * @param request - DescribeOutlineBindingRequest
   * @returns DescribeOutlineBindingResponse
   */
  async describeOutlineBinding(request: DescribeOutlineBindingRequest): Promise<DescribeOutlineBindingResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeOutlineBindingWithOptions(request, runtime);
  }

  /**
   * Indicates whether a restart is required for changes to the parameter to take effect. Valid values: - true: A restart is required. - false: A restart is not required.
   * 
   * @param request - DescribeParametersRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeParametersResponse
   */
  async describeParametersWithOptions(request: DescribeParametersRequest, runtime: $Util.RuntimeOptions): Promise<DescribeParametersResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.dimension)) {
      body["Dimension"] = request.dimension;
    }

    if (!Util.isUnset(request.dimensionValue)) {
      body["DimensionValue"] = request.dimensionValue;
    }

    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeParameters",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeParametersResponse>(await this.callApi(params, req, runtime), new DescribeParametersResponse({}));
  }

  /**
   * Indicates whether a restart is required for changes to the parameter to take effect. Valid values: - true: A restart is required. - false: A restart is not required.
   * 
   * @param request - DescribeParametersRequest
   * @returns DescribeParametersResponse
   */
  async describeParameters(request: DescribeParametersRequest): Promise<DescribeParametersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeParametersWithOptions(request, runtime);
  }

  /**
   * You can call this operation to query the modification history of cluster or tenant parameters.
   * 
   * @param request - DescribeParametersHistoryRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeParametersHistoryResponse
   */
  async describeParametersHistoryWithOptions(request: DescribeParametersHistoryRequest, runtime: $Util.RuntimeOptions): Promise<DescribeParametersHistoryResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.dimension)) {
      body["Dimension"] = request.dimension;
    }

    if (!Util.isUnset(request.dimensionValue)) {
      body["DimensionValue"] = request.dimensionValue;
    }

    if (!Util.isUnset(request.endTime)) {
      body["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.startTime)) {
      body["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeParametersHistory",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeParametersHistoryResponse>(await this.callApi(params, req, runtime), new DescribeParametersHistoryResponse({}));
  }

  /**
   * You can call this operation to query the modification history of cluster or tenant parameters.
   * 
   * @param request - DescribeParametersHistoryRequest
   * @returns DescribeParametersHistoryResponse
   */
  async describeParametersHistory(request: DescribeParametersHistoryRequest): Promise<DescribeParametersHistoryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeParametersHistoryWithOptions(request, runtime);
  }

  /**
   * You can call this operation to query session information.
   * 
   * @param request - DescribeProcessStatsCompositionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeProcessStatsCompositionResponse
   */
  async describeProcessStatsCompositionWithOptions(request: DescribeProcessStatsCompositionRequest, runtime: $Util.RuntimeOptions): Promise<DescribeProcessStatsCompositionResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.clientIp)) {
      body["ClientIp"] = request.clientIp;
    }

    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.serverIp)) {
      body["ServerIp"] = request.serverIp;
    }

    if (!Util.isUnset(request.sqlText)) {
      body["SqlText"] = request.sqlText;
    }

    if (!Util.isUnset(request.status)) {
      body["Status"] = request.status;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    if (!Util.isUnset(request.UId)) {
      body["UId"] = request.UId;
    }

    if (!Util.isUnset(request.users)) {
      body["Users"] = request.users;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeProcessStatsComposition",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeProcessStatsCompositionResponse>(await this.callApi(params, req, runtime), new DescribeProcessStatsCompositionResponse({}));
  }

  /**
   * You can call this operation to query session information.
   * 
   * @param request - DescribeProcessStatsCompositionRequest
   * @returns DescribeProcessStatsCompositionResponse
   */
  async describeProcessStatsComposition(request: DescribeProcessStatsCompositionRequest): Promise<DescribeProcessStatsCompositionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeProcessStatsCompositionWithOptions(request, runtime);
  }

  /**
   * 查询项目详情
   * 
   * @param request - DescribeProjectRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeProjectResponse
   */
  async describeProjectWithOptions(request: DescribeProjectRequest, runtime: $Util.RuntimeOptions): Promise<DescribeProjectResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.id)) {
      body["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeProject",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeProjectResponse>(await this.callApi(params, req, runtime), new DescribeProjectResponse({}));
  }

  /**
   * 查询项目详情
   * 
   * @param request - DescribeProjectRequest
   * @returns DescribeProjectResponse
   */
  async describeProject(request: DescribeProjectRequest): Promise<DescribeProjectResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeProjectWithOptions(request, runtime);
  }

  /**
   * 获取项目的组件信息
   * 
   * @param request - DescribeProjectComponentsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeProjectComponentsResponse
   */
  async describeProjectComponentsWithOptions(request: DescribeProjectComponentsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeProjectComponentsResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.id)) {
      body["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeProjectComponents",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeProjectComponentsResponse>(await this.callApi(params, req, runtime), new DescribeProjectComponentsResponse({}));
  }

  /**
   * 获取项目的组件信息
   * 
   * @param request - DescribeProjectComponentsRequest
   * @returns DescribeProjectComponentsResponse
   */
  async describeProjectComponents(request: DescribeProjectComponentsRequest): Promise<DescribeProjectComponentsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeProjectComponentsWithOptions(request, runtime);
  }

  /**
   * 获取迁移/同步项目 Progress 信息
   * 
   * @param request - DescribeProjectProgressRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeProjectProgressResponse
   */
  async describeProjectProgressWithOptions(request: DescribeProjectProgressRequest, runtime: $Util.RuntimeOptions): Promise<DescribeProjectProgressResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.id)) {
      body["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeProjectProgress",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeProjectProgressResponse>(await this.callApi(params, req, runtime), new DescribeProjectProgressResponse({}));
  }

  /**
   * 获取迁移/同步项目 Progress 信息
   * 
   * @param request - DescribeProjectProgressRequest
   * @returns DescribeProjectProgressResponse
   */
  async describeProjectProgress(request: DescribeProjectProgressRequest): Promise<DescribeProjectProgressResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeProjectProgressWithOptions(request, runtime);
  }

  /**
   * 查询项目步骤指标
   * 
   * @param request - DescribeProjectStepMetricRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeProjectStepMetricResponse
   */
  async describeProjectStepMetricWithOptions(request: DescribeProjectStepMetricRequest, runtime: $Util.RuntimeOptions): Promise<DescribeProjectStepMetricResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.aggregator)) {
      body["Aggregator"] = request.aggregator;
    }

    if (!Util.isUnset(request.beginTimestamp)) {
      body["BeginTimestamp"] = request.beginTimestamp;
    }

    if (!Util.isUnset(request.endTimestamp)) {
      body["EndTimestamp"] = request.endTimestamp;
    }

    if (!Util.isUnset(request.maxPointNum)) {
      body["MaxPointNum"] = request.maxPointNum;
    }

    if (!Util.isUnset(request.metricType)) {
      body["MetricType"] = request.metricType;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.stepName)) {
      body["StepName"] = request.stepName;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeProjectStepMetric",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeProjectStepMetricResponse>(await this.callApi(params, req, runtime), new DescribeProjectStepMetricResponse({}));
  }

  /**
   * 查询项目步骤指标
   * 
   * @param request - DescribeProjectStepMetricRequest
   * @returns DescribeProjectStepMetricResponse
   */
  async describeProjectStepMetric(request: DescribeProjectStepMetricRequest): Promise<DescribeProjectStepMetricResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeProjectStepMetricWithOptions(request, runtime);
  }

  /**
   * 查询项目步骤
   * 
   * @param request - DescribeProjectStepsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeProjectStepsResponse
   */
  async describeProjectStepsWithOptions(request: DescribeProjectStepsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeProjectStepsResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.id)) {
      body["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeProjectSteps",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeProjectStepsResponse>(await this.callApi(params, req, runtime), new DescribeProjectStepsResponse({}));
  }

  /**
   * 查询项目步骤
   * 
   * @param request - DescribeProjectStepsRequest
   * @returns DescribeProjectStepsResponse
   */
  async describeProjectSteps(request: DescribeProjectStepsRequest): Promise<DescribeProjectStepsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeProjectStepsWithOptions(request, runtime);
  }

  /**
   * The tenant mode.   Valid values:  
   * Oracle   
   * MySQL
   * 
   * @param request - DescribeRecommendIndexRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeRecommendIndexResponse
   */
  async describeRecommendIndexWithOptions(request: DescribeRecommendIndexRequest, runtime: $Util.RuntimeOptions): Promise<DescribeRecommendIndexResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.SQLId)) {
      body["SQLId"] = request.SQLId;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeRecommendIndex",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeRecommendIndexResponse>(await this.callApi(params, req, runtime), new DescribeRecommendIndexResponse({}));
  }

  /**
   * The tenant mode.   Valid values:  
   * Oracle   
   * MySQL
   * 
   * @param request - DescribeRecommendIndexRequest
   * @returns DescribeRecommendIndexResponse
   */
  async describeRecommendIndex(request: DescribeRecommendIndexRequest): Promise<DescribeRecommendIndexResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeRecommendIndexWithOptions(request, runtime);
  }

  /**
   * The username.
   * 
   * @param request - DescribeSQLDetailsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeSQLDetailsResponse
   */
  async describeSQLDetailsWithOptions(request: DescribeSQLDetailsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSQLDetailsResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.SQLId)) {
      body["SQLId"] = request.SQLId;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeSQLDetails",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSQLDetailsResponse>(await this.callApi(params, req, runtime), new DescribeSQLDetailsResponse({}));
  }

  /**
   * The username.
   * 
   * @param request - DescribeSQLDetailsRequest
   * @returns DescribeSQLDetailsResponse
   */
  async describeSQLDetails(request: DescribeSQLDetailsRequest): Promise<DescribeSQLDetailsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSQLDetailsWithOptions(request, runtime);
  }

  /**
   * You can call this operation to query the execution history of an SQL statement in a specified period based on an SQL ID.
   * 
   * @param request - DescribeSQLHistoryListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeSQLHistoryListResponse
   */
  async describeSQLHistoryListWithOptions(request: DescribeSQLHistoryListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSQLHistoryListResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.endTime)) {
      body["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.SQLId)) {
      body["SQLId"] = request.SQLId;
    }

    if (!Util.isUnset(request.startTime)) {
      body["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeSQLHistoryList",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSQLHistoryListResponse>(await this.callApi(params, req, runtime), new DescribeSQLHistoryListResponse({}));
  }

  /**
   * You can call this operation to query the execution history of an SQL statement in a specified period based on an SQL ID.
   * 
   * @param request - DescribeSQLHistoryListRequest
   * @returns DescribeSQLHistoryListResponse
   */
  async describeSQLHistoryList(request: DescribeSQLHistoryListRequest): Promise<DescribeSQLHistoryListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSQLHistoryListWithOptions(request, runtime);
  }

  /**
   * You can call this operation to query the information about the SQL execution plans stored in the diagnostic system based on an SQL ID.
   * 
   * @param request - DescribeSQLPlansRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeSQLPlansResponse
   */
  async describeSQLPlansWithOptions(request: DescribeSQLPlansRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSQLPlansResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.SQLId)) {
      body["SQLId"] = request.SQLId;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeSQLPlans",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSQLPlansResponse>(await this.callApi(params, req, runtime), new DescribeSQLPlansResponse({}));
  }

  /**
   * You can call this operation to query the information about the SQL execution plans stored in the diagnostic system based on an SQL ID.
   * 
   * @param request - DescribeSQLPlansRequest
   * @returns DescribeSQLPlansResponse
   */
  async describeSQLPlans(request: DescribeSQLPlansRequest): Promise<DescribeSQLPlansResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSQLPlansWithOptions(request, runtime);
  }

  /**
   * You can call this API to view the sample data of the execution details of the slow queries.
   * 
   * @param request - DescribeSQLSamplesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeSQLSamplesResponse
   */
  async describeSQLSamplesWithOptions(request: DescribeSQLSamplesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSQLSamplesResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.dbName)) {
      body["DbName"] = request.dbName;
    }

    if (!Util.isUnset(request.endTime)) {
      body["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.returnSqlText)) {
      body["ReturnSqlText"] = request.returnSqlText;
    }

    if (!Util.isUnset(request.sqlId)) {
      body["SqlId"] = request.sqlId;
    }

    if (!Util.isUnset(request.startTime)) {
      body["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeSQLSamples",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSQLSamplesResponse>(await this.callApi(params, req, runtime), new DescribeSQLSamplesResponse({}));
  }

  /**
   * You can call this API to view the sample data of the execution details of the slow queries.
   * 
   * @param request - DescribeSQLSamplesRequest
   * @returns DescribeSQLSamplesResponse
   */
  async describeSQLSamples(request: DescribeSQLSamplesRequest): Promise<DescribeSQLSamplesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSQLSamplesWithOptions(request, runtime);
  }

  /**
   * 获取单个 SQL 的调优建议，包括计划推荐和索引推荐
   * 
   * @param request - DescribeSQLTuningAdvicesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeSQLTuningAdvicesResponse
   */
  async describeSQLTuningAdvicesWithOptions(request: DescribeSQLTuningAdvicesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSQLTuningAdvicesResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      body["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.dbName)) {
      body["DbName"] = request.dbName;
    }

    if (!Util.isUnset(request.endTime)) {
      body["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.sqlId)) {
      body["SqlId"] = request.sqlId;
    }

    if (!Util.isUnset(request.startTime)) {
      body["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeSQLTuningAdvices",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSQLTuningAdvicesResponse>(await this.callApi(params, req, runtime), new DescribeSQLTuningAdvicesResponse({}));
  }

  /**
   * 获取单个 SQL 的调优建议，包括计划推荐和索引推荐
   * 
   * @param request - DescribeSQLTuningAdvicesRequest
   * @returns DescribeSQLTuningAdvicesResponse
   */
  async describeSQLTuningAdvices(request: DescribeSQLTuningAdvicesRequest): Promise<DescribeSQLTuningAdvicesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSQLTuningAdvicesWithOptions(request, runtime);
  }

  /**
   * 查询采样SQL的原始文本
   * 
   * @param request - DescribeSampleSqlRawTextsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeSampleSqlRawTextsResponse
   */
  async describeSampleSqlRawTextsWithOptions(request: DescribeSampleSqlRawTextsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSampleSqlRawTextsResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.dbName)) {
      body["DbName"] = request.dbName;
    }

    if (!Util.isUnset(request.endTime)) {
      body["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.limit)) {
      body["Limit"] = request.limit;
    }

    if (!Util.isUnset(request.sqlId)) {
      body["SqlId"] = request.sqlId;
    }

    if (!Util.isUnset(request.startTime)) {
      body["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    if (!Util.isUnset(request.traceId)) {
      body["TraceId"] = request.traceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeSampleSqlRawTexts",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSampleSqlRawTextsResponse>(await this.callApi(params, req, runtime), new DescribeSampleSqlRawTextsResponse({}));
  }

  /**
   * 查询采样SQL的原始文本
   * 
   * @param request - DescribeSampleSqlRawTextsRequest
   * @returns DescribeSampleSqlRawTextsResponse
   */
  async describeSampleSqlRawTexts(request: DescribeSampleSqlRawTextsRequest): Promise<DescribeSampleSqlRawTextsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSampleSqlRawTextsWithOptions(request, runtime);
  }

  /**
   * The name of the security group.
   * 
   * @param request - DescribeSecurityIpGroupsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeSecurityIpGroupsResponse
   */
  async describeSecurityIpGroupsWithOptions(request: DescribeSecurityIpGroupsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSecurityIpGroupsResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeSecurityIpGroups",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSecurityIpGroupsResponse>(await this.callApi(params, req, runtime), new DescribeSecurityIpGroupsResponse({}));
  }

  /**
   * The name of the security group.
   * 
   * @param request - DescribeSecurityIpGroupsRequest
   * @returns DescribeSecurityIpGroupsResponse
   */
  async describeSecurityIpGroups(request: DescribeSecurityIpGroupsRequest): Promise<DescribeSecurityIpGroupsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSecurityIpGroupsWithOptions(request, runtime);
  }

  /**
   * You can call this operation to query sessions between the ApsaraDB for OceanBase and the application.
   * 
   * @param request - DescribeSessionListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeSessionListResponse
   */
  async describeSessionListWithOptions(request: DescribeSessionListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSessionListResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeSessionList",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSessionListResponse>(await this.callApi(params, req, runtime), new DescribeSessionListResponse({}));
  }

  /**
   * You can call this operation to query sessions between the ApsaraDB for OceanBase and the application.
   * 
   * @param request - DescribeSessionListRequest
   * @returns DescribeSessionListResponse
   */
  async describeSessionList(request: DescribeSessionListRequest): Promise<DescribeSessionListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSessionListWithOptions(request, runtime);
  }

  /**
   * You can call this operation to query the execution history of an SQL statement by SQL ID that is determined as a slow SQL statement during a specified period of time.
   * 
   * @param request - DescribeSlowSQLHistoryListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeSlowSQLHistoryListResponse
   */
  async describeSlowSQLHistoryListWithOptions(request: DescribeSlowSQLHistoryListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSlowSQLHistoryListResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.endTime)) {
      body["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.SQLId)) {
      body["SQLId"] = request.SQLId;
    }

    if (!Util.isUnset(request.startTime)) {
      body["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeSlowSQLHistoryList",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSlowSQLHistoryListResponse>(await this.callApi(params, req, runtime), new DescribeSlowSQLHistoryListResponse({}));
  }

  /**
   * You can call this operation to query the execution history of an SQL statement by SQL ID that is determined as a slow SQL statement during a specified period of time.
   * 
   * @param request - DescribeSlowSQLHistoryListRequest
   * @returns DescribeSlowSQLHistoryListResponse
   */
  async describeSlowSQLHistoryList(request: DescribeSlowSQLHistoryListRequest): Promise<DescribeSlowSQLHistoryListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSlowSQLHistoryListWithOptions(request, runtime);
  }

  /**
   * You can call this operation to query the list of slow SQL statements
   * 
   * @param tmpReq - DescribeSlowSQLListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeSlowSQLListResponse
   */
  async describeSlowSQLListWithOptions(tmpReq: DescribeSlowSQLListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSlowSQLListResponse> {
    Util.validateModel(tmpReq);
    let request = new DescribeSlowSQLListShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.filterCondition)) {
      request.filterConditionShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.filterCondition, "FilterCondition", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.dbName)) {
      body["DbName"] = request.dbName;
    }

    if (!Util.isUnset(request.endTime)) {
      body["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.filterConditionShrink)) {
      body["FilterCondition"] = request.filterConditionShrink;
    }

    if (!Util.isUnset(request.nodeIp)) {
      body["NodeIp"] = request.nodeIp;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.SQLId)) {
      body["SQLId"] = request.SQLId;
    }

    if (!Util.isUnset(request.searchKeyWord)) {
      body["SearchKeyWord"] = request.searchKeyWord;
    }

    if (!Util.isUnset(request.searchParameter)) {
      body["SearchParameter"] = request.searchParameter;
    }

    if (!Util.isUnset(request.searchRule)) {
      body["SearchRule"] = request.searchRule;
    }

    if (!Util.isUnset(request.searchValue)) {
      body["SearchValue"] = request.searchValue;
    }

    if (!Util.isUnset(request.sortColumn)) {
      body["SortColumn"] = request.sortColumn;
    }

    if (!Util.isUnset(request.sortOrder)) {
      body["SortOrder"] = request.sortOrder;
    }

    if (!Util.isUnset(request.startTime)) {
      body["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeSlowSQLList",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSlowSQLListResponse>(await this.callApi(params, req, runtime), new DescribeSlowSQLListResponse({}));
  }

  /**
   * You can call this operation to query the list of slow SQL statements
   * 
   * @param request - DescribeSlowSQLListRequest
   * @returns DescribeSlowSQLListResponse
   */
  async describeSlowSQLList(request: DescribeSlowSQLListRequest): Promise<DescribeSlowSQLListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSlowSQLListWithOptions(request, runtime);
  }

  /**
   * You can call this operation to query tags.
   * 
   * @param request - DescribeTagValuesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeTagValuesResponse
   */
  async describeTagValuesWithOptions(request: DescribeTagValuesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeTagValuesResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.resourceType)) {
      body["ResourceType"] = request.resourceType;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeTagValues",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeTagValuesResponse>(await this.callApi(params, req, runtime), new DescribeTagValuesResponse({}));
  }

  /**
   * You can call this operation to query tags.
   * 
   * @param request - DescribeTagValuesRequest
   * @returns DescribeTagValuesResponse
   */
  async describeTagValues(request: DescribeTagValuesRequest): Promise<DescribeTagValuesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeTagValuesWithOptions(request, runtime);
  }

  /**
   * The ID of the VPC.
   * 
   * @param request - DescribeTenantRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeTenantResponse
   */
  async describeTenantWithOptions(request: DescribeTenantRequest, runtime: $Util.RuntimeOptions): Promise<DescribeTenantResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeTenant",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeTenantResponse>(await this.callApi(params, req, runtime), new DescribeTenantResponse({}));
  }

  /**
   * The ID of the VPC.
   * 
   * @param request - DescribeTenantRequest
   * @returns DescribeTenantResponse
   */
  async describeTenant(request: DescribeTenantRequest): Promise<DescribeTenantResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeTenantWithOptions(request, runtime);
  }

  /**
   * 查询租户加密信息
   * 
   * @param request - DescribeTenantEncryptionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeTenantEncryptionResponse
   */
  async describeTenantEncryptionWithOptions(request: DescribeTenantEncryptionRequest, runtime: $Util.RuntimeOptions): Promise<DescribeTenantEncryptionResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    if (!Util.isUnset(request.tenantName)) {
      body["TenantName"] = request.tenantName;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeTenantEncryption",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeTenantEncryptionResponse>(await this.callApi(params, req, runtime), new DescribeTenantEncryptionResponse({}));
  }

  /**
   * 查询租户加密信息
   * 
   * @param request - DescribeTenantEncryptionRequest
   * @returns DescribeTenantEncryptionResponse
   */
  async describeTenantEncryption(request: DescribeTenantEncryptionRequest): Promise<DescribeTenantEncryptionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeTenantEncryptionWithOptions(request, runtime);
  }

  /**
   * The list of tenant IDs.
   * 
   * @param request - DescribeTenantMetricsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeTenantMetricsResponse
   */
  async describeTenantMetricsWithOptions(request: DescribeTenantMetricsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeTenantMetricsResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.endTime)) {
      body["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.metrics)) {
      body["Metrics"] = request.metrics;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.startTime)) {
      body["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    if (!Util.isUnset(request.tenantIdList)) {
      body["TenantIdList"] = request.tenantIdList;
    }

    if (!Util.isUnset(request.tenantName)) {
      body["TenantName"] = request.tenantName;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeTenantMetrics",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeTenantMetricsResponse>(await this.callApi(params, req, runtime), new DescribeTenantMetricsResponse({}));
  }

  /**
   * The list of tenant IDs.
   * 
   * @param request - DescribeTenantMetricsRequest
   * @returns DescribeTenantMetricsResponse
   */
  async describeTenantMetrics(request: DescribeTenantMetricsRequest): Promise<DescribeTenantMetricsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeTenantMetricsWithOptions(request, runtime);
  }

  /**
   * You can call this operation to query the maximum readable timestamp of a tenant.
   * 
   * @param request - DescribeTenantReadableScnRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeTenantReadableScnResponse
   */
  async describeTenantReadableScnWithOptions(request: DescribeTenantReadableScnRequest, runtime: $Util.RuntimeOptions): Promise<DescribeTenantReadableScnResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeTenantReadableScn",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeTenantReadableScnResponse>(await this.callApi(params, req, runtime), new DescribeTenantReadableScnResponse({}));
  }

  /**
   * You can call this operation to query the maximum readable timestamp of a tenant.
   * 
   * @param request - DescribeTenantReadableScnRequest
   * @returns DescribeTenantReadableScnResponse
   */
  async describeTenantReadableScn(request: DescribeTenantReadableScnRequest): Promise<DescribeTenantReadableScnResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeTenantReadableScnWithOptions(request, runtime);
  }

  /**
   * You can call this operation to query security check items of an OceanBase Database tenant.
   * 
   * @param request - DescribeTenantSecurityConfigsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeTenantSecurityConfigsResponse
   */
  async describeTenantSecurityConfigsWithOptions(request: DescribeTenantSecurityConfigsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeTenantSecurityConfigsResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.checkId)) {
      body["CheckId"] = request.checkId;
    }

    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeTenantSecurityConfigs",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeTenantSecurityConfigsResponse>(await this.callApi(params, req, runtime), new DescribeTenantSecurityConfigsResponse({}));
  }

  /**
   * You can call this operation to query security check items of an OceanBase Database tenant.
   * 
   * @param request - DescribeTenantSecurityConfigsRequest
   * @returns DescribeTenantSecurityConfigsResponse
   */
  async describeTenantSecurityConfigs(request: DescribeTenantSecurityConfigsRequest): Promise<DescribeTenantSecurityConfigsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeTenantSecurityConfigsWithOptions(request, runtime);
  }

  /**
   * You can call this operation to view the list of whitelist groups of the tenant.
   * 
   * @param request - DescribeTenantSecurityIpGroupsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeTenantSecurityIpGroupsResponse
   */
  async describeTenantSecurityIpGroupsWithOptions(request: DescribeTenantSecurityIpGroupsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeTenantSecurityIpGroupsResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeTenantSecurityIpGroups",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeTenantSecurityIpGroupsResponse>(await this.callApi(params, req, runtime), new DescribeTenantSecurityIpGroupsResponse({}));
  }

  /**
   * You can call this operation to view the list of whitelist groups of the tenant.
   * 
   * @param request - DescribeTenantSecurityIpGroupsRequest
   * @returns DescribeTenantSecurityIpGroupsResponse
   */
  async describeTenantSecurityIpGroups(request: DescribeTenantSecurityIpGroupsRequest): Promise<DescribeTenantSecurityIpGroupsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeTenantSecurityIpGroupsWithOptions(request, runtime);
  }

  /**
   * You can call this operation to query the tags of tenants in a cluster.
   * 
   * @param request - DescribeTenantTagsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeTenantTagsResponse
   */
  async describeTenantTagsWithOptions(request: DescribeTenantTagsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeTenantTagsResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.tags)) {
      body["Tags"] = request.tags;
    }

    if (!Util.isUnset(request.tenantIds)) {
      body["TenantIds"] = request.tenantIds;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeTenantTags",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeTenantTagsResponse>(await this.callApi(params, req, runtime), new DescribeTenantTagsResponse({}));
  }

  /**
   * You can call this operation to query the tags of tenants in a cluster.
   * 
   * @param request - DescribeTenantTagsRequest
   * @returns DescribeTenantTagsResponse
   */
  async describeTenantTags(request: DescribeTenantTagsRequest): Promise<DescribeTenantTagsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeTenantTagsWithOptions(request, runtime);
  }

  /**
   * You can call this operation to obtain the account authorization information of the tenant.
   * 
   * @param request - DescribeTenantUserRolesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeTenantUserRolesResponse
   */
  async describeTenantUserRolesWithOptions(request: DescribeTenantUserRolesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeTenantUserRolesResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeTenantUserRoles",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeTenantUserRolesResponse>(await this.callApi(params, req, runtime), new DescribeTenantUserRolesResponse({}));
  }

  /**
   * You can call this operation to obtain the account authorization information of the tenant.
   * 
   * @param request - DescribeTenantUserRolesRequest
   * @returns DescribeTenantUserRolesResponse
   */
  async describeTenantUserRoles(request: DescribeTenantUserRolesRequest): Promise<DescribeTenantUserRolesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeTenantUserRolesWithOptions(request, runtime);
  }

  /**
   * The return result of the request.
   * 
   * @param request - DescribeTenantUsersRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeTenantUsersResponse
   */
  async describeTenantUsersWithOptions(request: DescribeTenantUsersRequest, runtime: $Util.RuntimeOptions): Promise<DescribeTenantUsersResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.searchKey)) {
      body["SearchKey"] = request.searchKey;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    if (!Util.isUnset(request.userName)) {
      body["UserName"] = request.userName;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeTenantUsers",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeTenantUsersResponse>(await this.callApi(params, req, runtime), new DescribeTenantUsersResponse({}));
  }

  /**
   * The return result of the request.
   * 
   * @param request - DescribeTenantUsersRequest
   * @returns DescribeTenantUsersResponse
   */
  async describeTenantUsers(request: DescribeTenantUsersRequest): Promise<DescribeTenantUsersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeTenantUsersWithOptions(request, runtime);
  }

  /**
   * Indicates whether a read-only connection has been created.
   * 
   * @param request - DescribeTenantZonesReadRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeTenantZonesReadResponse
   */
  async describeTenantZonesReadWithOptions(request: DescribeTenantZonesReadRequest, runtime: $Util.RuntimeOptions): Promise<DescribeTenantZonesReadResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeTenantZonesRead",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeTenantZonesReadResponse>(await this.callApi(params, req, runtime), new DescribeTenantZonesReadResponse({}));
  }

  /**
   * Indicates whether a read-only connection has been created.
   * 
   * @param request - DescribeTenantZonesReadRequest
   * @returns DescribeTenantZonesReadResponse
   */
  async describeTenantZonesRead(request: DescribeTenantZonesReadRequest): Promise<DescribeTenantZonesReadResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeTenantZonesReadWithOptions(request, runtime);
  }

  /**
   * The total memory size of the tenant, in GB.
   * 
   * @param request - DescribeTenantsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeTenantsResponse
   */
  async describeTenantsWithOptions(request: DescribeTenantsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeTenantsResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.searchKey)) {
      body["SearchKey"] = request.searchKey;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    if (!Util.isUnset(request.tenantName)) {
      body["TenantName"] = request.tenantName;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeTenants",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeTenantsResponse>(await this.callApi(params, req, runtime), new DescribeTenantsResponse({}));
  }

  /**
   * The total memory size of the tenant, in GB.
   * 
   * @param request - DescribeTenantsRequest
   * @returns DescribeTenantsResponse
   */
  async describeTenants(request: DescribeTenantsRequest): Promise<DescribeTenantsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeTenantsWithOptions(request, runtime);
  }

  /**
   * The time zones supported by the tenant.
   * 
   * @param request - DescribeTimeZonesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeTimeZonesResponse
   */
  async describeTimeZonesWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeTimeZonesResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeTimeZones",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeTimeZonesResponse>(await this.callApi(params, req, runtime), new DescribeTimeZonesResponse({}));
  }

  /**
   * The time zones supported by the tenant.
   * @returns DescribeTimeZonesResponse
   */
  async describeTimeZones(): Promise<DescribeTimeZonesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeTimeZonesWithOptions(runtime);
  }

  /**
   * The name of the database.
   * 
   * @param tmpReq - DescribeTopSQLListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeTopSQLListResponse
   */
  async describeTopSQLListWithOptions(tmpReq: DescribeTopSQLListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeTopSQLListResponse> {
    Util.validateModel(tmpReq);
    let request = new DescribeTopSQLListShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.filterCondition)) {
      request.filterConditionShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.filterCondition, "FilterCondition", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.dbName)) {
      body["DbName"] = request.dbName;
    }

    if (!Util.isUnset(request.endTime)) {
      body["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.filterConditionShrink)) {
      body["FilterCondition"] = request.filterConditionShrink;
    }

    if (!Util.isUnset(request.nodeIp)) {
      body["NodeIp"] = request.nodeIp;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.SQLId)) {
      body["SQLId"] = request.SQLId;
    }

    if (!Util.isUnset(request.searchKeyWord)) {
      body["SearchKeyWord"] = request.searchKeyWord;
    }

    if (!Util.isUnset(request.searchParameter)) {
      body["SearchParameter"] = request.searchParameter;
    }

    if (!Util.isUnset(request.searchRule)) {
      body["SearchRule"] = request.searchRule;
    }

    if (!Util.isUnset(request.searchValue)) {
      body["SearchValue"] = request.searchValue;
    }

    if (!Util.isUnset(request.sortColumn)) {
      body["SortColumn"] = request.sortColumn;
    }

    if (!Util.isUnset(request.sortOrder)) {
      body["SortOrder"] = request.sortOrder;
    }

    if (!Util.isUnset(request.startTime)) {
      body["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeTopSQLList",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeTopSQLListResponse>(await this.callApi(params, req, runtime), new DescribeTopSQLListResponse({}));
  }

  /**
   * The name of the database.
   * 
   * @param request - DescribeTopSQLListRequest
   * @returns DescribeTopSQLListResponse
   */
  async describeTopSQLList(request: DescribeTopSQLListRequest): Promise<DescribeTopSQLListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeTopSQLListWithOptions(request, runtime);
  }

  /**
   * The deployment mode.
   * 
   * @param request - DescribeZonesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeZonesResponse
   */
  async describeZonesWithOptions(request: DescribeZonesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeZonesResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.cpuArch)) {
      body["CpuArch"] = request.cpuArch;
    }

    if (!Util.isUnset(request.deployType)) {
      body["DeployType"] = request.deployType;
    }

    if (!Util.isUnset(request.series)) {
      body["Series"] = request.series;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeZones",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeZonesResponse>(await this.callApi(params, req, runtime), new DescribeZonesResponse({}));
  }

  /**
   * The deployment mode.
   * 
   * @param request - DescribeZonesRequest
   * @returns DescribeZonesResponse
   */
  async describeZones(request: DescribeZonesRequest): Promise<DescribeZonesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeZonesWithOptions(request, runtime);
  }

  /**
   * 公有云上传OSS 获取一个临时上传url
   * 
   * @param request - GetUploadOssUrlRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetUploadOssUrlResponse
   */
  async getUploadOssUrlWithOptions(request: GetUploadOssUrlRequest, runtime: $Util.RuntimeOptions): Promise<GetUploadOssUrlResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.effectiveTimeMinutes)) {
      body["EffectiveTimeMinutes"] = request.effectiveTimeMinutes;
    }

    if (!Util.isUnset(request.type)) {
      body["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetUploadOssUrl",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetUploadOssUrlResponse>(await this.callApi(params, req, runtime), new GetUploadOssUrlResponse({}));
  }

  /**
   * 公有云上传OSS 获取一个临时上传url
   * 
   * @param request - GetUploadOssUrlRequest
   * @returns GetUploadOssUrlResponse
   */
  async getUploadOssUrl(request: GetUploadOssUrlRequest): Promise<GetUploadOssUrlResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getUploadOssUrlWithOptions(request, runtime);
  }

  /**
   * You can call this operation to close a session.
   * 
   * @param request - KillProcessListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns KillProcessListResponse
   */
  async killProcessListWithOptions(request: KillProcessListRequest, runtime: $Util.RuntimeOptions): Promise<KillProcessListResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.sessionList)) {
      body["SessionList"] = request.sessionList;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "KillProcessList",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<KillProcessListResponse>(await this.callApi(params, req, runtime), new KillProcessListResponse({}));
  }

  /**
   * You can call this operation to close a session.
   * 
   * @param request - KillProcessListRequest
   * @returns KillProcessListResponse
   */
  async killProcessList(request: KillProcessListRequest): Promise<KillProcessListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.killProcessListWithOptions(request, runtime);
  }

  /**
   * 查询标签列表
   * 
   * @param request - ListAllLabelsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListAllLabelsResponse
   */
  async listAllLabelsWithOptions(runtime: $Util.RuntimeOptions): Promise<ListAllLabelsResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "ListAllLabels",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListAllLabelsResponse>(await this.callApi(params, req, runtime), new ListAllLabelsResponse({}));
  }

  /**
   * 查询标签列表
   * @returns ListAllLabelsResponse
   */
  async listAllLabels(): Promise<ListAllLabelsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listAllLabelsWithOptions(runtime);
  }

  /**
   * 查询数据源列表 (MySql、OB_MYSQL、OB_ORACLE)
   * 
   * @param tmpReq - ListDataSourceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListDataSourceResponse
   */
  async listDataSourceWithOptions(tmpReq: ListDataSourceRequest, runtime: $Util.RuntimeOptions): Promise<ListDataSourceResponse> {
    Util.validateModel(tmpReq);
    let request = new ListDataSourceShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.types)) {
      request.typesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.types, "Types", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.order)) {
      body["Order"] = request.order;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.searchKey)) {
      body["SearchKey"] = request.searchKey;
    }

    if (!Util.isUnset(request.sortField)) {
      body["SortField"] = request.sortField;
    }

    if (!Util.isUnset(request.typesShrink)) {
      body["Types"] = request.typesShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListDataSource",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListDataSourceResponse>(await this.callApi(params, req, runtime), new ListDataSourceResponse({}));
  }

  /**
   * 查询数据源列表 (MySql、OB_MYSQL、OB_ORACLE)
   * 
   * @param request - ListDataSourceRequest
   * @returns ListDataSourceResponse
   */
  async listDataSource(request: ListDataSourceRequest): Promise<ListDataSourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDataSourceWithOptions(request, runtime);
  }

  /**
   * 查询项目的全量校验结果
   * 
   * @param tmpReq - ListProjectFullVerifyResultRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListProjectFullVerifyResultResponse
   */
  async listProjectFullVerifyResultWithOptions(tmpReq: ListProjectFullVerifyResultRequest, runtime: $Util.RuntimeOptions): Promise<ListProjectFullVerifyResultResponse> {
    Util.validateModel(tmpReq);
    let request = new ListProjectFullVerifyResultShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.destSchemas)) {
      request.destSchemasShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.destSchemas, "DestSchemas", "json");
    }

    if (!Util.isUnset(tmpReq.sourceSchemas)) {
      request.sourceSchemasShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sourceSchemas, "SourceSchemas", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.destSchemasShrink)) {
      body["DestSchemas"] = request.destSchemasShrink;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.sourceSchemasShrink)) {
      body["SourceSchemas"] = request.sourceSchemasShrink;
    }

    if (!Util.isUnset(request.status)) {
      body["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListProjectFullVerifyResult",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListProjectFullVerifyResultResponse>(await this.callApi(params, req, runtime), new ListProjectFullVerifyResultResponse({}));
  }

  /**
   * 查询项目的全量校验结果
   * 
   * @param request - ListProjectFullVerifyResultRequest
   * @returns ListProjectFullVerifyResultResponse
   */
  async listProjectFullVerifyResult(request: ListProjectFullVerifyResultRequest): Promise<ListProjectFullVerifyResultResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listProjectFullVerifyResultWithOptions(request, runtime);
  }

  /**
   * 根据项目 ID 查询项目的修改记录
   * 
   * @param request - ListProjectModifyRecordsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListProjectModifyRecordsResponse
   */
  async listProjectModifyRecordsWithOptions(request: ListProjectModifyRecordsRequest, runtime: $Util.RuntimeOptions): Promise<ListProjectModifyRecordsResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.id)) {
      body["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListProjectModifyRecords",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListProjectModifyRecordsResponse>(await this.callApi(params, req, runtime), new ListProjectModifyRecordsResponse({}));
  }

  /**
   * 根据项目 ID 查询项目的修改记录
   * 
   * @param request - ListProjectModifyRecordsRequest
   * @returns ListProjectModifyRecordsResponse
   */
  async listProjectModifyRecords(request: ListProjectModifyRecordsRequest): Promise<ListProjectModifyRecordsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listProjectModifyRecordsWithOptions(request, runtime);
  }

  /**
   * 查询项目列表
   * 
   * @param tmpReq - ListProjectsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListProjectsResponse
   */
  async listProjectsWithOptions(tmpReq: ListProjectsRequest, runtime: $Util.RuntimeOptions): Promise<ListProjectsResponse> {
    Util.validateModel(tmpReq);
    let request = new ListProjectsShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.labelIds)) {
      request.labelIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.labelIds, "LabelIds", "json");
    }

    if (!Util.isUnset(tmpReq.sinkEndpointTypes)) {
      request.sinkEndpointTypesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sinkEndpointTypes, "SinkEndpointTypes", "json");
    }

    if (!Util.isUnset(tmpReq.sourceEndpointTypes)) {
      request.sourceEndpointTypesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sourceEndpointTypes, "SourceEndpointTypes", "json");
    }

    if (!Util.isUnset(tmpReq.status)) {
      request.statusShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.status, "Status", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.labelIdsShrink)) {
      body["LabelIds"] = request.labelIdsShrink;
    }

    if (!Util.isUnset(request.needRelatedInfo)) {
      body["NeedRelatedInfo"] = request.needRelatedInfo;
    }

    if (!Util.isUnset(request.order)) {
      body["Order"] = request.order;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.searchKey)) {
      body["SearchKey"] = request.searchKey;
    }

    if (!Util.isUnset(request.sinkEndpointTypesShrink)) {
      body["SinkEndpointTypes"] = request.sinkEndpointTypesShrink;
    }

    if (!Util.isUnset(request.sortField)) {
      body["SortField"] = request.sortField;
    }

    if (!Util.isUnset(request.sourceEndpointTypesShrink)) {
      body["SourceEndpointTypes"] = request.sourceEndpointTypesShrink;
    }

    if (!Util.isUnset(request.statusShrink)) {
      body["Status"] = request.statusShrink;
    }

    if (!Util.isUnset(request.type)) {
      body["Type"] = request.type;
    }

    if (!Util.isUnset(request.visibleSubProject)) {
      body["VisibleSubProject"] = request.visibleSubProject;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListProjects",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListProjectsResponse>(await this.callApi(params, req, runtime), new ListProjectsResponse({}));
  }

  /**
   * 查询项目列表
   * 
   * @param request - ListProjectsRequest
   * @returns ListProjectsResponse
   */
  async listProjects(request: ListProjectsRequest): Promise<ListProjectsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listProjectsWithOptions(request, runtime);
  }

  /**
   * 查询传输实例列表
   * 
   * @param tmpReq - ListWorkerInstancesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListWorkerInstancesResponse
   */
  async listWorkerInstancesWithOptions(tmpReq: ListWorkerInstancesRequest, runtime: $Util.RuntimeOptions): Promise<ListWorkerInstancesResponse> {
    Util.validateModel(tmpReq);
    let request = new ListWorkerInstancesShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.specs)) {
      request.specsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.specs, "Specs", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.destType)) {
      body["DestType"] = request.destType;
    }

    if (!Util.isUnset(request.instanceName)) {
      body["InstanceName"] = request.instanceName;
    }

    if (!Util.isUnset(request.onlyBindable)) {
      body["OnlyBindable"] = request.onlyBindable;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.sourceType)) {
      body["SourceType"] = request.sourceType;
    }

    if (!Util.isUnset(request.specsShrink)) {
      body["Specs"] = request.specsShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListWorkerInstances",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListWorkerInstancesResponse>(await this.callApi(params, req, runtime), new ListWorkerInstancesResponse({}));
  }

  /**
   * 查询传输实例列表
   * 
   * @param request - ListWorkerInstancesRequest
   * @returns ListWorkerInstancesResponse
   */
  async listWorkerInstances(request: ListWorkerInstancesRequest): Promise<ListWorkerInstancesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listWorkerInstancesWithOptions(request, runtime);
  }

  /**
   * The request ID.
   * 
   * @param request - ModifyDatabaseDescriptionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyDatabaseDescriptionResponse
   */
  async modifyDatabaseDescriptionWithOptions(request: ModifyDatabaseDescriptionRequest, runtime: $Util.RuntimeOptions): Promise<ModifyDatabaseDescriptionResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.databaseName)) {
      body["DatabaseName"] = request.databaseName;
    }

    if (!Util.isUnset(request.description)) {
      body["Description"] = request.description;
    }

    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ModifyDatabaseDescription",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyDatabaseDescriptionResponse>(await this.callApi(params, req, runtime), new ModifyDatabaseDescriptionResponse({}));
  }

  /**
   * The request ID.
   * 
   * @param request - ModifyDatabaseDescriptionRequest
   * @returns ModifyDatabaseDescriptionResponse
   */
  async modifyDatabaseDescription(request: ModifyDatabaseDescriptionRequest): Promise<ModifyDatabaseDescriptionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyDatabaseDescriptionWithOptions(request, runtime);
  }

  /**
   * The accounts that have privileges on the database.
   * 
   * @param request - ModifyDatabaseUserRolesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyDatabaseUserRolesResponse
   */
  async modifyDatabaseUserRolesWithOptions(request: ModifyDatabaseUserRolesRequest, runtime: $Util.RuntimeOptions): Promise<ModifyDatabaseUserRolesResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.databaseName)) {
      body["DatabaseName"] = request.databaseName;
    }

    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    if (!Util.isUnset(request.users)) {
      body["Users"] = request.users;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ModifyDatabaseUserRoles",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyDatabaseUserRolesResponse>(await this.callApi(params, req, runtime), new ModifyDatabaseUserRolesResponse({}));
  }

  /**
   * The accounts that have privileges on the database.
   * 
   * @param request - ModifyDatabaseUserRolesRequest
   * @returns ModifyDatabaseUserRolesResponse
   */
  async modifyDatabaseUserRoles(request: ModifyDatabaseUserRolesRequest): Promise<ModifyDatabaseUserRolesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyDatabaseUserRolesWithOptions(request, runtime);
  }

  /**
   * The name of the OceanBase cluster.
   * 
   * @param request - ModifyInstanceNameRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyInstanceNameResponse
   */
  async modifyInstanceNameWithOptions(request: ModifyInstanceNameRequest, runtime: $Util.RuntimeOptions): Promise<ModifyInstanceNameResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.instanceName)) {
      body["InstanceName"] = request.instanceName;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ModifyInstanceName",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyInstanceNameResponse>(await this.callApi(params, req, runtime), new ModifyInstanceNameResponse({}));
  }

  /**
   * The name of the OceanBase cluster.
   * 
   * @param request - ModifyInstanceNameRequest
   * @returns ModifyInstanceNameResponse
   */
  async modifyInstanceName(request: ModifyInstanceNameRequest): Promise<ModifyInstanceNameResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyInstanceNameWithOptions(request, runtime);
  }

  /**
   * You can call this operation to modify the number of nodes in a cluster.
   * 
   * @param request - ModifyInstanceNodeNumRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyInstanceNodeNumResponse
   */
  async modifyInstanceNodeNumWithOptions(request: ModifyInstanceNodeNumRequest, runtime: $Util.RuntimeOptions): Promise<ModifyInstanceNodeNumResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.dryRun)) {
      body["DryRun"] = request.dryRun;
    }

    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.nodeNum)) {
      body["NodeNum"] = request.nodeNum;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ModifyInstanceNodeNum",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyInstanceNodeNumResponse>(await this.callApi(params, req, runtime), new ModifyInstanceNodeNumResponse({}));
  }

  /**
   * You can call this operation to modify the number of nodes in a cluster.
   * 
   * @param request - ModifyInstanceNodeNumRequest
   * @returns ModifyInstanceNodeNumResponse
   */
  async modifyInstanceNodeNum(request: ModifyInstanceNodeNumRequest): Promise<ModifyInstanceNodeNumResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyInstanceNodeNumWithOptions(request, runtime);
  }

  /**
   * You can call this operation to modify the Secure Sockets Layer (SSL) setting for an OceanBase cluster instance.
   * 
   * @remarks
   * There is currently no authorization information disclosed in the API.
   * 
   * @param request - ModifyInstanceSSLRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyInstanceSSLResponse
   */
  async modifyInstanceSSLWithOptions(request: ModifyInstanceSSLRequest, runtime: $Util.RuntimeOptions): Promise<ModifyInstanceSSLResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.enableSSL)) {
      body["EnableSSL"] = request.enableSSL;
    }

    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ModifyInstanceSSL",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyInstanceSSLResponse>(await this.callApi(params, req, runtime), new ModifyInstanceSSLResponse({}));
  }

  /**
   * You can call this operation to modify the Secure Sockets Layer (SSL) setting for an OceanBase cluster instance.
   * 
   * @remarks
   * There is currently no authorization information disclosed in the API.
   * 
   * @param request - ModifyInstanceSSLRequest
   * @returns ModifyInstanceSSLResponse
   */
  async modifyInstanceSSL(request: ModifyInstanceSSLRequest): Promise<ModifyInstanceSSLResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyInstanceSSLWithOptions(request, runtime);
  }

  /**
   * You can call this operation to modify the cluster specifications and storage space.
   * 
   * @param request - ModifyInstanceSpecRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyInstanceSpecResponse
   */
  async modifyInstanceSpecWithOptions(request: ModifyInstanceSpecRequest, runtime: $Util.RuntimeOptions): Promise<ModifyInstanceSpecResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.diskSize)) {
      body["DiskSize"] = request.diskSize;
    }

    if (!Util.isUnset(request.diskType)) {
      body["DiskType"] = request.diskType;
    }

    if (!Util.isUnset(request.dryRun)) {
      body["DryRun"] = request.dryRun;
    }

    if (!Util.isUnset(request.instanceClass)) {
      body["InstanceClass"] = request.instanceClass;
    }

    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.upgradeSpecNative)) {
      body["UpgradeSpecNative"] = request.upgradeSpecNative;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ModifyInstanceSpec",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyInstanceSpecResponse>(await this.callApi(params, req, runtime), new ModifyInstanceSpecResponse({}));
  }

  /**
   * You can call this operation to modify the cluster specifications and storage space.
   * 
   * @param request - ModifyInstanceSpecRequest
   * @returns ModifyInstanceSpecResponse
   */
  async modifyInstanceSpec(request: ModifyInstanceSpecRequest): Promise<ModifyInstanceSpecResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyInstanceSpecWithOptions(request, runtime);
  }

  /**
   * You can call this operation to modify the tags of a cluster.
   * 
   * @param request - ModifyInstanceTagsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyInstanceTagsResponse
   */
  async modifyInstanceTagsWithOptions(request: ModifyInstanceTagsRequest, runtime: $Util.RuntimeOptions): Promise<ModifyInstanceTagsResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.tags)) {
      body["Tags"] = request.tags;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ModifyInstanceTags",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyInstanceTagsResponse>(await this.callApi(params, req, runtime), new ModifyInstanceTagsResponse({}));
  }

  /**
   * You can call this operation to modify the tags of a cluster.
   * 
   * @param request - ModifyInstanceTagsRequest
   * @returns ModifyInstanceTagsResponse
   */
  async modifyInstanceTags(request: ModifyInstanceTagsRequest): Promise<ModifyInstanceTagsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyInstanceTagsWithOptions(request, runtime);
  }

  /**
   * You can call this operation to modify the temporary capacity of the OceanBase cluster.
   * 
   * @param request - ModifyInstanceTemporaryCapacityRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyInstanceTemporaryCapacityResponse
   */
  async modifyInstanceTemporaryCapacityWithOptions(request: ModifyInstanceTemporaryCapacityRequest, runtime: $Util.RuntimeOptions): Promise<ModifyInstanceTemporaryCapacityResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.acceptLanguage)) {
      body["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!Util.isUnset(request.diskSize)) {
      body["DiskSize"] = request.diskSize;
    }

    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.spec)) {
      body["Spec"] = request.spec;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ModifyInstanceTemporaryCapacity",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyInstanceTemporaryCapacityResponse>(await this.callApi(params, req, runtime), new ModifyInstanceTemporaryCapacityResponse({}));
  }

  /**
   * You can call this operation to modify the temporary capacity of the OceanBase cluster.
   * 
   * @param request - ModifyInstanceTemporaryCapacityRequest
   * @returns ModifyInstanceTemporaryCapacityResponse
   */
  async modifyInstanceTemporaryCapacity(request: ModifyInstanceTemporaryCapacityRequest): Promise<ModifyInstanceTemporaryCapacityResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyInstanceTemporaryCapacityWithOptions(request, runtime);
  }

  /**
   * The modification results.
   * 
   * @param request - ModifyParametersRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyParametersResponse
   */
  async modifyParametersWithOptions(request: ModifyParametersRequest, runtime: $Util.RuntimeOptions): Promise<ModifyParametersResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.dimension)) {
      body["Dimension"] = request.dimension;
    }

    if (!Util.isUnset(request.dimensionValue)) {
      body["DimensionValue"] = request.dimensionValue;
    }

    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.parameters)) {
      body["Parameters"] = request.parameters;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ModifyParameters",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyParametersResponse>(await this.callApi(params, req, runtime), new ModifyParametersResponse({}));
  }

  /**
   * The modification results.
   * 
   * @param request - ModifyParametersRequest
   * @returns ModifyParametersResponse
   */
  async modifyParameters(request: ModifyParametersRequest): Promise<ModifyParametersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyParametersWithOptions(request, runtime);
  }

  /**
   * The name of the security group.
   * 
   * @param request - ModifySecurityIpsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifySecurityIpsResponse
   */
  async modifySecurityIpsWithOptions(request: ModifySecurityIpsRequest, runtime: $Util.RuntimeOptions): Promise<ModifySecurityIpsResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.securityIpGroupName)) {
      body["SecurityIpGroupName"] = request.securityIpGroupName;
    }

    if (!Util.isUnset(request.securityIps)) {
      body["SecurityIps"] = request.securityIps;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ModifySecurityIps",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifySecurityIpsResponse>(await this.callApi(params, req, runtime), new ModifySecurityIpsResponse({}));
  }

  /**
   * The name of the security group.
   * 
   * @param request - ModifySecurityIpsRequest
   * @returns ModifySecurityIpsResponse
   */
  async modifySecurityIps(request: ModifySecurityIpsRequest): Promise<ModifySecurityIpsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifySecurityIpsWithOptions(request, runtime);
  }

  /**
   * @param request - ModifyTagNameRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyTagNameResponse
   */
  async modifyTagNameWithOptions(request: ModifyTagNameRequest, runtime: $Util.RuntimeOptions): Promise<ModifyTagNameResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.key)) {
      body["Key"] = request.key;
    }

    if (!Util.isUnset(request.newKey)) {
      body["NewKey"] = request.newKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ModifyTagName",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyTagNameResponse>(await this.callApi(params, req, runtime), new ModifyTagNameResponse({}));
  }

  /**
   * @param request - ModifyTagNameRequest
   * @returns ModifyTagNameResponse
   */
  async modifyTagName(request: ModifyTagNameRequest): Promise<ModifyTagNameResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyTagNameWithOptions(request, runtime);
  }

  /**
   * You can call this operation to rename a tag.
   * 
   * @param request - ModifyTagValueNameRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyTagValueNameResponse
   */
  async modifyTagValueNameWithOptions(request: ModifyTagValueNameRequest, runtime: $Util.RuntimeOptions): Promise<ModifyTagValueNameResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.key)) {
      body["Key"] = request.key;
    }

    if (!Util.isUnset(request.newValue)) {
      body["NewValue"] = request.newValue;
    }

    if (!Util.isUnset(request.value)) {
      body["Value"] = request.value;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ModifyTagValueName",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyTagValueNameResponse>(await this.callApi(params, req, runtime), new ModifyTagValueNameResponse({}));
  }

  /**
   * You can call this operation to rename a tag.
   * 
   * @param request - ModifyTagValueNameRequest
   * @returns ModifyTagValueNameResponse
   */
  async modifyTagValueName(request: ModifyTagValueNameRequest): Promise<ModifyTagValueNameResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyTagValueNameWithOptions(request, runtime);
  }

  /**
   * 租户加密变更
   * 
   * @param request - ModifyTenantEncryptionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyTenantEncryptionResponse
   */
  async modifyTenantEncryptionWithOptions(request: ModifyTenantEncryptionRequest, runtime: $Util.RuntimeOptions): Promise<ModifyTenantEncryptionResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.encryptionKeyId)) {
      body["EncryptionKeyId"] = request.encryptionKeyId;
    }

    if (!Util.isUnset(request.encryptionType)) {
      body["EncryptionType"] = request.encryptionType;
    }

    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ModifyTenantEncryption",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyTenantEncryptionResponse>(await this.callApi(params, req, runtime), new ModifyTenantEncryptionResponse({}));
  }

  /**
   * 租户加密变更
   * 
   * @param request - ModifyTenantEncryptionRequest
   * @returns ModifyTenantEncryptionResponse
   */
  async modifyTenantEncryption(request: ModifyTenantEncryptionRequest): Promise<ModifyTenantEncryptionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyTenantEncryptionWithOptions(request, runtime);
  }

  /**
   * The return result of the request.
   * 
   * @param request - ModifyTenantPrimaryZoneRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyTenantPrimaryZoneResponse
   */
  async modifyTenantPrimaryZoneWithOptions(request: ModifyTenantPrimaryZoneRequest, runtime: $Util.RuntimeOptions): Promise<ModifyTenantPrimaryZoneResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.masterIntranetAddressZone)) {
      body["MasterIntranetAddressZone"] = request.masterIntranetAddressZone;
    }

    if (!Util.isUnset(request.primaryZone)) {
      body["PrimaryZone"] = request.primaryZone;
    }

    if (!Util.isUnset(request.tenantEndpointDirectId)) {
      body["TenantEndpointDirectId"] = request.tenantEndpointDirectId;
    }

    if (!Util.isUnset(request.tenantEndpointId)) {
      body["TenantEndpointId"] = request.tenantEndpointId;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    if (!Util.isUnset(request.userDirectVSwitchId)) {
      body["UserDirectVSwitchId"] = request.userDirectVSwitchId;
    }

    if (!Util.isUnset(request.userVSwitchId)) {
      body["UserVSwitchId"] = request.userVSwitchId;
    }

    if (!Util.isUnset(request.userVpcOwnerId)) {
      body["UserVpcOwnerId"] = request.userVpcOwnerId;
    }

    if (!Util.isUnset(request.vpcId)) {
      body["VpcId"] = request.vpcId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ModifyTenantPrimaryZone",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyTenantPrimaryZoneResponse>(await this.callApi(params, req, runtime), new ModifyTenantPrimaryZoneResponse({}));
  }

  /**
   * The return result of the request.
   * 
   * @param request - ModifyTenantPrimaryZoneRequest
   * @returns ModifyTenantPrimaryZoneResponse
   */
  async modifyTenantPrimaryZone(request: ModifyTenantPrimaryZoneRequest): Promise<ModifyTenantPrimaryZoneResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyTenantPrimaryZoneWithOptions(request, runtime);
  }

  /**
   * You can call this operation to modify the specifications of a tenant in an OceanBase cluster.
   * 
   * @param request - ModifyTenantResourceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyTenantResourceResponse
   */
  async modifyTenantResourceWithOptions(request: ModifyTenantResourceRequest, runtime: $Util.RuntimeOptions): Promise<ModifyTenantResourceResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.cpu)) {
      body["Cpu"] = request.cpu;
    }

    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.logDisk)) {
      body["LogDisk"] = request.logDisk;
    }

    if (!Util.isUnset(request.memory)) {
      body["Memory"] = request.memory;
    }

    if (!Util.isUnset(request.readOnlyZoneList)) {
      body["ReadOnlyZoneList"] = request.readOnlyZoneList;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ModifyTenantResource",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyTenantResourceResponse>(await this.callApi(params, req, runtime), new ModifyTenantResourceResponse({}));
  }

  /**
   * You can call this operation to modify the specifications of a tenant in an OceanBase cluster.
   * 
   * @param request - ModifyTenantResourceRequest
   * @returns ModifyTenantResourceResponse
   */
  async modifyTenantResource(request: ModifyTenantResourceRequest): Promise<ModifyTenantResourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyTenantResourceWithOptions(request, runtime);
  }

  /**
   * You can call this operation to modify the information on the whitelist group of the tenant.
   * 
   * @param request - ModifyTenantSecurityIpGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyTenantSecurityIpGroupResponse
   */
  async modifyTenantSecurityIpGroupWithOptions(request: ModifyTenantSecurityIpGroupRequest, runtime: $Util.RuntimeOptions): Promise<ModifyTenantSecurityIpGroupResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.securityIpGroupName)) {
      body["SecurityIpGroupName"] = request.securityIpGroupName;
    }

    if (!Util.isUnset(request.securityIps)) {
      body["SecurityIps"] = request.securityIps;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ModifyTenantSecurityIpGroup",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyTenantSecurityIpGroupResponse>(await this.callApi(params, req, runtime), new ModifyTenantSecurityIpGroupResponse({}));
  }

  /**
   * You can call this operation to modify the information on the whitelist group of the tenant.
   * 
   * @param request - ModifyTenantSecurityIpGroupRequest
   * @returns ModifyTenantSecurityIpGroupResponse
   */
  async modifyTenantSecurityIpGroup(request: ModifyTenantSecurityIpGroupRequest): Promise<ModifyTenantSecurityIpGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyTenantSecurityIpGroupWithOptions(request, runtime);
  }

  /**
   * You can call this operation to modify the tags of a tenant.
   * 
   * @param request - ModifyTenantTagsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyTenantTagsResponse
   */
  async modifyTenantTagsWithOptions(request: ModifyTenantTagsRequest, runtime: $Util.RuntimeOptions): Promise<ModifyTenantTagsResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.tags)) {
      body["Tags"] = request.tags;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ModifyTenantTags",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyTenantTagsResponse>(await this.callApi(params, req, runtime), new ModifyTenantTagsResponse({}));
  }

  /**
   * You can call this operation to modify the tags of a tenant.
   * 
   * @param request - ModifyTenantTagsRequest
   * @returns ModifyTenantTagsResponse
   */
  async modifyTenantTags(request: ModifyTenantTagsRequest): Promise<ModifyTenantTagsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyTenantTagsWithOptions(request, runtime);
  }

  /**
   * The description of the database.
   * 
   * @param request - ModifyTenantUserDescriptionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyTenantUserDescriptionResponse
   */
  async modifyTenantUserDescriptionWithOptions(request: ModifyTenantUserDescriptionRequest, runtime: $Util.RuntimeOptions): Promise<ModifyTenantUserDescriptionResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.description)) {
      body["Description"] = request.description;
    }

    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    if (!Util.isUnset(request.userName)) {
      body["UserName"] = request.userName;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ModifyTenantUserDescription",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyTenantUserDescriptionResponse>(await this.callApi(params, req, runtime), new ModifyTenantUserDescriptionResponse({}));
  }

  /**
   * The description of the database.
   * 
   * @param request - ModifyTenantUserDescriptionRequest
   * @returns ModifyTenantUserDescriptionResponse
   */
  async modifyTenantUserDescription(request: ModifyTenantUserDescriptionRequest): Promise<ModifyTenantUserDescriptionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyTenantUserDescriptionWithOptions(request, runtime);
  }

  /**
   * The request ID.
   * 
   * @param request - ModifyTenantUserPasswordRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyTenantUserPasswordResponse
   */
  async modifyTenantUserPasswordWithOptions(request: ModifyTenantUserPasswordRequest, runtime: $Util.RuntimeOptions): Promise<ModifyTenantUserPasswordResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.encryptionType)) {
      body["EncryptionType"] = request.encryptionType;
    }

    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    if (!Util.isUnset(request.userName)) {
      body["UserName"] = request.userName;
    }

    if (!Util.isUnset(request.userPassword)) {
      body["UserPassword"] = request.userPassword;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ModifyTenantUserPassword",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyTenantUserPasswordResponse>(await this.callApi(params, req, runtime), new ModifyTenantUserPasswordResponse({}));
  }

  /**
   * The request ID.
   * 
   * @param request - ModifyTenantUserPasswordRequest
   * @returns ModifyTenantUserPasswordResponse
   */
  async modifyTenantUserPassword(request: ModifyTenantUserPasswordRequest): Promise<ModifyTenantUserPasswordResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyTenantUserPasswordWithOptions(request, runtime);
  }

  /**
   * Indicates whether the privilege was granted to the role.
   * 
   * @param request - ModifyTenantUserRolesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyTenantUserRolesResponse
   */
  async modifyTenantUserRolesWithOptions(request: ModifyTenantUserRolesRequest, runtime: $Util.RuntimeOptions): Promise<ModifyTenantUserRolesResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.modifyType)) {
      body["ModifyType"] = request.modifyType;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    if (!Util.isUnset(request.userName)) {
      body["UserName"] = request.userName;
    }

    if (!Util.isUnset(request.userRole)) {
      body["UserRole"] = request.userRole;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ModifyTenantUserRoles",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyTenantUserRolesResponse>(await this.callApi(params, req, runtime), new ModifyTenantUserRolesResponse({}));
  }

  /**
   * Indicates whether the privilege was granted to the role.
   * 
   * @param request - ModifyTenantUserRolesRequest
   * @returns ModifyTenantUserRolesResponse
   */
  async modifyTenantUserRoles(request: ModifyTenantUserRolesRequest): Promise<ModifyTenantUserRolesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyTenantUserRolesWithOptions(request, runtime);
  }

  /**
   * The ID of the tenant.
   * 
   * @param request - ModifyTenantUserStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyTenantUserStatusResponse
   */
  async modifyTenantUserStatusWithOptions(request: ModifyTenantUserStatusRequest, runtime: $Util.RuntimeOptions): Promise<ModifyTenantUserStatusResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    if (!Util.isUnset(request.userName)) {
      body["UserName"] = request.userName;
    }

    if (!Util.isUnset(request.userStatus)) {
      body["UserStatus"] = request.userStatus;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ModifyTenantUserStatus",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyTenantUserStatusResponse>(await this.callApi(params, req, runtime), new ModifyTenantUserStatusResponse({}));
  }

  /**
   * The ID of the tenant.
   * 
   * @param request - ModifyTenantUserStatusRequest
   * @returns ModifyTenantUserStatusResponse
   */
  async modifyTenantUserStatus(request: ModifyTenantUserStatusRequest): Promise<ModifyTenantUserStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyTenantUserStatusWithOptions(request, runtime);
  }

  /**
   * 释放项目
   * 
   * @param request - ReleaseProjectRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ReleaseProjectResponse
   */
  async releaseProjectWithOptions(request: ReleaseProjectRequest, runtime: $Util.RuntimeOptions): Promise<ReleaseProjectResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.id)) {
      body["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ReleaseProject",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ReleaseProjectResponse>(await this.callApi(params, req, runtime), new ReleaseProjectResponse({}));
  }

  /**
   * 释放项目
   * 
   * @param request - ReleaseProjectRequest
   * @returns ReleaseProjectResponse
   */
  async releaseProject(request: ReleaseProjectRequest): Promise<ReleaseProjectResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.releaseProjectWithOptions(request, runtime);
  }

  /**
   * 释放传输实例 （未绑定项目时才可以释放）
   * 
   * @param request - ReleaseWorkerInstanceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ReleaseWorkerInstanceResponse
   */
  async releaseWorkerInstanceWithOptions(request: ReleaseWorkerInstanceRequest, runtime: $Util.RuntimeOptions): Promise<ReleaseWorkerInstanceResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.id)) {
      body["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ReleaseWorkerInstance",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ReleaseWorkerInstanceResponse>(await this.callApi(params, req, runtime), new ReleaseWorkerInstanceResponse({}));
  }

  /**
   * 释放传输实例 （未绑定项目时才可以释放）
   * 
   * @param request - ReleaseWorkerInstanceRequest
   * @returns ReleaseWorkerInstanceResponse
   */
  async releaseWorkerInstance(request: ReleaseWorkerInstanceRequest): Promise<ReleaseWorkerInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.releaseWorkerInstanceWithOptions(request, runtime);
  }

  /**
   * 恢复项目
   * 
   * @param request - ResumeProjectRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ResumeProjectResponse
   */
  async resumeProjectWithOptions(request: ResumeProjectRequest, runtime: $Util.RuntimeOptions): Promise<ResumeProjectResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.id)) {
      body["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ResumeProject",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ResumeProjectResponse>(await this.callApi(params, req, runtime), new ResumeProjectResponse({}));
  }

  /**
   * 恢复项目
   * 
   * @param request - ResumeProjectRequest
   * @returns ResumeProjectResponse
   */
  async resumeProject(request: ResumeProjectRequest): Promise<ResumeProjectResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.resumeProjectWithOptions(request, runtime);
  }

  /**
   * 根据修改记录 ID 重试修改操作（仅支持处于 FAILED 状态的修改记录）
   * 
   * @param request - RetryProjectModifyRecordsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RetryProjectModifyRecordsResponse
   */
  async retryProjectModifyRecordsWithOptions(request: RetryProjectModifyRecordsRequest, runtime: $Util.RuntimeOptions): Promise<RetryProjectModifyRecordsResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.id)) {
      body["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "RetryProjectModifyRecords",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RetryProjectModifyRecordsResponse>(await this.callApi(params, req, runtime), new RetryProjectModifyRecordsResponse({}));
  }

  /**
   * 根据修改记录 ID 重试修改操作（仅支持处于 FAILED 状态的修改记录）
   * 
   * @param request - RetryProjectModifyRecordsRequest
   * @returns RetryProjectModifyRecordsResponse
   */
  async retryProjectModifyRecords(request: RetryProjectModifyRecordsRequest): Promise<RetryProjectModifyRecordsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.retryProjectModifyRecordsWithOptions(request, runtime);
  }

  /**
   * 启动项目
   * 
   * @param request - StartProjectRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns StartProjectResponse
   */
  async startProjectWithOptions(request: StartProjectRequest, runtime: $Util.RuntimeOptions): Promise<StartProjectResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.id)) {
      body["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "StartProject",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<StartProjectResponse>(await this.callApi(params, req, runtime), new StartProjectResponse({}));
  }

  /**
   * 启动项目
   * 
   * @param request - StartProjectRequest
   * @returns StartProjectResponse
   */
  async startProject(request: StartProjectRequest): Promise<StartProjectResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.startProjectWithOptions(request, runtime);
  }

  /**
   * 启动该label下的所有未启动项目
   * 
   * @param request - StartProjectsByLabelRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns StartProjectsByLabelResponse
   */
  async startProjectsByLabelWithOptions(request: StartProjectsByLabelRequest, runtime: $Util.RuntimeOptions): Promise<StartProjectsByLabelResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.id)) {
      body["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "StartProjectsByLabel",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<StartProjectsByLabelResponse>(await this.callApi(params, req, runtime), new StartProjectsByLabelResponse({}));
  }

  /**
   * 启动该label下的所有未启动项目
   * 
   * @param request - StartProjectsByLabelRequest
   * @returns StartProjectsByLabelResponse
   */
  async startProjectsByLabel(request: StartProjectsByLabelRequest): Promise<StartProjectsByLabelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.startProjectsByLabelWithOptions(request, runtime);
  }

  /**
   * 暂停项目
   * 
   * @param request - StopProjectRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns StopProjectResponse
   */
  async stopProjectWithOptions(request: StopProjectRequest, runtime: $Util.RuntimeOptions): Promise<StopProjectResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.id)) {
      body["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "StopProject",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<StopProjectResponse>(await this.callApi(params, req, runtime), new StopProjectResponse({}));
  }

  /**
   * 暂停项目
   * 
   * @param request - StopProjectRequest
   * @returns StopProjectResponse
   */
  async stopProject(request: StopProjectRequest): Promise<StopProjectResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.stopProjectWithOptions(request, runtime);
  }

  /**
   * 根据修改记录 ID 终止修改操作，不可恢复（仅支持处于 RUNNING / FAILED 状态的修改记录）
   * 
   * @param request - StopProjectModifyRecordsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns StopProjectModifyRecordsResponse
   */
  async stopProjectModifyRecordsWithOptions(request: StopProjectModifyRecordsRequest, runtime: $Util.RuntimeOptions): Promise<StopProjectModifyRecordsResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.id)) {
      body["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "StopProjectModifyRecords",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<StopProjectModifyRecordsResponse>(await this.callApi(params, req, runtime), new StopProjectModifyRecordsResponse({}));
  }

  /**
   * 根据修改记录 ID 终止修改操作，不可恢复（仅支持处于 RUNNING / FAILED 状态的修改记录）
   * 
   * @param request - StopProjectModifyRecordsRequest
   * @returns StopProjectModifyRecordsResponse
   */
  async stopProjectModifyRecords(request: StopProjectModifyRecordsRequest): Promise<StopProjectModifyRecordsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.stopProjectModifyRecordsWithOptions(request, runtime);
  }

  /**
   * 暂停该label下的所有运行中项目
   * 
   * @param request - StopProjectsByLabelRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns StopProjectsByLabelResponse
   */
  async stopProjectsByLabelWithOptions(request: StopProjectsByLabelRequest, runtime: $Util.RuntimeOptions): Promise<StopProjectsByLabelResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.id)) {
      body["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "StopProjectsByLabel",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<StopProjectsByLabelResponse>(await this.callApi(params, req, runtime), new StopProjectsByLabelResponse({}));
  }

  /**
   * 暂停该label下的所有运行中项目
   * 
   * @param request - StopProjectsByLabelRequest
   * @returns StopProjectsByLabelResponse
   */
  async stopProjectsByLabel(request: StopProjectsByLabelRequest): Promise<StopProjectsByLabelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.stopProjectsByLabelWithOptions(request, runtime);
  }

  /**
   * You can call this operation to switch between the primary and standby instances of OceanBase.
   * 
   * @param request - SwitchoverInstanceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SwitchoverInstanceResponse
   */
  async switchoverInstanceWithOptions(request: SwitchoverInstanceRequest, runtime: $Util.RuntimeOptions): Promise<SwitchoverInstanceResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.forced)) {
      body["Forced"] = request.forced;
    }

    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.targetInstanceId)) {
      body["TargetInstanceId"] = request.targetInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "SwitchoverInstance",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SwitchoverInstanceResponse>(await this.callApi(params, req, runtime), new SwitchoverInstanceResponse({}));
  }

  /**
   * You can call this operation to switch between the primary and standby instances of OceanBase.
   * 
   * @param request - SwitchoverInstanceRequest
   * @returns SwitchoverInstanceResponse
   */
  async switchoverInstance(request: SwitchoverInstanceRequest): Promise<SwitchoverInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.switchoverInstanceWithOptions(request, runtime);
  }

  /**
   * 更新项目配置 Action=UpdateProjectConfig
   * 
   * @param tmpReq - UpdateProjectConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateProjectConfigResponse
   */
  async updateProjectConfigWithOptions(tmpReq: UpdateProjectConfigRequest, runtime: $Util.RuntimeOptions): Promise<UpdateProjectConfigResponse> {
    Util.validateModel(tmpReq);
    let request = new UpdateProjectConfigShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.commonTransferConfig)) {
      request.commonTransferConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.commonTransferConfig, "CommonTransferConfig", "json");
    }

    if (!Util.isUnset(tmpReq.fullTransferConfig)) {
      request.fullTransferConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.fullTransferConfig, "FullTransferConfig", "json");
    }

    if (!Util.isUnset(tmpReq.incrTransferConfig)) {
      request.incrTransferConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.incrTransferConfig, "IncrTransferConfig", "json");
    }

    if (!Util.isUnset(tmpReq.reverseIncrTransferConfig)) {
      request.reverseIncrTransferConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.reverseIncrTransferConfig, "ReverseIncrTransferConfig", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.commonTransferConfigShrink)) {
      body["CommonTransferConfig"] = request.commonTransferConfigShrink;
    }

    if (!Util.isUnset(request.fullTransferConfigShrink)) {
      body["FullTransferConfig"] = request.fullTransferConfigShrink;
    }

    if (!Util.isUnset(request.id)) {
      body["Id"] = request.id;
    }

    if (!Util.isUnset(request.incrTransferConfigShrink)) {
      body["IncrTransferConfig"] = request.incrTransferConfigShrink;
    }

    if (!Util.isUnset(request.reverseIncrTransferConfigShrink)) {
      body["ReverseIncrTransferConfig"] = request.reverseIncrTransferConfigShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateProjectConfig",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateProjectConfigResponse>(await this.callApi(params, req, runtime), new UpdateProjectConfigResponse({}));
  }

  /**
   * 更新项目配置 Action=UpdateProjectConfig
   * 
   * @param request - UpdateProjectConfigRequest
   * @returns UpdateProjectConfigResponse
   */
  async updateProjectConfig(request: UpdateProjectConfigRequest): Promise<UpdateProjectConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateProjectConfigWithOptions(request, runtime);
  }

}
