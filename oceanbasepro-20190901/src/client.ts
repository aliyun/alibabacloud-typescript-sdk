// This file is auto-generated, don't edit it
/**
 */
import OpenApi from '@alicloud/openapi-core';
import { OpenApiUtil, $OpenApiUtil } from '@alicloud/openapi-core';
import * as $dara from '@darabonba/typescript';

export class DataExtraInfoSubDbsValueTablesColumns extends $dara.Model {
  /**
   * @example
   * null
   */
  columnName?: string;
  /**
   * @example
   * null
   */
  position?: number;
  /**
   * @example
   * null
   */
  columnType?: string;
  /**
   * @example
   * null
   */
  recordFieldType?: string;
  /**
   * @example
   * null
   */
  rawColumnType?: string;
  /**
   * @example
   * null
   */
  columnKey?: string;
  /**
   * @example
   * true
   */
  nullable?: boolean;
  /**
   * @example
   * null
   */
  defaultValue?: string;
  /**
   * @example
   * null
   */
  dataLength?: number;
  /**
   * @example
   * 64
   */
  dataPrecision?: number;
  /**
   * @example
   * null
   */
  dataScale?: number;
  /**
   * @example
   * utf8
   */
  encoding?: string;
  /**
   * @example
   * comments
   */
  columnComment?: string;
  /**
   * @example
   * false
   */
  isGenerateField?: boolean;
  static names(): { [key: string]: string } {
    return {
      columnName: 'ColumnName',
      position: 'Position',
      columnType: 'ColumnType',
      recordFieldType: 'RecordFieldType',
      rawColumnType: 'RawColumnType',
      columnKey: 'ColumnKey',
      nullable: 'Nullable',
      defaultValue: 'DefaultValue',
      dataLength: 'DataLength',
      dataPrecision: 'DataPrecision',
      dataScale: 'DataScale',
      encoding: 'Encoding',
      columnComment: 'ColumnComment',
      isGenerateField: 'IsGenerateField',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnName: 'string',
      position: 'number',
      columnType: 'string',
      recordFieldType: 'string',
      rawColumnType: 'string',
      columnKey: 'string',
      nullable: 'boolean',
      defaultValue: 'string',
      dataLength: 'number',
      dataPrecision: 'number',
      dataScale: 'number',
      encoding: 'string',
      columnComment: 'string',
      isGenerateField: 'boolean',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DataExtraInfoSubDbsValueTables extends $dara.Model {
  /**
   * @example
   * fexg***
   */
  tableId?: string;
  /**
   * @example
   * db_name
   */
  database?: string;
  /**
   * @example
   * table_name
   */
  tableName?: string;
  /**
   * @example
   * mapped_table
   */
  mappingTableName?: string;
  /**
   * @example
   * g_i4kat***
   */
  instance?: string;
  columns?: DataExtraInfoSubDbsValueTablesColumns[];
  static names(): { [key: string]: string } {
    return {
      tableId: 'TableId',
      database: 'Database',
      tableName: 'TableName',
      mappingTableName: 'MappingTableName',
      instance: 'Instance',
      columns: 'Columns',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tableId: 'string',
      database: 'string',
      tableName: 'string',
      mappingTableName: 'string',
      instance: 'string',
      columns: { 'type': 'array', 'itemType': DataExtraInfoSubDbsValueTablesColumns },
    };
  }

  validate() {
    if(Array.isArray(this.columns)) {
      $dara.Model.validateArray(this.columns);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchKillProcessListResponseBodyData extends $dara.Model {
  /**
   * @remarks
   * Indicates whether the calling is successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      success: 'boolean',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelProjectModifyRecordResponseBodyErrorDetail extends $dara.Model {
  /**
   * @example
   * 200
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * Contact the administrator.
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  validate() {
    if(this.extraContext) {
      $dara.Model.validateMap(this.extraContext);
    }
    if(this.messageMcmsContext) {
      $dara.Model.validateMap(this.messageMcmsContext);
    }
    if(this.proposalMcmsContext) {
      $dara.Model.validateMap(this.proposalMcmsContext);
    }
    if(this.reasonMcmsContext) {
      $dara.Model.validateMap(this.reasonMcmsContext);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateInstanceResponseBodyData extends $dara.Model {
  /**
   * @remarks
   * The result of the dry-run request.
   * 
   * If the DryRun parameter is set to true and the dry run succeeds, the DryRunResult parameter returns true. Otherwise, an error code is returned.
   * If the DryRun parameter is set to false, no dry run is performed and the DryRunResult parameter returns false.
   * 
   * @example
   * true
   */
  dryRunResult?: boolean;
  /**
   * @remarks
   * Instance ID.
   * 
   * @example
   * i-bp67acfmxazb4p****
   */
  instanceId?: string;
  /**
   * @remarks
   * Order ID. The ID of the order that you have placed.
   * This parameter returns a value after you create a pre-paid or post-paid cluster.
   * 
   * @example
   * 1234567890
   */
  orderId?: string;
  /**
   * @remarks
   * Resource group ID.
   * 
   * @example
   * rg-***************
   */
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      dryRunResult: 'DryRunResult',
      instanceId: 'InstanceId',
      orderId: 'OrderId',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dryRunResult: 'boolean',
      instanceId: 'string',
      orderId: 'string',
      resourceGroupId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLabelResponseBodyErrorDetail extends $dara.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * null
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  validate() {
    if(this.extraContext) {
      $dara.Model.validateMap(this.extraContext);
    }
    if(this.messageMcmsContext) {
      $dara.Model.validateMap(this.messageMcmsContext);
    }
    if(this.proposalMcmsContext) {
      $dara.Model.validateMap(this.proposalMcmsContext);
    }
    if(this.reasonMcmsContext) {
      $dara.Model.validateMap(this.reasonMcmsContext);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMySqlDataSourceResponseBodyErrorDetail extends $dara.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * null
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * Contact the administrator.
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  validate() {
    if(this.extraContext) {
      $dara.Model.validateMap(this.extraContext);
    }
    if(this.messageMcmsContext) {
      $dara.Model.validateMap(this.messageMcmsContext);
    }
    if(this.proposalMcmsContext) {
      $dara.Model.validateMap(this.proposalMcmsContext);
    }
    if(this.reasonMcmsContext) {
      $dara.Model.validateMap(this.reasonMcmsContext);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOceanBaseDataSourceResponseBodyErrorDetail extends $dara.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * null
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  validate() {
    if(this.extraContext) {
      $dara.Model.validateMap(this.extraContext);
    }
    if(this.messageMcmsContext) {
      $dara.Model.validateMap(this.messageMcmsContext);
    }
    if(this.proposalMcmsContext) {
      $dara.Model.validateMap(this.proposalMcmsContext);
    }
    if(this.reasonMcmsContext) {
      $dara.Model.validateMap(this.reasonMcmsContext);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOmsMysqlDataSourceResponseBodyData extends $dara.Model {
  /**
   * @remarks
   * The ID of the data source record.
   * 
   * @example
   * e_1234abcd*****
   */
  endpointId?: string;
  static names(): { [key: string]: string } {
    return {
      endpointId: 'EndpointId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endpointId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectRequestCommonTransferConfigCustomColumns extends $dara.Model {
  columnName?: string;
  expression?: string;
  static names(): { [key: string]: string } {
    return {
      columnName: 'ColumnName',
      expression: 'Expression',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnName: 'string',
      expression: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectRequestCommonTransferConfig extends $dara.Model {
  /**
   * @example
   * false
   */
  activeActive?: boolean;
  customColumns?: CreateProjectRequestCommonTransferConfigCustomColumns[];
  /**
   * @example
   * null
   */
  dataWorksBusinessName?: string;
  /**
   * @example
   * TUPLE
   */
  datahubTopicType?: string;
  /**
   * @example
   * 0
   */
  mqPartition?: number;
  /**
   * @example
   * ONE
   */
  mqPartitionMode?: string;
  /**
   * @example
   * DEFAULT
   */
  mqSerializerType?: string;
  /**
   * @example
   * false
   */
  rocketMqEnableMsgTrace?: boolean;
  /**
   * @example
   * default_tag
   */
  rocketMqMsgTags?: string;
  /**
   * @example
   * OMS
   */
  rocketMqProducerGroup?: string;
  /**
   * @example
   * null
   */
  rocketMqSendMsgTimeout?: number;
  sinkStoreFormat?: string;
  sourceStoreFormat?: string;
  syncSchema?: boolean;
  syncSchemaColumnName?: string;
  /**
   * @example
   * ALL
   */
  tableCategory?: string;
  static names(): { [key: string]: string } {
    return {
      activeActive: 'ActiveActive',
      customColumns: 'CustomColumns',
      dataWorksBusinessName: 'DataWorksBusinessName',
      datahubTopicType: 'DatahubTopicType',
      mqPartition: 'MqPartition',
      mqPartitionMode: 'MqPartitionMode',
      mqSerializerType: 'MqSerializerType',
      rocketMqEnableMsgTrace: 'RocketMqEnableMsgTrace',
      rocketMqMsgTags: 'RocketMqMsgTags',
      rocketMqProducerGroup: 'RocketMqProducerGroup',
      rocketMqSendMsgTimeout: 'RocketMqSendMsgTimeout',
      sinkStoreFormat: 'SinkStoreFormat',
      sourceStoreFormat: 'SourceStoreFormat',
      syncSchema: 'SyncSchema',
      syncSchemaColumnName: 'SyncSchemaColumnName',
      tableCategory: 'TableCategory',
    };
  }

  static types(): { [key: string]: any } {
    return {
      activeActive: 'boolean',
      customColumns: { 'type': 'array', 'itemType': CreateProjectRequestCommonTransferConfigCustomColumns },
      dataWorksBusinessName: 'string',
      datahubTopicType: 'string',
      mqPartition: 'number',
      mqPartitionMode: 'string',
      mqSerializerType: 'string',
      rocketMqEnableMsgTrace: 'boolean',
      rocketMqMsgTags: 'string',
      rocketMqProducerGroup: 'string',
      rocketMqSendMsgTimeout: 'number',
      sinkStoreFormat: 'string',
      sourceStoreFormat: 'string',
      syncSchema: 'boolean',
      syncSchemaColumnName: 'string',
      tableCategory: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.customColumns)) {
      $dara.Model.validateArray(this.customColumns);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectRequestFullTransferConfig extends $dara.Model {
  /**
   * @example
   * true
   */
  allowDestTableNotEmpty?: boolean;
  /**
   * @example
   * NORMAL
   */
  fullTransferSpeedMode?: string;
  /**
   * @example
   * NORMAL
   */
  fullVerifySpeedMode?: string;
  hbaseObjCheckMode?: string;
  hbaseObjMigMode?: string;
  indexDDLConcurrencyLimit?: number;
  maxConcurrentIndexDDLs?: number;
  /**
   * @example
   * true
   */
  nonePkUkTruncateDstTable?: boolean;
  readWorkerNum?: number;
  throttleIOPS?: number;
  throttleRps?: number;
  writeWorkerNum?: number;
  static names(): { [key: string]: string } {
    return {
      allowDestTableNotEmpty: 'AllowDestTableNotEmpty',
      fullTransferSpeedMode: 'FullTransferSpeedMode',
      fullVerifySpeedMode: 'FullVerifySpeedMode',
      hbaseObjCheckMode: 'HbaseObjCheckMode',
      hbaseObjMigMode: 'HbaseObjMigMode',
      indexDDLConcurrencyLimit: 'IndexDDLConcurrencyLimit',
      maxConcurrentIndexDDLs: 'MaxConcurrentIndexDDLs',
      nonePkUkTruncateDstTable: 'NonePkUkTruncateDstTable',
      readWorkerNum: 'ReadWorkerNum',
      throttleIOPS: 'ThrottleIOPS',
      throttleRps: 'ThrottleRps',
      writeWorkerNum: 'WriteWorkerNum',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allowDestTableNotEmpty: 'boolean',
      fullTransferSpeedMode: 'string',
      fullVerifySpeedMode: 'string',
      hbaseObjCheckMode: 'string',
      hbaseObjMigMode: 'string',
      indexDDLConcurrencyLimit: 'number',
      maxConcurrentIndexDDLs: 'number',
      nonePkUkTruncateDstTable: 'boolean',
      readWorkerNum: 'number',
      throttleIOPS: 'number',
      throttleRps: 'number',
      writeWorkerNum: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectRequestIncrTransferConfig extends $dara.Model {
  /**
   * @example
   * true
   */
  enableIncrSyncStatistics?: boolean;
  /**
   * @example
   * true
   */
  enableSequencingWithinTxn?: boolean;
  /**
   * @example
   * 64
   */
  incrSyncConcurrency?: number;
  recordTypeWhiteList?: string[];
  /**
   * @example
   * 1689201369
   */
  startTimestamp?: string;
  /**
   * @example
   * 24
   */
  storeLogKeptHour?: number;
  supportDDLTypes?: string[];
  throttleIOPS?: number;
  throttleRps?: number;
  static names(): { [key: string]: string } {
    return {
      enableIncrSyncStatistics: 'EnableIncrSyncStatistics',
      enableSequencingWithinTxn: 'EnableSequencingWithinTxn',
      incrSyncConcurrency: 'IncrSyncConcurrency',
      recordTypeWhiteList: 'RecordTypeWhiteList',
      startTimestamp: 'StartTimestamp',
      storeLogKeptHour: 'StoreLogKeptHour',
      supportDDLTypes: 'SupportDDLTypes',
      throttleIOPS: 'ThrottleIOPS',
      throttleRps: 'ThrottleRps',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enableIncrSyncStatistics: 'boolean',
      enableSequencingWithinTxn: 'boolean',
      incrSyncConcurrency: 'number',
      recordTypeWhiteList: { 'type': 'array', 'itemType': 'string' },
      startTimestamp: 'string',
      storeLogKeptHour: 'number',
      supportDDLTypes: { 'type': 'array', 'itemType': 'string' },
      throttleIOPS: 'number',
      throttleRps: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.recordTypeWhiteList)) {
      $dara.Model.validateArray(this.recordTypeWhiteList);
    }
    if(Array.isArray(this.supportDDLTypes)) {
      $dara.Model.validateArray(this.supportDDLTypes);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectRequestReverseIncrTransferConfig extends $dara.Model {
  enableIncrSyncStatistics?: boolean;
  enableSequencingWithinTxn?: boolean;
  incrSyncConcurrency?: number;
  recordTypeWhiteList?: string[];
  startTimestamp?: string;
  storeLogKeptHour?: number;
  supportDDLTypes?: string[];
  throttleIOPS?: number;
  throttleRps?: number;
  static names(): { [key: string]: string } {
    return {
      enableIncrSyncStatistics: 'EnableIncrSyncStatistics',
      enableSequencingWithinTxn: 'EnableSequencingWithinTxn',
      incrSyncConcurrency: 'IncrSyncConcurrency',
      recordTypeWhiteList: 'RecordTypeWhiteList',
      startTimestamp: 'StartTimestamp',
      storeLogKeptHour: 'StoreLogKeptHour',
      supportDDLTypes: 'SupportDDLTypes',
      throttleIOPS: 'ThrottleIOPS',
      throttleRps: 'ThrottleRps',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enableIncrSyncStatistics: 'boolean',
      enableSequencingWithinTxn: 'boolean',
      incrSyncConcurrency: 'number',
      recordTypeWhiteList: { 'type': 'array', 'itemType': 'string' },
      startTimestamp: 'string',
      storeLogKeptHour: 'number',
      supportDDLTypes: { 'type': 'array', 'itemType': 'string' },
      throttleIOPS: 'number',
      throttleRps: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.recordTypeWhiteList)) {
      $dara.Model.validateArray(this.recordTypeWhiteList);
    }
    if(Array.isArray(this.supportDDLTypes)) {
      $dara.Model.validateArray(this.supportDDLTypes);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectRequestStructTransferConfig extends $dara.Model {
  /**
   * @example
   * DO_NOTHING_IF_BYTE_USED
   */
  byteCharConvertStrategy?: string;
  /**
   * @example
   * true
   */
  deferIndexCreation?: boolean;
  static names(): { [key: string]: string } {
    return {
      byteCharConvertStrategy: 'ByteCharConvertStrategy',
      deferIndexCreation: 'DeferIndexCreation',
    };
  }

  static types(): { [key: string]: any } {
    return {
      byteCharConvertStrategy: 'string',
      deferIndexCreation: 'boolean',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectRequestTransferMappingDatabasesSpecificTablesAdbTableSchema extends $dara.Model {
  distributedKeys?: string[];
  /**
   * @example
   * 30
   */
  partitionLifeCycle?: string;
  /**
   * @example
   * PARTITION BY VALUE(\\"id\\")
   */
  partitionStatement?: string;
  primaryKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      distributedKeys: 'DistributedKeys',
      partitionLifeCycle: 'PartitionLifeCycle',
      partitionStatement: 'PartitionStatement',
      primaryKeys: 'PrimaryKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      distributedKeys: { 'type': 'array', 'itemType': 'string' },
      partitionLifeCycle: 'string',
      partitionStatement: 'string',
      primaryKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(Array.isArray(this.distributedKeys)) {
      $dara.Model.validateArray(this.distributedKeys);
    }
    if(Array.isArray(this.primaryKeys)) {
      $dara.Model.validateArray(this.primaryKeys);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectRequestTransferMappingDatabasesSpecificTables extends $dara.Model {
  adbTableSchema?: CreateProjectRequestTransferMappingDatabasesSpecificTablesAdbTableSchema;
  filterColumns?: string[];
  /**
   * @example
   * e_4azdil4lu7***
   */
  id?: string;
  /**
   * @example
   * mapped_table
   */
  mappedName?: string;
  /**
   * @example
   * table_name
   */
  name?: string;
  shardColumns?: string[];
  /**
   * @example
   * id<5
   */
  whereClause?: string;
  static names(): { [key: string]: string } {
    return {
      adbTableSchema: 'AdbTableSchema',
      filterColumns: 'FilterColumns',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      shardColumns: 'ShardColumns',
      whereClause: 'WhereClause',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adbTableSchema: CreateProjectRequestTransferMappingDatabasesSpecificTablesAdbTableSchema,
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      mappedName: 'string',
      name: 'string',
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      whereClause: 'string',
    };
  }

  validate() {
    if(this.adbTableSchema && typeof (this.adbTableSchema as any).validate === 'function') {
      (this.adbTableSchema as any).validate();
    }
    if(Array.isArray(this.filterColumns)) {
      $dara.Model.validateArray(this.filterColumns);
    }
    if(Array.isArray(this.shardColumns)) {
      $dara.Model.validateArray(this.shardColumns);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectRequestTransferMappingDatabasesSpecificViewsAdbTableSchema extends $dara.Model {
  distributedKeys?: string[];
  /**
   * @example
   * 30
   */
  partitionLifeCycle?: string;
  /**
   * @example
   * PARTITION BY VALUE(\\"id\\")
   */
  partitionStatement?: string;
  primaryKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      distributedKeys: 'DistributedKeys',
      partitionLifeCycle: 'PartitionLifeCycle',
      partitionStatement: 'PartitionStatement',
      primaryKeys: 'PrimaryKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      distributedKeys: { 'type': 'array', 'itemType': 'string' },
      partitionLifeCycle: 'string',
      partitionStatement: 'string',
      primaryKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(Array.isArray(this.distributedKeys)) {
      $dara.Model.validateArray(this.distributedKeys);
    }
    if(Array.isArray(this.primaryKeys)) {
      $dara.Model.validateArray(this.primaryKeys);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectRequestTransferMappingDatabasesSpecificViews extends $dara.Model {
  adbTableSchema?: CreateProjectRequestTransferMappingDatabasesSpecificViewsAdbTableSchema;
  filterColumns?: string[];
  /**
   * @example
   * e_3wsmjv49a***
   */
  id?: string;
  /**
   * @example
   * mapped_view
   */
  mappedName?: string;
  /**
   * @example
   * view_name
   */
  name?: string;
  shardColumns?: string[];
  /**
   * @example
   * id<5
   */
  whereClause?: string;
  static names(): { [key: string]: string } {
    return {
      adbTableSchema: 'AdbTableSchema',
      filterColumns: 'FilterColumns',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      shardColumns: 'ShardColumns',
      whereClause: 'WhereClause',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adbTableSchema: CreateProjectRequestTransferMappingDatabasesSpecificViewsAdbTableSchema,
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      mappedName: 'string',
      name: 'string',
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      whereClause: 'string',
    };
  }

  validate() {
    if(this.adbTableSchema && typeof (this.adbTableSchema as any).validate === 'function') {
      (this.adbTableSchema as any).validate();
    }
    if(Array.isArray(this.filterColumns)) {
      $dara.Model.validateArray(this.filterColumns);
    }
    if(Array.isArray(this.shardColumns)) {
      $dara.Model.validateArray(this.shardColumns);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectRequestTransferMappingDatabasesTablesAdbTableSchema extends $dara.Model {
  distributedKeys?: string[];
  /**
   * @example
   * 30
   */
  partitionLifeCycle?: string;
  /**
   * @example
   * PARTITION BY VALUE(\\"id\\")
   */
  partitionStatement?: string;
  primaryKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      distributedKeys: 'DistributedKeys',
      partitionLifeCycle: 'PartitionLifeCycle',
      partitionStatement: 'PartitionStatement',
      primaryKeys: 'PrimaryKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      distributedKeys: { 'type': 'array', 'itemType': 'string' },
      partitionLifeCycle: 'string',
      partitionStatement: 'string',
      primaryKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(Array.isArray(this.distributedKeys)) {
      $dara.Model.validateArray(this.distributedKeys);
    }
    if(Array.isArray(this.primaryKeys)) {
      $dara.Model.validateArray(this.primaryKeys);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectRequestTransferMappingDatabasesTablesObkvPartitionConfig extends $dara.Model {
  partitionSize?: number;
  partitionType?: string;
  virtualColumn?: string;
  static names(): { [key: string]: string } {
    return {
      partitionSize: 'PartitionSize',
      partitionType: 'PartitionType',
      virtualColumn: 'VirtualColumn',
    };
  }

  static types(): { [key: string]: any } {
    return {
      partitionSize: 'number',
      partitionType: 'string',
      virtualColumn: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectRequestTransferMappingDatabasesTables extends $dara.Model {
  adbTableSchema?: CreateProjectRequestTransferMappingDatabasesTablesAdbTableSchema;
  filterColumns?: string[];
  /**
   * @example
   * e_4l085bu7***
   */
  id?: string;
  /**
   * @example
   * mapped_table
   */
  mappedName?: string;
  /**
   * @example
   * table_name
   */
  name?: string;
  obkvPartitionConfig?: CreateProjectRequestTransferMappingDatabasesTablesObkvPartitionConfig;
  shardColumns?: string[];
  /**
   * @example
   * id > 1
   */
  whereClause?: string;
  static names(): { [key: string]: string } {
    return {
      adbTableSchema: 'AdbTableSchema',
      filterColumns: 'FilterColumns',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      obkvPartitionConfig: 'ObkvPartitionConfig',
      shardColumns: 'ShardColumns',
      whereClause: 'WhereClause',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adbTableSchema: CreateProjectRequestTransferMappingDatabasesTablesAdbTableSchema,
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      mappedName: 'string',
      name: 'string',
      obkvPartitionConfig: CreateProjectRequestTransferMappingDatabasesTablesObkvPartitionConfig,
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      whereClause: 'string',
    };
  }

  validate() {
    if(this.adbTableSchema && typeof (this.adbTableSchema as any).validate === 'function') {
      (this.adbTableSchema as any).validate();
    }
    if(Array.isArray(this.filterColumns)) {
      $dara.Model.validateArray(this.filterColumns);
    }
    if(this.obkvPartitionConfig && typeof (this.obkvPartitionConfig as any).validate === 'function') {
      (this.obkvPartitionConfig as any).validate();
    }
    if(Array.isArray(this.shardColumns)) {
      $dara.Model.validateArray(this.shardColumns);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectRequestTransferMappingDatabasesViewsAdbTableSchema extends $dara.Model {
  distributedKeys?: string[];
  /**
   * @example
   * 30
   */
  partitionLifeCycle?: string;
  /**
   * @example
   * PARTITION BY VALUE(\\"id\\")
   */
  partitionStatement?: string;
  primaryKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      distributedKeys: 'DistributedKeys',
      partitionLifeCycle: 'PartitionLifeCycle',
      partitionStatement: 'PartitionStatement',
      primaryKeys: 'PrimaryKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      distributedKeys: { 'type': 'array', 'itemType': 'string' },
      partitionLifeCycle: 'string',
      partitionStatement: 'string',
      primaryKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(Array.isArray(this.distributedKeys)) {
      $dara.Model.validateArray(this.distributedKeys);
    }
    if(Array.isArray(this.primaryKeys)) {
      $dara.Model.validateArray(this.primaryKeys);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectRequestTransferMappingDatabasesViews extends $dara.Model {
  adbTableSchema?: CreateProjectRequestTransferMappingDatabasesViewsAdbTableSchema;
  filterColumns?: string[];
  /**
   * @example
   * e_4himpq4z***
   */
  id?: string;
  /**
   * @example
   * mapped_view
   */
  mappedName?: string;
  /**
   * @example
   * view_name
   */
  name?: string;
  shardColumns?: string[];
  /**
   * @example
   * id>1
   */
  whereClause?: string;
  static names(): { [key: string]: string } {
    return {
      adbTableSchema: 'AdbTableSchema',
      filterColumns: 'FilterColumns',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      shardColumns: 'ShardColumns',
      whereClause: 'WhereClause',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adbTableSchema: CreateProjectRequestTransferMappingDatabasesViewsAdbTableSchema,
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      mappedName: 'string',
      name: 'string',
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      whereClause: 'string',
    };
  }

  validate() {
    if(this.adbTableSchema && typeof (this.adbTableSchema as any).validate === 'function') {
      (this.adbTableSchema as any).validate();
    }
    if(Array.isArray(this.filterColumns)) {
      $dara.Model.validateArray(this.filterColumns);
    }
    if(Array.isArray(this.shardColumns)) {
      $dara.Model.validateArray(this.shardColumns);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectRequestTransferMappingDatabases extends $dara.Model {
  /**
   * @example
   * cluster_name
   */
  clusterName?: string;
  /**
   * @example
   * gez3***
   */
  id?: string;
  /**
   * @example
   * mapped_db
   */
  mappedName?: string;
  /**
   * @example
   * db_name
   */
  name?: string;
  specificTables?: CreateProjectRequestTransferMappingDatabasesSpecificTables[];
  specificViews?: CreateProjectRequestTransferMappingDatabasesSpecificViews[];
  tables?: CreateProjectRequestTransferMappingDatabasesTables[];
  /**
   * @example
   * tenant_name
   */
  tenantName?: string;
  views?: CreateProjectRequestTransferMappingDatabasesViews[];
  static names(): { [key: string]: string } {
    return {
      clusterName: 'ClusterName',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      specificTables: 'SpecificTables',
      specificViews: 'SpecificViews',
      tables: 'Tables',
      tenantName: 'TenantName',
      views: 'Views',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterName: 'string',
      id: 'string',
      mappedName: 'string',
      name: 'string',
      specificTables: { 'type': 'array', 'itemType': CreateProjectRequestTransferMappingDatabasesSpecificTables },
      specificViews: { 'type': 'array', 'itemType': CreateProjectRequestTransferMappingDatabasesSpecificViews },
      tables: { 'type': 'array', 'itemType': CreateProjectRequestTransferMappingDatabasesTables },
      tenantName: 'string',
      views: { 'type': 'array', 'itemType': CreateProjectRequestTransferMappingDatabasesViews },
    };
  }

  validate() {
    if(Array.isArray(this.specificTables)) {
      $dara.Model.validateArray(this.specificTables);
    }
    if(Array.isArray(this.specificViews)) {
      $dara.Model.validateArray(this.specificViews);
    }
    if(Array.isArray(this.tables)) {
      $dara.Model.validateArray(this.tables);
    }
    if(Array.isArray(this.views)) {
      $dara.Model.validateArray(this.views);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectRequestTransferMappingDatabasesBlackSpecificTablesAdbTableSchema extends $dara.Model {
  distributedKeys?: string[];
  /**
   * @example
   * 30
   */
  partitionLifeCycle?: string;
  /**
   * @example
   * PARTITION BY VALUE(\\"id\\")
   */
  partitionStatement?: string;
  primaryKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      distributedKeys: 'DistributedKeys',
      partitionLifeCycle: 'PartitionLifeCycle',
      partitionStatement: 'PartitionStatement',
      primaryKeys: 'PrimaryKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      distributedKeys: { 'type': 'array', 'itemType': 'string' },
      partitionLifeCycle: 'string',
      partitionStatement: 'string',
      primaryKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(Array.isArray(this.distributedKeys)) {
      $dara.Model.validateArray(this.distributedKeys);
    }
    if(Array.isArray(this.primaryKeys)) {
      $dara.Model.validateArray(this.primaryKeys);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectRequestTransferMappingDatabasesBlackSpecificTables extends $dara.Model {
  adbTableSchema?: CreateProjectRequestTransferMappingDatabasesBlackSpecificTablesAdbTableSchema;
  filterColumns?: string[];
  /**
   * @example
   * e_4himpq4zf***
   */
  id?: string;
  /**
   * @example
   * mapped_table
   */
  mappedName?: string;
  /**
   * @example
   * table_name
   */
  name?: string;
  shardColumns?: string[];
  /**
   * @example
   * id<1
   */
  whereClause?: string;
  static names(): { [key: string]: string } {
    return {
      adbTableSchema: 'AdbTableSchema',
      filterColumns: 'FilterColumns',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      shardColumns: 'ShardColumns',
      whereClause: 'WhereClause',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adbTableSchema: CreateProjectRequestTransferMappingDatabasesBlackSpecificTablesAdbTableSchema,
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      mappedName: 'string',
      name: 'string',
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      whereClause: 'string',
    };
  }

  validate() {
    if(this.adbTableSchema && typeof (this.adbTableSchema as any).validate === 'function') {
      (this.adbTableSchema as any).validate();
    }
    if(Array.isArray(this.filterColumns)) {
      $dara.Model.validateArray(this.filterColumns);
    }
    if(Array.isArray(this.shardColumns)) {
      $dara.Model.validateArray(this.shardColumns);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectRequestTransferMappingDatabasesBlackSpecificViewsAdbTableSchema extends $dara.Model {
  distributedKeys?: string[];
  /**
   * @example
   * 30
   */
  partitionLifeCycle?: string;
  /**
   * @example
   * PARTITION BY VALUE(\\"id\\")
   */
  partitionStatement?: string;
  primaryKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      distributedKeys: 'DistributedKeys',
      partitionLifeCycle: 'PartitionLifeCycle',
      partitionStatement: 'PartitionStatement',
      primaryKeys: 'PrimaryKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      distributedKeys: { 'type': 'array', 'itemType': 'string' },
      partitionLifeCycle: 'string',
      partitionStatement: 'string',
      primaryKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(Array.isArray(this.distributedKeys)) {
      $dara.Model.validateArray(this.distributedKeys);
    }
    if(Array.isArray(this.primaryKeys)) {
      $dara.Model.validateArray(this.primaryKeys);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectRequestTransferMappingDatabasesBlackSpecificViews extends $dara.Model {
  adbTableSchema?: CreateProjectRequestTransferMappingDatabasesBlackSpecificViewsAdbTableSchema;
  filterColumns?: string[];
  /**
   * @example
   * e_474hmh5iqo***
   */
  id?: string;
  /**
   * @example
   * mapped_table
   */
  mappedName?: string;
  /**
   * @example
   * table_name
   */
  name?: string;
  shardColumns?: string[];
  /**
   * @example
   * id<1
   */
  whereClause?: string;
  static names(): { [key: string]: string } {
    return {
      adbTableSchema: 'AdbTableSchema',
      filterColumns: 'FilterColumns',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      shardColumns: 'ShardColumns',
      whereClause: 'WhereClause',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adbTableSchema: CreateProjectRequestTransferMappingDatabasesBlackSpecificViewsAdbTableSchema,
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      mappedName: 'string',
      name: 'string',
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      whereClause: 'string',
    };
  }

  validate() {
    if(this.adbTableSchema && typeof (this.adbTableSchema as any).validate === 'function') {
      (this.adbTableSchema as any).validate();
    }
    if(Array.isArray(this.filterColumns)) {
      $dara.Model.validateArray(this.filterColumns);
    }
    if(Array.isArray(this.shardColumns)) {
      $dara.Model.validateArray(this.shardColumns);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectRequestTransferMappingDatabasesBlackTablesAdbTableSchema extends $dara.Model {
  distributedKeys?: string[];
  /**
   * @example
   * 30
   */
  partitionLifeCycle?: string;
  /**
   * @example
   * PARTITION BY VALUE(\\"id\\")
   */
  partitionStatement?: string;
  primaryKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      distributedKeys: 'DistributedKeys',
      partitionLifeCycle: 'PartitionLifeCycle',
      partitionStatement: 'PartitionStatement',
      primaryKeys: 'PrimaryKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      distributedKeys: { 'type': 'array', 'itemType': 'string' },
      partitionLifeCycle: 'string',
      partitionStatement: 'string',
      primaryKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(Array.isArray(this.distributedKeys)) {
      $dara.Model.validateArray(this.distributedKeys);
    }
    if(Array.isArray(this.primaryKeys)) {
      $dara.Model.validateArray(this.primaryKeys);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectRequestTransferMappingDatabasesBlackTables extends $dara.Model {
  adbTableSchema?: CreateProjectRequestTransferMappingDatabasesBlackTablesAdbTableSchema;
  filterColumns?: string[];
  /**
   * @example
   * e_474hmh5iqo***
   */
  id?: string;
  /**
   * @example
   * mapped_table
   */
  mappedName?: string;
  /**
   * @example
   * table_name
   */
  name?: string;
  shardColumns?: string[];
  /**
   * @example
   * id<1
   */
  whereClause?: string;
  static names(): { [key: string]: string } {
    return {
      adbTableSchema: 'AdbTableSchema',
      filterColumns: 'FilterColumns',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      shardColumns: 'ShardColumns',
      whereClause: 'WhereClause',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adbTableSchema: CreateProjectRequestTransferMappingDatabasesBlackTablesAdbTableSchema,
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      mappedName: 'string',
      name: 'string',
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      whereClause: 'string',
    };
  }

  validate() {
    if(this.adbTableSchema && typeof (this.adbTableSchema as any).validate === 'function') {
      (this.adbTableSchema as any).validate();
    }
    if(Array.isArray(this.filterColumns)) {
      $dara.Model.validateArray(this.filterColumns);
    }
    if(Array.isArray(this.shardColumns)) {
      $dara.Model.validateArray(this.shardColumns);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectRequestTransferMappingDatabasesBlackViewsAdbTableSchema extends $dara.Model {
  distributedKeys?: string[];
  /**
   * @example
   * 30
   */
  partitionLifeCycle?: string;
  /**
   * @example
   * PARTITION BY VALUE(\\"id\\")
   */
  partitionStatement?: string;
  primaryKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      distributedKeys: 'DistributedKeys',
      partitionLifeCycle: 'PartitionLifeCycle',
      partitionStatement: 'PartitionStatement',
      primaryKeys: 'PrimaryKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      distributedKeys: { 'type': 'array', 'itemType': 'string' },
      partitionLifeCycle: 'string',
      partitionStatement: 'string',
      primaryKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(Array.isArray(this.distributedKeys)) {
      $dara.Model.validateArray(this.distributedKeys);
    }
    if(Array.isArray(this.primaryKeys)) {
      $dara.Model.validateArray(this.primaryKeys);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectRequestTransferMappingDatabasesBlackViews extends $dara.Model {
  adbTableSchema?: CreateProjectRequestTransferMappingDatabasesBlackViewsAdbTableSchema;
  filterColumns?: string[];
  /**
   * @example
   * e_4azdil4lu7mo
   */
  id?: string;
  /**
   * @example
   * mapped_view
   */
  mappedName?: string;
  /**
   * @example
   * view_name
   */
  name?: string;
  shardColumns?: string[];
  /**
   * @example
   * id<5
   */
  whereClause?: string;
  static names(): { [key: string]: string } {
    return {
      adbTableSchema: 'AdbTableSchema',
      filterColumns: 'FilterColumns',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      shardColumns: 'ShardColumns',
      whereClause: 'WhereClause',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adbTableSchema: CreateProjectRequestTransferMappingDatabasesBlackViewsAdbTableSchema,
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      mappedName: 'string',
      name: 'string',
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      whereClause: 'string',
    };
  }

  validate() {
    if(this.adbTableSchema && typeof (this.adbTableSchema as any).validate === 'function') {
      (this.adbTableSchema as any).validate();
    }
    if(Array.isArray(this.filterColumns)) {
      $dara.Model.validateArray(this.filterColumns);
    }
    if(Array.isArray(this.shardColumns)) {
      $dara.Model.validateArray(this.shardColumns);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectRequestTransferMappingDatabasesBlack extends $dara.Model {
  /**
   * @example
   * cluster_name
   */
  clusterName?: string;
  /**
   * @example
   * e_3y6v5v1x94f4
   */
  id?: string;
  /**
   * @example
   * mapped_db
   */
  mappedName?: string;
  /**
   * @example
   * db_name
   */
  name?: string;
  specificTables?: CreateProjectRequestTransferMappingDatabasesBlackSpecificTables[];
  specificViews?: CreateProjectRequestTransferMappingDatabasesBlackSpecificViews[];
  tables?: CreateProjectRequestTransferMappingDatabasesBlackTables[];
  /**
   * @example
   * tenant_name
   */
  tenantName?: string;
  views?: CreateProjectRequestTransferMappingDatabasesBlackViews[];
  static names(): { [key: string]: string } {
    return {
      clusterName: 'ClusterName',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      specificTables: 'SpecificTables',
      specificViews: 'SpecificViews',
      tables: 'Tables',
      tenantName: 'TenantName',
      views: 'Views',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterName: 'string',
      id: 'string',
      mappedName: 'string',
      name: 'string',
      specificTables: { 'type': 'array', 'itemType': CreateProjectRequestTransferMappingDatabasesBlackSpecificTables },
      specificViews: { 'type': 'array', 'itemType': CreateProjectRequestTransferMappingDatabasesBlackSpecificViews },
      tables: { 'type': 'array', 'itemType': CreateProjectRequestTransferMappingDatabasesBlackTables },
      tenantName: 'string',
      views: { 'type': 'array', 'itemType': CreateProjectRequestTransferMappingDatabasesBlackViews },
    };
  }

  validate() {
    if(Array.isArray(this.specificTables)) {
      $dara.Model.validateArray(this.specificTables);
    }
    if(Array.isArray(this.specificViews)) {
      $dara.Model.validateArray(this.specificViews);
    }
    if(Array.isArray(this.tables)) {
      $dara.Model.validateArray(this.tables);
    }
    if(Array.isArray(this.views)) {
      $dara.Model.validateArray(this.views);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectRequestTransferMapping extends $dara.Model {
  databases?: CreateProjectRequestTransferMappingDatabases[];
  databasesBlack?: CreateProjectRequestTransferMappingDatabasesBlack[];
  /**
   * @example
   * SPCEIFIC
   */
  mode?: string;
  tableAndViewBlackList?: string[];
  tableAndViewWhiteList?: string[];
  static names(): { [key: string]: string } {
    return {
      databases: 'Databases',
      databasesBlack: 'DatabasesBlack',
      mode: 'Mode',
      tableAndViewBlackList: 'TableAndViewBlackList',
      tableAndViewWhiteList: 'TableAndViewWhiteList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      databases: { 'type': 'array', 'itemType': CreateProjectRequestTransferMappingDatabases },
      databasesBlack: { 'type': 'array', 'itemType': CreateProjectRequestTransferMappingDatabasesBlack },
      mode: 'string',
      tableAndViewBlackList: { 'type': 'array', 'itemType': 'string' },
      tableAndViewWhiteList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(Array.isArray(this.databases)) {
      $dara.Model.validateArray(this.databases);
    }
    if(Array.isArray(this.databasesBlack)) {
      $dara.Model.validateArray(this.databasesBlack);
    }
    if(Array.isArray(this.tableAndViewBlackList)) {
      $dara.Model.validateArray(this.tableAndViewBlackList);
    }
    if(Array.isArray(this.tableAndViewWhiteList)) {
      $dara.Model.validateArray(this.tableAndViewWhiteList);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectResponseBodyErrorDetail extends $dara.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * Contact the administrator.
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  validate() {
    if(this.extraContext) {
      $dara.Model.validateMap(this.extraContext);
    }
    if(this.messageMcmsContext) {
      $dara.Model.validateMap(this.messageMcmsContext);
    }
    if(this.proposalMcmsContext) {
      $dara.Model.validateMap(this.proposalMcmsContext);
    }
    if(this.reasonMcmsContext) {
      $dara.Model.validateMap(this.reasonMcmsContext);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequestDatabasesSpecificTablesAdbTableSchema extends $dara.Model {
  distributedKeys?: string[];
  /**
   * @example
   * 30
   */
  partitionLifeCycle?: string;
  /**
   * @example
   * PARTITION BY VALUE(\\"id\\")
   */
  partitionStatement?: string;
  primaryKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      distributedKeys: 'DistributedKeys',
      partitionLifeCycle: 'PartitionLifeCycle',
      partitionStatement: 'PartitionStatement',
      primaryKeys: 'PrimaryKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      distributedKeys: { 'type': 'array', 'itemType': 'string' },
      partitionLifeCycle: 'string',
      partitionStatement: 'string',
      primaryKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(Array.isArray(this.distributedKeys)) {
      $dara.Model.validateArray(this.distributedKeys);
    }
    if(Array.isArray(this.primaryKeys)) {
      $dara.Model.validateArray(this.primaryKeys);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequestDatabasesSpecificTables extends $dara.Model {
  adbTableSchema?: CreateProjectModifyRecordsRequestDatabasesSpecificTablesAdbTableSchema;
  filterColumns?: string[];
  /**
   * @example
   * table_id
   */
  id?: string;
  /**
   * @example
   * mapped_table
   */
  mappedName?: string;
  /**
   * @example
   * table_name
   */
  name?: string;
  shardColumns?: string[];
  /**
   * @example
   * id<1
   */
  whereClause?: string;
  static names(): { [key: string]: string } {
    return {
      adbTableSchema: 'AdbTableSchema',
      filterColumns: 'FilterColumns',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      shardColumns: 'ShardColumns',
      whereClause: 'WhereClause',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adbTableSchema: CreateProjectModifyRecordsRequestDatabasesSpecificTablesAdbTableSchema,
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      mappedName: 'string',
      name: 'string',
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      whereClause: 'string',
    };
  }

  validate() {
    if(this.adbTableSchema && typeof (this.adbTableSchema as any).validate === 'function') {
      (this.adbTableSchema as any).validate();
    }
    if(Array.isArray(this.filterColumns)) {
      $dara.Model.validateArray(this.filterColumns);
    }
    if(Array.isArray(this.shardColumns)) {
      $dara.Model.validateArray(this.shardColumns);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequestDatabasesSpecificViewsAdbTableSchema extends $dara.Model {
  distributedKeys?: string[];
  /**
   * @example
   * 30
   */
  partitionLifeCycle?: string;
  /**
   * @example
   * PARTITION BY VALUE(\\"id\\")
   */
  partitionStatement?: string;
  primaryKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      distributedKeys: 'DistributedKeys',
      partitionLifeCycle: 'PartitionLifeCycle',
      partitionStatement: 'PartitionStatement',
      primaryKeys: 'PrimaryKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      distributedKeys: { 'type': 'array', 'itemType': 'string' },
      partitionLifeCycle: 'string',
      partitionStatement: 'string',
      primaryKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(Array.isArray(this.distributedKeys)) {
      $dara.Model.validateArray(this.distributedKeys);
    }
    if(Array.isArray(this.primaryKeys)) {
      $dara.Model.validateArray(this.primaryKeys);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequestDatabasesSpecificViews extends $dara.Model {
  adbTableSchema?: CreateProjectModifyRecordsRequestDatabasesSpecificViewsAdbTableSchema;
  filterColumns?: string[];
  /**
   * @example
   * view_id
   */
  id?: string;
  /**
   * @example
   * mapped_view
   */
  mappedName?: string;
  /**
   * @example
   * view_name
   */
  name?: string;
  shardColumns?: string[];
  /**
   * @example
   * id <1
   */
  whereClause?: string;
  static names(): { [key: string]: string } {
    return {
      adbTableSchema: 'AdbTableSchema',
      filterColumns: 'FilterColumns',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      shardColumns: 'ShardColumns',
      whereClause: 'WhereClause',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adbTableSchema: CreateProjectModifyRecordsRequestDatabasesSpecificViewsAdbTableSchema,
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      mappedName: 'string',
      name: 'string',
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      whereClause: 'string',
    };
  }

  validate() {
    if(this.adbTableSchema && typeof (this.adbTableSchema as any).validate === 'function') {
      (this.adbTableSchema as any).validate();
    }
    if(Array.isArray(this.filterColumns)) {
      $dara.Model.validateArray(this.filterColumns);
    }
    if(Array.isArray(this.shardColumns)) {
      $dara.Model.validateArray(this.shardColumns);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequestDatabasesTablesAdbTableSchema extends $dara.Model {
  distributedKeys?: string[];
  /**
   * @example
   * 30
   */
  partitionLifeCycle?: string;
  /**
   * @example
   * PARTITION BY VALUE(\\"id\\")
   */
  partitionStatement?: string;
  primaryKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      distributedKeys: 'DistributedKeys',
      partitionLifeCycle: 'PartitionLifeCycle',
      partitionStatement: 'PartitionStatement',
      primaryKeys: 'PrimaryKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      distributedKeys: { 'type': 'array', 'itemType': 'string' },
      partitionLifeCycle: 'string',
      partitionStatement: 'string',
      primaryKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(Array.isArray(this.distributedKeys)) {
      $dara.Model.validateArray(this.distributedKeys);
    }
    if(Array.isArray(this.primaryKeys)) {
      $dara.Model.validateArray(this.primaryKeys);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequestDatabasesTablesObkvPartitionConfig extends $dara.Model {
  partitionSize?: number;
  partitionType?: string;
  virtualColumn?: string;
  static names(): { [key: string]: string } {
    return {
      partitionSize: 'PartitionSize',
      partitionType: 'PartitionType',
      virtualColumn: 'VirtualColumn',
    };
  }

  static types(): { [key: string]: any } {
    return {
      partitionSize: 'number',
      partitionType: 'string',
      virtualColumn: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequestDatabasesTables extends $dara.Model {
  adbTableSchema?: CreateProjectModifyRecordsRequestDatabasesTablesAdbTableSchema;
  filterColumns?: string[];
  /**
   * @example
   * table_id
   */
  id?: string;
  /**
   * @example
   * mapped_table
   */
  mappedName?: string;
  /**
   * @example
   * table_name
   */
  name?: string;
  obkvPartitionConfig?: CreateProjectModifyRecordsRequestDatabasesTablesObkvPartitionConfig;
  shardColumns?: string[];
  /**
   * @example
   * id<1
   */
  whereClause?: string;
  static names(): { [key: string]: string } {
    return {
      adbTableSchema: 'AdbTableSchema',
      filterColumns: 'FilterColumns',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      obkvPartitionConfig: 'ObkvPartitionConfig',
      shardColumns: 'ShardColumns',
      whereClause: 'WhereClause',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adbTableSchema: CreateProjectModifyRecordsRequestDatabasesTablesAdbTableSchema,
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      mappedName: 'string',
      name: 'string',
      obkvPartitionConfig: CreateProjectModifyRecordsRequestDatabasesTablesObkvPartitionConfig,
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      whereClause: 'string',
    };
  }

  validate() {
    if(this.adbTableSchema && typeof (this.adbTableSchema as any).validate === 'function') {
      (this.adbTableSchema as any).validate();
    }
    if(Array.isArray(this.filterColumns)) {
      $dara.Model.validateArray(this.filterColumns);
    }
    if(this.obkvPartitionConfig && typeof (this.obkvPartitionConfig as any).validate === 'function') {
      (this.obkvPartitionConfig as any).validate();
    }
    if(Array.isArray(this.shardColumns)) {
      $dara.Model.validateArray(this.shardColumns);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequestDatabasesViewsAdbTableSchema extends $dara.Model {
  distributedKeys?: string[];
  /**
   * @example
   * 30
   */
  partitionLifeCycle?: string;
  /**
   * @example
   * PARTITION BY VALUE(\\"id\\")
   */
  partitionStatement?: string;
  primaryKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      distributedKeys: 'DistributedKeys',
      partitionLifeCycle: 'PartitionLifeCycle',
      partitionStatement: 'PartitionStatement',
      primaryKeys: 'PrimaryKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      distributedKeys: { 'type': 'array', 'itemType': 'string' },
      partitionLifeCycle: 'string',
      partitionStatement: 'string',
      primaryKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(Array.isArray(this.distributedKeys)) {
      $dara.Model.validateArray(this.distributedKeys);
    }
    if(Array.isArray(this.primaryKeys)) {
      $dara.Model.validateArray(this.primaryKeys);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequestDatabasesViews extends $dara.Model {
  adbTableSchema?: CreateProjectModifyRecordsRequestDatabasesViewsAdbTableSchema;
  filterColumns?: string[];
  /**
   * @example
   * view_id
   */
  id?: string;
  /**
   * @example
   * mapped_view
   */
  mappedName?: string;
  /**
   * @example
   * view_name
   */
  name?: string;
  shardColumns?: string[];
  /**
   * @example
   * id<1
   */
  whereClause?: string;
  static names(): { [key: string]: string } {
    return {
      adbTableSchema: 'AdbTableSchema',
      filterColumns: 'FilterColumns',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      shardColumns: 'ShardColumns',
      whereClause: 'WhereClause',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adbTableSchema: CreateProjectModifyRecordsRequestDatabasesViewsAdbTableSchema,
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      mappedName: 'string',
      name: 'string',
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      whereClause: 'string',
    };
  }

  validate() {
    if(this.adbTableSchema && typeof (this.adbTableSchema as any).validate === 'function') {
      (this.adbTableSchema as any).validate();
    }
    if(Array.isArray(this.filterColumns)) {
      $dara.Model.validateArray(this.filterColumns);
    }
    if(Array.isArray(this.shardColumns)) {
      $dara.Model.validateArray(this.shardColumns);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequestDatabases extends $dara.Model {
  /**
   * @example
   * db_id
   */
  id?: string;
  /**
   * @example
   * mapped_db
   */
  mappedName?: string;
  /**
   * @example
   * db_name
   */
  name?: string;
  specificTables?: CreateProjectModifyRecordsRequestDatabasesSpecificTables[];
  specificViews?: CreateProjectModifyRecordsRequestDatabasesSpecificViews[];
  tables?: CreateProjectModifyRecordsRequestDatabasesTables[];
  views?: CreateProjectModifyRecordsRequestDatabasesViews[];
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      specificTables: 'SpecificTables',
      specificViews: 'SpecificViews',
      tables: 'Tables',
      views: 'Views',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      mappedName: 'string',
      name: 'string',
      specificTables: { 'type': 'array', 'itemType': CreateProjectModifyRecordsRequestDatabasesSpecificTables },
      specificViews: { 'type': 'array', 'itemType': CreateProjectModifyRecordsRequestDatabasesSpecificViews },
      tables: { 'type': 'array', 'itemType': CreateProjectModifyRecordsRequestDatabasesTables },
      views: { 'type': 'array', 'itemType': CreateProjectModifyRecordsRequestDatabasesViews },
    };
  }

  validate() {
    if(Array.isArray(this.specificTables)) {
      $dara.Model.validateArray(this.specificTables);
    }
    if(Array.isArray(this.specificViews)) {
      $dara.Model.validateArray(this.specificViews);
    }
    if(Array.isArray(this.tables)) {
      $dara.Model.validateArray(this.tables);
    }
    if(Array.isArray(this.views)) {
      $dara.Model.validateArray(this.views);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequestTransferMappingBlackTableRulesObjectMapping extends $dara.Model {
  mappedName?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      mappedName: 'MappedName',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      mappedName: 'string',
      name: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequestTransferMappingBlackTableRulesSchemaMapping extends $dara.Model {
  mappedName?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      mappedName: 'MappedName',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      mappedName: 'string',
      name: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequestTransferMappingBlackTableRules extends $dara.Model {
  objectMapping?: CreateProjectModifyRecordsRequestTransferMappingBlackTableRulesObjectMapping;
  schemaMapping?: CreateProjectModifyRecordsRequestTransferMappingBlackTableRulesSchemaMapping;
  static names(): { [key: string]: string } {
    return {
      objectMapping: 'ObjectMapping',
      schemaMapping: 'SchemaMapping',
    };
  }

  static types(): { [key: string]: any } {
    return {
      objectMapping: CreateProjectModifyRecordsRequestTransferMappingBlackTableRulesObjectMapping,
      schemaMapping: CreateProjectModifyRecordsRequestTransferMappingBlackTableRulesSchemaMapping,
    };
  }

  validate() {
    if(this.objectMapping && typeof (this.objectMapping as any).validate === 'function') {
      (this.objectMapping as any).validate();
    }
    if(this.schemaMapping && typeof (this.schemaMapping as any).validate === 'function') {
      (this.schemaMapping as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequestTransferMappingBlackViewRulesObjectMapping extends $dara.Model {
  mappedName?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      mappedName: 'MappedName',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      mappedName: 'string',
      name: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequestTransferMappingBlackViewRulesSchemaMapping extends $dara.Model {
  mappedName?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      mappedName: 'MappedName',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      mappedName: 'string',
      name: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequestTransferMappingBlackViewRules extends $dara.Model {
  objectMapping?: CreateProjectModifyRecordsRequestTransferMappingBlackViewRulesObjectMapping;
  schemaMapping?: CreateProjectModifyRecordsRequestTransferMappingBlackViewRulesSchemaMapping;
  static names(): { [key: string]: string } {
    return {
      objectMapping: 'ObjectMapping',
      schemaMapping: 'SchemaMapping',
    };
  }

  static types(): { [key: string]: any } {
    return {
      objectMapping: CreateProjectModifyRecordsRequestTransferMappingBlackViewRulesObjectMapping,
      schemaMapping: CreateProjectModifyRecordsRequestTransferMappingBlackViewRulesSchemaMapping,
    };
  }

  validate() {
    if(this.objectMapping && typeof (this.objectMapping as any).validate === 'function') {
      (this.objectMapping as any).validate();
    }
    if(this.schemaMapping && typeof (this.schemaMapping as any).validate === 'function') {
      (this.schemaMapping as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequestTransferMappingDatabasesSpecificTablesAdbTableSchema extends $dara.Model {
  distributedKeys?: string[];
  partitionLifeCycle?: string;
  partitionStatement?: string;
  primaryKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      distributedKeys: 'DistributedKeys',
      partitionLifeCycle: 'PartitionLifeCycle',
      partitionStatement: 'PartitionStatement',
      primaryKeys: 'PrimaryKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      distributedKeys: { 'type': 'array', 'itemType': 'string' },
      partitionLifeCycle: 'string',
      partitionStatement: 'string',
      primaryKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(Array.isArray(this.distributedKeys)) {
      $dara.Model.validateArray(this.distributedKeys);
    }
    if(Array.isArray(this.primaryKeys)) {
      $dara.Model.validateArray(this.primaryKeys);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequestTransferMappingDatabasesSpecificTables extends $dara.Model {
  adbTableSchema?: CreateProjectModifyRecordsRequestTransferMappingDatabasesSpecificTablesAdbTableSchema;
  filterColumns?: string[];
  id?: string;
  mappedName?: string;
  name?: string;
  shardColumns?: string[];
  whereClause?: string;
  static names(): { [key: string]: string } {
    return {
      adbTableSchema: 'AdbTableSchema',
      filterColumns: 'FilterColumns',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      shardColumns: 'ShardColumns',
      whereClause: 'WhereClause',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adbTableSchema: CreateProjectModifyRecordsRequestTransferMappingDatabasesSpecificTablesAdbTableSchema,
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      mappedName: 'string',
      name: 'string',
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      whereClause: 'string',
    };
  }

  validate() {
    if(this.adbTableSchema && typeof (this.adbTableSchema as any).validate === 'function') {
      (this.adbTableSchema as any).validate();
    }
    if(Array.isArray(this.filterColumns)) {
      $dara.Model.validateArray(this.filterColumns);
    }
    if(Array.isArray(this.shardColumns)) {
      $dara.Model.validateArray(this.shardColumns);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequestTransferMappingDatabasesSpecificViewsAdbTableSchema extends $dara.Model {
  distributedKeys?: string[];
  partitionLifeCycle?: string;
  partitionStatement?: string;
  primaryKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      distributedKeys: 'DistributedKeys',
      partitionLifeCycle: 'PartitionLifeCycle',
      partitionStatement: 'PartitionStatement',
      primaryKeys: 'PrimaryKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      distributedKeys: { 'type': 'array', 'itemType': 'string' },
      partitionLifeCycle: 'string',
      partitionStatement: 'string',
      primaryKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(Array.isArray(this.distributedKeys)) {
      $dara.Model.validateArray(this.distributedKeys);
    }
    if(Array.isArray(this.primaryKeys)) {
      $dara.Model.validateArray(this.primaryKeys);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequestTransferMappingDatabasesSpecificViews extends $dara.Model {
  adbTableSchema?: CreateProjectModifyRecordsRequestTransferMappingDatabasesSpecificViewsAdbTableSchema;
  filterColumns?: string[];
  id?: string;
  mappedName?: string;
  name?: string;
  shardColumns?: string[];
  whereClause?: string;
  static names(): { [key: string]: string } {
    return {
      adbTableSchema: 'AdbTableSchema',
      filterColumns: 'FilterColumns',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      shardColumns: 'ShardColumns',
      whereClause: 'WhereClause',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adbTableSchema: CreateProjectModifyRecordsRequestTransferMappingDatabasesSpecificViewsAdbTableSchema,
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      mappedName: 'string',
      name: 'string',
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      whereClause: 'string',
    };
  }

  validate() {
    if(this.adbTableSchema && typeof (this.adbTableSchema as any).validate === 'function') {
      (this.adbTableSchema as any).validate();
    }
    if(Array.isArray(this.filterColumns)) {
      $dara.Model.validateArray(this.filterColumns);
    }
    if(Array.isArray(this.shardColumns)) {
      $dara.Model.validateArray(this.shardColumns);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequestTransferMappingDatabasesTablesAdbTableSchema extends $dara.Model {
  distributedKeys?: string[];
  partitionLifeCycle?: string;
  partitionStatement?: string;
  primaryKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      distributedKeys: 'DistributedKeys',
      partitionLifeCycle: 'PartitionLifeCycle',
      partitionStatement: 'PartitionStatement',
      primaryKeys: 'PrimaryKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      distributedKeys: { 'type': 'array', 'itemType': 'string' },
      partitionLifeCycle: 'string',
      partitionStatement: 'string',
      primaryKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(Array.isArray(this.distributedKeys)) {
      $dara.Model.validateArray(this.distributedKeys);
    }
    if(Array.isArray(this.primaryKeys)) {
      $dara.Model.validateArray(this.primaryKeys);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequestTransferMappingDatabasesTablesObkvPartitionConfig extends $dara.Model {
  partitionSize?: number;
  partitionType?: string;
  virtualColumn?: string;
  static names(): { [key: string]: string } {
    return {
      partitionSize: 'PartitionSize',
      partitionType: 'PartitionType',
      virtualColumn: 'VirtualColumn',
    };
  }

  static types(): { [key: string]: any } {
    return {
      partitionSize: 'number',
      partitionType: 'string',
      virtualColumn: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequestTransferMappingDatabasesTables extends $dara.Model {
  adbTableSchema?: CreateProjectModifyRecordsRequestTransferMappingDatabasesTablesAdbTableSchema;
  filterColumns?: string[];
  id?: string;
  mappedName?: string;
  name?: string;
  obkvPartitionConfig?: CreateProjectModifyRecordsRequestTransferMappingDatabasesTablesObkvPartitionConfig;
  shardColumns?: string[];
  whereClause?: string;
  static names(): { [key: string]: string } {
    return {
      adbTableSchema: 'AdbTableSchema',
      filterColumns: 'FilterColumns',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      obkvPartitionConfig: 'ObkvPartitionConfig',
      shardColumns: 'ShardColumns',
      whereClause: 'WhereClause',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adbTableSchema: CreateProjectModifyRecordsRequestTransferMappingDatabasesTablesAdbTableSchema,
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      mappedName: 'string',
      name: 'string',
      obkvPartitionConfig: CreateProjectModifyRecordsRequestTransferMappingDatabasesTablesObkvPartitionConfig,
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      whereClause: 'string',
    };
  }

  validate() {
    if(this.adbTableSchema && typeof (this.adbTableSchema as any).validate === 'function') {
      (this.adbTableSchema as any).validate();
    }
    if(Array.isArray(this.filterColumns)) {
      $dara.Model.validateArray(this.filterColumns);
    }
    if(this.obkvPartitionConfig && typeof (this.obkvPartitionConfig as any).validate === 'function') {
      (this.obkvPartitionConfig as any).validate();
    }
    if(Array.isArray(this.shardColumns)) {
      $dara.Model.validateArray(this.shardColumns);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequestTransferMappingDatabasesViewsAdbTableSchema extends $dara.Model {
  distributedKeys?: string[];
  partitionLifeCycle?: string;
  partitionStatement?: string;
  primaryKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      distributedKeys: 'DistributedKeys',
      partitionLifeCycle: 'PartitionLifeCycle',
      partitionStatement: 'PartitionStatement',
      primaryKeys: 'PrimaryKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      distributedKeys: { 'type': 'array', 'itemType': 'string' },
      partitionLifeCycle: 'string',
      partitionStatement: 'string',
      primaryKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(Array.isArray(this.distributedKeys)) {
      $dara.Model.validateArray(this.distributedKeys);
    }
    if(Array.isArray(this.primaryKeys)) {
      $dara.Model.validateArray(this.primaryKeys);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequestTransferMappingDatabasesViews extends $dara.Model {
  adbTableSchema?: CreateProjectModifyRecordsRequestTransferMappingDatabasesViewsAdbTableSchema;
  filterColumns?: string[];
  id?: string;
  mappedName?: string;
  name?: string;
  shardColumns?: string[];
  whereClause?: string;
  static names(): { [key: string]: string } {
    return {
      adbTableSchema: 'AdbTableSchema',
      filterColumns: 'FilterColumns',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      shardColumns: 'ShardColumns',
      whereClause: 'WhereClause',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adbTableSchema: CreateProjectModifyRecordsRequestTransferMappingDatabasesViewsAdbTableSchema,
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      mappedName: 'string',
      name: 'string',
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      whereClause: 'string',
    };
  }

  validate() {
    if(this.adbTableSchema && typeof (this.adbTableSchema as any).validate === 'function') {
      (this.adbTableSchema as any).validate();
    }
    if(Array.isArray(this.filterColumns)) {
      $dara.Model.validateArray(this.filterColumns);
    }
    if(Array.isArray(this.shardColumns)) {
      $dara.Model.validateArray(this.shardColumns);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequestTransferMappingDatabases extends $dara.Model {
  clusterName?: string;
  id?: string;
  mappedName?: string;
  name?: string;
  specificTables?: CreateProjectModifyRecordsRequestTransferMappingDatabasesSpecificTables[];
  specificViews?: CreateProjectModifyRecordsRequestTransferMappingDatabasesSpecificViews[];
  tables?: CreateProjectModifyRecordsRequestTransferMappingDatabasesTables[];
  tenantName?: string;
  views?: CreateProjectModifyRecordsRequestTransferMappingDatabasesViews[];
  static names(): { [key: string]: string } {
    return {
      clusterName: 'ClusterName',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      specificTables: 'SpecificTables',
      specificViews: 'SpecificViews',
      tables: 'Tables',
      tenantName: 'TenantName',
      views: 'Views',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterName: 'string',
      id: 'string',
      mappedName: 'string',
      name: 'string',
      specificTables: { 'type': 'array', 'itemType': CreateProjectModifyRecordsRequestTransferMappingDatabasesSpecificTables },
      specificViews: { 'type': 'array', 'itemType': CreateProjectModifyRecordsRequestTransferMappingDatabasesSpecificViews },
      tables: { 'type': 'array', 'itemType': CreateProjectModifyRecordsRequestTransferMappingDatabasesTables },
      tenantName: 'string',
      views: { 'type': 'array', 'itemType': CreateProjectModifyRecordsRequestTransferMappingDatabasesViews },
    };
  }

  validate() {
    if(Array.isArray(this.specificTables)) {
      $dara.Model.validateArray(this.specificTables);
    }
    if(Array.isArray(this.specificViews)) {
      $dara.Model.validateArray(this.specificViews);
    }
    if(Array.isArray(this.tables)) {
      $dara.Model.validateArray(this.tables);
    }
    if(Array.isArray(this.views)) {
      $dara.Model.validateArray(this.views);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequestTransferMappingDatabasesBlackSpecificTablesAdbTableSchema extends $dara.Model {
  distributedKeys?: string[];
  partitionLifeCycle?: string;
  partitionStatement?: string;
  primaryKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      distributedKeys: 'DistributedKeys',
      partitionLifeCycle: 'PartitionLifeCycle',
      partitionStatement: 'PartitionStatement',
      primaryKeys: 'PrimaryKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      distributedKeys: { 'type': 'array', 'itemType': 'string' },
      partitionLifeCycle: 'string',
      partitionStatement: 'string',
      primaryKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(Array.isArray(this.distributedKeys)) {
      $dara.Model.validateArray(this.distributedKeys);
    }
    if(Array.isArray(this.primaryKeys)) {
      $dara.Model.validateArray(this.primaryKeys);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequestTransferMappingDatabasesBlackSpecificTables extends $dara.Model {
  adbTableSchema?: CreateProjectModifyRecordsRequestTransferMappingDatabasesBlackSpecificTablesAdbTableSchema;
  filterColumns?: string[];
  id?: string;
  mappedName?: string;
  name?: string;
  shardColumns?: string[];
  whereClause?: string;
  static names(): { [key: string]: string } {
    return {
      adbTableSchema: 'AdbTableSchema',
      filterColumns: 'FilterColumns',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      shardColumns: 'ShardColumns',
      whereClause: 'WhereClause',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adbTableSchema: CreateProjectModifyRecordsRequestTransferMappingDatabasesBlackSpecificTablesAdbTableSchema,
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      mappedName: 'string',
      name: 'string',
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      whereClause: 'string',
    };
  }

  validate() {
    if(this.adbTableSchema && typeof (this.adbTableSchema as any).validate === 'function') {
      (this.adbTableSchema as any).validate();
    }
    if(Array.isArray(this.filterColumns)) {
      $dara.Model.validateArray(this.filterColumns);
    }
    if(Array.isArray(this.shardColumns)) {
      $dara.Model.validateArray(this.shardColumns);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequestTransferMappingDatabasesBlackSpecificViewsAdbTableSchema extends $dara.Model {
  distributedKeys?: string[];
  partitionLifeCycle?: string;
  partitionStatement?: string;
  primaryKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      distributedKeys: 'DistributedKeys',
      partitionLifeCycle: 'PartitionLifeCycle',
      partitionStatement: 'PartitionStatement',
      primaryKeys: 'PrimaryKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      distributedKeys: { 'type': 'array', 'itemType': 'string' },
      partitionLifeCycle: 'string',
      partitionStatement: 'string',
      primaryKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(Array.isArray(this.distributedKeys)) {
      $dara.Model.validateArray(this.distributedKeys);
    }
    if(Array.isArray(this.primaryKeys)) {
      $dara.Model.validateArray(this.primaryKeys);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequestTransferMappingDatabasesBlackSpecificViews extends $dara.Model {
  adbTableSchema?: CreateProjectModifyRecordsRequestTransferMappingDatabasesBlackSpecificViewsAdbTableSchema;
  filterColumns?: string[];
  id?: string;
  mappedName?: string;
  name?: string;
  shardColumns?: string[];
  whereClause?: string;
  static names(): { [key: string]: string } {
    return {
      adbTableSchema: 'AdbTableSchema',
      filterColumns: 'FilterColumns',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      shardColumns: 'ShardColumns',
      whereClause: 'WhereClause',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adbTableSchema: CreateProjectModifyRecordsRequestTransferMappingDatabasesBlackSpecificViewsAdbTableSchema,
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      mappedName: 'string',
      name: 'string',
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      whereClause: 'string',
    };
  }

  validate() {
    if(this.adbTableSchema && typeof (this.adbTableSchema as any).validate === 'function') {
      (this.adbTableSchema as any).validate();
    }
    if(Array.isArray(this.filterColumns)) {
      $dara.Model.validateArray(this.filterColumns);
    }
    if(Array.isArray(this.shardColumns)) {
      $dara.Model.validateArray(this.shardColumns);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequestTransferMappingDatabasesBlackTablesAdbTableSchema extends $dara.Model {
  distributedKeys?: string[];
  partitionLifeCycle?: string;
  partitionStatement?: string;
  primaryKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      distributedKeys: 'DistributedKeys',
      partitionLifeCycle: 'PartitionLifeCycle',
      partitionStatement: 'PartitionStatement',
      primaryKeys: 'PrimaryKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      distributedKeys: { 'type': 'array', 'itemType': 'string' },
      partitionLifeCycle: 'string',
      partitionStatement: 'string',
      primaryKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(Array.isArray(this.distributedKeys)) {
      $dara.Model.validateArray(this.distributedKeys);
    }
    if(Array.isArray(this.primaryKeys)) {
      $dara.Model.validateArray(this.primaryKeys);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequestTransferMappingDatabasesBlackTables extends $dara.Model {
  adbTableSchema?: CreateProjectModifyRecordsRequestTransferMappingDatabasesBlackTablesAdbTableSchema;
  filterColumns?: string[];
  id?: string;
  mappedName?: string;
  name?: string;
  shardColumns?: string[];
  whereClause?: string;
  static names(): { [key: string]: string } {
    return {
      adbTableSchema: 'AdbTableSchema',
      filterColumns: 'FilterColumns',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      shardColumns: 'ShardColumns',
      whereClause: 'WhereClause',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adbTableSchema: CreateProjectModifyRecordsRequestTransferMappingDatabasesBlackTablesAdbTableSchema,
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      mappedName: 'string',
      name: 'string',
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      whereClause: 'string',
    };
  }

  validate() {
    if(this.adbTableSchema && typeof (this.adbTableSchema as any).validate === 'function') {
      (this.adbTableSchema as any).validate();
    }
    if(Array.isArray(this.filterColumns)) {
      $dara.Model.validateArray(this.filterColumns);
    }
    if(Array.isArray(this.shardColumns)) {
      $dara.Model.validateArray(this.shardColumns);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequestTransferMappingDatabasesBlackViewsAdbTableSchema extends $dara.Model {
  distributedKeys?: string[];
  partitionLifeCycle?: string;
  partitionStatement?: string;
  primaryKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      distributedKeys: 'DistributedKeys',
      partitionLifeCycle: 'PartitionLifeCycle',
      partitionStatement: 'PartitionStatement',
      primaryKeys: 'PrimaryKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      distributedKeys: { 'type': 'array', 'itemType': 'string' },
      partitionLifeCycle: 'string',
      partitionStatement: 'string',
      primaryKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(Array.isArray(this.distributedKeys)) {
      $dara.Model.validateArray(this.distributedKeys);
    }
    if(Array.isArray(this.primaryKeys)) {
      $dara.Model.validateArray(this.primaryKeys);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequestTransferMappingDatabasesBlackViews extends $dara.Model {
  adbTableSchema?: CreateProjectModifyRecordsRequestTransferMappingDatabasesBlackViewsAdbTableSchema;
  filterColumns?: string[];
  id?: string;
  mappedName?: string;
  name?: string;
  shardColumns?: string[];
  whereClause?: string;
  static names(): { [key: string]: string } {
    return {
      adbTableSchema: 'AdbTableSchema',
      filterColumns: 'FilterColumns',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      shardColumns: 'ShardColumns',
      whereClause: 'WhereClause',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adbTableSchema: CreateProjectModifyRecordsRequestTransferMappingDatabasesBlackViewsAdbTableSchema,
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      mappedName: 'string',
      name: 'string',
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      whereClause: 'string',
    };
  }

  validate() {
    if(this.adbTableSchema && typeof (this.adbTableSchema as any).validate === 'function') {
      (this.adbTableSchema as any).validate();
    }
    if(Array.isArray(this.filterColumns)) {
      $dara.Model.validateArray(this.filterColumns);
    }
    if(Array.isArray(this.shardColumns)) {
      $dara.Model.validateArray(this.shardColumns);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequestTransferMappingDatabasesBlack extends $dara.Model {
  clusterName?: string;
  id?: string;
  mappedName?: string;
  name?: string;
  specificTables?: CreateProjectModifyRecordsRequestTransferMappingDatabasesBlackSpecificTables[];
  specificViews?: CreateProjectModifyRecordsRequestTransferMappingDatabasesBlackSpecificViews[];
  tables?: CreateProjectModifyRecordsRequestTransferMappingDatabasesBlackTables[];
  tenantName?: string;
  views?: CreateProjectModifyRecordsRequestTransferMappingDatabasesBlackViews[];
  static names(): { [key: string]: string } {
    return {
      clusterName: 'ClusterName',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      specificTables: 'SpecificTables',
      specificViews: 'SpecificViews',
      tables: 'Tables',
      tenantName: 'TenantName',
      views: 'Views',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterName: 'string',
      id: 'string',
      mappedName: 'string',
      name: 'string',
      specificTables: { 'type': 'array', 'itemType': CreateProjectModifyRecordsRequestTransferMappingDatabasesBlackSpecificTables },
      specificViews: { 'type': 'array', 'itemType': CreateProjectModifyRecordsRequestTransferMappingDatabasesBlackSpecificViews },
      tables: { 'type': 'array', 'itemType': CreateProjectModifyRecordsRequestTransferMappingDatabasesBlackTables },
      tenantName: 'string',
      views: { 'type': 'array', 'itemType': CreateProjectModifyRecordsRequestTransferMappingDatabasesBlackViews },
    };
  }

  validate() {
    if(Array.isArray(this.specificTables)) {
      $dara.Model.validateArray(this.specificTables);
    }
    if(Array.isArray(this.specificViews)) {
      $dara.Model.validateArray(this.specificViews);
    }
    if(Array.isArray(this.tables)) {
      $dara.Model.validateArray(this.tables);
    }
    if(Array.isArray(this.views)) {
      $dara.Model.validateArray(this.views);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequestTransferMappingSchemasSpecificTablesAdbTableSchema extends $dara.Model {
  distributedKeys?: string[];
  partitionLifeCycle?: string;
  partitionStatement?: string;
  primaryKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      distributedKeys: 'DistributedKeys',
      partitionLifeCycle: 'PartitionLifeCycle',
      partitionStatement: 'PartitionStatement',
      primaryKeys: 'PrimaryKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      distributedKeys: { 'type': 'array', 'itemType': 'string' },
      partitionLifeCycle: 'string',
      partitionStatement: 'string',
      primaryKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(Array.isArray(this.distributedKeys)) {
      $dara.Model.validateArray(this.distributedKeys);
    }
    if(Array.isArray(this.primaryKeys)) {
      $dara.Model.validateArray(this.primaryKeys);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequestTransferMappingSchemasSpecificTables extends $dara.Model {
  adbTableSchema?: CreateProjectModifyRecordsRequestTransferMappingSchemasSpecificTablesAdbTableSchema;
  filterColumns?: string[];
  id?: string;
  mappedName?: string;
  name?: string;
  shardColumns?: string[];
  whereClause?: string;
  static names(): { [key: string]: string } {
    return {
      adbTableSchema: 'AdbTableSchema',
      filterColumns: 'FilterColumns',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      shardColumns: 'ShardColumns',
      whereClause: 'WhereClause',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adbTableSchema: CreateProjectModifyRecordsRequestTransferMappingSchemasSpecificTablesAdbTableSchema,
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      mappedName: 'string',
      name: 'string',
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      whereClause: 'string',
    };
  }

  validate() {
    if(this.adbTableSchema && typeof (this.adbTableSchema as any).validate === 'function') {
      (this.adbTableSchema as any).validate();
    }
    if(Array.isArray(this.filterColumns)) {
      $dara.Model.validateArray(this.filterColumns);
    }
    if(Array.isArray(this.shardColumns)) {
      $dara.Model.validateArray(this.shardColumns);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequestTransferMappingSchemasSpecificViewsAdbTableSchema extends $dara.Model {
  distributedKeys?: string[];
  partitionLifeCycle?: string;
  partitionStatement?: string;
  primaryKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      distributedKeys: 'DistributedKeys',
      partitionLifeCycle: 'PartitionLifeCycle',
      partitionStatement: 'PartitionStatement',
      primaryKeys: 'PrimaryKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      distributedKeys: { 'type': 'array', 'itemType': 'string' },
      partitionLifeCycle: 'string',
      partitionStatement: 'string',
      primaryKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(Array.isArray(this.distributedKeys)) {
      $dara.Model.validateArray(this.distributedKeys);
    }
    if(Array.isArray(this.primaryKeys)) {
      $dara.Model.validateArray(this.primaryKeys);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequestTransferMappingSchemasSpecificViews extends $dara.Model {
  adbTableSchema?: CreateProjectModifyRecordsRequestTransferMappingSchemasSpecificViewsAdbTableSchema;
  filterColumns?: string[];
  id?: string;
  mappedName?: string;
  name?: string;
  shardColumns?: string[];
  whereClause?: string;
  static names(): { [key: string]: string } {
    return {
      adbTableSchema: 'AdbTableSchema',
      filterColumns: 'FilterColumns',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      shardColumns: 'ShardColumns',
      whereClause: 'WhereClause',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adbTableSchema: CreateProjectModifyRecordsRequestTransferMappingSchemasSpecificViewsAdbTableSchema,
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      mappedName: 'string',
      name: 'string',
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      whereClause: 'string',
    };
  }

  validate() {
    if(this.adbTableSchema && typeof (this.adbTableSchema as any).validate === 'function') {
      (this.adbTableSchema as any).validate();
    }
    if(Array.isArray(this.filterColumns)) {
      $dara.Model.validateArray(this.filterColumns);
    }
    if(Array.isArray(this.shardColumns)) {
      $dara.Model.validateArray(this.shardColumns);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequestTransferMappingSchemasTablesAdbTableSchema extends $dara.Model {
  distributedKeys?: string[];
  partitionLifeCycle?: string;
  partitionStatement?: string;
  primaryKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      distributedKeys: 'DistributedKeys',
      partitionLifeCycle: 'PartitionLifeCycle',
      partitionStatement: 'PartitionStatement',
      primaryKeys: 'PrimaryKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      distributedKeys: { 'type': 'array', 'itemType': 'string' },
      partitionLifeCycle: 'string',
      partitionStatement: 'string',
      primaryKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(Array.isArray(this.distributedKeys)) {
      $dara.Model.validateArray(this.distributedKeys);
    }
    if(Array.isArray(this.primaryKeys)) {
      $dara.Model.validateArray(this.primaryKeys);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequestTransferMappingSchemasTablesObkvPartitionConfig extends $dara.Model {
  partitionSize?: number;
  partitionType?: string;
  virtualColumn?: string;
  static names(): { [key: string]: string } {
    return {
      partitionSize: 'PartitionSize',
      partitionType: 'PartitionType',
      virtualColumn: 'VirtualColumn',
    };
  }

  static types(): { [key: string]: any } {
    return {
      partitionSize: 'number',
      partitionType: 'string',
      virtualColumn: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequestTransferMappingSchemasTables extends $dara.Model {
  adbTableSchema?: CreateProjectModifyRecordsRequestTransferMappingSchemasTablesAdbTableSchema;
  filterColumns?: string[];
  id?: string;
  mappedName?: string;
  name?: string;
  obkvPartitionConfig?: CreateProjectModifyRecordsRequestTransferMappingSchemasTablesObkvPartitionConfig;
  shardColumns?: string[];
  whereClause?: string;
  static names(): { [key: string]: string } {
    return {
      adbTableSchema: 'AdbTableSchema',
      filterColumns: 'FilterColumns',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      obkvPartitionConfig: 'ObkvPartitionConfig',
      shardColumns: 'ShardColumns',
      whereClause: 'WhereClause',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adbTableSchema: CreateProjectModifyRecordsRequestTransferMappingSchemasTablesAdbTableSchema,
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      mappedName: 'string',
      name: 'string',
      obkvPartitionConfig: CreateProjectModifyRecordsRequestTransferMappingSchemasTablesObkvPartitionConfig,
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      whereClause: 'string',
    };
  }

  validate() {
    if(this.adbTableSchema && typeof (this.adbTableSchema as any).validate === 'function') {
      (this.adbTableSchema as any).validate();
    }
    if(Array.isArray(this.filterColumns)) {
      $dara.Model.validateArray(this.filterColumns);
    }
    if(this.obkvPartitionConfig && typeof (this.obkvPartitionConfig as any).validate === 'function') {
      (this.obkvPartitionConfig as any).validate();
    }
    if(Array.isArray(this.shardColumns)) {
      $dara.Model.validateArray(this.shardColumns);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequestTransferMappingSchemasViewsAdbTableSchema extends $dara.Model {
  distributedKeys?: string[];
  partitionLifeCycle?: string;
  partitionStatement?: string;
  primaryKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      distributedKeys: 'DistributedKeys',
      partitionLifeCycle: 'PartitionLifeCycle',
      partitionStatement: 'PartitionStatement',
      primaryKeys: 'PrimaryKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      distributedKeys: { 'type': 'array', 'itemType': 'string' },
      partitionLifeCycle: 'string',
      partitionStatement: 'string',
      primaryKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(Array.isArray(this.distributedKeys)) {
      $dara.Model.validateArray(this.distributedKeys);
    }
    if(Array.isArray(this.primaryKeys)) {
      $dara.Model.validateArray(this.primaryKeys);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequestTransferMappingSchemasViews extends $dara.Model {
  adbTableSchema?: CreateProjectModifyRecordsRequestTransferMappingSchemasViewsAdbTableSchema;
  filterColumns?: string[];
  id?: string;
  mappedName?: string;
  name?: string;
  shardColumns?: string[];
  whereClause?: string;
  static names(): { [key: string]: string } {
    return {
      adbTableSchema: 'AdbTableSchema',
      filterColumns: 'FilterColumns',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      shardColumns: 'ShardColumns',
      whereClause: 'WhereClause',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adbTableSchema: CreateProjectModifyRecordsRequestTransferMappingSchemasViewsAdbTableSchema,
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      mappedName: 'string',
      name: 'string',
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      whereClause: 'string',
    };
  }

  validate() {
    if(this.adbTableSchema && typeof (this.adbTableSchema as any).validate === 'function') {
      (this.adbTableSchema as any).validate();
    }
    if(Array.isArray(this.filterColumns)) {
      $dara.Model.validateArray(this.filterColumns);
    }
    if(Array.isArray(this.shardColumns)) {
      $dara.Model.validateArray(this.shardColumns);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequestTransferMappingSchemas extends $dara.Model {
  clusterName?: string;
  id?: string;
  mappedName?: string;
  name?: string;
  specificTables?: CreateProjectModifyRecordsRequestTransferMappingSchemasSpecificTables[];
  specificViews?: CreateProjectModifyRecordsRequestTransferMappingSchemasSpecificViews[];
  tables?: CreateProjectModifyRecordsRequestTransferMappingSchemasTables[];
  tenantName?: string;
  views?: CreateProjectModifyRecordsRequestTransferMappingSchemasViews[];
  static names(): { [key: string]: string } {
    return {
      clusterName: 'ClusterName',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      specificTables: 'SpecificTables',
      specificViews: 'SpecificViews',
      tables: 'Tables',
      tenantName: 'TenantName',
      views: 'Views',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterName: 'string',
      id: 'string',
      mappedName: 'string',
      name: 'string',
      specificTables: { 'type': 'array', 'itemType': CreateProjectModifyRecordsRequestTransferMappingSchemasSpecificTables },
      specificViews: { 'type': 'array', 'itemType': CreateProjectModifyRecordsRequestTransferMappingSchemasSpecificViews },
      tables: { 'type': 'array', 'itemType': CreateProjectModifyRecordsRequestTransferMappingSchemasTables },
      tenantName: 'string',
      views: { 'type': 'array', 'itemType': CreateProjectModifyRecordsRequestTransferMappingSchemasViews },
    };
  }

  validate() {
    if(Array.isArray(this.specificTables)) {
      $dara.Model.validateArray(this.specificTables);
    }
    if(Array.isArray(this.specificViews)) {
      $dara.Model.validateArray(this.specificViews);
    }
    if(Array.isArray(this.tables)) {
      $dara.Model.validateArray(this.tables);
    }
    if(Array.isArray(this.views)) {
      $dara.Model.validateArray(this.views);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequestTransferMappingWhiteTableRulesObjectMapping extends $dara.Model {
  mappedName?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      mappedName: 'MappedName',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      mappedName: 'string',
      name: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequestTransferMappingWhiteTableRulesSchemaMapping extends $dara.Model {
  mappedName?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      mappedName: 'MappedName',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      mappedName: 'string',
      name: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequestTransferMappingWhiteTableRules extends $dara.Model {
  objectMapping?: CreateProjectModifyRecordsRequestTransferMappingWhiteTableRulesObjectMapping;
  schemaMapping?: CreateProjectModifyRecordsRequestTransferMappingWhiteTableRulesSchemaMapping;
  static names(): { [key: string]: string } {
    return {
      objectMapping: 'ObjectMapping',
      schemaMapping: 'SchemaMapping',
    };
  }

  static types(): { [key: string]: any } {
    return {
      objectMapping: CreateProjectModifyRecordsRequestTransferMappingWhiteTableRulesObjectMapping,
      schemaMapping: CreateProjectModifyRecordsRequestTransferMappingWhiteTableRulesSchemaMapping,
    };
  }

  validate() {
    if(this.objectMapping && typeof (this.objectMapping as any).validate === 'function') {
      (this.objectMapping as any).validate();
    }
    if(this.schemaMapping && typeof (this.schemaMapping as any).validate === 'function') {
      (this.schemaMapping as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequestTransferMappingWhiteViewRulesObjectMapping extends $dara.Model {
  mappedName?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      mappedName: 'MappedName',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      mappedName: 'string',
      name: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequestTransferMappingWhiteViewRulesSchemaMapping extends $dara.Model {
  mappedName?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      mappedName: 'MappedName',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      mappedName: 'string',
      name: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequestTransferMappingWhiteViewRules extends $dara.Model {
  objectMapping?: CreateProjectModifyRecordsRequestTransferMappingWhiteViewRulesObjectMapping;
  schemaMapping?: CreateProjectModifyRecordsRequestTransferMappingWhiteViewRulesSchemaMapping;
  static names(): { [key: string]: string } {
    return {
      objectMapping: 'ObjectMapping',
      schemaMapping: 'SchemaMapping',
    };
  }

  static types(): { [key: string]: any } {
    return {
      objectMapping: CreateProjectModifyRecordsRequestTransferMappingWhiteViewRulesObjectMapping,
      schemaMapping: CreateProjectModifyRecordsRequestTransferMappingWhiteViewRulesSchemaMapping,
    };
  }

  validate() {
    if(this.objectMapping && typeof (this.objectMapping as any).validate === 'function') {
      (this.objectMapping as any).validate();
    }
    if(this.schemaMapping && typeof (this.schemaMapping as any).validate === 'function') {
      (this.schemaMapping as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequestTransferMapping extends $dara.Model {
  blackTableRules?: CreateProjectModifyRecordsRequestTransferMappingBlackTableRules[];
  blackViewRules?: CreateProjectModifyRecordsRequestTransferMappingBlackViewRules[];
  databases?: CreateProjectModifyRecordsRequestTransferMappingDatabases[];
  databasesBlack?: CreateProjectModifyRecordsRequestTransferMappingDatabasesBlack[];
  /**
   * @example
   * SPCEIFIC
   */
  mode?: string;
  schemas?: CreateProjectModifyRecordsRequestTransferMappingSchemas[];
  tableAndViewBlackList?: string[];
  tableAndViewWhiteList?: string[];
  whiteTableRules?: CreateProjectModifyRecordsRequestTransferMappingWhiteTableRules[];
  whiteViewRules?: CreateProjectModifyRecordsRequestTransferMappingWhiteViewRules[];
  static names(): { [key: string]: string } {
    return {
      blackTableRules: 'BlackTableRules',
      blackViewRules: 'BlackViewRules',
      databases: 'Databases',
      databasesBlack: 'DatabasesBlack',
      mode: 'Mode',
      schemas: 'Schemas',
      tableAndViewBlackList: 'TableAndViewBlackList',
      tableAndViewWhiteList: 'TableAndViewWhiteList',
      whiteTableRules: 'WhiteTableRules',
      whiteViewRules: 'WhiteViewRules',
    };
  }

  static types(): { [key: string]: any } {
    return {
      blackTableRules: { 'type': 'array', 'itemType': CreateProjectModifyRecordsRequestTransferMappingBlackTableRules },
      blackViewRules: { 'type': 'array', 'itemType': CreateProjectModifyRecordsRequestTransferMappingBlackViewRules },
      databases: { 'type': 'array', 'itemType': CreateProjectModifyRecordsRequestTransferMappingDatabases },
      databasesBlack: { 'type': 'array', 'itemType': CreateProjectModifyRecordsRequestTransferMappingDatabasesBlack },
      mode: 'string',
      schemas: { 'type': 'array', 'itemType': CreateProjectModifyRecordsRequestTransferMappingSchemas },
      tableAndViewBlackList: { 'type': 'array', 'itemType': 'string' },
      tableAndViewWhiteList: { 'type': 'array', 'itemType': 'string' },
      whiteTableRules: { 'type': 'array', 'itemType': CreateProjectModifyRecordsRequestTransferMappingWhiteTableRules },
      whiteViewRules: { 'type': 'array', 'itemType': CreateProjectModifyRecordsRequestTransferMappingWhiteViewRules },
    };
  }

  validate() {
    if(Array.isArray(this.blackTableRules)) {
      $dara.Model.validateArray(this.blackTableRules);
    }
    if(Array.isArray(this.blackViewRules)) {
      $dara.Model.validateArray(this.blackViewRules);
    }
    if(Array.isArray(this.databases)) {
      $dara.Model.validateArray(this.databases);
    }
    if(Array.isArray(this.databasesBlack)) {
      $dara.Model.validateArray(this.databasesBlack);
    }
    if(Array.isArray(this.schemas)) {
      $dara.Model.validateArray(this.schemas);
    }
    if(Array.isArray(this.tableAndViewBlackList)) {
      $dara.Model.validateArray(this.tableAndViewBlackList);
    }
    if(Array.isArray(this.tableAndViewWhiteList)) {
      $dara.Model.validateArray(this.tableAndViewWhiteList);
    }
    if(Array.isArray(this.whiteTableRules)) {
      $dara.Model.validateArray(this.whiteTableRules);
    }
    if(Array.isArray(this.whiteViewRules)) {
      $dara.Model.validateArray(this.whiteViewRules);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsResponseBodyErrorDetail extends $dara.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * Contact the administrator.
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  validate() {
    if(this.extraContext) {
      $dara.Model.validateMap(this.extraContext);
    }
    if(this.messageMcmsContext) {
      $dara.Model.validateMap(this.messageMcmsContext);
    }
    if(this.proposalMcmsContext) {
      $dara.Model.validateMap(this.proposalMcmsContext);
    }
    if(this.reasonMcmsContext) {
      $dara.Model.validateMap(this.reasonMcmsContext);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRdsPostgreSQLDataSourceResponseBodyErrorDetail extends $dara.Model {
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * null
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  validate() {
    if(this.extraContext) {
      $dara.Model.validateMap(this.extraContext);
    }
    if(this.messageMcmsContext) {
      $dara.Model.validateMap(this.messageMcmsContext);
    }
    if(this.proposalMcmsContext) {
      $dara.Model.validateMap(this.proposalMcmsContext);
    }
    if(this.reasonMcmsContext) {
      $dara.Model.validateMap(this.reasonMcmsContext);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSecurityIpGroupResponseBodySecurityIpGroup extends $dara.Model {
  /**
   * @remarks
   * ```
   * http(s)://[Endpoint]/?Action=CreateSecurityIpGroup
   * &InstanceId=ob317v4uif****
   * &SecurityIps=192.168.1.1,192.168.0.0.1/8
   * &SecurityIpGroupName=pay_online
   * &Common request parameters
   * ```
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * You can call this operation to create an IP address whitelist group.
   * 
   * @example
   * pay_online
   */
  securityIpGroupName?: string;
  /**
   * @example
   * 192.168.1.1,192.168.0.0.1/8
   */
  securityIps?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      securityIpGroupName: 'SecurityIpGroupName',
      securityIps: 'SecurityIps',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      securityIpGroupName: 'string',
      securityIps: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTenantSecurityIpGroupResponseBodySecurityIpGroup extends $dara.Model {
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The name of the whitelist group.
   * 
   * @example
   * paytest
   */
  securityIpGroupName?: string;
  /**
   * @remarks
   * The list of IP addresses in the IP address whitelist group.   
   * 
   * It is a string separated by commas, and each object is an IP address or CIDR block.
   * 
   * @example
   * 192.***.*.*
   */
  securityIps?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * @example
   * t4louaeei****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      securityIpGroupName: 'SecurityIpGroupName',
      securityIps: 'SecurityIps',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      securityIpGroupName: 'string',
      securityIps: 'string',
      tenantId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTenantUserResponseBodyTenantUserRoles extends $dara.Model {
  /**
   * @example
   * db_pay1
   */
  database?: string;
  /**
   * @example
   * ReadOnly
   */
  role?: string;
  static names(): { [key: string]: string } {
    return {
      database: 'Database',
      role: 'Role',
    };
  }

  static types(): { [key: string]: any } {
    return {
      database: 'string',
      role: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTenantUserResponseBodyTenantUser extends $dara.Model {
  /**
   * @example
   * Encrypt,Decrypt
   */
  globalPermissions?: string;
  roles?: CreateTenantUserResponseBodyTenantUserRoles[];
  /**
   * @example
   * pay_test
   */
  userName?: string;
  /**
   * @example
   * ONLINE
   */
  userStatus?: string;
  userType?: string;
  static names(): { [key: string]: string } {
    return {
      globalPermissions: 'GlobalPermissions',
      roles: 'Roles',
      userName: 'UserName',
      userStatus: 'UserStatus',
      userType: 'UserType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      globalPermissions: 'string',
      roles: { 'type': 'array', 'itemType': CreateTenantUserResponseBodyTenantUserRoles },
      userName: 'string',
      userStatus: 'string',
      userType: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.roles)) {
      $dara.Model.validateArray(this.roles);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDataSourceResponseBodyErrorDetail extends $dara.Model {
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * Contact the administrator.
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  validate() {
    if(this.extraContext) {
      $dara.Model.validateMap(this.extraContext);
    }
    if(this.messageMcmsContext) {
      $dara.Model.validateMap(this.messageMcmsContext);
    }
    if(this.proposalMcmsContext) {
      $dara.Model.validateMap(this.proposalMcmsContext);
    }
    if(this.reasonMcmsContext) {
      $dara.Model.validateMap(this.reasonMcmsContext);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteInstancesResponseBodyData extends $dara.Model {
  /**
   * @remarks
   * The result of the dry-run request.
   * - If the DryRun parameter is set to true and the dry run succeeds, the DryRunResult parameter returns true. Otherwise, an error code is returned.
   * - If the DryRun parameter is set to false, no dry run is performed and the DryRunResult parameter returns false.
   * 
   * @example
   * false
   */
  dryRunResult?: boolean;
  static names(): { [key: string]: string } {
    return {
      dryRunResult: 'DryRunResult',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dryRunResult: 'boolean',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProjectResponseBodyErrorDetail extends $dara.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * Contact the administrator.
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  validate() {
    if(this.extraContext) {
      $dara.Model.validateMap(this.extraContext);
    }
    if(this.messageMcmsContext) {
      $dara.Model.validateMap(this.messageMcmsContext);
    }
    if(this.proposalMcmsContext) {
      $dara.Model.validateMap(this.proposalMcmsContext);
    }
    if(this.reasonMcmsContext) {
      $dara.Model.validateMap(this.reasonMcmsContext);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSecurityIpGroupResponseBodySecurityIpGroup extends $dara.Model {
  /**
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @example
   * paytest
   */
  securityIpGroupName?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      securityIpGroupName: 'SecurityIpGroupName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      securityIpGroupName: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTenantSecurityIpGroupResponseBodySecurityIpGroup extends $dara.Model {
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The name of the whitelist group.
   * 
   * @example
   * paytest
   */
  securityIpGroupName?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * @example
   * t4louaeei****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      securityIpGroupName: 'SecurityIpGroupName',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      securityIpGroupName: 'string',
      tenantId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAnomalySQLListResponseBodyAnomalySQLList extends $dara.Model {
  /**
   * @remarks
   * The average CPU time, in ms.
   * 
   * @example
   * 50.13
   */
  cpuTime?: number;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * database1
   */
  dbName?: string;
  /**
   * @remarks
   * The diagnosis information.
   * 
   * @example
   * Total number of executions = 80199, Average CPU time = 6.8 ms, Overall CPU utilization = 87%
   */
  diagnosis?: string;
  /**
   * @remarks
   * The diagnostic rule.
   * 
   * @example
   * Utilization above threshold
   */
  diagnosisRule?: string;
  /**
   * @remarks
   * The number of executions.
   * 
   * @example
   * 89043
   */
  executions?: number;
  /**
   * @remarks
   * The sequence number of the returned SQL statement.
   * 
   * @example
   * 1
   */
  key?: number;
  /**
   * @remarks
   * The request time, in ms.
   * 
   * @example
   * 50.00
   */
  requestTime?: number;
  /**
   * @remarks
   * The request time in UTC +0.
   * 
   * @example
   * 2022-01-11T07:08:00Z
   */
  requestTimeUTCString?: string;
  /**
   * @remarks
   * SQLID.
   * 
   * @example
   * 99E9D3BF****B486239E6C7BC79B****
   */
  SQLId?: string;
  /**
   * @remarks
   * The SQL text.
   * 
   * @example
   * SELECT  ****   FROM ****   WHERE **** = ? AND **** = ?   ORDER BY **** ASC
   */
  SQLText?: string;
  /**
   * @remarks
   * The suggestions.
   * 
   * @example
   * Check your business scenarios, data distribution changes, request surges, and execution plan changes.
   */
  suggestion?: string;
  /**
   * @remarks
   * The username.
   * 
   * @example
   * tester
   */
  userName?: string;
  static names(): { [key: string]: string } {
    return {
      cpuTime: 'CpuTime',
      dbName: 'DbName',
      diagnosis: 'Diagnosis',
      diagnosisRule: 'DiagnosisRule',
      executions: 'Executions',
      key: 'Key',
      requestTime: 'RequestTime',
      requestTimeUTCString: 'RequestTimeUTCString',
      SQLId: 'SQLId',
      SQLText: 'SQLText',
      suggestion: 'Suggestion',
      userName: 'UserName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cpuTime: 'number',
      dbName: 'string',
      diagnosis: 'string',
      diagnosisRule: 'string',
      executions: 'number',
      key: 'number',
      requestTime: 'number',
      requestTimeUTCString: 'string',
      SQLId: 'string',
      SQLText: 'string',
      suggestion: 'string',
      userName: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAvailableCpuResourceResponseBodyData extends $dara.Model {
  /**
   * @example
   * UnitNum.RejectComment.Storage
   */
  comment?: string;
  /**
   * @example
   * 10
   */
  maxCpu?: number;
  /**
   * @example
   * 2
   */
  minCpu?: number;
  /**
   * @example
   * UnitNum.Change.Accept
   */
  reviewCode?: string;
  /**
   * @example
   * 2
   */
  unitNum?: number;
  static names(): { [key: string]: string } {
    return {
      comment: 'Comment',
      maxCpu: 'MaxCpu',
      minCpu: 'MinCpu',
      reviewCode: 'ReviewCode',
      unitNum: 'UnitNum',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comment: 'string',
      maxCpu: 'number',
      minCpu: 'number',
      reviewCode: 'string',
      unitNum: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAvailableMemResourceResponseBodyData extends $dara.Model {
  /**
   * @remarks
   * The maximum memory size for each resource unit, in GB.
   * 
   * @example
   * 10
   */
  maxMem?: number;
  /**
   * @remarks
   * The minimum memory size required for each resource unit, in GB.
   * 
   * @example
   * 5
   */
  minMem?: number;
  /**
   * @remarks
   * The maximum allowed memory usage, in GB.
   * 
   * @example
   * 10.0
   */
  safeMem?: string;
  /**
   * @remarks
   * The number of resource units in the tenant.
   * 
   * @example
   * 2
   */
  usedMem?: number;
  static names(): { [key: string]: string } {
    return {
      maxMem: 'MaxMem',
      minMem: 'MinMem',
      safeMem: 'SafeMem',
      usedMem: 'UsedMem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxMem: 'number',
      minMem: 'number',
      safeMem: 'string',
      usedMem: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAvailableSpecResponseBodyDataAvailableSpecificationsDiskSizeRange extends $dara.Model {
  /**
   * @example
   * 40000
   */
  max?: number;
  /**
   * @example
   * 1000
   */
  min?: number;
  /**
   * @example
   * 5
   */
  step?: number;
  static names(): { [key: string]: string } {
    return {
      max: 'Max',
      min: 'Min',
      step: 'Step',
    };
  }

  static types(): { [key: string]: any } {
    return {
      max: 'number',
      min: 'number',
      step: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAvailableSpecResponseBodyDataAvailableSpecificationsLogDiskSizeRange extends $dara.Model {
  /**
   * @example
   * 4000
   */
  max?: number;
  /**
   * @example
   * 100
   */
  min?: number;
  /**
   * @example
   * 5
   */
  step?: number;
  static names(): { [key: string]: string } {
    return {
      max: 'Max',
      min: 'Min',
      step: 'Step',
    };
  }

  static types(): { [key: string]: any } {
    return {
      max: 'number',
      min: 'number',
      step: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAvailableSpecResponseBodyDataAvailableSpecifications extends $dara.Model {
  diskSizeRange?: DescribeAvailableSpecResponseBodyDataAvailableSpecificationsDiskSizeRange;
  diskTypes?: string[];
  /**
   * @example
   * 4C16GB
   */
  instanceClass?: string;
  logDiskSizeRange?: DescribeAvailableSpecResponseBodyDataAvailableSpecificationsLogDiskSizeRange;
  nodeNum?: number[];
  /**
   * @example
   * oceanbase.cluster.cd8.xlarge
   */
  spec?: string;
  static names(): { [key: string]: string } {
    return {
      diskSizeRange: 'DiskSizeRange',
      diskTypes: 'DiskTypes',
      instanceClass: 'InstanceClass',
      logDiskSizeRange: 'LogDiskSizeRange',
      nodeNum: 'NodeNum',
      spec: 'Spec',
    };
  }

  static types(): { [key: string]: any } {
    return {
      diskSizeRange: DescribeAvailableSpecResponseBodyDataAvailableSpecificationsDiskSizeRange,
      diskTypes: { 'type': 'array', 'itemType': 'string' },
      instanceClass: 'string',
      logDiskSizeRange: DescribeAvailableSpecResponseBodyDataAvailableSpecificationsLogDiskSizeRange,
      nodeNum: { 'type': 'array', 'itemType': 'number' },
      spec: 'string',
    };
  }

  validate() {
    if(this.diskSizeRange && typeof (this.diskSizeRange as any).validate === 'function') {
      (this.diskSizeRange as any).validate();
    }
    if(Array.isArray(this.diskTypes)) {
      $dara.Model.validateArray(this.diskTypes);
    }
    if(this.logDiskSizeRange && typeof (this.logDiskSizeRange as any).validate === 'function') {
      (this.logDiskSizeRange as any).validate();
    }
    if(Array.isArray(this.nodeNum)) {
      $dara.Model.validateArray(this.nodeNum);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAvailableSpecResponseBodyData extends $dara.Model {
  availableSpecifications?: DescribeAvailableSpecResponseBodyDataAvailableSpecifications[];
  static names(): { [key: string]: string } {
    return {
      availableSpecifications: 'AvailableSpecifications',
    };
  }

  static types(): { [key: string]: any } {
    return {
      availableSpecifications: { 'type': 'array', 'itemType': DescribeAvailableSpecResponseBodyDataAvailableSpecifications },
    };
  }

  validate() {
    if(Array.isArray(this.availableSpecifications)) {
      $dara.Model.validateArray(this.availableSpecifications);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAvailableZoneResponseBodyDataAvailableZonesSupportSpecificationsDiskSizeRange extends $dara.Model {
  /**
   * @example
   * 40000
   */
  max?: number;
  /**
   * @example
   * 1000
   */
  min?: number;
  /**
   * @example
   * 5
   */
  step?: number;
  static names(): { [key: string]: string } {
    return {
      max: 'Max',
      min: 'Min',
      step: 'Step',
    };
  }

  static types(): { [key: string]: any } {
    return {
      max: 'number',
      min: 'number',
      step: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAvailableZoneResponseBodyDataAvailableZonesSupportSpecificationsSupportEngineVersions extends $dara.Model {
  /**
   * @example
   * 3.2.4.4
   */
  obVersion?: string;
  /**
   * @example
   * true
   */
  supportIsolationOptimization?: boolean;
  supportReplicaModes?: string[];
  static names(): { [key: string]: string } {
    return {
      obVersion: 'ObVersion',
      supportIsolationOptimization: 'SupportIsolationOptimization',
      supportReplicaModes: 'SupportReplicaModes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      obVersion: 'string',
      supportIsolationOptimization: 'boolean',
      supportReplicaModes: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(Array.isArray(this.supportReplicaModes)) {
      $dara.Model.validateArray(this.supportReplicaModes);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAvailableZoneResponseBodyDataAvailableZonesSupportSpecifications extends $dara.Model {
  diskSizeRange?: DescribeAvailableZoneResponseBodyDataAvailableZonesSupportSpecificationsDiskSizeRange;
  diskTypes?: string[];
  /**
   * @example
   * 4C16GB
   */
  instanceClass?: string;
  /**
   * @example
   * oceanbase.cluster.cd8.xlarge
   */
  spec?: string;
  supportEngineVersions?: DescribeAvailableZoneResponseBodyDataAvailableZonesSupportSpecificationsSupportEngineVersions[];
  static names(): { [key: string]: string } {
    return {
      diskSizeRange: 'DiskSizeRange',
      diskTypes: 'DiskTypes',
      instanceClass: 'InstanceClass',
      spec: 'Spec',
      supportEngineVersions: 'SupportEngineVersions',
    };
  }

  static types(): { [key: string]: any } {
    return {
      diskSizeRange: DescribeAvailableZoneResponseBodyDataAvailableZonesSupportSpecificationsDiskSizeRange,
      diskTypes: { 'type': 'array', 'itemType': 'string' },
      instanceClass: 'string',
      spec: 'string',
      supportEngineVersions: { 'type': 'array', 'itemType': DescribeAvailableZoneResponseBodyDataAvailableZonesSupportSpecificationsSupportEngineVersions },
    };
  }

  validate() {
    if(this.diskSizeRange && typeof (this.diskSizeRange as any).validate === 'function') {
      (this.diskSizeRange as any).validate();
    }
    if(Array.isArray(this.diskTypes)) {
      $dara.Model.validateArray(this.diskTypes);
    }
    if(Array.isArray(this.supportEngineVersions)) {
      $dara.Model.validateArray(this.supportEngineVersions);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAvailableZoneResponseBodyDataAvailableZones extends $dara.Model {
  /**
   * @example
   * PUBLIC
   */
  channel?: string;
  /**
   * @example
   * x86
   */
  cpuArch?: string;
  /**
   * @example
   * multiple
   */
  deployType?: string;
  /**
   * @example
   * cluster
   */
  instanceType?: string;
  /**
   * @example
   * cn-hangzhou
   */
  region?: string;
  /**
   * @example
   * normal
   */
  series?: string;
  supportSpecifications?: DescribeAvailableZoneResponseBodyDataAvailableZonesSupportSpecifications[];
  /**
   * @example
   * cn-hangzhou-h,cn-hangzhou-i,cn-hangzhou-j
   */
  zones?: string;
  static names(): { [key: string]: string } {
    return {
      channel: 'Channel',
      cpuArch: 'CpuArch',
      deployType: 'DeployType',
      instanceType: 'InstanceType',
      region: 'Region',
      series: 'Series',
      supportSpecifications: 'SupportSpecifications',
      zones: 'Zones',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channel: 'string',
      cpuArch: 'string',
      deployType: 'string',
      instanceType: 'string',
      region: 'string',
      series: 'string',
      supportSpecifications: { 'type': 'array', 'itemType': DescribeAvailableZoneResponseBodyDataAvailableZonesSupportSpecifications },
      zones: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.supportSpecifications)) {
      $dara.Model.validateArray(this.supportSpecifications);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAvailableZoneResponseBodyData extends $dara.Model {
  availableZones?: DescribeAvailableZoneResponseBodyDataAvailableZones[];
  static names(): { [key: string]: string } {
    return {
      availableZones: 'AvailableZones',
    };
  }

  static types(): { [key: string]: any } {
    return {
      availableZones: { 'type': 'array', 'itemType': DescribeAvailableZoneResponseBodyDataAvailableZones },
    };
  }

  validate() {
    if(Array.isArray(this.availableZones)) {
      $dara.Model.validateArray(this.availableZones);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackupEncryptedStringResponseBodyData extends $dara.Model {
  backupInfoJson?: string;
  static names(): { [key: string]: string } {
    return {
      backupInfoJson: 'BackupInfoJson',
    };
  }

  static types(): { [key: string]: any } {
    return {
      backupInfoJson: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackupSetDownloadLinkResponseBodyData extends $dara.Model {
  /**
   * @remarks
   * The restorable time of the backup set.
   * 
   * @example
   * yyyy-MM-dd HH:mm:ss
   */
  backupRestorableTime?: string;
  /**
   * @remarks
   * The ID of the target backup set.
   * 
   * @example
   * bak-4n****gacpa8
   */
  backupSetId?: string;
  /**
   * @remarks
   * The time when the download task corresponding to the target backup set was created.
   * 
   * @example
   * 2020-05-22T17:04:18
   */
  downloadTaskCreateTime?: string;
  /**
   * @remarks
   * The ID of the download task corresponding to the target backup set.
   * 
   * @example
   * 1000002
   */
  downloadTaskId?: number;
  /**
   * @remarks
   * The status of the download task corresponding to the target backup set.
   * 
   * @example
   * RUNNING
   */
  downloadTaskStatus?: string;
  /**
   * @remarks
   * The internal URL.
   * 
   * @example
   * http://bucket.oss-region-internal.aliyuncs.com/xxxxx
   */
  internalUrl?: string;
  /**
   * @remarks
   * The validity period of the URL, in seconds.
   * 
   * @example
   * 3600
   */
  urlAliveTime?: number;
  /**
   * @remarks
   * The expiration time of the URL.
   * 
   * @example
   * 2024-01-04 17:39:49
   */
  urlExpiredTime?: string;
  static names(): { [key: string]: string } {
    return {
      backupRestorableTime: 'BackupRestorableTime',
      backupSetId: 'BackupSetId',
      downloadTaskCreateTime: 'DownloadTaskCreateTime',
      downloadTaskId: 'DownloadTaskId',
      downloadTaskStatus: 'DownloadTaskStatus',
      internalUrl: 'InternalUrl',
      urlAliveTime: 'UrlAliveTime',
      urlExpiredTime: 'UrlExpiredTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      backupRestorableTime: 'string',
      backupSetId: 'string',
      downloadTaskCreateTime: 'string',
      downloadTaskId: 'number',
      downloadTaskStatus: 'string',
      internalUrl: 'string',
      urlAliveTime: 'number',
      urlExpiredTime: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCharsetResponseBodyCharset extends $dara.Model {
  /**
   * @remarks
   * DescribeCharset
   * 
   * @example
   * utf8
   */
  charset?: string;
  collations?: string[];
  static names(): { [key: string]: string } {
    return {
      charset: 'Charset',
      collations: 'Collations',
    };
  }

  static types(): { [key: string]: any } {
    return {
      charset: 'string',
      collations: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(Array.isArray(this.collations)) {
      $dara.Model.validateArray(this.collations);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDataBackupSetResponseBodyDataBackupObjectsDatabaseTablesList extends $dara.Model {
  /**
   * @example
   * sms_pre
   */
  database?: string;
  tables?: string[];
  static names(): { [key: string]: string } {
    return {
      database: 'Database',
      tables: 'Tables',
    };
  }

  static types(): { [key: string]: any } {
    return {
      database: 'string',
      tables: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(Array.isArray(this.tables)) {
      $dara.Model.validateArray(this.tables);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDataBackupSetResponseBodyDataBackupObjects extends $dara.Model {
  /**
   * @example
   * test-****way
   */
  clusterName?: string;
  databaseTablesList?: DescribeDataBackupSetResponseBodyDataBackupObjectsDatabaseTablesList[];
  /**
   * @example
   * ob2mr3oae0****
   */
  tenantName?: string;
  static names(): { [key: string]: string } {
    return {
      clusterName: 'ClusterName',
      databaseTablesList: 'DatabaseTablesList',
      tenantName: 'TenantName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterName: 'string',
      databaseTablesList: { 'type': 'array', 'itemType': DescribeDataBackupSetResponseBodyDataBackupObjectsDatabaseTablesList },
      tenantName: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.databaseTablesList)) {
      $dara.Model.validateArray(this.databaseTablesList);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDataBackupSetResponseBodyDataBackupResultsTableBackupResults extends $dara.Model {
  /**
   * @example
   * order_ce****_online
   */
  database?: string;
  /**
   * @example
   * Create tag success
   */
  message?: string;
  /**
   * @example
   * RUNNING
   */
  status?: string;
  /**
   * @example
   * tr_sale_order_****
   */
  table?: string;
  static names(): { [key: string]: string } {
    return {
      database: 'Database',
      message: 'Message',
      status: 'Status',
      table: 'Table',
    };
  }

  static types(): { [key: string]: any } {
    return {
      database: 'string',
      message: 'string',
      status: 'string',
      table: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDataBackupSetResponseBodyDataBackupResults extends $dara.Model {
  /**
   * @example
   * container-opa-****-02
   */
  clusterName?: string;
  tableBackupResults?: DescribeDataBackupSetResponseBodyDataBackupResultsTableBackupResults[];
  /**
   * @example
   * ob2mr3oae0****
   */
  tenantName?: string;
  static names(): { [key: string]: string } {
    return {
      clusterName: 'ClusterName',
      tableBackupResults: 'TableBackupResults',
      tenantName: 'TenantName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterName: 'string',
      tableBackupResults: { 'type': 'array', 'itemType': DescribeDataBackupSetResponseBodyDataBackupResultsTableBackupResults },
      tenantName: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.tableBackupResults)) {
      $dara.Model.validateArray(this.tableBackupResults);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDataBackupSetResponseBodyData extends $dara.Model {
  /**
   * @example
   * cluster
   */
  backupObjectType?: string;
  backupObjects?: DescribeDataBackupSetResponseBodyDataBackupObjects[];
  backupResults?: DescribeDataBackupSetResponseBodyDataBackupResults[];
  /**
   * @example
   * 2023-05-15T07:11:08Z
   */
  checkpoint?: string;
  /**
   * @example
   * 31457280
   */
  dataSize?: number;
  /**
   * @example
   * 1678847020352
   */
  dataVersion?: number;
  /**
   * @example
   * 100***012
   */
  downloadTaskId?: number;
  /**
   * @example
   * not_exist
   */
  downloadTaskStatus?: string;
  /**
   * @example
   * 2023-04-13T03:38:10Z
   */
  endTime?: string;
  /**
   * @example
   * logical
   */
  method?: string;
  /**
   * @example
   * automated
   */
  policy?: string;
  /**
   * @example
   * 52
   */
  progress?: string;
  /**
   * @example
   * imm-test-set-cb****ee-b7d7-11ed-956f-****3e10bd70
   */
  setId?: number;
  /**
   * @example
   * 2020-05-22T17:04:18
   */
  startTime?: string;
  /**
   * @example
   * RUNNING
   */
  status?: string;
  /**
   * @example
   * standard
   */
  storageClass?: string;
  /**
   * @example
   * manual
   */
  type?: string;
  /**
   * @example
   * VALID
   */
  validity?: string;
  static names(): { [key: string]: string } {
    return {
      backupObjectType: 'BackupObjectType',
      backupObjects: 'BackupObjects',
      backupResults: 'BackupResults',
      checkpoint: 'Checkpoint',
      dataSize: 'DataSize',
      dataVersion: 'DataVersion',
      downloadTaskId: 'DownloadTaskId',
      downloadTaskStatus: 'DownloadTaskStatus',
      endTime: 'EndTime',
      method: 'Method',
      policy: 'Policy',
      progress: 'Progress',
      setId: 'SetId',
      startTime: 'StartTime',
      status: 'Status',
      storageClass: 'StorageClass',
      type: 'Type',
      validity: 'Validity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      backupObjectType: 'string',
      backupObjects: { 'type': 'array', 'itemType': DescribeDataBackupSetResponseBodyDataBackupObjects },
      backupResults: { 'type': 'array', 'itemType': DescribeDataBackupSetResponseBodyDataBackupResults },
      checkpoint: 'string',
      dataSize: 'number',
      dataVersion: 'number',
      downloadTaskId: 'number',
      downloadTaskStatus: 'string',
      endTime: 'string',
      method: 'string',
      policy: 'string',
      progress: 'string',
      setId: 'number',
      startTime: 'string',
      status: 'string',
      storageClass: 'string',
      type: 'string',
      validity: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.backupObjects)) {
      $dara.Model.validateArray(this.backupObjects);
    }
    if(Array.isArray(this.backupResults)) {
      $dara.Model.validateArray(this.backupResults);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDatabasesResponseBodyDatabasesTables extends $dara.Model {
  /**
   * @remarks
   * The name of the database table.
   * 
   * @example
   * testTables
   */
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tableName: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDatabasesResponseBodyDatabasesUsers extends $dara.Model {
  /**
   * @remarks
   * If you have granted custom privileges on the database, this parameter indicates the custom privileges, separated by commas (,). Otherwise, no data is returned for this parameter.
   * 
   * @example
   * select,delete,update
   */
  privileges?: string;
  /**
   * @remarks
   * The role of the account.    
   * In MySQL mode, a role is a database-level role. Valid values:  
   * - ReadWrite: a role that has the read and write privileges, namely ALL PRIVILEGES.  
   * - ReadOnly: a role that has only the read-only privilege SELECT.   
   * - DDL: a role that has the DDL privileges such as CREATE, DROP, ALTER, SHOW VIEW, and CREATE VIEW.   
   * - DML: a role that has the DML privileges such as SELECT, INSERT, UPDATE, DELETE, and SHOW VIEW.
   * 
   * @example
   * ReadOnly
   */
  role?: string;
  /**
   * @remarks
   * The name of the account.
   * 
   * @example
   * user_pay_ro
   */
  userName?: string;
  /**
   * @remarks
   * The type of the account. Valid values:  
   * - Admin: the super administrator account. 
   * - Normal: a general account.
   * 
   * @example
   * Normal
   */
  userType?: string;
  static names(): { [key: string]: string } {
    return {
      privileges: 'Privileges',
      role: 'Role',
      userName: 'UserName',
      userType: 'UserType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      privileges: 'string',
      role: 'string',
      userName: 'string',
      userType: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDatabasesResponseBodyDatabases extends $dara.Model {
  /**
   * @remarks
   * The collation.
   * 
   * @example
   * utf8mb4_general_ci
   */
  collation?: string;
  /**
   * @remarks
   * The time when the database was created.
   * 
   * @example
   * 2022-02-21 15:41:06
   */
  createTime?: string;
  /**
   * @remarks
   * The actual data size, in GB. 
   * >Notice: This parameter is no longer used in later versions. RequiredSize is used instead.
   * 
   * @example
   * 5.67 GB
   */
  dataSize?: number;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * sms_pre
   */
  databaseName?: string;
  /**
   * @remarks
   * The database type.
   * 
   * @example
   * mysql
   */
  dbType?: string;
  /**
   * @remarks
   * The description of the database.
   * 
   * @example
   * test db
   */
  description?: string;
  /**
   * @remarks
   * The encoding standard of the database. Encoding standards such as utf8mb4 and GBK are supported.
   * 
   * @example
   * utf8mb4
   */
  encoding?: string;
  /**
   * @remarks
   * The ID of the cluster to which the tenant belongs.
   * 
   * @example
   * obsdh2f****
   */
  instanceId?: string;
  /**
   * @remarks
   * The storage space required, in GB.
   * 
   * @example
   * 5.67 GB
   */
  requiredSize?: number;
  /**
   * @remarks
   * The status of the database. Valid values:    
   * - ONLINE: The database is running.  
   * - DELETING: The database is being deleted.
   * 
   * @example
   * ONLINE
   */
  status?: string;
  /**
   * @remarks
   * The list of database tables.
   */
  tables?: DescribeDatabasesResponseBodyDatabasesTables[];
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * @example
   * t33h8y08k****
   */
  tenantId?: string;
  /**
   * @remarks
   * The name of the tenant.
   * 
   * @example
   * tenantABC
   */
  tenantName?: string;
  /**
   * @remarks
   * The list of accounts that are granted privileges on this database.
   */
  users?: DescribeDatabasesResponseBodyDatabasesUsers[];
  static names(): { [key: string]: string } {
    return {
      collation: 'Collation',
      createTime: 'CreateTime',
      dataSize: 'DataSize',
      databaseName: 'DatabaseName',
      dbType: 'DbType',
      description: 'Description',
      encoding: 'Encoding',
      instanceId: 'InstanceId',
      requiredSize: 'RequiredSize',
      status: 'Status',
      tables: 'Tables',
      tenantId: 'TenantId',
      tenantName: 'TenantName',
      users: 'Users',
    };
  }

  static types(): { [key: string]: any } {
    return {
      collation: 'string',
      createTime: 'string',
      dataSize: 'number',
      databaseName: 'string',
      dbType: 'string',
      description: 'string',
      encoding: 'string',
      instanceId: 'string',
      requiredSize: 'number',
      status: 'string',
      tables: { 'type': 'array', 'itemType': DescribeDatabasesResponseBodyDatabasesTables },
      tenantId: 'string',
      tenantName: 'string',
      users: { 'type': 'array', 'itemType': DescribeDatabasesResponseBodyDatabasesUsers },
    };
  }

  validate() {
    if(Array.isArray(this.tables)) {
      $dara.Model.validateArray(this.tables);
    }
    if(Array.isArray(this.users)) {
      $dara.Model.validateArray(this.users);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceResponseBodyInstanceDataDiskAutoScaleConfig extends $dara.Model {
  /**
   * @remarks
   * Specifies whether to enable the automatic scaling of the data disk.
   * 
   * @example
   * true
   */
  autoScale?: boolean;
  /**
   * @remarks
   * The maximum size of the disk, in GB.
   * 
   * @example
   * 80000
   */
  maxDiskSize?: number;
  /**
   * @remarks
   * The size of scaling step during a major compaction.
   * 
   * @example
   * 100
   */
  scaleStepInMerge?: number;
  /**
   * @remarks
   * The size of scaling step during daily use.
   * 
   * @example
   * 50
   */
  scaleStepInNormal?: number;
  /**
   * @remarks
   * The maximum usage of the data disk, in percentage, that triggers the scaling of the data disk for major compactions.
   * 
   * @example
   * 90
   */
  upperMergeThreshold?: number;
  /**
   * @remarks
   * The step size of the scale-out.
   * 
   * @example
   * 5
   */
  upperScaleStep?: string;
  /**
   * @remarks
   * The scale-out strategy. Valid values: RAW and PERCENTAGE.
   * 
   * @example
   * RAW
   */
  upperScaleStrategy?: string;
  /**
   * @remarks
   * The maximum usage of the data disk, in percentage, that triggers the scaling of the data disk for daily use.
   * 
   * @example
   * 80
   */
  upperThreshold?: number;
  /**
   * @remarks
   * The maximum space, in GB, to which the data disk can be scaled.
   * 
   * @example
   * 16
   */
  upperbound?: number;
  static names(): { [key: string]: string } {
    return {
      autoScale: 'AutoScale',
      maxDiskSize: 'MaxDiskSize',
      scaleStepInMerge: 'ScaleStepInMerge',
      scaleStepInNormal: 'ScaleStepInNormal',
      upperMergeThreshold: 'UpperMergeThreshold',
      upperScaleStep: 'UpperScaleStep',
      upperScaleStrategy: 'UpperScaleStrategy',
      upperThreshold: 'UpperThreshold',
      upperbound: 'Upperbound',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoScale: 'boolean',
      maxDiskSize: 'number',
      scaleStepInMerge: 'number',
      scaleStepInNormal: 'number',
      upperMergeThreshold: 'number',
      upperScaleStep: 'string',
      upperScaleStrategy: 'string',
      upperThreshold: 'number',
      upperbound: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceResponseBodyInstanceReadOnlyResourceCapacityUnit extends $dara.Model {
  /**
   * @remarks
   * The maximum number of capacity units.
   * 
   * @example
   * 4
   */
  maxCapacityUnit?: number;
  /**
   * @remarks
   * The minimum number of capacity units.
   * 
   * @example
   * 1
   */
  minCapacityUnit?: number;
  /**
   * @remarks
   * The number of used capacity units.
   * 
   * @example
   * 2
   */
  usedCapacityUnit?: string;
  static names(): { [key: string]: string } {
    return {
      maxCapacityUnit: 'MaxCapacityUnit',
      minCapacityUnit: 'MinCapacityUnit',
      usedCapacityUnit: 'UsedCapacityUnit',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxCapacityUnit: 'number',
      minCapacityUnit: 'number',
      usedCapacityUnit: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceResponseBodyInstanceReadOnlyResourceCpu extends $dara.Model {
  /**
   * @remarks
   * The number of original CPU cores in the cluster.
   * 
   * @example
   * 14
   */
  originalTotalCpu?: number;
  /**
   * @remarks
   * The total number of CPU cores of the cluster.
   * 
   * @example
   * 14
   */
  totalCpu?: number;
  /**
   * @remarks
   * The number of CPU cores of each replica node in the cluster.
   * 
   * @example
   * 10
   */
  unitCpu?: number;
  /**
   * @remarks
   * The number of CPU cores used by the cluster.
   * 
   * @example
   * 10
   */
  usedCpu?: number;
  static names(): { [key: string]: string } {
    return {
      originalTotalCpu: 'OriginalTotalCpu',
      totalCpu: 'TotalCpu',
      unitCpu: 'UnitCpu',
      usedCpu: 'UsedCpu',
    };
  }

  static types(): { [key: string]: any } {
    return {
      originalTotalCpu: 'number',
      totalCpu: 'number',
      unitCpu: 'number',
      usedCpu: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceResponseBodyInstanceReadOnlyResourceDiskSize extends $dara.Model {
  /**
   * @remarks
   * The size of the data disk, in GB.
   * 
   * @example
   * 200
   */
  dataUsedSize?: number;
  /**
   * @remarks
   * The maximum disk size that can be created.
   * 
   * @example
   * 80000
   */
  maxDiskSize?: number;
  /**
   * @remarks
   * The maximum disk usage of the OBServer node.
   */
  maxDiskUsedObServer?: string[];
  /**
   * @remarks
   * The maximum disk usage, in percentage.
   * 
   * @example
   * 0.14
   */
  maxDiskUsedPercent?: number;
  /**
   * @remarks
   * The original size of the disk.
   * 
   * @example
   * 200
   */
  originalTotalDiskSize?: number;
  /**
   * @remarks
   * The total storage space of the cluster, in GB.
   * 
   * @example
   * 200
   */
  totalDiskSize?: number;
  /**
   * @remarks
   * The storage space of each replica node in the cluster, in GB.
   * 
   * @example
   * 200
   */
  unitDiskSize?: number;
  /**
   * @remarks
   * The size of used storage space of the cluster, in GB.
   * 
   * @example
   * 100
   */
  usedDiskSize?: number;
  static names(): { [key: string]: string } {
    return {
      dataUsedSize: 'DataUsedSize',
      maxDiskSize: 'MaxDiskSize',
      maxDiskUsedObServer: 'MaxDiskUsedObServer',
      maxDiskUsedPercent: 'MaxDiskUsedPercent',
      originalTotalDiskSize: 'OriginalTotalDiskSize',
      totalDiskSize: 'TotalDiskSize',
      unitDiskSize: 'UnitDiskSize',
      usedDiskSize: 'UsedDiskSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataUsedSize: 'number',
      maxDiskSize: 'number',
      maxDiskUsedObServer: { 'type': 'array', 'itemType': 'string' },
      maxDiskUsedPercent: 'number',
      originalTotalDiskSize: 'number',
      totalDiskSize: 'number',
      unitDiskSize: 'number',
      usedDiskSize: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.maxDiskUsedObServer)) {
      $dara.Model.validateArray(this.maxDiskUsedObServer);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceResponseBodyInstanceReadOnlyResourceLogDiskSize extends $dara.Model {
  /**
   * @remarks
   * The allocated disk space for log storage, in GB.
   * 
   * @example
   * 0.0
   */
  logAssignedSize?: string;
  /**
   * @remarks
   * The maximum storage space allocated for.
   */
  maxLogAssignedObServer?: string[];
  /**
   * @remarks
   * The maximum percentage of space allocated for log storage.
   * 
   * @example
   * 6.68
   */
  maxLogAssignedPercent?: string;
  /**
   * @remarks
   * The information about the log disk space of the cluster.
   * 
   * @example
   * 400
   */
  totalDiskSize?: number;
  /**
   * @remarks
   * The log disk space of each replica node in the cluster, in GB.
   * 
   * @example
   * 200
   */
  unitDiskSize?: number;
  static names(): { [key: string]: string } {
    return {
      logAssignedSize: 'LogAssignedSize',
      maxLogAssignedObServer: 'MaxLogAssignedObServer',
      maxLogAssignedPercent: 'MaxLogAssignedPercent',
      totalDiskSize: 'TotalDiskSize',
      unitDiskSize: 'UnitDiskSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logAssignedSize: 'string',
      maxLogAssignedObServer: { 'type': 'array', 'itemType': 'string' },
      maxLogAssignedPercent: 'string',
      totalDiskSize: 'number',
      unitDiskSize: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.maxLogAssignedObServer)) {
      $dara.Model.validateArray(this.maxLogAssignedObServer);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceResponseBodyInstanceReadOnlyResourceMemory extends $dara.Model {
  /**
   * @remarks
   * The original memory size of the cluster.
   * 
   * @example
   * 72
   */
  originalTotalMemory?: number;
  /**
   * @remarks
   * The total memory size of the cluster, in GB.
   * 
   * @example
   * 70
   */
  totalMemory?: number;
  /**
   * @remarks
   * The memory size of each replica node in the cluster, in GB.
   * 
   * @example
   * 10
   */
  unitMemory?: number;
  /**
   * @remarks
   * The size of memory used by the cluster, in GB.
   * 
   * @example
   * 10
   */
  usedMemory?: number;
  static names(): { [key: string]: string } {
    return {
      originalTotalMemory: 'OriginalTotalMemory',
      totalMemory: 'TotalMemory',
      unitMemory: 'UnitMemory',
      usedMemory: 'UsedMemory',
    };
  }

  static types(): { [key: string]: any } {
    return {
      originalTotalMemory: 'number',
      totalMemory: 'number',
      unitMemory: 'number',
      usedMemory: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceResponseBodyInstanceReadOnlyResource extends $dara.Model {
  /**
   * @remarks
   * The information about capacity units.
   */
  capacityUnit?: DescribeInstanceResponseBodyInstanceReadOnlyResourceCapacityUnit;
  /**
   * @remarks
   * The information about the CPU resources of the cluster.
   */
  cpu?: DescribeInstanceResponseBodyInstanceReadOnlyResourceCpu;
  /**
   * @remarks
   * The information about the storage resources of the cluster.
   */
  diskSize?: DescribeInstanceResponseBodyInstanceReadOnlyResourceDiskSize;
  /**
   * @remarks
   * The information about the log disk space of the cluster.
   */
  logDiskSize?: DescribeInstanceResponseBodyInstanceReadOnlyResourceLogDiskSize;
  /**
   * @remarks
   * The information about the memory resources of the cluster.
   */
  memory?: DescribeInstanceResponseBodyInstanceReadOnlyResourceMemory;
  /**
   * @remarks
   * The number of resource units in the cluster.
   * 
   * @example
   * 1
   */
  unitCount?: number;
  static names(): { [key: string]: string } {
    return {
      capacityUnit: 'CapacityUnit',
      cpu: 'Cpu',
      diskSize: 'DiskSize',
      logDiskSize: 'LogDiskSize',
      memory: 'Memory',
      unitCount: 'UnitCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      capacityUnit: DescribeInstanceResponseBodyInstanceReadOnlyResourceCapacityUnit,
      cpu: DescribeInstanceResponseBodyInstanceReadOnlyResourceCpu,
      diskSize: DescribeInstanceResponseBodyInstanceReadOnlyResourceDiskSize,
      logDiskSize: DescribeInstanceResponseBodyInstanceReadOnlyResourceLogDiskSize,
      memory: DescribeInstanceResponseBodyInstanceReadOnlyResourceMemory,
      unitCount: 'number',
    };
  }

  validate() {
    if(this.capacityUnit && typeof (this.capacityUnit as any).validate === 'function') {
      (this.capacityUnit as any).validate();
    }
    if(this.cpu && typeof (this.cpu as any).validate === 'function') {
      (this.cpu as any).validate();
    }
    if(this.diskSize && typeof (this.diskSize as any).validate === 'function') {
      (this.diskSize as any).validate();
    }
    if(this.logDiskSize && typeof (this.logDiskSize as any).validate === 'function') {
      (this.logDiskSize as any).validate();
    }
    if(this.memory && typeof (this.memory as any).validate === 'function') {
      (this.memory as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceResponseBodyInstanceResourceCapacityUnit extends $dara.Model {
  /**
   * @remarks
   * The maximum number of capacity units.
   * 
   * @example
   * 4
   */
  maxCapacityUnit?: number;
  /**
   * @remarks
   * The minimum number of capacity units.
   * 
   * @example
   * 1
   */
  minCapacityUnit?: number;
  /**
   * @remarks
   * The number of used capacity units.
   * 
   * @example
   * 2
   */
  usedCapacityUnit?: string;
  static names(): { [key: string]: string } {
    return {
      maxCapacityUnit: 'MaxCapacityUnit',
      minCapacityUnit: 'MinCapacityUnit',
      usedCapacityUnit: 'UsedCapacityUnit',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxCapacityUnit: 'number',
      minCapacityUnit: 'number',
      usedCapacityUnit: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceResponseBodyInstanceResourceCpu extends $dara.Model {
  /**
   * @remarks
   * The number of original CPU cores in the cluster.
   * 
   * @example
   * 14
   */
  originalTotalCpu?: number;
  /**
   * @remarks
   * The total number of CPU cores of the cluster.
   * 
   * @example
   * 14
   */
  totalCpu?: number;
  /**
   * @remarks
   * The number of CPU cores of each replica node in the cluster.
   * 
   * @example
   * 10
   */
  unitCpu?: number;
  /**
   * @remarks
   * The number of CPU cores used in the cluster.
   * 
   * @example
   * 10
   */
  usedCpu?: number;
  static names(): { [key: string]: string } {
    return {
      originalTotalCpu: 'OriginalTotalCpu',
      totalCpu: 'TotalCpu',
      unitCpu: 'UnitCpu',
      usedCpu: 'UsedCpu',
    };
  }

  static types(): { [key: string]: any } {
    return {
      originalTotalCpu: 'number',
      totalCpu: 'number',
      unitCpu: 'number',
      usedCpu: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceResponseBodyInstanceResourceDiskSize extends $dara.Model {
  /**
   * @remarks
   * The size of the data disk, in GB.
   * 
   * @example
   * 200
   */
  dataUsedSize?: number;
  /**
   * @remarks
   * The maximum disk size that can be created.
   * 
   * @example
   * 80000
   */
  maxDiskSize?: number;
  /**
   * @remarks
   * The maximum disk usage of the OBServer node.
   */
  maxDiskUsedObServer?: string[];
  /**
   * @remarks
   * The maximum disk usage, in percentage.
   * 
   * @example
   * 0.14
   */
  maxDiskUsedPercent?: number;
  /**
   * @remarks
   * The original size of the disk.
   * 
   * @example
   * 200
   */
  originalTotalDiskSize?: number;
  /**
   * @remarks
   * The total storage space of the cluster, in GB.
   * 
   * @example
   * 200
   */
  totalDiskSize?: number;
  /**
   * @remarks
   * The storage space of each replica node in the cluster, in GB.
   * 
   * @example
   * 200
   */
  unitDiskSize?: number;
  /**
   * @remarks
   * The size of used storage space of the cluster, in GB.
   * 
   * @example
   * 100
   */
  usedDiskSize?: number;
  static names(): { [key: string]: string } {
    return {
      dataUsedSize: 'DataUsedSize',
      maxDiskSize: 'MaxDiskSize',
      maxDiskUsedObServer: 'MaxDiskUsedObServer',
      maxDiskUsedPercent: 'MaxDiskUsedPercent',
      originalTotalDiskSize: 'OriginalTotalDiskSize',
      totalDiskSize: 'TotalDiskSize',
      unitDiskSize: 'UnitDiskSize',
      usedDiskSize: 'UsedDiskSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataUsedSize: 'number',
      maxDiskSize: 'number',
      maxDiskUsedObServer: { 'type': 'array', 'itemType': 'string' },
      maxDiskUsedPercent: 'number',
      originalTotalDiskSize: 'number',
      totalDiskSize: 'number',
      unitDiskSize: 'number',
      usedDiskSize: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.maxDiskUsedObServer)) {
      $dara.Model.validateArray(this.maxDiskUsedObServer);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceResponseBodyInstanceResourceLogDiskSize extends $dara.Model {
  /**
   * @remarks
   * The allocated disk space for log storage, in GB.
   * 
   * @example
   * 0.0
   */
  logAssignedSize?: string;
  /**
   * @remarks
   * The maximum storage space allocated for.
   */
  maxLogAssignedObServer?: string[];
  /**
   * @remarks
   * The maximum percentage of space allocated for log storage.
   * 
   * @example
   * 6.68
   */
  maxLogAssignedPercent?: string;
  /**
   * @remarks
   * The original size of the disk.
   * 
   * @example
   * 200
   */
  originalTotalDiskSize?: number;
  /**
   * @remarks
   * The total log disk space of the cluster, in GB.
   * 
   * @example
   * 400
   */
  totalDiskSize?: number;
  /**
   * @remarks
   * The log disk space of each replica node in the cluster. Unit: GB.
   * 
   * @example
   * 200
   */
  unitDiskSize?: number;
  static names(): { [key: string]: string } {
    return {
      logAssignedSize: 'LogAssignedSize',
      maxLogAssignedObServer: 'MaxLogAssignedObServer',
      maxLogAssignedPercent: 'MaxLogAssignedPercent',
      originalTotalDiskSize: 'OriginalTotalDiskSize',
      totalDiskSize: 'TotalDiskSize',
      unitDiskSize: 'UnitDiskSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logAssignedSize: 'string',
      maxLogAssignedObServer: { 'type': 'array', 'itemType': 'string' },
      maxLogAssignedPercent: 'string',
      originalTotalDiskSize: 'number',
      totalDiskSize: 'number',
      unitDiskSize: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.maxLogAssignedObServer)) {
      $dara.Model.validateArray(this.maxLogAssignedObServer);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceResponseBodyInstanceResourceMemory extends $dara.Model {
  /**
   * @remarks
   * The original memory size of the cluster, in GB.
   * 
   * @example
   * 72
   */
  originalTotalMemory?: number;
  /**
   * @remarks
   * The total memory size of the cluster, in GB.
   * 
   * @example
   * 70
   */
  totalMemory?: number;
  /**
   * @remarks
   * The memory size of each replica node in the cluster, in GB.
   * 
   * @example
   * 10
   */
  unitMemory?: number;
  /**
   * @remarks
   * The size of used memory in the cluster, in GB.
   * 
   * @example
   * 10
   */
  usedMemory?: number;
  static names(): { [key: string]: string } {
    return {
      originalTotalMemory: 'OriginalTotalMemory',
      totalMemory: 'TotalMemory',
      unitMemory: 'UnitMemory',
      usedMemory: 'UsedMemory',
    };
  }

  static types(): { [key: string]: any } {
    return {
      originalTotalMemory: 'number',
      totalMemory: 'number',
      unitMemory: 'number',
      usedMemory: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceResponseBodyInstanceResource extends $dara.Model {
  /**
   * @remarks
   * The information about capacity units.
   */
  capacityUnit?: DescribeInstanceResponseBodyInstanceResourceCapacityUnit;
  /**
   * @remarks
   * The information about the CPU resources of the cluster.
   */
  cpu?: DescribeInstanceResponseBodyInstanceResourceCpu;
  /**
   * @remarks
   * The information about the storage resources of the cluster.
   */
  diskSize?: DescribeInstanceResponseBodyInstanceResourceDiskSize;
  /**
   * @remarks
   * The information about the log disk space of the cluster.
   */
  logDiskSize?: DescribeInstanceResponseBodyInstanceResourceLogDiskSize;
  /**
   * @remarks
   * The information about the memory resources of the cluster.
   */
  memory?: DescribeInstanceResponseBodyInstanceResourceMemory;
  /**
   * @remarks
   * The number of resource units in the cluster.
   * 
   * @example
   * 1
   */
  unitCount?: number;
  static names(): { [key: string]: string } {
    return {
      capacityUnit: 'CapacityUnit',
      cpu: 'Cpu',
      diskSize: 'DiskSize',
      logDiskSize: 'LogDiskSize',
      memory: 'Memory',
      unitCount: 'UnitCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      capacityUnit: DescribeInstanceResponseBodyInstanceResourceCapacityUnit,
      cpu: DescribeInstanceResponseBodyInstanceResourceCpu,
      diskSize: DescribeInstanceResponseBodyInstanceResourceDiskSize,
      logDiskSize: DescribeInstanceResponseBodyInstanceResourceLogDiskSize,
      memory: DescribeInstanceResponseBodyInstanceResourceMemory,
      unitCount: 'number',
    };
  }

  validate() {
    if(this.capacityUnit && typeof (this.capacityUnit as any).validate === 'function') {
      (this.capacityUnit as any).validate();
    }
    if(this.cpu && typeof (this.cpu as any).validate === 'function') {
      (this.cpu as any).validate();
    }
    if(this.diskSize && typeof (this.diskSize as any).validate === 'function') {
      (this.diskSize as any).validate();
    }
    if(this.logDiskSize && typeof (this.logDiskSize as any).validate === 'function') {
      (this.logDiskSize as any).validate();
    }
    if(this.memory && typeof (this.memory as any).validate === 'function') {
      (this.memory as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceResponseBodyInstanceTenantCreatable extends $dara.Model {
  /**
   * @remarks
   * The reason why you cannot create a tenant in the cluster.
   * 
   * @example
   * CPU_NOT_ENOUGH,  MEMORY_NOT_ENOUGH, TENANT_COUNT_EXCEEDS_LIMIT
   */
  disableCreateTenantReason?: string;
  /**
   * @remarks
   * Specifies whether a tenant can be created.
   * 
   * @example
   * true
   */
  enableCreateTenant?: boolean;
  static names(): { [key: string]: string } {
    return {
      disableCreateTenantReason: 'DisableCreateTenantReason',
      enableCreateTenant: 'EnableCreateTenant',
    };
  }

  static types(): { [key: string]: any } {
    return {
      disableCreateTenantReason: 'string',
      enableCreateTenant: 'boolean',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceResponseBodyInstance extends $dara.Model {
  /**
   * @remarks
   * Indicates whether the OceanBase Database Proxy (ODP) SQL firewall is supported.
   * 
   * @example
   * false
   */
  allowCreateProxySqlFirewallRule?: boolean;
  /**
   * @remarks
   * Indicates whether the maximum number of public connections can be modified.
   * 
   * @example
   * false
   */
  allowModifyInternetAddressConnectionLimit?: boolean;
  /**
   * @remarks
   * Indicates whether automatic renewal is enabled. 
   * 
   * This parameter is valid only for clusters whose billing methods are set to PREPAY.
   * 
   * @example
   * true
   */
  autoRenewal?: boolean;
  /**
   * @remarks
   * Indicates whether automatic upgrade of the OBServer version is enabled.
   * 
   * @example
   * true
   */
  autoUpgradeObVersion?: boolean;
  /**
   * @remarks
   * The list of zones.
   */
  availableZones?: string[];
  /**
   * @remarks
   * The CPU architecture of the cluster.
   * 
   * @example
   * X86
   */
  cpuArchitecture?: string;
  /**
   * @remarks
   * The time in UTC when the cluster was created.
   * 
   * @example
   * 2021-10-19T07:13:41Z
   */
  createTime?: string;
  /**
   * @remarks
   * Specifies whether to enable automatic scaling of the data disk.
   * > <br>This parameter is deprecated.
   * 
   * @example
   * -
   */
  dataDiskAutoScale?: boolean;
  /**
   * @remarks
   * Specifies parameters for the automatic scaling of the data disk.
   */
  dataDiskAutoScaleConfig?: DescribeInstanceResponseBodyInstanceDataDiskAutoScaleConfig;
  /**
   * @remarks
   * The time when the major compaction of cluster data is performed.
   * 
   * @example
   * 02:00
   */
  dataMergeTime?: string;
  /**
   * @remarks
   * The data replica distribution mode of the cluster. Valid values: 
   * - n: indicates the single-IDC mode. 
   * - n-n: indicates the dual-IDC mode. 
   * - n-n-n: indicates the multi-IDC mode. 
   * 
   * > <br>The integer n represents the number of OBServer nodes in each IDC.
   * 
   * @example
   * 1-1-1
   */
  deployMode?: string;
  /**
   * @remarks
   * The deployment type of the cluster. Valid values:  
   * - multiple: multi-IDC deployment   
   * - single: single-IDC deployment   
   * - dual: dual-IDC deployment
   * 
   * @example
   * multiple
   */
  deployType?: string;
  /**
   * @remarks
   * The type of the storage disk where the cluster is deployed. 
   * 
   * The default value is cloud_essd_pl1, which indicates an ESSD cloud disk.
   * 
   * @example
   * cloud_essd_pl1
   */
  diskType?: string;
  /**
   * @remarks
   * Specifies whether to enable isolation optimization.
   * 
   * @example
   * false
   */
  enableIsolationOptimization?: boolean;
  /**
   * @remarks
   * Specifies whether to enable the proxy service.
   * - true
   * - false
   * 
   * @example
   * true
   */
  enableProxyService?: boolean;
  /**
   * @remarks
   * Indicates whether read-only replicas are supported.
   * 
   * @example
   * true
   */
  enableReadOnlyReplica?: boolean;
  /**
   * @remarks
   * Indicates whether read-only replicas can be purchased for the cluster.
   * 
   * @example
   * false
   */
  enableReadOnlyReplicaManagement?: boolean;
  /**
   * @remarks
   * Indicates whether the log disk specifications can be upgraded.
   * 
   * @example
   * false
   */
  enableUpgradeLogDisk?: boolean;
  /**
   * @remarks
   * The maximum number of units of the proxy service in exclusive mode.
   * 
   * @example
   * 1
   */
  exclusiveUnitNumLimit?: number;
  /**
   * @remarks
   * The time in UTC when the cluster expires.
   * 
   * @example
   * 2021-10-17T16:00:00Z
   */
  expireTime?: string;
  /**
   * @remarks
   * Specifies whether to indicate the temporary status of the capacity.
   * 
   * @example
   * false
   */
  inTempCapacityStatus?: boolean;
  /**
   * @remarks
   * The specifications of the cluster.  You can specify one of the following four plans:    
   * - 8C32G: indicates 8 CPU cores and 32 GB of memory. 
   * - 14C70G: indicates 14 CPU cores and 70 GB of memory. 
   * - 30C180G: indicates 30 CPU cores and 180 GB of memory. 
   * - 62C400G: indicates 62 CPU cores and 400 GB of memory.
   * 
   * @example
   * 14C70G
   */
  instanceClass?: string;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The name of the OceanBase cluster.
   * 
   * @example
   * ob4test
   */
  instanceName?: string;
  /**
   * @remarks
   * The role of the instance.
   * 
   * @example
   * NORMAL
   */
  instanceRole?: string;
  /**
   * @remarks
   * Indicates whether the OBServer version is the latest.
   * 
   * @example
   * true
   */
  isLatestObVersion?: boolean;
  /**
   * @remarks
   * Indicates whether trusted ECS instances are used.
   * 
   * @example
   * true
   */
  isTrustEcs?: boolean;
  /**
   * @remarks
   * Specifies whether to enable the control group feature.
   * 
   * @example
   * false
   */
  isolationOptimization?: boolean;
  /**
   * @remarks
   * The period in UTC for the daily routine maintenance of the cluster.
   * 
   * @example
   * 19:00Z-20:00Z
   */
  maintainTime?: string;
  /**
   * @remarks
   * The number of nodes in the cluster. If the cluster is deployed in n-n-n mode, the number of nodes in the cluster equals n × 3.
   * 
   * @example
   * 6
   */
  nodeNum?: string;
  /**
   * @remarks
   * The detailed information of the OBServer version.
   * 
   * @example
   * 2.2.77-20210526202046
   */
  obRpmVersion?: string;
  /**
   * @remarks
   * The billing method of the OceanBase cluster. Valid values: 
   * - PREPAY: the subscription billing method. 
   * - POSTPAY: the pay-as-you-go billing method.
   * 
   * @example
   * PREPAY
   */
  payType?: string;
  /**
   * @remarks
   * The ID of the primary cluster.
   * 
   * @example
   * ob3h8ytroxxxxx
   */
  primaryInstance?: string;
  /**
   * @remarks
   * The region of the primary cluster.
   * 
   * @example
   * cn-hangzhou
   */
  primaryRegion?: string;
  /**
   * @remarks
   * The ID of the proxy cluster.
   * > This parameter returns a value only if you set the **EnableProxyService** parameter to true.
   * 
   * @example
   * proxy-56****a6tg2o
   */
  proxyClusterId?: string;
  /**
   * @remarks
   * The status of the proxy service.
   * 
   * @example
   * ONLINE
   */
  proxyServiceStatus?: string;
  /**
   * @remarks
   * The information about cluster resources.
   */
  readOnlyResource?: DescribeInstanceResponseBodyInstanceReadOnlyResource;
  /**
   * @remarks
   * The number of full-featured replicas. Return value: 3 or 2.
   * - 3: three full-featured replicas.
   * - 2: two full-featured replicas.
   * 
   * An OceanBase cluster deployed in three-zone mode supports only three full-featured replicas. An OceanBase cluster deployed in two-zone mode supports only two full-featured replicas. An OceanBase cluster deployed in one single zone supports two or three full-featured replicas.
   * 
   * @example
   * 2F1A
   */
  replicaMode?: string;
  /**
   * @remarks
   * The information about cluster resources.
   */
  resource?: DescribeInstanceResponseBodyInstanceResource;
  /**
   * @remarks
   * The series of the instance. Valid values:
   * 
   * - normal: Standard Cluster Edition (Cloud Disk). This is the default value.
   * 
   * - normal_ssd: Standard Cluster Edition (Local Disk)
   * 
   * - history: History Database Cluster Edition
   * 
   * @example
   * Normal
   */
  series?: string;
  /**
   * @remarks
   * The maximum number of units of the proxy service in shared mode.
   * 
   * @example
   * 3
   */
  sharedUnitNumLimit?: number;
  /**
   * @remarks
   * The specification type.
   * 
   * @example
   * dedicatedspec
   */
  specType?: string;
  /**
   * @remarks
   * The status of the cluster. Valid values: 
   *  - PENDING_CREATE: The cluster is being created. 
   *  - ONLINE: The cluster is running. 
   *  - TENANT_CREATING: The tenant is being created. 
   * - TENANT_SPEC_MODIFYING: The tenant specifications are being modified. 
   * - EXPANDING: Nodes are being added to the cluster to increase its capacity. 
   * - REDUCING: Nodes are being removed from the cluster to reduce its capacity. 
   * - SPEC_UPGRADING: The service plan is being upgraded. 
   * - DISK_UPGRADING: The storage space is being expanded. 
   * - WHITE_LIST_MODIFYING: The whitelist is being modified. 
   * - PARAMETER_MODIFYING: Parameters are being modified. 
   * - SSL_MODIFYING: The SSL certificate is being changed. 
   * - PREPAID_EXPIRE_CLOSED: The payment is overdue. This parameter is valid for a cluster whose billing method is set to PREPAY. 
   * - ARREARS_CLOSED: The payment is overdue. This parameter is valid for a cluster whose billing method is set to POSTPAY. 
   * - PENDING_DELETE: The cluster is being deleted.    
   * Generally, the cluster is in the ONLINE state.
   * 
   * @example
   * ONLINE
   */
  status?: string;
  /**
   * @remarks
   * Specifies whether a tenant can be created.
   */
  tenantCreatable?: DescribeInstanceResponseBodyInstanceTenantCreatable;
  /**
   * @remarks
   * The unit specification of the proxy service.
   * 
   * @example
   * 2C4G
   */
  unitSpec?: string;
  /**
   * @remarks
   * The version of OceanBase Database.
   * 
   * @example
   * 2.2.77
   */
  version?: string;
  /**
   * @remarks
   * The ID of the zone to which the instance belongs.
   * <props="intl">For more information about how to obtain the list of zones, see [DescribeZones](https://www.alibabacloud.com/help/en/apsaradb-for-oceanbase/latest/api-oceanbasepro-2019-09-01-describezones).
   */
  zones?: string[];
  static names(): { [key: string]: string } {
    return {
      allowCreateProxySqlFirewallRule: 'AllowCreateProxySqlFirewallRule',
      allowModifyInternetAddressConnectionLimit: 'AllowModifyInternetAddressConnectionLimit',
      autoRenewal: 'AutoRenewal',
      autoUpgradeObVersion: 'AutoUpgradeObVersion',
      availableZones: 'AvailableZones',
      cpuArchitecture: 'CpuArchitecture',
      createTime: 'CreateTime',
      dataDiskAutoScale: 'DataDiskAutoScale',
      dataDiskAutoScaleConfig: 'DataDiskAutoScaleConfig',
      dataMergeTime: 'DataMergeTime',
      deployMode: 'DeployMode',
      deployType: 'DeployType',
      diskType: 'DiskType',
      enableIsolationOptimization: 'EnableIsolationOptimization',
      enableProxyService: 'EnableProxyService',
      enableReadOnlyReplica: 'EnableReadOnlyReplica',
      enableReadOnlyReplicaManagement: 'EnableReadOnlyReplicaManagement',
      enableUpgradeLogDisk: 'EnableUpgradeLogDisk',
      exclusiveUnitNumLimit: 'ExclusiveUnitNumLimit',
      expireTime: 'ExpireTime',
      inTempCapacityStatus: 'InTempCapacityStatus',
      instanceClass: 'InstanceClass',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      instanceRole: 'InstanceRole',
      isLatestObVersion: 'IsLatestObVersion',
      isTrustEcs: 'IsTrustEcs',
      isolationOptimization: 'IsolationOptimization',
      maintainTime: 'MaintainTime',
      nodeNum: 'NodeNum',
      obRpmVersion: 'ObRpmVersion',
      payType: 'PayType',
      primaryInstance: 'PrimaryInstance',
      primaryRegion: 'PrimaryRegion',
      proxyClusterId: 'ProxyClusterId',
      proxyServiceStatus: 'ProxyServiceStatus',
      readOnlyResource: 'ReadOnlyResource',
      replicaMode: 'ReplicaMode',
      resource: 'Resource',
      series: 'Series',
      sharedUnitNumLimit: 'SharedUnitNumLimit',
      specType: 'SpecType',
      status: 'Status',
      tenantCreatable: 'TenantCreatable',
      unitSpec: 'UnitSpec',
      version: 'Version',
      zones: 'Zones',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allowCreateProxySqlFirewallRule: 'boolean',
      allowModifyInternetAddressConnectionLimit: 'boolean',
      autoRenewal: 'boolean',
      autoUpgradeObVersion: 'boolean',
      availableZones: { 'type': 'array', 'itemType': 'string' },
      cpuArchitecture: 'string',
      createTime: 'string',
      dataDiskAutoScale: 'boolean',
      dataDiskAutoScaleConfig: DescribeInstanceResponseBodyInstanceDataDiskAutoScaleConfig,
      dataMergeTime: 'string',
      deployMode: 'string',
      deployType: 'string',
      diskType: 'string',
      enableIsolationOptimization: 'boolean',
      enableProxyService: 'boolean',
      enableReadOnlyReplica: 'boolean',
      enableReadOnlyReplicaManagement: 'boolean',
      enableUpgradeLogDisk: 'boolean',
      exclusiveUnitNumLimit: 'number',
      expireTime: 'string',
      inTempCapacityStatus: 'boolean',
      instanceClass: 'string',
      instanceId: 'string',
      instanceName: 'string',
      instanceRole: 'string',
      isLatestObVersion: 'boolean',
      isTrustEcs: 'boolean',
      isolationOptimization: 'boolean',
      maintainTime: 'string',
      nodeNum: 'string',
      obRpmVersion: 'string',
      payType: 'string',
      primaryInstance: 'string',
      primaryRegion: 'string',
      proxyClusterId: 'string',
      proxyServiceStatus: 'string',
      readOnlyResource: DescribeInstanceResponseBodyInstanceReadOnlyResource,
      replicaMode: 'string',
      resource: DescribeInstanceResponseBodyInstanceResource,
      series: 'string',
      sharedUnitNumLimit: 'number',
      specType: 'string',
      status: 'string',
      tenantCreatable: DescribeInstanceResponseBodyInstanceTenantCreatable,
      unitSpec: 'string',
      version: 'string',
      zones: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(Array.isArray(this.availableZones)) {
      $dara.Model.validateArray(this.availableZones);
    }
    if(this.dataDiskAutoScaleConfig && typeof (this.dataDiskAutoScaleConfig as any).validate === 'function') {
      (this.dataDiskAutoScaleConfig as any).validate();
    }
    if(this.readOnlyResource && typeof (this.readOnlyResource as any).validate === 'function') {
      (this.readOnlyResource as any).validate();
    }
    if(this.resource && typeof (this.resource as any).validate === 'function') {
      (this.resource as any).validate();
    }
    if(this.tenantCreatable && typeof (this.tenantCreatable as any).validate === 'function') {
      (this.tenantCreatable as any).validate();
    }
    if(Array.isArray(this.zones)) {
      $dara.Model.validateArray(this.zones);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceCreatableZoneResponseBodyZoneList extends $dara.Model {
  fullCopyId?: string;
  /**
   * @example
   * true
   */
  isInCluster?: boolean;
  logicalZoneName?: string;
  replicateZoneIndex?: number;
  /**
   * @remarks
   * DescribeInstanceCreatableZone
   * 
   * @example
   * cn-hangzhou-i
   */
  zone?: string;
  static names(): { [key: string]: string } {
    return {
      fullCopyId: 'FullCopyId',
      isInCluster: 'IsInCluster',
      logicalZoneName: 'LogicalZoneName',
      replicateZoneIndex: 'ReplicateZoneIndex',
      zone: 'Zone',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fullCopyId: 'string',
      isInCluster: 'boolean',
      logicalZoneName: 'string',
      replicateZoneIndex: 'number',
      zone: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceSSLResponseBodyInstanceSSL extends $dara.Model {
  /**
   * @remarks
   * The status of automatic update of SSL certificates. Valid values: 
   * * CLOSE: The automatic update of SSL certificates is disabled. 
   * * OPEN: The automatic update of SSL certificates is enabled.
   * 
   * @example
   * OPEN
   */
  autoUpdate?: string;
  /**
   * @remarks
   * The URL of the certificate authority (CA) node.
   * 
   * @example
   * https://xxxx
   */
  caUrl?: string;
  /**
   * @remarks
   * The operation to modify the SSL status. Valid values:
   * 
   * - open: Enable SSL encryption.
   * 
   * - update: Update the CA certificate.
   * 
   * - close: Disable SSL encryption.
   * 
   * @example
   * OPEN
   */
  enableSSL?: string;
  /**
   * @remarks
   * The forced enabling status of SSL.
   * 
   * @example
   * CLOSE
   */
  forceSSL?: string;
  /**
   * @remarks
   * Indicates whether SSL can be forcibly enabled.
   * 
   * @example
   * false
   */
  forceSSLSupport?: boolean;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The SSL status of the cluster.
   * 
   * @example
   * RUNNING
   */
  status?: string;
  tenantId?: string;
  /**
   * @remarks
   * The validity period of the SSL certificate.
   * 
   * @example
   * 2024-09-20 07:55:03.0
   */
  validPeriod?: string;
  static names(): { [key: string]: string } {
    return {
      autoUpdate: 'AutoUpdate',
      caUrl: 'CaUrl',
      enableSSL: 'EnableSSL',
      forceSSL: 'ForceSSL',
      forceSSLSupport: 'ForceSSLSupport',
      instanceId: 'InstanceId',
      status: 'Status',
      tenantId: 'TenantId',
      validPeriod: 'ValidPeriod',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoUpdate: 'string',
      caUrl: 'string',
      enableSSL: 'string',
      forceSSL: 'string',
      forceSSLSupport: 'boolean',
      instanceId: 'string',
      status: 'string',
      tenantId: 'string',
      validPeriod: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceSecurityConfigsResponseBodyInstanceSecurityConfigsSecurityConfigs extends $dara.Model {
  /**
   * @remarks
   * The name of the check item.
   * 
   * @example
   * Check whether the scope of the cluster allowlist is too big
   */
  configDescription?: string;
  /**
   * @remarks
   * The group of the check.
   * 
   * @example
   * WHITELIST
   */
  configGroup?: string;
  /**
   * @remarks
   * The name of the specific check item.
   * 
   * @example
   * xxx
   */
  configName?: string;
  /**
   * @remarks
   * Specifies whether a risk is detected.
   * 
   * @example
   * true
   */
  risk?: boolean;
  /**
   * @remarks
   * Security recommendations.
   * 
   * @example
   * xxx
   */
  riskDescription?: string;
  static names(): { [key: string]: string } {
    return {
      configDescription: 'ConfigDescription',
      configGroup: 'ConfigGroup',
      configName: 'ConfigName',
      risk: 'Risk',
      riskDescription: 'RiskDescription',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configDescription: 'string',
      configGroup: 'string',
      configName: 'string',
      risk: 'boolean',
      riskDescription: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceSecurityConfigsResponseBodyInstanceSecurityConfigs extends $dara.Model {
  /**
   * @remarks
   * The unique identifier of the check.
   * 
   * @example
   * xxx
   */
  checkId?: string;
  /**
   * @remarks
   * The time when the check was performed.
   * 
   * @example
   * 2023-08-07 15:30:00
   */
  checkTime?: string;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The list of check items.
   */
  securityConfigs?: DescribeInstanceSecurityConfigsResponseBodyInstanceSecurityConfigsSecurityConfigs[];
  /**
   * @remarks
   * The total number of security check items for the cluster.
   * 
   * @example
   * 5
   */
  totalCheckCount?: number;
  /**
   * @remarks
   * The total number of detected cluster security risks.
   * 
   * @example
   * 0
   */
  totalRiskCount?: number;
  static names(): { [key: string]: string } {
    return {
      checkId: 'CheckId',
      checkTime: 'CheckTime',
      instanceId: 'InstanceId',
      securityConfigs: 'SecurityConfigs',
      totalCheckCount: 'TotalCheckCount',
      totalRiskCount: 'TotalRiskCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkId: 'string',
      checkTime: 'string',
      instanceId: 'string',
      securityConfigs: { 'type': 'array', 'itemType': DescribeInstanceSecurityConfigsResponseBodyInstanceSecurityConfigsSecurityConfigs },
      totalCheckCount: 'number',
      totalRiskCount: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.securityConfigs)) {
      $dara.Model.validateArray(this.securityConfigs);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceSummaryResponseBodyInstanceSummaryRegionalInstanceSummaryList extends $dara.Model {
  /**
   * @remarks
   * The number of expired instances.
   * 
   * @example
   * 1
   */
  expiredInstancesCount?: number;
  /**
   * @remarks
   * The number of instances about to expire.
   * 
   * @example
   * 1
   */
  immediatelyExpiredInstancesCount?: number;
  /**
   * @remarks
   * The number of recently created instances.
   * 
   * @example
   * 1
   */
  recentCreatedInstancesCount?: number;
  /**
   * @remarks
   * The ID of the region.
   * 
   * @example
   * cn-shanghai
   */
  region?: string;
  /**
   * @remarks
   * The total number of running instances.
   * 
   * @example
   * 1
   */
  runningInstancesCount?: number;
  /**
   * @remarks
   * The total number of instances.
   * 
   * @example
   * 3
   */
  totalInstancesCount?: number;
  static names(): { [key: string]: string } {
    return {
      expiredInstancesCount: 'ExpiredInstancesCount',
      immediatelyExpiredInstancesCount: 'ImmediatelyExpiredInstancesCount',
      recentCreatedInstancesCount: 'RecentCreatedInstancesCount',
      region: 'Region',
      runningInstancesCount: 'RunningInstancesCount',
      totalInstancesCount: 'TotalInstancesCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      expiredInstancesCount: 'number',
      immediatelyExpiredInstancesCount: 'number',
      recentCreatedInstancesCount: 'number',
      region: 'string',
      runningInstancesCount: 'number',
      totalInstancesCount: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceSummaryResponseBodyInstanceSummary extends $dara.Model {
  /**
   * @remarks
   * The total number of alerts during the query period.
   * 
   * @example
   * 1
   */
  alarmSummaryCount?: number;
  /**
   * @remarks
   * The total number of abnormal SQL statements.
   * 
   * @example
   * 1
   */
  anomalySQLCount?: number;
  /**
   * @remarks
   * The number of cluster instances.
   * 
   * @example
   * 1
   */
  clusterInstancesCount?: number;
  /**
   * @remarks
   * The number of expired instances.
   * 
   * @example
   * 1
   */
  expiredInstancesCount?: number;
  /**
   * @remarks
   * The total number of expired instances to be released.
   * 
   * @example
   * 1
   */
  immediatelyExpiredInstancesCount?: number;
  /**
   * @remarks
   * The total number of clusters with capacity risks.
   * 
   * @example
   * 2
   */
  insufficientDiskInstancesCount?: number;
  /**
   * @remarks
   * The number of overloaded instances.
   * 
   * @example
   * 1
   */
  overLoadInstancesCount?: number;
  /**
   * @remarks
   * A list of regional instances.
   */
  regionalInstanceSummaryList?: DescribeInstanceSummaryResponseBodyInstanceSummaryRegionalInstanceSummaryList[];
  /**
   * @remarks
   * The number of running instances.
   * 
   * @example
   * 1
   */
  runningInstancesCount?: number;
  /**
   * @remarks
   * The number of tenant instances.
   * 
   * @example
   * 1
   */
  tenantInstancesCount?: number;
  /**
   * @remarks
   * The total number of instances.
   * 
   * @example
   * 3
   */
  totalInstancesCount?: number;
  /**
   * @remarks
   * The number of data transmission instances.
   * 
   * @example
   * 1
   */
  totalOmsInstancesCount?: number;
  static names(): { [key: string]: string } {
    return {
      alarmSummaryCount: 'AlarmSummaryCount',
      anomalySQLCount: 'AnomalySQLCount',
      clusterInstancesCount: 'ClusterInstancesCount',
      expiredInstancesCount: 'ExpiredInstancesCount',
      immediatelyExpiredInstancesCount: 'ImmediatelyExpiredInstancesCount',
      insufficientDiskInstancesCount: 'InsufficientDiskInstancesCount',
      overLoadInstancesCount: 'OverLoadInstancesCount',
      regionalInstanceSummaryList: 'RegionalInstanceSummaryList',
      runningInstancesCount: 'RunningInstancesCount',
      tenantInstancesCount: 'TenantInstancesCount',
      totalInstancesCount: 'TotalInstancesCount',
      totalOmsInstancesCount: 'TotalOmsInstancesCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alarmSummaryCount: 'number',
      anomalySQLCount: 'number',
      clusterInstancesCount: 'number',
      expiredInstancesCount: 'number',
      immediatelyExpiredInstancesCount: 'number',
      insufficientDiskInstancesCount: 'number',
      overLoadInstancesCount: 'number',
      regionalInstanceSummaryList: { 'type': 'array', 'itemType': DescribeInstanceSummaryResponseBodyInstanceSummaryRegionalInstanceSummaryList },
      runningInstancesCount: 'number',
      tenantInstancesCount: 'number',
      totalInstancesCount: 'number',
      totalOmsInstancesCount: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.regionalInstanceSummaryList)) {
      $dara.Model.validateArray(this.regionalInstanceSummaryList);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTagsResponseBodyTagResources extends $dara.Model {
  /**
   * @remarks
   * The resource ID.
   * 
   * @example
   * ob317v4uif****
   */
  resourceId?: string;
  /**
   * @remarks
   * The type of the resource.
   * 
   * @example
   * instance
   */
  resourceType?: string;
  /**
   * @remarks
   * The tag of the resource.
   * 
   * @example
   * [{"Key": "xxx", "Value", "xxx"},{}]
   */
  tag?: string;
  static names(): { [key: string]: string } {
    return {
      resourceId: 'ResourceId',
      resourceType: 'ResourceType',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceId: 'string',
      resourceType: 'string',
      tag: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTopologyResponseBodyInstanceTopologyReplicasReplicaResourceCpu extends $dara.Model {
  /**
   * @remarks
   * The total number of CPU cores of the replica.
   * 
   * @example
   * 16
   */
  totalCpu?: number;
  /**
   * @remarks
   * The number of CPU cores used by the replica.
   * 
   * @example
   * 8
   */
  usedCpu?: number;
  static names(): { [key: string]: string } {
    return {
      totalCpu: 'TotalCpu',
      usedCpu: 'UsedCpu',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCpu: 'number',
      usedCpu: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTopologyResponseBodyInstanceTopologyReplicasReplicaResourceDiskSize extends $dara.Model {
  /**
   * @remarks
   * The total disk space of the replica, in GB.
   * 
   * @example
   * 100
   */
  totalDiskSize?: number;
  /**
   * @remarks
   * The disk space used by the replica, in GB.
   * 
   * @example
   * 50
   */
  usedDiskSize?: number;
  static names(): { [key: string]: string } {
    return {
      totalDiskSize: 'TotalDiskSize',
      usedDiskSize: 'UsedDiskSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalDiskSize: 'number',
      usedDiskSize: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTopologyResponseBodyInstanceTopologyReplicasReplicaResourceMemory extends $dara.Model {
  /**
   * @remarks
   * The total memory size of the replica, in GB.
   * 
   * @example
   * 32
   */
  totalMemory?: number;
  /**
   * @remarks
   * The size of memory used by the replica, in GB.
   * 
   * @example
   * 16
   */
  usedMemory?: number;
  static names(): { [key: string]: string } {
    return {
      totalMemory: 'TotalMemory',
      usedMemory: 'UsedMemory',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalMemory: 'number',
      usedMemory: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTopologyResponseBodyInstanceTopologyReplicasReplicaResource extends $dara.Model {
  /**
   * @remarks
   * The information about the CPU resources of the replica.
   */
  cpu?: DescribeInstanceTopologyResponseBodyInstanceTopologyReplicasReplicaResourceCpu;
  /**
   * @remarks
   * The information about the data disk of the replica.
   */
  diskSize?: DescribeInstanceTopologyResponseBodyInstanceTopologyReplicasReplicaResourceDiskSize;
  /**
   * @remarks
   * The information about the memory resources of the replica.
   */
  memory?: DescribeInstanceTopologyResponseBodyInstanceTopologyReplicasReplicaResourceMemory;
  static names(): { [key: string]: string } {
    return {
      cpu: 'Cpu',
      diskSize: 'DiskSize',
      memory: 'Memory',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cpu: DescribeInstanceTopologyResponseBodyInstanceTopologyReplicasReplicaResourceCpu,
      diskSize: DescribeInstanceTopologyResponseBodyInstanceTopologyReplicasReplicaResourceDiskSize,
      memory: DescribeInstanceTopologyResponseBodyInstanceTopologyReplicasReplicaResourceMemory,
    };
  }

  validate() {
    if(this.cpu && typeof (this.cpu as any).validate === 'function') {
      (this.cpu as any).validate();
    }
    if(this.diskSize && typeof (this.diskSize as any).validate === 'function') {
      (this.diskSize as any).validate();
    }
    if(this.memory && typeof (this.memory as any).validate === 'function') {
      (this.memory as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTopologyResponseBodyInstanceTopologyReplicas extends $dara.Model {
  /**
   * @remarks
   * The ID of the replica.
   * 
   * @example
   * cn-hangzhou-h-z0
   */
  logicalZone?: string;
  /**
   * @remarks
   * The number of nodes of the replica.
   * 
   * @example
   * 1
   */
  nodeNum?: number;
  /**
   * @remarks
   * The type of the read-only replica.
   * 
   * @example
   * ROW_STORE
   */
  readOnlyReplicaType?: string;
  /**
   * @remarks
   * The information about the replica resources.
   */
  replicaResource?: DescribeInstanceTopologyResponseBodyInstanceTopologyReplicasReplicaResource;
  /**
   * @remarks
   * The type of the replica.
   * 
   * @example
   * FULL
   */
  replicaType?: string;
  /**
   * @remarks
   * The status of the replica. Valid values: ACTIVE, INACTIVE, and UNKNOWN.
   * 
   * @example
   * ACTIVE
   */
  status?: string;
  /**
   * @remarks
   * The serial number of the replica.
   * 
   * @example
   * 1
   */
  zoneLogicalId?: number;
  /**
   * @remarks
   * The region of the replica.
   * 
   * @example
   * cn-hangzhou-h
   */
  zoneLogicalName?: string;
  /**
   * @remarks
   * The zone of the replica.
   * 
   * @example
   * cn-hangzhou-h
   */
  zoneRegionName?: string;
  static names(): { [key: string]: string } {
    return {
      logicalZone: 'LogicalZone',
      nodeNum: 'NodeNum',
      readOnlyReplicaType: 'ReadOnlyReplicaType',
      replicaResource: 'ReplicaResource',
      replicaType: 'ReplicaType',
      status: 'Status',
      zoneLogicalId: 'ZoneLogicalId',
      zoneLogicalName: 'ZoneLogicalName',
      zoneRegionName: 'ZoneRegionName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logicalZone: 'string',
      nodeNum: 'number',
      readOnlyReplicaType: 'string',
      replicaResource: DescribeInstanceTopologyResponseBodyInstanceTopologyReplicasReplicaResource,
      replicaType: 'string',
      status: 'string',
      zoneLogicalId: 'number',
      zoneLogicalName: 'string',
      zoneRegionName: 'string',
    };
  }

  validate() {
    if(this.replicaResource && typeof (this.replicaResource as any).validate === 'function') {
      (this.replicaResource as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTopologyResponseBodyInstanceTopologyTenantsTenantZonesUnits extends $dara.Model {
  /**
   * @remarks
   * Indicates whether the migration can be canceled. This parameter is valid only for resource units that are being manually immigrated or emigrated.
   * 
   * @example
   * true
   */
  enableCancelMigrateUnit?: boolean;
  /**
   * @remarks
   * Indicates whether the resource unit can be migrated.
   * 
   * @example
   * true
   */
  enableMigrateUnit?: boolean;
  /**
   * @remarks
   * Indicates whether the resource unit is manually migrated.
   * 
   * @example
   * true
   */
  manualMigrate?: boolean;
  /**
   * @remarks
   * The ID of the OBServer node in which the resource unit resides.
   * 
   * @example
   * i-bp16niirq4zdmgvm****
   */
  nodeId?: string;
  /**
   * @remarks
   * The type of the replica. Node filtering conditions are configured based on the replica type when you query the monitoring data of the OceanBase cluster. 
   * * By default, the replica type is not specified when you query the monitoring data of OceanBase clusters or the access proxy. If you do not specify the replica type when you query the monitoring data of an OceanBase cluster, the monitoring data of all nodes is queried. 
   * * If you set the replica type to FULL when you query the monitoring data of an OceanBase cluster, the monitoring data of only the full-featured replica nodes is queried. 
   * * If you set the replica type to READONLY when you query the monitoring data of an OceanBase cluster, the monitoring data of only the read-only replica nodes is queried.
   * 
   * @example
   * FULL
   */
  replicaType?: string;
  /**
   * @remarks
   * The number of CPU cores of the resource unit.
   * 
   * @example
   * 2
   */
  unitCpu?: number;
  /**
   * @remarks
   * The data size of the resource unit.
   * 
   * @example
   * 10
   */
  unitDataSize?: number;
  /**
   * @remarks
   * The ID of the resource unit.
   * 
   * @example
   * 1002
   */
  unitId?: string;
  /**
   * @remarks
   * The memory size of the resource unit, in GB.
   * 
   * @example
   * 10
   */
  unitMemory?: number;
  /**
   * @remarks
   * The status of the resource unit. Valid values: 
   * * ONLINE: The resource unit is running. 
   * * IMMIGRATING: The resource unit is being immigrated. 
   * * EMIGRATING: The resource unit is being emigrated. 
   * * CANCEL_EMIGRATING: The immigration of the resource unit is being canceled. 
   * * CANCEL_EMIGRATING: The emigration of the resource unit is being canceled. 
   * * DELETING: The resource unit is being deleted.
   * 
   * @example
   * ONLINE
   */
  unitStatus?: string;
  static names(): { [key: string]: string } {
    return {
      enableCancelMigrateUnit: 'EnableCancelMigrateUnit',
      enableMigrateUnit: 'EnableMigrateUnit',
      manualMigrate: 'ManualMigrate',
      nodeId: 'NodeId',
      replicaType: 'ReplicaType',
      unitCpu: 'UnitCpu',
      unitDataSize: 'UnitDataSize',
      unitId: 'UnitId',
      unitMemory: 'UnitMemory',
      unitStatus: 'UnitStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enableCancelMigrateUnit: 'boolean',
      enableMigrateUnit: 'boolean',
      manualMigrate: 'boolean',
      nodeId: 'string',
      replicaType: 'string',
      unitCpu: 'number',
      unitDataSize: 'number',
      unitId: 'string',
      unitMemory: 'number',
      unitStatus: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTopologyResponseBodyInstanceTopologyTenantsTenantZones extends $dara.Model {
  /**
   * @remarks
   * Indicates whether the zone is the primary zone.
   * 
   * @example
   * true
   */
  isPrimaryTenantZone?: boolean;
  /**
   * @remarks
   * The ID of the replica.
   * 
   * @example
   * cn-hangzhou-h-z0
   */
  logicalZone?: string;
  /**
   * @remarks
   * The type of the read-only replica.
   * 
   * @example
   * ROW_STORE
   */
  readOnlyReplicaType?: string;
  /**
   * @remarks
   * The replica type of the tenant.
   * 
   * @example
   * FULL
   */
  replicaType?: string;
  /**
   * @remarks
   * The ID of the zone.
   * 
   * @example
   * cn-hangzhou-h
   */
  tenantZoneId?: string;
  /**
   * @remarks
   * The role to access the zone. Valid values: 
   * * ReadWrite: a role that has the read and write privileges. 
   * * ReadOnly: a role that has only the read-only privilege.
   * 
   * @example
   * ReadWrite
   */
  tenantZoneRole?: string;
  /**
   * @remarks
   * The information about the resource units.
   */
  units?: DescribeInstanceTopologyResponseBodyInstanceTopologyTenantsTenantZonesUnits[];
  static names(): { [key: string]: string } {
    return {
      isPrimaryTenantZone: 'IsPrimaryTenantZone',
      logicalZone: 'LogicalZone',
      readOnlyReplicaType: 'ReadOnlyReplicaType',
      replicaType: 'ReplicaType',
      tenantZoneId: 'TenantZoneId',
      tenantZoneRole: 'TenantZoneRole',
      units: 'Units',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isPrimaryTenantZone: 'boolean',
      logicalZone: 'string',
      readOnlyReplicaType: 'string',
      replicaType: 'string',
      tenantZoneId: 'string',
      tenantZoneRole: 'string',
      units: { 'type': 'array', 'itemType': DescribeInstanceTopologyResponseBodyInstanceTopologyTenantsTenantZonesUnits },
    };
  }

  validate() {
    if(Array.isArray(this.units)) {
      $dara.Model.validateArray(this.units);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTopologyResponseBodyInstanceTopologyTenants extends $dara.Model {
  /**
   * @remarks
   * The deployment mode of the primary zone. Valid values: 
   * * RANDOM. 
   * * STATIC.
   * 
   * @example
   * RANDOM
   */
  primaryZoneDeployType?: string;
  /**
   * @remarks
   * The number of CPU cores of the tenant.
   * 
   * @example
   * 2
   */
  tenantCpu?: number;
  /**
   * @remarks
   * The deployment type of the tenant. Valid values: 
   * * multiple: multi-IDC deployment. 
   * * single: single-IDC deployment. 
   * * dual: dual-IDC deployment.
   * 
   * @example
   * multiple
   */
  tenantDeployType?: string;
  /**
   * @remarks
   * The disk space of the tenant, in GB.
   * 
   * @example
   * 2
   */
  tenantDiskSize?: number;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * @example
   * t33h8y08k****
   */
  tenantId?: string;
  /**
   * @remarks
   * The memory size of the tenant, in GB.
   * 
   * @example
   * 10
   */
  tenantMemory?: number;
  /**
   * @remarks
   * The mode of the tenant. Valid values: 
   * * Oracle  
   * * MySQL
   * 
   * @example
   * Oracle
   */
  tenantMode?: string;
  /**
   * @remarks
   * The name of the tenant.
   * 
   * @example
   * pay_online
   */
  tenantName?: string;
  /**
   * @remarks
   * The status of the tenant. Valid values: 
   * * PENDING_CREATE: The tenant is being created. 
   * * RESTORE: The tenant is being restored. 
   * * ONLINE: The tenant is running. 
   * * SPEC_MODIFYING: The specification of the tenant is being modified. 
   * * ALLOCATING_INTERNET_ADDRESS: A public IP address is being allocated to the tenant. 
   * * PENDING_OFFLINE_INTERNET_ADDRESS: The public IP address is being disabled. 
   * * PRIMARY_ZONE_MODIFYING: The tenant is being switched to a new primary zone. 
   * * PARAMETER_MODIFYING: Parameters are being modified. 
   * * WHITE_LIST_MODIFYING: The allowlist is being modified.
   * 
   * @example
   * ONLINE
   */
  tenantStatus?: string;
  /**
   * @remarks
   * The number of CPU cores of a single node in the tenant.
   * 
   * @example
   * 4
   */
  tenantUnitCpu?: number;
  /**
   * @remarks
   * The memory size of a single node in the tenant, in GB.
   * 
   * @example
   * 16
   */
  tenantUnitMemory?: number;
  /**
   * @remarks
   * The number of resource units in the tenant.
   * 
   * @example
   * 1
   */
  tenantUnitNum?: number;
  /**
   * @remarks
   * The information about the zones.
   */
  tenantZones?: DescribeInstanceTopologyResponseBodyInstanceTopologyTenantsTenantZones[];
  static names(): { [key: string]: string } {
    return {
      primaryZoneDeployType: 'PrimaryZoneDeployType',
      tenantCpu: 'TenantCpu',
      tenantDeployType: 'TenantDeployType',
      tenantDiskSize: 'TenantDiskSize',
      tenantId: 'TenantId',
      tenantMemory: 'TenantMemory',
      tenantMode: 'TenantMode',
      tenantName: 'TenantName',
      tenantStatus: 'TenantStatus',
      tenantUnitCpu: 'TenantUnitCpu',
      tenantUnitMemory: 'TenantUnitMemory',
      tenantUnitNum: 'TenantUnitNum',
      tenantZones: 'TenantZones',
    };
  }

  static types(): { [key: string]: any } {
    return {
      primaryZoneDeployType: 'string',
      tenantCpu: 'number',
      tenantDeployType: 'string',
      tenantDiskSize: 'number',
      tenantId: 'string',
      tenantMemory: 'number',
      tenantMode: 'string',
      tenantName: 'string',
      tenantStatus: 'string',
      tenantUnitCpu: 'number',
      tenantUnitMemory: 'number',
      tenantUnitNum: 'number',
      tenantZones: { 'type': 'array', 'itemType': DescribeInstanceTopologyResponseBodyInstanceTopologyTenantsTenantZones },
    };
  }

  validate() {
    if(Array.isArray(this.tenantZones)) {
      $dara.Model.validateArray(this.tenantZones);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResourceCpu extends $dara.Model {
  /**
   * @remarks
   * The total number of CPU cores of the node.
   * 
   * @example
   * 14
   */
  totalCpu?: number;
  /**
   * @remarks
   * The number of CPU cores used by the node.
   * 
   * @example
   * 4
   */
  usedCpu?: number;
  static names(): { [key: string]: string } {
    return {
      totalCpu: 'TotalCpu',
      usedCpu: 'UsedCpu',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCpu: 'number',
      usedCpu: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResourceDiskSize extends $dara.Model {
  /**
   * @remarks
   * The total storage space of the node, in GB.
   * 
   * @example
   * 100
   */
  totalDiskSize?: number;
  /**
   * @remarks
   * The size of storage space used by the node, in GB.
   * 
   * @example
   * 50
   */
  usedDiskSize?: number;
  static names(): { [key: string]: string } {
    return {
      totalDiskSize: 'TotalDiskSize',
      usedDiskSize: 'UsedDiskSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalDiskSize: 'number',
      usedDiskSize: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResourceMemory extends $dara.Model {
  /**
   * @remarks
   * The total memory size of the node, in GB.
   * 
   * @example
   * 70
   */
  totalMemory?: number;
  /**
   * @remarks
   * The size of memory used by the node, in GB.
   * 
   * @example
   * 10
   */
  usedMemory?: number;
  static names(): { [key: string]: string } {
    return {
      totalMemory: 'TotalMemory',
      usedMemory: 'UsedMemory',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalMemory: 'number',
      usedMemory: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResource extends $dara.Model {
  /**
   * @remarks
   * The information about the CPU resources of the node.
   */
  cpu?: DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResourceCpu;
  /**
   * @remarks
   * The information about the storage resources of the node.
   */
  diskSize?: DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResourceDiskSize;
  /**
   * @remarks
   * The information about the memory resources of the node.
   */
  memory?: DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResourceMemory;
  static names(): { [key: string]: string } {
    return {
      cpu: 'Cpu',
      diskSize: 'DiskSize',
      memory: 'Memory',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cpu: DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResourceCpu,
      diskSize: DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResourceDiskSize,
      memory: DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResourceMemory,
    };
  }

  validate() {
    if(this.cpu && typeof (this.cpu as any).validate === 'function') {
      (this.cpu as any).validate();
    }
    if(this.diskSize && typeof (this.diskSize as any).validate === 'function') {
      (this.diskSize as any).validate();
    }
    if(this.memory && typeof (this.memory as any).validate === 'function') {
      (this.memory as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodes extends $dara.Model {
  /**
   * @remarks
   * The ID of the full-featured replica.
   * 
   * @example
   * 1
   */
  fullCopyId?: number;
  /**
   * @remarks
   * The ID of the replica.
   * 
   * @example
   * cn-hangzhou-h-z0
   */
  logicalZone?: string;
  /**
   * @remarks
   * The ID of the replica node.
   * 
   * @example
   * 1
   */
  nodeCopyId?: number;
  /**
   * @remarks
   * The ID of the node.
   * 
   * @example
   * i-bp16niirq4zdmgvm****
   */
  nodeId?: string;
  /**
   * @remarks
   * The information about node resources.
   */
  nodeResource?: DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResource;
  /**
   * @remarks
   * The status of the node.
   * 
   * @example
   * ONLINE
   */
  nodeStatus?: string;
  /**
   * @remarks
   * The ID of the read-only replica.
   * 
   * @example
   * 1
   */
  readOnlyCopyId?: number;
  /**
   * @remarks
   * The type of the read-only replica.
   * 
   * @example
   * ROW_STORE
   */
  readOnlyReplicaType?: string;
  /**
   * @remarks
   * The type of the replica. Valid values: 
   * * FULL. 
   * * READONLY.
   * 
   * @example
   * FULL
   */
  replicaType?: string;
  static names(): { [key: string]: string } {
    return {
      fullCopyId: 'FullCopyId',
      logicalZone: 'LogicalZone',
      nodeCopyId: 'NodeCopyId',
      nodeId: 'NodeId',
      nodeResource: 'NodeResource',
      nodeStatus: 'NodeStatus',
      readOnlyCopyId: 'ReadOnlyCopyId',
      readOnlyReplicaType: 'ReadOnlyReplicaType',
      replicaType: 'ReplicaType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fullCopyId: 'number',
      logicalZone: 'string',
      nodeCopyId: 'number',
      nodeId: 'string',
      nodeResource: DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResource,
      nodeStatus: 'string',
      readOnlyCopyId: 'number',
      readOnlyReplicaType: 'string',
      replicaType: 'string',
    };
  }

  validate() {
    if(this.nodeResource && typeof (this.nodeResource as any).validate === 'function') {
      (this.nodeResource as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTopologyResponseBodyInstanceTopologyZonesZoneResourceDiskSize extends $dara.Model {
  /**
   * @remarks
   * The IDs of OBServer nodes that use the maximum disk space.
   */
  maxDiskUsedObServer?: string[];
  /**
   * @remarks
   * The maximum disk usage, in percentage.
   * 
   * @example
   * 0.14
   */
  maxDiskUsedPercent?: number;
  static names(): { [key: string]: string } {
    return {
      maxDiskUsedObServer: 'MaxDiskUsedObServer',
      maxDiskUsedPercent: 'MaxDiskUsedPercent',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxDiskUsedObServer: { 'type': 'array', 'itemType': 'string' },
      maxDiskUsedPercent: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.maxDiskUsedObServer)) {
      $dara.Model.validateArray(this.maxDiskUsedObServer);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTopologyResponseBodyInstanceTopologyZonesZoneResource extends $dara.Model {
  /**
   * @remarks
   * The information about the storage resources of the node.
   */
  diskSize?: DescribeInstanceTopologyResponseBodyInstanceTopologyZonesZoneResourceDiskSize;
  static names(): { [key: string]: string } {
    return {
      diskSize: 'DiskSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      diskSize: DescribeInstanceTopologyResponseBodyInstanceTopologyZonesZoneResourceDiskSize,
    };
  }

  validate() {
    if(this.diskSize && typeof (this.diskSize as any).validate === 'function') {
      (this.diskSize as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTopologyResponseBodyInstanceTopologyZones extends $dara.Model {
  /**
   * @remarks
   * The information about the nodes.
   */
  nodes?: DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodes[];
  /**
   * @remarks
   * The ID of the region.
   * 
   * @example
   * cn-hangzhou
   */
  region?: string;
  /**
   * @remarks
   * The storage capacity of the zone.
   * 
   * @example
   * 200 GB
   */
  zoneDisk?: string;
  /**
   * @remarks
   * The ID of the zone.
   * 
   * @example
   * cn-hangzhou-i
   */
  zoneId?: string;
  /**
   * @remarks
   * The information about zones.
   */
  zoneResource?: DescribeInstanceTopologyResponseBodyInstanceTopologyZonesZoneResource;
  static names(): { [key: string]: string } {
    return {
      nodes: 'Nodes',
      region: 'Region',
      zoneDisk: 'ZoneDisk',
      zoneId: 'ZoneId',
      zoneResource: 'ZoneResource',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodes: { 'type': 'array', 'itemType': DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodes },
      region: 'string',
      zoneDisk: 'string',
      zoneId: 'string',
      zoneResource: DescribeInstanceTopologyResponseBodyInstanceTopologyZonesZoneResource,
    };
  }

  validate() {
    if(Array.isArray(this.nodes)) {
      $dara.Model.validateArray(this.nodes);
    }
    if(this.zoneResource && typeof (this.zoneResource as any).validate === 'function') {
      (this.zoneResource as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTopologyResponseBodyInstanceTopology extends $dara.Model {
  /**
   * @remarks
   * The information about replicas.
   */
  replicas?: DescribeInstanceTopologyResponseBodyInstanceTopologyReplicas[];
  /**
   * @remarks
   * The information about the tenants.
   */
  tenants?: DescribeInstanceTopologyResponseBodyInstanceTopologyTenants[];
  /**
   * @remarks
   * The information about the zones in which the cluster is deployed.
   */
  zones?: DescribeInstanceTopologyResponseBodyInstanceTopologyZones[];
  static names(): { [key: string]: string } {
    return {
      replicas: 'Replicas',
      tenants: 'Tenants',
      zones: 'Zones',
    };
  }

  static types(): { [key: string]: any } {
    return {
      replicas: { 'type': 'array', 'itemType': DescribeInstanceTopologyResponseBodyInstanceTopologyReplicas },
      tenants: { 'type': 'array', 'itemType': DescribeInstanceTopologyResponseBodyInstanceTopologyTenants },
      zones: { 'type': 'array', 'itemType': DescribeInstanceTopologyResponseBodyInstanceTopologyZones },
    };
  }

  validate() {
    if(Array.isArray(this.replicas)) {
      $dara.Model.validateArray(this.replicas);
    }
    if(Array.isArray(this.tenants)) {
      $dara.Model.validateArray(this.tenants);
    }
    if(Array.isArray(this.zones)) {
      $dara.Model.validateArray(this.zones);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesResponseBodyInstancesDataDiskAutoScaleConfig extends $dara.Model {
  /**
   * @remarks
   * Specifies whether to enable the automatic scaling of the data disk.
   * 
   * @example
   * true
   */
  autoScale?: boolean;
  /**
   * @remarks
   * The maximum size of the disk, in GB.
   * 
   * @example
   * 80000
   */
  maxDiskSize?: number;
  /**
   * @remarks
   * The size of scaling step during a major compaction.
   * 
   * @example
   * 100
   */
  scaleStepInMerge?: number;
  /**
   * @remarks
   * The size of scaling step during daily use.
   * 
   * @example
   * 50
   */
  scaleStepInNormal?: number;
  /**
   * @remarks
   * The maximum usage of the data disk, in percentage, that triggers the scaling of the data disk for major compactions.
   * 
   * @example
   * 90
   */
  upperMergeThreshold?: number;
  /**
   * @remarks
   * The scale-out strategy. Valid values: RAW and PERCENTAGE.
   * 
   * @example
   * RAW
   */
  upperScaleStrategy?: string;
  /**
   * @remarks
   * The maximum usage of the data disk, in percentage, that triggers the scaling of the data disk for daily use.
   * 
   * @example
   * 80
   */
  upperThreshold?: number;
  /**
   * @remarks
   * The maximum space, in GB, to which the data disk can be scaled.
   * 
   * @example
   * 16
   */
  upperbound?: number;
  static names(): { [key: string]: string } {
    return {
      autoScale: 'AutoScale',
      maxDiskSize: 'MaxDiskSize',
      scaleStepInMerge: 'ScaleStepInMerge',
      scaleStepInNormal: 'ScaleStepInNormal',
      upperMergeThreshold: 'UpperMergeThreshold',
      upperScaleStrategy: 'UpperScaleStrategy',
      upperThreshold: 'UpperThreshold',
      upperbound: 'Upperbound',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoScale: 'boolean',
      maxDiskSize: 'number',
      scaleStepInMerge: 'number',
      scaleStepInNormal: 'number',
      upperMergeThreshold: 'number',
      upperScaleStrategy: 'string',
      upperThreshold: 'number',
      upperbound: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesResponseBodyInstancesResourceCapacityUnit extends $dara.Model {
  /**
   * @remarks
   * The maximum number of capacity units.
   * 
   * @example
   * 4
   */
  maxCapacityUnit?: number;
  /**
   * @remarks
   * The minimum number of capacity units.
   * 
   * @example
   * 1
   */
  minCapacityUnit?: number;
  /**
   * @remarks
   * The number of used capacity units.
   * 
   * @example
   * 2
   */
  usedCapacityUnit?: number;
  static names(): { [key: string]: string } {
    return {
      maxCapacityUnit: 'MaxCapacityUnit',
      minCapacityUnit: 'MinCapacityUnit',
      usedCapacityUnit: 'UsedCapacityUnit',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxCapacityUnit: 'number',
      minCapacityUnit: 'number',
      usedCapacityUnit: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesResponseBodyInstancesResourceCpu extends $dara.Model {
  /**
   * @remarks
   * The number of original CPU cores in the cluster.
   * 
   * @example
   * 14
   */
  originalTotalCpu?: number;
  /**
   * @remarks
   * The total number of CPU cores of the cluster.
   * 
   * @example
   * 14
   */
  totalCpu?: number;
  /**
   * @remarks
   * The number of CPU cores of each replica node in the cluster.
   * 
   * @example
   * 10
   */
  unitCpu?: number;
  /**
   * @remarks
   * The number of CPU cores used in the cluster.
   * 
   * @example
   * 10
   */
  usedCpu?: number;
  static names(): { [key: string]: string } {
    return {
      originalTotalCpu: 'OriginalTotalCpu',
      totalCpu: 'TotalCpu',
      unitCpu: 'UnitCpu',
      usedCpu: 'UsedCpu',
    };
  }

  static types(): { [key: string]: any } {
    return {
      originalTotalCpu: 'number',
      totalCpu: 'number',
      unitCpu: 'number',
      usedCpu: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesResponseBodyInstancesResourceDiskSize extends $dara.Model {
  /**
   * @remarks
   * The original size of the disk.
   * 
   * @example
   * 200
   */
  originalTotalDiskSize?: number;
  /**
   * @remarks
   * The total storage space of the cluster, in GB.
   * 
   * @example
   * 200
   */
  totalDiskSize?: number;
  /**
   * @remarks
   * The storage space of each replica node in the cluster, in GB.
   * 
   * @example
   * 200
   */
  unitDiskSize?: number;
  /**
   * @remarks
   * The size of used storage space of the cluster, in GB.
   * 
   * @example
   * 100
   */
  usedDiskSize?: number;
  static names(): { [key: string]: string } {
    return {
      originalTotalDiskSize: 'OriginalTotalDiskSize',
      totalDiskSize: 'TotalDiskSize',
      unitDiskSize: 'UnitDiskSize',
      usedDiskSize: 'UsedDiskSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      originalTotalDiskSize: 'number',
      totalDiskSize: 'number',
      unitDiskSize: 'number',
      usedDiskSize: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesResponseBodyInstancesResourceMemory extends $dara.Model {
  /**
   * @remarks
   * The original memory size of the cluster, in GB.
   * 
   * @example
   * 72
   */
  originalTotalMemory?: number;
  /**
   * @remarks
   * The total memory size of the cluster, in GB.
   * 
   * @example
   * 70
   */
  totalMemory?: number;
  /**
   * @remarks
   * The memory size of each replica node in the cluster, in GB.
   * 
   * @example
   * 10
   */
  unitMemory?: number;
  /**
   * @remarks
   * The size of used memory in the cluster, in GB.
   * 
   * @example
   * 10
   */
  usedMemory?: number;
  static names(): { [key: string]: string } {
    return {
      originalTotalMemory: 'OriginalTotalMemory',
      totalMemory: 'TotalMemory',
      unitMemory: 'UnitMemory',
      usedMemory: 'UsedMemory',
    };
  }

  static types(): { [key: string]: any } {
    return {
      originalTotalMemory: 'number',
      totalMemory: 'number',
      unitMemory: 'number',
      usedMemory: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesResponseBodyInstancesResource extends $dara.Model {
  /**
   * @remarks
   * The information about capacity units.
   */
  capacityUnit?: DescribeInstancesResponseBodyInstancesResourceCapacityUnit;
  /**
   * @remarks
   * The information about the CPU resources of the cluster.
   */
  cpu?: DescribeInstancesResponseBodyInstancesResourceCpu;
  /**
   * @remarks
   * The information about the storage resources of the cluster.
   */
  diskSize?: DescribeInstancesResponseBodyInstancesResourceDiskSize;
  /**
   * @remarks
   * The information about the memory resources of the cluster.
   */
  memory?: DescribeInstancesResponseBodyInstancesResourceMemory;
  /**
   * @remarks
   * The number of resource units in the cluster.
   * 
   * @example
   * 1
   */
  unitCount?: number;
  static names(): { [key: string]: string } {
    return {
      capacityUnit: 'CapacityUnit',
      cpu: 'Cpu',
      diskSize: 'DiskSize',
      memory: 'Memory',
      unitCount: 'UnitCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      capacityUnit: DescribeInstancesResponseBodyInstancesResourceCapacityUnit,
      cpu: DescribeInstancesResponseBodyInstancesResourceCpu,
      diskSize: DescribeInstancesResponseBodyInstancesResourceDiskSize,
      memory: DescribeInstancesResponseBodyInstancesResourceMemory,
      unitCount: 'number',
    };
  }

  validate() {
    if(this.capacityUnit && typeof (this.capacityUnit as any).validate === 'function') {
      (this.capacityUnit as any).validate();
    }
    if(this.cpu && typeof (this.cpu as any).validate === 'function') {
      (this.cpu as any).validate();
    }
    if(this.diskSize && typeof (this.diskSize as any).validate === 'function') {
      (this.diskSize as any).validate();
    }
    if(this.memory && typeof (this.memory as any).validate === 'function') {
      (this.memory as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesResponseBodyInstances extends $dara.Model {
  /**
   * @remarks
   * The information about the zone in which the cluster is deployed.
   */
  availableZones?: string[];
  /**
   * @remarks
   * The product code of the OceanBase cluster.   
   * - oceanbase_oceanbasepre_public_cn: indicates an OceanBase cluster that is billed based on the subscription plan and that is deployed in a China site.  
   * - oceanbase_oceanbasepost_public_cn: indicates an OceanBase cluster that is billed based on the pay-as-you-go plan and that is deployed in a China site.  
   * - oceanbase_obpre_public_intl: indicates an OceanBase cluster that is billed based on the subscription plan and that is deployed in an international site.
   * 
   * @example
   * oceanbase_oceanbasepost_public_cn
   */
  commodityCode?: string;
  /**
   * @remarks
   * The number of CPU cores of the cluster.
   * 
   * @example
   * 14
   */
  cpu?: number;
  /**
   * @remarks
   * The CPU architecture of the cluster.
   * 
   * @example
   * X86_64, AARCH64
   */
  cpuArchitecture?: string;
  /**
   * @remarks
   * The time in UTC when the cluster was created.
   * 
   * @example
   * 2021-10-19T07:13:41Z
   */
  createTime?: string;
  /**
   * @remarks
   * Specifies parameters for the automatic scaling of the data disk.
   */
  dataDiskAutoScaleConfig?: DescribeInstancesResponseBodyInstancesDataDiskAutoScaleConfig;
  /**
   * @remarks
   * The data replica distribution mode of the cluster. The value is in the n-n-n format, where n is the number of OBServer nodes in each IDC.
   * 
   * @example
   * 1-1-1
   */
  deployMode?: string;
  /**
   * @remarks
   * The deployment type of the cluster. Valid values:   
   * - multiple: multi-IDC deployment  
   * - single: single-IDC deployment  
   * - dual: dual-IDC deployment
   * 
   * @example
   * multiple
   */
  deployType?: string;
  /**
   * @remarks
   * The size of the storage space, in GB.
   * 
   * @example
   * 200
   */
  diskSize?: number;
  /**
   * @remarks
   * The type of the storage disk where the cluster is deployed.   
   * The default value is cloud_essd_pl1, which indicates an ESSD cloud disk.
   * 
   * @example
   * cloud_essd_pl1
   */
  diskType?: string;
  /**
   * @remarks
   * Indicates whether the cluster supports read-only replicas.
   * 
   * @example
   * yes
   */
  enableReadOnlyReplicaManagement?: boolean;
  /**
   * @remarks
   * Indicates whether new nodes can be added.
   * 
   * @example
   * true
   */
  enableUpgradeNodes?: boolean;
  /**
   * @remarks
   * The time elapsed since the expiration of the cluster, in seconds. 
   * > In subscription mode, if the cluster has not expired, this parameter indicates the remaining validity period of the cluster. If the cluster has expired, this parameter indicates the time elapsed since the expiration.
   * 
   * @example
   * 2606682
   */
  expireSeconds?: number;
  /**
   * @remarks
   * The time in UTC when the cluster expires. 
   * > This parameter is valid only for subscription instances.
   * 
   * @example
   * 2021-10-17T16:00:00Z
   */
  expireTime?: string;
  /**
   * @remarks
   * Specifies whether to indicate the temporary status of the capacity.
   * 
   * @example
   * false
   */
  inTempCapacityStatus?: boolean;
  /**
   * @remarks
   * The specifications of the cluster.  You can specify one of the following four plans:  
   * - 8C32G: indicates 8 CPU cores and 32 GB of memory.  
   * - 14C70G: indicates 14 CPU cores and 70 GB of memory.  
   * - 30C180G: indicates 30 CPU cores and 180 GB of memory.  
   * - 62C400G: indicates 62 CPU cores and 400 GB of memory.
   * 
   * @example
   * 14C70G
   */
  instanceClass?: string;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The name of the OceanBase cluster.
   * 
   * @example
   * ob4test
   */
  instanceName?: string;
  /**
   * @remarks
   * The role of the instance.
   * 
   * @example
   * NORMAL
   */
  instanceRole?: string;
  /**
   * @remarks
   * The instance type.
   * - cluster: indicates a cluster instance.
   * - mtenant: indicates a tenant instance in MySQL mode.
   * - mtenant_serverless: indicates a serverless instance in MySQL mode.
   * 
   * @example
   * CLUSTER
   */
  instanceType?: string;
  /**
   * @remarks
   * The time period in UTC for the daily routine maintenance of the cluster.
   * 
   * @example
   * 2021-10-19T07:13:41Z
   */
  maintainTime?: string;
  /**
   * @remarks
   * The memory size of the instance, in GB.
   * 
   * @example
   * 70
   */
  mem?: number;
  /**
   * @remarks
   * The version of the OceanBase Database RedHat Package Managerment (RPM) package.
   * 
   * @example
   * 4.2.1.7-107030032024062709
   */
  obRpmVersion?: string;
  /**
   * @remarks
   * The billing method for the OceanBase cluster. Valid values:  
   * - PREPAY: the subscription billing method.  
   * - POSTPAY: the pay-as-you-go billing method.
   * 
   * @example
   * PREPAY
   */
  payType?: string;
  /**
   * @example
   * 3F、2F1A
   */
  replicaMode?: string;
  /**
   * @remarks
   * The information about cluster resources.
   */
  resource?: DescribeInstancesResponseBodyInstancesResource;
  /**
   * @remarks
   * The ID of the resource group.
   * 
   * @example
   * group1
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The series of the OceanBase cluster. Valid values:   
   * - NORMAL: the high availability edition.   
   * - BASIC: the basic edition.
   * 
   * @example
   * NORMAL
   */
  series?: string;
  /**
   * @remarks
   * The specification type.
   * 
   * @example
   * dedicatedspec
   */
  specType?: string;
  /**
   * @remarks
   * The status of the cluster. Valid values:   
   * - ONLINE: The cluster is running.  
   * - PENDING_CREATE: The cluster is being created.  
   * - ARREARS_CLOSED("arrears_closed"): The cluster is suspended due to insufficient balance.
   * - PREPAID_EXPIRE_CLOSED("prepaid_expire_closed"): The cluster is suspended because the subscription has expired.
   * - WHITE_LIST_MODIFYING("white_list_modifying"): The allowlist of the cluster is being modified.
   * - SSL_MODIFYING("ssl_modifying"): The Secure Sockets Layer (SSL) settings of the cluster are being modified.
   * - PARAMETER_MODIFYING("parameter_modifying"): Parameters of the cluster are being modified.
   * - TENANT_CREATING("tenant_creating"): A tenant is being created in the cluster.
   * - TENANT_SPEC_MODIFYING("tenant_spec_modifying"): The specifications of a tenant in the cluster are being modified.
   * - EXPANDING("expanding"): Nodes are being added to the cluster.
   * - REDUCING("reducing"): Nodes are being removed from the cluster.
   * - ZONE_CHANGING("zone_changing"): Zones of the cluster are being modified.
   * - SPEC_UPGRADING: The service plan is being upgraded.
   * - SPEC_DOWNGRADING("spec_downgrading"): The plan specification is being downgraded.
   * - DISK_UPGRADING: The storage space is being expanded.
   * - UPGRADING("upgrading"): The version of the cluster is being upgraded.
   * - PENDING_DELETE("pending_delete"): The cluster is being deleted.
   * - DELETED("deleted"): The cluster has been deleted.
   * - ABNORMAL("abnormal"): The cluster is abnormal.
   * - OFFLINE("offline"): The cluster is offline.
   * - STANDBY_CREATING("standby_creating"): A standby cluster is being created for the cluster.
   * - STANDBY_DELETING("standby_deleting"): A standby cluster of the cluster is being deleted.
   * - SWITCHOVER_SWITCHING("switchover_switching"): The cluster is undergoing a primary/standby switchover.
   * - STANDBY_DISCONNECTING("standby_disconnecting"): The cluster is being decoupled from its standby cluster.
   * - LOG_DISK_UPGRADING("log_disk_upgrading"): The log disk of the cluster is being scaled out.
   * - ISOLATION_OPTIMIZATION_MODIFYING("isolation_optimization_modifying"): The isolation optimization settings of the cluster are being modified.
   * - DISKTYPE_MODIFYING("disktype_modifying"): The data disk type of the cluster is being modified.
   * - PROXY_SERVICE_CREATING("proxy_service_creating"): The proxy service is being enabled for the cluster.
   * - PROXY_SERVICE_DELETING("proxy_service_deleting"): The proxy service is being disabled for the cluster.
   * - PROXY_SERVICE_SPEC_MODIFYING("proxy_service_spec_modifying"): The proxy service specification is being modified for the cluster.
   * - READONLY_ADD_NODE("readonly_add_node"): A read-only node is being added to the cluster.
   * - READONLY_REDUCE_NODE("readonly_reduce_node"): A read-only node is being removed from the cluster.
   * - READONLY_REDUCE_ZONE("readonly_reduce_zone"): A read-only zone is being removed from the cluster.
   * - READONLY_ADD_ZONE("readonly_add_zone"): A read-only zone is being added to the cluster.
   * - READONLY_UPGRADE_SPEC("readonly_upgrade_spec"): The specification of read-only replicas is being upgraded.
   * - READONLY_UPGRADE_DISK("readonly_upgrade_disk"): The disk space of read-only replicas is being scaled out.
   * - READONLY_DOWNGRADE_SPEC("readonly_downgrade_spec"): The specification of read-only replicas is being downgraded.
   * - READONLY_DOWNGRADE_DISK("readonly_downgrade_disk"): The disk space of read-only replicas is being scaled in.
   * - CREATING_TENANT_READONLY_REPLICA("creating_tenant_readonly_replica"): A read-only replica is being created for a tenant in the cluster.
   * - DELETING_TENANT_READONLY_REPLICA("deleting_tenant_readonly_replica"): A read-only replica is being deleted for a tenant in the cluster.
   * - DISK_DOWNGRADING("disk_downgrading"): The disk space of the cluster is being scaled in.
   * - DEPLOY_MODE_MODIFYING("deploy_mode_modifying"): The deployment mode of the cluster is being modified.
   * > Generally, the cluster is in the ONLINE state.
   * 
   * @example
   * ONLINE
   */
  state?: string;
  /**
   * @remarks
   * The size of used storage space of the cluster, in GB.
   * 
   * @example
   * 20
   */
  usedDiskSize?: number;
  /**
   * @remarks
   * The OBServer version.
   * 
   * @example
   * 2.2.77
   */
  version?: string;
  /**
   * @remarks
   * vpcId
   * 
   * @example
   * vpc-8vb8qjrixzovjpy******
   */
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      availableZones: 'AvailableZones',
      commodityCode: 'CommodityCode',
      cpu: 'Cpu',
      cpuArchitecture: 'CpuArchitecture',
      createTime: 'CreateTime',
      dataDiskAutoScaleConfig: 'DataDiskAutoScaleConfig',
      deployMode: 'DeployMode',
      deployType: 'DeployType',
      diskSize: 'DiskSize',
      diskType: 'DiskType',
      enableReadOnlyReplicaManagement: 'EnableReadOnlyReplicaManagement',
      enableUpgradeNodes: 'EnableUpgradeNodes',
      expireSeconds: 'ExpireSeconds',
      expireTime: 'ExpireTime',
      inTempCapacityStatus: 'InTempCapacityStatus',
      instanceClass: 'InstanceClass',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      instanceRole: 'InstanceRole',
      instanceType: 'InstanceType',
      maintainTime: 'MaintainTime',
      mem: 'Mem',
      obRpmVersion: 'ObRpmVersion',
      payType: 'PayType',
      replicaMode: 'ReplicaMode',
      resource: 'Resource',
      resourceGroupId: 'ResourceGroupId',
      series: 'Series',
      specType: 'SpecType',
      state: 'State',
      usedDiskSize: 'UsedDiskSize',
      version: 'Version',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      availableZones: { 'type': 'array', 'itemType': 'string' },
      commodityCode: 'string',
      cpu: 'number',
      cpuArchitecture: 'string',
      createTime: 'string',
      dataDiskAutoScaleConfig: DescribeInstancesResponseBodyInstancesDataDiskAutoScaleConfig,
      deployMode: 'string',
      deployType: 'string',
      diskSize: 'number',
      diskType: 'string',
      enableReadOnlyReplicaManagement: 'boolean',
      enableUpgradeNodes: 'boolean',
      expireSeconds: 'number',
      expireTime: 'string',
      inTempCapacityStatus: 'boolean',
      instanceClass: 'string',
      instanceId: 'string',
      instanceName: 'string',
      instanceRole: 'string',
      instanceType: 'string',
      maintainTime: 'string',
      mem: 'number',
      obRpmVersion: 'string',
      payType: 'string',
      replicaMode: 'string',
      resource: DescribeInstancesResponseBodyInstancesResource,
      resourceGroupId: 'string',
      series: 'string',
      specType: 'string',
      state: 'string',
      usedDiskSize: 'number',
      version: 'string',
      vpcId: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.availableZones)) {
      $dara.Model.validateArray(this.availableZones);
    }
    if(this.dataDiskAutoScaleConfig && typeof (this.dataDiskAutoScaleConfig as any).validate === 'function') {
      (this.dataDiskAutoScaleConfig as any).validate();
    }
    if(this.resource && typeof (this.resource as any).validate === 'function') {
      (this.resource as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOasAnomalySQLListResponseBodyDataSqlList extends $dara.Model {
  /**
   * @remarks
   * The average CPU time.
   * 
   * @example
   * 100.24
   */
  avgCpuTime?: number;
  /**
   * @remarks
   * The average DB time.
   * 
   * @example
   * 100
   */
  avgDbTime?: number;
  /**
   * @remarks
   * The average response time.
   * 
   * @example
   * 100.28
   */
  avgElapsedTime?: number;
  /**
   * @remarks
   * The average plan generation time.
   * 
   * @example
   * 0
   */
  avgGetPlanTime?: number;
  /**
   * @remarks
   * The average number of logical reads.
   * 
   * @example
   * 25
   */
  avgLogicalReads?: number;
  /**
   * @remarks
   * The average number of retries.
   * 
   * @example
   * 4
   */
  avgRetryCount?: number;
  /**
   * @remarks
   * The total CPU time.
   * 
   * @example
   * 100.23
   */
  cpuTime?: number;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * test_hsp****eway
   */
  dbName?: string;
  /**
   * @remarks
   * The diagnostic types.
   */
  diagTypes?: string[];
  /**
   * @remarks
   * The diagnostic details. 
   * 
   * > This parameter is deprecated.
   * 
   * @example
   * -
   */
  diagnosis?: string;
  /**
   * @remarks
   * The total number of executions.
   * 
   * @example
   * 100
   */
  executions?: number;
  /**
   * @remarks
   * The last execution time.
   * 
   * @example
   * 2023-04-12T04:38:38Z
   */
  lastExecutedTime?: string;
  /**
   * @remarks
   * The risk level.
   * 
   * @example
   * LOW
   */
  riskLevel?: string;
  /**
   * @remarks
   * The ID of the SQL statement.
   * 
   * @example
   * 3A645****789F13DE0CF6D084FF9****
   */
  sqlId?: string;
  /**
   * @remarks
   * The prefix of the SQL text.
   * 
   * @example
   * select * from test
   */
  sqlTextShort?: string;
  /**
   * @remarks
   * The suggestion on the suspicious SQL statement.
   * 
   * @example
   * {\\"Role\\": \\"eSG\\", \\"Result\\": \\"100\\", \\"Suggestion\\": \\"TRACER_OTHER_ERR\\"}
   */
  suggestion?: string;
  /**
   * @remarks
   * The total DB time.
   * 
   * @example
   * 100
   */
  sumDbTime?: number;
  /**
   * @remarks
   * The total response time.
   * 
   * @example
   * 11452126.36
   */
  sumElapsedTime?: string;
  /**
   * @remarks
   * The total number of retries.
   * 
   * @example
   * 6
   */
  sumRetryCount?: number;
  /**
   * @remarks
   * The username.
   * 
   * @example
   * test_user
   */
  userName?: string;
  static names(): { [key: string]: string } {
    return {
      avgCpuTime: 'AvgCpuTime',
      avgDbTime: 'AvgDbTime',
      avgElapsedTime: 'AvgElapsedTime',
      avgGetPlanTime: 'AvgGetPlanTime',
      avgLogicalReads: 'AvgLogicalReads',
      avgRetryCount: 'AvgRetryCount',
      cpuTime: 'CpuTime',
      dbName: 'DbName',
      diagTypes: 'DiagTypes',
      diagnosis: 'Diagnosis',
      executions: 'Executions',
      lastExecutedTime: 'LastExecutedTime',
      riskLevel: 'RiskLevel',
      sqlId: 'SqlId',
      sqlTextShort: 'SqlTextShort',
      suggestion: 'Suggestion',
      sumDbTime: 'SumDbTime',
      sumElapsedTime: 'SumElapsedTime',
      sumRetryCount: 'SumRetryCount',
      userName: 'UserName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avgCpuTime: 'number',
      avgDbTime: 'number',
      avgElapsedTime: 'number',
      avgGetPlanTime: 'number',
      avgLogicalReads: 'number',
      avgRetryCount: 'number',
      cpuTime: 'number',
      dbName: 'string',
      diagTypes: { 'type': 'array', 'itemType': 'string' },
      diagnosis: 'string',
      executions: 'number',
      lastExecutedTime: 'string',
      riskLevel: 'string',
      sqlId: 'string',
      sqlTextShort: 'string',
      suggestion: 'string',
      sumDbTime: 'number',
      sumElapsedTime: 'string',
      sumRetryCount: 'number',
      userName: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.diagTypes)) {
      $dara.Model.validateArray(this.diagTypes);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOasAnomalySQLListResponseBodyData extends $dara.Model {
  /**
   * @remarks
   * Average CPU time of the suspicious SQL.
   * 
   * @example
   * 100.24
   */
  avgCpuTime?: number;
  /**
   * @remarks
   * The average DB time.
   * 
   * @example
   * 100
   */
  avgDbTime?: number;
  /**
   * @remarks
   * Average response time of the suspicious SQL.
   * 
   * @example
   * 100.28
   */
  avgElapsedTime?: number;
  /**
   * @remarks
   * Average time to obtain the execution plan of the suspicious SQL.
   * 
   * @example
   * 0
   */
  avgGetPlanTime?: number;
  /**
   * @remarks
   * The average number of logical reads.
   * 
   * @example
   * 25
   */
  avgLogicalReads?: number;
  /**
   * @remarks
   * The average number of retries.
   * 
   * @example
   * 4
   */
  avgRetryCount?: number;
  /**
   * @remarks
   * CPU time of the suspicious SQL.
   * 
   * @example
   * 100.23
   */
  cpuTime?: number;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * db_***
   */
  dbName?: string;
  /**
   * @remarks
   * The type of the diagnosis.
   */
  diagTypes?: string[];
  /**
   * @remarks
   * The details of diagnosis.
   * 
   * @example
   * -
   */
  diagnosis?: string;
  /**
   * @remarks
   * 是否动态SQL
   * 
   * @example
   * false
   */
  dynamicSql?: boolean;
  /**
   * @remarks
   * Total execution count of the suspicious SQL.
   * 
   * @example
   * 1
   */
  executions?: number;
  /**
   * @remarks
   * Last execution time of the suspicious SQL.
   * 
   * @example
   * 2023-04-12T04:38:38Z
   */
  lastExecutedTime?: number;
  /**
   * @remarks
   * Risk level.
   * 
   * @example
   * high
   */
  riskLevel?: string;
  /**
   * @remarks
   * SQL ID.
   * 
   * @example
   * 8D6E84****0B8FB1823D199E2CA1****
   */
  sqlId?: string;
  /**
   * @remarks
   * The list of SQL statements.
   */
  sqlList?: DescribeOasAnomalySQLListResponseBodyDataSqlList[];
  /**
   * @remarks
   * Prefix of the SQL text.
   */
  sqlTextShort?: string;
  /**
   * @remarks
   * Suggestion for the suspicious SQL.
   * 
   * @example
   * review
   */
  suggestion?: string;
  /**
   * @remarks
   * The total DB time.
   * 
   * @example
   * 100
   */
  sumDbTime?: number;
  /**
   * @remarks
   * Total response time of the suspicious SQL.
   * 
   * @example
   * 11452126.36
   */
  sumElapsedTime?: string;
  /**
   * @remarks
   * The total number of retries.
   * 
   * @example
   * 6
   */
  sumRetryCount?: number;
  /**
   * @remarks
   * Username.
   * 
   * @example
   * test_user
   */
  userName?: string;
  static names(): { [key: string]: string } {
    return {
      avgCpuTime: 'AvgCpuTime',
      avgDbTime: 'AvgDbTime',
      avgElapsedTime: 'AvgElapsedTime',
      avgGetPlanTime: 'AvgGetPlanTime',
      avgLogicalReads: 'AvgLogicalReads',
      avgRetryCount: 'AvgRetryCount',
      cpuTime: 'CpuTime',
      dbName: 'DbName',
      diagTypes: 'DiagTypes',
      diagnosis: 'Diagnosis',
      dynamicSql: 'DynamicSql',
      executions: 'Executions',
      lastExecutedTime: 'LastExecutedTime',
      riskLevel: 'RiskLevel',
      sqlId: 'SqlId',
      sqlList: 'SqlList',
      sqlTextShort: 'SqlTextShort',
      suggestion: 'Suggestion',
      sumDbTime: 'SumDbTime',
      sumElapsedTime: 'SumElapsedTime',
      sumRetryCount: 'SumRetryCount',
      userName: 'UserName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avgCpuTime: 'number',
      avgDbTime: 'number',
      avgElapsedTime: 'number',
      avgGetPlanTime: 'number',
      avgLogicalReads: 'number',
      avgRetryCount: 'number',
      cpuTime: 'number',
      dbName: 'string',
      diagTypes: { 'type': 'array', 'itemType': 'string' },
      diagnosis: 'string',
      dynamicSql: 'boolean',
      executions: 'number',
      lastExecutedTime: 'number',
      riskLevel: 'string',
      sqlId: 'string',
      sqlList: { 'type': 'array', 'itemType': DescribeOasAnomalySQLListResponseBodyDataSqlList },
      sqlTextShort: 'string',
      suggestion: 'string',
      sumDbTime: 'number',
      sumElapsedTime: 'string',
      sumRetryCount: 'number',
      userName: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.diagTypes)) {
      $dara.Model.validateArray(this.diagTypes);
    }
    if(Array.isArray(this.sqlList)) {
      $dara.Model.validateArray(this.sqlList);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOasSQLDetailsResponseBodyData extends $dara.Model {
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * test_db
   */
  dbName?: string;
  /**
   * @remarks
   * SQL text.
   * 
   * @example
   * select a from b
   */
  fulltext?: string;
  /**
   * @remarks
   * Parameterized text.
   * 
   * @example
   * select a from b
   */
  statement?: string;
  /**
   * @remarks
   * The table name related to the SQL.
   */
  tables?: string[];
  /**
   * @remarks
   * The username.
   * 
   * @example
   * test_user
   */
  userName?: string;
  static names(): { [key: string]: string } {
    return {
      dbName: 'DbName',
      fulltext: 'Fulltext',
      statement: 'Statement',
      tables: 'Tables',
      userName: 'UserName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbName: 'string',
      fulltext: 'string',
      statement: 'string',
      tables: { 'type': 'array', 'itemType': 'string' },
      userName: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.tables)) {
      $dara.Model.validateArray(this.tables);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOasSQLHistoryListResponseBodyData extends $dara.Model {
  /**
   * @remarks
   * Average updated rows during the execution period.
   * 
   * @example
   * 9978.75
   */
  avgAffectedRows?: number;
  /**
   * @remarks
   * Average Application event wait time (in milliseconds) during the client waiting period.
   * 
   * @example
   * 0.0
   */
  avgApplicationWaitTime?: number;
  /**
   * @remarks
   * Average BlockCache hit count during the execution period.
   * 
   * @example
   * 0.0
   */
  avgBlockCacheHit?: number;
  /**
   * @remarks
   * Average BlockIndexCache hit count during the execution period.
   * 
   * @example
   * 0.0
   */
  avgBlockIndexCacheHit?: number;
  /**
   * @remarks
   * Average BloomFilterCache hit count during the execution period.
   * 
   * @example
   * 0.0
   */
  avgBloomFilterCacheHit?: number;
  /**
   * @remarks
   * Average Concurrency event wait time (in milliseconds) during the execution period.
   * 
   * @example
   * 0.0
   */
  avgConcurrencyWaitTime?: number;
  /**
   * @remarks
   * Average CPU time (in milliseconds) during the execution period.
   * 
   * @example
   * 1875.34
   */
  avgCpuTime?: number;
  /**
   * @remarks
   * The average DB time, in milliseconds.
   * 
   * @example
   * 100
   */
  avgDbTime?: number;
  /**
   * @remarks
   * Average syntax parsing time (in milliseconds) during the execution period.
   * 
   * @example
   * 0.0
   */
  avgDecodeTime?: number;
  /**
   * @remarks
   * Average physical read count during the execution period.
   * 
   * @example
   * 0.0
   */
  avgDiskReads?: number;
  /**
   * @remarks
   * Average response time (in milliseconds) during the execution period.
   * 
   * @example
   * 1876.78
   */
  avgElapsedTime?: number;
  /**
   * @remarks
   * Average plan execution time (in milliseconds) during the execution period.
   * 
   * @example
   * 1895.7
   */
  avgExecuteTime?: number;
  /**
   * @remarks
   * Average number of RPC requests executed during the execution period.
   * 
   * @example
   * 0
   */
  avgExecutorRpcCount?: number;
  /**
   * @remarks
   * Average degree of parallelism during the execution period.
   * 
   * @example
   * 3
   */
  avgExpectedWorkerCount?: number;
  /**
   * @remarks
   * Average plan generation time (in milliseconds) during the execution period.
   * 
   * @example
   * 0.0
   */
  avgGetPlanTime?: number;
  /**
   * @remarks
   * Average logical reads during the execution period.
   * 
   * @example
   * 0.0
   */
  avgLogicalReads?: number;
  /**
   * @remarks
   * Average Memstore read rows during the execution period.
   * 
   * @example
   * 0.0
   */
  avgMemstoreReadRows?: number;
  /**
   * @remarks
   * Average network transmission time (in milliseconds) during the execution period.
   * 
   * @example
   * 8
   */
  avgNetTime?: number;
  /**
   * @remarks
   * Average network enqueue time (in milliseconds) during the network waiting period.
   * 
   * @example
   * 0.0
   */
  avgNetWaitTime?: number;
  /**
   * @remarks
   * Average number of partition accessed during the execution period.
   * 
   * @example
   * 1
   */
  avgPartitionCount?: number;
  /**
   * @remarks
   * Average queueing time (in milliseconds) during the execution period.
   * 
   * @example
   * 0.01
   */
  avgQueueTime?: number;
  /**
   * @remarks
   * Average number of rows returned during the execution period.
   * 
   * @example
   * 0.0
   */
  avgReturnRows?: number;
  /**
   * @remarks
   * Average RowCache hit count during the execution period.
   * 
   * @example
   * 0.0
   */
  avgRowCacheHit?: number;
  /**
   * @remarks
   * Average number of RPC sent during the execution.
   * 
   * @example
   * 8.0
   */
  avgRpcCount?: number;
  /**
   * @remarks
   * Average Schedule event wait time (in milliseconds) during the scheduling period.
   * 
   * @example
   * 0.0
   */
  avgScheduleTime?: number;
  /**
   * @remarks
   * Average Ssstore read rows during the execution period.
   * 
   * @example
   * 0.0
   */
  avgSsstoreReadRows?: number;
  /**
   * @remarks
   * Average number of threads used of the SQL during the execution period.
   * 
   * @example
   * 3
   */
  avgUsedWorkerCount?: number;
  /**
   * @remarks
   * Average UserIO event wait time (in milliseconds) during the execution period.
   * 
   * @example
   * 0.0
   */
  avgUserIoWaitTime?: number;
  /**
   * @remarks
   * Average number of waits during the execution period.
   * 
   * @example
   * 0
   */
  avgWaitCount?: number;
  /**
   * @remarks
   * Average wait time (in milliseconds) during the execution period.
   * 
   * @example
   * 1442.49
   */
  avgWaitTime?: number;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * test_db
   */
  dbName?: string;
  /**
   * @remarks
   * Distributed plan percentage during the execution period.
   * 
   * @example
   * 100
   */
  distPlanPercentage?: number;
  /**
   * @remarks
   * Average execution count per second during the execution period.
   * 
   * @example
   * 0.31
   */
  execPs?: number;
  /**
   * @remarks
   * Total number of executions during the execution period.
   * 
   * @example
   * 1
   */
  executions?: number;
  /**
   * @remarks
   * The total number of errors during the execution period.
   * 
   * @example
   * 0
   */
  failCount?: number;
  /**
   * @remarks
   * Error percentage during the execution period.
   * 
   * @example
   * 0
   */
  failPercentage?: number;
  /**
   * @remarks
   * Local plan percentage during the execution period.
   * 
   * @example
   * 0
   */
  localPlanPercentage?: number;
  /**
   * @remarks
   * Max updated rows during the execution period.
   * 
   * @example
   * 10000
   */
  maxAffectedRows?: number;
  /**
   * @remarks
   * Max Application event wait time (in milliseconds) during the execution period
   * 
   * @example
   * 0
   */
  maxApplicationWaitTime?: number;
  /**
   * @remarks
   * Max Concurrency event wait time (in milliseconds) during the execution period
   * 
   * @example
   * 0
   */
  maxConcurrencyWaitTime?: number;
  /**
   * @remarks
   * Max CPU time.
   * 
   * @example
   * 13641.9
   */
  maxCpuTime?: number;
  /**
   * @remarks
   * Max physical read count during the execution period.
   * 
   * @example
   * 0
   */
  maxDiskReads?: number;
  /**
   * @remarks
   * Max response time.
   * 
   * @example
   * 13643.3
   */
  maxElapsedTime?: number;
  /**
   * @remarks
   * Max returned rows during the execution period.
   * 
   * @example
   * 0
   */
  maxReturnRows?: number;
  /**
   * @remarks
   * Max UserIO event wait time (in milliseconds) during the execution period
   * 
   * @example
   * 0
   */
  maxUserIoWaitTime?: number;
  /**
   * @remarks
   * Max wait time (in milliseconds) during the execution period.
   * 
   * @example
   * 3.4
   */
  maxWaitTime?: number;
  /**
   * @remarks
   * Plan hit rage during the execution period.
   * 
   * @example
   * 0
   */
  missPlanPercentage?: number;
  /**
   * @remarks
   * Missed plan count.
   * 
   * @example
   * 0
   */
  missPlans?: number;
  /**
   * @remarks
   * Remote plan percentage during the execution period.
   * 
   * @example
   * 0
   */
  remotePlanPercentage?: number;
  /**
   * @remarks
   * Remote plan count.
   * 
   * @example
   * 0
   */
  remotePlans?: number;
  /**
   * @remarks
   * Number of occurrences of code 4012 during the execution period.
   * 
   * @example
   * 0
   */
  retCode4012Count?: number;
  /**
   * @remarks
   * Number of occurrences of code 4013 during the execution period.
   * 
   * @example
   * 0
   */
  retCode4013Count?: number;
  /**
   * @remarks
   * Number of occurrences of code 5001 during the execution period.
   * 
   * @example
   * 0
   */
  retCode5001Count?: number;
  /**
   * @remarks
   * Number of occurrences of code 5024 during the execution period.
   * 
   * @example
   * 0
   */
  retCode5024Count?: number;
  /**
   * @remarks
   * Number of occurrences of code 5167 during the execution period.
   * 
   * @example
   * 0
   */
  retCode5167Count?: number;
  /**
   * @remarks
   * Number of occurrences of code 5217 during the execution period.
   * 
   * @example
   * 0
   */
  retCode5217Count?: number;
  /**
   * @remarks
   * Number of occurrences of code 6002 during the execution period.
   * 
   * @example
   * 0
   */
  retCode6002Count?: number;
  /**
   * @remarks
   * Total number of retries during the execution period.
   * 
   * @example
   * 0
   */
  retryCount?: number;
  /**
   * @remarks
   * SQL ID.
   * 
   * @example
   * 8D6E84****0B8FB1823D199E2CA1****
   */
  SQLId?: string;
  /**
   * @remarks
   * The server where the SQL is executed.
   * 
   * @example
   * i-bp1db1****8uemejio
   */
  server?: string;
  /**
   * @remarks
   * Strong consistent transaction percentage during the execution period.
   * 
   * @example
   * 100
   */
  strongConsistencyPercentage?: number;
  /**
   * @remarks
   * The total DB time, in milliseconds.
   * 
   * @example
   * 100
   */
  sumDbTime?: number;
  /**
   * @remarks
   * Total response time (in milliseconds) during the execution period.
   * 
   * @example
   * 11452126.36
   */
  sumElapsedTime?: number;
  /**
   * @remarks
   * Total logical reads.
   * 
   * @example
   * 0
   */
  sumLogicalReads?: number;
  /**
   * @remarks
   * The total wait time (in milliseconds) during the internal waiting period.
   * 
   * @example
   * 9421.73
   */
  sumWaitTime?: number;
  /**
   * @remarks
   * Table scan percentage during the execution period.
   * 
   * @example
   * 0
   */
  tableScanPercentage?: number;
  /**
   * @remarks
   * Timestamp for the sample.
   * 
   * @example
   * 2023-04-12T04:46:38Z
   */
  timestamp?: string;
  /**
   * @remarks
   * Username.
   * 
   * @example
   * test_user
   */
  userName?: string;
  /**
   * @remarks
   * The wait event.
   * 
   * @example
   * none
   */
  waitEvent?: string;
  /**
   * @remarks
   * Eventually consistent transaction percentage during the execution period.
   * 
   * @example
   * 0
   */
  weakConsistencyPercentage?: number;
  static names(): { [key: string]: string } {
    return {
      avgAffectedRows: 'AvgAffectedRows',
      avgApplicationWaitTime: 'AvgApplicationWaitTime',
      avgBlockCacheHit: 'AvgBlockCacheHit',
      avgBlockIndexCacheHit: 'AvgBlockIndexCacheHit',
      avgBloomFilterCacheHit: 'AvgBloomFilterCacheHit',
      avgConcurrencyWaitTime: 'AvgConcurrencyWaitTime',
      avgCpuTime: 'AvgCpuTime',
      avgDbTime: 'AvgDbTime',
      avgDecodeTime: 'AvgDecodeTime',
      avgDiskReads: 'AvgDiskReads',
      avgElapsedTime: 'AvgElapsedTime',
      avgExecuteTime: 'AvgExecuteTime',
      avgExecutorRpcCount: 'AvgExecutorRpcCount',
      avgExpectedWorkerCount: 'AvgExpectedWorkerCount',
      avgGetPlanTime: 'AvgGetPlanTime',
      avgLogicalReads: 'AvgLogicalReads',
      avgMemstoreReadRows: 'AvgMemstoreReadRows',
      avgNetTime: 'AvgNetTime',
      avgNetWaitTime: 'AvgNetWaitTime',
      avgPartitionCount: 'AvgPartitionCount',
      avgQueueTime: 'AvgQueueTime',
      avgReturnRows: 'AvgReturnRows',
      avgRowCacheHit: 'AvgRowCacheHit',
      avgRpcCount: 'AvgRpcCount',
      avgScheduleTime: 'AvgScheduleTime',
      avgSsstoreReadRows: 'AvgSsstoreReadRows',
      avgUsedWorkerCount: 'AvgUsedWorkerCount',
      avgUserIoWaitTime: 'AvgUserIoWaitTime',
      avgWaitCount: 'AvgWaitCount',
      avgWaitTime: 'AvgWaitTime',
      dbName: 'DbName',
      distPlanPercentage: 'DistPlanPercentage',
      execPs: 'ExecPs',
      executions: 'Executions',
      failCount: 'FailCount',
      failPercentage: 'FailPercentage',
      localPlanPercentage: 'LocalPlanPercentage',
      maxAffectedRows: 'MaxAffectedRows',
      maxApplicationWaitTime: 'MaxApplicationWaitTime',
      maxConcurrencyWaitTime: 'MaxConcurrencyWaitTime',
      maxCpuTime: 'MaxCpuTime',
      maxDiskReads: 'MaxDiskReads',
      maxElapsedTime: 'MaxElapsedTime',
      maxReturnRows: 'MaxReturnRows',
      maxUserIoWaitTime: 'MaxUserIoWaitTime',
      maxWaitTime: 'MaxWaitTime',
      missPlanPercentage: 'MissPlanPercentage',
      missPlans: 'MissPlans',
      remotePlanPercentage: 'RemotePlanPercentage',
      remotePlans: 'RemotePlans',
      retCode4012Count: 'RetCode4012Count',
      retCode4013Count: 'RetCode4013Count',
      retCode5001Count: 'RetCode5001Count',
      retCode5024Count: 'RetCode5024Count',
      retCode5167Count: 'RetCode5167Count',
      retCode5217Count: 'RetCode5217Count',
      retCode6002Count: 'RetCode6002Count',
      retryCount: 'RetryCount',
      SQLId: 'SQLId',
      server: 'Server',
      strongConsistencyPercentage: 'StrongConsistencyPercentage',
      sumDbTime: 'SumDbTime',
      sumElapsedTime: 'SumElapsedTime',
      sumLogicalReads: 'SumLogicalReads',
      sumWaitTime: 'SumWaitTime',
      tableScanPercentage: 'TableScanPercentage',
      timestamp: 'Timestamp',
      userName: 'UserName',
      waitEvent: 'WaitEvent',
      weakConsistencyPercentage: 'WeakConsistencyPercentage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avgAffectedRows: 'number',
      avgApplicationWaitTime: 'number',
      avgBlockCacheHit: 'number',
      avgBlockIndexCacheHit: 'number',
      avgBloomFilterCacheHit: 'number',
      avgConcurrencyWaitTime: 'number',
      avgCpuTime: 'number',
      avgDbTime: 'number',
      avgDecodeTime: 'number',
      avgDiskReads: 'number',
      avgElapsedTime: 'number',
      avgExecuteTime: 'number',
      avgExecutorRpcCount: 'number',
      avgExpectedWorkerCount: 'number',
      avgGetPlanTime: 'number',
      avgLogicalReads: 'number',
      avgMemstoreReadRows: 'number',
      avgNetTime: 'number',
      avgNetWaitTime: 'number',
      avgPartitionCount: 'number',
      avgQueueTime: 'number',
      avgReturnRows: 'number',
      avgRowCacheHit: 'number',
      avgRpcCount: 'number',
      avgScheduleTime: 'number',
      avgSsstoreReadRows: 'number',
      avgUsedWorkerCount: 'number',
      avgUserIoWaitTime: 'number',
      avgWaitCount: 'number',
      avgWaitTime: 'number',
      dbName: 'string',
      distPlanPercentage: 'number',
      execPs: 'number',
      executions: 'number',
      failCount: 'number',
      failPercentage: 'number',
      localPlanPercentage: 'number',
      maxAffectedRows: 'number',
      maxApplicationWaitTime: 'number',
      maxConcurrencyWaitTime: 'number',
      maxCpuTime: 'number',
      maxDiskReads: 'number',
      maxElapsedTime: 'number',
      maxReturnRows: 'number',
      maxUserIoWaitTime: 'number',
      maxWaitTime: 'number',
      missPlanPercentage: 'number',
      missPlans: 'number',
      remotePlanPercentage: 'number',
      remotePlans: 'number',
      retCode4012Count: 'number',
      retCode4013Count: 'number',
      retCode5001Count: 'number',
      retCode5024Count: 'number',
      retCode5167Count: 'number',
      retCode5217Count: 'number',
      retCode6002Count: 'number',
      retryCount: 'number',
      SQLId: 'string',
      server: 'string',
      strongConsistencyPercentage: 'number',
      sumDbTime: 'number',
      sumElapsedTime: 'number',
      sumLogicalReads: 'number',
      sumWaitTime: 'number',
      tableScanPercentage: 'number',
      timestamp: 'string',
      userName: 'string',
      waitEvent: 'string',
      weakConsistencyPercentage: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOasSQLPlansResponseBodyDataPlanExplain extends $dara.Model {
  /**
   * @remarks
   * JSON string of the SQL execution plan.
   * 
   * @example
   * {\\"RootOperations\\":[{\\"Children\\
   */
  planJsonString?: string;
  static names(): { [key: string]: string } {
    return {
      planJsonString: 'PlanJsonString',
    };
  }

  static types(): { [key: string]: any } {
    return {
      planJsonString: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOasSQLPlansResponseBodyDataPlans extends $dara.Model {
  /**
   * @remarks
   * Average Application event waiting time (in milliseconds) during the execution period.
   * 
   * @example
   * 0.0
   */
  avgApplicationWaitTime?: number;
  /**
   * @remarks
   * Average cache read count during the execution period.
   * 
   * @example
   * 30137.03
   */
  avgBufferGets?: number;
  /**
   * @remarks
   * Average Concurrency event waiting time (in milliseconds) during the execution period.
   * 
   * @example
   * 0.0
   */
  avgConcurrencyWaitTime?: number;
  /**
   * @remarks
   * Average CPU time (in milliseconds) during the execution period.
   * 
   * @example
   * 1875.34
   */
  avgCpuTime?: number;
  /**
   * @remarks
   * The average physical read count during the execution period.
   * 
   * @example
   * 0.0
   */
  avgDiskReads?: number;
  /**
   * @remarks
   * The average physical write count during the execution period.
   * 
   * @example
   * 0.0
   */
  avgDiskWrites?: number;
  /**
   * @remarks
   * Average interval waiting time (in milliseconds) during the execution period.
   * 
   * @example
   * 1876.78
   */
  avgElapsedTime?: number;
  /**
   * @remarks
   * Average row processing waiting time (in milliseconds) during the execution period.
   * 
   * @example
   * 1.0
   */
  avgRowProcessed?: number;
  /**
   * @remarks
   * Average UserIo event waiting time (in milliseconds) during the execution period.
   * 
   * @example
   * 0.0
   */
  avgUserIoWaitTime?: number;
  /**
   * @remarks
   * Collection time.
   * 
   * @example
   * 1684368****00000
   */
  collectTimeUs?: number;
  /**
   * @remarks
   * Percentage of delayed long-running queries.
   * 
   * @example
   * 0.0
   */
  delayedLargeQueryPercentage?: number;
  /**
   * @remarks
   * The average execution count per second during the execution period.
   * 
   * @example
   * 0.31
   */
  execPs?: number;
  /**
   * @remarks
   * The total number of executions during the execution period.
   * 
   * @example
   * 1
   */
  executions?: number;
  /**
   * @remarks
   * First time to load the plan.
   * 
   * @example
   * 2023-04-12T04:46:38Z
   */
  firstLoadTime?: string;
  /**
   * @remarks
   * First loading time.
   * 
   * @example
   * 1684****03289441
   */
  firstLoadTimeUs?: number;
  /**
   * @remarks
   * Whether to hit the diagnosis.
   * 
   * @example
   * false
   */
  hitDiagnosis?: boolean;
  /**
   * @remarks
   * Hit rate.
   * 
   * @example
   * 100.0
   */
  hitPercentage?: number;
  /**
   * @remarks
   * Percentage of completed long-running queries.
   * 
   * @example
   * 0.0
   */
  largeQueryPercentage?: number;
  /**
   * @remarks
   * Merge version.
   * 
   * @example
   * 513
   */
  mergedVersion?: number;
  /**
   * @remarks
   * Database ID.
   * 
   * @example
   * 11006****828
   */
  obDbId?: number;
  /**
   * @remarks
   * Server ID.
   * 
   * @example
   * 2
   */
  obServerId?: number;
  /**
   * @remarks
   * The outline_data parameter of the SQL execution plan.
   * 
   * @example
   * /*+ BEGIN_OUTLINE_DATA INDEX(@\\"SEL$1\\
   */
  outlineData?: string;
  /**
   * @remarks
   * Outline ID.
   * 
   * @example
   * -1
   */
  outlineId?: number;
  /**
   * @remarks
   * The internal identifier of the SQL execution plan in the diagnostic system.
   * 
   * @example
   * -86290582****886880
   */
  planHash?: string;
  /**
   * @remarks
   * The ID of the plan.
   * 
   * @example
   * 590****
   */
  planId?: number;
  /**
   * @remarks
   * Plan size.
   * 
   * @example
   * 10****
   */
  planSize?: number;
  /**
   * @remarks
   * Plan type, including LOCAL, REMOTE, DIST.
   * 
   * @example
   * LOCAL
   */
  planType?: string;
  /**
   * @remarks
   * The internal unique identifier of the SQL execution plan in the diagnostic system.
   * 
   * @example
   * "52c7c53****53e61b3f7586b17****ad"
   */
  planUnionHash?: string;
  /**
   * @remarks
   * Schema version.
   * 
   * @example
   * 16838****3550464
   */
  schemaVersion?: number;
  /**
   * @remarks
   * The server where the SQL is executed.
   * 
   * @example
   * i-bp1db1a9us038****jio
   */
  server?: string;
  /**
   * @remarks
   * The ID of the backend server instance.
   * 
   * @example
   * 2
   */
  serverId?: number;
  /**
   * @remarks
   * SQL ID.
   * 
   * @example
   * 46939C87ECA****95ED0FF64F44B****
   */
  sqlId?: string;
  /**
   * @remarks
   * Whether a full table scan is performed.
   * 
   * @example
   * false
   */
  tableScan?: boolean;
  /**
   * @remarks
   * Percentage of timeouts.
   * 
   * @example
   * 0.0
   */
  timeoutPercentage?: number;
  /**
   * @remarks
   * The unique identifier of the plan.
   * 
   * @example
   * AAAAAAAAAAI****AAFoT2QAF--7W****
   */
  uid?: string;
  static names(): { [key: string]: string } {
    return {
      avgApplicationWaitTime: 'AvgApplicationWaitTime',
      avgBufferGets: 'AvgBufferGets',
      avgConcurrencyWaitTime: 'AvgConcurrencyWaitTime',
      avgCpuTime: 'AvgCpuTime',
      avgDiskReads: 'AvgDiskReads',
      avgDiskWrites: 'AvgDiskWrites',
      avgElapsedTime: 'AvgElapsedTime',
      avgRowProcessed: 'AvgRowProcessed',
      avgUserIoWaitTime: 'AvgUserIoWaitTime',
      collectTimeUs: 'CollectTimeUs',
      delayedLargeQueryPercentage: 'DelayedLargeQueryPercentage',
      execPs: 'ExecPs',
      executions: 'Executions',
      firstLoadTime: 'FirstLoadTime',
      firstLoadTimeUs: 'FirstLoadTimeUs',
      hitDiagnosis: 'HitDiagnosis',
      hitPercentage: 'HitPercentage',
      largeQueryPercentage: 'LargeQueryPercentage',
      mergedVersion: 'MergedVersion',
      obDbId: 'ObDbId',
      obServerId: 'ObServerId',
      outlineData: 'OutlineData',
      outlineId: 'OutlineId',
      planHash: 'PlanHash',
      planId: 'PlanId',
      planSize: 'PlanSize',
      planType: 'PlanType',
      planUnionHash: 'PlanUnionHash',
      schemaVersion: 'SchemaVersion',
      server: 'Server',
      serverId: 'ServerId',
      sqlId: 'SqlId',
      tableScan: 'TableScan',
      timeoutPercentage: 'TimeoutPercentage',
      uid: 'Uid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avgApplicationWaitTime: 'number',
      avgBufferGets: 'number',
      avgConcurrencyWaitTime: 'number',
      avgCpuTime: 'number',
      avgDiskReads: 'number',
      avgDiskWrites: 'number',
      avgElapsedTime: 'number',
      avgRowProcessed: 'number',
      avgUserIoWaitTime: 'number',
      collectTimeUs: 'number',
      delayedLargeQueryPercentage: 'number',
      execPs: 'number',
      executions: 'number',
      firstLoadTime: 'string',
      firstLoadTimeUs: 'number',
      hitDiagnosis: 'boolean',
      hitPercentage: 'number',
      largeQueryPercentage: 'number',
      mergedVersion: 'number',
      obDbId: 'number',
      obServerId: 'number',
      outlineData: 'string',
      outlineId: 'number',
      planHash: 'string',
      planId: 'number',
      planSize: 'number',
      planType: 'string',
      planUnionHash: 'string',
      schemaVersion: 'number',
      server: 'string',
      serverId: 'number',
      sqlId: 'string',
      tableScan: 'boolean',
      timeoutPercentage: 'number',
      uid: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOasSQLPlansResponseBodyData extends $dara.Model {
  /**
   * @remarks
   * Average CPU time (in milliseconds) during the execution period.
   * 
   * @example
   * 1875.34
   */
  avgCpuTime?: number;
  /**
   * @remarks
   * Whether to bind the execution plan.
   * 
   * @example
   * false
   */
  bounded?: boolean;
  /**
   * @remarks
   * Execution count.
   * 
   * @example
   * 1
   */
  executions?: number;
  /**
   * @remarks
   * First loading time.
   * 
   * @example
   * 2023-04-12T04:46:38Z
   */
  firstLoadTime?: string;
  /**
   * @remarks
   * Whether to hit the diagnosis.
   * 
   * @example
   * false
   */
  hitDiagnosis?: boolean;
  /**
   * @remarks
   * Hit rate.
   * 
   * @example
   * 100.0
   */
  hitPercentage?: number;
  /**
   * @remarks
   * Merge version.
   * 
   * @example
   * 513
   */
  mergedVersion?: number;
  /**
   * @remarks
   * The ID of the outline used by the execution plan.
   * 
   * @example
   * 3********
   */
  outlineId?: string;
  /**
   * @remarks
   * The outline status of the execution plan. Valid values:
   * * **Effective**: indicates that the outline_data and outlIne_content fields exactly match with each other. 
   * * **Unknown**: indicates that the outline status is unknown.
   * 
   * @example
   * Effective
   */
  outlineStatus?: string;
  /**
   * @remarks
   * Execution plan.
   */
  planExplain?: DescribeOasSQLPlansResponseBodyDataPlanExplain;
  /**
   * @remarks
   * The internal identifier of the SQL execution plan in the diagnostic system.
   * 
   * @example
   * 1758****24913166****
   */
  planHash?: string;
  /**
   * @remarks
   * Execution plan type.
   * 
   * @example
   * LOCAL
   */
  planType?: string;
  /**
   * @remarks
   * The internal unique identifier of the SQL execution plan in the diagnostic system.
   * 
   * @example
   * "52c7c53****53e61b3f7586b17****ad"
   */
  planUnionHash?: string;
  /**
   * @remarks
   * The list of the execution plan.
   */
  plans?: DescribeOasSQLPlansResponseBodyDataPlans[];
  /**
   * @remarks
   * The SQL for the query.
   * 
   * @example
   * "select 1 from t"
   */
  querySql?: string;
  /**
   * @remarks
   * Indicates whether full table scan is performed.
   * 
   * @example
   * false
   */
  tableScan?: boolean;
  static names(): { [key: string]: string } {
    return {
      avgCpuTime: 'AvgCpuTime',
      bounded: 'Bounded',
      executions: 'Executions',
      firstLoadTime: 'FirstLoadTime',
      hitDiagnosis: 'HitDiagnosis',
      hitPercentage: 'HitPercentage',
      mergedVersion: 'MergedVersion',
      outlineId: 'OutlineId',
      outlineStatus: 'OutlineStatus',
      planExplain: 'PlanExplain',
      planHash: 'PlanHash',
      planType: 'PlanType',
      planUnionHash: 'PlanUnionHash',
      plans: 'Plans',
      querySql: 'QuerySql',
      tableScan: 'TableScan',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avgCpuTime: 'number',
      bounded: 'boolean',
      executions: 'number',
      firstLoadTime: 'string',
      hitDiagnosis: 'boolean',
      hitPercentage: 'number',
      mergedVersion: 'number',
      outlineId: 'string',
      outlineStatus: 'string',
      planExplain: DescribeOasSQLPlansResponseBodyDataPlanExplain,
      planHash: 'string',
      planType: 'string',
      planUnionHash: 'string',
      plans: { 'type': 'array', 'itemType': DescribeOasSQLPlansResponseBodyDataPlans },
      querySql: 'string',
      tableScan: 'boolean',
    };
  }

  validate() {
    if(this.planExplain && typeof (this.planExplain as any).validate === 'function') {
      (this.planExplain as any).validate();
    }
    if(Array.isArray(this.plans)) {
      $dara.Model.validateArray(this.plans);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOasSlowSQLListResponseBodyDataSqlList extends $dara.Model {
  avgAffectedRows?: number;
  avgApplicationWaitTime?: number;
  avgBlockCacheHit?: number;
  avgBlockIndexCacheHit?: number;
  avgBloomFilterCacheHit?: number;
  avgConcurrencyWaitTime?: number;
  avgCpuTime?: number;
  avgDbTime?: number;
  avgDecodeTime?: number;
  avgDiskReads?: number;
  avgElapsedTime?: number;
  avgExecuteTime?: number;
  avgExecutorRpcCount?: number;
  avgExpectedWorkerCount?: number;
  avgGetPlanTime?: number;
  avgLogicalReads?: number;
  avgMemstoreReadRows?: number;
  avgNetTime?: number;
  avgNetWaitTime?: number;
  avgPartitionCount?: number;
  avgQueueTime?: number;
  avgReturnRows?: number;
  avgRowCacheHit?: number;
  avgRpcCount?: number;
  avgScheduleTime?: number;
  avgSsstoreReadRows?: number;
  avgUsedWorkerCount?: number;
  avgUserIoWaitTime?: number;
  avgWaitCount?: number;
  avgWaitTime?: number;
  clientIp?: string;
  dbName?: string;
  distPlanPercentage?: number;
  execPs?: number;
  executions?: number;
  failCount?: number;
  failPercentage?: number;
  inner?: boolean;
  localPlanPercentage?: number;
  maxAffectedRows?: number;
  maxApplicationWaitTime?: number;
  maxConcurrencyWaitTime?: number;
  maxCpuTime?: number;
  maxDiskReads?: number;
  maxElapsedTime?: number;
  maxReturnRows?: number;
  maxUserIoWaitTime?: number;
  maxWaitTime?: number;
  missPlanPercentage?: number;
  missPlans?: number;
  remotePlanPercentage?: number;
  remotePlans?: number;
  retCode4012Count?: number;
  retCode4013Count?: number;
  retCode5001Count?: number;
  retCode5024Count?: number;
  retCode5167Count?: number;
  retCode5217Count?: number;
  retCode6002Count?: number;
  retryCount?: number;
  rpcCount?: number;
  server?: string;
  serverIp?: string;
  serverPort?: number;
  sqlId?: string;
  sqlTextShort?: string;
  sqlType?: string;
  strongConsistencyPercentage?: number;
  sumDbTime?: number;
  sumElapsedTime?: number;
  sumLogicalReads?: number;
  sumWaitTime?: number;
  tableScanPercentage?: number;
  totalWaitTime?: number;
  userName?: string;
  waitEvent?: string;
  weakConsistencyPercentage?: number;
  static names(): { [key: string]: string } {
    return {
      avgAffectedRows: 'AvgAffectedRows',
      avgApplicationWaitTime: 'AvgApplicationWaitTime',
      avgBlockCacheHit: 'AvgBlockCacheHit',
      avgBlockIndexCacheHit: 'AvgBlockIndexCacheHit',
      avgBloomFilterCacheHit: 'AvgBloomFilterCacheHit',
      avgConcurrencyWaitTime: 'AvgConcurrencyWaitTime',
      avgCpuTime: 'AvgCpuTime',
      avgDbTime: 'AvgDbTime',
      avgDecodeTime: 'AvgDecodeTime',
      avgDiskReads: 'AvgDiskReads',
      avgElapsedTime: 'AvgElapsedTime',
      avgExecuteTime: 'AvgExecuteTime',
      avgExecutorRpcCount: 'AvgExecutorRpcCount',
      avgExpectedWorkerCount: 'AvgExpectedWorkerCount',
      avgGetPlanTime: 'AvgGetPlanTime',
      avgLogicalReads: 'AvgLogicalReads',
      avgMemstoreReadRows: 'AvgMemstoreReadRows',
      avgNetTime: 'AvgNetTime',
      avgNetWaitTime: 'AvgNetWaitTime',
      avgPartitionCount: 'AvgPartitionCount',
      avgQueueTime: 'AvgQueueTime',
      avgReturnRows: 'AvgReturnRows',
      avgRowCacheHit: 'AvgRowCacheHit',
      avgRpcCount: 'AvgRpcCount',
      avgScheduleTime: 'AvgScheduleTime',
      avgSsstoreReadRows: 'AvgSsstoreReadRows',
      avgUsedWorkerCount: 'AvgUsedWorkerCount',
      avgUserIoWaitTime: 'AvgUserIoWaitTime',
      avgWaitCount: 'AvgWaitCount',
      avgWaitTime: 'AvgWaitTime',
      clientIp: 'ClientIp',
      dbName: 'DbName',
      distPlanPercentage: 'DistPlanPercentage',
      execPs: 'ExecPs',
      executions: 'Executions',
      failCount: 'FailCount',
      failPercentage: 'FailPercentage',
      inner: 'Inner',
      localPlanPercentage: 'LocalPlanPercentage',
      maxAffectedRows: 'MaxAffectedRows',
      maxApplicationWaitTime: 'MaxApplicationWaitTime',
      maxConcurrencyWaitTime: 'MaxConcurrencyWaitTime',
      maxCpuTime: 'MaxCpuTime',
      maxDiskReads: 'MaxDiskReads',
      maxElapsedTime: 'MaxElapsedTime',
      maxReturnRows: 'MaxReturnRows',
      maxUserIoWaitTime: 'MaxUserIoWaitTime',
      maxWaitTime: 'MaxWaitTime',
      missPlanPercentage: 'MissPlanPercentage',
      missPlans: 'MissPlans',
      remotePlanPercentage: 'RemotePlanPercentage',
      remotePlans: 'RemotePlans',
      retCode4012Count: 'RetCode4012Count',
      retCode4013Count: 'RetCode4013Count',
      retCode5001Count: 'RetCode5001Count',
      retCode5024Count: 'RetCode5024Count',
      retCode5167Count: 'RetCode5167Count',
      retCode5217Count: 'RetCode5217Count',
      retCode6002Count: 'RetCode6002Count',
      retryCount: 'RetryCount',
      rpcCount: 'RpcCount',
      server: 'Server',
      serverIp: 'ServerIp',
      serverPort: 'ServerPort',
      sqlId: 'SqlId',
      sqlTextShort: 'SqlTextShort',
      sqlType: 'SqlType',
      strongConsistencyPercentage: 'StrongConsistencyPercentage',
      sumDbTime: 'SumDbTime',
      sumElapsedTime: 'SumElapsedTime',
      sumLogicalReads: 'SumLogicalReads',
      sumWaitTime: 'SumWaitTime',
      tableScanPercentage: 'TableScanPercentage',
      totalWaitTime: 'TotalWaitTime',
      userName: 'UserName',
      waitEvent: 'WaitEvent',
      weakConsistencyPercentage: 'WeakConsistencyPercentage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avgAffectedRows: 'number',
      avgApplicationWaitTime: 'number',
      avgBlockCacheHit: 'number',
      avgBlockIndexCacheHit: 'number',
      avgBloomFilterCacheHit: 'number',
      avgConcurrencyWaitTime: 'number',
      avgCpuTime: 'number',
      avgDbTime: 'number',
      avgDecodeTime: 'number',
      avgDiskReads: 'number',
      avgElapsedTime: 'number',
      avgExecuteTime: 'number',
      avgExecutorRpcCount: 'number',
      avgExpectedWorkerCount: 'number',
      avgGetPlanTime: 'number',
      avgLogicalReads: 'number',
      avgMemstoreReadRows: 'number',
      avgNetTime: 'number',
      avgNetWaitTime: 'number',
      avgPartitionCount: 'number',
      avgQueueTime: 'number',
      avgReturnRows: 'number',
      avgRowCacheHit: 'number',
      avgRpcCount: 'number',
      avgScheduleTime: 'number',
      avgSsstoreReadRows: 'number',
      avgUsedWorkerCount: 'number',
      avgUserIoWaitTime: 'number',
      avgWaitCount: 'number',
      avgWaitTime: 'number',
      clientIp: 'string',
      dbName: 'string',
      distPlanPercentage: 'number',
      execPs: 'number',
      executions: 'number',
      failCount: 'number',
      failPercentage: 'number',
      inner: 'boolean',
      localPlanPercentage: 'number',
      maxAffectedRows: 'number',
      maxApplicationWaitTime: 'number',
      maxConcurrencyWaitTime: 'number',
      maxCpuTime: 'number',
      maxDiskReads: 'number',
      maxElapsedTime: 'number',
      maxReturnRows: 'number',
      maxUserIoWaitTime: 'number',
      maxWaitTime: 'number',
      missPlanPercentage: 'number',
      missPlans: 'number',
      remotePlanPercentage: 'number',
      remotePlans: 'number',
      retCode4012Count: 'number',
      retCode4013Count: 'number',
      retCode5001Count: 'number',
      retCode5024Count: 'number',
      retCode5167Count: 'number',
      retCode5217Count: 'number',
      retCode6002Count: 'number',
      retryCount: 'number',
      rpcCount: 'number',
      server: 'string',
      serverIp: 'string',
      serverPort: 'number',
      sqlId: 'string',
      sqlTextShort: 'string',
      sqlType: 'string',
      strongConsistencyPercentage: 'number',
      sumDbTime: 'number',
      sumElapsedTime: 'number',
      sumLogicalReads: 'number',
      sumWaitTime: 'number',
      tableScanPercentage: 'number',
      totalWaitTime: 'number',
      userName: 'string',
      waitEvent: 'string',
      weakConsistencyPercentage: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOasSlowSQLListResponseBodyData extends $dara.Model {
  /**
   * @remarks
   * Average updated rows during the execution period.
   * 
   * @example
   * 9978.75
   */
  avgAffectedRows?: number;
  /**
   * @remarks
   * Average Application event wait time (in milliseconds) during the client waiting period.
   * 
   * @example
   * 0.0
   */
  avgApplicationWaitTime?: number;
  /**
   * @remarks
   * Average BlockCache hit count during the execution period.
   * 
   * @example
   * 0.0
   */
  avgBlockCacheHit?: number;
  /**
   * @remarks
   * Average BlockIndexCache hit count during the execution period.
   * 
   * @example
   * 0.0
   */
  avgBlockIndexCacheHit?: number;
  /**
   * @remarks
   * Average BloomFilterCache hit count during the execution period.
   * 
   * @example
   * 0.0
   */
  avgBloomFilterCacheHit?: number;
  /**
   * @remarks
   * Average Concurrency event wait time (in milliseconds) during the execution period.
   * 
   * @example
   * 0.0
   */
  avgConcurrencyWaitTime?: number;
  /**
   * @remarks
   * Average CPU time (in milliseconds) during the execution period.
   * 
   * @example
   * 1875.34
   */
  avgCpuTime?: number;
  avgDbTime?: number;
  /**
   * @remarks
   * Average syntax parsing time (in milliseconds) during the execution period.
   * 
   * @example
   * 0.0
   */
  avgDecodeTime?: number;
  /**
   * @remarks
   * Average physical read count during the execution period.
   * 
   * @example
   * 0.0
   */
  avgDiskReads?: number;
  /**
   * @remarks
   * Average response time (in milliseconds) during the execution period.
   * 
   * @example
   * 1876.78
   */
  avgElapsedTime?: number;
  /**
   * @remarks
   * Average plan execution time (in milliseconds) during the execution period.
   * 
   * @example
   * 1895.7
   */
  avgExecuteTime?: number;
  /**
   * @remarks
   * Average number of RPC requests executed during the execution period.
   * 
   * @example
   * 0.0
   */
  avgExecutorRpcCount?: number;
  /**
   * @remarks
   * Average degree of parallelism during the execution period.
   * 
   * @example
   * 3
   */
  avgExpectedWorkerCount?: number;
  /**
   * @remarks
   * Average plan generation time (in milliseconds) during the execution period.
   * 
   * @example
   * 0.0
   */
  avgGetPlanTime?: number;
  /**
   * @remarks
   * Average logical reads of the SQL during the execution period.
   * 
   * @example
   * 0.0
   */
  avgLogicalReads?: number;
  /**
   * @remarks
   * Strong consistent transaction percentage during the execution period.
   * 
   * @example
   * 0.0
   */
  avgMemstoreReadRows?: number;
  /**
   * @remarks
   * Average network transmission time (in milliseconds) during the execution period.
   * 
   * @example
   * 0.0
   */
  avgNetTime?: number;
  /**
   * @remarks
   * Average network enqueue time (in milliseconds) during the network waiting period.
   * 
   * @example
   * 0.0
   */
  avgNetWaitTime?: number;
  /**
   * @remarks
   * Average number of partition accessed during the execution period.
   * 
   * @example
   * 1.0
   */
  avgPartitionCount?: number;
  /**
   * @remarks
   * Average queueing time (in milliseconds) during the execution period.
   * 
   * @example
   * 0.01
   */
  avgQueueTime?: number;
  /**
   * @remarks
   * Average number of rows returned during the execution period.
   * 
   * @example
   * 0.0
   */
  avgReturnRows?: number;
  /**
   * @remarks
   * Average RowCache hit count during the execution period.
   * 
   * @example
   * 0.0
   */
  avgRowCacheHit?: number;
  /**
   * @remarks
   * Average number of RPC sent during the execution.
   * 
   * @example
   * 8.0
   */
  avgRpcCount?: number;
  /**
   * @remarks
   * Average Schedule event wait time (in milliseconds) during the scheduling period.
   * 
   * @example
   * 0.0
   */
  avgScheduleTime?: number;
  /**
   * @remarks
   * Eventually consistent transaction percentage during the execution period.
   * 
   * @example
   * 0.0
   */
  avgSsstoreReadRows?: number;
  /**
   * @remarks
   * Average number of threads used of the SQL during the execution period.
   * 
   * @example
   * 3
   */
  avgUsedWorkerCount?: number;
  /**
   * @remarks
   * Average UserIO event wait time (in milliseconds) during the execution period.
   * 
   * @example
   * 0.0
   */
  avgUserIoWaitTime?: number;
  /**
   * @remarks
   * Average number of waits during the execution period.
   * 
   * @example
   * 0.0
   */
  avgWaitCount?: number;
  /**
   * @remarks
   * Average wait time (in milliseconds) during the execution period.
   * 
   * @example
   * 1.42
   */
  avgWaitTime?: number;
  /**
   * @remarks
   * Client IP.
   * 
   * @example
   * 1*2.***.1*3.***
   */
  clientIp?: string;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * test_db
   */
  dbName?: string;
  /**
   * @remarks
   * Distributed plan percentage during the execution period.
   * 
   * @example
   * 100.0
   */
  distPlanPercentage?: number;
  dynamicSql?: boolean;
  /**
   * @remarks
   * Average execution count per second during the execution period.
   * 
   * @example
   * 0.31
   */
  execPs?: number;
  /**
   * @remarks
   * Total number of executions during the execution period.
   * 
   * @example
   * 1
   */
  executions?: number;
  /**
   * @remarks
   * Average number of partition accessed during the execution period.
   * 
   * @example
   * 0
   */
  failCount?: number;
  /**
   * @remarks
   * Error percentage during the execution period.
   * 
   * @example
   * 0.0
   */
  failPercentage?: number;
  /**
   * @remarks
   * Whether an internal SQL.
   * 
   * @example
   * false
   */
  inner?: boolean;
  /**
   * @remarks
   * Local plan percentage during the execution period.
   * 
   * @example
   * 0.0
   */
  localPlanPercentage?: number;
  /**
   * @remarks
   * Max affected rows during the execution period.
   * 
   * @example
   * 10000.0
   */
  maxAffectedRows?: number;
  /**
   * @remarks
   * Max Application event wait time (in milliseconds) during the execution period
   * 
   * @example
   * 0.0
   */
  maxApplicationWaitTime?: number;
  /**
   * @remarks
   * Max Concurrency event wait time (in milliseconds) during the execution period
   * 
   * @example
   * 0.0
   */
  maxConcurrencyWaitTime?: number;
  /**
   * @remarks
   * Max CPU time.
   * 
   * @example
   * 257.967
   */
  maxCpuTime?: number;
  /**
   * @remarks
   * Max physical read count during the execution period.
   * 
   * @example
   * 0.0
   */
  maxDiskReads?: number;
  /**
   * @remarks
   * Max response time during the execution period.
   * 
   * @example
   * 260.044
   */
  maxElapsedTime?: number;
  /**
   * @remarks
   * Max returned rows during the execution period.
   * 
   * @example
   * 0.0
   */
  maxReturnRows?: number;
  /**
   * @remarks
   * Max UserIO event wait time (in milliseconds) during the execution period.
   * 
   * @example
   * 0.0
   */
  maxUserIoWaitTime?: number;
  /**
   * @remarks
   * Max wait time (in milliseconds) during the execution period.
   * 
   * @example
   * 3.4
   */
  maxWaitTime?: number;
  /**
   * @remarks
   * Plan hit rage during the execution period.
   * 
   * @example
   * 0.0
   */
  missPlanPercentage?: number;
  /**
   * @remarks
   * Missed hit count of the execution plan during the execution period.
   * 
   * @example
   * 0
   */
  missPlans?: number;
  /**
   * @remarks
   * Remote plan percentage during the execution period.
   * 
   * @example
   * 0.0
   */
  remotePlanPercentage?: number;
  /**
   * @remarks
   * Remote execution count during the execution period.
   * 
   * @example
   * 0
   */
  remotePlans?: number;
  /**
   * @remarks
   * Number of occurrences of code 4012 during the execution period.
   * 
   * @example
   * 0
   */
  retCode4012Count?: number;
  /**
   * @remarks
   * Number of occurrences of code 4013 during the execution period.
   * 
   * @example
   * 0
   */
  retCode4013Count?: number;
  /**
   * @remarks
   * Number of occurrences of code 5001 during the execution period.
   * 
   * @example
   * 0
   */
  retCode5001Count?: number;
  /**
   * @remarks
   * Number of occurrences of code 5024 during the execution period.
   * 
   * @example
   * 0
   */
  retCode5024Count?: number;
  /**
   * @remarks
   * Number of occurrences of code 5167 during the execution period.
   * 
   * @example
   * 0
   */
  retCode5167Count?: number;
  /**
   * @remarks
   * Number of occurrences of code 5217 during the execution period.
   * 
   * @example
   * 0
   */
  retCode5217Count?: number;
  /**
   * @remarks
   * Number of occurrences of code 6002 during the execution period.
   * 
   * @example
   * 0
   */
  retCode6002Count?: number;
  /**
   * @remarks
   * Total number of retries during the execution period.
   * 
   * @example
   * 5
   */
  retryCount?: number;
  /**
   * @remarks
   * RPC count during the execution period.
   * 
   * @example
   * 0
   */
  rpcCount?: number;
  /**
   * @remarks
   * The server where the SQL is executed.
   * 
   * @example
   * i-bp1db1a**s038**mej**
   */
  server?: string;
  /**
   * @remarks
   * The IP address of the server.
   * 
   * @example
   * i-bp1db1a**s038**mej**
   */
  serverIp?: string;
  /**
   * @remarks
   * The server port where the SQL is executed.
   * 
   * @example
   * 10110
   */
  serverPort?: number;
  /**
   * @remarks
   * SQL ID.
   * 
   * @example
   * 8D6E84****0B8FB1823D199E2CA1****
   */
  sqlId?: string;
  sqlList?: DescribeOasSlowSQLListResponseBodyDataSqlList[];
  /**
   * @remarks
   * SQL text (the first 100 characters).
   * 
   * @example
   * select a from b where
   */
  sqlTextShort?: string;
  /**
   * @remarks
   * SQL type.
   * 
   * @example
   * select
   */
  sqlType?: string;
  /**
   * @remarks
   * Strong consistent transaction percentage during the execution period.
   * 
   * @example
   * 100.0
   */
  strongConsistencyPercentage?: number;
  sumDbTime?: number;
  /**
   * @remarks
   * Total response time (in milliseconds) during the execution period.
   * 
   * @example
   * 11452126.36
   */
  sumElapsedTime?: number;
  /**
   * @remarks
   * Total logical reads of the SQL during the execution period.
   * 
   * @example
   * 0.0
   */
  sumLogicalReads?: number;
  /**
   * @remarks
   * The total wait time (in milliseconds) during the internal waiting period.
   * 
   * @example
   * 9421.73
   */
  sumWaitTime?: number;
  /**
   * @remarks
   * Table scan percentage during the execution period.
   * 
   * @example
   * 0.0
   */
  tableScanPercentage?: number;
  /**
   * @remarks
   * Total wait time during the execution period.
   * 
   * @example
   * 10.966
   */
  totalWaitTime?: number;
  /**
   * @remarks
   * Username.
   * 
   * @example
   * test_user
   */
  userName?: string;
  /**
   * @remarks
   * Longest wait event during the execution period.
   * 
   * @example
   * none
   */
  waitEvent?: string;
  /**
   * @remarks
   * Eventually consistent transaction percentage during the execution period.
   * 
   * @example
   * 0.0
   */
  weakConsistencyPercentage?: number;
  static names(): { [key: string]: string } {
    return {
      avgAffectedRows: 'AvgAffectedRows',
      avgApplicationWaitTime: 'AvgApplicationWaitTime',
      avgBlockCacheHit: 'AvgBlockCacheHit',
      avgBlockIndexCacheHit: 'AvgBlockIndexCacheHit',
      avgBloomFilterCacheHit: 'AvgBloomFilterCacheHit',
      avgConcurrencyWaitTime: 'AvgConcurrencyWaitTime',
      avgCpuTime: 'AvgCpuTime',
      avgDbTime: 'AvgDbTime',
      avgDecodeTime: 'AvgDecodeTime',
      avgDiskReads: 'AvgDiskReads',
      avgElapsedTime: 'AvgElapsedTime',
      avgExecuteTime: 'AvgExecuteTime',
      avgExecutorRpcCount: 'AvgExecutorRpcCount',
      avgExpectedWorkerCount: 'AvgExpectedWorkerCount',
      avgGetPlanTime: 'AvgGetPlanTime',
      avgLogicalReads: 'AvgLogicalReads',
      avgMemstoreReadRows: 'AvgMemstoreReadRows',
      avgNetTime: 'AvgNetTime',
      avgNetWaitTime: 'AvgNetWaitTime',
      avgPartitionCount: 'AvgPartitionCount',
      avgQueueTime: 'AvgQueueTime',
      avgReturnRows: 'AvgReturnRows',
      avgRowCacheHit: 'AvgRowCacheHit',
      avgRpcCount: 'AvgRpcCount',
      avgScheduleTime: 'AvgScheduleTime',
      avgSsstoreReadRows: 'AvgSsstoreReadRows',
      avgUsedWorkerCount: 'AvgUsedWorkerCount',
      avgUserIoWaitTime: 'AvgUserIoWaitTime',
      avgWaitCount: 'AvgWaitCount',
      avgWaitTime: 'AvgWaitTime',
      clientIp: 'ClientIp',
      dbName: 'DbName',
      distPlanPercentage: 'DistPlanPercentage',
      dynamicSql: 'DynamicSql',
      execPs: 'ExecPs',
      executions: 'Executions',
      failCount: 'FailCount',
      failPercentage: 'FailPercentage',
      inner: 'Inner',
      localPlanPercentage: 'LocalPlanPercentage',
      maxAffectedRows: 'MaxAffectedRows',
      maxApplicationWaitTime: 'MaxApplicationWaitTime',
      maxConcurrencyWaitTime: 'MaxConcurrencyWaitTime',
      maxCpuTime: 'MaxCpuTime',
      maxDiskReads: 'MaxDiskReads',
      maxElapsedTime: 'MaxElapsedTime',
      maxReturnRows: 'MaxReturnRows',
      maxUserIoWaitTime: 'MaxUserIoWaitTime',
      maxWaitTime: 'MaxWaitTime',
      missPlanPercentage: 'MissPlanPercentage',
      missPlans: 'MissPlans',
      remotePlanPercentage: 'RemotePlanPercentage',
      remotePlans: 'RemotePlans',
      retCode4012Count: 'RetCode4012Count',
      retCode4013Count: 'RetCode4013Count',
      retCode5001Count: 'RetCode5001Count',
      retCode5024Count: 'RetCode5024Count',
      retCode5167Count: 'RetCode5167Count',
      retCode5217Count: 'RetCode5217Count',
      retCode6002Count: 'RetCode6002Count',
      retryCount: 'RetryCount',
      rpcCount: 'RpcCount',
      server: 'Server',
      serverIp: 'ServerIp',
      serverPort: 'ServerPort',
      sqlId: 'SqlId',
      sqlList: 'SqlList',
      sqlTextShort: 'SqlTextShort',
      sqlType: 'SqlType',
      strongConsistencyPercentage: 'StrongConsistencyPercentage',
      sumDbTime: 'SumDbTime',
      sumElapsedTime: 'SumElapsedTime',
      sumLogicalReads: 'SumLogicalReads',
      sumWaitTime: 'SumWaitTime',
      tableScanPercentage: 'TableScanPercentage',
      totalWaitTime: 'TotalWaitTime',
      userName: 'UserName',
      waitEvent: 'WaitEvent',
      weakConsistencyPercentage: 'WeakConsistencyPercentage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avgAffectedRows: 'number',
      avgApplicationWaitTime: 'number',
      avgBlockCacheHit: 'number',
      avgBlockIndexCacheHit: 'number',
      avgBloomFilterCacheHit: 'number',
      avgConcurrencyWaitTime: 'number',
      avgCpuTime: 'number',
      avgDbTime: 'number',
      avgDecodeTime: 'number',
      avgDiskReads: 'number',
      avgElapsedTime: 'number',
      avgExecuteTime: 'number',
      avgExecutorRpcCount: 'number',
      avgExpectedWorkerCount: 'number',
      avgGetPlanTime: 'number',
      avgLogicalReads: 'number',
      avgMemstoreReadRows: 'number',
      avgNetTime: 'number',
      avgNetWaitTime: 'number',
      avgPartitionCount: 'number',
      avgQueueTime: 'number',
      avgReturnRows: 'number',
      avgRowCacheHit: 'number',
      avgRpcCount: 'number',
      avgScheduleTime: 'number',
      avgSsstoreReadRows: 'number',
      avgUsedWorkerCount: 'number',
      avgUserIoWaitTime: 'number',
      avgWaitCount: 'number',
      avgWaitTime: 'number',
      clientIp: 'string',
      dbName: 'string',
      distPlanPercentage: 'number',
      dynamicSql: 'boolean',
      execPs: 'number',
      executions: 'number',
      failCount: 'number',
      failPercentage: 'number',
      inner: 'boolean',
      localPlanPercentage: 'number',
      maxAffectedRows: 'number',
      maxApplicationWaitTime: 'number',
      maxConcurrencyWaitTime: 'number',
      maxCpuTime: 'number',
      maxDiskReads: 'number',
      maxElapsedTime: 'number',
      maxReturnRows: 'number',
      maxUserIoWaitTime: 'number',
      maxWaitTime: 'number',
      missPlanPercentage: 'number',
      missPlans: 'number',
      remotePlanPercentage: 'number',
      remotePlans: 'number',
      retCode4012Count: 'number',
      retCode4013Count: 'number',
      retCode5001Count: 'number',
      retCode5024Count: 'number',
      retCode5167Count: 'number',
      retCode5217Count: 'number',
      retCode6002Count: 'number',
      retryCount: 'number',
      rpcCount: 'number',
      server: 'string',
      serverIp: 'string',
      serverPort: 'number',
      sqlId: 'string',
      sqlList: { 'type': 'array', 'itemType': DescribeOasSlowSQLListResponseBodyDataSqlList },
      sqlTextShort: 'string',
      sqlType: 'string',
      strongConsistencyPercentage: 'number',
      sumDbTime: 'number',
      sumElapsedTime: 'number',
      sumLogicalReads: 'number',
      sumWaitTime: 'number',
      tableScanPercentage: 'number',
      totalWaitTime: 'number',
      userName: 'string',
      waitEvent: 'string',
      weakConsistencyPercentage: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.sqlList)) {
      $dara.Model.validateArray(this.sqlList);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOasTopSQLListResponseBodyDataSqlList extends $dara.Model {
  avgAffectedRows?: number;
  avgApplicationWaitTime?: number;
  avgBlockCacheHit?: number;
  avgBlockIndexCacheHit?: number;
  avgBloomFilterCacheHit?: number;
  avgConcurrencyWaitTime?: number;
  avgCpuTime?: number;
  avgDbTime?: number;
  avgDecodeTime?: number;
  avgDiskReads?: number;
  avgElapsedTime?: number;
  avgExecuteTime?: number;
  avgExecutorRpcCount?: number;
  avgExpectedWorkerCount?: number;
  avgGetPlanTime?: number;
  avgLogicalReads?: number;
  avgMemstoreReadRows?: number;
  avgNetTime?: number;
  avgNetWaitTime?: number;
  avgPartitionCount?: number;
  avgQueueTime?: number;
  avgReturnRows?: number;
  avgRowCacheHit?: number;
  avgRpcCount?: number;
  avgScheduleTime?: number;
  avgSsstoreReadRows?: number;
  avgUsedWorkerCount?: number;
  avgUserIoWaitTime?: number;
  avgWaitCount?: number;
  avgWaitTime?: number;
  clientIp?: string;
  cpuPercentage?: number;
  dbName?: string;
  distPlanPercentage?: number;
  execPs?: number;
  executions?: number;
  failCount?: number;
  failPercentage?: number;
  inner?: boolean;
  localPlanPercentage?: number;
  maxAffectedRows?: number;
  maxApplicationWaitTime?: number;
  maxConcurrencyWaitTime?: number;
  maxCpuTime?: number;
  maxDiskReads?: number;
  maxElapsedTime?: number;
  maxReturnRows?: number;
  maxUserIoWaitTime?: number;
  maxWaitTime?: number;
  missPlanPercentage?: number;
  missPlans?: number;
  remotePlanPercentage?: number;
  remotePlans?: number;
  retCode4012Count?: number;
  retCode4013Count?: number;
  retCode5001Count?: number;
  retCode5024Count?: number;
  retCode5167Count?: number;
  retCode5217Count?: number;
  retCode6002Count?: number;
  retryCount?: number;
  rpcCount?: number;
  server?: string;
  serverIp?: string;
  serverPort?: number;
  sqlId?: string;
  sqlTextShort?: string;
  sqlType?: string;
  strongConsistencyPercentage?: number;
  sumDbTime?: number;
  sumElapsedTime?: number;
  sumLogicalReads?: number;
  sumWaitTime?: number;
  tableScanPercentage?: number;
  totalWaitTime?: number;
  userName?: string;
  waitEvent?: string;
  weakConsistencyPercentage?: number;
  static names(): { [key: string]: string } {
    return {
      avgAffectedRows: 'AvgAffectedRows',
      avgApplicationWaitTime: 'AvgApplicationWaitTime',
      avgBlockCacheHit: 'AvgBlockCacheHit',
      avgBlockIndexCacheHit: 'AvgBlockIndexCacheHit',
      avgBloomFilterCacheHit: 'AvgBloomFilterCacheHit',
      avgConcurrencyWaitTime: 'AvgConcurrencyWaitTime',
      avgCpuTime: 'AvgCpuTime',
      avgDbTime: 'AvgDbTime',
      avgDecodeTime: 'AvgDecodeTime',
      avgDiskReads: 'AvgDiskReads',
      avgElapsedTime: 'AvgElapsedTime',
      avgExecuteTime: 'AvgExecuteTime',
      avgExecutorRpcCount: 'AvgExecutorRpcCount',
      avgExpectedWorkerCount: 'AvgExpectedWorkerCount',
      avgGetPlanTime: 'AvgGetPlanTime',
      avgLogicalReads: 'AvgLogicalReads',
      avgMemstoreReadRows: 'AvgMemstoreReadRows',
      avgNetTime: 'AvgNetTime',
      avgNetWaitTime: 'AvgNetWaitTime',
      avgPartitionCount: 'AvgPartitionCount',
      avgQueueTime: 'AvgQueueTime',
      avgReturnRows: 'AvgReturnRows',
      avgRowCacheHit: 'AvgRowCacheHit',
      avgRpcCount: 'AvgRpcCount',
      avgScheduleTime: 'AvgScheduleTime',
      avgSsstoreReadRows: 'AvgSsstoreReadRows',
      avgUsedWorkerCount: 'AvgUsedWorkerCount',
      avgUserIoWaitTime: 'AvgUserIoWaitTime',
      avgWaitCount: 'AvgWaitCount',
      avgWaitTime: 'AvgWaitTime',
      clientIp: 'ClientIp',
      cpuPercentage: 'CpuPercentage',
      dbName: 'DbName',
      distPlanPercentage: 'DistPlanPercentage',
      execPs: 'ExecPs',
      executions: 'Executions',
      failCount: 'FailCount',
      failPercentage: 'FailPercentage',
      inner: 'Inner',
      localPlanPercentage: 'LocalPlanPercentage',
      maxAffectedRows: 'MaxAffectedRows',
      maxApplicationWaitTime: 'MaxApplicationWaitTime',
      maxConcurrencyWaitTime: 'MaxConcurrencyWaitTime',
      maxCpuTime: 'MaxCpuTime',
      maxDiskReads: 'MaxDiskReads',
      maxElapsedTime: 'MaxElapsedTime',
      maxReturnRows: 'MaxReturnRows',
      maxUserIoWaitTime: 'MaxUserIoWaitTime',
      maxWaitTime: 'MaxWaitTime',
      missPlanPercentage: 'MissPlanPercentage',
      missPlans: 'MissPlans',
      remotePlanPercentage: 'RemotePlanPercentage',
      remotePlans: 'RemotePlans',
      retCode4012Count: 'RetCode4012Count',
      retCode4013Count: 'RetCode4013Count',
      retCode5001Count: 'RetCode5001Count',
      retCode5024Count: 'RetCode5024Count',
      retCode5167Count: 'RetCode5167Count',
      retCode5217Count: 'RetCode5217Count',
      retCode6002Count: 'RetCode6002Count',
      retryCount: 'RetryCount',
      rpcCount: 'RpcCount',
      server: 'Server',
      serverIp: 'ServerIp',
      serverPort: 'ServerPort',
      sqlId: 'SqlId',
      sqlTextShort: 'SqlTextShort',
      sqlType: 'SqlType',
      strongConsistencyPercentage: 'StrongConsistencyPercentage',
      sumDbTime: 'SumDbTime',
      sumElapsedTime: 'SumElapsedTime',
      sumLogicalReads: 'SumLogicalReads',
      sumWaitTime: 'SumWaitTime',
      tableScanPercentage: 'TableScanPercentage',
      totalWaitTime: 'TotalWaitTime',
      userName: 'UserName',
      waitEvent: 'WaitEvent',
      weakConsistencyPercentage: 'WeakConsistencyPercentage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avgAffectedRows: 'number',
      avgApplicationWaitTime: 'number',
      avgBlockCacheHit: 'number',
      avgBlockIndexCacheHit: 'number',
      avgBloomFilterCacheHit: 'number',
      avgConcurrencyWaitTime: 'number',
      avgCpuTime: 'number',
      avgDbTime: 'number',
      avgDecodeTime: 'number',
      avgDiskReads: 'number',
      avgElapsedTime: 'number',
      avgExecuteTime: 'number',
      avgExecutorRpcCount: 'number',
      avgExpectedWorkerCount: 'number',
      avgGetPlanTime: 'number',
      avgLogicalReads: 'number',
      avgMemstoreReadRows: 'number',
      avgNetTime: 'number',
      avgNetWaitTime: 'number',
      avgPartitionCount: 'number',
      avgQueueTime: 'number',
      avgReturnRows: 'number',
      avgRowCacheHit: 'number',
      avgRpcCount: 'number',
      avgScheduleTime: 'number',
      avgSsstoreReadRows: 'number',
      avgUsedWorkerCount: 'number',
      avgUserIoWaitTime: 'number',
      avgWaitCount: 'number',
      avgWaitTime: 'number',
      clientIp: 'string',
      cpuPercentage: 'number',
      dbName: 'string',
      distPlanPercentage: 'number',
      execPs: 'number',
      executions: 'number',
      failCount: 'number',
      failPercentage: 'number',
      inner: 'boolean',
      localPlanPercentage: 'number',
      maxAffectedRows: 'number',
      maxApplicationWaitTime: 'number',
      maxConcurrencyWaitTime: 'number',
      maxCpuTime: 'number',
      maxDiskReads: 'number',
      maxElapsedTime: 'number',
      maxReturnRows: 'number',
      maxUserIoWaitTime: 'number',
      maxWaitTime: 'number',
      missPlanPercentage: 'number',
      missPlans: 'number',
      remotePlanPercentage: 'number',
      remotePlans: 'number',
      retCode4012Count: 'number',
      retCode4013Count: 'number',
      retCode5001Count: 'number',
      retCode5024Count: 'number',
      retCode5167Count: 'number',
      retCode5217Count: 'number',
      retCode6002Count: 'number',
      retryCount: 'number',
      rpcCount: 'number',
      server: 'string',
      serverIp: 'string',
      serverPort: 'number',
      sqlId: 'string',
      sqlTextShort: 'string',
      sqlType: 'string',
      strongConsistencyPercentage: 'number',
      sumDbTime: 'number',
      sumElapsedTime: 'number',
      sumLogicalReads: 'number',
      sumWaitTime: 'number',
      tableScanPercentage: 'number',
      totalWaitTime: 'number',
      userName: 'string',
      waitEvent: 'string',
      weakConsistencyPercentage: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOasTopSQLListResponseBodyData extends $dara.Model {
  /**
   * @remarks
   * Average updated rows during the execution period.
   * 
   * @example
   * 9978.75
   */
  avgAffectedRows?: number;
  /**
   * @remarks
   * Average Application event wait time (in milliseconds) during the execution period.
   * 
   * @example
   * 0.0
   */
  avgApplicationWaitTime?: number;
  /**
   * @remarks
   * Average BlockCache hit count during the execution period.
   * 
   * @example
   * 0.0
   */
  avgBlockCacheHit?: number;
  /**
   * @remarks
   * Average BlockIndexCache hit count during the execution period.
   * 
   * @example
   * 0.0
   */
  avgBlockIndexCacheHit?: number;
  /**
   * @remarks
   * Average BloomFilterCache hit count during the execution period.
   * 
   * @example
   * 0.0
   */
  avgBloomFilterCacheHit?: number;
  /**
   * @remarks
   * Average Concurrency event wait time (in milliseconds) during the execution period.
   * 
   * @example
   * 0.0
   */
  avgConcurrencyWaitTime?: number;
  /**
   * @remarks
   * Average CPU time (in milliseconds) during the execution period.
   * 
   * @example
   * 1875.34
   */
  avgCpuTime?: number;
  avgDbTime?: number;
  /**
   * @remarks
   * Average syntax parsing time (in milliseconds) during the execution period.
   * 
   * @example
   * 0.0
   */
  avgDecodeTime?: number;
  /**
   * @remarks
   * Average physical read count during the execution period.
   * 
   * @example
   * 0.0
   */
  avgDiskReads?: number;
  /**
   * @remarks
   * Average response time (in milliseconds) during the execution period.
   * 
   * @example
   * 903.29
   */
  avgElapsedTime?: number;
  /**
   * @remarks
   * Average plan execution time (in milliseconds) during the execution period.
   * 
   * @example
   * 1895.7
   */
  avgExecuteTime?: number;
  /**
   * @remarks
   * Average number of RPC requests executed during the execution period.
   * 
   * @example
   * 0.0
   */
  avgExecutorRpcCount?: number;
  /**
   * @remarks
   * Average degree of parallelism during the execution period.
   * 
   * @example
   * 3
   */
  avgExpectedWorkerCount?: number;
  /**
   * @remarks
   * Average plan generation time (in milliseconds) during the execution period.
   * 
   * @example
   * 0.0
   */
  avgGetPlanTime?: number;
  /**
   * @remarks
   * Average logical reads of the SQL during the execution period.
   * 
   * @example
   * 0.0
   */
  avgLogicalReads?: number;
  /**
   * @remarks
   * Strong consistent transaction percentage during the execution period.
   * 
   * @example
   * 0.0
   */
  avgMemstoreReadRows?: number;
  /**
   * @remarks
   * Average network transmission time (in milliseconds) during the execution period.
   * 
   * @example
   * 0.0
   */
  avgNetTime?: number;
  /**
   * @remarks
   * Average network enqueue time (in milliseconds) during the execution period.
   * 
   * @example
   * 0.0
   */
  avgNetWaitTime?: number;
  /**
   * @remarks
   * Average number of partition accessed during the execution period.
   * 
   * @example
   * 1.0
   */
  avgPartitionCount?: number;
  /**
   * @remarks
   * Average queueing time (in milliseconds) during the execution period.
   * 
   * @example
   * 0.01
   */
  avgQueueTime?: number;
  /**
   * @remarks
   * Average returned rows during the execution period.
   * 
   * @example
   * 0.0
   */
  avgReturnRows?: number;
  /**
   * @remarks
   * Average RowCache hit count during the execution period.
   * 
   * @example
   * 0.0
   */
  avgRowCacheHit?: number;
  /**
   * @remarks
   * Average count of RPC sent during the execution period.
   * 
   * @example
   * 8.0
   */
  avgRpcCount?: number;
  /**
   * @remarks
   * Average Schedule event wait time (in milliseconds) during the execution period.
   * 
   * @example
   * 0.0
   */
  avgScheduleTime?: number;
  /**
   * @remarks
   * Eventually consistent transaction percentage during the execution period.
   * 
   * @example
   * 0.0
   */
  avgSsstoreReadRows?: number;
  /**
   * @remarks
   * Average number of threads used of the SQL during the execution period.
   * 
   * @example
   * 3
   */
  avgUsedWorkerCount?: number;
  /**
   * @remarks
   * Average UserIO event wait time (in milliseconds) during the execution period.
   * 
   * @example
   * 0.0
   */
  avgUserIoWaitTime?: number;
  /**
   * @remarks
   * Average wait count during the execution period.
   * 
   * @example
   * 0.0
   */
  avgWaitCount?: number;
  /**
   * @remarks
   * Average wait time (in milliseconds) during the execution period.
   * 
   * @example
   * 1442.49
   */
  avgWaitTime?: number;
  /**
   * @remarks
   * Client IP.
   * 
   * @example
   * i-bp1db****38uemejio
   */
  clientIp?: string;
  /**
   * @remarks
   * CPU percentage.
   * 
   * @example
   * 100.0
   */
  cpuPercentage?: number;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * test_db
   */
  dbName?: string;
  /**
   * @remarks
   * Distributed plan percentage during the execution period.
   * 
   * @example
   * 100.0
   */
  distPlanPercentage?: number;
  dynamicSql?: boolean;
  /**
   * @remarks
   * Average execution count per second during the execution period.
   * 
   * @example
   * 0.31
   */
  execPs?: number;
  /**
   * @remarks
   * Total number of executions during the execution period.
   * 
   * @example
   * 1
   */
  executions?: number;
  /**
   * @remarks
   * Average number of partition accessed during the execution period.
   * 
   * @example
   * 0
   */
  failCount?: number;
  /**
   * @remarks
   * Error percentage during the execution period.
   * 
   * @example
   * 0.0
   */
  failPercentage?: number;
  /**
   * @remarks
   * Whether a internal SQL.
   * 
   * @example
   * false
   */
  inner?: boolean;
  lastFailCode?: number;
  /**
   * @remarks
   * Local plan percentage during the execution period.
   * 
   * @example
   * 0.0
   */
  localPlanPercentage?: number;
  /**
   * @remarks
   * Max affected rows during the execution period.
   * 
   * @example
   * 10000.0
   */
  maxAffectedRows?: number;
  /**
   * @remarks
   * Max Application event wait time (in milliseconds) during the execution period.
   * 
   * @example
   * 0.0
   */
  maxApplicationWaitTime?: number;
  /**
   * @remarks
   * Max Concurrency event wait time (in milliseconds) during the execution period.
   * 
   * @example
   * 0.0
   */
  maxConcurrencyWaitTime?: number;
  /**
   * @remarks
   * Max CPU time (in milliseconds).
   * 
   * @example
   * 13641.9
   */
  maxCpuTime?: number;
  /**
   * @remarks
   * Max physical read count during the execution period.
   * 
   * @example
   * 0.0
   */
  maxDiskReads?: number;
  /**
   * @remarks
   * Max response time during the execution period.
   * 
   * @example
   * 13643.3
   */
  maxElapsedTime?: number;
  /**
   * @remarks
   * Max returned rows during the execution period.
   * 
   * @example
   * 0.0
   */
  maxReturnRows?: number;
  /**
   * @remarks
   * Max UserIO event wait time (in milliseconds) during the execution period.
   * 
   * @example
   * 0.0
   */
  maxUserIoWaitTime?: number;
  /**
   * @remarks
   * Max wait time (in milliseconds) during the execution period.
   * 
   * @example
   * 3.4
   */
  maxWaitTime?: number;
  /**
   * @remarks
   * Plan hit rage during the execution period.
   * 
   * @example
   * 0.0
   */
  missPlanPercentage?: number;
  /**
   * @remarks
   * Missed hit count of the execution plan during the execution period.
   * 
   * @example
   * 0
   */
  missPlans?: number;
  /**
   * @remarks
   * Remote plan percentage during the execution period.
   * 
   * @example
   * 0.0
   */
  remotePlanPercentage?: number;
  /**
   * @remarks
   * Remote execution count during the execution period.
   * 
   * @example
   * 0
   */
  remotePlans?: number;
  /**
   * @remarks
   * Number of occurrences of the code 4012 during the execution period.
   * 
   * @example
   * 0
   */
  retCode4012Count?: number;
  /**
   * @remarks
   * Number of occurrences of the code 4013 during the execution period.
   * 
   * @example
   * 0
   */
  retCode4013Count?: number;
  /**
   * @remarks
   * Number of occurrences of the code 5001 during the execution period.
   * 
   * @example
   * 0
   */
  retCode5001Count?: number;
  /**
   * @remarks
   * Number of occurrences of the code 5024 during the execution period.
   * 
   * @example
   * 0
   */
  retCode5024Count?: number;
  /**
   * @remarks
   * Number of occurrences of the code 5167 during the execution period.
   * 
   * @example
   * 0
   */
  retCode5167Count?: number;
  /**
   * @remarks
   * Number of occurrences of the code 5217 during the execution period.
   * 
   * @example
   * 0
   */
  retCode5217Count?: number;
  /**
   * @remarks
   * Number of occurrences of the code 6002 during the execution period.
   * 
   * @example
   * 0
   */
  retCode6002Count?: number;
  /**
   * @remarks
   * Total retry count during the execution period.
   * 
   * @example
   * 0
   */
  retryCount?: number;
  /**
   * @remarks
   * RPC count during the execution period.
   * 
   * @example
   * 0.0
   */
  rpcCount?: number;
  /**
   * @remarks
   * The server where the SQL is executed.
   * 
   * @example
   * i-bp1db1****8uemejio
   */
  server?: string;
  /**
   * @remarks
   * The server IP where the SQL is executed.
   * 
   * @example
   * i-bp1db1****8uemejio
   */
  serverIp?: string;
  /**
   * @remarks
   * The server port where the SQL is executed.
   * 
   * @example
   * 389
   */
  serverPort?: number;
  /**
   * @remarks
   * SQL ID.
   * 
   * @example
   * 8D6E84****0B8FB1823D199E2CA1****
   */
  sqlId?: string;
  sqlList?: DescribeOasTopSQLListResponseBodyDataSqlList[];
  /**
   * @remarks
   * SQL text (the first 100 characters).
   */
  sqlTextShort?: string;
  /**
   * @remarks
   * SQL type.
   * 
   * @example
   * select
   */
  sqlType?: string;
  /**
   * @remarks
   * Strong consistent transaction percentage during the execution period.
   * 
   * @example
   * 100.0
   */
  strongConsistencyPercentage?: number;
  sumDbTime?: number;
  /**
   * @remarks
   * Total response time (in milliseconds) during the execution period.
   * 
   * @example
   * 11452126.36
   */
  sumElapsedTime?: number;
  /**
   * @remarks
   * Total logical reads.
   * 
   * @example
   * 0.0
   */
  sumLogicalReads?: number;
  /**
   * @remarks
   * Total wait time (in milliseconds) during the execution period.
   * 
   * @example
   * 9421.73
   */
  sumWaitTime?: number;
  /**
   * @remarks
   * Table scan percentage during the execution period.
   * 
   * @example
   * 0.0
   */
  tableScanPercentage?: number;
  /**
   * @remarks
   * Total wait time (in milliseconds) during the execution period.
   * 
   * @example
   * 10.966
   */
  totalWaitTime?: number;
  /**
   * @remarks
   * Username.
   * 
   * @example
   * test_user
   */
  userName?: string;
  /**
   * @remarks
   * Longest wait event during the execution period.
   * 
   * @example
   * none
   */
  waitEvent?: string;
  /**
   * @remarks
   * Eventually consistent transaction percentage during the execution period.
   * 
   * @example
   * 0.0
   */
  weakConsistencyPercentage?: number;
  static names(): { [key: string]: string } {
    return {
      avgAffectedRows: 'AvgAffectedRows',
      avgApplicationWaitTime: 'AvgApplicationWaitTime',
      avgBlockCacheHit: 'AvgBlockCacheHit',
      avgBlockIndexCacheHit: 'AvgBlockIndexCacheHit',
      avgBloomFilterCacheHit: 'AvgBloomFilterCacheHit',
      avgConcurrencyWaitTime: 'AvgConcurrencyWaitTime',
      avgCpuTime: 'AvgCpuTime',
      avgDbTime: 'AvgDbTime',
      avgDecodeTime: 'AvgDecodeTime',
      avgDiskReads: 'AvgDiskReads',
      avgElapsedTime: 'AvgElapsedTime',
      avgExecuteTime: 'AvgExecuteTime',
      avgExecutorRpcCount: 'AvgExecutorRpcCount',
      avgExpectedWorkerCount: 'AvgExpectedWorkerCount',
      avgGetPlanTime: 'AvgGetPlanTime',
      avgLogicalReads: 'AvgLogicalReads',
      avgMemstoreReadRows: 'AvgMemstoreReadRows',
      avgNetTime: 'AvgNetTime',
      avgNetWaitTime: 'AvgNetWaitTime',
      avgPartitionCount: 'AvgPartitionCount',
      avgQueueTime: 'AvgQueueTime',
      avgReturnRows: 'AvgReturnRows',
      avgRowCacheHit: 'AvgRowCacheHit',
      avgRpcCount: 'AvgRpcCount',
      avgScheduleTime: 'AvgScheduleTime',
      avgSsstoreReadRows: 'AvgSsstoreReadRows',
      avgUsedWorkerCount: 'AvgUsedWorkerCount',
      avgUserIoWaitTime: 'AvgUserIoWaitTime',
      avgWaitCount: 'AvgWaitCount',
      avgWaitTime: 'AvgWaitTime',
      clientIp: 'ClientIp',
      cpuPercentage: 'CpuPercentage',
      dbName: 'DbName',
      distPlanPercentage: 'DistPlanPercentage',
      dynamicSql: 'DynamicSql',
      execPs: 'ExecPs',
      executions: 'Executions',
      failCount: 'FailCount',
      failPercentage: 'FailPercentage',
      inner: 'Inner',
      lastFailCode: 'LastFailCode',
      localPlanPercentage: 'LocalPlanPercentage',
      maxAffectedRows: 'MaxAffectedRows',
      maxApplicationWaitTime: 'MaxApplicationWaitTime',
      maxConcurrencyWaitTime: 'MaxConcurrencyWaitTime',
      maxCpuTime: 'MaxCpuTime',
      maxDiskReads: 'MaxDiskReads',
      maxElapsedTime: 'MaxElapsedTime',
      maxReturnRows: 'MaxReturnRows',
      maxUserIoWaitTime: 'MaxUserIoWaitTime',
      maxWaitTime: 'MaxWaitTime',
      missPlanPercentage: 'MissPlanPercentage',
      missPlans: 'MissPlans',
      remotePlanPercentage: 'RemotePlanPercentage',
      remotePlans: 'RemotePlans',
      retCode4012Count: 'RetCode4012Count',
      retCode4013Count: 'RetCode4013Count',
      retCode5001Count: 'RetCode5001Count',
      retCode5024Count: 'RetCode5024Count',
      retCode5167Count: 'RetCode5167Count',
      retCode5217Count: 'RetCode5217Count',
      retCode6002Count: 'RetCode6002Count',
      retryCount: 'RetryCount',
      rpcCount: 'RpcCount',
      server: 'Server',
      serverIp: 'ServerIp',
      serverPort: 'ServerPort',
      sqlId: 'SqlId',
      sqlList: 'SqlList',
      sqlTextShort: 'SqlTextShort',
      sqlType: 'SqlType',
      strongConsistencyPercentage: 'StrongConsistencyPercentage',
      sumDbTime: 'SumDbTime',
      sumElapsedTime: 'SumElapsedTime',
      sumLogicalReads: 'SumLogicalReads',
      sumWaitTime: 'SumWaitTime',
      tableScanPercentage: 'TableScanPercentage',
      totalWaitTime: 'TotalWaitTime',
      userName: 'UserName',
      waitEvent: 'WaitEvent',
      weakConsistencyPercentage: 'WeakConsistencyPercentage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avgAffectedRows: 'number',
      avgApplicationWaitTime: 'number',
      avgBlockCacheHit: 'number',
      avgBlockIndexCacheHit: 'number',
      avgBloomFilterCacheHit: 'number',
      avgConcurrencyWaitTime: 'number',
      avgCpuTime: 'number',
      avgDbTime: 'number',
      avgDecodeTime: 'number',
      avgDiskReads: 'number',
      avgElapsedTime: 'number',
      avgExecuteTime: 'number',
      avgExecutorRpcCount: 'number',
      avgExpectedWorkerCount: 'number',
      avgGetPlanTime: 'number',
      avgLogicalReads: 'number',
      avgMemstoreReadRows: 'number',
      avgNetTime: 'number',
      avgNetWaitTime: 'number',
      avgPartitionCount: 'number',
      avgQueueTime: 'number',
      avgReturnRows: 'number',
      avgRowCacheHit: 'number',
      avgRpcCount: 'number',
      avgScheduleTime: 'number',
      avgSsstoreReadRows: 'number',
      avgUsedWorkerCount: 'number',
      avgUserIoWaitTime: 'number',
      avgWaitCount: 'number',
      avgWaitTime: 'number',
      clientIp: 'string',
      cpuPercentage: 'number',
      dbName: 'string',
      distPlanPercentage: 'number',
      dynamicSql: 'boolean',
      execPs: 'number',
      executions: 'number',
      failCount: 'number',
      failPercentage: 'number',
      inner: 'boolean',
      lastFailCode: 'number',
      localPlanPercentage: 'number',
      maxAffectedRows: 'number',
      maxApplicationWaitTime: 'number',
      maxConcurrencyWaitTime: 'number',
      maxCpuTime: 'number',
      maxDiskReads: 'number',
      maxElapsedTime: 'number',
      maxReturnRows: 'number',
      maxUserIoWaitTime: 'number',
      maxWaitTime: 'number',
      missPlanPercentage: 'number',
      missPlans: 'number',
      remotePlanPercentage: 'number',
      remotePlans: 'number',
      retCode4012Count: 'number',
      retCode4013Count: 'number',
      retCode5001Count: 'number',
      retCode5024Count: 'number',
      retCode5167Count: 'number',
      retCode5217Count: 'number',
      retCode6002Count: 'number',
      retryCount: 'number',
      rpcCount: 'number',
      server: 'string',
      serverIp: 'string',
      serverPort: 'number',
      sqlId: 'string',
      sqlList: { 'type': 'array', 'itemType': DescribeOasTopSQLListResponseBodyDataSqlList },
      sqlTextShort: 'string',
      sqlType: 'string',
      strongConsistencyPercentage: 'number',
      sumDbTime: 'number',
      sumElapsedTime: 'number',
      sumLogicalReads: 'number',
      sumWaitTime: 'number',
      tableScanPercentage: 'number',
      totalWaitTime: 'number',
      userName: 'string',
      waitEvent: 'string',
      weakConsistencyPercentage: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.sqlList)) {
      $dara.Model.validateArray(this.sqlList);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOutlineBindingResponseBodyOutlineBinding extends $dara.Model {
  /**
   * @remarks
   * The bound index.
   * 
   * @example
   * PRIMARY
   */
  bindIndex?: string;
  /**
   * @remarks
   * The bound plan.
   * 
   * @example
   * PHY_TABLE_SCAN | bmsql_order_line | 40 ******
   */
  bindPlan?: string;
  /**
   * @remarks
   * The maximum number of concurrent tasks.
   * 
   * @example
   * 2
   */
  maxConcurrent?: number;
  /**
   * @remarks
   * OutlineID.
   * 
   * @example
   * -1
   */
  outlineId?: number;
  /**
   * @remarks
   * The name of the tenant. The tenant name must start with a letter or an underscore (_), and contain 2 to 20 characters, which can be uppercase letters, lowercase letters, digits, and underscores (_). It cannot be set to sys.
   * 
   * @example
   * cluster_info
   */
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      bindIndex: 'BindIndex',
      bindPlan: 'BindPlan',
      maxConcurrent: 'MaxConcurrent',
      outlineId: 'OutlineId',
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bindIndex: 'string',
      bindPlan: 'string',
      maxConcurrent: 'number',
      outlineId: 'number',
      tableName: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeParametersResponseBodyParameters extends $dara.Model {
  /**
   * @remarks
   * DescribeParameters
   */
  acceptableValue?: string[];
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * @example
   * 600
   */
  currentValue?: string;
  /**
   * @remarks
   * ```
   * http(s)://[Endpoint]/?Action=DescribeParameters
   * &InstanceId=ob317v4uif****
   * &Dimension=TENANT
   * &DimensionValue=ob2mr3oae0****
   * &Common request parameters
   * ```
   * 
   * @example
   * 600s
   */
  defaultValue?: string;
  /**
   * @remarks
   * The description of the parameter.
   * 
   * @example
   * The operation that you want to perform.   
   * Set the value to **DescribeParameters**.
   */
  description?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * connect_timeout
   */
  name?: string;
  /**
   * @remarks
   * The name of the parameter.
   * 
   * @example
   * false
   */
  needReboot?: boolean;
  /**
   * @remarks
   * 参数是否只读
   */
  readonly?: boolean;
  /**
   * @remarks
   * {
   *     "RequestId": "EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C",
   *     "Parameters": [
   *         {
   *             "Description": "The maximum delay allowed in weak-consistency reads.",
   *             "ValueType": "CAPACITY",
   *             "CurrentValue": "600",
   *             "NeedReboot": false,
   *             "Name": "connect_timeout",
   *             "DefaultValue": "600s",
   *             "RejectedValue": [
   *                 "1s"
   *             ],
   *             "AcceptableValue": [
   *                 "1s"
   *             ]
   *         }
   *     ]
   * }
   */
  rejectedValue?: string[];
  /**
   * @example
   * s
   */
  unit?: string;
  /**
   * @remarks
   * The invalid value range of the parameter.    
   * It is an array with two string elements, which represents a range. The first element represents the minimum value and the second element represents the maximum value.
   * 
   * @example
   * CAPACITY
   */
  valueType?: string;
  static names(): { [key: string]: string } {
    return {
      acceptableValue: 'AcceptableValue',
      currentValue: 'CurrentValue',
      defaultValue: 'DefaultValue',
      description: 'Description',
      name: 'Name',
      needReboot: 'NeedReboot',
      readonly: 'Readonly',
      rejectedValue: 'RejectedValue',
      unit: 'Unit',
      valueType: 'ValueType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptableValue: { 'type': 'array', 'itemType': 'string' },
      currentValue: 'string',
      defaultValue: 'string',
      description: 'string',
      name: 'string',
      needReboot: 'boolean',
      readonly: 'boolean',
      rejectedValue: { 'type': 'array', 'itemType': 'string' },
      unit: 'string',
      valueType: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.acceptableValue)) {
      $dara.Model.validateArray(this.acceptableValue);
    }
    if(Array.isArray(this.rejectedValue)) {
      $dara.Model.validateArray(this.rejectedValue);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeParametersHistoryResponseBodyRespondParameters extends $dara.Model {
  /**
   * @remarks
   * The time when the parameter modification was initiated.
   * 
   * @example
   * 2024-11-26T08:03:34Z
   */
  createTime?: string;
  /**
   * @remarks
   * The resource ID of the parameter type. When you called this operation to query the modification history of cluster parameters, the value is DEFAULT_DIMENSION_VALUE. When you called this operation to query the modification history of tenant parameters, the value is the tenant ID.
   * 
   * @example
   * t69uo********
   */
  dimensionValue?: string;
  /**
   * @remarks
   * The name of the parameter.
   * 
   * @example
   * connect_timeout
   */
  name?: string;
  /**
   * @remarks
   * The value of the parameter after the modification.
   * 
   * @example
   * 30
   */
  newValue?: string;
  /**
   * @remarks
   * The value of the parameter before the modification.
   * 
   * @example
   * 10
   */
  oldValue?: string;
  /**
   * @remarks
   * The modification status of the parameter. Valid values: 
   * * APPLIED: The parameter was modified.
   * * SCHEDULING: The parameter was to be modified.
   * 
   * @example
   * APPLIED
   */
  status?: string;
  /**
   * @remarks
   * The time when the parameter modification took effect.
   * 
   * @example
   * 2024-11-26T08:03:34Z
   */
  updateTime?: string;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      dimensionValue: 'DimensionValue',
      name: 'Name',
      newValue: 'NewValue',
      oldValue: 'OldValue',
      status: 'Status',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'string',
      dimensionValue: 'string',
      name: 'string',
      newValue: 'string',
      oldValue: 'string',
      status: 'string',
      updateTime: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeParametersHistoryResponseBodyRespond extends $dara.Model {
  /**
   * @remarks
   * The number of the page to return.    
   * - Start value: 1   
   * - Default value: 1
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The information about parameters.
   */
  parameters?: DescribeParametersHistoryResponseBodyRespondParameters[];
  /**
   * @remarks
   * The total count, which takes effect in a pagination query.
   * 
   * @example
   * 5
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      parameters: 'Parameters',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      parameters: { 'type': 'array', 'itemType': DescribeParametersHistoryResponseBodyRespondParameters },
      totalCount: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.parameters)) {
      $dara.Model.validateArray(this.parameters);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProcessStatsCompositionResponseBodyDataAllProcessList extends $dara.Model {
  /**
   * @remarks
   * The IP address of the client.
   * 
   * @example
   * xx.xx.xx.xx
   */
  clientIp?: string;
  /**
   * @remarks
   * The type of the SQL statement being executed in the session.
   * 
   * @example
   * Query
   */
  command?: string;
  /**
   * @remarks
   * The CPU time spent on executing the current SQL statement, in seconds. 
   * 
   * > This parameter is introduced since OceanBase Database V3.2.4 BP5.
   * 
   * @example
   * 1
   */
  cpuTime?: number;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * c1
   */
  database?: string;
  /**
   * @remarks
   * The definition of this parameter varies based on whether the SQL statement is executed.
   * * When the request is accepted and the result is not returned to the client, this parameter indicates the time interval between the time when the request is accepted and the current time, in seconds.
   * * When the request is not accepted, this parameter indicates the duration for which the current status lasts, in seconds.
   * 
   * @example
   * 5
   */
  executeTime?: number;
  /**
   * @remarks
   * The ID of the execution plan.
   * 
   * @example
   * 1898
   */
  planId?: string;
  /**
   * @remarks
   * The session ID of the client. If an OceanBase Database Proxy (ODP) is used for connection, the session ID of the ODP is returned.
   * 
   * @example
   * 7521015416********
   */
  proxySessId?: string;
  /**
   * @remarks
   * The IP address of the server.
   * 
   * @example
   * xx.xx.xx.xx
   */
  serverIp?: string;
  /**
   * @remarks
   * The ID of the session.
   * 
   * @example
   * 322441****
   */
  sessionId?: number;
  /**
   * @remarks
   * The ID of the SQL statement.
   * 
   * @example
   * 45CCBDC7DEBDCDAXXXXAFC********
   */
  sqlId?: string;
  /**
   * @remarks
   * The SQL text.
   * 
   * @example
   * select * from c1 where id = 100;
   */
  sqlText?: string;
  /**
   * @remarks
   * The status of the session.
   * 
   * @example
   * ACTIVE
   */
  status?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * @example
   * test_mysql
   */
  tenantId?: string;
  /**
   * @remarks
   * The ID of the trace.
   * 
   * @example
   * YB420XXX128-00062XXXX8313XXX1-X-X
   */
  traceId?: string;
  /**
   * @remarks
   * The user to which the session belongs.
   * 
   * @example
   * test_user
   */
  user?: string;
  static names(): { [key: string]: string } {
    return {
      clientIp: 'ClientIp',
      command: 'Command',
      cpuTime: 'CpuTime',
      database: 'Database',
      executeTime: 'ExecuteTime',
      planId: 'PlanId',
      proxySessId: 'ProxySessId',
      serverIp: 'ServerIp',
      sessionId: 'SessionId',
      sqlId: 'SqlId',
      sqlText: 'SqlText',
      status: 'Status',
      tenantId: 'TenantId',
      traceId: 'TraceId',
      user: 'User',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clientIp: 'string',
      command: 'string',
      cpuTime: 'number',
      database: 'string',
      executeTime: 'number',
      planId: 'string',
      proxySessId: 'string',
      serverIp: 'string',
      sessionId: 'number',
      sqlId: 'string',
      sqlText: 'string',
      status: 'string',
      tenantId: 'string',
      traceId: 'string',
      user: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProcessStatsCompositionResponseBodyDataSessionStatisticsDataBaseStatistics extends $dara.Model {
  /**
   * @remarks
   * The number of active sessions.
   * 
   * @example
   * 25
   */
  activeCount?: number;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * test_database
   */
  metricValue?: string;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 30
   */
  totalCount?: number;
  /**
   * @remarks
   * The dimension. This value is fixed to database.
   * 
   * @example
   * database
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      activeCount: 'ActiveCount',
      metricValue: 'MetricValue',
      totalCount: 'TotalCount',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      activeCount: 'number',
      metricValue: 'string',
      totalCount: 'number',
      type: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProcessStatsCompositionResponseBodyDataSessionStatisticsSourceStatistics extends $dara.Model {
  /**
   * @remarks
   * The number of active sessions.
   * 
   * @example
   * 25
   */
  activeCount?: number;
  /**
   * @remarks
   * The IP address of the client.
   * 
   * @example
   * xx.xx.xx.xx
   */
  metricValue?: string;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 30
   */
  totalCount?: number;
  /**
   * @remarks
   * The dimension. This value is fixed to client.
   * 
   * @example
   * client
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      activeCount: 'ActiveCount',
      metricValue: 'MetricValue',
      totalCount: 'TotalCount',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      activeCount: 'number',
      metricValue: 'string',
      totalCount: 'number',
      type: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProcessStatsCompositionResponseBodyDataSessionStatisticsUserStatistics extends $dara.Model {
  /**
   * @remarks
   * The number of active sessions.
   * 
   * @example
   * 25
   */
  activeCount?: number;
  /**
   * @remarks
   * The username.
   * 
   * @example
   * test_user
   */
  metricValue?: string;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 30
   */
  totalCount?: number;
  /**
   * @remarks
   * The dimension. This value is fixed to user.
   * 
   * @example
   * user
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      activeCount: 'ActiveCount',
      metricValue: 'MetricValue',
      totalCount: 'TotalCount',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      activeCount: 'number',
      metricValue: 'string',
      totalCount: 'number',
      type: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProcessStatsCompositionResponseBodyDataSessionStatistics extends $dara.Model {
  /**
   * @remarks
   * The session data in the database dimension.
   */
  dataBaseStatistics?: DescribeProcessStatsCompositionResponseBodyDataSessionStatisticsDataBaseStatistics[];
  /**
   * @remarks
   * The session data in the client dimension.
   */
  sourceStatistics?: DescribeProcessStatsCompositionResponseBodyDataSessionStatisticsSourceStatistics[];
  /**
   * @remarks
   * The session data in the user dimension.
   */
  userStatistics?: DescribeProcessStatsCompositionResponseBodyDataSessionStatisticsUserStatistics[];
  static names(): { [key: string]: string } {
    return {
      dataBaseStatistics: 'DataBaseStatistics',
      sourceStatistics: 'SourceStatistics',
      userStatistics: 'UserStatistics',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataBaseStatistics: { 'type': 'array', 'itemType': DescribeProcessStatsCompositionResponseBodyDataSessionStatisticsDataBaseStatistics },
      sourceStatistics: { 'type': 'array', 'itemType': DescribeProcessStatsCompositionResponseBodyDataSessionStatisticsSourceStatistics },
      userStatistics: { 'type': 'array', 'itemType': DescribeProcessStatsCompositionResponseBodyDataSessionStatisticsUserStatistics },
    };
  }

  validate() {
    if(Array.isArray(this.dataBaseStatistics)) {
      $dara.Model.validateArray(this.dataBaseStatistics);
    }
    if(Array.isArray(this.sourceStatistics)) {
      $dara.Model.validateArray(this.sourceStatistics);
    }
    if(Array.isArray(this.userStatistics)) {
      $dara.Model.validateArray(this.userStatistics);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProcessStatsCompositionResponseBodyData extends $dara.Model {
  /**
   * @remarks
   * The number of active sessions.
   * 
   * @example
   * 60
   */
  activeSessionCount?: number;
  /**
   * @remarks
   * The details of all sessions.
   */
  allProcessList?: DescribeProcessStatsCompositionResponseBodyDataAllProcessList[];
  /**
   * @remarks
   * The number of sessions in the SLEEP state.
   * 
   * @example
   * 30
   */
  idleSessionCount?: number;
  /**
   * @remarks
   * The version of OceanBase Database.
   * 
   * @example
   * 3.2.4
   */
  obVersion?: string;
  /**
   * @remarks
   * The session data in different dimensions.
   */
  sessionStatistics?: DescribeProcessStatsCompositionResponseBodyDataSessionStatistics;
  /**
   * @remarks
   * The total number of sessions.
   * 
   * @example
   * 100
   */
  totalSessionCount?: number;
  static names(): { [key: string]: string } {
    return {
      activeSessionCount: 'ActiveSessionCount',
      allProcessList: 'AllProcessList',
      idleSessionCount: 'IdleSessionCount',
      obVersion: 'ObVersion',
      sessionStatistics: 'SessionStatistics',
      totalSessionCount: 'TotalSessionCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      activeSessionCount: 'number',
      allProcessList: { 'type': 'array', 'itemType': DescribeProcessStatsCompositionResponseBodyDataAllProcessList },
      idleSessionCount: 'number',
      obVersion: 'string',
      sessionStatistics: DescribeProcessStatsCompositionResponseBodyDataSessionStatistics,
      totalSessionCount: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.allProcessList)) {
      $dara.Model.validateArray(this.allProcessList);
    }
    if(this.sessionStatistics && typeof (this.sessionStatistics as any).validate === 'function') {
      (this.sessionStatistics as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataAlarmStats extends $dara.Model {
  /**
   * @example
   * null
   */
  alarmContent?: string;
  /**
   * @example
   * false
   */
  alarming?: boolean;
  /**
   * @example
   * true
   */
  openMonitor?: boolean;
  /**
   * @example
   * 0
   */
  recentlyTriggerCount?: number;
  ruleToRecentlyTriggerCount?: { [key: string]: number };
  /**
   * @example
   * null
   */
  target?: string;
  static names(): { [key: string]: string } {
    return {
      alarmContent: 'AlarmContent',
      alarming: 'Alarming',
      openMonitor: 'OpenMonitor',
      recentlyTriggerCount: 'RecentlyTriggerCount',
      ruleToRecentlyTriggerCount: 'RuleToRecentlyTriggerCount',
      target: 'Target',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alarmContent: 'string',
      alarming: 'boolean',
      openMonitor: 'boolean',
      recentlyTriggerCount: 'number',
      ruleToRecentlyTriggerCount: { 'type': 'map', 'keyType': 'string', 'valueType': 'number' },
      target: 'string',
    };
  }

  validate() {
    if(this.ruleToRecentlyTriggerCount) {
      $dara.Model.validateMap(this.ruleToRecentlyTriggerCount);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataCommonTransferConfig extends $dara.Model {
  /**
   * @example
   * true
   */
  activeActive?: boolean;
  /**
   * @example
   * null
   */
  dataWorksBusinessName?: string;
  /**
   * @example
   * TUPLE
   */
  datahubTopicType?: string;
  /**
   * @example
   * 0
   */
  mqPartition?: number;
  /**
   * @example
   * ONE
   */
  mqPartitionMode?: string;
  /**
   * @example
   * DEFAULT
   */
  mqSerializerType?: string;
  /**
   * @example
   * true
   */
  rocketMqEnableMsgTrace?: boolean;
  /**
   * @example
   * default_tag
   */
  rocketMqMsgTags?: string;
  /**
   * @example
   * OMS
   */
  rocketMqProducerGroup?: string;
  /**
   * @example
   * null
   */
  rocketMqSendMsgTimeout?: number;
  sinkStoreFormat?: string;
  sourceStoreFormat?: string;
  /**
   * @example
   * ALL
   */
  tableCategory?: string;
  static names(): { [key: string]: string } {
    return {
      activeActive: 'ActiveActive',
      dataWorksBusinessName: 'DataWorksBusinessName',
      datahubTopicType: 'DatahubTopicType',
      mqPartition: 'MqPartition',
      mqPartitionMode: 'MqPartitionMode',
      mqSerializerType: 'MqSerializerType',
      rocketMqEnableMsgTrace: 'RocketMqEnableMsgTrace',
      rocketMqMsgTags: 'RocketMqMsgTags',
      rocketMqProducerGroup: 'RocketMqProducerGroup',
      rocketMqSendMsgTimeout: 'RocketMqSendMsgTimeout',
      sinkStoreFormat: 'SinkStoreFormat',
      sourceStoreFormat: 'SourceStoreFormat',
      tableCategory: 'TableCategory',
    };
  }

  static types(): { [key: string]: any } {
    return {
      activeActive: 'boolean',
      dataWorksBusinessName: 'string',
      datahubTopicType: 'string',
      mqPartition: 'number',
      mqPartitionMode: 'string',
      mqSerializerType: 'string',
      rocketMqEnableMsgTrace: 'boolean',
      rocketMqMsgTags: 'string',
      rocketMqProducerGroup: 'string',
      rocketMqSendMsgTimeout: 'number',
      sinkStoreFormat: 'string',
      sourceStoreFormat: 'string',
      tableCategory: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataExtraInfo extends $dara.Model {
  /**
   * @example
   * true
   */
  accessObSource?: boolean;
  /**
   * @example
   * false
   */
  ignoreUnsupportDdl?: boolean;
  /**
   * @example
   * 1689244596
   */
  incrSyncTimestamp?: number;
  /**
   * @example
   * 1689214358
   */
  logServiceStartCheckpoint?: number;
  /**
   * @example
   * -1
   */
  maxConnectorCount?: number;
  /**
   * @example
   * true
   */
  monitoringIncr?: boolean;
  /**
   * @example
   * true
   */
  overwriteConfig?: boolean;
  reverseSubtopics?: string[];
  /**
   * @example
   * 90
   */
  runningProgress?: number;
  /**
   * @example
   * PRE-CHECK
   */
  runningStep?: string;
  /**
   * @example
   * 24
   */
  sourceStoreKeptHour?: number;
  /**
   * @example
   * true
   */
  storeIncr?: boolean;
  subConds?: { [key: string]: DataExtraInfoSubCondsValue[] };
  subDbs?: { [key: string]: DataExtraInfoSubDbsValue[] };
  subIds?: { [key: string]: string };
  subtopics?: string[];
  /**
   * @example
   * null
   */
  syncDelay?: number;
  /**
   * @example
   * 1689214358
   */
  syncDelaySampleTimestamp?: number;
  static names(): { [key: string]: string } {
    return {
      accessObSource: 'AccessObSource',
      ignoreUnsupportDdl: 'IgnoreUnsupportDdl',
      incrSyncTimestamp: 'IncrSyncTimestamp',
      logServiceStartCheckpoint: 'LogServiceStartCheckpoint',
      maxConnectorCount: 'MaxConnectorCount',
      monitoringIncr: 'MonitoringIncr',
      overwriteConfig: 'OverwriteConfig',
      reverseSubtopics: 'ReverseSubtopics',
      runningProgress: 'RunningProgress',
      runningStep: 'RunningStep',
      sourceStoreKeptHour: 'SourceStoreKeptHour',
      storeIncr: 'StoreIncr',
      subConds: 'SubConds',
      subDbs: 'SubDbs',
      subIds: 'SubIds',
      subtopics: 'Subtopics',
      syncDelay: 'SyncDelay',
      syncDelaySampleTimestamp: 'SyncDelaySampleTimestamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessObSource: 'boolean',
      ignoreUnsupportDdl: 'boolean',
      incrSyncTimestamp: 'number',
      logServiceStartCheckpoint: 'number',
      maxConnectorCount: 'number',
      monitoringIncr: 'boolean',
      overwriteConfig: 'boolean',
      reverseSubtopics: { 'type': 'array', 'itemType': 'string' },
      runningProgress: 'number',
      runningStep: 'string',
      sourceStoreKeptHour: 'number',
      storeIncr: 'boolean',
      subConds: { 'type': 'map', 'keyType': 'string', 'valueType': { 'type': 'array', 'itemType': DataExtraInfoSubCondsValue } },
      subDbs: { 'type': 'map', 'keyType': 'string', 'valueType': { 'type': 'array', 'itemType': DataExtraInfoSubDbsValue } },
      subIds: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      subtopics: { 'type': 'array', 'itemType': 'string' },
      syncDelay: 'number',
      syncDelaySampleTimestamp: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.reverseSubtopics)) {
      $dara.Model.validateArray(this.reverseSubtopics);
    }
    if(this.subConds) {
      $dara.Model.validateMap(this.subConds);
    }
    if(this.subDbs) {
      $dara.Model.validateMap(this.subDbs);
    }
    if(this.subIds) {
      $dara.Model.validateMap(this.subIds);
    }
    if(Array.isArray(this.subtopics)) {
      $dara.Model.validateArray(this.subtopics);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataFullTransferConfig extends $dara.Model {
  /**
   * @example
   * true
   */
  allowDestTableNotEmpty?: boolean;
  /**
   * @example
   * FAST
   */
  fullTransferSpeedMode?: string;
  /**
   * @example
   * FAST
   */
  fullVerifySpeedMode?: string;
  /**
   * @example
   * false
   */
  nonePkUkTruncateDstTable?: boolean;
  readWorkerNum?: number;
  throttleIOPS?: number;
  throttleRps?: number;
  writeWorkerNum?: number;
  static names(): { [key: string]: string } {
    return {
      allowDestTableNotEmpty: 'AllowDestTableNotEmpty',
      fullTransferSpeedMode: 'FullTransferSpeedMode',
      fullVerifySpeedMode: 'FullVerifySpeedMode',
      nonePkUkTruncateDstTable: 'NonePkUkTruncateDstTable',
      readWorkerNum: 'ReadWorkerNum',
      throttleIOPS: 'ThrottleIOPS',
      throttleRps: 'ThrottleRps',
      writeWorkerNum: 'WriteWorkerNum',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allowDestTableNotEmpty: 'boolean',
      fullTransferSpeedMode: 'string',
      fullVerifySpeedMode: 'string',
      nonePkUkTruncateDstTable: 'boolean',
      readWorkerNum: 'number',
      throttleIOPS: 'number',
      throttleRps: 'number',
      writeWorkerNum: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataIncrTransferConfig extends $dara.Model {
  /**
   * @example
   * true
   */
  enableIncrSyncStatistics?: boolean;
  /**
   * @example
   * false
   */
  enableSequencingWithinTxn?: boolean;
  /**
   * @example
   * 64
   */
  incrSyncConcurrency?: number;
  recordTypeWhiteList?: string[];
  /**
   * @example
   * 1667286900
   */
  startTimestamp?: number;
  /**
   * @example
   * 24
   */
  storeLogKeptHour?: number;
  supportDDLTypes?: string[];
  throttleIOPS?: number;
  throttleRps?: number;
  static names(): { [key: string]: string } {
    return {
      enableIncrSyncStatistics: 'EnableIncrSyncStatistics',
      enableSequencingWithinTxn: 'EnableSequencingWithinTxn',
      incrSyncConcurrency: 'IncrSyncConcurrency',
      recordTypeWhiteList: 'RecordTypeWhiteList',
      startTimestamp: 'StartTimestamp',
      storeLogKeptHour: 'StoreLogKeptHour',
      supportDDLTypes: 'SupportDDLTypes',
      throttleIOPS: 'ThrottleIOPS',
      throttleRps: 'ThrottleRps',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enableIncrSyncStatistics: 'boolean',
      enableSequencingWithinTxn: 'boolean',
      incrSyncConcurrency: 'number',
      recordTypeWhiteList: { 'type': 'array', 'itemType': 'string' },
      startTimestamp: 'number',
      storeLogKeptHour: 'number',
      supportDDLTypes: { 'type': 'array', 'itemType': 'string' },
      throttleIOPS: 'number',
      throttleRps: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.recordTypeWhiteList)) {
      $dara.Model.validateArray(this.recordTypeWhiteList);
    }
    if(Array.isArray(this.supportDDLTypes)) {
      $dara.Model.validateArray(this.supportDDLTypes);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataLabels extends $dara.Model {
  /**
   * @example
   * l_dr****
   */
  id?: string;
  /**
   * @example
   * test_tag
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      name: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataReverseIncrTransferConfig extends $dara.Model {
  enableIncrSyncStatistics?: boolean;
  enableSequencingWithinTxn?: boolean;
  incrSyncConcurrency?: number;
  recordTypeWhiteList?: string[];
  startTimestamp?: number;
  storeLogKeptHour?: number;
  supportDDLTypes?: string[];
  throttleIOPS?: number;
  throttleRps?: number;
  static names(): { [key: string]: string } {
    return {
      enableIncrSyncStatistics: 'EnableIncrSyncStatistics',
      enableSequencingWithinTxn: 'EnableSequencingWithinTxn',
      incrSyncConcurrency: 'IncrSyncConcurrency',
      recordTypeWhiteList: 'RecordTypeWhiteList',
      startTimestamp: 'StartTimestamp',
      storeLogKeptHour: 'StoreLogKeptHour',
      supportDDLTypes: 'SupportDDLTypes',
      throttleIOPS: 'ThrottleIOPS',
      throttleRps: 'ThrottleRps',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enableIncrSyncStatistics: 'boolean',
      enableSequencingWithinTxn: 'boolean',
      incrSyncConcurrency: 'number',
      recordTypeWhiteList: { 'type': 'array', 'itemType': 'string' },
      startTimestamp: 'number',
      storeLogKeptHour: 'number',
      supportDDLTypes: { 'type': 'array', 'itemType': 'string' },
      throttleIOPS: 'number',
      throttleRps: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.recordTypeWhiteList)) {
      $dara.Model.validateArray(this.recordTypeWhiteList);
    }
    if(Array.isArray(this.supportDDLTypes)) {
      $dara.Model.validateArray(this.supportDDLTypes);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataSinkConnectInfo extends $dara.Model {
  /**
   * @example
   * utf8mb4
   */
  charset?: string;
  /**
   * @example
   * null
   */
  connExtraAttributes?: any;
  /**
   * @example
   * null
   */
  connectionInfo?: string;
  /**
   * @example
   * MYSQL_PUBLIC
   */
  dbEngine?: string;
  /**
   * @example
   * e_4w1q****
   */
  endpointId?: string;
  /**
   * @example
   * RATION12948*****
   */
  endpointName?: string;
  /**
   * @example
   * sink
   */
  endpointSide?: string;
  /**
   * @example
   * xxx.xxx.xxx.1
   */
  host?: string;
  /**
   * @example
   * e_4lgzuzi9znr4
   */
  id?: string;
  /**
   * @example
   * null
   */
  nlsLengthSemantics?: string;
  /**
   * @example
   * null
   */
  ocpName?: string;
  /**
   * @example
   * Linux
   */
  operatingSystem?: string;
  /**
   * @remarks
   * Owner。
   * 
   * @example
   * oms_test
   */
  owner?: string;
  /**
   * @example
   * 2883
   */
  port?: number;
  /**
   * @example
   * cn-hangzhou
   */
  region?: string;
  /**
   * @example
   * 1325847***
   */
  resourceOwner?: string;
  /**
   * @example
   * +08:00
   */
  timezone?: string;
  /**
   * @example
   * oms2027obmysql@oms_***
   */
  username?: string;
  /**
   * @example
   * 2.2.77
   */
  version?: string;
  static names(): { [key: string]: string } {
    return {
      charset: 'Charset',
      connExtraAttributes: 'ConnExtraAttributes',
      connectionInfo: 'ConnectionInfo',
      dbEngine: 'DbEngine',
      endpointId: 'EndpointId',
      endpointName: 'EndpointName',
      endpointSide: 'EndpointSide',
      host: 'Host',
      id: 'Id',
      nlsLengthSemantics: 'NlsLengthSemantics',
      ocpName: 'OcpName',
      operatingSystem: 'OperatingSystem',
      owner: 'Owner',
      port: 'Port',
      region: 'Region',
      resourceOwner: 'ResourceOwner',
      timezone: 'Timezone',
      username: 'Username',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      charset: 'string',
      connExtraAttributes: 'any',
      connectionInfo: 'string',
      dbEngine: 'string',
      endpointId: 'string',
      endpointName: 'string',
      endpointSide: 'string',
      host: 'string',
      id: 'string',
      nlsLengthSemantics: 'string',
      ocpName: 'string',
      operatingSystem: 'string',
      owner: 'string',
      port: 'number',
      region: 'string',
      resourceOwner: 'string',
      timezone: 'string',
      username: 'string',
      version: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataSourceConnectInfo extends $dara.Model {
  /**
   * @example
   * utf8mb4
   */
  charset?: string;
  /**
   * @example
   * null
   */
  connExtraAttributes?: any;
  /**
   * @example
   * null
   */
  connectionInfo?: string;
  /**
   * @example
   * OB_MYSQL_PUBLIC
   */
  dbEngine?: string;
  /**
   * @example
   * e_3kx5i***1s
   */
  endpointId?: string;
  /**
   * @example
   * migon****
   */
  endpointName?: string;
  /**
   * @example
   * source
   */
  endpointSide?: string;
  /**
   * @example
   * xxx.xxx.xxx.1
   */
  host?: string;
  /**
   * @example
   * c_feg****
   */
  id?: string;
  /**
   * @example
   * null
   */
  nlsLengthSemantics?: string;
  /**
   * @example
   * null
   */
  ocpName?: string;
  /**
   * @example
   * Linux
   */
  operatingSystem?: string;
  /**
   * @remarks
   * Owner。
   * 
   * @example
   * oms_test
   */
  owner?: string;
  /**
   * @example
   * 2883
   */
  port?: number;
  /**
   * @example
   * cn-shanghai
   */
  region?: string;
  /**
   * @example
   * 1325847***
   */
  resourceOwner?: string;
  /**
   * @example
   * +08:00
   */
  timezone?: string;
  /**
   * @example
   * oms2027obmysql@oms_***
   */
  username?: string;
  /**
   * @example
   * 2.2.77
   */
  version?: string;
  static names(): { [key: string]: string } {
    return {
      charset: 'Charset',
      connExtraAttributes: 'ConnExtraAttributes',
      connectionInfo: 'ConnectionInfo',
      dbEngine: 'DbEngine',
      endpointId: 'EndpointId',
      endpointName: 'EndpointName',
      endpointSide: 'EndpointSide',
      host: 'Host',
      id: 'Id',
      nlsLengthSemantics: 'NlsLengthSemantics',
      ocpName: 'OcpName',
      operatingSystem: 'OperatingSystem',
      owner: 'Owner',
      port: 'Port',
      region: 'Region',
      resourceOwner: 'ResourceOwner',
      timezone: 'Timezone',
      username: 'Username',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      charset: 'string',
      connExtraAttributes: 'any',
      connectionInfo: 'string',
      dbEngine: 'string',
      endpointId: 'string',
      endpointName: 'string',
      endpointSide: 'string',
      host: 'string',
      id: 'string',
      nlsLengthSemantics: 'string',
      ocpName: 'string',
      operatingSystem: 'string',
      owner: 'string',
      port: 'number',
      region: 'string',
      resourceOwner: 'string',
      timezone: 'string',
      username: 'string',
      version: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataStepsExtraInfoErrorDetails extends $dara.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @remarks
   * FATAL, ERROR, WARNING, CRITICAL
   * 
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * Contact the administrator.
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  validate() {
    if(this.extraContext) {
      $dara.Model.validateMap(this.extraContext);
    }
    if(this.messageMcmsContext) {
      $dara.Model.validateMap(this.messageMcmsContext);
    }
    if(this.proposalMcmsContext) {
      $dara.Model.validateMap(this.proposalMcmsContext);
    }
    if(this.reasonMcmsContext) {
      $dara.Model.validateMap(this.reasonMcmsContext);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataStepsExtraInfo extends $dara.Model {
  /**
   * @example
   * INNER_ERROR
   */
  errorCode?: string;
  errorDetails?: DescribeProjectResponseBodyDataStepsExtraInfoErrorDetails[];
  /**
   * @example
   * A system error occurred.
   */
  errorMsg?: string;
  errorParam?: { [key: string]: string };
  /**
   * @example
   * null
   */
  failedTime?: string;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorDetails: 'ErrorDetails',
      errorMsg: 'ErrorMsg',
      errorParam: 'ErrorParam',
      failedTime: 'FailedTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorDetails: { 'type': 'array', 'itemType': DescribeProjectResponseBodyDataStepsExtraInfoErrorDetails },
      errorMsg: 'string',
      errorParam: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      failedTime: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.errorDetails)) {
      $dara.Model.validateArray(this.errorDetails);
    }
    if(this.errorParam) {
      $dara.Model.validateMap(this.errorParam);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataSteps extends $dara.Model {
  description?: string;
  extraInfo?: DescribeProjectResponseBodyDataStepsExtraInfo;
  /**
   * @example
   * 2020-05-22T17:04:18
   */
  finishTime?: string;
  /**
   * @example
   * PRE_CHECK
   */
  name?: string;
  /**
   * @example
   * 1
   */
  order?: number;
  /**
   * @example
   * 90
   */
  progress?: number;
  /**
   * @example
   * 2020-05-22T17:04:18
   */
  startTime?: string;
  /**
   * @example
   * RUNNING
   */
  status?: string;
  stepInfo?: { [key: string]: any };
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      extraInfo: 'ExtraInfo',
      finishTime: 'FinishTime',
      name: 'Name',
      order: 'Order',
      progress: 'Progress',
      startTime: 'StartTime',
      status: 'Status',
      stepInfo: 'StepInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      extraInfo: DescribeProjectResponseBodyDataStepsExtraInfo,
      finishTime: 'string',
      name: 'string',
      order: 'number',
      progress: 'number',
      startTime: 'string',
      status: 'string',
      stepInfo: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
    };
  }

  validate() {
    if(this.extraInfo && typeof (this.extraInfo as any).validate === 'function') {
      (this.extraInfo as any).validate();
    }
    if(this.stepInfo) {
      $dara.Model.validateMap(this.stepInfo);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataStructTransferConfig extends $dara.Model {
  /**
   * @example
   * DO_NOTHING_IF_BYTE_USED
   */
  byteCharConvertStrategy?: string;
  /**
   * @example
   * true
   */
  deferIndexCreation?: boolean;
  static names(): { [key: string]: string } {
    return {
      byteCharConvertStrategy: 'ByteCharConvertStrategy',
      deferIndexCreation: 'DeferIndexCreation',
    };
  }

  static types(): { [key: string]: any } {
    return {
      byteCharConvertStrategy: 'string',
      deferIndexCreation: 'boolean',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificTablesAdbTableSchema extends $dara.Model {
  distributedKeys?: string[];
  /**
   * @example
   * 30
   */
  partitionLifeCycle?: string;
  /**
   * @example
   * PARTITION BY VALUE(\\"id\\")
   */
  partitionStatement?: string;
  primaryKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      distributedKeys: 'DistributedKeys',
      partitionLifeCycle: 'PartitionLifeCycle',
      partitionStatement: 'PartitionStatement',
      primaryKeys: 'PrimaryKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      distributedKeys: { 'type': 'array', 'itemType': 'string' },
      partitionLifeCycle: 'string',
      partitionStatement: 'string',
      primaryKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(Array.isArray(this.distributedKeys)) {
      $dara.Model.validateArray(this.distributedKeys);
    }
    if(Array.isArray(this.primaryKeys)) {
      $dara.Model.validateArray(this.primaryKeys);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificTables extends $dara.Model {
  adbTableSchema?: DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificTablesAdbTableSchema;
  filterColumns?: string[];
  /**
   * @example
   * table_id
   */
  id?: string;
  /**
   * @example
   * mapped_table
   */
  mappedName?: string;
  /**
   * @example
   * table_name
   */
  name?: string;
  shardColumns?: string[];
  /**
   * @example
   * id>1
   */
  whereClause?: string;
  static names(): { [key: string]: string } {
    return {
      adbTableSchema: 'AdbTableSchema',
      filterColumns: 'FilterColumns',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      shardColumns: 'ShardColumns',
      whereClause: 'WhereClause',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adbTableSchema: DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificTablesAdbTableSchema,
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      mappedName: 'string',
      name: 'string',
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      whereClause: 'string',
    };
  }

  validate() {
    if(this.adbTableSchema && typeof (this.adbTableSchema as any).validate === 'function') {
      (this.adbTableSchema as any).validate();
    }
    if(Array.isArray(this.filterColumns)) {
      $dara.Model.validateArray(this.filterColumns);
    }
    if(Array.isArray(this.shardColumns)) {
      $dara.Model.validateArray(this.shardColumns);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificViewsAdbTableSchema extends $dara.Model {
  distributedKeys?: string[];
  /**
   * @example
   * 30
   */
  partitionLifeCycle?: string;
  /**
   * @example
   * PARTITION BY VALUE(\\"id\\")
   */
  partitionStatement?: string;
  primaryKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      distributedKeys: 'DistributedKeys',
      partitionLifeCycle: 'PartitionLifeCycle',
      partitionStatement: 'PartitionStatement',
      primaryKeys: 'PrimaryKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      distributedKeys: { 'type': 'array', 'itemType': 'string' },
      partitionLifeCycle: 'string',
      partitionStatement: 'string',
      primaryKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(Array.isArray(this.distributedKeys)) {
      $dara.Model.validateArray(this.distributedKeys);
    }
    if(Array.isArray(this.primaryKeys)) {
      $dara.Model.validateArray(this.primaryKeys);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificViews extends $dara.Model {
  adbTableSchema?: DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificViewsAdbTableSchema;
  filterColumns?: string[];
  /**
   * @example
   * view_id
   */
  id?: string;
  /**
   * @example
   * mapped_name
   */
  mappedName?: string;
  /**
   * @example
   * view_name
   */
  name?: string;
  shardColumns?: string[];
  /**
   * @example
   * id<3
   */
  whereClause?: string;
  static names(): { [key: string]: string } {
    return {
      adbTableSchema: 'AdbTableSchema',
      filterColumns: 'FilterColumns',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      shardColumns: 'ShardColumns',
      whereClause: 'WhereClause',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adbTableSchema: DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificViewsAdbTableSchema,
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      mappedName: 'string',
      name: 'string',
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      whereClause: 'string',
    };
  }

  validate() {
    if(this.adbTableSchema && typeof (this.adbTableSchema as any).validate === 'function') {
      (this.adbTableSchema as any).validate();
    }
    if(Array.isArray(this.filterColumns)) {
      $dara.Model.validateArray(this.filterColumns);
    }
    if(Array.isArray(this.shardColumns)) {
      $dara.Model.validateArray(this.shardColumns);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataTransferMappingDatabasesTablesAdbTableSchema extends $dara.Model {
  distributedKeys?: string[];
  /**
   * @example
   * 30
   */
  partitionLifeCycle?: string;
  /**
   * @example
   * PARTITION BY VALUE(\\"id\\")
   */
  partitionStatement?: string;
  primaryKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      distributedKeys: 'DistributedKeys',
      partitionLifeCycle: 'PartitionLifeCycle',
      partitionStatement: 'PartitionStatement',
      primaryKeys: 'PrimaryKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      distributedKeys: { 'type': 'array', 'itemType': 'string' },
      partitionLifeCycle: 'string',
      partitionStatement: 'string',
      primaryKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(Array.isArray(this.distributedKeys)) {
      $dara.Model.validateArray(this.distributedKeys);
    }
    if(Array.isArray(this.primaryKeys)) {
      $dara.Model.validateArray(this.primaryKeys);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataTransferMappingDatabasesTables extends $dara.Model {
  adbTableSchema?: DescribeProjectResponseBodyDataTransferMappingDatabasesTablesAdbTableSchema;
  filterColumns?: string[];
  /**
   * @example
   * table_id
   */
  id?: string;
  /**
   * @example
   * mapped_table
   */
  mappedName?: string;
  /**
   * @example
   * table_name
   */
  name?: string;
  shardColumns?: string[];
  /**
   * @example
   * id > 1
   */
  whereClause?: string;
  static names(): { [key: string]: string } {
    return {
      adbTableSchema: 'AdbTableSchema',
      filterColumns: 'FilterColumns',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      shardColumns: 'ShardColumns',
      whereClause: 'WhereClause',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adbTableSchema: DescribeProjectResponseBodyDataTransferMappingDatabasesTablesAdbTableSchema,
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      mappedName: 'string',
      name: 'string',
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      whereClause: 'string',
    };
  }

  validate() {
    if(this.adbTableSchema && typeof (this.adbTableSchema as any).validate === 'function') {
      (this.adbTableSchema as any).validate();
    }
    if(Array.isArray(this.filterColumns)) {
      $dara.Model.validateArray(this.filterColumns);
    }
    if(Array.isArray(this.shardColumns)) {
      $dara.Model.validateArray(this.shardColumns);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataTransferMappingDatabasesViewsAdbTableSchema extends $dara.Model {
  distributedKeys?: string[];
  /**
   * @example
   * 30
   */
  partitionLifeCycle?: string;
  /**
   * @example
   * PARTITION BY VALUE(\\"id\\")
   */
  partitionStatement?: string;
  primaryKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      distributedKeys: 'DistributedKeys',
      partitionLifeCycle: 'PartitionLifeCycle',
      partitionStatement: 'PartitionStatement',
      primaryKeys: 'PrimaryKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      distributedKeys: { 'type': 'array', 'itemType': 'string' },
      partitionLifeCycle: 'string',
      partitionStatement: 'string',
      primaryKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(Array.isArray(this.distributedKeys)) {
      $dara.Model.validateArray(this.distributedKeys);
    }
    if(Array.isArray(this.primaryKeys)) {
      $dara.Model.validateArray(this.primaryKeys);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataTransferMappingDatabasesViews extends $dara.Model {
  adbTableSchema?: DescribeProjectResponseBodyDataTransferMappingDatabasesViewsAdbTableSchema;
  filterColumns?: string[];
  /**
   * @example
   * fexdg***
   */
  id?: string;
  /**
   * @example
   * mapped_view
   */
  mappedName?: string;
  /**
   * @example
   * view_name
   */
  name?: string;
  shardColumns?: string[];
  /**
   * @example
   * id < 1
   */
  whereClause?: string;
  static names(): { [key: string]: string } {
    return {
      adbTableSchema: 'AdbTableSchema',
      filterColumns: 'FilterColumns',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      shardColumns: 'ShardColumns',
      whereClause: 'WhereClause',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adbTableSchema: DescribeProjectResponseBodyDataTransferMappingDatabasesViewsAdbTableSchema,
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      mappedName: 'string',
      name: 'string',
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      whereClause: 'string',
    };
  }

  validate() {
    if(this.adbTableSchema && typeof (this.adbTableSchema as any).validate === 'function') {
      (this.adbTableSchema as any).validate();
    }
    if(Array.isArray(this.filterColumns)) {
      $dara.Model.validateArray(this.filterColumns);
    }
    if(Array.isArray(this.shardColumns)) {
      $dara.Model.validateArray(this.shardColumns);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataTransferMappingDatabases extends $dara.Model {
  /**
   * @example
   * db_id
   */
  id?: string;
  /**
   * @example
   * mapped_db
   */
  mappedName?: string;
  /**
   * @example
   * db_name
   */
  name?: string;
  specificTables?: DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificTables[];
  specificViews?: DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificViews[];
  tables?: DescribeProjectResponseBodyDataTransferMappingDatabasesTables[];
  /**
   * @example
   * tenant_name
   */
  tenantName?: string;
  /**
   * @example
   * MYSQL
   */
  type?: string;
  views?: DescribeProjectResponseBodyDataTransferMappingDatabasesViews[];
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      specificTables: 'SpecificTables',
      specificViews: 'SpecificViews',
      tables: 'Tables',
      tenantName: 'TenantName',
      type: 'Type',
      views: 'Views',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      mappedName: 'string',
      name: 'string',
      specificTables: { 'type': 'array', 'itemType': DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificTables },
      specificViews: { 'type': 'array', 'itemType': DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificViews },
      tables: { 'type': 'array', 'itemType': DescribeProjectResponseBodyDataTransferMappingDatabasesTables },
      tenantName: 'string',
      type: 'string',
      views: { 'type': 'array', 'itemType': DescribeProjectResponseBodyDataTransferMappingDatabasesViews },
    };
  }

  validate() {
    if(Array.isArray(this.specificTables)) {
      $dara.Model.validateArray(this.specificTables);
    }
    if(Array.isArray(this.specificViews)) {
      $dara.Model.validateArray(this.specificViews);
    }
    if(Array.isArray(this.tables)) {
      $dara.Model.validateArray(this.tables);
    }
    if(Array.isArray(this.views)) {
      $dara.Model.validateArray(this.views);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificTablesAdbTableSchema extends $dara.Model {
  distributedKeys?: string[];
  /**
   * @example
   * 30
   */
  partitionLifeCycle?: string;
  /**
   * @example
   * PARTITION BY VALUE(\\"id\\")
   */
  partitionStatement?: string;
  primaryKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      distributedKeys: 'DistributedKeys',
      partitionLifeCycle: 'PartitionLifeCycle',
      partitionStatement: 'PartitionStatement',
      primaryKeys: 'PrimaryKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      distributedKeys: { 'type': 'array', 'itemType': 'string' },
      partitionLifeCycle: 'string',
      partitionStatement: 'string',
      primaryKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(Array.isArray(this.distributedKeys)) {
      $dara.Model.validateArray(this.distributedKeys);
    }
    if(Array.isArray(this.primaryKeys)) {
      $dara.Model.validateArray(this.primaryKeys);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificTables extends $dara.Model {
  adbTableSchema?: DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificTablesAdbTableSchema;
  filterColumns?: string[];
  /**
   * @example
   * table_id
   */
  id?: string;
  /**
   * @example
   * mapped_table
   */
  mappedName?: string;
  /**
   * @example
   * table_name
   */
  name?: string;
  shardColumns?: string[];
  /**
   * @example
   * id<3
   */
  whereClause?: string;
  static names(): { [key: string]: string } {
    return {
      adbTableSchema: 'AdbTableSchema',
      filterColumns: 'FilterColumns',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      shardColumns: 'ShardColumns',
      whereClause: 'WhereClause',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adbTableSchema: DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificTablesAdbTableSchema,
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      mappedName: 'string',
      name: 'string',
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      whereClause: 'string',
    };
  }

  validate() {
    if(this.adbTableSchema && typeof (this.adbTableSchema as any).validate === 'function') {
      (this.adbTableSchema as any).validate();
    }
    if(Array.isArray(this.filterColumns)) {
      $dara.Model.validateArray(this.filterColumns);
    }
    if(Array.isArray(this.shardColumns)) {
      $dara.Model.validateArray(this.shardColumns);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificViewsAdbTableSchema extends $dara.Model {
  distributedKeys?: string[];
  /**
   * @example
   * 30
   */
  partitionLifeCycle?: string;
  /**
   * @example
   * PARTITION BY VALUE(\\"id\\")
   */
  partitionStatement?: string;
  primaryKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      distributedKeys: 'DistributedKeys',
      partitionLifeCycle: 'PartitionLifeCycle',
      partitionStatement: 'PartitionStatement',
      primaryKeys: 'PrimaryKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      distributedKeys: { 'type': 'array', 'itemType': 'string' },
      partitionLifeCycle: 'string',
      partitionStatement: 'string',
      primaryKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(Array.isArray(this.distributedKeys)) {
      $dara.Model.validateArray(this.distributedKeys);
    }
    if(Array.isArray(this.primaryKeys)) {
      $dara.Model.validateArray(this.primaryKeys);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificViews extends $dara.Model {
  adbTableSchema?: DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificViewsAdbTableSchema;
  filterColumns?: string[];
  /**
   * @example
   * view_id
   */
  id?: string;
  /**
   * @example
   * mapped_view
   */
  mappedName?: string;
  /**
   * @example
   * view_name
   */
  name?: string;
  shardColumns?: string[];
  /**
   * @example
   * id>2
   */
  whereClause?: string;
  static names(): { [key: string]: string } {
    return {
      adbTableSchema: 'AdbTableSchema',
      filterColumns: 'FilterColumns',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      shardColumns: 'ShardColumns',
      whereClause: 'WhereClause',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adbTableSchema: DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificViewsAdbTableSchema,
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      mappedName: 'string',
      name: 'string',
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      whereClause: 'string',
    };
  }

  validate() {
    if(this.adbTableSchema && typeof (this.adbTableSchema as any).validate === 'function') {
      (this.adbTableSchema as any).validate();
    }
    if(Array.isArray(this.filterColumns)) {
      $dara.Model.validateArray(this.filterColumns);
    }
    if(Array.isArray(this.shardColumns)) {
      $dara.Model.validateArray(this.shardColumns);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataTransferMappingDatabasesBlackTablesAdbTableSchema extends $dara.Model {
  distributedKeys?: string[];
  /**
   * @example
   * 30
   */
  partitionLifeCycle?: string;
  /**
   * @example
   * PARTITION BY VALUE(\\"id\\")
   */
  partitionStatement?: string;
  primaryKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      distributedKeys: 'DistributedKeys',
      partitionLifeCycle: 'PartitionLifeCycle',
      partitionStatement: 'PartitionStatement',
      primaryKeys: 'PrimaryKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      distributedKeys: { 'type': 'array', 'itemType': 'string' },
      partitionLifeCycle: 'string',
      partitionStatement: 'string',
      primaryKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(Array.isArray(this.distributedKeys)) {
      $dara.Model.validateArray(this.distributedKeys);
    }
    if(Array.isArray(this.primaryKeys)) {
      $dara.Model.validateArray(this.primaryKeys);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataTransferMappingDatabasesBlackTables extends $dara.Model {
  adbTableSchema?: DescribeProjectResponseBodyDataTransferMappingDatabasesBlackTablesAdbTableSchema;
  filterColumns?: string[];
  /**
   * @example
   * table_id
   */
  id?: string;
  /**
   * @example
   * mapped_table
   */
  mappedName?: string;
  /**
   * @example
   * table_name
   */
  name?: string;
  shardColumns?: string[];
  /**
   * @example
   * id>1
   */
  whereClause?: string;
  static names(): { [key: string]: string } {
    return {
      adbTableSchema: 'AdbTableSchema',
      filterColumns: 'FilterColumns',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      shardColumns: 'ShardColumns',
      whereClause: 'WhereClause',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adbTableSchema: DescribeProjectResponseBodyDataTransferMappingDatabasesBlackTablesAdbTableSchema,
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      mappedName: 'string',
      name: 'string',
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      whereClause: 'string',
    };
  }

  validate() {
    if(this.adbTableSchema && typeof (this.adbTableSchema as any).validate === 'function') {
      (this.adbTableSchema as any).validate();
    }
    if(Array.isArray(this.filterColumns)) {
      $dara.Model.validateArray(this.filterColumns);
    }
    if(Array.isArray(this.shardColumns)) {
      $dara.Model.validateArray(this.shardColumns);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataTransferMappingDatabasesBlackViewsAdbTableSchema extends $dara.Model {
  distributedKeys?: string[];
  /**
   * @example
   * 30
   */
  partitionLifeCycle?: string;
  /**
   * @example
   * PARTITION BY VALUE(\\"id\\")
   */
  partitionStatement?: string;
  primaryKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      distributedKeys: 'DistributedKeys',
      partitionLifeCycle: 'PartitionLifeCycle',
      partitionStatement: 'PartitionStatement',
      primaryKeys: 'PrimaryKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      distributedKeys: { 'type': 'array', 'itemType': 'string' },
      partitionLifeCycle: 'string',
      partitionStatement: 'string',
      primaryKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(Array.isArray(this.distributedKeys)) {
      $dara.Model.validateArray(this.distributedKeys);
    }
    if(Array.isArray(this.primaryKeys)) {
      $dara.Model.validateArray(this.primaryKeys);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataTransferMappingDatabasesBlackViews extends $dara.Model {
  adbTableSchema?: DescribeProjectResponseBodyDataTransferMappingDatabasesBlackViewsAdbTableSchema;
  filterColumns?: string[];
  /**
   * @example
   * view_id
   */
  id?: string;
  /**
   * @example
   * mapped_name
   */
  mappedName?: string;
  /**
   * @example
   * view_name
   */
  name?: string;
  shardColumns?: string[];
  /**
   * @example
   * id>2
   */
  whereClause?: string;
  static names(): { [key: string]: string } {
    return {
      adbTableSchema: 'AdbTableSchema',
      filterColumns: 'FilterColumns',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      shardColumns: 'ShardColumns',
      whereClause: 'WhereClause',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adbTableSchema: DescribeProjectResponseBodyDataTransferMappingDatabasesBlackViewsAdbTableSchema,
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      mappedName: 'string',
      name: 'string',
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      whereClause: 'string',
    };
  }

  validate() {
    if(this.adbTableSchema && typeof (this.adbTableSchema as any).validate === 'function') {
      (this.adbTableSchema as any).validate();
    }
    if(Array.isArray(this.filterColumns)) {
      $dara.Model.validateArray(this.filterColumns);
    }
    if(Array.isArray(this.shardColumns)) {
      $dara.Model.validateArray(this.shardColumns);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataTransferMappingDatabasesBlack extends $dara.Model {
  /**
   * @example
   * db_id
   */
  id?: string;
  /**
   * @example
   * mapped_db
   */
  mappedName?: string;
  /**
   * @example
   * db_name
   */
  name?: string;
  specificTables?: DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificTables[];
  specificViews?: DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificViews[];
  tables?: DescribeProjectResponseBodyDataTransferMappingDatabasesBlackTables[];
  /**
   * @example
   * mapped_tenant
   */
  tenantName?: string;
  /**
   * @example
   * DATABASE
   */
  type?: string;
  views?: DescribeProjectResponseBodyDataTransferMappingDatabasesBlackViews[];
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      specificTables: 'SpecificTables',
      specificViews: 'SpecificViews',
      tables: 'Tables',
      tenantName: 'TenantName',
      type: 'Type',
      views: 'Views',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      mappedName: 'string',
      name: 'string',
      specificTables: { 'type': 'array', 'itemType': DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificTables },
      specificViews: { 'type': 'array', 'itemType': DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificViews },
      tables: { 'type': 'array', 'itemType': DescribeProjectResponseBodyDataTransferMappingDatabasesBlackTables },
      tenantName: 'string',
      type: 'string',
      views: { 'type': 'array', 'itemType': DescribeProjectResponseBodyDataTransferMappingDatabasesBlackViews },
    };
  }

  validate() {
    if(Array.isArray(this.specificTables)) {
      $dara.Model.validateArray(this.specificTables);
    }
    if(Array.isArray(this.specificViews)) {
      $dara.Model.validateArray(this.specificViews);
    }
    if(Array.isArray(this.tables)) {
      $dara.Model.validateArray(this.tables);
    }
    if(Array.isArray(this.views)) {
      $dara.Model.validateArray(this.views);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataTransferMapping extends $dara.Model {
  databases?: DescribeProjectResponseBodyDataTransferMappingDatabases[];
  databasesBlack?: DescribeProjectResponseBodyDataTransferMappingDatabasesBlack[];
  /**
   * @example
   * SPECIFIC
   */
  mode?: string;
  tableAndViewBlackList?: string[];
  tableAndViewWhiteList?: string[];
  static names(): { [key: string]: string } {
    return {
      databases: 'Databases',
      databasesBlack: 'DatabasesBlack',
      mode: 'Mode',
      tableAndViewBlackList: 'TableAndViewBlackList',
      tableAndViewWhiteList: 'TableAndViewWhiteList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      databases: { 'type': 'array', 'itemType': DescribeProjectResponseBodyDataTransferMappingDatabases },
      databasesBlack: { 'type': 'array', 'itemType': DescribeProjectResponseBodyDataTransferMappingDatabasesBlack },
      mode: 'string',
      tableAndViewBlackList: { 'type': 'array', 'itemType': 'string' },
      tableAndViewWhiteList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(Array.isArray(this.databases)) {
      $dara.Model.validateArray(this.databases);
    }
    if(Array.isArray(this.databasesBlack)) {
      $dara.Model.validateArray(this.databasesBlack);
    }
    if(Array.isArray(this.tableAndViewBlackList)) {
      $dara.Model.validateArray(this.tableAndViewBlackList);
    }
    if(Array.isArray(this.tableAndViewWhiteList)) {
      $dara.Model.validateArray(this.tableAndViewWhiteList);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyDataWorkerGradeInfo extends $dara.Model {
  autoRenewal?: boolean;
  chargeType?: string;
  destRegion?: string;
  destType?: string;
  endTime?: string;
  expired?: boolean;
  gmtCreate?: string;
  grade?: string;
  id?: string;
  name?: string;
  sourceRegion?: string;
  sourceType?: string;
  spec?: string;
  specName?: string;
  static names(): { [key: string]: string } {
    return {
      autoRenewal: 'AutoRenewal',
      chargeType: 'ChargeType',
      destRegion: 'DestRegion',
      destType: 'DestType',
      endTime: 'EndTime',
      expired: 'Expired',
      gmtCreate: 'GmtCreate',
      grade: 'Grade',
      id: 'Id',
      name: 'Name',
      sourceRegion: 'SourceRegion',
      sourceType: 'SourceType',
      spec: 'Spec',
      specName: 'SpecName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoRenewal: 'boolean',
      chargeType: 'string',
      destRegion: 'string',
      destType: 'string',
      endTime: 'string',
      expired: 'boolean',
      gmtCreate: 'string',
      grade: 'string',
      id: 'string',
      name: 'string',
      sourceRegion: 'string',
      sourceType: 'string',
      spec: 'string',
      specName: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyData extends $dara.Model {
  alarmStats?: DescribeProjectResponseBodyDataAlarmStats;
  commonTransferConfig?: DescribeProjectResponseBodyDataCommonTransferConfig;
  /**
   * @example
   * c_deg***
   */
  destConnId?: string;
  /**
   * @example
   * true
   */
  enableFullTransfer?: boolean;
  /**
   * @example
   * true
   */
  enableFullVerify?: boolean;
  /**
   * @example
   * true
   */
  enableIncrTransfer?: boolean;
  /**
   * @example
   * true
   */
  enableIncrVerify?: boolean;
  /**
   * @example
   * true
   */
  enableReverseIncrTransfer?: boolean;
  /**
   * @example
   * true
   */
  enableStructTransfer?: boolean;
  extraInfo?: DescribeProjectResponseBodyDataExtraInfo;
  fullTransferConfig?: DescribeProjectResponseBodyDataFullTransferConfig;
  /**
   * @example
   * 2023-07-13T06:26:15
   */
  gmtCreate?: string;
  /**
   * @example
   * 2023-07-13T07:02:27
   */
  gmtFinish?: string;
  /**
   * @example
   * 2023-07-13T06:26:15
   */
  gmtModified?: string;
  /**
   * @example
   * 2023-07-13T07:02:27
   */
  gmtStart?: string;
  /**
   * @example
   * np_fe****
   */
  id?: string;
  /**
   * @example
   * HIGH
   */
  importance?: string;
  incrTransferConfig?: DescribeProjectResponseBodyDataIncrTransferConfig;
  /**
   * @example
   * false
   */
  isMerging?: boolean;
  /**
   * @example
   * false
   */
  isModifying?: boolean;
  /**
   * @example
   * false
   */
  isSubProject?: boolean;
  labels?: DescribeProjectResponseBodyDataLabels[];
  /**
   * @example
   * test
   */
  name?: string;
  /**
   * @example
   * omsefry***
   */
  owner?: string;
  reverseIncrTransferConfig?: DescribeProjectResponseBodyDataReverseIncrTransferConfig;
  sinkConnectInfo?: DescribeProjectResponseBodyDataSinkConnectInfo;
  /**
   * @example
   * MYSQL
   */
  sinkEndpointType?: string;
  sourceConnectInfo?: DescribeProjectResponseBodyDataSourceConnectInfo;
  /**
   * @example
   * OB_MYSQL
   */
  sourceEndpointType?: string;
  /**
   * @example
   * RUNNING
   */
  status?: string;
  steps?: DescribeProjectResponseBodyDataSteps[];
  structTransferConfig?: DescribeProjectResponseBodyDataStructTransferConfig;
  transferMapping?: DescribeProjectResponseBodyDataTransferMapping;
  /**
   * @example
   * SYNC
   */
  type?: string;
  /**
   * @example
   * g_i4wa7XXX
   */
  workerGradeId?: string;
  workerGradeInfo?: DescribeProjectResponseBodyDataWorkerGradeInfo;
  static names(): { [key: string]: string } {
    return {
      alarmStats: 'AlarmStats',
      commonTransferConfig: 'CommonTransferConfig',
      destConnId: 'DestConnId',
      enableFullTransfer: 'EnableFullTransfer',
      enableFullVerify: 'EnableFullVerify',
      enableIncrTransfer: 'EnableIncrTransfer',
      enableIncrVerify: 'EnableIncrVerify',
      enableReverseIncrTransfer: 'EnableReverseIncrTransfer',
      enableStructTransfer: 'EnableStructTransfer',
      extraInfo: 'ExtraInfo',
      fullTransferConfig: 'FullTransferConfig',
      gmtCreate: 'GmtCreate',
      gmtFinish: 'GmtFinish',
      gmtModified: 'GmtModified',
      gmtStart: 'GmtStart',
      id: 'Id',
      importance: 'Importance',
      incrTransferConfig: 'IncrTransferConfig',
      isMerging: 'IsMerging',
      isModifying: 'IsModifying',
      isSubProject: 'IsSubProject',
      labels: 'Labels',
      name: 'Name',
      owner: 'Owner',
      reverseIncrTransferConfig: 'ReverseIncrTransferConfig',
      sinkConnectInfo: 'SinkConnectInfo',
      sinkEndpointType: 'SinkEndpointType',
      sourceConnectInfo: 'SourceConnectInfo',
      sourceEndpointType: 'SourceEndpointType',
      status: 'Status',
      steps: 'Steps',
      structTransferConfig: 'StructTransferConfig',
      transferMapping: 'TransferMapping',
      type: 'Type',
      workerGradeId: 'WorkerGradeId',
      workerGradeInfo: 'WorkerGradeInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alarmStats: DescribeProjectResponseBodyDataAlarmStats,
      commonTransferConfig: DescribeProjectResponseBodyDataCommonTransferConfig,
      destConnId: 'string',
      enableFullTransfer: 'boolean',
      enableFullVerify: 'boolean',
      enableIncrTransfer: 'boolean',
      enableIncrVerify: 'boolean',
      enableReverseIncrTransfer: 'boolean',
      enableStructTransfer: 'boolean',
      extraInfo: DescribeProjectResponseBodyDataExtraInfo,
      fullTransferConfig: DescribeProjectResponseBodyDataFullTransferConfig,
      gmtCreate: 'string',
      gmtFinish: 'string',
      gmtModified: 'string',
      gmtStart: 'string',
      id: 'string',
      importance: 'string',
      incrTransferConfig: DescribeProjectResponseBodyDataIncrTransferConfig,
      isMerging: 'boolean',
      isModifying: 'boolean',
      isSubProject: 'boolean',
      labels: { 'type': 'array', 'itemType': DescribeProjectResponseBodyDataLabels },
      name: 'string',
      owner: 'string',
      reverseIncrTransferConfig: DescribeProjectResponseBodyDataReverseIncrTransferConfig,
      sinkConnectInfo: DescribeProjectResponseBodyDataSinkConnectInfo,
      sinkEndpointType: 'string',
      sourceConnectInfo: DescribeProjectResponseBodyDataSourceConnectInfo,
      sourceEndpointType: 'string',
      status: 'string',
      steps: { 'type': 'array', 'itemType': DescribeProjectResponseBodyDataSteps },
      structTransferConfig: DescribeProjectResponseBodyDataStructTransferConfig,
      transferMapping: DescribeProjectResponseBodyDataTransferMapping,
      type: 'string',
      workerGradeId: 'string',
      workerGradeInfo: DescribeProjectResponseBodyDataWorkerGradeInfo,
    };
  }

  validate() {
    if(this.alarmStats && typeof (this.alarmStats as any).validate === 'function') {
      (this.alarmStats as any).validate();
    }
    if(this.commonTransferConfig && typeof (this.commonTransferConfig as any).validate === 'function') {
      (this.commonTransferConfig as any).validate();
    }
    if(this.extraInfo && typeof (this.extraInfo as any).validate === 'function') {
      (this.extraInfo as any).validate();
    }
    if(this.fullTransferConfig && typeof (this.fullTransferConfig as any).validate === 'function') {
      (this.fullTransferConfig as any).validate();
    }
    if(this.incrTransferConfig && typeof (this.incrTransferConfig as any).validate === 'function') {
      (this.incrTransferConfig as any).validate();
    }
    if(Array.isArray(this.labels)) {
      $dara.Model.validateArray(this.labels);
    }
    if(this.reverseIncrTransferConfig && typeof (this.reverseIncrTransferConfig as any).validate === 'function') {
      (this.reverseIncrTransferConfig as any).validate();
    }
    if(this.sinkConnectInfo && typeof (this.sinkConnectInfo as any).validate === 'function') {
      (this.sinkConnectInfo as any).validate();
    }
    if(this.sourceConnectInfo && typeof (this.sourceConnectInfo as any).validate === 'function') {
      (this.sourceConnectInfo as any).validate();
    }
    if(Array.isArray(this.steps)) {
      $dara.Model.validateArray(this.steps);
    }
    if(this.structTransferConfig && typeof (this.structTransferConfig as any).validate === 'function') {
      (this.structTransferConfig as any).validate();
    }
    if(this.transferMapping && typeof (this.transferMapping as any).validate === 'function') {
      (this.transferMapping as any).validate();
    }
    if(this.workerGradeInfo && typeof (this.workerGradeInfo as any).validate === 'function') {
      (this.workerGradeInfo as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBodyErrorDetail extends $dara.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * null
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  validate() {
    if(this.extraContext) {
      $dara.Model.validateMap(this.extraContext);
    }
    if(this.messageMcmsContext) {
      $dara.Model.validateMap(this.messageMcmsContext);
    }
    if(this.proposalMcmsContext) {
      $dara.Model.validateMap(this.proposalMcmsContext);
    }
    if(this.reasonMcmsContext) {
      $dara.Model.validateMap(this.reasonMcmsContext);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectComponentsResponseBodyDataFullImportComponentsErrorDetails extends $dara.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * null
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  validate() {
    if(this.extraContext) {
      $dara.Model.validateMap(this.extraContext);
    }
    if(this.messageMcmsContext) {
      $dara.Model.validateMap(this.messageMcmsContext);
    }
    if(this.proposalMcmsContext) {
      $dara.Model.validateMap(this.proposalMcmsContext);
    }
    if(this.reasonMcmsContext) {
      $dara.Model.validateMap(this.reasonMcmsContext);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectComponentsResponseBodyDataFullImportComponents extends $dara.Model {
  errorDetails?: DescribeProjectComponentsResponseBodyDataFullImportComponentsErrorDetails[];
  /**
   * @example
   * 2023-07-13T18:04:36
   */
  gmtCreate?: string;
  /**
   * @example
   * 2023-07-13T18:04:36
   */
  gmtModify?: string;
  /**
   * @example
   * p_4w8v****
   */
  identity?: string;
  /**
   * @example
   * xxx.xxx.xxx.1
   */
  ip?: string;
  /**
   * @example
   * xxx.xxx.xxx.1-9000:connector_v2:np_4w8v****c-full_trans-1-0:0000000276
   */
  name?: string;
  /**
   * @example
   * 90
   */
  progress?: number;
  /**
   * @example
   * cn-hangzhou
   */
  region?: string;
  /**
   * @example
   * RUNNING
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      errorDetails: 'ErrorDetails',
      gmtCreate: 'GmtCreate',
      gmtModify: 'GmtModify',
      identity: 'Identity',
      ip: 'Ip',
      name: 'Name',
      progress: 'Progress',
      region: 'Region',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorDetails: { 'type': 'array', 'itemType': DescribeProjectComponentsResponseBodyDataFullImportComponentsErrorDetails },
      gmtCreate: 'string',
      gmtModify: 'string',
      identity: 'string',
      ip: 'string',
      name: 'string',
      progress: 'number',
      region: 'string',
      status: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.errorDetails)) {
      $dara.Model.validateArray(this.errorDetails);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectComponentsResponseBodyDataFullVerifyComponentsErrorDetails extends $dara.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * null
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  validate() {
    if(this.extraContext) {
      $dara.Model.validateMap(this.extraContext);
    }
    if(this.messageMcmsContext) {
      $dara.Model.validateMap(this.messageMcmsContext);
    }
    if(this.proposalMcmsContext) {
      $dara.Model.validateMap(this.proposalMcmsContext);
    }
    if(this.reasonMcmsContext) {
      $dara.Model.validateMap(this.reasonMcmsContext);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectComponentsResponseBodyDataFullVerifyComponents extends $dara.Model {
  /**
   * @example
   * 100
   */
  consistentQuantity?: number;
  errorDetails?: DescribeProjectComponentsResponseBodyDataFullVerifyComponentsErrorDetails[];
  /**
   * @example
   * 0
   */
  inconsistentQuantity?: number;
  /**
   * @example
   * xxx.xxx.xxx.1
   */
  ip?: string;
  /**
   * @example
   * xxx.xxx.xxx.1-9000:90247:0000000033
   */
  name?: string;
  /**
   * @example
   * 100
   */
  progress?: string;
  /**
   * @example
   * 100
   */
  recordProgress?: number;
  /**
   * @example
   * cn-beijing
   */
  region?: string;
  /**
   * @example
   * RUNNING
   */
  status?: string;
  /**
   * @example
   * 1345***
   */
  taskId?: number;
  static names(): { [key: string]: string } {
    return {
      consistentQuantity: 'ConsistentQuantity',
      errorDetails: 'ErrorDetails',
      inconsistentQuantity: 'InconsistentQuantity',
      ip: 'Ip',
      name: 'Name',
      progress: 'Progress',
      recordProgress: 'RecordProgress',
      region: 'Region',
      status: 'Status',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consistentQuantity: 'number',
      errorDetails: { 'type': 'array', 'itemType': DescribeProjectComponentsResponseBodyDataFullVerifyComponentsErrorDetails },
      inconsistentQuantity: 'number',
      ip: 'string',
      name: 'string',
      progress: 'string',
      recordProgress: 'number',
      region: 'string',
      status: 'string',
      taskId: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.errorDetails)) {
      $dara.Model.validateArray(this.errorDetails);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectComponentsResponseBodyDataIncrSyncComponentsErrorDetails extends $dara.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * null
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  validate() {
    if(this.extraContext) {
      $dara.Model.validateMap(this.extraContext);
    }
    if(this.messageMcmsContext) {
      $dara.Model.validateMap(this.messageMcmsContext);
    }
    if(this.proposalMcmsContext) {
      $dara.Model.validateMap(this.proposalMcmsContext);
    }
    if(this.reasonMcmsContext) {
      $dara.Model.validateMap(this.reasonMcmsContext);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectComponentsResponseBodyDataIncrSyncComponents extends $dara.Model {
  /**
   * @example
   * 2023-07-13T09:19:53
   */
  checkpoint?: string;
  /**
   * @example
   * 1689250071
   */
  checkpointSampleTimestamp?: number;
  /**
   * @example
   * 1
   */
  delay?: number;
  errorDetails?: DescribeProjectComponentsResponseBodyDataIncrSyncComponentsErrorDetails[];
  /**
   * @example
   * 2023-07-13T18:04:36
   */
  gmtCreate?: string;
  /**
   * @example
   * 2023-07-13T18:04:36
   */
  gmtModify?: string;
  /**
   * @example
   * np_4w***
   */
  identity?: string;
  /**
   * @example
   * xxx.xxx.xxx.1
   */
  ip?: string;
  /**
   * @example
   * xxx.xxx.xxx.1-9000:connector_v2:np_4w****jxc-incr_trans-1-0:0000000277
   */
  name?: string;
  /**
   * @example
   * cn-zhangjiakou
   */
  region?: string;
  /**
   * @example
   * RUNNING
   */
  status?: string;
  subtopics?: string[];
  /**
   * @example
   * 1
   */
  tps?: number;
  static names(): { [key: string]: string } {
    return {
      checkpoint: 'Checkpoint',
      checkpointSampleTimestamp: 'CheckpointSampleTimestamp',
      delay: 'Delay',
      errorDetails: 'ErrorDetails',
      gmtCreate: 'GmtCreate',
      gmtModify: 'GmtModify',
      identity: 'Identity',
      ip: 'Ip',
      name: 'Name',
      region: 'Region',
      status: 'Status',
      subtopics: 'Subtopics',
      tps: 'Tps',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkpoint: 'string',
      checkpointSampleTimestamp: 'number',
      delay: 'number',
      errorDetails: { 'type': 'array', 'itemType': DescribeProjectComponentsResponseBodyDataIncrSyncComponentsErrorDetails },
      gmtCreate: 'string',
      gmtModify: 'string',
      identity: 'string',
      ip: 'string',
      name: 'string',
      region: 'string',
      status: 'string',
      subtopics: { 'type': 'array', 'itemType': 'string' },
      tps: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.errorDetails)) {
      $dara.Model.validateArray(this.errorDetails);
    }
    if(Array.isArray(this.subtopics)) {
      $dara.Model.validateArray(this.subtopics);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectComponentsResponseBodyDataReverseIncrSyncComponentsErrorDetails extends $dara.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * null
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  validate() {
    if(this.extraContext) {
      $dara.Model.validateMap(this.extraContext);
    }
    if(this.messageMcmsContext) {
      $dara.Model.validateMap(this.messageMcmsContext);
    }
    if(this.proposalMcmsContext) {
      $dara.Model.validateMap(this.proposalMcmsContext);
    }
    if(this.reasonMcmsContext) {
      $dara.Model.validateMap(this.reasonMcmsContext);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectComponentsResponseBodyDataReverseIncrSyncComponents extends $dara.Model {
  /**
   * @example
   * 2023-07-13T09:19:53
   */
  checkpoint?: string;
  /**
   * @example
   * 1689250049
   */
  checkpointSampleTimestamp?: number;
  /**
   * @example
   * 1
   */
  delay?: number;
  errorDetails?: DescribeProjectComponentsResponseBodyDataReverseIncrSyncComponentsErrorDetails[];
  /**
   * @example
   * 2023-07-13T18:04:36
   */
  gmtCreate?: string;
  /**
   * @example
   * 2023-07-13T18:04:36
   */
  gmtModify?: string;
  /**
   * @example
   * np_4w8****
   */
  identity?: string;
  /**
   * @example
   * xxx.xxx.xxx.1
   */
  ip?: string;
  /**
   * @example
   * xxx.xxx.xxx.1-9000:connector_v2:np_4w8****9jxc-incr_trans-1-0:0000000277
   */
  name?: string;
  /**
   * @example
   * cn-shanghai
   */
  region?: string;
  /**
   * @example
   * RUNNING
   */
  status?: string;
  subtopics?: string[];
  /**
   * @example
   * 1
   */
  tps?: number;
  static names(): { [key: string]: string } {
    return {
      checkpoint: 'Checkpoint',
      checkpointSampleTimestamp: 'CheckpointSampleTimestamp',
      delay: 'Delay',
      errorDetails: 'ErrorDetails',
      gmtCreate: 'GmtCreate',
      gmtModify: 'GmtModify',
      identity: 'Identity',
      ip: 'Ip',
      name: 'Name',
      region: 'Region',
      status: 'Status',
      subtopics: 'Subtopics',
      tps: 'Tps',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkpoint: 'string',
      checkpointSampleTimestamp: 'number',
      delay: 'number',
      errorDetails: { 'type': 'array', 'itemType': DescribeProjectComponentsResponseBodyDataReverseIncrSyncComponentsErrorDetails },
      gmtCreate: 'string',
      gmtModify: 'string',
      identity: 'string',
      ip: 'string',
      name: 'string',
      region: 'string',
      status: 'string',
      subtopics: { 'type': 'array', 'itemType': 'string' },
      tps: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.errorDetails)) {
      $dara.Model.validateArray(this.errorDetails);
    }
    if(Array.isArray(this.subtopics)) {
      $dara.Model.validateArray(this.subtopics);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectComponentsResponseBodyDataReverseStoreListErrorDetails extends $dara.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * null
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  validate() {
    if(this.extraContext) {
      $dara.Model.validateMap(this.extraContext);
    }
    if(this.messageMcmsContext) {
      $dara.Model.validateMap(this.messageMcmsContext);
    }
    if(this.proposalMcmsContext) {
      $dara.Model.validateMap(this.proposalMcmsContext);
    }
    if(this.reasonMcmsContext) {
      $dara.Model.validateMap(this.reasonMcmsContext);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectComponentsResponseBodyDataReverseStoreList extends $dara.Model {
  /**
   * @example
   * 2023-07-13T09:19:53
   */
  beginCheckpoint?: string;
  /**
   * @example
   * 1
   */
  conn?: number;
  /**
   * @example
   * 1
   */
  delay?: number;
  /**
   * @example
   * 2023-07-13T09:19:53
   */
  endCheckpoint?: string;
  /**
   * @example
   * null
   */
  errMsg?: string;
  errorDetails?: DescribeProjectComponentsResponseBodyDataReverseStoreListErrorDetails[];
  /**
   * @example
   * 1689250071
   */
  gmt?: number;
  /**
   * @example
   * 2023-07-13T18:04:36
   */
  gmtCreate?: string;
  /**
   * @example
   * 2023-07-13T18:04:36
   */
  gmtModified?: string;
  /**
   * @example
   * xxx.xxx.xxx.1
   */
  ip?: string;
  /**
   * @example
   * 1689250071
   */
  latelyHeartbeatTimeSec?: number;
  /**
   * @example
   * xxx.xxx.xxx.1-9000:connector_v2:np_4w****9jxc-incr_trans-1-0:0000000277
   */
  name?: string;
  /**
   * @example
   * 2883
   */
  port?: number;
  /**
   * @example
   * cn-shenzhen
   */
  region?: string;
  /**
   * @example
   * EXCEPTION
   */
  status?: string;
  /**
   * @example
   * 2882
   */
  storePort?: number;
  /**
   * @remarks
   * SubTopic。
   * 
   * @example
   * null
   */
  subtopic?: string;
  /**
   * @example
   * false
   */
  toSwitch?: boolean;
  /**
   * @remarks
   * Topic。
   * 
   * @example
   * null
   */
  topic?: string;
  /**
   * @example
   * 1
   */
  tps?: number;
  static names(): { [key: string]: string } {
    return {
      beginCheckpoint: 'BeginCheckpoint',
      conn: 'Conn',
      delay: 'Delay',
      endCheckpoint: 'EndCheckpoint',
      errMsg: 'ErrMsg',
      errorDetails: 'ErrorDetails',
      gmt: 'Gmt',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      ip: 'Ip',
      latelyHeartbeatTimeSec: 'LatelyHeartbeatTimeSec',
      name: 'Name',
      port: 'Port',
      region: 'Region',
      status: 'Status',
      storePort: 'StorePort',
      subtopic: 'Subtopic',
      toSwitch: 'ToSwitch',
      topic: 'Topic',
      tps: 'Tps',
    };
  }

  static types(): { [key: string]: any } {
    return {
      beginCheckpoint: 'string',
      conn: 'number',
      delay: 'number',
      endCheckpoint: 'string',
      errMsg: 'string',
      errorDetails: { 'type': 'array', 'itemType': DescribeProjectComponentsResponseBodyDataReverseStoreListErrorDetails },
      gmt: 'number',
      gmtCreate: 'string',
      gmtModified: 'string',
      ip: 'string',
      latelyHeartbeatTimeSec: 'number',
      name: 'string',
      port: 'number',
      region: 'string',
      status: 'string',
      storePort: 'number',
      subtopic: 'string',
      toSwitch: 'boolean',
      topic: 'string',
      tps: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.errorDetails)) {
      $dara.Model.validateArray(this.errorDetails);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectComponentsResponseBodyDataStoreListErrorDetails extends $dara.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * null
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  validate() {
    if(this.extraContext) {
      $dara.Model.validateMap(this.extraContext);
    }
    if(this.messageMcmsContext) {
      $dara.Model.validateMap(this.messageMcmsContext);
    }
    if(this.proposalMcmsContext) {
      $dara.Model.validateMap(this.proposalMcmsContext);
    }
    if(this.reasonMcmsContext) {
      $dara.Model.validateMap(this.reasonMcmsContext);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectComponentsResponseBodyDataStoreList extends $dara.Model {
  /**
   * @example
   * 2023-07-13T09:19:53
   */
  beginCheckpoint?: string;
  /**
   * @example
   * 1
   */
  conn?: number;
  /**
   * @example
   * 24
   */
  delay?: number;
  /**
   * @example
   * 2023-07-13T09:19:53
   */
  endCheckpoint?: string;
  /**
   * @example
   * null
   */
  errMsg?: string;
  errorDetails?: DescribeProjectComponentsResponseBodyDataStoreListErrorDetails[];
  /**
   * @example
   * 1689250049
   */
  gmt?: number;
  /**
   * @example
   * 2023-07-13T17:29:54
   */
  gmtCreate?: string;
  /**
   * @example
   * 2023-07-13T17:29:54
   */
  gmtModified?: string;
  /**
   * @example
   * xxx.xxx.xxx.1
   */
  ip?: string;
  /**
   * @example
   * 1689250071
   */
  latelyHeartbeatTimeSec?: number;
  /**
   * @example
   * xxx.xxx.xxx.1-7145:OB_ORACLE_np_4w3r***_4w:0000***97
   */
  name?: string;
  /**
   * @example
   * 2883
   */
  port?: number;
  /**
   * @example
   * cn-shanghai
   */
  region?: string;
  /**
   * @example
   * EXCEPTION
   */
  status?: string;
  /**
   * @example
   * 2882
   */
  storePort?: number;
  /**
   * @remarks
   * SubTopic。
   * 
   * @example
   * OB_ORACLE_np_4w3***c_4w3**-0
   */
  subtopic?: string;
  /**
   * @example
   * false
   */
  toSwitch?: boolean;
  /**
   * @remarks
   * Topic。
   * 
   * @example
   * OB_ORACLE_np_4w3r29c_4w3****
   */
  topic?: string;
  /**
   * @example
   * 0
   */
  tps?: number;
  static names(): { [key: string]: string } {
    return {
      beginCheckpoint: 'BeginCheckpoint',
      conn: 'Conn',
      delay: 'Delay',
      endCheckpoint: 'EndCheckpoint',
      errMsg: 'ErrMsg',
      errorDetails: 'ErrorDetails',
      gmt: 'Gmt',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      ip: 'Ip',
      latelyHeartbeatTimeSec: 'LatelyHeartbeatTimeSec',
      name: 'Name',
      port: 'Port',
      region: 'Region',
      status: 'Status',
      storePort: 'StorePort',
      subtopic: 'Subtopic',
      toSwitch: 'ToSwitch',
      topic: 'Topic',
      tps: 'Tps',
    };
  }

  static types(): { [key: string]: any } {
    return {
      beginCheckpoint: 'string',
      conn: 'number',
      delay: 'number',
      endCheckpoint: 'string',
      errMsg: 'string',
      errorDetails: { 'type': 'array', 'itemType': DescribeProjectComponentsResponseBodyDataStoreListErrorDetails },
      gmt: 'number',
      gmtCreate: 'string',
      gmtModified: 'string',
      ip: 'string',
      latelyHeartbeatTimeSec: 'number',
      name: 'string',
      port: 'number',
      region: 'string',
      status: 'string',
      storePort: 'number',
      subtopic: 'string',
      toSwitch: 'boolean',
      topic: 'string',
      tps: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.errorDetails)) {
      $dara.Model.validateArray(this.errorDetails);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectComponentsResponseBodyData extends $dara.Model {
  fullImportComponents?: DescribeProjectComponentsResponseBodyDataFullImportComponents[];
  fullVerifyComponents?: DescribeProjectComponentsResponseBodyDataFullVerifyComponents[];
  incrSyncComponents?: DescribeProjectComponentsResponseBodyDataIncrSyncComponents[];
  reverseIncrSyncComponents?: DescribeProjectComponentsResponseBodyDataReverseIncrSyncComponents[];
  reverseStoreList?: DescribeProjectComponentsResponseBodyDataReverseStoreList[];
  storeList?: DescribeProjectComponentsResponseBodyDataStoreList[];
  static names(): { [key: string]: string } {
    return {
      fullImportComponents: 'FullImportComponents',
      fullVerifyComponents: 'FullVerifyComponents',
      incrSyncComponents: 'IncrSyncComponents',
      reverseIncrSyncComponents: 'ReverseIncrSyncComponents',
      reverseStoreList: 'ReverseStoreList',
      storeList: 'StoreList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fullImportComponents: { 'type': 'array', 'itemType': DescribeProjectComponentsResponseBodyDataFullImportComponents },
      fullVerifyComponents: { 'type': 'array', 'itemType': DescribeProjectComponentsResponseBodyDataFullVerifyComponents },
      incrSyncComponents: { 'type': 'array', 'itemType': DescribeProjectComponentsResponseBodyDataIncrSyncComponents },
      reverseIncrSyncComponents: { 'type': 'array', 'itemType': DescribeProjectComponentsResponseBodyDataReverseIncrSyncComponents },
      reverseStoreList: { 'type': 'array', 'itemType': DescribeProjectComponentsResponseBodyDataReverseStoreList },
      storeList: { 'type': 'array', 'itemType': DescribeProjectComponentsResponseBodyDataStoreList },
    };
  }

  validate() {
    if(Array.isArray(this.fullImportComponents)) {
      $dara.Model.validateArray(this.fullImportComponents);
    }
    if(Array.isArray(this.fullVerifyComponents)) {
      $dara.Model.validateArray(this.fullVerifyComponents);
    }
    if(Array.isArray(this.incrSyncComponents)) {
      $dara.Model.validateArray(this.incrSyncComponents);
    }
    if(Array.isArray(this.reverseIncrSyncComponents)) {
      $dara.Model.validateArray(this.reverseIncrSyncComponents);
    }
    if(Array.isArray(this.reverseStoreList)) {
      $dara.Model.validateArray(this.reverseStoreList);
    }
    if(Array.isArray(this.storeList)) {
      $dara.Model.validateArray(this.storeList);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectComponentsResponseBodyErrorDetail extends $dara.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * null
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  validate() {
    if(this.extraContext) {
      $dara.Model.validateMap(this.extraContext);
    }
    if(this.messageMcmsContext) {
      $dara.Model.validateMap(this.messageMcmsContext);
    }
    if(this.proposalMcmsContext) {
      $dara.Model.validateMap(this.proposalMcmsContext);
    }
    if(this.reasonMcmsContext) {
      $dara.Model.validateMap(this.reasonMcmsContext);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectProgressResponseBodyData extends $dara.Model {
  /**
   * @example
   * MEDIUM
   */
  alarmLevel?: string;
  /**
   * @example
   * PRE_CHECK
   */
  currentStep?: string;
  /**
   * @example
   * true
   */
  enableFullTransfer?: boolean;
  /**
   * @example
   * true
   */
  enableIncrSync?: boolean;
  /**
   * @example
   * true
   */
  enableReverseIncrTransfer?: boolean;
  /**
   * @example
   * true
   */
  enableStructTransfer?: boolean;
  /**
   * @example
   * 100
   */
  fullTransferProgress?: number;
  /**
   * @example
   * 1689248064
   */
  incrSyncCheckpoint?: number;
  /**
   * @example
   * np_fe****
   */
  projectId?: string;
  /**
   * @example
   * 1689248075
   */
  reverseIncrTransferCheckpoint?: number;
  /**
   * @example
   * RUNNING
   */
  status?: string;
  /**
   * @example
   * 100
   */
  structTransferProgress?: number;
  static names(): { [key: string]: string } {
    return {
      alarmLevel: 'AlarmLevel',
      currentStep: 'CurrentStep',
      enableFullTransfer: 'EnableFullTransfer',
      enableIncrSync: 'EnableIncrSync',
      enableReverseIncrTransfer: 'EnableReverseIncrTransfer',
      enableStructTransfer: 'EnableStructTransfer',
      fullTransferProgress: 'FullTransferProgress',
      incrSyncCheckpoint: 'IncrSyncCheckpoint',
      projectId: 'ProjectId',
      reverseIncrTransferCheckpoint: 'ReverseIncrTransferCheckpoint',
      status: 'Status',
      structTransferProgress: 'StructTransferProgress',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alarmLevel: 'string',
      currentStep: 'string',
      enableFullTransfer: 'boolean',
      enableIncrSync: 'boolean',
      enableReverseIncrTransfer: 'boolean',
      enableStructTransfer: 'boolean',
      fullTransferProgress: 'number',
      incrSyncCheckpoint: 'number',
      projectId: 'string',
      reverseIncrTransferCheckpoint: 'number',
      status: 'string',
      structTransferProgress: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectProgressResponseBodyErrorDetail extends $dara.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * null
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  validate() {
    if(this.extraContext) {
      $dara.Model.validateMap(this.extraContext);
    }
    if(this.messageMcmsContext) {
      $dara.Model.validateMap(this.messageMcmsContext);
    }
    if(this.proposalMcmsContext) {
      $dara.Model.validateMap(this.proposalMcmsContext);
    }
    if(this.reasonMcmsContext) {
      $dara.Model.validateMap(this.reasonMcmsContext);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectStepMetricResponseBodyDataMetricsDataPoints extends $dara.Model {
  /**
   * @example
   * 1689244696
   */
  timestamp?: number;
  /**
   * @example
   * 0
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      timestamp: 'Timestamp',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timestamp: 'number',
      value: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectStepMetricResponseBodyDataMetrics extends $dara.Model {
  dataPoints?: DescribeProjectStepMetricResponseBodyDataMetricsDataPoints[];
  /**
   * @example
   * metric_name
   */
  name?: string;
  tags?: { [key: string]: string };
  static names(): { [key: string]: string } {
    return {
      dataPoints: 'DataPoints',
      name: 'Name',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataPoints: { 'type': 'array', 'itemType': DescribeProjectStepMetricResponseBodyDataMetricsDataPoints },
      name: 'string',
      tags: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
    };
  }

  validate() {
    if(Array.isArray(this.dataPoints)) {
      $dara.Model.validateArray(this.dataPoints);
    }
    if(this.tags) {
      $dara.Model.validateMap(this.tags);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectStepMetricResponseBodyData extends $dara.Model {
  /**
   * @example
   * AVG
   */
  aggregator?: string;
  metrics?: DescribeProjectStepMetricResponseBodyDataMetrics[];
  /**
   * @example
   * null
   */
  referenceValue?: number;
  static names(): { [key: string]: string } {
    return {
      aggregator: 'Aggregator',
      metrics: 'Metrics',
      referenceValue: 'ReferenceValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aggregator: 'string',
      metrics: { 'type': 'array', 'itemType': DescribeProjectStepMetricResponseBodyDataMetrics },
      referenceValue: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.metrics)) {
      $dara.Model.validateArray(this.metrics);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectStepMetricResponseBodyErrorDetail extends $dara.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * null
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  validate() {
    if(this.extraContext) {
      $dara.Model.validateMap(this.extraContext);
    }
    if(this.messageMcmsContext) {
      $dara.Model.validateMap(this.messageMcmsContext);
    }
    if(this.proposalMcmsContext) {
      $dara.Model.validateMap(this.proposalMcmsContext);
    }
    if(this.reasonMcmsContext) {
      $dara.Model.validateMap(this.reasonMcmsContext);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectStepsResponseBodyDataExtraInfoErrorDetails extends $dara.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * null
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  validate() {
    if(this.extraContext) {
      $dara.Model.validateMap(this.extraContext);
    }
    if(this.messageMcmsContext) {
      $dara.Model.validateMap(this.messageMcmsContext);
    }
    if(this.proposalMcmsContext) {
      $dara.Model.validateMap(this.proposalMcmsContext);
    }
    if(this.reasonMcmsContext) {
      $dara.Model.validateMap(this.reasonMcmsContext);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectStepsResponseBodyDataExtraInfo extends $dara.Model {
  /**
   * @example
   * INNER_ERROR
   */
  errorCode?: string;
  errorDetails?: DescribeProjectStepsResponseBodyDataExtraInfoErrorDetails[];
  /**
   * @example
   * The ResourceDirectoryId is invalid.
   */
  errorMsg?: string;
  errorParam?: { [key: string]: string };
  /**
   * @example
   * null
   */
  failedTime?: string;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorDetails: 'ErrorDetails',
      errorMsg: 'ErrorMsg',
      errorParam: 'ErrorParam',
      failedTime: 'FailedTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorDetails: { 'type': 'array', 'itemType': DescribeProjectStepsResponseBodyDataExtraInfoErrorDetails },
      errorMsg: 'string',
      errorParam: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      failedTime: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.errorDetails)) {
      $dara.Model.validateArray(this.errorDetails);
    }
    if(this.errorParam) {
      $dara.Model.validateMap(this.errorParam);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectStepsResponseBodyData extends $dara.Model {
  description?: string;
  extraInfo?: DescribeProjectStepsResponseBodyDataExtraInfo;
  /**
   * @example
   * 2020-05-22T17:04:18
   */
  finishTime?: string;
  /**
   * @example
   * PRE_CHECK
   */
  name?: string;
  /**
   * @example
   * 1
   */
  order?: number;
  /**
   * @example
   * 100
   */
  progress?: number;
  /**
   * @example
   * 2020-05-22T17:04:18
   */
  startTime?: string;
  /**
   * @example
   * RUNNING
   */
  status?: string;
  /**
   * @example
   * null
   */
  stepInfo?: { [key: string]: any };
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      extraInfo: 'ExtraInfo',
      finishTime: 'FinishTime',
      name: 'Name',
      order: 'Order',
      progress: 'Progress',
      startTime: 'StartTime',
      status: 'Status',
      stepInfo: 'StepInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      extraInfo: DescribeProjectStepsResponseBodyDataExtraInfo,
      finishTime: 'string',
      name: 'string',
      order: 'number',
      progress: 'number',
      startTime: 'string',
      status: 'string',
      stepInfo: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
    };
  }

  validate() {
    if(this.extraInfo && typeof (this.extraInfo as any).validate === 'function') {
      (this.extraInfo as any).validate();
    }
    if(this.stepInfo) {
      $dara.Model.validateMap(this.stepInfo);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectStepsResponseBodyErrorDetail extends $dara.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * Contact the administrator.
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  validate() {
    if(this.extraContext) {
      $dara.Model.validateMap(this.extraContext);
    }
    if(this.messageMcmsContext) {
      $dara.Model.validateMap(this.messageMcmsContext);
    }
    if(this.proposalMcmsContext) {
      $dara.Model.validateMap(this.proposalMcmsContext);
    }
    if(this.reasonMcmsContext) {
      $dara.Model.validateMap(this.reasonMcmsContext);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProxyServiceResponseBodyData extends $dara.Model {
  /**
   * @example
   * 2023-07-05T08:23:10Z
   */
  createTime?: string;
  /**
   * @example
   * 1
   */
  currentEndpointNum?: number;
  /**
   * @example
   * 3
   */
  endpointNumQuota?: number;
  /**
   * @example
   * 2123-07-05T16:00:00
   */
  expireTime?: string;
  /**
   * @example
   * proxy-3t****zrieasg
   */
  proxyClusterId?: string;
  /**
   * @example
   * shared
   */
  proxyMode?: string;
  /**
   * @example
   * 1.0
   */
  proxyServiceVersion?: string;
  /**
   * @example
   * 4.3.1.0-xxxxxxxxx
   */
  proxyVersion?: string;
  /**
   * @example
   * ONLINE
   */
  status?: string;
  /**
   * @example
   * 1
   */
  unitNum?: number;
  /**
   * @example
   * 4
   */
  unitNumLimit?: number;
  /**
   * @example
   * 4C8GB
   */
  unitSpec?: string;
  /**
   * @example
   * cn-shanghai-e,cn-shanghai-f
   */
  zone?: string;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      currentEndpointNum: 'CurrentEndpointNum',
      endpointNumQuota: 'EndpointNumQuota',
      expireTime: 'ExpireTime',
      proxyClusterId: 'ProxyClusterId',
      proxyMode: 'ProxyMode',
      proxyServiceVersion: 'ProxyServiceVersion',
      proxyVersion: 'ProxyVersion',
      status: 'Status',
      unitNum: 'UnitNum',
      unitNumLimit: 'UnitNumLimit',
      unitSpec: 'UnitSpec',
      zone: 'Zone',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'string',
      currentEndpointNum: 'number',
      endpointNumQuota: 'number',
      expireTime: 'string',
      proxyClusterId: 'string',
      proxyMode: 'string',
      proxyServiceVersion: 'string',
      proxyVersion: 'string',
      status: 'string',
      unitNum: 'number',
      unitNumLimit: 'number',
      unitSpec: 'string',
      zone: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRecommendIndexResponseBodyRecommendIndex extends $dara.Model {
  /**
   * @remarks
   * Example 1
   * 
   * @example
   * PRIMARY
   */
  suggestIndex?: string;
  /**
   * @example
   * testtable
   */
  tableList?: string;
  /**
   * @example
   * mysql
   */
  tenantMode?: string;
  static names(): { [key: string]: string } {
    return {
      suggestIndex: 'SuggestIndex',
      tableList: 'TableList',
      tenantMode: 'TenantMode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      suggestIndex: 'string',
      tableList: 'string',
      tenantMode: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRestorableTenantsResponseBodyTenantsBackupSets extends $dara.Model {
  /**
   * @remarks
   * The ID of the full backup set used for restore.
   * 
   * @example
   * bak-4n****gacpa8
   */
  backupSetId?: string;
  /**
   * @remarks
   * The checkpoint of the backup set.
   * 
   * @example
   * 2024-01-01\\"T\\"12:10:10.000\\"Z\\"
   */
  checkpoint?: string;
  /**
   * @remarks
   * The ID of the backup set.
   * 
   * @example
   * bak-xxxxx
   */
  setId?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * @example
   * t5********
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      backupSetId: 'BackupSetId',
      checkpoint: 'Checkpoint',
      setId: 'SetId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      backupSetId: 'string',
      checkpoint: 'string',
      setId: 'string',
      tenantId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRestorableTenantsResponseBodyTenantsTimeIntervalList extends $dara.Model {
  /**
   * @remarks
   * The end time of the restorable period.
   * 
   * @example
   * 2023-03-13T02:43:03Z
   */
  endTime?: string;
  /**
   * @remarks
   * Indicates whether the restore is based on archiving.
   * 
   * @example
   * true
   */
  fromArchive?: boolean;
  /**
   * @remarks
   * The start time of the restorable period.
   * 
   * @example
   * 2023-01-20T16:00:00Z
   */
  startTime?: string;
  /**
   * @remarks
   * The storage type of backup data.
   * 
   * @example
   * standard
   */
  storageType?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      fromArchive: 'FromArchive',
      startTime: 'StartTime',
      storageType: 'StorageType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      fromArchive: 'boolean',
      startTime: 'string',
      storageType: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRestorableTenantsResponseBodyTenants extends $dara.Model {
  /**
   * @remarks
   * The name of the backup directory.
   * 
   * @example
   * backup
   */
  backupBucketName?: string;
  /**
   * @remarks
   * The list of backup sets.
   */
  backupSets?: DescribeRestorableTenantsResponseBodyTenantsBackupSets[];
  /**
   * @remarks
   * The ID of the cluster.
   * 
   * @example
   * objnf3b2****
   */
  clusterId?: string;
  /**
   * @remarks
   * The name of the cluster.
   * 
   * @example
   * testCluster
   */
  clusterName?: string;
  /**
   * @remarks
   * The number of CPU cores.
   * 
   * @example
   * 1
   */
  cpuNum?: number;
  /**
   * @remarks
   * The size of memory for the tenant.
   * 
   * @example
   * 100
   */
  memoryNum?: number;
  /**
   * @remarks
   * The backup method.
   * 
   * @example
   * logical
   */
  method?: string;
  /**
   * @remarks
   * The version of the OceanBase Database RPM package.
   * 
   * @example
   * 3.2.3.1-2022080510****
   */
  obRpmVersion?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * @example
   * tvd43v****
   */
  obTenantId?: string;
  /**
   * @remarks
   * The major version of OceanBase Database.
   * 
   * @example
   * 3.2.3.1
   */
  obVersion?: string;
  /**
   * @remarks
   * The region of the cluster.
   * 
   * @example
   * cn-hangzhou
   */
  sourceRegion?: string;
  /**
   * @remarks
   * The alias of the tenant.
   * 
   * @example
   * aaa
   */
  tenantAlias?: string;
  /**
   * @remarks
   * The remaining validity period, in days, of the backup data of the tenant.
   * 
   * @example
   * 7
   */
  tenantDataBackupRemainDays?: number;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * @example
   * ob317v4uif****
   */
  tenantId?: string;
  /**
   * @remarks
   * The mode of the tenant.
   * 
   * @example
   * Oracle
   */
  tenantMode?: string;
  /**
   * @remarks
   * The name of the tenant.
   * 
   * @example
   * sbtest1
   */
  tenantName?: string;
  /**
   * @remarks
   * The list of restorable periods of the tenant.
   */
  timeIntervalList?: DescribeRestorableTenantsResponseBodyTenantsTimeIntervalList[];
  /**
   * @remarks
   * The number of nodes of the tenant.
   * 
   * @example
   * 2
   */
  unitNum?: number;
  /**
   * @remarks
   * The size of disk space for the tenant.
   * 
   * @example
   * 50
   */
  usedDisk?: number;
  static names(): { [key: string]: string } {
    return {
      backupBucketName: 'BackupBucketName',
      backupSets: 'BackupSets',
      clusterId: 'ClusterId',
      clusterName: 'ClusterName',
      cpuNum: 'CpuNum',
      memoryNum: 'MemoryNum',
      method: 'Method',
      obRpmVersion: 'ObRpmVersion',
      obTenantId: 'ObTenantId',
      obVersion: 'ObVersion',
      sourceRegion: 'SourceRegion',
      tenantAlias: 'TenantAlias',
      tenantDataBackupRemainDays: 'TenantDataBackupRemainDays',
      tenantId: 'TenantId',
      tenantMode: 'TenantMode',
      tenantName: 'TenantName',
      timeIntervalList: 'TimeIntervalList',
      unitNum: 'UnitNum',
      usedDisk: 'UsedDisk',
    };
  }

  static types(): { [key: string]: any } {
    return {
      backupBucketName: 'string',
      backupSets: { 'type': 'array', 'itemType': DescribeRestorableTenantsResponseBodyTenantsBackupSets },
      clusterId: 'string',
      clusterName: 'string',
      cpuNum: 'number',
      memoryNum: 'number',
      method: 'string',
      obRpmVersion: 'string',
      obTenantId: 'string',
      obVersion: 'string',
      sourceRegion: 'string',
      tenantAlias: 'string',
      tenantDataBackupRemainDays: 'number',
      tenantId: 'string',
      tenantMode: 'string',
      tenantName: 'string',
      timeIntervalList: { 'type': 'array', 'itemType': DescribeRestorableTenantsResponseBodyTenantsTimeIntervalList },
      unitNum: 'number',
      usedDisk: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.backupSets)) {
      $dara.Model.validateArray(this.backupSets);
    }
    if(Array.isArray(this.timeIntervalList)) {
      $dara.Model.validateArray(this.timeIntervalList);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSQLDetailsResponseBodySQLDetails extends $dara.Model {
  /**
   * @example
   * testdb
   */
  dbName?: string;
  /**
   * @remarks
   * {"name":"DescribeSQLDetails","product":"OceanBasePro","version":"2019-09-01","path":"/","deprecated":0,"method":"POST|GET","protocol":"HTTP|HTTPS","hidden":0,"timeout":10000,"parameter_type":"Single","params":"[{\\"name\\":\\"Action\\",\\"position\\":\\"Query\\",\\"required\\":true,\\"checkBlank\\":false,\\"visibility\\":\\"Public\\",\\"deprecated\\":false,\\"type\\":\\"String\\",\\"description\\":\\"\\",\\"example\\":\\"DescribeSQLDetails\\"},{\\"name\\":\\"TenantId\\",\\"position\\":\\"Body\\",\\"required\\":true,\\"checkBlank\\":false,\\"visibility\\":\\"Public\\",\\"deprecated\\":false,\\"type\\":\\"String\\",\\"title\\":\\"\\",\\"description\\":\\"\\",\\"example\\":\\"t2mr3oae0****\\"},{\\"name\\":\\"SQLId\\",\\"position\\":\\"Body\\",\\"required\\":true,\\"checkBlank\\":false,\\"visibility\\":\\"Public\\",\\"deprecated\\":false,\\"type\\":\\"String\\",\\"title\\":\\"SQLID\\",\\"description\\":\\"SQLID。\\",\\"example\\":\\"8D6E84****0B8FB1823D199E2CA1****\\"}]","response_headers":"[]","response":"{\\"type\\":\\"Object\\",\\"children\\":[{\\"name\\":\\"RequestId\\",\\"required\\":false,\\"checkBlank\\":false,\\"visibility\\":\\"Public\\",\\"deprecated\\":false,\\"type\\":\\"String\\",\\"title\\":\\"\\",\\"description\\":\\"\\",\\"example\\":\\"473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E\\"},{\\"name\\":\\"SQLDetails\\",\\"required\\":false,\\"checkBlank\\":false,\\"visibility\\":\\"Public\\",\\"deprecated\\":false,\\"type\\":\\"Array\\",\\"subType\\":\\"Object\\",\\"description\\":\\"  \\",\\"children\\":[{\\"name\\":\\"SQLText\\",\\"required\\":false,\\"checkBlank\\":false,\\"visibility\\":\\"Public\\",\\"deprecated\\":false,\\"type\\":\\"String\\",\\"title\\":\\"\\",\\"description\\":\\"\\",\\"example\\":\\"SELECT  ****   FROM ****   WHERE **** = ? AND **** = ?   ORDER BY **** ASC\\"},{\\"name\\":\\"DbName\\",\\"required\\":false,\\"checkBlank\\":false,\\"visibility\\":\\"Public\\",\\"deprecated\\":false,\\"type\\":\\"String\\",\\"title\\":\\"\\",\\"description\\":\\"\\",\\"example\\":\\"testdb\\"},{\\"name\\":\\"UserName\\",\\"required\\":false,\\"checkBlank\\":false,\\"visibility\\":\\"Public\\",\\"deprecated\\":false,\\"type\\":\\"String\\",\\"title\\":\\"\\",\\"description\\":\\"\\",\\"example\\":\\"tester\\"}],\\"title\\":\\"\\"}],\\"title\\":\\"\\",\\"description\\":\\"\\"}","errors":"{}"}
   * 
   * @example
   * SELECT  ****   FROM ****   WHERE **** = ? AND **** = ?   ORDER BY **** ASC
   */
  SQLText?: string;
  /**
   * @example
   * tester
   */
  userName?: string;
  static names(): { [key: string]: string } {
    return {
      dbName: 'DbName',
      SQLText: 'SQLText',
      userName: 'UserName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbName: 'string',
      SQLText: 'string',
      userName: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSQLHistoryListResponseBodySQLHistoryListList extends $dara.Model {
  /**
   * @remarks
   * The number of rows affected.
   * 
   * @example
   * 0
   */
  affectedRows?: number;
  /**
   * @remarks
   * The wait time of the client.
   * 
   * @example
   * 0.0
   */
  appWaitTime?: number;
  /**
   * @remarks
   * The number of block cache hits.
   * 
   * @example
   * 14
   */
  blockCacheHit?: number;
  /**
   * @remarks
   * The number of block index cache hits.
   * 
   * @example
   * 4
   */
  blockIndexCacheHit?: number;
  /**
   * @remarks
   * The number of Bloom filter cache hits.
   * 
   * @example
   * 0
   */
  bloomFilterCacheHit?: number;
  /**
   * @remarks
   * The IP address of the client.
   * 
   * @example
   * 1*2.***.1*3.***
   */
  clientIp?: string;
  /**
   * @remarks
   * The wait time in concurrent execution.
   * 
   * @example
   * 0.0
   */
  concurrencyWaitTime?: number;
  /**
   * @remarks
   * The average CPU time.
   * 
   * @example
   * 50.13
   */
  cpuTime?: number;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * testdb
   */
  dbName?: string;
  /**
   * @remarks
   * The time to wait for decoding.
   * 
   * @example
   * 0.0
   */
  decodeTime?: number;
  /**
   * @remarks
   * The number of physical reads.
   * 
   * @example
   * 0
   */
  diskRead?: number;
  /**
   * @remarks
   * The average response time.
   * 
   * @example
   * 76.382
   */
  elapsedTime?: number;
  /**
   * @remarks
   * The end time.
   * 
   * @example
   * 2021-12-28T02:08:18Z
   */
  endTime?: number;
  /**
   * @remarks
   * The end time in UTC +0.
   * 
   * @example
   * 2021-12-28T02:08:18Z
   */
  endTimeUTCString?: string;
  /**
   * @remarks
   * The wait event.
   * 
   * @example
   * mysql response wait client
   */
  event?: string;
  /**
   * @remarks
   * The number of executions per second.
   * 
   * @example
   * 163.0
   */
  execPerSecond?: number;
  /**
   * @remarks
   * The internal execution time.
   * 
   * @example
   * 61.044
   */
  executeTime?: number;
  /**
   * @remarks
   * The number of executions.
   * 
   * @example
   * 89403
   */
  executions?: number;
  /**
   * @remarks
   * The number of failures.
   * 
   * @example
   * 0
   */
  failTimes?: number;
  /**
   * @remarks
   * The time spent in hard parsing.
   * 
   * @example
   * 0.052
   */
  getPlanTime?: number;
  /**
   * @remarks
   * The I/O wait time.
   * 
   * @example
   * 0.0
   */
  IOWaitTime?: number;
  /**
   * @remarks
   * The number of logical reads.
   * 
   * @example
   * 19
   */
  logicalRead?: number;
  /**
   * @remarks
   * The maximum CPU time.
   * 
   * @example
   * 257.967
   */
  maxCpuTime?: number;
  /**
   * @remarks
   * The maximum response time.
   * 
   * @example
   * 260.44
   */
  maxElapsedTime?: number;
  /**
   * @remarks
   * The number of rows read from the memory.
   * 
   * @example
   * 527
   */
  memstoreReadRowCount?: number;
  /**
   * @remarks
   * The number of plan misses.
   * 
   * @example
   * 0
   */
  missPlans?: number;
  /**
   * @remarks
   * The network latency.
   * 
   * @example
   * 0.0
   */
  netWaitTime?: number;
  /**
   * @remarks
   * The IP address of the node.
   * 
   * @example
   * i-bp18qljorblo8es*****
   */
  nodeIp?: string;
  /**
   * @remarks
   * The queuing time.
   * 
   * @example
   * 15.275
   */
  queueTime?: number;
  /**
   * @remarks
   * The number of RPCs.
   * 
   * @example
   * 0
   */
  RPCCount?: number;
  /**
   * @remarks
   * The number of remote plans.
   * 
   * @example
   * 0
   */
  remotePlans?: number;
  /**
   * @remarks
   * The number of retries.
   * 
   * @example
   * 0
   */
  retryCount?: number;
  /**
   * @remarks
   * The number of rows returned.
   * 
   * @example
   * 1
   */
  returnRows?: number;
  /**
   * @remarks
   * The number of row cache hits.
   * 
   * @example
   * 0
   */
  rowCacheHit?: number;
  /**
   * @remarks
   * The scheduling duration.
   * 
   * @example
   * 0.0
   */
  scheduleTime?: number;
  /**
   * @remarks
   * The number of rows read from the disk.
   * 
   * @example
   * 43086
   */
  ssstoreReadRowCount?: number;
  /**
   * @remarks
   * The internal wait time.
   * 
   * @example
   * 10.966
   */
  totalWaitTime?: number;
  /**
   * @remarks
   * The username.
   * 
   * @example
   * tester
   */
  userName?: string;
  static names(): { [key: string]: string } {
    return {
      affectedRows: 'AffectedRows',
      appWaitTime: 'AppWaitTime',
      blockCacheHit: 'BlockCacheHit',
      blockIndexCacheHit: 'BlockIndexCacheHit',
      bloomFilterCacheHit: 'BloomFilterCacheHit',
      clientIp: 'ClientIp',
      concurrencyWaitTime: 'ConcurrencyWaitTime',
      cpuTime: 'CpuTime',
      dbName: 'DbName',
      decodeTime: 'DecodeTime',
      diskRead: 'DiskRead',
      elapsedTime: 'ElapsedTime',
      endTime: 'EndTime',
      endTimeUTCString: 'EndTimeUTCString',
      event: 'Event',
      execPerSecond: 'ExecPerSecond',
      executeTime: 'ExecuteTime',
      executions: 'Executions',
      failTimes: 'FailTimes',
      getPlanTime: 'GetPlanTime',
      IOWaitTime: 'IOWaitTime',
      logicalRead: 'LogicalRead',
      maxCpuTime: 'MaxCpuTime',
      maxElapsedTime: 'MaxElapsedTime',
      memstoreReadRowCount: 'MemstoreReadRowCount',
      missPlans: 'MissPlans',
      netWaitTime: 'NetWaitTime',
      nodeIp: 'NodeIp',
      queueTime: 'QueueTime',
      RPCCount: 'RPCCount',
      remotePlans: 'RemotePlans',
      retryCount: 'RetryCount',
      returnRows: 'ReturnRows',
      rowCacheHit: 'RowCacheHit',
      scheduleTime: 'ScheduleTime',
      ssstoreReadRowCount: 'SsstoreReadRowCount',
      totalWaitTime: 'TotalWaitTime',
      userName: 'UserName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      affectedRows: 'number',
      appWaitTime: 'number',
      blockCacheHit: 'number',
      blockIndexCacheHit: 'number',
      bloomFilterCacheHit: 'number',
      clientIp: 'string',
      concurrencyWaitTime: 'number',
      cpuTime: 'number',
      dbName: 'string',
      decodeTime: 'number',
      diskRead: 'number',
      elapsedTime: 'number',
      endTime: 'number',
      endTimeUTCString: 'string',
      event: 'string',
      execPerSecond: 'number',
      executeTime: 'number',
      executions: 'number',
      failTimes: 'number',
      getPlanTime: 'number',
      IOWaitTime: 'number',
      logicalRead: 'number',
      maxCpuTime: 'number',
      maxElapsedTime: 'number',
      memstoreReadRowCount: 'number',
      missPlans: 'number',
      netWaitTime: 'number',
      nodeIp: 'string',
      queueTime: 'number',
      RPCCount: 'number',
      remotePlans: 'number',
      retryCount: 'number',
      returnRows: 'number',
      rowCacheHit: 'number',
      scheduleTime: 'number',
      ssstoreReadRowCount: 'number',
      totalWaitTime: 'number',
      userName: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSQLHistoryListResponseBodySQLHistoryList extends $dara.Model {
  /**
   * @remarks
   * The quantity.
   * 
   * @example
   * 1
   */
  count?: number;
  list?: DescribeSQLHistoryListResponseBodySQLHistoryListList[];
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      list: 'List',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      list: { 'type': 'array', 'itemType': DescribeSQLHistoryListResponseBodySQLHistoryListList },
    };
  }

  validate() {
    if(Array.isArray(this.list)) {
      $dara.Model.validateArray(this.list);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSQLPlansResponseBodySQLPlans extends $dara.Model {
  /**
   * @remarks
   * The average execution duration, in ms.
   * 
   * @example
   * 1
   */
  avgExecutionMS?: number;
  /**
   * @remarks
   * The average execution duration when the database uses this execution plan, in ms.
   * 
   * @example
   * 288
   */
  avgExecutionTimeMS?: number;
  /**
   * @remarks
   * The time when the plan was loaded for the first time, .
   * 
   * @example
   * 1641492303000
   */
  firstLoadTime?: number;
  /**
   * @remarks
   * The time when the plan was loaded for the first time, in UTC +0.
   * 
   * @example
   * 2022-01-06T18:05:03Z
   */
  firstLoadTimeUTCString?: string;
  /**
   * @remarks
   * The number of hits.
   * 
   * @example
   * 3
   */
  hitCount?: number;
  /**
   * @remarks
   * The major compaction version.
   * 
   * @example
   * 132
   */
  mergedVersion?: number;
  /**
   * @remarks
   * The IP address of the node.
   * 
   * @example
   * i-bp16niirq4zdmgvm****
   */
  nodeIp?: string;
  /**
   * @remarks
   * The outline data.
   */
  outlineData?: string;
  /**
   * @remarks
   * OutlineID.
   * 
   * @example
   * -1
   */
  outlineId?: number;
  /**
   * @remarks
   * The time when the plan was bound.
   * 
   * @example
   * 1641492303000
   */
  outlineTime?: number;
  /**
   * @remarks
   * The time when the plan was bound, in UTC +0.
   * 
   * @example
   * 2022-01-06T18:05:03Z
   */
  outlineTimeUTCString?: string;
  /**
   * @remarks
   * The complete execution plan of the SQL statement.
   * 
   * @example
   * PHY_TABLE_SCAN | bmsql_order_line | 40 ******
   */
  planFull?: string;
  /**
   * @remarks
   * The ID of the SQL execution plan in the database.
   * 
   * @example
   * 9114
   */
  planId?: number;
  /**
   * @remarks
   * The information about the plan.
   * 
   * @example
   * PHY_TABLE_SCAN
   */
  planInfo?: string;
  /**
   * @remarks
   * The unique identifier of the SQL execution plan in the diagnostic system.
   * 
   * @example
   * 859ef7ee****b23ac98cdeb2476f****
   */
  planUnionHash?: string;
  /**
   * @remarks
   * The query SQL statement.
   * 
   * @example
   * SELECT ol_i_id, ***, *** FROM aaa
   */
  querySQL?: string;
  static names(): { [key: string]: string } {
    return {
      avgExecutionMS: 'AvgExecutionMS',
      avgExecutionTimeMS: 'AvgExecutionTimeMS',
      firstLoadTime: 'FirstLoadTime',
      firstLoadTimeUTCString: 'FirstLoadTimeUTCString',
      hitCount: 'HitCount',
      mergedVersion: 'MergedVersion',
      nodeIp: 'NodeIp',
      outlineData: 'OutlineData',
      outlineId: 'OutlineId',
      outlineTime: 'OutlineTime',
      outlineTimeUTCString: 'OutlineTimeUTCString',
      planFull: 'PlanFull',
      planId: 'PlanId',
      planInfo: 'PlanInfo',
      planUnionHash: 'PlanUnionHash',
      querySQL: 'QuerySQL',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avgExecutionMS: 'number',
      avgExecutionTimeMS: 'number',
      firstLoadTime: 'number',
      firstLoadTimeUTCString: 'string',
      hitCount: 'number',
      mergedVersion: 'number',
      nodeIp: 'string',
      outlineData: 'string',
      outlineId: 'number',
      outlineTime: 'number',
      outlineTimeUTCString: 'string',
      planFull: 'string',
      planId: 'number',
      planInfo: 'string',
      planUnionHash: 'string',
      querySQL: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSQLSamplesResponseBodyData extends $dara.Model {
  /**
   * @remarks
   * Average updated rows during the execution period.
   * 
   * @example
   * 10000.0
   */
  affectedRows?: number;
  /**
   * @remarks
   * Application event waiting time (in milliseconds).
   * 
   * @example
   * 0.0
   */
  applicationWaitTime?: number;
  /**
   * @remarks
   * BlockCache hit count
   * 
   * @example
   * 99279.0
   */
  blockCacheHit?: number;
  /**
   * @remarks
   * BlockIndexCache hit count
   * 
   * @example
   * 142514.0
   */
  blockIndexCacheHit?: number;
  /**
   * @remarks
   * BloomFilterCache hit count.
   * 
   * @example
   * 0.0
   */
  bloomFilterCacheHit?: number;
  /**
   * @remarks
   * Client IP.
   * 
   * @example
   * i-bp1db****38uemejio
   */
  clientIp?: string;
  /**
   * @remarks
   * Client port.
   * 
   * @example
   * 4****
   */
  clientPort?: string;
  /**
   * @remarks
   * Concurrency event waiting time (in milliseconds).
   * 
   * @example
   * 0.0
   */
  concurrencyWaitTime?: number;
  /**
   * @remarks
   * Consistency level.
   * 
   * @example
   * 3
   */
  consistencyLevel?: string;
  /**
   * @remarks
   * CPU time (in milliseconds).
   * 
   * @example
   * 3377.57
   */
  cpuTime?: number;
  /**
   * @remarks
   * Database name.
   * 
   * @example
   * test_db
   */
  dbName?: string;
  /**
   * @remarks
   * Syntax parsing time (in milliseconds).
   * 
   * @example
   * 0.0
   */
  decodeTime?: number;
  /**
   * @remarks
   * Disk read count.
   * 
   * @example
   * 96972.0
   */
  diskReads?: number;
  /**
   * @remarks
   * Response time (in milliseconds).
   * 
   * @example
   * 2182.66
   */
  elapsedTime?: number;
  /**
   * @remarks
   * Plan execution time (in milliseconds).
   * 
   * @example
   * 8262.01
   */
  executeTime?: number;
  /**
   * @remarks
   * Whether to initiate RPC.
   * 
   * @example
   * 0.0
   */
  executorRpc?: boolean;
  /**
   * @remarks
   * Degree of parallelism.
   * 
   * @example
   * 0
   */
  expectedWorkerCount?: number;
  /**
   * @remarks
   * The full SQL text. 
   * 
   * > This parameter is unavailable.
   * 
   * @example
   * select * from test where c1 > 1 and c2 > 3;
   */
  fullSqlText?: string;
  /**
   * @remarks
   * Plan generation time (in milliseconds).
   * 
   * @example
   * 0.19
   */
  getPlanTime?: number;
  /**
   * @remarks
   * Whether to hit the execution plan.
   * 
   * @example
   * true
   */
  hitPlan?: boolean;
  /**
   * @remarks
   * Whether an internal SQL.
   * 
   * @example
   * false
   */
  inner?: boolean;
  /**
   * @remarks
   * Memstore read row count.
   * 
   * @example
   * 0
   */
  memstoreReadRows?: number;
  /**
   * @remarks
   * Network transmission time (in milliseconds).
   * 
   * @example
   * 0.0
   */
  netTime?: number;
  /**
   * @remarks
   * Network enqueue time (in milliseconds).
   * 
   * @example
   * 0.0
   */
  netWaitTime?: number;
  /**
   * @remarks
   * Database ID.
   * 
   * @example
   * 11006111****4828
   */
  obDbId?: number;
  /**
   * @remarks
   * Server  ID.
   * 
   * @example
   * 2
   */
  obServerId?: number;
  /**
   * @remarks
   * User ID.
   * 
   * @example
   * 100010
   */
  obUserId?: number;
  /**
   * @remarks
   * The parameter value of the SQL statement.
   * 
   * @example
   * 1****
   */
  paramsValue?: string;
  /**
   * @remarks
   * Average number of partition accessed during the execution period.
   * 
   * @example
   * 1.0
   */
  partitionCount?: number;
  /**
   * @remarks
   * The execution plan ID.
   * 
   * @example
   * 590****
   */
  planId?: number;
  /**
   * @remarks
   * Plan type.
   * 
   * @example
   * LOCAL
   */
  planType?: string;
  /**
   * @remarks
   * Queueing time (in milliseconds).
   * 
   * @example
   * 0.02
   */
  queueTime?: number;
  /**
   * @remarks
   * Request ID.
   * 
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @remarks
   * SQL request time.
   * 
   * @example
   * 2023-04-12T04:46:38Z
   */
  requestTime?: string;
  /**
   * @remarks
   * Result code.
   * 
   * @example
   * 0
   */
  retCode?: number;
  /**
   * @remarks
   * Retry count.
   * 
   * @example
   * 0
   */
  retryCount?: number;
  /**
   * @remarks
   * Average returned rows during the execution period.
   * 
   * @example
   * 0.0
   */
  returnRows?: number;
  /**
   * @remarks
   * RowCache hit count.
   * 
   * @example
   * 498.0
   */
  rowCacheHit?: number;
  /**
   * @remarks
   * Number of RPC sent.
   * 
   * @example
   * 8.0
   */
  rpcCount?: number;
  /**
   * @remarks
   * Schedule event waiting time (in milliseconds).
   * 
   * @example
   * 0.0
   */
  scheduleTime?: number;
  /**
   * @remarks
   * The server where the SQL is executed.
   * 
   * @example
   * i-bp1db1****8uemejio
   */
  server?: string;
  /**
   * @remarks
   * The SQL text.
   * 
   * @example
   * select ** from t
   */
  sqlText?: string;
  /**
   * @remarks
   * SQL type.
   * 
   * @example
   * select
   */
  sqlType?: string;
  /**
   * @remarks
   * Ssstore read row count.
   * 
   * @example
   * 986190
   */
  ssstoreReadRows?: number;
  /**
   * @remarks
   * Parameterized SQL text.
   * 
   * @example
   * select a from b
   */
  statement?: string;
  /**
   * @remarks
   * Whether to perform full table scan.
   * 
   * @example
   * false
   */
  tableScan?: boolean;
  /**
   * @remarks
   * Trace ID.
   * 
   * @example
   * YB42C****-0005E303D1****-0-0
   */
  traceId?: string;
  /**
   * @remarks
   * Transaction hash.
   * 
   * @example
   * 1219****927****73791
   */
  transHash?: string;
  /**
   * @remarks
   * Actual number of SQL execution threads.
   * 
   * @example
   * 0
   */
  usedWorkerCount?: number;
  /**
   * @remarks
   * UserIO event waiting time (in milliseconds).
   * 
   * @example
   * 0.0
   */
  userIoWaitTime?: number;
  /**
   * @remarks
   * Username.
   * 
   * @example
   * test_user
   */
  userName?: string;
  /**
   * @remarks
   * Wait count.
   * 
   * @example
   * 0.0
   */
  waitCount?: number;
  /**
   * @remarks
   * Longest wait event during the execution period.
   * 
   * @example
   * none
   */
  waitEvent?: string;
  /**
   * @remarks
   * Wait time (in milliseconds).
   * 
   * @example
   * 0.0
   */
  waitTime?: number;
  static names(): { [key: string]: string } {
    return {
      affectedRows: 'AffectedRows',
      applicationWaitTime: 'ApplicationWaitTime',
      blockCacheHit: 'BlockCacheHit',
      blockIndexCacheHit: 'BlockIndexCacheHit',
      bloomFilterCacheHit: 'BloomFilterCacheHit',
      clientIp: 'ClientIp',
      clientPort: 'ClientPort',
      concurrencyWaitTime: 'ConcurrencyWaitTime',
      consistencyLevel: 'ConsistencyLevel',
      cpuTime: 'CpuTime',
      dbName: 'DbName',
      decodeTime: 'DecodeTime',
      diskReads: 'DiskReads',
      elapsedTime: 'ElapsedTime',
      executeTime: 'ExecuteTime',
      executorRpc: 'ExecutorRpc',
      expectedWorkerCount: 'ExpectedWorkerCount',
      fullSqlText: 'FullSqlText',
      getPlanTime: 'GetPlanTime',
      hitPlan: 'HitPlan',
      inner: 'Inner',
      memstoreReadRows: 'MemstoreReadRows',
      netTime: 'NetTime',
      netWaitTime: 'NetWaitTime',
      obDbId: 'ObDbId',
      obServerId: 'ObServerId',
      obUserId: 'ObUserId',
      paramsValue: 'ParamsValue',
      partitionCount: 'PartitionCount',
      planId: 'PlanId',
      planType: 'PlanType',
      queueTime: 'QueueTime',
      requestId: 'RequestId',
      requestTime: 'RequestTime',
      retCode: 'RetCode',
      retryCount: 'RetryCount',
      returnRows: 'ReturnRows',
      rowCacheHit: 'RowCacheHit',
      rpcCount: 'RpcCount',
      scheduleTime: 'ScheduleTime',
      server: 'Server',
      sqlText: 'SqlText',
      sqlType: 'SqlType',
      ssstoreReadRows: 'SsstoreReadRows',
      statement: 'Statement',
      tableScan: 'TableScan',
      traceId: 'TraceId',
      transHash: 'TransHash',
      usedWorkerCount: 'UsedWorkerCount',
      userIoWaitTime: 'UserIoWaitTime',
      userName: 'UserName',
      waitCount: 'WaitCount',
      waitEvent: 'WaitEvent',
      waitTime: 'WaitTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      affectedRows: 'number',
      applicationWaitTime: 'number',
      blockCacheHit: 'number',
      blockIndexCacheHit: 'number',
      bloomFilterCacheHit: 'number',
      clientIp: 'string',
      clientPort: 'string',
      concurrencyWaitTime: 'number',
      consistencyLevel: 'string',
      cpuTime: 'number',
      dbName: 'string',
      decodeTime: 'number',
      diskReads: 'number',
      elapsedTime: 'number',
      executeTime: 'number',
      executorRpc: 'boolean',
      expectedWorkerCount: 'number',
      fullSqlText: 'string',
      getPlanTime: 'number',
      hitPlan: 'boolean',
      inner: 'boolean',
      memstoreReadRows: 'number',
      netTime: 'number',
      netWaitTime: 'number',
      obDbId: 'number',
      obServerId: 'number',
      obUserId: 'number',
      paramsValue: 'string',
      partitionCount: 'number',
      planId: 'number',
      planType: 'string',
      queueTime: 'number',
      requestId: 'string',
      requestTime: 'string',
      retCode: 'number',
      retryCount: 'number',
      returnRows: 'number',
      rowCacheHit: 'number',
      rpcCount: 'number',
      scheduleTime: 'number',
      server: 'string',
      sqlText: 'string',
      sqlType: 'string',
      ssstoreReadRows: 'number',
      statement: 'string',
      tableScan: 'boolean',
      traceId: 'string',
      transHash: 'string',
      usedWorkerCount: 'number',
      userIoWaitTime: 'number',
      userName: 'string',
      waitCount: 'number',
      waitEvent: 'string',
      waitTime: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSQLTuningAdvicesResponseBodyDataColumns extends $dara.Model {
  /**
   * @example
   * xxxx
   */
  columnName?: string;
  /**
   * @example
   * 100
   */
  maxValue?: string;
  /**
   * @example
   * 1
   */
  minValue?: string;
  /**
   * @remarks
   * NDV
   * 
   * @example
   * 100
   */
  ndv?: number;
  static names(): { [key: string]: string } {
    return {
      columnName: 'ColumnName',
      maxValue: 'MaxValue',
      minValue: 'MinValue',
      ndv: 'Ndv',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnName: 'string',
      maxValue: 'string',
      minValue: 'string',
      ndv: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSQLTuningAdvicesResponseBodyDataPlan extends $dara.Model {
  /**
   * @example
   * 0
   */
  avgApplicationWaitTime?: number;
  /**
   * @example
   * 0
   */
  avgBufferGets?: number;
  /**
   * @example
   * 0
   */
  avgConcurrencyWaitTime?: number;
  /**
   * @example
   * 100.36
   */
  avgCpuTime?: number;
  /**
   * @example
   * 0
   */
  avgDiskReads?: number;
  /**
   * @example
   * 0
   */
  avgDiskWrites?: number;
  /**
   * @example
   * 713.62
   */
  avgElapsedTime?: number;
  /**
   * @example
   * 1
   */
  avgRowProcessed?: number;
  /**
   * @example
   * 0
   */
  avgUserIoWaitTime?: number;
  /**
   * @example
   * 1672358400000000
   */
  collectTimeUs?: number;
  /**
   * @example
   * 0
   */
  delayedLargeQueryPercentage?: number;
  /**
   * @example
   * 1.45
   */
  execPs?: number;
  /**
   * @example
   * 2062
   */
  executions?: number;
  /**
   * @example
   * 2022-12-30T02:25:30.576Z
   */
  firstLoadTime?: string;
  /**
   * @example
   * 1672367130576163
   */
  firstLoadTimeUs?: number;
  /**
   * @example
   * false
   */
  hitDiagnosis?: boolean;
  /**
   * @example
   * 66.8
   */
  hitPercentage?: number;
  /**
   * @example
   * 0
   */
  largeQueryPercentage?: number;
  /**
   * @example
   * 3
   */
  mergedVersion?: number;
  /**
   * @example
   * 1108307720799259
   */
  obDbId?: number;
  /**
   * @remarks
   * server  ID。
   * 
   * @example
   * 1
   */
  obServerId?: number;
  /**
   * @example
   * xxxxx
   */
  outlineData?: string;
  /**
   * @remarks
   * Outline ID。
   * 
   * @example
   * 1
   */
  outlineId?: number;
  /**
   * @example
   * -86290582****886880
   */
  planHash?: string;
  /**
   * @example
   * 818
   */
  planId?: number;
  /**
   * @example
   * 49216
   */
  planSize?: number;
  /**
   * @example
   * LOCAL
   */
  planType?: string;
  /**
   * @example
   * 1672367130529680
   */
  schemaVersion?: number;
  /**
   * @example
   * i-bp1*****sw64dhb*****
   */
  serverSn?: string;
  /**
   * @example
   * false
   */
  tableScan?: boolean;
  /**
   * @example
   * 0
   */
  timeoutPercentage?: number;
  /**
   * @example
   * AAAAAAAAAAEAAAAAAAADMgAF8QJQwIUj
   */
  uid?: string;
  static names(): { [key: string]: string } {
    return {
      avgApplicationWaitTime: 'AvgApplicationWaitTime',
      avgBufferGets: 'AvgBufferGets',
      avgConcurrencyWaitTime: 'AvgConcurrencyWaitTime',
      avgCpuTime: 'AvgCpuTime',
      avgDiskReads: 'AvgDiskReads',
      avgDiskWrites: 'AvgDiskWrites',
      avgElapsedTime: 'AvgElapsedTime',
      avgRowProcessed: 'AvgRowProcessed',
      avgUserIoWaitTime: 'AvgUserIoWaitTime',
      collectTimeUs: 'CollectTimeUs',
      delayedLargeQueryPercentage: 'DelayedLargeQueryPercentage',
      execPs: 'ExecPs',
      executions: 'Executions',
      firstLoadTime: 'FirstLoadTime',
      firstLoadTimeUs: 'FirstLoadTimeUs',
      hitDiagnosis: 'HitDiagnosis',
      hitPercentage: 'HitPercentage',
      largeQueryPercentage: 'LargeQueryPercentage',
      mergedVersion: 'MergedVersion',
      obDbId: 'ObDbId',
      obServerId: 'ObServerId',
      outlineData: 'OutlineData',
      outlineId: 'OutlineId',
      planHash: 'PlanHash',
      planId: 'PlanId',
      planSize: 'PlanSize',
      planType: 'PlanType',
      schemaVersion: 'SchemaVersion',
      serverSn: 'ServerSn',
      tableScan: 'TableScan',
      timeoutPercentage: 'TimeoutPercentage',
      uid: 'Uid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avgApplicationWaitTime: 'number',
      avgBufferGets: 'number',
      avgConcurrencyWaitTime: 'number',
      avgCpuTime: 'number',
      avgDiskReads: 'number',
      avgDiskWrites: 'number',
      avgElapsedTime: 'number',
      avgRowProcessed: 'number',
      avgUserIoWaitTime: 'number',
      collectTimeUs: 'number',
      delayedLargeQueryPercentage: 'number',
      execPs: 'number',
      executions: 'number',
      firstLoadTime: 'string',
      firstLoadTimeUs: 'number',
      hitDiagnosis: 'boolean',
      hitPercentage: 'number',
      largeQueryPercentage: 'number',
      mergedVersion: 'number',
      obDbId: 'number',
      obServerId: 'number',
      outlineData: 'string',
      outlineId: 'number',
      planHash: 'string',
      planId: 'number',
      planSize: 'number',
      planType: 'string',
      schemaVersion: 'number',
      serverSn: 'string',
      tableScan: 'boolean',
      timeoutPercentage: 'number',
      uid: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSQLTuningAdvicesResponseBodyData extends $dara.Model {
  /**
   * @example
   * c1;c2;c3
   */
  columnNames?: string;
  columns?: DescribeSQLTuningAdvicesResponseBodyDataColumns[];
  /**
   * @example
   * test_db
   */
  dbName?: string;
  /**
   * @example
   * Local/Global
   */
  localityType?: string;
  plan?: DescribeSQLTuningAdvicesResponseBodyDataPlan;
  /**
   * @example
   * test_table
   */
  table?: string;
  /**
   * @example
   * PLAN_BINDING/INDEX_CREATION
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      columnNames: 'ColumnNames',
      columns: 'Columns',
      dbName: 'DbName',
      localityType: 'LocalityType',
      plan: 'Plan',
      table: 'Table',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnNames: 'string',
      columns: { 'type': 'array', 'itemType': DescribeSQLTuningAdvicesResponseBodyDataColumns },
      dbName: 'string',
      localityType: 'string',
      plan: DescribeSQLTuningAdvicesResponseBodyDataPlan,
      table: 'string',
      type: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.columns)) {
      $dara.Model.validateArray(this.columns);
    }
    if(this.plan && typeof (this.plan as any).validate === 'function') {
      (this.plan as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSampleSqlRawTextsResponseBodyData extends $dara.Model {
  sqlText?: string[];
  static names(): { [key: string]: string } {
    return {
      sqlText: 'SqlText',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sqlText: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(Array.isArray(this.sqlText)) {
      $dara.Model.validateArray(this.sqlText);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSecurityIpGroupsResponseBodySecurityIpGroups extends $dara.Model {
  /**
   * @example
   * online_paycore
   */
  securityIpGroupName?: string;
  /**
   * @example
   * 121.41.106.33,100.104.7.0/26
   */
  securityIps?: string;
  static names(): { [key: string]: string } {
    return {
      securityIpGroupName: 'SecurityIpGroupName',
      securityIps: 'SecurityIps',
    };
  }

  static types(): { [key: string]: any } {
    return {
      securityIpGroupName: 'string',
      securityIps: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSessionListResponseBodyData extends $dara.Model {
  /**
   * @remarks
   * The address of the client, with the format ip:port.
   * 
   * @example
   * 192.***.**.100:80
   */
  host?: string;
  /**
   * @remarks
   * The session ID of the proxy service.
   * 
   * @example
   * d2c90ad0-bc54-410f-bb89-2dcf14aa3c6d
   */
  sessionId?: string;
  static names(): { [key: string]: string } {
    return {
      host: 'Host',
      sessionId: 'SessionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      host: 'string',
      sessionId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSlowSQLHistoryListResponseBodySlowSQLHistoryListList extends $dara.Model {
  /**
   * @remarks
   * The number of rows affected.
   * 
   * @example
   * 0
   */
  affectedRows?: number;
  /**
   * @remarks
   * The wait time of the client.
   * 
   * @example
   * 0.0
   */
  appWaitTime?: number;
  /**
   * @remarks
   * The number of block cache hits.
   * 
   * @example
   * 14
   */
  blockCacheHit?: number;
  /**
   * @remarks
   * The number of block index cache hits.
   * 
   * @example
   * 4
   */
  blockIndexCacheHit?: number;
  /**
   * @remarks
   * The number of Bloom filter cache hits.
   * 
   * @example
   * 0
   */
  bloomFilterCacheHit?: number;
  /**
   * @remarks
   * The IP address of the client.
   * 
   * @example
   * 1*2.***.1*3.***
   */
  clientIp?: string;
  /**
   * @remarks
   * The wait time in concurrent execution.
   * 
   * @example
   * 0.0
   */
  concurrencyWaitTime?: number;
  /**
   * @remarks
   * The average CPU time.
   * 
   * @example
   * 50.13
   */
  cpuTime?: number;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * testdb
   */
  dbName?: string;
  /**
   * @remarks
   * The time to wait for decoding.
   * 
   * @example
   * 0.0
   */
  decodeTime?: number;
  /**
   * @remarks
   * The number of physical reads.
   * 
   * @example
   * 0
   */
  diskRead?: number;
  /**
   * @remarks
   * The average response time.
   * 
   * @example
   * 76.382
   */
  elapsedTime?: number;
  /**
   * @remarks
   * The end time.
   * 
   * @example
   * 2021-12-28T02:08:18Z
   */
  endTimeUTCString?: string;
  /**
   * @remarks
   * The wait event.
   * 
   * @example
   * mysql response wait client
   */
  event?: string;
  /**
   * @remarks
   * The number of executions per second.
   * 
   * @example
   * 163.0
   */
  execPerSecond?: number;
  /**
   * @remarks
   * The internal execution time.
   * 
   * @example
   * 61.044
   */
  executeTime?: number;
  /**
   * @remarks
   * The number of executions.
   * 
   * @example
   * 89403
   */
  executions?: number;
  /**
   * @remarks
   * The number of failures.
   * 
   * @example
   * 0
   */
  failTimes?: number;
  /**
   * @remarks
   * Hard parsing time.
   * 
   * @example
   * 0.052
   */
  getPlanTime?: number;
  /**
   * @remarks
   * The I/O wait time.
   * 
   * @example
   * 0.0
   */
  IOWaitTime?: number;
  /**
   * @remarks
   * The number of logical reads.
   * 
   * @example
   * 19
   */
  logicalRead?: number;
  /**
   * @remarks
   * The maximum CPU time.
   * 
   * @example
   * 257.967
   */
  maxCpuTime?: number;
  /**
   * @remarks
   * The maximum response time.
   * 
   * @example
   * 260.044
   */
  maxElapsedTime?: number;
  /**
   * @remarks
   * The number of rows read from the memory.
   * 
   * @example
   * 527
   */
  memstoreReadRowCount?: number;
  /**
   * @remarks
   * The number of plan misses.
   * 
   * @example
   * 0
   */
  missPlans?: number;
  /**
   * @remarks
   * The wait time for network.
   * 
   * @example
   * 0.0
   */
  netWaitTime?: number;
  /**
   * @remarks
   * The IP address of the node.
   * 
   * @example
   * i-bp18qljorblo8es*****
   */
  nodeIp?: string;
  /**
   * @remarks
   * The queuing time.
   * 
   * @example
   * 15.275
   */
  queueTime?: number;
  /**
   * @remarks
   * The number of RPCs.
   * 
   * @example
   * 0
   */
  RPCCount?: number;
  /**
   * @remarks
   * The number of remote plans.
   * 
   * @example
   * 0
   */
  remotePlans?: number;
  /**
   * @remarks
   * The number of retries.
   * 
   * @example
   * 0
   */
  retryCount?: number;
  /**
   * @remarks
   * The number of rows returned.
   * 
   * @example
   * 1
   */
  returnRows?: number;
  /**
   * @remarks
   * The number of row cache hits.
   * 
   * @example
   * 0
   */
  rowCacheHit?: number;
  /**
   * @remarks
   * The scheduling duration.
   * 
   * @example
   * 0.0
   */
  scheduleTime?: number;
  /**
   * @remarks
   * SQLID.
   * 
   * @example
   * 8D6E84****0B8FB1823D199E2CA1****
   */
  sqlId?: string;
  /**
   * @remarks
   * The SQL type.
   * 
   * @example
   * 1
   */
  sqlType?: string;
  /**
   * @remarks
   * The number of rows read from the disk.
   * 
   * @example
   * 43086
   */
  ssstoreReadRowCount?: number;
  /**
   * @remarks
   * The name of the tenant.
   * 
   * @example
   * pay_online
   */
  tenantName?: string;
  /**
   * @remarks
   * The internal wait time.
   * 
   * @example
   * 10.966
   */
  totalWaitTime?: number;
  /**
   * @remarks
   * The username.
   * 
   * @example
   * tester
   */
  userName?: string;
  static names(): { [key: string]: string } {
    return {
      affectedRows: 'AffectedRows',
      appWaitTime: 'AppWaitTime',
      blockCacheHit: 'BlockCacheHit',
      blockIndexCacheHit: 'BlockIndexCacheHit',
      bloomFilterCacheHit: 'BloomFilterCacheHit',
      clientIp: 'ClientIp',
      concurrencyWaitTime: 'ConcurrencyWaitTime',
      cpuTime: 'CpuTime',
      dbName: 'DbName',
      decodeTime: 'DecodeTime',
      diskRead: 'DiskRead',
      elapsedTime: 'ElapsedTime',
      endTimeUTCString: 'EndTimeUTCString',
      event: 'Event',
      execPerSecond: 'ExecPerSecond',
      executeTime: 'ExecuteTime',
      executions: 'Executions',
      failTimes: 'FailTimes',
      getPlanTime: 'GetPlanTime',
      IOWaitTime: 'IOWaitTime',
      logicalRead: 'LogicalRead',
      maxCpuTime: 'MaxCpuTime',
      maxElapsedTime: 'MaxElapsedTime',
      memstoreReadRowCount: 'MemstoreReadRowCount',
      missPlans: 'MissPlans',
      netWaitTime: 'NetWaitTime',
      nodeIp: 'NodeIp',
      queueTime: 'QueueTime',
      RPCCount: 'RPCCount',
      remotePlans: 'RemotePlans',
      retryCount: 'RetryCount',
      returnRows: 'ReturnRows',
      rowCacheHit: 'RowCacheHit',
      scheduleTime: 'ScheduleTime',
      sqlId: 'SqlId',
      sqlType: 'SqlType',
      ssstoreReadRowCount: 'SsstoreReadRowCount',
      tenantName: 'TenantName',
      totalWaitTime: 'TotalWaitTime',
      userName: 'UserName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      affectedRows: 'number',
      appWaitTime: 'number',
      blockCacheHit: 'number',
      blockIndexCacheHit: 'number',
      bloomFilterCacheHit: 'number',
      clientIp: 'string',
      concurrencyWaitTime: 'number',
      cpuTime: 'number',
      dbName: 'string',
      decodeTime: 'number',
      diskRead: 'number',
      elapsedTime: 'number',
      endTimeUTCString: 'string',
      event: 'string',
      execPerSecond: 'number',
      executeTime: 'number',
      executions: 'number',
      failTimes: 'number',
      getPlanTime: 'number',
      IOWaitTime: 'number',
      logicalRead: 'number',
      maxCpuTime: 'number',
      maxElapsedTime: 'number',
      memstoreReadRowCount: 'number',
      missPlans: 'number',
      netWaitTime: 'number',
      nodeIp: 'string',
      queueTime: 'number',
      RPCCount: 'number',
      remotePlans: 'number',
      retryCount: 'number',
      returnRows: 'number',
      rowCacheHit: 'number',
      scheduleTime: 'number',
      sqlId: 'string',
      sqlType: 'string',
      ssstoreReadRowCount: 'number',
      tenantName: 'string',
      totalWaitTime: 'number',
      userName: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSlowSQLHistoryListResponseBodySlowSQLHistoryList extends $dara.Model {
  /**
   * @remarks
   * The quantity.
   * 
   * @example
   * 1
   */
  count?: number;
  /**
   * @remarks
   * The return result of the request.
   */
  list?: DescribeSlowSQLHistoryListResponseBodySlowSQLHistoryListList[];
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      list: 'List',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      list: { 'type': 'array', 'itemType': DescribeSlowSQLHistoryListResponseBodySlowSQLHistoryListList },
    };
  }

  validate() {
    if(Array.isArray(this.list)) {
      $dara.Model.validateArray(this.list);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSlowSQLListResponseBodySlowSQLList extends $dara.Model {
  /**
   * @remarks
   * The number of rows affected.
   * 
   * @example
   * 0
   */
  affectedRows?: number;
  /**
   * @remarks
   * The wait time of the client.
   * 
   * @example
   * 0.0
   */
  appWaitTime?: number;
  /**
   * @remarks
   * The number of block cache hits.
   * 
   * @example
   * 14
   */
  blockCacheHit?: number;
  /**
   * @remarks
   * The number of block index cache hits.
   * 
   * @example
   * 4
   */
  blockIndexCacheHit?: number;
  /**
   * @remarks
   * The number of Bloom filter cache hits.
   * 
   * @example
   * 0
   */
  bloomFilterCacheHit?: number;
  /**
   * @remarks
   * The IP address of the client.
   * 
   * @example
   * 1*2.***.1*3.***
   */
  clientIp?: string;
  /**
   * @remarks
   * The wait time in concurrent execution.
   * 
   * @example
   * 0.0
   */
  concurrencyWaitTime?: number;
  /**
   * @remarks
   * The average CPU time.
   * 
   * @example
   * 50.13
   */
  cpuTime?: number;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * testdb
   */
  dbName?: string;
  /**
   * @remarks
   * The time to wait for decoding.
   * 
   * @example
   * 0.0
   */
  decodeTime?: number;
  /**
   * @remarks
   * The number of physical reads.
   * 
   * @example
   * 0
   */
  diskRead?: number;
  /**
   * @remarks
   * The average response time.
   * 
   * @example
   * 76.382
   */
  elapsedTime?: number;
  /**
   * @remarks
   * The wait event.
   * 
   * @example
   * mysql response wait client
   */
  event?: string;
  /**
   * @remarks
   * The number of executions per second.
   * 
   * @example
   * 163.0
   */
  execPerSecond?: number;
  /**
   * @remarks
   * The internal execution time.
   * 
   * @example
   * 61.044
   */
  executeTime?: number;
  /**
   * @remarks
   * The number of executions.
   * 
   * @example
   * 89403
   */
  executions?: number;
  /**
   * @remarks
   * The number of failures.
   * 
   * @example
   * 0
   */
  failTimes?: number;
  /**
   * @remarks
   * The time spent in hard parsing.
   * 
   * @example
   * 0.052
   */
  getPlanTime?: number;
  /**
   * @remarks
   * The I/O wait time.
   * 
   * @example
   * 0.0
   */
  IOWaitTime?: number;
  /**
   * @remarks
   * The sequence number of the returned SQL statement.
   * 
   * @example
   * 1
   */
  key?: number;
  /**
   * @remarks
   * The number of logical reads.
   * 
   * @example
   * 19
   */
  logicalRead?: number;
  /**
   * @remarks
   * The maximum CPU time.
   * 
   * @example
   * 257.967
   */
  maxCpuTime?: number;
  /**
   * @remarks
   * The maximum response time.
   * 
   * @example
   * 260.044
   */
  maxElapsedTime?: number;
  /**
   * @remarks
   * The number of rows read from the memory.
   * 
   * @example
   * 527
   */
  memstoreReadRowCount?: number;
  /**
   * @remarks
   * The number of plan misses.
   * 
   * @example
   * 0
   */
  missPlans?: number;
  /**
   * @remarks
   * The network latency.
   * 
   * @example
   * 0.0
   */
  netWaitTime?: number;
  /**
   * @remarks
   * The IP address of the node.
   * 
   * @example
   * i-bp18qljorblo8es*****
   */
  nodeIp?: string;
  /**
   * @remarks
   * The queuing time.
   * 
   * @example
   * 15.275
   */
  queueTime?: number;
  /**
   * @remarks
   * The number of RPCs.
   * 
   * @example
   * 0
   */
  RPCCount?: number;
  /**
   * @remarks
   * The number of remote plans.
   * 
   * @example
   * 0
   */
  remotePlans?: number;
  /**
   * @remarks
   * The number of retries.
   * 
   * @example
   * 0
   */
  retryCount?: number;
  /**
   * @remarks
   * The number of rows returned.
   * 
   * @example
   * 1
   */
  returnRows?: number;
  /**
   * @remarks
   * The number of row cache hits.
   * 
   * @example
   * 0
   */
  rowCacheHit?: number;
  /**
   * @remarks
   * SQLID.
   * 
   * @example
   * 8D6E84****0B8FB1823D199E2CA1****
   */
  SQLId?: string;
  /**
   * @remarks
   * The SQL text.
   * 
   * @example
   * SELECT  ****   FROM ****   WHERE **** = ? AND **** = ?   ORDER BY **** ASC
   */
  SQLText?: string;
  /**
   * @remarks
   * The SQL type.
   * 
   * @example
   * 1
   */
  SQLType?: number;
  /**
   * @remarks
   * The scheduling duration.
   * 
   * @example
   * 0.0
   */
  scheduleTime?: number;
  /**
   * @remarks
   * The number of rows read from the disk.
   * 
   * @example
   * 43086
   */
  ssstoreReadRowCount?: number;
  /**
   * @remarks
   * The internal wait time.
   * 
   * @example
   * 10.966
   */
  totalWaitTime?: number;
  /**
   * @remarks
   * The username.
   * 
   * @example
   * tester
   */
  userName?: string;
  static names(): { [key: string]: string } {
    return {
      affectedRows: 'AffectedRows',
      appWaitTime: 'AppWaitTime',
      blockCacheHit: 'BlockCacheHit',
      blockIndexCacheHit: 'BlockIndexCacheHit',
      bloomFilterCacheHit: 'BloomFilterCacheHit',
      clientIp: 'ClientIp',
      concurrencyWaitTime: 'ConcurrencyWaitTime',
      cpuTime: 'CpuTime',
      dbName: 'DbName',
      decodeTime: 'DecodeTime',
      diskRead: 'DiskRead',
      elapsedTime: 'ElapsedTime',
      event: 'Event',
      execPerSecond: 'ExecPerSecond',
      executeTime: 'ExecuteTime',
      executions: 'Executions',
      failTimes: 'FailTimes',
      getPlanTime: 'GetPlanTime',
      IOWaitTime: 'IOWaitTime',
      key: 'Key',
      logicalRead: 'LogicalRead',
      maxCpuTime: 'MaxCpuTime',
      maxElapsedTime: 'MaxElapsedTime',
      memstoreReadRowCount: 'MemstoreReadRowCount',
      missPlans: 'MissPlans',
      netWaitTime: 'NetWaitTime',
      nodeIp: 'NodeIp',
      queueTime: 'QueueTime',
      RPCCount: 'RPCCount',
      remotePlans: 'RemotePlans',
      retryCount: 'RetryCount',
      returnRows: 'ReturnRows',
      rowCacheHit: 'RowCacheHit',
      SQLId: 'SQLId',
      SQLText: 'SQLText',
      SQLType: 'SQLType',
      scheduleTime: 'ScheduleTime',
      ssstoreReadRowCount: 'SsstoreReadRowCount',
      totalWaitTime: 'TotalWaitTime',
      userName: 'UserName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      affectedRows: 'number',
      appWaitTime: 'number',
      blockCacheHit: 'number',
      blockIndexCacheHit: 'number',
      bloomFilterCacheHit: 'number',
      clientIp: 'string',
      concurrencyWaitTime: 'number',
      cpuTime: 'number',
      dbName: 'string',
      decodeTime: 'number',
      diskRead: 'number',
      elapsedTime: 'number',
      event: 'string',
      execPerSecond: 'number',
      executeTime: 'number',
      executions: 'number',
      failTimes: 'number',
      getPlanTime: 'number',
      IOWaitTime: 'number',
      key: 'number',
      logicalRead: 'number',
      maxCpuTime: 'number',
      maxElapsedTime: 'number',
      memstoreReadRowCount: 'number',
      missPlans: 'number',
      netWaitTime: 'number',
      nodeIp: 'string',
      queueTime: 'number',
      RPCCount: 'number',
      remotePlans: 'number',
      retryCount: 'number',
      returnRows: 'number',
      rowCacheHit: 'number',
      SQLId: 'string',
      SQLText: 'string',
      SQLType: 'number',
      scheduleTime: 'number',
      ssstoreReadRowCount: 'number',
      totalWaitTime: 'number',
      userName: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSqlAuditStatResponseBodyData extends $dara.Model {
  /**
   * @example
   * 1
   */
  affectRows?: number;
  /**
   * @example
   * test_database_1
   */
  databaseName?: string;
  /**
   * @example
   * 142
   */
  executeTime?: number;
  /**
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @example
   * UPDATE
   */
  operatorType?: string;
  /**
   * @example
   * 1
   */
  returnRows?: number;
  /**
   * @example
   * 1
   */
  scanRows?: number;
  /**
   * @remarks
   * Sql ID
   * 
   * @example
   * 8D6E84****0B8FB1823D199E2CA1****
   */
  sqlId?: string;
  /**
   * @example
   * UPDATE `oceanbase_test_table` SET `name` = ? WHERE `key` = ?
   */
  sqlStatement?: string;
  /**
   * @example
   * t33h8y08k****
   */
  tenantId?: string;
  /**
   * @example
   * 1
   */
  totalAffectRows?: number;
  /**
   * @example
   * 0
   */
  totalFailed?: number;
  /**
   * @example
   * 1
   */
  totalReturnRows?: number;
  /**
   * @example
   * 10
   */
  totalScanRows?: number;
  /**
   * @example
   * 1
   */
  totalSucceed?: number;
  /**
   * @example
   * xx.xx.xx.xx
   */
  userClientIp?: string;
  /**
   * @example
   * test_mysql
   */
  userName?: string;
  static names(): { [key: string]: string } {
    return {
      affectRows: 'AffectRows',
      databaseName: 'DatabaseName',
      executeTime: 'ExecuteTime',
      instanceId: 'InstanceId',
      operatorType: 'OperatorType',
      returnRows: 'ReturnRows',
      scanRows: 'ScanRows',
      sqlId: 'SqlId',
      sqlStatement: 'SqlStatement',
      tenantId: 'TenantId',
      totalAffectRows: 'TotalAffectRows',
      totalFailed: 'TotalFailed',
      totalReturnRows: 'TotalReturnRows',
      totalScanRows: 'TotalScanRows',
      totalSucceed: 'TotalSucceed',
      userClientIp: 'UserClientIp',
      userName: 'UserName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      affectRows: 'number',
      databaseName: 'string',
      executeTime: 'number',
      instanceId: 'string',
      operatorType: 'string',
      returnRows: 'number',
      scanRows: 'number',
      sqlId: 'string',
      sqlStatement: 'string',
      tenantId: 'string',
      totalAffectRows: 'number',
      totalFailed: 'number',
      totalReturnRows: 'number',
      totalScanRows: 'number',
      totalSucceed: 'number',
      userClientIp: 'string',
      userName: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStandbyCreateModeResponseBodyData extends $dara.Model {
  /**
   * @example
   * BACKUP_RESTORE
   */
  createMode?: string;
  static names(): { [key: string]: string } {
    return {
      createMode: 'CreateMode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createMode: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantResponseBodyTenantReadOnlyResourceCapacityUnit extends $dara.Model {
  /**
   * @remarks
   * The maximum number of capacity units.
   * 
   * @example
   * 16
   */
  maxCapacityUnit?: number;
  /**
   * @remarks
   * The minimum number of capacity units.
   * 
   * @example
   * 1
   */
  minCapacityUnit?: number;
  /**
   * @remarks
   * The number of used capacity units.
   * 
   * @example
   * 5
   */
  usedCapacit?: number;
  static names(): { [key: string]: string } {
    return {
      maxCapacityUnit: 'MaxCapacityUnit',
      minCapacityUnit: 'MinCapacityUnit',
      usedCapacit: 'UsedCapacit',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxCapacityUnit: 'number',
      minCapacityUnit: 'number',
      usedCapacit: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantResponseBodyTenantReadOnlyResourceCpu extends $dara.Model {
  /**
   * @remarks
   * The total number of CPU cores of the tenant.
   * 
   * @example
   * 10
   */
  totalCpu?: number;
  /**
   * @remarks
   * The number of CPU cores in each resource unit of the tenant.
   * 
   * @example
   * 8
   */
  unitCpu?: number;
  /**
   * @remarks
   * The number of CPU cores used by the cluster.
   * 
   * @example
   * 8
   */
  usedCpu?: number;
  static names(): { [key: string]: string } {
    return {
      totalCpu: 'TotalCpu',
      unitCpu: 'UnitCpu',
      usedCpu: 'UsedCpu',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCpu: 'number',
      unitCpu: 'number',
      usedCpu: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantResponseBodyTenantReadOnlyResourceDiskSize extends $dara.Model {
  /**
   * @remarks
   * The size of disk space used by the tenant, in GB.
   * 
   * @example
   * 86
   */
  usedDiskSize?: number;
  static names(): { [key: string]: string } {
    return {
      usedDiskSize: 'UsedDiskSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      usedDiskSize: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantResponseBodyTenantReadOnlyResourceLogDiskSize extends $dara.Model {
  /**
   * @remarks
   * The total log disk size of the tenant, in GB.
   * 
   * @example
   * 8.0
   */
  totalLogDisk?: number;
  /**
   * @remarks
   * The log disk size of each resource unit of the tenant, in GB.
   * 
   * @example
   * 8.0
   */
  unitLogDisk?: number;
  static names(): { [key: string]: string } {
    return {
      totalLogDisk: 'TotalLogDisk',
      unitLogDisk: 'UnitLogDisk',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalLogDisk: 'number',
      unitLogDisk: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantResponseBodyTenantReadOnlyResourceMemory extends $dara.Model {
  /**
   * @remarks
   * The total memory size of the tenant, in GB.
   * 
   * @example
   * 64
   */
  totalMemory?: number;
  /**
   * @remarks
   * The memory size of each resource unit of the tenant, in GB.
   * 
   * @example
   * 32
   */
  unitMemory?: number;
  /**
   * @remarks
   * The size of memory used by the tenant, in GB.
   * 
   * @example
   * 30
   */
  usedMemory?: number;
  static names(): { [key: string]: string } {
    return {
      totalMemory: 'TotalMemory',
      unitMemory: 'UnitMemory',
      usedMemory: 'UsedMemory',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalMemory: 'number',
      unitMemory: 'number',
      usedMemory: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantResponseBodyTenantReadOnlyResource extends $dara.Model {
  /**
   * @remarks
   * The information about capacity units.
   */
  capacityUnit?: DescribeTenantResponseBodyTenantReadOnlyResourceCapacityUnit;
  /**
   * @remarks
   * The number of CPU cores of each replica node in the cluster.
   */
  cpu?: DescribeTenantResponseBodyTenantReadOnlyResourceCpu;
  /**
   * @remarks
   * The size of the data disk.
   */
  diskSize?: DescribeTenantResponseBodyTenantReadOnlyResourceDiskSize;
  /**
   * @remarks
   * The information about the log disk resources of the tenant.
   */
  logDiskSize?: DescribeTenantResponseBodyTenantReadOnlyResourceLogDiskSize;
  /**
   * @remarks
   * The information about the memory resources of the cluster.
   */
  memory?: DescribeTenantResponseBodyTenantReadOnlyResourceMemory;
  /**
   * @remarks
   * The number of resource units in the tenant.
   * 
   * @example
   * 2
   */
  unitNum?: number;
  static names(): { [key: string]: string } {
    return {
      capacityUnit: 'CapacityUnit',
      cpu: 'Cpu',
      diskSize: 'DiskSize',
      logDiskSize: 'LogDiskSize',
      memory: 'Memory',
      unitNum: 'UnitNum',
    };
  }

  static types(): { [key: string]: any } {
    return {
      capacityUnit: DescribeTenantResponseBodyTenantReadOnlyResourceCapacityUnit,
      cpu: DescribeTenantResponseBodyTenantReadOnlyResourceCpu,
      diskSize: DescribeTenantResponseBodyTenantReadOnlyResourceDiskSize,
      logDiskSize: DescribeTenantResponseBodyTenantReadOnlyResourceLogDiskSize,
      memory: DescribeTenantResponseBodyTenantReadOnlyResourceMemory,
      unitNum: 'number',
    };
  }

  validate() {
    if(this.capacityUnit && typeof (this.capacityUnit as any).validate === 'function') {
      (this.capacityUnit as any).validate();
    }
    if(this.cpu && typeof (this.cpu as any).validate === 'function') {
      (this.cpu as any).validate();
    }
    if(this.diskSize && typeof (this.diskSize as any).validate === 'function') {
      (this.diskSize as any).validate();
    }
    if(this.logDiskSize && typeof (this.logDiskSize as any).validate === 'function') {
      (this.logDiskSize as any).validate();
    }
    if(this.memory && typeof (this.memory as any).validate === 'function') {
      (this.memory as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantResponseBodyTenantTenantConnections extends $dara.Model {
  /**
   * @remarks
   * The type of the address.
   * 
   * - MASTER: the primary address, which supports both data read and write.
   * - READONLY: a read-only address.
   * - READWRITE: a read/write splitting address.
   * - CLOGSERVICE: a clog service address.
   * 
   * @example
   * READONLY
   */
  addressType?: string;
  /**
   * @remarks
   * The logical zones of the endpoints.
   */
  connectionLogicalZones?: string[];
  /**
   * @remarks
   * The type of the replica corresponding to the tenant connection.
   * 
   * @example
   * FULL
   */
  connectionReplicaType?: string;
  /**
   * @remarks
   * The list of zones corresponding to the tenant connection.
   * 
   * @example
   * ["cn-hangzhou-i", "cn-hangzhou-j"]
   */
  connectionZones?: string[];
  /**
   * @remarks
   * Specifies whether to enable transaction splitting.
   * 
   * @example
   * false
   */
  enableTransactionSplit?: boolean;
  /**
   * @remarks
   * The Internet address for accessing the tenant.
   * 
   * @example
   * t32a7ru5u****mo.oceanbase.aliyuncs.com
   */
  internetAddress?: string;
  /**
   * @remarks
   * The status of the Internet address for accessing the tenant. Valid values:   
   * - CLOSED: The address is disabled.   
   * - ALLOCATING_INTERNET_ADDRESS: An address is being applied for.   
   * - PENDING_OFFLINE_INTERNET_ADDRESS: The address is being disabled.   
   * - ONLINE: The address is in service.
   * 
   * @example
   * CLOSED
   */
  internetAddressStatus?: string;
  /**
   * @remarks
   * The upper limit of the maximum number of public connections.
   * 
   * @example
   * 4000
   */
  internetMaxConnectionLimit?: number;
  /**
   * @remarks
   * The current value set for the maximum number of public connections.
   * 
   * @example
   * 2500
   */
  internetMaxConnectionNum?: number;
  /**
   * @remarks
   * The Internet port for accessing the tenant.
   * 
   * @example
   * 3306
   */
  internetPort?: number;
  /**
   * @remarks
   * The port for direct loads of public connections.
   * 
   * @example
   * 3307
   */
  internetRpcPort?: number;
  /**
   * @remarks
   * The intranet address for accessing the tenant.
   * 
   * @example
   * t4nunwxr0****.oceanbase.aliyuncs.com
   */
  intranetAddress?: string;
  /**
   * @remarks
   * The primary zone corresponding to the address for accessing the tenant.
   * 
   * @example
   * cn-hangzhou-b
   */
  intranetAddressMasterZoneId?: string;
  /**
   * @remarks
   * The standby zone corresponding to the address for accessing the tenant.
   * 
   * @example
   * cn-hangzhou-g
   */
  intranetAddressSlaveZoneId?: string;
  /**
   * @remarks
   * The status of the intranet address for accessing the tenant.  
   * The value ONLINE indicates that the address is in service.
   * 
   * @example
   * ONLINE
   */
  intranetAddressStatus?: string;
  /**
   * @remarks
   * The intranet port for accessing the tenant.
   * 
   * @example
   * 2983
   */
  intranetPort?: number;
  /**
   * @remarks
   * The port for direct loads of private connections.
   * 
   * @example
   * 3307
   */
  intranetRpcPort?: number;
  /**
   * @remarks
   * The port of private SQL connections.
   * 
   * @example
   * 3306
   */
  intranetSqlPort?: number;
  /**
   * @remarks
   * The current value set for the maximum number of private connections.
   * 
   * @example
   * 1000
   */
  maxConnectionLimit?: number;
  /**
   * @remarks
   * The maximum number of connections.
   * 
   * @example
   * 5000
   */
  maxConnectionNum?: number;
  /**
   * @remarks
   * The ODP version.
   * 
   * @example
   * 4.3.1-xxxxxxxxx
   */
  odpVersion?: string;
  /**
   * @remarks
   * The degree of parallelism (DOP).
   * 
   * @example
   * 1
   */
  parallelQueryDegree?: number;
  /**
   * @remarks
   * The ID of the OceanBase Database Proxy (ODP) cluster.
   * 
   * @example
   * proxy-xxxxxxx
   */
  proxyClusterId?: string;
  /**
   * @remarks
   * The ID of the tenant endpoint.
   * 
   * @example
   * obe-4tw51gp7****
   */
  tenantEndpointId?: string;
  /**
   * @remarks
   * Specifies whether to enable transaction splitting.
   * 
   * @example
   * false
   */
  transactionSplit?: boolean;
  /**
   * @remarks
   * The ID of the vSwitch.
   * 
   * @example
   * vsw-bp1i7b94u2et716yl****
   */
  vSwitchId?: string;
  /**
   * @remarks
   * The ID of the VPC.
   * 
   * @example
   * vpc-bp1qiail1asmfe23t****
   */
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      addressType: 'AddressType',
      connectionLogicalZones: 'ConnectionLogicalZones',
      connectionReplicaType: 'ConnectionReplicaType',
      connectionZones: 'ConnectionZones',
      enableTransactionSplit: 'EnableTransactionSplit',
      internetAddress: 'InternetAddress',
      internetAddressStatus: 'InternetAddressStatus',
      internetMaxConnectionLimit: 'InternetMaxConnectionLimit',
      internetMaxConnectionNum: 'InternetMaxConnectionNum',
      internetPort: 'InternetPort',
      internetRpcPort: 'InternetRpcPort',
      intranetAddress: 'IntranetAddress',
      intranetAddressMasterZoneId: 'IntranetAddressMasterZoneId',
      intranetAddressSlaveZoneId: 'IntranetAddressSlaveZoneId',
      intranetAddressStatus: 'IntranetAddressStatus',
      intranetPort: 'IntranetPort',
      intranetRpcPort: 'IntranetRpcPort',
      intranetSqlPort: 'IntranetSqlPort',
      maxConnectionLimit: 'MaxConnectionLimit',
      maxConnectionNum: 'MaxConnectionNum',
      odpVersion: 'OdpVersion',
      parallelQueryDegree: 'ParallelQueryDegree',
      proxyClusterId: 'ProxyClusterId',
      tenantEndpointId: 'TenantEndpointId',
      transactionSplit: 'TransactionSplit',
      vSwitchId: 'VSwitchId',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addressType: 'string',
      connectionLogicalZones: { 'type': 'array', 'itemType': 'string' },
      connectionReplicaType: 'string',
      connectionZones: { 'type': 'array', 'itemType': 'string' },
      enableTransactionSplit: 'boolean',
      internetAddress: 'string',
      internetAddressStatus: 'string',
      internetMaxConnectionLimit: 'number',
      internetMaxConnectionNum: 'number',
      internetPort: 'number',
      internetRpcPort: 'number',
      intranetAddress: 'string',
      intranetAddressMasterZoneId: 'string',
      intranetAddressSlaveZoneId: 'string',
      intranetAddressStatus: 'string',
      intranetPort: 'number',
      intranetRpcPort: 'number',
      intranetSqlPort: 'number',
      maxConnectionLimit: 'number',
      maxConnectionNum: 'number',
      odpVersion: 'string',
      parallelQueryDegree: 'number',
      proxyClusterId: 'string',
      tenantEndpointId: 'string',
      transactionSplit: 'boolean',
      vSwitchId: 'string',
      vpcId: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.connectionLogicalZones)) {
      $dara.Model.validateArray(this.connectionLogicalZones);
    }
    if(Array.isArray(this.connectionZones)) {
      $dara.Model.validateArray(this.connectionZones);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantResponseBodyTenantTenantResourceCapacityUnit extends $dara.Model {
  /**
   * @remarks
   * The maximum number of capacity units.
   * 
   * @example
   * 16
   */
  maxCapacityUnit?: number;
  /**
   * @remarks
   * The minimum number of capacity units.
   * 
   * @example
   * 1
   */
  minCapacityUnit?: number;
  /**
   * @remarks
   * The number of used capacity units.
   * 
   * @example
   * 5
   */
  usedCapacit?: number;
  static names(): { [key: string]: string } {
    return {
      maxCapacityUnit: 'MaxCapacityUnit',
      minCapacityUnit: 'MinCapacityUnit',
      usedCapacit: 'UsedCapacit',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxCapacityUnit: 'number',
      minCapacityUnit: 'number',
      usedCapacit: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantResponseBodyTenantTenantResourceCpu extends $dara.Model {
  /**
   * @remarks
   * The total number of CPU cores of the tenant.
   * 
   * @example
   * 10
   */
  totalCpu?: number;
  /**
   * @remarks
   * The number of CPU cores in each resource unit of the tenant.
   * 
   * @example
   * 8
   */
  unitCpu?: number;
  /**
   * @remarks
   * The number of used CPU cores of the tenant.
   * 
   * @example
   * 8
   */
  usedCpu?: number;
  static names(): { [key: string]: string } {
    return {
      totalCpu: 'TotalCpu',
      unitCpu: 'UnitCpu',
      usedCpu: 'UsedCpu',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalCpu: 'number',
      unitCpu: 'number',
      usedCpu: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantResponseBodyTenantTenantResourceDiskSize extends $dara.Model {
  /**
   * @remarks
   * The size of used disk space of the tenant, in GB.
   * 
   * @example
   * 86
   */
  usedDiskSize?: number;
  static names(): { [key: string]: string } {
    return {
      usedDiskSize: 'UsedDiskSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      usedDiskSize: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantResponseBodyTenantTenantResourceLogDiskSize extends $dara.Model {
  /**
   * @remarks
   * The total size of log disk of the tenant, in GB.
   * 
   * @example
   * 8.0
   */
  totalLogDisk?: number;
  /**
   * @remarks
   * The log disk size of each resource unit of the tenant, in GB.
   * 
   * @example
   * 8.0
   */
  unitLogDisk?: number;
  static names(): { [key: string]: string } {
    return {
      totalLogDisk: 'TotalLogDisk',
      unitLogDisk: 'UnitLogDisk',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalLogDisk: 'number',
      unitLogDisk: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantResponseBodyTenantTenantResourceMemory extends $dara.Model {
  /**
   * @remarks
   * The total memory size of the tenant, in GB.
   * 
   * @example
   * 64
   */
  totalMemory?: number;
  /**
   * @remarks
   * The memory size of each resource unit of the tenant, in GB.
   * 
   * @example
   * 32
   */
  unitMemory?: number;
  /**
   * @remarks
   * The size of used memory of the tenant, in GB.
   * 
   * @example
   * 30
   */
  usedMemory?: number;
  static names(): { [key: string]: string } {
    return {
      totalMemory: 'TotalMemory',
      unitMemory: 'UnitMemory',
      usedMemory: 'UsedMemory',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalMemory: 'number',
      unitMemory: 'number',
      usedMemory: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantResponseBodyTenantTenantResource extends $dara.Model {
  /**
   * @remarks
   * The information about capacity units.
   */
  capacityUnit?: DescribeTenantResponseBodyTenantTenantResourceCapacityUnit;
  /**
   * @remarks
   * The information about the CPU resources of the tenant.
   */
  cpu?: DescribeTenantResponseBodyTenantTenantResourceCpu;
  /**
   * @remarks
   * The information about the disk resources of the tenant.
   */
  diskSize?: DescribeTenantResponseBodyTenantTenantResourceDiskSize;
  /**
   * @remarks
   * The information about the log disk resources of the tenant.
   */
  logDiskSize?: DescribeTenantResponseBodyTenantTenantResourceLogDiskSize;
  /**
   * @remarks
   * The information about the memory resources of the tenant.
   */
  memory?: DescribeTenantResponseBodyTenantTenantResourceMemory;
  /**
   * @remarks
   * The number of resource units for the tenant.
   * 
   * @example
   * 1
   */
  unitNum?: number;
  static names(): { [key: string]: string } {
    return {
      capacityUnit: 'CapacityUnit',
      cpu: 'Cpu',
      diskSize: 'DiskSize',
      logDiskSize: 'LogDiskSize',
      memory: 'Memory',
      unitNum: 'UnitNum',
    };
  }

  static types(): { [key: string]: any } {
    return {
      capacityUnit: DescribeTenantResponseBodyTenantTenantResourceCapacityUnit,
      cpu: DescribeTenantResponseBodyTenantTenantResourceCpu,
      diskSize: DescribeTenantResponseBodyTenantTenantResourceDiskSize,
      logDiskSize: DescribeTenantResponseBodyTenantTenantResourceLogDiskSize,
      memory: DescribeTenantResponseBodyTenantTenantResourceMemory,
      unitNum: 'number',
    };
  }

  validate() {
    if(this.capacityUnit && typeof (this.capacityUnit as any).validate === 'function') {
      (this.capacityUnit as any).validate();
    }
    if(this.cpu && typeof (this.cpu as any).validate === 'function') {
      (this.cpu as any).validate();
    }
    if(this.diskSize && typeof (this.diskSize as any).validate === 'function') {
      (this.diskSize as any).validate();
    }
    if(this.logDiskSize && typeof (this.logDiskSize as any).validate === 'function') {
      (this.logDiskSize as any).validate();
    }
    if(this.memory && typeof (this.memory as any).validate === 'function') {
      (this.memory as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantResponseBodyTenantTenantZonesTenantZoneReplicas extends $dara.Model {
  /**
   * @remarks
   * The ID of the full-featured replica.
   * 
   * @example
   * 3
   */
  fullCopyId?: number;
  /**
   * @remarks
   * The name of the logical zone.
   * 
   * @example
   * cn-shanghai-f-z0
   */
  logicZoneName?: string;
  /**
   * @remarks
   * The ID of the read-only replica.
   * 
   * @example
   * 3
   */
  readOnlyCopyId?: string;
  /**
   * @remarks
   * The type of the read-only replica.
   * 
   * @example
   * ROW_STORE
   */
  readOnlyReplicaType?: string;
  /**
   * @remarks
   * The ID of the zone replica.
   * 
   * @example
   * 2
   */
  zoneCopyId?: number;
  /**
   * @remarks
   * The number of nodes in the zone.
   * 
   * @example
   * 1
   */
  zoneNodes?: number;
  /**
   * @remarks
   * The type of the zone replica.
   * 
   * @example
   * FULL
   */
  zoneReplicaType?: string;
  static names(): { [key: string]: string } {
    return {
      fullCopyId: 'FullCopyId',
      logicZoneName: 'LogicZoneName',
      readOnlyCopyId: 'ReadOnlyCopyId',
      readOnlyReplicaType: 'ReadOnlyReplicaType',
      zoneCopyId: 'ZoneCopyId',
      zoneNodes: 'ZoneNodes',
      zoneReplicaType: 'ZoneReplicaType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fullCopyId: 'number',
      logicZoneName: 'string',
      readOnlyCopyId: 'string',
      readOnlyReplicaType: 'string',
      zoneCopyId: 'number',
      zoneNodes: 'number',
      zoneReplicaType: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantResponseBodyTenantTenantZones extends $dara.Model {
  /**
   * @remarks
   * The region where the zone of the tenant resides.
   * 
   * @example
   * cn-hangzhou
   */
  region?: string;
  /**
   * @remarks
   * The ID of the zone.
   * 
   * @example
   * cn-hangzhou-h
   */
  tenantZoneId?: string;
  /**
   * @remarks
   * The zone replicas of the tenant.
   */
  tenantZoneReplicas?: DescribeTenantResponseBodyTenantTenantZonesTenantZoneReplicas[];
  /**
   * @remarks
   * The role of the zone of the tenant.
   * 
   * @example
   * ReadWrite
   */
  tenantZoneRole?: string;
  static names(): { [key: string]: string } {
    return {
      region: 'Region',
      tenantZoneId: 'TenantZoneId',
      tenantZoneReplicas: 'TenantZoneReplicas',
      tenantZoneRole: 'TenantZoneRole',
    };
  }

  static types(): { [key: string]: any } {
    return {
      region: 'string',
      tenantZoneId: 'string',
      tenantZoneReplicas: { 'type': 'array', 'itemType': DescribeTenantResponseBodyTenantTenantZonesTenantZoneReplicas },
      tenantZoneRole: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.tenantZoneReplicas)) {
      $dara.Model.validateArray(this.tenantZoneReplicas);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantResponseBodyTenant extends $dara.Model {
  /**
   * @remarks
   * The list of zones.
   */
  availableZones?: string[];
  /**
   * @remarks
   * The character set.
   * 
   * @example
   * utf8mb4
   */
  charset?: string;
  /**
   * @remarks
   * The enabling status of the clog service.  
   * - CLOSED: The clog service is disabled.  
   * - ONLINE: The clog service is running.
   * 
   * @example
   * CLOSED
   */
  clogServiceStatus?: string;
  /**
   * @remarks
   * The collation.
   * 
   * @example
   * utf8mb4_general_ci
   */
  collation?: string;
  /**
   * @remarks
   * The time when the tenant was created.
   * 
   * @example
   * 2023-04-21 11:15:47.0
   */
  createTime?: string;
  /**
   * @remarks
   * The major compaction time of the tenant. This parameter is supported only in OceanBase Database V4.0.0 and later.
   * 
   * @example
   * 02:36Z
   */
  dataMergeTime?: string;
  /**
   * @remarks
   * The data replica distribution mode of the tenant.    
   * 
   * - For the high availability version, N-N-N indicates the three-zone mode, and N-N indicates the dual-zone or single-zone mode.
   * - For the basic version, N indicates the single-zone mode. 
   * 
   * > <br>N represents the number of nodes in a single zone.
   * 
   * @example
   * 1-1-1
   */
  deployMode?: string;
  /**
   * @remarks
   * The deployment type of the cluster. Valid values:  
   * - multiple: multi-IDC deployment   
   * - single: single-IDC deployment   
   * - dual: dual-IDC deployment
   * 
   * @example
   * multiple
   */
  deployType?: string;
  /**
   * @remarks
   * The description of the tenant.
   * 
   * @example
   * paycore database
   */
  description?: string;
  /**
   * @remarks
   * The type of the disk.
   * 
   * @example
   * cloud_essd_pl1
   */
  diskType?: string;
  /**
   * @remarks
   * Indicates whether the binlog service is available for application.
   * 
   * @example
   * true
   */
  enableBinlogService?: boolean;
  /**
   * @remarks
   * Indicates whether the clog service is available. To enable the clog service, submit a ticket.
   * 
   * @example
   * false
   */
  enableClogService?: boolean;
  /**
   * @remarks
   * Indicates whether the Internet address can be enabled for the tenant.
   * 
   * @example
   * true
   */
  enableInternetAddressService?: boolean;
  /**
   * @remarks
   * Indicates whether parallel query can be enabled.
   * 
   * @example
   * true
   */
  enableParallelQuery?: boolean;
  /**
   * @remarks
   * Indicates whether read-only replicas are supported.
   * 
   * @example
   * true
   */
  enableReadOnlyReplica?: boolean;
  /**
   * @remarks
   * Indicates whether to enable read/write splitting endpoint.
   * 
   * @example
   * false
   */
  enableReadWriteSplit?: boolean;
  /**
   * @remarks
   * The type of the instance.
   * 
   * @example
   * KAFKA_PUBLIC
   */
  instanceType?: string;
  /**
   * @remarks
   * Indicates whether the table name is case-sensitive. Valid values: 
   * * **1**: The table name is case-insensitive. 
   * * **0**: The table name is case-sensitive.
   * 
   * @example
   * 1
   */
  lowerCaseTableNames?: number;
  /**
   * @remarks
   * The zone where the primary node is located.
   * 
   * @example
   * cn-hangzhou-h
   */
  masterIntranetAddressZone?: string;
  /**
   * @remarks
   * The maximum value of DOP.
   * 
   * @example
   * 32
   */
  maxParallelQueryDegree?: number;
  /**
   * @remarks
   * The ODP version.
   * 
   * @example
   * 4.3.1-xxxxxxxxx
   */
  odpVersion?: string;
  /**
   * @remarks
   * The parameter template.
   * 
   * @example
   * express_oltp
   */
  parameterTemplate?: string;
  /**
   * @remarks
   * The type of the payment.
   * 
   * @example
   * POSTPAY
   */
  payType?: string;
  /**
   * @remarks
   * The primary zone of the tenant.
   * 
   * @example
   * cn-hangzhou-h
   */
  primaryZone?: string;
  /**
   * @remarks
   * The deployment type of the primary zone.
   * 
   * @example
   * RANDOM
   */
  primaryZoneDeployType?: string;
  /**
   * @remarks
   * The information about read-only resources.
   */
  readOnlyResource?: DescribeTenantResponseBodyTenantReadOnlyResource;
  /**
   * @remarks
   * The status of the recycle bin in the tenant. Valid values: 
   * * ON: The recycly bin is enabled. 
   * * OFF: The recycle bin is disabled.
   * 
   * @example
   * ON
   */
  recycleBinStatus?: string;
  /**
   * @remarks
   * The series of the instance.
   * 
   * @example
   * normal
   */
  series?: string;
  /**
   * @remarks
   * The status of the tenant.
   * 
   * - ONLINE: The tenant is running.
   * 
   * - PENDING_CREATE: The tenant is being created.
   * 
   * - WAITING_ALLOCATE_MASTER_ADDRESS: The standby cluster is waiting for the primary address to be created.
   * 
   * - ALLOCATING_MASTER_ADDRESS: The primary address is being created.
   * 
   * - DELETING_MASTER_ADDRESS: The primary address is being deleted.
   * 
   * - ALLOCATING_INTERNET_ADDRESS: The Internet address is being created.
   * 
   * - PENDING_OFFLINE_INTERNET_ADDRESS: The Internet address is being deleted.
   * 
   * - ALLOCATING_READONLY_ADDRESS: The read-only address is being created.
   * 
   * - DELETING_READONLY_ADDRESS: The read-only address is being deleted.
   * 
   * - ALLOCATING_READWRITE_ADDRESS: The read/write splitting address is being created.
   * 
   * - DELETING_READWRITE_ADDRESS: The read/write splitting address is being deleted.
   * 
   * - ALLOCATING_CLOGSERVICE_ADDRESS: The clog address is being created.
   * 
   * - DELETING_CLOGSERVICE_ADDRESS: The clog address is being deleted.
   * 
   * - MODIFYING_ADDRESS: The domain name of the address is being modified.
   * 
   * - MODIFYING_PRIMARY_ZONE: The primary zone is being switched.
   * 
   * - MODIFYING_READONLY_ADDRESS: The read-only address is being modified.
   * 
   * - MODIFYING_READWRITE_ADDRESS: The read/write splitting address is being modified.
   * 
   * - SPEC_MODIFYING: The specifications of the tenant are being modified.
   * 
   * - WHITE_LIST_MODIFYING: The allowlist is being modified.
   * 
   * - CREATING_BINLOG: Binlogs are being created.
   * 
   * @example
   * ONLINE
   */
  status?: string;
  /**
   * @remarks
   * The connection information of the tenant.
   */
  tenantConnections?: DescribeTenantResponseBodyTenantTenantConnections[];
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * @example
   * t4louaeei****
   */
  tenantId?: string;
  /**
   * @remarks
   * The maximum number of connections allowed in the tenant.
   * 
   * @example
   * 1600
   */
  tenantMaxConnections?: string;
  /**
   * @remarks
   * The mode of the tenant.
   * Valid values:
   * - Oracle   
   * - MySQL
   * 
   * @example
   * MySQL
   */
  tenantMode?: string;
  /**
   * @remarks
   * The name of the tenant.
   * 
   * @example
   * forMySQLTenant
   */
  tenantName?: string;
  /**
   * @remarks
   * The resource information of the tenant.
   */
  tenantResource?: DescribeTenantResponseBodyTenantTenantResource;
  /**
   * @remarks
   * The information about zones in the tenant.
   */
  tenantZones?: DescribeTenantResponseBodyTenantTenantZones[];
  /**
   * @remarks
   * The time zone.
   * 
   * @example
   * Asia/Shanghai
   */
  timeZone?: string;
  /**
   * @remarks
   * The version information.
   * 
   * @example
   * 4.2.1
   */
  version?: string;
  /**
   * @remarks
   * The Virtual Private Cloud (VPC) ID of the tenant. If no suitable VPC is available, create a VPC as prompted. For more information, see "What is a VPC".
   * 
   * @example
   * vpc-bp1d2q3mhg9i23ofi****
   */
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      availableZones: 'AvailableZones',
      charset: 'Charset',
      clogServiceStatus: 'ClogServiceStatus',
      collation: 'Collation',
      createTime: 'CreateTime',
      dataMergeTime: 'DataMergeTime',
      deployMode: 'DeployMode',
      deployType: 'DeployType',
      description: 'Description',
      diskType: 'DiskType',
      enableBinlogService: 'EnableBinlogService',
      enableClogService: 'EnableClogService',
      enableInternetAddressService: 'EnableInternetAddressService',
      enableParallelQuery: 'EnableParallelQuery',
      enableReadOnlyReplica: 'EnableReadOnlyReplica',
      enableReadWriteSplit: 'EnableReadWriteSplit',
      instanceType: 'InstanceType',
      lowerCaseTableNames: 'LowerCaseTableNames',
      masterIntranetAddressZone: 'MasterIntranetAddressZone',
      maxParallelQueryDegree: 'MaxParallelQueryDegree',
      odpVersion: 'OdpVersion',
      parameterTemplate: 'ParameterTemplate',
      payType: 'PayType',
      primaryZone: 'PrimaryZone',
      primaryZoneDeployType: 'PrimaryZoneDeployType',
      readOnlyResource: 'ReadOnlyResource',
      recycleBinStatus: 'RecycleBinStatus',
      series: 'Series',
      status: 'Status',
      tenantConnections: 'TenantConnections',
      tenantId: 'TenantId',
      tenantMaxConnections: 'TenantMaxConnections',
      tenantMode: 'TenantMode',
      tenantName: 'TenantName',
      tenantResource: 'TenantResource',
      tenantZones: 'TenantZones',
      timeZone: 'TimeZone',
      version: 'Version',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      availableZones: { 'type': 'array', 'itemType': 'string' },
      charset: 'string',
      clogServiceStatus: 'string',
      collation: 'string',
      createTime: 'string',
      dataMergeTime: 'string',
      deployMode: 'string',
      deployType: 'string',
      description: 'string',
      diskType: 'string',
      enableBinlogService: 'boolean',
      enableClogService: 'boolean',
      enableInternetAddressService: 'boolean',
      enableParallelQuery: 'boolean',
      enableReadOnlyReplica: 'boolean',
      enableReadWriteSplit: 'boolean',
      instanceType: 'string',
      lowerCaseTableNames: 'number',
      masterIntranetAddressZone: 'string',
      maxParallelQueryDegree: 'number',
      odpVersion: 'string',
      parameterTemplate: 'string',
      payType: 'string',
      primaryZone: 'string',
      primaryZoneDeployType: 'string',
      readOnlyResource: DescribeTenantResponseBodyTenantReadOnlyResource,
      recycleBinStatus: 'string',
      series: 'string',
      status: 'string',
      tenantConnections: { 'type': 'array', 'itemType': DescribeTenantResponseBodyTenantTenantConnections },
      tenantId: 'string',
      tenantMaxConnections: 'string',
      tenantMode: 'string',
      tenantName: 'string',
      tenantResource: DescribeTenantResponseBodyTenantTenantResource,
      tenantZones: { 'type': 'array', 'itemType': DescribeTenantResponseBodyTenantTenantZones },
      timeZone: 'string',
      version: 'string',
      vpcId: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.availableZones)) {
      $dara.Model.validateArray(this.availableZones);
    }
    if(this.readOnlyResource && typeof (this.readOnlyResource as any).validate === 'function') {
      (this.readOnlyResource as any).validate();
    }
    if(Array.isArray(this.tenantConnections)) {
      $dara.Model.validateArray(this.tenantConnections);
    }
    if(this.tenantResource && typeof (this.tenantResource as any).validate === 'function') {
      (this.tenantResource as any).validate();
    }
    if(Array.isArray(this.tenantZones)) {
      $dara.Model.validateArray(this.tenantZones);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantEncryptionResponseBodyTenantEncryptions extends $dara.Model {
  /**
   * @example
   * false
   */
  enableEncryption?: boolean;
  /**
   * @example
   * xxx
   */
  encryptionKeyId?: string;
  /**
   * @example
   * INTERNAL
   */
  encryptionType?: string;
  /**
   * @example
   * OPEN
   */
  status?: string;
  /**
   * @example
   * t4louaeei****
   */
  tenantId?: string;
  /**
   * @example
   * MySQL
   */
  tenantMode?: string;
  /**
   * @example
   * forMySQLTenant
   */
  tenantName?: string;
  /**
   * @example
   * ONLINE
   */
  tenantStatus?: string;
  static names(): { [key: string]: string } {
    return {
      enableEncryption: 'EnableEncryption',
      encryptionKeyId: 'EncryptionKeyId',
      encryptionType: 'EncryptionType',
      status: 'Status',
      tenantId: 'TenantId',
      tenantMode: 'TenantMode',
      tenantName: 'TenantName',
      tenantStatus: 'TenantStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enableEncryption: 'boolean',
      encryptionKeyId: 'string',
      encryptionType: 'string',
      status: 'string',
      tenantId: 'string',
      tenantMode: 'string',
      tenantName: 'string',
      tenantStatus: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantReadableScnResponseBodyData extends $dara.Model {
  /**
   * @remarks
   * The maximum readable timestamp.
   * 
   * @example
   * 1715329164977
   */
  readableScn?: number;
  static names(): { [key: string]: string } {
    return {
      readableScn: 'ReadableScn',
    };
  }

  static types(): { [key: string]: any } {
    return {
      readableScn: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantSecurityConfigsResponseBodyConfigsTenantSecurityConfigsSecurityConfigs extends $dara.Model {
  /**
   * @remarks
   * The name of the check item.
   * 
   * @example
   * Check whether the scope of the cluster allowlist is too big
   */
  configDescription?: string;
  /**
   * @remarks
   * The group of the risk.
   * 
   * @example
   * WHITELIST
   */
  configGroup?: string;
  /**
   * @remarks
   * The name of the risk.
   * 
   * @example
   * WHITELIST_RANGE_LARGE
   */
  configName?: string;
  /**
   * @remarks
   * Indicates whether the risk causes security issues.
   * 
   * @example
   * true
   */
  risk?: boolean;
  /**
   * @remarks
   * The description of the risk.
   * 
   * @example
   * The scope of the allowlist is too big.
   */
  riskDescription?: string;
  static names(): { [key: string]: string } {
    return {
      configDescription: 'ConfigDescription',
      configGroup: 'ConfigGroup',
      configName: 'ConfigName',
      risk: 'Risk',
      riskDescription: 'RiskDescription',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configDescription: 'string',
      configGroup: 'string',
      configName: 'string',
      risk: 'boolean',
      riskDescription: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantSecurityConfigsResponseBodyConfigsTenantSecurityConfigs extends $dara.Model {
  /**
   * @remarks
   * The number of detected tenant security risks.
   * 
   * @example
   * 0
   */
  riskCount?: number;
  /**
   * @remarks
   * The list of risks.
   */
  securityConfigs?: DescribeTenantSecurityConfigsResponseBodyConfigsTenantSecurityConfigsSecurityConfigs[];
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * @example
   * xxx
   */
  tenantId?: string;
  /**
   * @remarks
   * The name of the tenant.
   * 
   * @example
   * xxx
   */
  tenantName?: string;
  static names(): { [key: string]: string } {
    return {
      riskCount: 'RiskCount',
      securityConfigs: 'SecurityConfigs',
      tenantId: 'TenantId',
      tenantName: 'TenantName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      riskCount: 'number',
      securityConfigs: { 'type': 'array', 'itemType': DescribeTenantSecurityConfigsResponseBodyConfigsTenantSecurityConfigsSecurityConfigs },
      tenantId: 'string',
      tenantName: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.securityConfigs)) {
      $dara.Model.validateArray(this.securityConfigs);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantSecurityConfigsResponseBodyConfigs extends $dara.Model {
  /**
   * @remarks
   * The unique identifier of the check.
   * 
   * @example
   * xxx
   */
  checkId?: string;
  /**
   * @remarks
   * The time when the check was performed.
   * 
   * @example
   * 2023-08-07 15:30:00
   */
  checkTime?: string;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The check result.
   */
  tenantSecurityConfigs?: DescribeTenantSecurityConfigsResponseBodyConfigsTenantSecurityConfigs[];
  /**
   * @remarks
   * The total number of security check items.
   * 
   * @example
   * 4
   */
  totalCheckCount?: number;
  /**
   * @remarks
   * The total number of detected security risks.
   * 
   * @example
   * 0
   */
  totalRiskCount?: number;
  static names(): { [key: string]: string } {
    return {
      checkId: 'CheckId',
      checkTime: 'CheckTime',
      instanceId: 'InstanceId',
      tenantSecurityConfigs: 'TenantSecurityConfigs',
      totalCheckCount: 'TotalCheckCount',
      totalRiskCount: 'TotalRiskCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkId: 'string',
      checkTime: 'string',
      instanceId: 'string',
      tenantSecurityConfigs: { 'type': 'array', 'itemType': DescribeTenantSecurityConfigsResponseBodyConfigsTenantSecurityConfigs },
      totalCheckCount: 'number',
      totalRiskCount: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.tenantSecurityConfigs)) {
      $dara.Model.validateArray(this.tenantSecurityConfigs);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantSecurityIpGroupsResponseBodySecurityIpGroups extends $dara.Model {
  /**
   * @remarks
   * The group name.
   * 
   * @example
   * test1
   */
  securityIpGroupName?: string;
  /**
   * @remarks
   * The whitelist group type.
   * - instance: the whitelist group from the cluster.
   * - tenant: the whitelist group of the current tenant.
   * 
   * @example
   * tenant
   */
  securityIpGroupType?: string;
  /**
   * @remarks
   * The whitelist of IP addresses. It is a string separated by commas, and each object is an IP string or a CIDR block.
   * 
   * @example
   * 192.***.*.*"
   */
  securityIps?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * @example
   * t4louaeei****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      securityIpGroupName: 'SecurityIpGroupName',
      securityIpGroupType: 'SecurityIpGroupType',
      securityIps: 'SecurityIps',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      securityIpGroupName: 'string',
      securityIpGroupType: 'string',
      securityIps: 'string',
      tenantId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantTagsResponseBodyTagResources extends $dara.Model {
  /**
   * @remarks
   * The ID of the resource.
   * 
   * @example
   * ob317v4uif****
   */
  resourceId?: string;
  /**
   * @remarks
   * The type of the resource.
   * 
   * @example
   * instance
   */
  resourceType?: string;
  /**
   * @remarks
   * The tag of the resource.
   * 
   * @example
   * [{"Key": "xxx", "Value", "xxx"},{}]
   */
  tag?: string;
  static names(): { [key: string]: string } {
    return {
      resourceId: 'ResourceId',
      resourceType: 'ResourceType',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceId: 'string',
      resourceType: 'string',
      tag: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantUsersResponseBodyTenantUsersDatabases extends $dara.Model {
  /**
   * @example
   * db_pay1
   */
  database?: string;
  privileges?: string;
  /**
   * @example
   * ReadOnly
   */
  role?: string;
  /**
   * @example
   * tbl_pay1
   */
  table?: string;
  static names(): { [key: string]: string } {
    return {
      database: 'Database',
      privileges: 'Privileges',
      role: 'Role',
      table: 'Table',
    };
  }

  static types(): { [key: string]: any } {
    return {
      database: 'string',
      privileges: 'string',
      role: 'string',
      table: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantUsersResponseBodyTenantUsers extends $dara.Model {
  databases?: DescribeTenantUsersResponseBodyTenantUsersDatabases[];
  /**
   * @example
   * use for test
   */
  description?: string;
  /**
   * @example
   * Encrypt,Decrypt
   */
  globalPermissions?: string;
  /**
   * @remarks
   * 所属集群Id
   * 
   * @example
   * obshc32****
   */
  instanceId?: string;
  /**
   * @remarks
   * 所属租户Id
   * 
   * @example
   * tshfs3****
   */
  tenantId?: string;
  /**
   * @example
   * pay_test
   */
  userName?: string;
  /**
   * @example
   * NORMAL
   */
  userStatus?: string;
  /**
   * @example
   * NORMAL
   */
  userType?: string;
  static names(): { [key: string]: string } {
    return {
      databases: 'Databases',
      description: 'Description',
      globalPermissions: 'GlobalPermissions',
      instanceId: 'InstanceId',
      tenantId: 'TenantId',
      userName: 'UserName',
      userStatus: 'UserStatus',
      userType: 'UserType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      databases: { 'type': 'array', 'itemType': DescribeTenantUsersResponseBodyTenantUsersDatabases },
      description: 'string',
      globalPermissions: 'string',
      instanceId: 'string',
      tenantId: 'string',
      userName: 'string',
      userStatus: 'string',
      userType: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.databases)) {
      $dara.Model.validateArray(this.databases);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantZonesReadResponseBodyTenantZones extends $dara.Model {
  /**
   * @remarks
   * Example 1
   * 
   * @example
   * true
   */
  isElectable?: boolean;
  /**
   * @example
   * true
   */
  isPrimary?: boolean;
  /**
   * @example
   * true
   */
  isReadable?: string;
  /**
   * @example
   * cn-hangzhou-i
   */
  zone?: string;
  static names(): { [key: string]: string } {
    return {
      isElectable: 'IsElectable',
      isPrimary: 'IsPrimary',
      isReadable: 'IsReadable',
      zone: 'Zone',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isElectable: 'boolean',
      isPrimary: 'boolean',
      isReadable: 'string',
      zone: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantsResponseBodyTenants extends $dara.Model {
  /**
   * @remarks
   * The character set.
   * 
   * @example
   * utf8mb4
   */
  charset?: string;
  /**
   * @remarks
   * The collation.
   * 
   * @example
   * utf8mb4_general_ci
   */
  collation?: string;
  /**
   * @remarks
   * The total number of CPU cores of the tenant.
   * 
   * @example
   * 10
   */
  cpu?: number;
  /**
   * @remarks
   * The time when the tenant was created.
   * 
   * @example
   * 2021-09-17 15:52:17.0
   */
  createTime?: string;
  /**
   * @remarks
   * The data replica distribution mode of the tenant.   
   * 
   * - For the high availability version, N-N-N indicates the three-zone mode, and N-N indicates the dual-zone or single-zone mode.
   * - For the basic version, N indicates the single-zone mode. 
   * 
   * > <br>N represents the number of nodes in a single zone.
   * 
   * @example
   * 1-1-1
   */
  deployMode?: string;
  /**
   * @remarks
   * The deployment type of the tenant. <br>
   * - multiple: multi-IDC deployment
   * - single: single-IDC deployment
   * - dual: dual-IDC deployment
   * 
   * @example
   * multiple
   */
  deployType?: string;
  /**
   * @remarks
   * The description of the tenant.
   * 
   * @example
   * PayCore business database
   */
  description?: string;
  /**
   * @remarks
   * Indicates whether read-only replicas are supported.
   * 
   * @example
   * true
   */
  enableReadOnlyReplica?: boolean;
  /**
   * @remarks
   * The total memory size of the tenant, in GB.
   * 
   * @example
   * 20
   */
  mem?: number;
  /**
   * @remarks
   * The parameter template.
   * 
   * @example
   * express_oltp
   */
  parameterTemplate?: string;
  /**
   * @remarks
   * The primary zone of the tenant.
   * 
   * @example
   * cn-hangzhou-i
   */
  primaryZone?: string;
  /**
   * @remarks
   * The status of the tenant.  <br>
   * - PENDING_CREATE: The tenant is being created.
   * - RESTORE: The tenant is being recovered.
   * - ONLINE: The tenant is running.
   * - SPEC_MODIFYING: The specification of the tenant is being modified.
   * ALLOCATING_INTERNET_ADDRESS: An Internet address is being allocated.
   * PENDING_OFFLINE_INTERNET_ADDRESS: The Internet address is being disabled.
   * - PRIMARY_ZONE_MODIFYING: The tenant is switching to a new primary zone.
   * - PARAMETER_MODIFYING: Parameters are being modified.
   * - WHITE_LIST_MODIFYING: The whitelist is being modified.
   * 
   * @example
   * ONLINE
   */
  status?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * @example
   * t33h8y08k****
   */
  tenantId?: string;
  /**
   * @remarks
   * The tenant mode.   
   * Valid values:   
   * Oracle
   * MySQL
   * 
   * @example
   * Oracle
   */
  tenantMode?: string;
  /**
   * @remarks
   * The name of the tenant.
   * 
   * @example
   * pay_online
   */
  tenantName?: string;
  /**
   * @remarks
   * The number of CPU cores in each resource unit of the tenant.
   * 
   * @example
   * 5
   */
  unitCpu?: number;
  /**
   * @remarks
   * The memory size of each resource unit of the tenant, in GB.
   * 
   * @example
   * 10
   */
  unitMem?: number;
  /**
   * @remarks
   * The number of resource units in the tenant.
   * 
   * @example
   * 2
   */
  unitNum?: number;
  /**
   * @remarks
   * The number of used disks of the tenant.
   * 
   * @example
   * 10
   */
  usedDiskSize?: number;
  /**
   * @remarks
   * The ID of the VPC.   <br>If no suitable VPC is available, create a VPC as prompted. For more information, see "What is a VPC".
   * 
   * @example
   * vpc-bp1d2q3mhg9i23ofi****
   */
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      charset: 'Charset',
      collation: 'Collation',
      cpu: 'Cpu',
      createTime: 'CreateTime',
      deployMode: 'DeployMode',
      deployType: 'DeployType',
      description: 'Description',
      enableReadOnlyReplica: 'EnableReadOnlyReplica',
      mem: 'Mem',
      parameterTemplate: 'ParameterTemplate',
      primaryZone: 'PrimaryZone',
      status: 'Status',
      tenantId: 'TenantId',
      tenantMode: 'TenantMode',
      tenantName: 'TenantName',
      unitCpu: 'UnitCpu',
      unitMem: 'UnitMem',
      unitNum: 'UnitNum',
      usedDiskSize: 'UsedDiskSize',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      charset: 'string',
      collation: 'string',
      cpu: 'number',
      createTime: 'string',
      deployMode: 'string',
      deployType: 'string',
      description: 'string',
      enableReadOnlyReplica: 'boolean',
      mem: 'number',
      parameterTemplate: 'string',
      primaryZone: 'string',
      status: 'string',
      tenantId: 'string',
      tenantMode: 'string',
      tenantName: 'string',
      unitCpu: 'number',
      unitMem: 'number',
      unitNum: 'number',
      usedDiskSize: 'number',
      vpcId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTimeZonesResponseBodyTimeZonesList extends $dara.Model {
  /**
   * @remarks
   * Example 1
   * 
   * @example
   * (GMT+8:00) Asia/Shanghai
   */
  description?: string;
  /**
   * @remarks
   * The operation that you want to perform.   
   * Set the value to **DescribeTimeZones**.
   * 
   * @example
   * Asia/Shanghai
   */
  timeZone?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      timeZone: 'TimeZone',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      timeZone: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTimeZonesResponseBodyTimeZones extends $dara.Model {
  /**
   * @example
   * Asia/Shanghai
   */
  default?: string;
  /**
   * @remarks
   * The list of time zones.
   */
  list?: DescribeTimeZonesResponseBodyTimeZonesList[];
  static names(): { [key: string]: string } {
    return {
      default: 'Default',
      list: 'List',
    };
  }

  static types(): { [key: string]: any } {
    return {
      default: 'string',
      list: { 'type': 'array', 'itemType': DescribeTimeZonesResponseBodyTimeZonesList },
    };
  }

  validate() {
    if(Array.isArray(this.list)) {
      $dara.Model.validateArray(this.list);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTopSQLListResponseBodyTopSQLList extends $dara.Model {
  /**
   * @remarks
   * The internal wait time, in ms.
   * 
   * @example
   * 0
   */
  affectedRows?: number;
  /**
   * @remarks
   * The wait time in concurrent execution, in ms.
   * 
   * @example
   * 0.0
   */
  appWaitTime?: number;
  /**
   * @remarks
   * The average CPU time, in ms.
   * 
   * @example
   * 14
   */
  blockCacheHit?: number;
  /**
   * @remarks
   * $.parameters[16].schema.example
   * 
   * @example
   * 4
   */
  blockIndexCacheHit?: number;
  /**
   * @remarks
   * $.parameters[14].schema.enumValueTitles
   * 
   * @example
   * 0
   */
  bloomFilterCacheHit?: number;
  /**
   * @remarks
   * $.parameters[14].schema.description
   * 
   * @example
   * 1*2.***.1*3.***
   */
  clientIp?: string;
  /**
   * @remarks
   * The number of rows returned.
   * 
   * @example
   * 0.0
   */
  concurrencyWaitTime?: number;
  /**
   * @remarks
   * The maximum CPU time, in ms.
   * 
   * @example
   * 50.13
   */
  cpuTime?: number;
  /**
   * @remarks
   * The number of remote plans.
   * 
   * @example
   * testdb
   */
  dbName?: string;
  /**
   * @remarks
   * The number of rows to return on each page.   
   * - Maximum value: 100   
   * - Default value: 10
   * 
   * @example
   * 0.0
   */
  decodeTime?: number;
  /**
   * @remarks
   * The IP address of the client.
   * 
   * @example
   * 0
   */
  diskRead?: number;
  /**
   * @remarks
   * The sorting rule.
   * 
   * @example
   * 76.382
   */
  elapsedTime?: number;
  /**
   * @remarks
   * The number of rows read from the disk.
   * 
   * @example
   * mysql response wait client
   */
  event?: string;
  /**
   * @remarks
   * The operation that you want to perform.   
   * Set the value to **DescribeTopSQLList**.
   * 
   * @example
   * 163.0
   */
  execPerSecond?: number;
  /**
   * @remarks
   * The number of rows read from the memory.
   * 
   * @example
   * 61.044
   */
  executeTime?: number;
  /**
   * @remarks
   * The number of executions per second.
   * 
   * @example
   * 89403
   */
  executions?: number;
  /**
   * @remarks
   * $.parameters[12].schema.description
   * 
   * @example
   * 0
   */
  failTimes?: number;
  /**
   * @remarks
   * The queuing time, in ms.
   * 
   * @example
   * 0.052
   */
  getPlanTime?: number;
  /**
   * @remarks
   * $.parameters[15].schema.example
   * 
   * @example
   * 0.0
   */
  IOWaitTime?: number;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * 1
   */
  key?: number;
  /**
   * @remarks
   * You can call this operation to query SQL execution performance data collected by the diagnostic system.
   * 
   * @example
   * 19
   */
  logicalRead?: number;
  /**
   * @remarks
   * SQLID.
   * 
   * @example
   * 257.967
   */
  maxCpuTime?: number;
  /**
   * @remarks
   * The sequence number of the returned SQL statement.
   * 
   * @example
   * 260.044
   */
  maxElapsedTime?: number;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * 527
   */
  memstoreReadRowCount?: number;
  /**
   * @remarks
   * The total count.
   * 
   * @example
   * 0
   */
  missPlans?: number;
  /**
   * @remarks
   * The end time of the time range for querying TOP SQL statements.   
   * The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
   * 
   * @example
   * 0.0
   */
  netWaitTime?: number;
  /**
   * @remarks
   * The username.
   * 
   * @example
   * i-bp18qljorblo8es*****
   */
  nodeIp?: string;
  /**
   * @remarks
   * $.parameters[12].schema.enumValueTitles
   * 
   * @example
   * 15.275
   */
  queueTime?: number;
  /**
   * @remarks
   * The start time of the time range for querying TOP SQL statements.   
   * The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
   * 
   * @example
   * 0
   */
  RPCCount?: number;
  /**
   * @remarks
   * The return result of the request.
   * 
   * @example
   * 0
   */
  remotePlans?: number;
  /**
   * @remarks
   * $.parameters[13].schema.description
   * 
   * @example
   * 0
   */
  retryCount?: number;
  /**
   * @remarks
   * The wait event.
   * 
   * @example
   * 1
   */
  returnRows?: number;
  /**
   * @remarks
   * ```
   * http(s)://[Endpoint]/?Action=DescribeTopSQLList
   * &TenantId=t2mr3oae0****
   * &StartTime=2021-06-13 15:40:43
   * &EndTime=2021-09-13 15:40:43
   * &DbName=testdb
   * &SearchKeyWord=update
   * &SearchParameter=cputime
   * &SearchRule=>
   * &SearchValue=0.01
   * &SQLId=8D6E84****0B8FB1823D199E2CA1****
   * &NodeIp=i-bp19y05uq6xpacyqnlrc
   * &PageNumber=1
   * &PageSize=10
   * &SortColumn=cputime
   * &SortOrder=desc
   * &Common request parameters
   * ```
   * 
   * @example
   * 0
   */
  rowCacheHit?: number;
  /**
   * @remarks
   * $.parameters[13].schema.example
   * 
   * @example
   * 8D6E84****0B8FB1823D199E2CA1****
   */
  SQLId?: string;
  /**
   * @remarks
   * The list of top SQL statements.
   * 
   * @example
   * SELECT  ****   FROM ****   WHERE **** = ? AND **** = ?   ORDER BY **** ASC
   */
  SQLText?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 1
   */
  SQLType?: number;
  /**
   * @remarks
   * The search keyword.
   * 
   * @example
   * 0.0
   */
  scheduleTime?: number;
  /**
   * @example
   * 43086
   */
  ssstoreReadRowCount?: number;
  /**
   * @remarks
   * -
   * 
   * @example
   * 10.966
   */
  totalWaitTime?: number;
  /**
   * @remarks
   * The number of Bloom filter cache hits.
   * 
   * @example
   * tester
   */
  userName?: string;
  static names(): { [key: string]: string } {
    return {
      affectedRows: 'AffectedRows',
      appWaitTime: 'AppWaitTime',
      blockCacheHit: 'BlockCacheHit',
      blockIndexCacheHit: 'BlockIndexCacheHit',
      bloomFilterCacheHit: 'BloomFilterCacheHit',
      clientIp: 'ClientIp',
      concurrencyWaitTime: 'ConcurrencyWaitTime',
      cpuTime: 'CpuTime',
      dbName: 'DbName',
      decodeTime: 'DecodeTime',
      diskRead: 'DiskRead',
      elapsedTime: 'ElapsedTime',
      event: 'Event',
      execPerSecond: 'ExecPerSecond',
      executeTime: 'ExecuteTime',
      executions: 'Executions',
      failTimes: 'FailTimes',
      getPlanTime: 'GetPlanTime',
      IOWaitTime: 'IOWaitTime',
      key: 'Key',
      logicalRead: 'LogicalRead',
      maxCpuTime: 'MaxCpuTime',
      maxElapsedTime: 'MaxElapsedTime',
      memstoreReadRowCount: 'MemstoreReadRowCount',
      missPlans: 'MissPlans',
      netWaitTime: 'NetWaitTime',
      nodeIp: 'NodeIp',
      queueTime: 'QueueTime',
      RPCCount: 'RPCCount',
      remotePlans: 'RemotePlans',
      retryCount: 'RetryCount',
      returnRows: 'ReturnRows',
      rowCacheHit: 'RowCacheHit',
      SQLId: 'SQLId',
      SQLText: 'SQLText',
      SQLType: 'SQLType',
      scheduleTime: 'ScheduleTime',
      ssstoreReadRowCount: 'SsstoreReadRowCount',
      totalWaitTime: 'TotalWaitTime',
      userName: 'UserName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      affectedRows: 'number',
      appWaitTime: 'number',
      blockCacheHit: 'number',
      blockIndexCacheHit: 'number',
      bloomFilterCacheHit: 'number',
      clientIp: 'string',
      concurrencyWaitTime: 'number',
      cpuTime: 'number',
      dbName: 'string',
      decodeTime: 'number',
      diskRead: 'number',
      elapsedTime: 'number',
      event: 'string',
      execPerSecond: 'number',
      executeTime: 'number',
      executions: 'number',
      failTimes: 'number',
      getPlanTime: 'number',
      IOWaitTime: 'number',
      key: 'number',
      logicalRead: 'number',
      maxCpuTime: 'number',
      maxElapsedTime: 'number',
      memstoreReadRowCount: 'number',
      missPlans: 'number',
      netWaitTime: 'number',
      nodeIp: 'string',
      queueTime: 'number',
      RPCCount: 'number',
      remotePlans: 'number',
      retryCount: 'number',
      returnRows: 'number',
      rowCacheHit: 'number',
      SQLId: 'string',
      SQLText: 'string',
      SQLType: 'number',
      scheduleTime: 'number',
      ssstoreReadRowCount: 'number',
      totalWaitTime: 'number',
      userName: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeZonesResponseBodyZones extends $dara.Model {
  /**
   * @example
   * 1-1-1
   */
  deployType?: string;
  /**
   * @example
   * NORMAL
   */
  series?: string;
  /**
   * @example
   * cn-hangzhou-i,cn-hangzhou-j,cn-hangzhou-h
   */
  zoneId?: string;
  /**
   * @example
   * H/I/J
   */
  zoneName?: string;
  static names(): { [key: string]: string } {
    return {
      deployType: 'DeployType',
      series: 'Series',
      zoneId: 'ZoneId',
      zoneName: 'ZoneName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deployType: 'string',
      series: 'string',
      zoneId: 'string',
      zoneName: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUploadOssUrlResponseBodyData extends $dara.Model {
  /**
   * @example
   * 2023-07-26T06:33:11.175
   */
  expectedExpirationTime?: string;
  /**
   * @example
   * open_api_create_project/oacp_4xd****vk
   */
  ossKey?: string;
  /**
   * @example
   * https://cn-hangzhou-pre-omsstore.oss-cn-hangzhou.aliyuncs.com/open_api_create_project/oacp_4x****pvk?Expires=169031&OSSAccessKeyId=LTAI5tMN52D***TBf&Signature=XdDFPz%2BXKC***%2B
   */
  ossUrl?: string;
  static names(): { [key: string]: string } {
    return {
      expectedExpirationTime: 'ExpectedExpirationTime',
      ossKey: 'OssKey',
      ossUrl: 'OssUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      expectedExpirationTime: 'string',
      ossKey: 'string',
      ossUrl: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUploadOssUrlResponseBodyErrorDetail extends $dara.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * null
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * null
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  validate() {
    if(this.extraContext) {
      $dara.Model.validateMap(this.extraContext);
    }
    if(this.messageMcmsContext) {
      $dara.Model.validateMap(this.messageMcmsContext);
    }
    if(this.proposalMcmsContext) {
      $dara.Model.validateMap(this.proposalMcmsContext);
    }
    if(this.reasonMcmsContext) {
      $dara.Model.validateMap(this.reasonMcmsContext);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class KillProcessListResponseBodyData extends $dara.Model {
  /**
   * @remarks
   * The client IP address.
   * 
   * @example
   * 127.0.0.1
   */
  clientIp?: string;
  /**
   * @remarks
   * The start command for the container of the application.
   * 
   * @example
   * select 1
   */
  command?: string;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * test
   */
  database?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * Instance not found.
   */
  errorMessage?: string;
  /**
   * @remarks
   * Execution time (UTC+8). If it is left empty, it means to execute immediately.
   * 
   * @example
   * 142
   */
  executeTime?: string;
  /**
   * @remarks
   * The IP address of the server.
   * 
   * @example
   * 127.0.0.1
   */
  serverIp?: string;
  /**
   * @remarks
   * The ID of the session.
   * 
   * @example
   * 1123
   */
  sessionId?: number;
  /**
   * @remarks
   * The SQL statement.
   * 
   * @example
   * :
   */
  sqlText?: string;
  /**
   * @remarks
   * The status of the task.
   * 
   * @example
   * SLEEP
   */
  status?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * @example
   * t3ogqv07a56n4
   */
  tenantId?: string;
  /**
   * @remarks
   * The database username.
   * 
   * @example
   * oas
   */
  user?: string;
  static names(): { [key: string]: string } {
    return {
      clientIp: 'ClientIp',
      command: 'Command',
      database: 'Database',
      errorMessage: 'ErrorMessage',
      executeTime: 'ExecuteTime',
      serverIp: 'ServerIp',
      sessionId: 'SessionId',
      sqlText: 'SqlText',
      status: 'Status',
      tenantId: 'TenantId',
      user: 'User',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clientIp: 'string',
      command: 'string',
      database: 'string',
      errorMessage: 'string',
      executeTime: 'string',
      serverIp: 'string',
      sessionId: 'number',
      sqlText: 'string',
      status: 'string',
      tenantId: 'string',
      user: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAllLabelsResponseBodyData extends $dara.Model {
  /**
   * @example
   * l_4w6r0***
   */
  id?: string;
  /**
   * @example
   * test
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      name: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAllLabelsResponseBodyErrorDetail extends $dara.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * Contact the administrator.
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  validate() {
    if(this.extraContext) {
      $dara.Model.validateMap(this.extraContext);
    }
    if(this.messageMcmsContext) {
      $dara.Model.validateMap(this.messageMcmsContext);
    }
    if(this.proposalMcmsContext) {
      $dara.Model.validateMap(this.proposalMcmsContext);
    }
    if(this.reasonMcmsContext) {
      $dara.Model.validateMap(this.reasonMcmsContext);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataSourceResponseBodyData extends $dara.Model {
  /**
   * @example
   * utf8mb4
   */
  charset?: string;
  /**
   * @example
   * cluster_name
   */
  cluster?: string;
  /**
   * @example
   * null
   */
  connExtraAttributes?: any;
  /**
   * @example
   * test
   */
  description?: string;
  /**
   * @example
   * 2023-07-13T20:27:28.000+00:00
   */
  gmtCreate?: string;
  /**
   * @example
   * 2023-07-13T20:37:28.000+00:00
   */
  gmtModified?: string;
  /**
   * @example
   * e_4w****v
   */
  id?: string;
  /**
   * @example
   * xxx.xxx.xxx.1
   */
  ip?: string;
  /**
   * @example
   * RATION***1DBUTF11
   */
  name?: string;
  /**
   * @example
   * Linux
   */
  operatingSystem?: string;
  /**
   * @example
   * null
   */
  oracleNlsLengthSemantics?: string;
  /**
   * @example
   * null
   */
  oracleSid?: string;
  /**
   * @example
   * admin
   */
  owner?: string;
  /**
   * @example
   * null
   */
  partnerId?: string;
  /**
   * @example
   * 2883
   */
  port?: number;
  /**
   * @example
   * cn-beijing
   */
  region?: string;
  /**
   * @example
   * 178641****05809
   */
  resourceOwner?: string;
  /**
   * @example
   * MASTER
   */
  role?: string;
  /**
   * @example
   * schema_name
   */
  schema?: string;
  /**
   * @example
   * tenant_name
   */
  tenant?: string;
  /**
   * @example
   * +08:00
   */
  timezone?: string;
  /**
   * @example
   * MYSQL_PUBLIC
   */
  type?: string;
  /**
   * @example
   * user_name
   */
  userName?: string;
  /**
   * @example
   * 4.1.0
   */
  version?: string;
  /**
   * @example
   * vpc_t4***
   */
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      charset: 'Charset',
      cluster: 'Cluster',
      connExtraAttributes: 'ConnExtraAttributes',
      description: 'Description',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      id: 'Id',
      ip: 'Ip',
      name: 'Name',
      operatingSystem: 'OperatingSystem',
      oracleNlsLengthSemantics: 'OracleNlsLengthSemantics',
      oracleSid: 'OracleSid',
      owner: 'Owner',
      partnerId: 'PartnerId',
      port: 'Port',
      region: 'Region',
      resourceOwner: 'ResourceOwner',
      role: 'Role',
      schema: 'Schema',
      tenant: 'Tenant',
      timezone: 'Timezone',
      type: 'Type',
      userName: 'UserName',
      version: 'Version',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      charset: 'string',
      cluster: 'string',
      connExtraAttributes: 'any',
      description: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      id: 'string',
      ip: 'string',
      name: 'string',
      operatingSystem: 'string',
      oracleNlsLengthSemantics: 'string',
      oracleSid: 'string',
      owner: 'string',
      partnerId: 'string',
      port: 'number',
      region: 'string',
      resourceOwner: 'string',
      role: 'string',
      schema: 'string',
      tenant: 'string',
      timezone: 'string',
      type: 'string',
      userName: 'string',
      version: 'string',
      vpcId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataSourceResponseBodyErrorDetail extends $dara.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * null
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  validate() {
    if(this.extraContext) {
      $dara.Model.validateMap(this.extraContext);
    }
    if(this.messageMcmsContext) {
      $dara.Model.validateMap(this.messageMcmsContext);
    }
    if(this.proposalMcmsContext) {
      $dara.Model.validateMap(this.proposalMcmsContext);
    }
    if(this.reasonMcmsContext) {
      $dara.Model.validateMap(this.reasonMcmsContext);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectFullVerifyResultResponseBodyDataFullVerifyTableStatisticsErrorDetails extends $dara.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * null
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * null
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  validate() {
    if(this.extraContext) {
      $dara.Model.validateMap(this.extraContext);
    }
    if(this.messageMcmsContext) {
      $dara.Model.validateMap(this.messageMcmsContext);
    }
    if(this.proposalMcmsContext) {
      $dara.Model.validateMap(this.proposalMcmsContext);
    }
    if(this.reasonMcmsContext) {
      $dara.Model.validateMap(this.reasonMcmsContext);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectFullVerifyResultResponseBodyDataFullVerifyTableStatistics extends $dara.Model {
  /**
   * @example
   * 200
   */
  consistentCount?: number;
  /**
   * @example
   * 0
   */
  destOnlyCount?: number;
  /**
   * @example
   * dest_db
   */
  destSchemaName?: string;
  errorDetails?: ListProjectFullVerifyResultResponseBodyDataFullVerifyTableStatisticsErrorDetails[];
  /**
   * @example
   * null
   */
  message?: string;
  /**
   * @example
   * 0
   */
  mismatchedCount?: number;
  /**
   * @example
   * 80
   */
  progress?: string;
  /**
   * @example
   * desc
   */
  resultDesc?: string;
  /**
   * @example
   * RUNNING
   */
  resultType?: string;
  /**
   * @example
   * 0
   */
  sourceOnlyCount?: number;
  /**
   * @example
   * source_db
   */
  sourceSchemaName?: string;
  /**
   * @example
   * source_table
   */
  sourceTableName?: string;
  /**
   * @example
   * RUNNING
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      consistentCount: 'ConsistentCount',
      destOnlyCount: 'DestOnlyCount',
      destSchemaName: 'DestSchemaName',
      errorDetails: 'ErrorDetails',
      message: 'Message',
      mismatchedCount: 'MismatchedCount',
      progress: 'Progress',
      resultDesc: 'ResultDesc',
      resultType: 'ResultType',
      sourceOnlyCount: 'SourceOnlyCount',
      sourceSchemaName: 'SourceSchemaName',
      sourceTableName: 'SourceTableName',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consistentCount: 'number',
      destOnlyCount: 'number',
      destSchemaName: 'string',
      errorDetails: { 'type': 'array', 'itemType': ListProjectFullVerifyResultResponseBodyDataFullVerifyTableStatisticsErrorDetails },
      message: 'string',
      mismatchedCount: 'number',
      progress: 'string',
      resultDesc: 'string',
      resultType: 'string',
      sourceOnlyCount: 'number',
      sourceSchemaName: 'string',
      sourceTableName: 'string',
      status: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.errorDetails)) {
      $dara.Model.validateArray(this.errorDetails);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectFullVerifyResultResponseBodyData extends $dara.Model {
  /**
   * @example
   * 11
   */
  differentNumber?: number;
  fullVerifyTableStatistics?: ListProjectFullVerifyResultResponseBodyDataFullVerifyTableStatistics[];
  static names(): { [key: string]: string } {
    return {
      differentNumber: 'DifferentNumber',
      fullVerifyTableStatistics: 'FullVerifyTableStatistics',
    };
  }

  static types(): { [key: string]: any } {
    return {
      differentNumber: 'number',
      fullVerifyTableStatistics: { 'type': 'array', 'itemType': ListProjectFullVerifyResultResponseBodyDataFullVerifyTableStatistics },
    };
  }

  validate() {
    if(Array.isArray(this.fullVerifyTableStatistics)) {
      $dara.Model.validateArray(this.fullVerifyTableStatistics);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectFullVerifyResultResponseBodyErrorDetail extends $dara.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * null
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  validate() {
    if(this.extraContext) {
      $dara.Model.validateMap(this.extraContext);
    }
    if(this.messageMcmsContext) {
      $dara.Model.validateMap(this.messageMcmsContext);
    }
    if(this.proposalMcmsContext) {
      $dara.Model.validateMap(this.proposalMcmsContext);
    }
    if(this.reasonMcmsContext) {
      $dara.Model.validateMap(this.reasonMcmsContext);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectModifyRecordsResponseBodyDataDatabasesSpecificTablesAdbTableSchema extends $dara.Model {
  distributedKeys?: string[];
  /**
   * @example
   * 30
   */
  partitionLifeCycle?: number;
  /**
   * @example
   * PARTITION BY VALUE(\\"id\\")
   */
  partitionStatement?: string;
  primaryKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      distributedKeys: 'DistributedKeys',
      partitionLifeCycle: 'PartitionLifeCycle',
      partitionStatement: 'PartitionStatement',
      primaryKeys: 'PrimaryKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      distributedKeys: { 'type': 'array', 'itemType': 'string' },
      partitionLifeCycle: 'number',
      partitionStatement: 'string',
      primaryKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(Array.isArray(this.distributedKeys)) {
      $dara.Model.validateArray(this.distributedKeys);
    }
    if(Array.isArray(this.primaryKeys)) {
      $dara.Model.validateArray(this.primaryKeys);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectModifyRecordsResponseBodyDataDatabasesSpecificTablesColumns extends $dara.Model {
  /**
   * @example
   * comments
   */
  columnComment?: string;
  /**
   * @example
   * PRI
   */
  columnKey?: string;
  /**
   * @example
   * col_name
   */
  columnName?: string;
  /**
   * @example
   * FLOAT
   */
  columnType?: string;
  /**
   * @example
   * null
   */
  dataLength?: number;
  /**
   * @example
   * 64
   */
  dataPrecision?: number;
  /**
   * @example
   * null
   */
  dataScale?: number;
  /**
   * @example
   * null
   */
  defaultValue?: string;
  /**
   * @example
   * utf16
   */
  encoding?: string;
  /**
   * @example
   * false
   */
  isGenerateField?: boolean;
  /**
   * @example
   * mapped_name
   */
  mappedName?: string;
  /**
   * @example
   * false
   */
  nullable?: boolean;
  /**
   * @example
   * null
   */
  position?: number;
  /**
   * @example
   * null
   */
  rawColumnType?: string;
  /**
   * @example
   * INT8
   */
  recordFieldType?: string;
  /**
   * @example
   * DATABASE
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      columnComment: 'ColumnComment',
      columnKey: 'ColumnKey',
      columnName: 'ColumnName',
      columnType: 'ColumnType',
      dataLength: 'DataLength',
      dataPrecision: 'DataPrecision',
      dataScale: 'DataScale',
      defaultValue: 'DefaultValue',
      encoding: 'Encoding',
      isGenerateField: 'IsGenerateField',
      mappedName: 'MappedName',
      nullable: 'Nullable',
      position: 'Position',
      rawColumnType: 'RawColumnType',
      recordFieldType: 'RecordFieldType',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnComment: 'string',
      columnKey: 'string',
      columnName: 'string',
      columnType: 'string',
      dataLength: 'number',
      dataPrecision: 'number',
      dataScale: 'number',
      defaultValue: 'string',
      encoding: 'string',
      isGenerateField: 'boolean',
      mappedName: 'string',
      nullable: 'boolean',
      position: 'number',
      rawColumnType: 'string',
      recordFieldType: 'string',
      type: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectModifyRecordsResponseBodyDataDatabasesSpecificTables extends $dara.Model {
  adbTableSchema?: ListProjectModifyRecordsResponseBodyDataDatabasesSpecificTablesAdbTableSchema;
  columns?: ListProjectModifyRecordsResponseBodyDataDatabasesSpecificTablesColumns[];
  filterColumns?: string[];
  /**
   * @example
   * table_id
   */
  id?: string;
  /**
   * @example
   * mapped_name
   */
  mappedName?: string;
  /**
   * @example
   * table_name
   */
  name?: string;
  shardColumns?: string[];
  /**
   * @example
   * id<3
   */
  whereClause?: string;
  static names(): { [key: string]: string } {
    return {
      adbTableSchema: 'AdbTableSchema',
      columns: 'Columns',
      filterColumns: 'FilterColumns',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      shardColumns: 'ShardColumns',
      whereClause: 'WhereClause',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adbTableSchema: ListProjectModifyRecordsResponseBodyDataDatabasesSpecificTablesAdbTableSchema,
      columns: { 'type': 'array', 'itemType': ListProjectModifyRecordsResponseBodyDataDatabasesSpecificTablesColumns },
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      mappedName: 'string',
      name: 'string',
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      whereClause: 'string',
    };
  }

  validate() {
    if(this.adbTableSchema && typeof (this.adbTableSchema as any).validate === 'function') {
      (this.adbTableSchema as any).validate();
    }
    if(Array.isArray(this.columns)) {
      $dara.Model.validateArray(this.columns);
    }
    if(Array.isArray(this.filterColumns)) {
      $dara.Model.validateArray(this.filterColumns);
    }
    if(Array.isArray(this.shardColumns)) {
      $dara.Model.validateArray(this.shardColumns);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectModifyRecordsResponseBodyDataDatabasesSpecificViewsAdbTableSchema extends $dara.Model {
  distributedKeys?: string[];
  /**
   * @example
   * 30
   */
  partitionLifeCycle?: number;
  /**
   * @example
   * PARTITION BY VALUE(\\"id\\")
   */
  partitionStatement?: string;
  primaryKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      distributedKeys: 'DistributedKeys',
      partitionLifeCycle: 'PartitionLifeCycle',
      partitionStatement: 'PartitionStatement',
      primaryKeys: 'PrimaryKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      distributedKeys: { 'type': 'array', 'itemType': 'string' },
      partitionLifeCycle: 'number',
      partitionStatement: 'string',
      primaryKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(Array.isArray(this.distributedKeys)) {
      $dara.Model.validateArray(this.distributedKeys);
    }
    if(Array.isArray(this.primaryKeys)) {
      $dara.Model.validateArray(this.primaryKeys);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectModifyRecordsResponseBodyDataDatabasesSpecificViewsColumns extends $dara.Model {
  /**
   * @example
   * comments
   */
  columnComment?: string;
  /**
   * @example
   * PRI
   */
  columnKey?: string;
  /**
   * @example
   * col_name
   */
  columnName?: string;
  /**
   * @example
   * FLOAT
   */
  columnType?: string;
  /**
   * @example
   * null
   */
  dataLength?: number;
  /**
   * @example
   * 64
   */
  dataPrecision?: number;
  /**
   * @example
   * null
   */
  dataScale?: number;
  /**
   * @example
   * null
   */
  defaultValue?: string;
  /**
   * @example
   * utf16
   */
  encoding?: string;
  /**
   * @example
   * false
   */
  isGenerateField?: boolean;
  /**
   * @example
   * mapped_name
   */
  mappedName?: string;
  /**
   * @example
   * true
   */
  nullable?: boolean;
  /**
   * @example
   * null
   */
  position?: number;
  /**
   * @example
   * null
   */
  rawColumnType?: string;
  /**
   * @example
   * INT8
   */
  recordFieldType?: string;
  /**
   * @example
   * DATABASE
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      columnComment: 'ColumnComment',
      columnKey: 'ColumnKey',
      columnName: 'ColumnName',
      columnType: 'ColumnType',
      dataLength: 'DataLength',
      dataPrecision: 'DataPrecision',
      dataScale: 'DataScale',
      defaultValue: 'DefaultValue',
      encoding: 'Encoding',
      isGenerateField: 'IsGenerateField',
      mappedName: 'MappedName',
      nullable: 'Nullable',
      position: 'Position',
      rawColumnType: 'RawColumnType',
      recordFieldType: 'RecordFieldType',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnComment: 'string',
      columnKey: 'string',
      columnName: 'string',
      columnType: 'string',
      dataLength: 'number',
      dataPrecision: 'number',
      dataScale: 'number',
      defaultValue: 'string',
      encoding: 'string',
      isGenerateField: 'boolean',
      mappedName: 'string',
      nullable: 'boolean',
      position: 'number',
      rawColumnType: 'string',
      recordFieldType: 'string',
      type: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectModifyRecordsResponseBodyDataDatabasesSpecificViews extends $dara.Model {
  adbTableSchema?: ListProjectModifyRecordsResponseBodyDataDatabasesSpecificViewsAdbTableSchema;
  columns?: ListProjectModifyRecordsResponseBodyDataDatabasesSpecificViewsColumns[];
  filterColumns?: string[];
  /**
   * @example
   * table_id
   */
  id?: string;
  /**
   * @example
   * mapped_name
   */
  mappedName?: string;
  /**
   * @example
   * table_name
   */
  name?: string;
  shardColumns?: string[];
  /**
   * @example
   * id < 1
   */
  whereClause?: string;
  static names(): { [key: string]: string } {
    return {
      adbTableSchema: 'AdbTableSchema',
      columns: 'Columns',
      filterColumns: 'FilterColumns',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      shardColumns: 'ShardColumns',
      whereClause: 'WhereClause',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adbTableSchema: ListProjectModifyRecordsResponseBodyDataDatabasesSpecificViewsAdbTableSchema,
      columns: { 'type': 'array', 'itemType': ListProjectModifyRecordsResponseBodyDataDatabasesSpecificViewsColumns },
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      mappedName: 'string',
      name: 'string',
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      whereClause: 'string',
    };
  }

  validate() {
    if(this.adbTableSchema && typeof (this.adbTableSchema as any).validate === 'function') {
      (this.adbTableSchema as any).validate();
    }
    if(Array.isArray(this.columns)) {
      $dara.Model.validateArray(this.columns);
    }
    if(Array.isArray(this.filterColumns)) {
      $dara.Model.validateArray(this.filterColumns);
    }
    if(Array.isArray(this.shardColumns)) {
      $dara.Model.validateArray(this.shardColumns);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectModifyRecordsResponseBodyDataDatabasesTablesAdbTableSchema extends $dara.Model {
  distributedKeys?: string[];
  /**
   * @example
   * 30
   */
  partitionLifeCycle?: number;
  /**
   * @example
   * PARTITION BY VALUE(\\"id\\")
   */
  partitionStatement?: string;
  primaryKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      distributedKeys: 'DistributedKeys',
      partitionLifeCycle: 'PartitionLifeCycle',
      partitionStatement: 'PartitionStatement',
      primaryKeys: 'PrimaryKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      distributedKeys: { 'type': 'array', 'itemType': 'string' },
      partitionLifeCycle: 'number',
      partitionStatement: 'string',
      primaryKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(Array.isArray(this.distributedKeys)) {
      $dara.Model.validateArray(this.distributedKeys);
    }
    if(Array.isArray(this.primaryKeys)) {
      $dara.Model.validateArray(this.primaryKeys);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectModifyRecordsResponseBodyDataDatabasesTablesColumns extends $dara.Model {
  /**
   * @example
   * comments
   */
  columnComment?: string;
  /**
   * @example
   * PRI
   */
  columnKey?: string;
  /**
   * @example
   * col_name
   */
  columnName?: string;
  /**
   * @example
   * FLOAT
   */
  columnType?: string;
  /**
   * @example
   * null
   */
  dataLength?: number;
  /**
   * @example
   * 64
   */
  dataPrecision?: number;
  /**
   * @example
   * null
   */
  dataScale?: number;
  /**
   * @example
   * null
   */
  defaultValue?: string;
  /**
   * @example
   * utf8
   */
  encoding?: string;
  /**
   * @example
   * false
   */
  isGenerateField?: boolean;
  /**
   * @example
   * mapped_col
   */
  mappedName?: string;
  /**
   * @example
   * true
   */
  nullable?: boolean;
  /**
   * @example
   * null
   */
  position?: number;
  /**
   * @example
   * null
   */
  rawColumnType?: string;
  /**
   * @example
   * INT8
   */
  recordFieldType?: string;
  /**
   * @example
   * DATABASE
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      columnComment: 'ColumnComment',
      columnKey: 'ColumnKey',
      columnName: 'ColumnName',
      columnType: 'ColumnType',
      dataLength: 'DataLength',
      dataPrecision: 'DataPrecision',
      dataScale: 'DataScale',
      defaultValue: 'DefaultValue',
      encoding: 'Encoding',
      isGenerateField: 'IsGenerateField',
      mappedName: 'MappedName',
      nullable: 'Nullable',
      position: 'Position',
      rawColumnType: 'RawColumnType',
      recordFieldType: 'RecordFieldType',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnComment: 'string',
      columnKey: 'string',
      columnName: 'string',
      columnType: 'string',
      dataLength: 'number',
      dataPrecision: 'number',
      dataScale: 'number',
      defaultValue: 'string',
      encoding: 'string',
      isGenerateField: 'boolean',
      mappedName: 'string',
      nullable: 'boolean',
      position: 'number',
      rawColumnType: 'string',
      recordFieldType: 'string',
      type: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectModifyRecordsResponseBodyDataDatabasesTables extends $dara.Model {
  adbTableSchema?: ListProjectModifyRecordsResponseBodyDataDatabasesTablesAdbTableSchema;
  columns?: ListProjectModifyRecordsResponseBodyDataDatabasesTablesColumns[];
  filterColumns?: string[];
  /**
   * @example
   * table_id
   */
  id?: string;
  /**
   * @example
   * mapped_name
   */
  mappedName?: string;
  /**
   * @example
   * table_name
   */
  name?: string;
  shardColumns?: string[];
  /**
   * @example
   * id < 1
   */
  whereClause?: string;
  static names(): { [key: string]: string } {
    return {
      adbTableSchema: 'AdbTableSchema',
      columns: 'Columns',
      filterColumns: 'FilterColumns',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      shardColumns: 'ShardColumns',
      whereClause: 'WhereClause',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adbTableSchema: ListProjectModifyRecordsResponseBodyDataDatabasesTablesAdbTableSchema,
      columns: { 'type': 'array', 'itemType': ListProjectModifyRecordsResponseBodyDataDatabasesTablesColumns },
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      mappedName: 'string',
      name: 'string',
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      whereClause: 'string',
    };
  }

  validate() {
    if(this.adbTableSchema && typeof (this.adbTableSchema as any).validate === 'function') {
      (this.adbTableSchema as any).validate();
    }
    if(Array.isArray(this.columns)) {
      $dara.Model.validateArray(this.columns);
    }
    if(Array.isArray(this.filterColumns)) {
      $dara.Model.validateArray(this.filterColumns);
    }
    if(Array.isArray(this.shardColumns)) {
      $dara.Model.validateArray(this.shardColumns);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectModifyRecordsResponseBodyDataDatabasesViewsAdbTableSchema extends $dara.Model {
  distributedKeys?: string[];
  /**
   * @example
   * 30
   */
  partitionLifeCycle?: number;
  /**
   * @example
   * PARTITION BY VALUE(\\"id\\")
   */
  partitionStatement?: string;
  primaryKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      distributedKeys: 'DistributedKeys',
      partitionLifeCycle: 'PartitionLifeCycle',
      partitionStatement: 'PartitionStatement',
      primaryKeys: 'PrimaryKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      distributedKeys: { 'type': 'array', 'itemType': 'string' },
      partitionLifeCycle: 'number',
      partitionStatement: 'string',
      primaryKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(Array.isArray(this.distributedKeys)) {
      $dara.Model.validateArray(this.distributedKeys);
    }
    if(Array.isArray(this.primaryKeys)) {
      $dara.Model.validateArray(this.primaryKeys);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectModifyRecordsResponseBodyDataDatabasesViewsColumns extends $dara.Model {
  /**
   * @example
   * comments
   */
  columnComment?: string;
  /**
   * @example
   * PRI
   */
  columnKey?: string;
  /**
   * @example
   * col_name
   */
  columnName?: string;
  /**
   * @example
   * FLOAT
   */
  columnType?: string;
  /**
   * @example
   * null
   */
  dataLength?: number;
  /**
   * @example
   * 64
   */
  dataPrecision?: number;
  /**
   * @example
   * null
   */
  dataScale?: number;
  /**
   * @example
   * null
   */
  defaultValue?: string;
  /**
   * @example
   * utf16
   */
  encoding?: string;
  /**
   * @example
   * false
   */
  isGenerateField?: boolean;
  /**
   * @example
   * mapped_name
   */
  mappedName?: string;
  /**
   * @example
   * false
   */
  nullable?: boolean;
  /**
   * @example
   * null
   */
  position?: number;
  /**
   * @example
   * null
   */
  rawColumnType?: string;
  /**
   * @example
   * INT8
   */
  recordFieldType?: string;
  /**
   * @example
   * DATABASE
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      columnComment: 'ColumnComment',
      columnKey: 'ColumnKey',
      columnName: 'ColumnName',
      columnType: 'ColumnType',
      dataLength: 'DataLength',
      dataPrecision: 'DataPrecision',
      dataScale: 'DataScale',
      defaultValue: 'DefaultValue',
      encoding: 'Encoding',
      isGenerateField: 'IsGenerateField',
      mappedName: 'MappedName',
      nullable: 'Nullable',
      position: 'Position',
      rawColumnType: 'RawColumnType',
      recordFieldType: 'RecordFieldType',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnComment: 'string',
      columnKey: 'string',
      columnName: 'string',
      columnType: 'string',
      dataLength: 'number',
      dataPrecision: 'number',
      dataScale: 'number',
      defaultValue: 'string',
      encoding: 'string',
      isGenerateField: 'boolean',
      mappedName: 'string',
      nullable: 'boolean',
      position: 'number',
      rawColumnType: 'string',
      recordFieldType: 'string',
      type: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectModifyRecordsResponseBodyDataDatabasesViews extends $dara.Model {
  adbTableSchema?: ListProjectModifyRecordsResponseBodyDataDatabasesViewsAdbTableSchema;
  columns?: ListProjectModifyRecordsResponseBodyDataDatabasesViewsColumns[];
  filterColumns?: string[];
  /**
   * @example
   * table_id
   */
  id?: string;
  /**
   * @example
   * mapped_view
   */
  mappedName?: string;
  /**
   * @example
   * table_name
   */
  name?: string;
  shardColumns?: string[];
  /**
   * @example
   * id<1
   */
  whereClause?: string;
  static names(): { [key: string]: string } {
    return {
      adbTableSchema: 'AdbTableSchema',
      columns: 'Columns',
      filterColumns: 'FilterColumns',
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      shardColumns: 'ShardColumns',
      whereClause: 'WhereClause',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adbTableSchema: ListProjectModifyRecordsResponseBodyDataDatabasesViewsAdbTableSchema,
      columns: { 'type': 'array', 'itemType': ListProjectModifyRecordsResponseBodyDataDatabasesViewsColumns },
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      mappedName: 'string',
      name: 'string',
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      whereClause: 'string',
    };
  }

  validate() {
    if(this.adbTableSchema && typeof (this.adbTableSchema as any).validate === 'function') {
      (this.adbTableSchema as any).validate();
    }
    if(Array.isArray(this.columns)) {
      $dara.Model.validateArray(this.columns);
    }
    if(Array.isArray(this.filterColumns)) {
      $dara.Model.validateArray(this.filterColumns);
    }
    if(Array.isArray(this.shardColumns)) {
      $dara.Model.validateArray(this.shardColumns);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectModifyRecordsResponseBodyDataDatabases extends $dara.Model {
  /**
   * @example
   * db_id
   */
  id?: string;
  /**
   * @example
   * mapped_db
   */
  mappedName?: string;
  /**
   * @example
   * db_name
   */
  name?: string;
  specificTables?: ListProjectModifyRecordsResponseBodyDataDatabasesSpecificTables[];
  specificViews?: ListProjectModifyRecordsResponseBodyDataDatabasesSpecificViews[];
  tables?: ListProjectModifyRecordsResponseBodyDataDatabasesTables[];
  views?: ListProjectModifyRecordsResponseBodyDataDatabasesViews[];
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      mappedName: 'MappedName',
      name: 'Name',
      specificTables: 'SpecificTables',
      specificViews: 'SpecificViews',
      tables: 'Tables',
      views: 'Views',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      mappedName: 'string',
      name: 'string',
      specificTables: { 'type': 'array', 'itemType': ListProjectModifyRecordsResponseBodyDataDatabasesSpecificTables },
      specificViews: { 'type': 'array', 'itemType': ListProjectModifyRecordsResponseBodyDataDatabasesSpecificViews },
      tables: { 'type': 'array', 'itemType': ListProjectModifyRecordsResponseBodyDataDatabasesTables },
      views: { 'type': 'array', 'itemType': ListProjectModifyRecordsResponseBodyDataDatabasesViews },
    };
  }

  validate() {
    if(Array.isArray(this.specificTables)) {
      $dara.Model.validateArray(this.specificTables);
    }
    if(Array.isArray(this.specificViews)) {
      $dara.Model.validateArray(this.specificViews);
    }
    if(Array.isArray(this.tables)) {
      $dara.Model.validateArray(this.tables);
    }
    if(Array.isArray(this.views)) {
      $dara.Model.validateArray(this.views);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectModifyRecordsResponseBodyDataErrorDetail extends $dara.Model {
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * null
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  validate() {
    if(this.extraContext) {
      $dara.Model.validateMap(this.extraContext);
    }
    if(this.messageMcmsContext) {
      $dara.Model.validateMap(this.messageMcmsContext);
    }
    if(this.proposalMcmsContext) {
      $dara.Model.validateMap(this.proposalMcmsContext);
    }
    if(this.reasonMcmsContext) {
      $dara.Model.validateMap(this.reasonMcmsContext);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfoTables extends $dara.Model {
  /**
   * @example
   * table_name
   */
  name?: string;
  /**
   * @example
   * schema_name
   */
  schema?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      schema: 'Schema',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      schema: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfoTablesBlack extends $dara.Model {
  /**
   * @example
   * table_name
   */
  name?: string;
  /**
   * @example
   * schema_name
   */
  schema?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      schema: 'Schema',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      schema: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfoViews extends $dara.Model {
  /**
   * @example
   * view_name
   */
  name?: string;
  /**
   * @example
   * schema_name
   */
  schema?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      schema: 'Schema',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      schema: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfoViewsBlack extends $dara.Model {
  /**
   * @example
   * view_name
   */
  name?: string;
  /**
   * @example
   * schema_name
   */
  schema?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      schema: 'Schema',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      schema: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfo extends $dara.Model {
  tables?: ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfoTables[];
  tablesBlack?: ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfoTablesBlack[];
  views?: ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfoViews[];
  viewsBlack?: ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfoViewsBlack[];
  /**
   * @example
   * true
   */
  wildcardMode?: boolean;
  static names(): { [key: string]: string } {
    return {
      tables: 'Tables',
      tablesBlack: 'TablesBlack',
      views: 'Views',
      viewsBlack: 'ViewsBlack',
      wildcardMode: 'WildcardMode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tables: { 'type': 'array', 'itemType': ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfoTables },
      tablesBlack: { 'type': 'array', 'itemType': ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfoTablesBlack },
      views: { 'type': 'array', 'itemType': ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfoViews },
      viewsBlack: { 'type': 'array', 'itemType': ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfoViewsBlack },
      wildcardMode: 'boolean',
    };
  }

  validate() {
    if(Array.isArray(this.tables)) {
      $dara.Model.validateArray(this.tables);
    }
    if(Array.isArray(this.tablesBlack)) {
      $dara.Model.validateArray(this.tablesBlack);
    }
    if(Array.isArray(this.views)) {
      $dara.Model.validateArray(this.views);
    }
    if(Array.isArray(this.viewsBlack)) {
      $dara.Model.validateArray(this.viewsBlack);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfoColumnMappings extends $dara.Model {
  /**
   * @example
   * dest_name
   */
  destName?: string;
  /**
   * @example
   * source_name
   */
  sourceName?: string;
  /**
   * @example
   * source_schema
   */
  sourceSchema?: string;
  /**
   * @example
   * source_table
   */
  sourceTable?: string;
  static names(): { [key: string]: string } {
    return {
      destName: 'DestName',
      sourceName: 'SourceName',
      sourceSchema: 'SourceSchema',
      sourceTable: 'SourceTable',
    };
  }

  static types(): { [key: string]: any } {
    return {
      destName: 'string',
      sourceName: 'string',
      sourceSchema: 'string',
      sourceTable: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfoSchemaMappings extends $dara.Model {
  /**
   * @example
   * mapped_schema
   */
  destName?: string;
  /**
   * @example
   * source_name
   */
  sourceName?: string;
  static names(): { [key: string]: string } {
    return {
      destName: 'DestName',
      sourceName: 'SourceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      destName: 'string',
      sourceName: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfoTableMappings extends $dara.Model {
  /**
   * @example
   * dest_name
   */
  destName?: string;
  /**
   * @example
   * source_name
   */
  sourceName?: string;
  /**
   * @example
   * source_schema
   */
  sourceSchema?: string;
  static names(): { [key: string]: string } {
    return {
      destName: 'DestName',
      sourceName: 'SourceName',
      sourceSchema: 'SourceSchema',
    };
  }

  static types(): { [key: string]: any } {
    return {
      destName: 'string',
      sourceName: 'string',
      sourceSchema: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfoViewMappings extends $dara.Model {
  /**
   * @example
   * dest_name
   */
  destName?: string;
  /**
   * @example
   * source_name
   */
  sourceName?: string;
  /**
   * @example
   * schema_name
   */
  sourceSchema?: string;
  static names(): { [key: string]: string } {
    return {
      destName: 'DestName',
      sourceName: 'SourceName',
      sourceSchema: 'SourceSchema',
    };
  }

  static types(): { [key: string]: any } {
    return {
      destName: 'string',
      sourceName: 'string',
      sourceSchema: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfo extends $dara.Model {
  columnMappings?: ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfoColumnMappings[];
  schemaMappings?: ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfoSchemaMappings[];
  tableMappings?: ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfoTableMappings[];
  viewMappings?: ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfoViewMappings[];
  static names(): { [key: string]: string } {
    return {
      columnMappings: 'ColumnMappings',
      schemaMappings: 'SchemaMappings',
      tableMappings: 'TableMappings',
      viewMappings: 'ViewMappings',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnMappings: { 'type': 'array', 'itemType': ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfoColumnMappings },
      schemaMappings: { 'type': 'array', 'itemType': ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfoSchemaMappings },
      tableMappings: { 'type': 'array', 'itemType': ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfoTableMappings },
      viewMappings: { 'type': 'array', 'itemType': ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfoViewMappings },
    };
  }

  validate() {
    if(Array.isArray(this.columnMappings)) {
      $dara.Model.validateArray(this.columnMappings);
    }
    if(Array.isArray(this.schemaMappings)) {
      $dara.Model.validateArray(this.schemaMappings);
    }
    if(Array.isArray(this.tableMappings)) {
      $dara.Model.validateArray(this.tableMappings);
    }
    if(Array.isArray(this.viewMappings)) {
      $dara.Model.validateArray(this.viewMappings);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectModifyRecordsResponseBodyDataTableEtlList extends $dara.Model {
  /**
   * @example
   * db_name
   */
  database?: string;
  /**
   * @example
   * dest_db
   */
  destDatabase?: string;
  /**
   * @example
   * dest_name
   */
  destName?: string;
  filterColumns?: string[];
  /**
   * @example
   * null
   */
  logicTableId?: string;
  shardColumns?: string[];
  /**
   * @example
   * null
   */
  sourceEndpointId?: string;
  /**
   * @example
   * table_name
   */
  tableName?: string;
  /**
   * @example
   * tenant_name
   */
  tenantName?: string;
  /**
   * @example
   * id>1
   */
  whereClause?: string;
  static names(): { [key: string]: string } {
    return {
      database: 'Database',
      destDatabase: 'DestDatabase',
      destName: 'DestName',
      filterColumns: 'FilterColumns',
      logicTableId: 'LogicTableId',
      shardColumns: 'ShardColumns',
      sourceEndpointId: 'SourceEndpointId',
      tableName: 'TableName',
      tenantName: 'TenantName',
      whereClause: 'WhereClause',
    };
  }

  static types(): { [key: string]: any } {
    return {
      database: 'string',
      destDatabase: 'string',
      destName: 'string',
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      logicTableId: 'string',
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      sourceEndpointId: 'string',
      tableName: 'string',
      tenantName: 'string',
      whereClause: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.filterColumns)) {
      $dara.Model.validateArray(this.filterColumns);
    }
    if(Array.isArray(this.shardColumns)) {
      $dara.Model.validateArray(this.shardColumns);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectModifyRecordsResponseBodyData extends $dara.Model {
  databases?: ListProjectModifyRecordsResponseBodyDataDatabases[];
  errorDetail?: ListProjectModifyRecordsResponseBodyDataErrorDetail;
  /**
   * @example
   * 2023-07-13T06:26:15
   */
  gmtModified?: string;
  /**
   * @example
   * 344000005
   */
  id?: number;
  /**
   * @example
   * id
   */
  mergeRequestId?: number;
  migrationObjectsInfo?: ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfo;
  omsProjectMappingInfo?: ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfo;
  /**
   * @example
   * PENDING
   */
  status?: string;
  /**
   * @example
   * np_598qm***
   */
  subProjectId?: string;
  tableEtlList?: ListProjectModifyRecordsResponseBodyDataTableEtlList[];
  /**
   * @example
   * INCREASE_OBJECT
   */
  type?: string;
  /**
   * @example
   * id
   */
  updateRequestId?: number;
  static names(): { [key: string]: string } {
    return {
      databases: 'Databases',
      errorDetail: 'ErrorDetail',
      gmtModified: 'GmtModified',
      id: 'Id',
      mergeRequestId: 'MergeRequestId',
      migrationObjectsInfo: 'MigrationObjectsInfo',
      omsProjectMappingInfo: 'OmsProjectMappingInfo',
      status: 'Status',
      subProjectId: 'SubProjectId',
      tableEtlList: 'TableEtlList',
      type: 'Type',
      updateRequestId: 'UpdateRequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      databases: { 'type': 'array', 'itemType': ListProjectModifyRecordsResponseBodyDataDatabases },
      errorDetail: ListProjectModifyRecordsResponseBodyDataErrorDetail,
      gmtModified: 'string',
      id: 'number',
      mergeRequestId: 'number',
      migrationObjectsInfo: ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfo,
      omsProjectMappingInfo: ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfo,
      status: 'string',
      subProjectId: 'string',
      tableEtlList: { 'type': 'array', 'itemType': ListProjectModifyRecordsResponseBodyDataTableEtlList },
      type: 'string',
      updateRequestId: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.databases)) {
      $dara.Model.validateArray(this.databases);
    }
    if(this.errorDetail && typeof (this.errorDetail as any).validate === 'function') {
      (this.errorDetail as any).validate();
    }
    if(this.migrationObjectsInfo && typeof (this.migrationObjectsInfo as any).validate === 'function') {
      (this.migrationObjectsInfo as any).validate();
    }
    if(this.omsProjectMappingInfo && typeof (this.omsProjectMappingInfo as any).validate === 'function') {
      (this.omsProjectMappingInfo as any).validate();
    }
    if(Array.isArray(this.tableEtlList)) {
      $dara.Model.validateArray(this.tableEtlList);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectModifyRecordsResponseBodyErrorDetail extends $dara.Model {
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * Contact the administrator.
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  validate() {
    if(this.extraContext) {
      $dara.Model.validateMap(this.extraContext);
    }
    if(this.messageMcmsContext) {
      $dara.Model.validateMap(this.messageMcmsContext);
    }
    if(this.proposalMcmsContext) {
      $dara.Model.validateMap(this.proposalMcmsContext);
    }
    if(this.reasonMcmsContext) {
      $dara.Model.validateMap(this.reasonMcmsContext);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectsResponseBodyDataAlarmStats extends $dara.Model {
  /**
   * @example
   * null
   */
  alarmContent?: string;
  /**
   * @example
   * false
   */
  alarming?: boolean;
  /**
   * @example
   * true
   */
  openMonitor?: boolean;
  /**
   * @example
   * 0
   */
  recentlyTriggerCount?: number;
  ruleToRecentlyTriggerCount?: { [key: string]: number };
  /**
   * @example
   * null
   */
  target?: string;
  static names(): { [key: string]: string } {
    return {
      alarmContent: 'AlarmContent',
      alarming: 'Alarming',
      openMonitor: 'OpenMonitor',
      recentlyTriggerCount: 'RecentlyTriggerCount',
      ruleToRecentlyTriggerCount: 'RuleToRecentlyTriggerCount',
      target: 'Target',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alarmContent: 'string',
      alarming: 'boolean',
      openMonitor: 'boolean',
      recentlyTriggerCount: 'number',
      ruleToRecentlyTriggerCount: { 'type': 'map', 'keyType': 'string', 'valueType': 'number' },
      target: 'string',
    };
  }

  validate() {
    if(this.ruleToRecentlyTriggerCount) {
      $dara.Model.validateMap(this.ruleToRecentlyTriggerCount);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectsResponseBodyDataCommonTransferConfig extends $dara.Model {
  /**
   * @example
   * false
   */
  activeActive?: boolean;
  /**
   * @example
   * null
   */
  dataWorksBusinessName?: string;
  /**
   * @example
   * TUPLE
   */
  datahubTopicType?: string;
  /**
   * @example
   * 0
   */
  mqPartition?: number;
  /**
   * @example
   * ONE
   */
  mqPartitionMode?: string;
  /**
   * @example
   * DEFAULT
   */
  mqSerializerType?: string;
  /**
   * @example
   * false
   */
  rocketMqEnableMsgTrace?: boolean;
  /**
   * @example
   * default_tag
   */
  rocketMqMsgTags?: string;
  /**
   * @example
   * OMS
   */
  rocketMqProducerGroup?: string;
  /**
   * @example
   * null
   */
  rocketMqSendMsgTimeout?: number;
  /**
   * @example
   * ALL
   */
  tableCategory?: string;
  static names(): { [key: string]: string } {
    return {
      activeActive: 'ActiveActive',
      dataWorksBusinessName: 'DataWorksBusinessName',
      datahubTopicType: 'DatahubTopicType',
      mqPartition: 'MqPartition',
      mqPartitionMode: 'MqPartitionMode',
      mqSerializerType: 'MqSerializerType',
      rocketMqEnableMsgTrace: 'RocketMqEnableMsgTrace',
      rocketMqMsgTags: 'RocketMqMsgTags',
      rocketMqProducerGroup: 'RocketMqProducerGroup',
      rocketMqSendMsgTimeout: 'RocketMqSendMsgTimeout',
      tableCategory: 'TableCategory',
    };
  }

  static types(): { [key: string]: any } {
    return {
      activeActive: 'boolean',
      dataWorksBusinessName: 'string',
      datahubTopicType: 'string',
      mqPartition: 'number',
      mqPartitionMode: 'string',
      mqSerializerType: 'string',
      rocketMqEnableMsgTrace: 'boolean',
      rocketMqMsgTags: 'string',
      rocketMqProducerGroup: 'string',
      rocketMqSendMsgTimeout: 'number',
      tableCategory: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectsResponseBodyDataExtraInfo extends $dara.Model {
  /**
   * @example
   * true
   */
  accessObSource?: boolean;
  /**
   * @example
   * true
   */
  ignoreUnsupportDdl?: boolean;
  /**
   * @example
   * 1689244596
   */
  incrSyncTimestamp?: number;
  /**
   * @example
   * 1689214358
   */
  logServiceStartCheckpoint?: number;
  /**
   * @example
   * -1
   */
  maxConnectorCount?: number;
  /**
   * @example
   * true
   */
  monitoringIncr?: boolean;
  /**
   * @example
   * true
   */
  overwriteConfig?: boolean;
  reverseSubtopics?: string[];
  /**
   * @example
   * 90
   */
  runningProgress?: number;
  /**
   * @example
   * TRANSFER_PRECHECK
   */
  runningStep?: string;
  /**
   * @example
   * 24
   */
  sourceStoreKeptHour?: number;
  /**
   * @example
   * true
   */
  storeIncr?: boolean;
  subConds?: { [key: string]: DataExtraInfoSubCondsValue[] };
  subDbs?: { [key: string]: DataExtraInfoSubDbsValue[] };
  subIds?: { [key: string]: string };
  subtopics?: string[];
  /**
   * @example
   * null
   */
  syncDelay?: number;
  /**
   * @example
   * 1689214358
   */
  syncDelaySampleTimestamp?: number;
  static names(): { [key: string]: string } {
    return {
      accessObSource: 'AccessObSource',
      ignoreUnsupportDdl: 'IgnoreUnsupportDdl',
      incrSyncTimestamp: 'IncrSyncTimestamp',
      logServiceStartCheckpoint: 'LogServiceStartCheckpoint',
      maxConnectorCount: 'MaxConnectorCount',
      monitoringIncr: 'MonitoringIncr',
      overwriteConfig: 'OverwriteConfig',
      reverseSubtopics: 'ReverseSubtopics',
      runningProgress: 'RunningProgress',
      runningStep: 'RunningStep',
      sourceStoreKeptHour: 'SourceStoreKeptHour',
      storeIncr: 'StoreIncr',
      subConds: 'SubConds',
      subDbs: 'SubDbs',
      subIds: 'SubIds',
      subtopics: 'Subtopics',
      syncDelay: 'SyncDelay',
      syncDelaySampleTimestamp: 'SyncDelaySampleTimestamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessObSource: 'boolean',
      ignoreUnsupportDdl: 'boolean',
      incrSyncTimestamp: 'number',
      logServiceStartCheckpoint: 'number',
      maxConnectorCount: 'number',
      monitoringIncr: 'boolean',
      overwriteConfig: 'boolean',
      reverseSubtopics: { 'type': 'array', 'itemType': 'string' },
      runningProgress: 'number',
      runningStep: 'string',
      sourceStoreKeptHour: 'number',
      storeIncr: 'boolean',
      subConds: { 'type': 'map', 'keyType': 'string', 'valueType': { 'type': 'array', 'itemType': DataExtraInfoSubCondsValue } },
      subDbs: { 'type': 'map', 'keyType': 'string', 'valueType': { 'type': 'array', 'itemType': DataExtraInfoSubDbsValue } },
      subIds: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      subtopics: { 'type': 'array', 'itemType': 'string' },
      syncDelay: 'number',
      syncDelaySampleTimestamp: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.reverseSubtopics)) {
      $dara.Model.validateArray(this.reverseSubtopics);
    }
    if(this.subConds) {
      $dara.Model.validateMap(this.subConds);
    }
    if(this.subDbs) {
      $dara.Model.validateMap(this.subDbs);
    }
    if(this.subIds) {
      $dara.Model.validateMap(this.subIds);
    }
    if(Array.isArray(this.subtopics)) {
      $dara.Model.validateArray(this.subtopics);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectsResponseBodyDataFullTransferConfig extends $dara.Model {
  /**
   * @example
   * false
   */
  allowDestTableNotEmpty?: boolean;
  /**
   * @example
   * NORMAL
   */
  fullTransferSpeedMode?: string;
  /**
   * @example
   * NORMAL
   */
  fullVerifySpeedMode?: string;
  /**
   * @example
   * false
   */
  nonePkUkTruncateDstTable?: boolean;
  static names(): { [key: string]: string } {
    return {
      allowDestTableNotEmpty: 'AllowDestTableNotEmpty',
      fullTransferSpeedMode: 'FullTransferSpeedMode',
      fullVerifySpeedMode: 'FullVerifySpeedMode',
      nonePkUkTruncateDstTable: 'NonePkUkTruncateDstTable',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allowDestTableNotEmpty: 'boolean',
      fullTransferSpeedMode: 'string',
      fullVerifySpeedMode: 'string',
      nonePkUkTruncateDstTable: 'boolean',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectsResponseBodyDataIncrTransferConfig extends $dara.Model {
  /**
   * @example
   * true
   */
  enableIncrSyncStatistics?: boolean;
  /**
   * @example
   * true
   */
  enableSequencingWithinTxn?: boolean;
  /**
   * @example
   * 64
   */
  incrSyncConcurrency?: number;
  recordTypeWhiteList?: string[];
  /**
   * @example
   * 1681004708
   */
  startTimestamp?: number;
  /**
   * @example
   * 24
   */
  storeLogKeptHour?: number;
  static names(): { [key: string]: string } {
    return {
      enableIncrSyncStatistics: 'EnableIncrSyncStatistics',
      enableSequencingWithinTxn: 'EnableSequencingWithinTxn',
      incrSyncConcurrency: 'IncrSyncConcurrency',
      recordTypeWhiteList: 'RecordTypeWhiteList',
      startTimestamp: 'StartTimestamp',
      storeLogKeptHour: 'StoreLogKeptHour',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enableIncrSyncStatistics: 'boolean',
      enableSequencingWithinTxn: 'boolean',
      incrSyncConcurrency: 'number',
      recordTypeWhiteList: { 'type': 'array', 'itemType': 'string' },
      startTimestamp: 'number',
      storeLogKeptHour: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.recordTypeWhiteList)) {
      $dara.Model.validateArray(this.recordTypeWhiteList);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectsResponseBodyDataLabels extends $dara.Model {
  /**
   * @example
   * 2
   */
  count?: number;
  /**
   * @example
   * admin
   */
  creator?: string;
  /**
   * @example
   * l_dfe****
   */
  id?: string;
  /**
   * @example
   * label_name
   */
  name?: string;
  /**
   * @example
   * 1
   */
  type?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      creator: 'Creator',
      id: 'Id',
      name: 'Name',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      creator: 'string',
      id: 'string',
      name: 'string',
      type: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectsResponseBodyDataSinkConnectInfo extends $dara.Model {
  /**
   * @example
   * utf8mb4
   */
  charset?: string;
  /**
   * @example
   * null
   */
  connExtraAttributes?: any;
  /**
   * @example
   * null
   */
  connectionInfo?: string;
  /**
   * @example
   * MYSQL_PUBLIC
   */
  dbEngine?: string;
  /**
   * @example
   * e_4w3aic***
   */
  endpointId?: string;
  /**
   * @example
   * ation129***9apimysql5616****
   */
  endpointName?: string;
  /**
   * @example
   * sink
   */
  endpointSide?: string;
  /**
   * @example
   * xxx.xxx.xxx.1
   */
  host?: string;
  /**
   * @example
   * c_4w3akx***
   */
  id?: string;
  /**
   * @example
   * null
   */
  nlsLengthSemantics?: string;
  /**
   * @example
   * null
   */
  ocpName?: string;
  /**
   * @example
   * Linux
   */
  operatingSystem?: string;
  /**
   * @remarks
   * Owner。
   * 
   * @example
   * admin
   */
  owner?: string;
  /**
   * @example
   * 2883
   */
  port?: number;
  /**
   * @example
   * cn-hangzhou
   */
  region?: string;
  /**
   * @example
   * 1325847***
   */
  resourceOwner?: string;
  /**
   * @example
   * +08:00
   */
  timezone?: string;
  /**
   * @example
   * oms**obmys**
   */
  username?: string;
  /**
   * @example
   * 2.2.77
   */
  version?: string;
  static names(): { [key: string]: string } {
    return {
      charset: 'Charset',
      connExtraAttributes: 'ConnExtraAttributes',
      connectionInfo: 'ConnectionInfo',
      dbEngine: 'DbEngine',
      endpointId: 'EndpointId',
      endpointName: 'EndpointName',
      endpointSide: 'EndpointSide',
      host: 'Host',
      id: 'Id',
      nlsLengthSemantics: 'NlsLengthSemantics',
      ocpName: 'OcpName',
      operatingSystem: 'OperatingSystem',
      owner: 'Owner',
      port: 'Port',
      region: 'Region',
      resourceOwner: 'ResourceOwner',
      timezone: 'Timezone',
      username: 'Username',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      charset: 'string',
      connExtraAttributes: 'any',
      connectionInfo: 'string',
      dbEngine: 'string',
      endpointId: 'string',
      endpointName: 'string',
      endpointSide: 'string',
      host: 'string',
      id: 'string',
      nlsLengthSemantics: 'string',
      ocpName: 'string',
      operatingSystem: 'string',
      owner: 'string',
      port: 'number',
      region: 'string',
      resourceOwner: 'string',
      timezone: 'string',
      username: 'string',
      version: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectsResponseBodyDataSourceConnectInfo extends $dara.Model {
  /**
   * @example
   * utf8mb4
   */
  charset?: string;
  /**
   * @example
   * null
   */
  connExtraAttributes?: any;
  /**
   * @example
   * null
   */
  connectionInfo?: string;
  /**
   * @example
   * OB_MYSQL_PUBLIC
   */
  dbEngine?: string;
  /**
   * @example
   * e_4w3al***
   */
  endpointId?: string;
  /**
   * @example
   * ration12****0obmysql4116892***
   */
  endpointName?: string;
  /**
   * @example
   * source
   */
  endpointSide?: string;
  /**
   * @example
   * xxx.xxx.xxx.1
   */
  host?: string;
  /**
   * @example
   * c_4w3aq****
   */
  id?: string;
  /**
   * @example
   * null
   */
  nlsLengthSemantics?: string;
  /**
   * @example
   * null
   */
  ocpName?: string;
  /**
   * @example
   * Linux
   */
  operatingSystem?: string;
  /**
   * @remarks
   * Owner。
   * 
   * @example
   * admin
   */
  owner?: string;
  /**
   * @example
   * 2883
   */
  port?: number;
  /**
   * @example
   * cn-hangzhou
   */
  region?: string;
  /**
   * @example
   * 1325847***
   */
  resourceOwner?: string;
  /**
   * @example
   * UTC
   */
  timezone?: string;
  /**
   * @example
   * oms931mys**
   */
  username?: string;
  /**
   * @example
   * 5.7.27
   */
  version?: string;
  static names(): { [key: string]: string } {
    return {
      charset: 'Charset',
      connExtraAttributes: 'ConnExtraAttributes',
      connectionInfo: 'ConnectionInfo',
      dbEngine: 'DbEngine',
      endpointId: 'EndpointId',
      endpointName: 'EndpointName',
      endpointSide: 'EndpointSide',
      host: 'Host',
      id: 'Id',
      nlsLengthSemantics: 'NlsLengthSemantics',
      ocpName: 'OcpName',
      operatingSystem: 'OperatingSystem',
      owner: 'Owner',
      port: 'Port',
      region: 'Region',
      resourceOwner: 'ResourceOwner',
      timezone: 'Timezone',
      username: 'Username',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      charset: 'string',
      connExtraAttributes: 'any',
      connectionInfo: 'string',
      dbEngine: 'string',
      endpointId: 'string',
      endpointName: 'string',
      endpointSide: 'string',
      host: 'string',
      id: 'string',
      nlsLengthSemantics: 'string',
      ocpName: 'string',
      operatingSystem: 'string',
      owner: 'string',
      port: 'number',
      region: 'string',
      resourceOwner: 'string',
      timezone: 'string',
      username: 'string',
      version: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectsResponseBodyDataStepsExtraInfoErrorDetails extends $dara.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * Contact the administrator.
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  validate() {
    if(this.extraContext) {
      $dara.Model.validateMap(this.extraContext);
    }
    if(this.messageMcmsContext) {
      $dara.Model.validateMap(this.messageMcmsContext);
    }
    if(this.proposalMcmsContext) {
      $dara.Model.validateMap(this.proposalMcmsContext);
    }
    if(this.reasonMcmsContext) {
      $dara.Model.validateMap(this.reasonMcmsContext);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectsResponseBodyDataStepsExtraInfo extends $dara.Model {
  /**
   * @example
   * INNER_ERROR
   */
  errorCode?: string;
  errorDetails?: ListProjectsResponseBodyDataStepsExtraInfoErrorDetails[];
  /**
   * @example
   * A system error occurred.
   */
  errorMsg?: string;
  errorParam?: { [key: string]: string };
  /**
   * @example
   * null
   */
  failedTime?: string;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorDetails: 'ErrorDetails',
      errorMsg: 'ErrorMsg',
      errorParam: 'ErrorParam',
      failedTime: 'FailedTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorDetails: { 'type': 'array', 'itemType': ListProjectsResponseBodyDataStepsExtraInfoErrorDetails },
      errorMsg: 'string',
      errorParam: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      failedTime: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.errorDetails)) {
      $dara.Model.validateArray(this.errorDetails);
    }
    if(this.errorParam) {
      $dara.Model.validateMap(this.errorParam);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectsResponseBodyDataSteps extends $dara.Model {
  description?: string;
  extraInfo?: ListProjectsResponseBodyDataStepsExtraInfo;
  /**
   * @example
   * 2020-05-22T17:05:18
   */
  finishTime?: string;
  /**
   * @example
   * TRANSFER_PRECHECK
   */
  name?: string;
  /**
   * @example
   * 1
   */
  order?: number;
  /**
   * @example
   * 100
   */
  progress?: number;
  /**
   * @example
   * 2020-05-22T17:04:18
   */
  startTime?: string;
  /**
   * @example
   * RUNNING
   */
  status?: string;
  /**
   * @example
   * null
   */
  stepInfo?: { [key: string]: any };
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      extraInfo: 'ExtraInfo',
      finishTime: 'FinishTime',
      name: 'Name',
      order: 'Order',
      progress: 'Progress',
      startTime: 'StartTime',
      status: 'Status',
      stepInfo: 'StepInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      extraInfo: ListProjectsResponseBodyDataStepsExtraInfo,
      finishTime: 'string',
      name: 'string',
      order: 'number',
      progress: 'number',
      startTime: 'string',
      status: 'string',
      stepInfo: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
    };
  }

  validate() {
    if(this.extraInfo && typeof (this.extraInfo as any).validate === 'function') {
      (this.extraInfo as any).validate();
    }
    if(this.stepInfo) {
      $dara.Model.validateMap(this.stepInfo);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectsResponseBodyDataStructTransferConfig extends $dara.Model {
  /**
   * @example
   * DO_NOTHING_IF_BYTE_USED
   */
  byteCharConvertStrategy?: string;
  /**
   * @example
   * false
   */
  deferIndexCreation?: boolean;
  static names(): { [key: string]: string } {
    return {
      byteCharConvertStrategy: 'ByteCharConvertStrategy',
      deferIndexCreation: 'DeferIndexCreation',
    };
  }

  static types(): { [key: string]: any } {
    return {
      byteCharConvertStrategy: 'string',
      deferIndexCreation: 'boolean',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectsResponseBodyDataTransferMapping extends $dara.Model {
  /**
   * @example
   * SPECIFIC
   */
  mode?: string;
  static names(): { [key: string]: string } {
    return {
      mode: 'Mode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      mode: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectsResponseBodyDataWorkerGradeInfo extends $dara.Model {
  autoRenewal?: boolean;
  chargeType?: string;
  destRegion?: string;
  destType?: string;
  endTime?: string;
  expired?: boolean;
  gmtCreate?: string;
  grade?: string;
  id?: string;
  name?: string;
  sourceRegion?: string;
  sourceType?: string;
  spec?: string;
  specName?: string;
  static names(): { [key: string]: string } {
    return {
      autoRenewal: 'AutoRenewal',
      chargeType: 'ChargeType',
      destRegion: 'DestRegion',
      destType: 'DestType',
      endTime: 'EndTime',
      expired: 'Expired',
      gmtCreate: 'GmtCreate',
      grade: 'Grade',
      id: 'Id',
      name: 'Name',
      sourceRegion: 'SourceRegion',
      sourceType: 'SourceType',
      spec: 'Spec',
      specName: 'SpecName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoRenewal: 'boolean',
      chargeType: 'string',
      destRegion: 'string',
      destType: 'string',
      endTime: 'string',
      expired: 'boolean',
      gmtCreate: 'string',
      grade: 'string',
      id: 'string',
      name: 'string',
      sourceRegion: 'string',
      sourceType: 'string',
      spec: 'string',
      specName: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectsResponseBodyData extends $dara.Model {
  alarmStats?: ListProjectsResponseBodyDataAlarmStats;
  commonTransferConfig?: ListProjectsResponseBodyDataCommonTransferConfig;
  /**
   * @example
   * null
   */
  destConnId?: string;
  /**
   * @example
   * true
   */
  enableFullTransfer?: boolean;
  /**
   * @example
   * true
   */
  enableFullVerify?: boolean;
  /**
   * @example
   * true
   */
  enableIncrTransfer?: boolean;
  /**
   * @example
   * true
   */
  enableIncrVerify?: boolean;
  /**
   * @example
   * true
   */
  enableReverseIncrTransfer?: boolean;
  /**
   * @example
   * true
   */
  enableStructTransfer?: boolean;
  extraInfo?: ListProjectsResponseBodyDataExtraInfo;
  fullTransferConfig?: ListProjectsResponseBodyDataFullTransferConfig;
  /**
   * @example
   * 2023-07-13T06:26:15
   */
  gmtCreate?: string;
  /**
   * @example
   * 2023-07-13T08:01:27
   */
  gmtFinish?: string;
  /**
   * @example
   * 2023-07-13T07:01:27
   */
  gmtModified?: string;
  /**
   * @example
   * 2023-07-13T07:02:27
   */
  gmtStart?: string;
  /**
   * @example
   * np_4w****
   */
  id?: string;
  /**
   * @example
   * MEDIUM
   */
  importance?: string;
  incrTransferConfig?: ListProjectsResponseBodyDataIncrTransferConfig;
  /**
   * @example
   * false
   */
  isMerging?: boolean;
  /**
   * @example
   * false
   */
  isModifying?: boolean;
  /**
   * @example
   * false
   */
  isSubProject?: boolean;
  labels?: ListProjectsResponseBodyDataLabels[];
  /**
   * @example
   * project_name
   */
  name?: string;
  /**
   * @example
   * admin
   */
  owner?: string;
  sinkConnectInfo?: ListProjectsResponseBodyDataSinkConnectInfo;
  /**
   * @example
   * OB_MYSQL
   */
  sinkEndpointType?: string;
  sourceConnectInfo?: ListProjectsResponseBodyDataSourceConnectInfo;
  /**
   * @example
   * MYSQL
   */
  sourceEndpointType?: string;
  /**
   * @example
   * RUNNING
   */
  status?: string;
  steps?: ListProjectsResponseBodyDataSteps[];
  structTransferConfig?: ListProjectsResponseBodyDataStructTransferConfig;
  transferMapping?: ListProjectsResponseBodyDataTransferMapping;
  /**
   * @example
   * MIGRATION
   */
  type?: string;
  /**
   * @example
   * g_i4wa7XXX
   */
  workerGradeId?: string;
  workerGradeInfo?: ListProjectsResponseBodyDataWorkerGradeInfo;
  static names(): { [key: string]: string } {
    return {
      alarmStats: 'AlarmStats',
      commonTransferConfig: 'CommonTransferConfig',
      destConnId: 'DestConnId',
      enableFullTransfer: 'EnableFullTransfer',
      enableFullVerify: 'EnableFullVerify',
      enableIncrTransfer: 'EnableIncrTransfer',
      enableIncrVerify: 'EnableIncrVerify',
      enableReverseIncrTransfer: 'EnableReverseIncrTransfer',
      enableStructTransfer: 'EnableStructTransfer',
      extraInfo: 'ExtraInfo',
      fullTransferConfig: 'FullTransferConfig',
      gmtCreate: 'GmtCreate',
      gmtFinish: 'GmtFinish',
      gmtModified: 'GmtModified',
      gmtStart: 'GmtStart',
      id: 'Id',
      importance: 'Importance',
      incrTransferConfig: 'IncrTransferConfig',
      isMerging: 'IsMerging',
      isModifying: 'IsModifying',
      isSubProject: 'IsSubProject',
      labels: 'Labels',
      name: 'Name',
      owner: 'Owner',
      sinkConnectInfo: 'SinkConnectInfo',
      sinkEndpointType: 'SinkEndpointType',
      sourceConnectInfo: 'SourceConnectInfo',
      sourceEndpointType: 'SourceEndpointType',
      status: 'Status',
      steps: 'Steps',
      structTransferConfig: 'StructTransferConfig',
      transferMapping: 'TransferMapping',
      type: 'Type',
      workerGradeId: 'WorkerGradeId',
      workerGradeInfo: 'WorkerGradeInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alarmStats: ListProjectsResponseBodyDataAlarmStats,
      commonTransferConfig: ListProjectsResponseBodyDataCommonTransferConfig,
      destConnId: 'string',
      enableFullTransfer: 'boolean',
      enableFullVerify: 'boolean',
      enableIncrTransfer: 'boolean',
      enableIncrVerify: 'boolean',
      enableReverseIncrTransfer: 'boolean',
      enableStructTransfer: 'boolean',
      extraInfo: ListProjectsResponseBodyDataExtraInfo,
      fullTransferConfig: ListProjectsResponseBodyDataFullTransferConfig,
      gmtCreate: 'string',
      gmtFinish: 'string',
      gmtModified: 'string',
      gmtStart: 'string',
      id: 'string',
      importance: 'string',
      incrTransferConfig: ListProjectsResponseBodyDataIncrTransferConfig,
      isMerging: 'boolean',
      isModifying: 'boolean',
      isSubProject: 'boolean',
      labels: { 'type': 'array', 'itemType': ListProjectsResponseBodyDataLabels },
      name: 'string',
      owner: 'string',
      sinkConnectInfo: ListProjectsResponseBodyDataSinkConnectInfo,
      sinkEndpointType: 'string',
      sourceConnectInfo: ListProjectsResponseBodyDataSourceConnectInfo,
      sourceEndpointType: 'string',
      status: 'string',
      steps: { 'type': 'array', 'itemType': ListProjectsResponseBodyDataSteps },
      structTransferConfig: ListProjectsResponseBodyDataStructTransferConfig,
      transferMapping: ListProjectsResponseBodyDataTransferMapping,
      type: 'string',
      workerGradeId: 'string',
      workerGradeInfo: ListProjectsResponseBodyDataWorkerGradeInfo,
    };
  }

  validate() {
    if(this.alarmStats && typeof (this.alarmStats as any).validate === 'function') {
      (this.alarmStats as any).validate();
    }
    if(this.commonTransferConfig && typeof (this.commonTransferConfig as any).validate === 'function') {
      (this.commonTransferConfig as any).validate();
    }
    if(this.extraInfo && typeof (this.extraInfo as any).validate === 'function') {
      (this.extraInfo as any).validate();
    }
    if(this.fullTransferConfig && typeof (this.fullTransferConfig as any).validate === 'function') {
      (this.fullTransferConfig as any).validate();
    }
    if(this.incrTransferConfig && typeof (this.incrTransferConfig as any).validate === 'function') {
      (this.incrTransferConfig as any).validate();
    }
    if(Array.isArray(this.labels)) {
      $dara.Model.validateArray(this.labels);
    }
    if(this.sinkConnectInfo && typeof (this.sinkConnectInfo as any).validate === 'function') {
      (this.sinkConnectInfo as any).validate();
    }
    if(this.sourceConnectInfo && typeof (this.sourceConnectInfo as any).validate === 'function') {
      (this.sourceConnectInfo as any).validate();
    }
    if(Array.isArray(this.steps)) {
      $dara.Model.validateArray(this.steps);
    }
    if(this.structTransferConfig && typeof (this.structTransferConfig as any).validate === 'function') {
      (this.structTransferConfig as any).validate();
    }
    if(this.transferMapping && typeof (this.transferMapping as any).validate === 'function') {
      (this.transferMapping as any).validate();
    }
    if(this.workerGradeInfo && typeof (this.workerGradeInfo as any).validate === 'function') {
      (this.workerGradeInfo as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectsResponseBodyErrorDetail extends $dara.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * Contact the administrator.
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  validate() {
    if(this.extraContext) {
      $dara.Model.validateMap(this.extraContext);
    }
    if(this.messageMcmsContext) {
      $dara.Model.validateMap(this.messageMcmsContext);
    }
    if(this.proposalMcmsContext) {
      $dara.Model.validateMap(this.proposalMcmsContext);
    }
    if(this.reasonMcmsContext) {
      $dara.Model.validateMap(this.reasonMcmsContext);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkerInstancesResponseBodyData extends $dara.Model {
  /**
   * @example
   * 2023-07-14T20:49:53
   */
  gmtCreate?: string;
  /**
   * @example
   * g_i4katzv***
   */
  id?: string;
  /**
   * @example
   * i4wa71k****
   */
  name?: string;
  /**
   * @example
   * np_4kb18w****
   */
  projectId?: string;
  /**
   * @example
   * j_migration_cloud-kafkavpc-ob
   */
  projectName?: string;
  /**
   * @example
   * MIGRATION
   */
  projectType?: string;
  /**
   * @example
   * null
   */
  region?: string;
  /**
   * @example
   * oms.g2m.small
   */
  spec?: string;
  /**
   * @example
   * ONLINE
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      gmtCreate: 'GmtCreate',
      id: 'Id',
      name: 'Name',
      projectId: 'ProjectId',
      projectName: 'ProjectName',
      projectType: 'ProjectType',
      region: 'Region',
      spec: 'Spec',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gmtCreate: 'string',
      id: 'string',
      name: 'string',
      projectId: 'string',
      projectName: 'string',
      projectType: 'string',
      region: 'string',
      spec: 'string',
      status: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkerInstancesResponseBodyErrorDetail extends $dara.Model {
  /**
   * @example
   * 200
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * FATAL
   */
  level?: string;
  /**
   * @example
   * successful
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * null
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  validate() {
    if(this.extraContext) {
      $dara.Model.validateMap(this.extraContext);
    }
    if(this.messageMcmsContext) {
      $dara.Model.validateMap(this.messageMcmsContext);
    }
    if(this.proposalMcmsContext) {
      $dara.Model.validateMap(this.proposalMcmsContext);
    }
    if(this.reasonMcmsContext) {
      $dara.Model.validateMap(this.reasonMcmsContext);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDatabaseUserRolesResponseBodyTenantUserUsers extends $dara.Model {
  /**
   * @example
   * ReadOnly
   */
  role?: string;
  /**
   * @example
   * user_pay_ro
   */
  userName?: string;
  static names(): { [key: string]: string } {
    return {
      role: 'Role',
      userName: 'UserName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      role: 'string',
      userName: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDatabaseUserRolesResponseBodyTenantUser extends $dara.Model {
  /**
   * @remarks
   * Example 1
   * 
   * @example
   * sms_pre
   */
  databaseName?: string;
  /**
   * @example
   * t33h8y08k****
   */
  tenantId?: string;
  users?: ModifyDatabaseUserRolesResponseBodyTenantUserUsers[];
  static names(): { [key: string]: string } {
    return {
      databaseName: 'DatabaseName',
      tenantId: 'TenantId',
      users: 'Users',
    };
  }

  static types(): { [key: string]: any } {
    return {
      databaseName: 'string',
      tenantId: 'string',
      users: { 'type': 'array', 'itemType': ModifyDatabaseUserRolesResponseBodyTenantUserUsers },
    };
  }

  validate() {
    if(Array.isArray(this.users)) {
      $dara.Model.validateArray(this.users);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceNodeNumResponseBodyData extends $dara.Model {
  /**
   * @remarks
   * The result of the dry-run request.
   * - If the DryRun parameter is set to true and the dry run succeeds, the DryRunResult parameter returns true. Otherwise, an error code is returned.
   * - If the DryRun parameter is set to false, no dry run is performed and the DryRunResult parameter returns false.
   * 
   * @example
   * false
   */
  dryRunResult?: boolean;
  /**
   * @remarks
   * The ID of the order.
   * 
   * @example
   * 2132903*********
   */
  orderId?: string;
  static names(): { [key: string]: string } {
    return {
      dryRunResult: 'DryRunResult',
      orderId: 'OrderId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dryRunResult: 'boolean',
      orderId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceSSLResponseBodyInstanceSSL extends $dara.Model {
  /**
   * @remarks
   * The operation to modify the SSL status. Valid values:
   * 
   * - open: Enable SSL encryption.
   * 
   * - update: Update the CA certificate.
   * 
   * - close: Disable SSL encryption.
   * 
   * @example
   * open
   */
  enableSSL?: string;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      enableSSL: 'EnableSSL',
      instanceId: 'InstanceId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enableSSL: 'string',
      instanceId: 'string',
      tenantId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceSpecResponseBodyData extends $dara.Model {
  /**
   * @remarks
   * The result of the dry-run request.
   * - If the DryRun parameter is set to true and the dry run succeeds, the DryRunResult parameter returns true. Otherwise, an error code is returned.
   * - If the DryRun parameter is set to false, no dry run is performed and the DryRunResult parameter returns false.
   * 
   * @example
   * false
   */
  dryRunResult?: boolean;
  /**
   * @remarks
   * The ID of the order that you have placed.
   * 
   * @example
   * 213290*********
   */
  orderId?: string;
  static names(): { [key: string]: string } {
    return {
      dryRunResult: 'DryRunResult',
      orderId: 'OrderId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dryRunResult: 'boolean',
      orderId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyParametersResponseBodyResults extends $dara.Model {
  /**
   * @example
   * schedule timeout.
   */
  message?: string;
  /**
   * @example
   * false
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      message: 'Message',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      message: 'string',
      success: 'boolean',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifySecurityIpsResponseBodySecurityIpGroup extends $dara.Model {
  /**
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @example
   * online_paycore
   */
  securityIpGroupName?: string;
  /**
   * @example
   * 121.41.106.33,100.104.7.0/26
   */
  securityIps?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      securityIpGroupName: 'SecurityIpGroupName',
      securityIps: 'SecurityIps',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      securityIpGroupName: 'string',
      securityIps: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantEncryptionResponseBodyTenantEncryption extends $dara.Model {
  /**
   * @example
   * EncryptionKey
   */
  encryptionType?: string;
  /**
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @example
   * ob2mr3oae0****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      encryptionType: 'EncryptionType',
      instanceId: 'InstanceId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      encryptionType: 'string',
      instanceId: 'string',
      tenantId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantSecurityIpGroupResponseBodySecurityIpGroup extends $dara.Model {
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The name of the whitelist group.
   * 
   * @example
   * paytest
   */
  securityIpGroupName?: string;
  /**
   * @remarks
   * The list of IP addresses in the IP address whitelist group.
   * 
   * It is a string separated by commas, and each object is an IP address or a CIDR block.
   * 
   * @example
   * 192.***.*.*
   */
  securityIps?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * @example
   * t4louaeei****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      securityIpGroupName: 'SecurityIpGroupName',
      securityIps: 'SecurityIps',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      securityIpGroupName: 'string',
      securityIps: 'string',
      tenantId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantUserRolesResponseBodyTenantUserUserRole extends $dara.Model {
  /**
   * @remarks
   * ```
   * http(s)://[Endpoint]/?Action=ModifyTenantUserRoles
   * &UserName=pay_test
   * &TenantId=ob2mr3oae0****
   * &UserRole=[{"Database":"20210824160559","Role":"readwrite"}]
   * &InstanceId=ob317v4uif****
   * &ModifyType=update
   * &Common request parameters
   * ```
   * 
   * @example
   * db_pay1
   */
  database?: string;
  /**
   * @example
   * true
   */
  isSuccess?: boolean;
  /**
   * @remarks
   * You can call this operation to modify the database privileges of a specified account in a tenant.
   * 
   * @example
   * ReadOnly
   */
  role?: string;
  /**
   * @example
   * tbl_pay1
   */
  table?: string;
  static names(): { [key: string]: string } {
    return {
      database: 'Database',
      isSuccess: 'IsSuccess',
      role: 'Role',
      table: 'Table',
    };
  }

  static types(): { [key: string]: any } {
    return {
      database: 'string',
      isSuccess: 'boolean',
      role: 'string',
      table: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantUserRolesResponseBodyTenantUser extends $dara.Model {
  /**
   * @example
   * t33h8y08k****
   */
  tenantId?: string;
  /**
   * @example
   * pay_test
   */
  userName?: string;
  /**
   * @remarks
   * The name of the database (MySQL mode) or schema (Oracle mode).
   * 
   * @example
   * 账号具备的数据库权限信息列表。
   */
  userRole?: ModifyTenantUserRolesResponseBodyTenantUserUserRole[];
  static names(): { [key: string]: string } {
    return {
      tenantId: 'TenantId',
      userName: 'UserName',
      userRole: 'UserRole',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
      userName: 'string',
      userRole: { 'type': 'array', 'itemType': ModifyTenantUserRolesResponseBodyTenantUserUserRole },
    };
  }

  validate() {
    if(Array.isArray(this.userRole)) {
      $dara.Model.validateArray(this.userRole);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantUserStatusResponseBodyTenantUser extends $dara.Model {
  /**
   * @example
   * t33h8y08k****
   */
  tenantId?: string;
  /**
   * @example
   * pay_test
   */
  userName?: string;
  /**
   * @example
   * LOCKED
   */
  userStatus?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'TenantId',
      userName: 'UserName',
      userStatus: 'UserStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
      userName: 'string',
      userStatus: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleaseProjectResponseBodyErrorDetail extends $dara.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * Contact the administrator.
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  validate() {
    if(this.extraContext) {
      $dara.Model.validateMap(this.extraContext);
    }
    if(this.messageMcmsContext) {
      $dara.Model.validateMap(this.messageMcmsContext);
    }
    if(this.proposalMcmsContext) {
      $dara.Model.validateMap(this.proposalMcmsContext);
    }
    if(this.reasonMcmsContext) {
      $dara.Model.validateMap(this.reasonMcmsContext);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleaseWorkerInstanceResponseBodyErrorDetail extends $dara.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * Contact the administrator.
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  validate() {
    if(this.extraContext) {
      $dara.Model.validateMap(this.extraContext);
    }
    if(this.messageMcmsContext) {
      $dara.Model.validateMap(this.messageMcmsContext);
    }
    if(this.proposalMcmsContext) {
      $dara.Model.validateMap(this.proposalMcmsContext);
    }
    if(this.reasonMcmsContext) {
      $dara.Model.validateMap(this.reasonMcmsContext);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResumeProjectResponseBodyErrorDetail extends $dara.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * Contact the administrator.
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  validate() {
    if(this.extraContext) {
      $dara.Model.validateMap(this.extraContext);
    }
    if(this.messageMcmsContext) {
      $dara.Model.validateMap(this.messageMcmsContext);
    }
    if(this.proposalMcmsContext) {
      $dara.Model.validateMap(this.proposalMcmsContext);
    }
    if(this.reasonMcmsContext) {
      $dara.Model.validateMap(this.reasonMcmsContext);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RetryProjectModifyRecordsResponseBodyErrorDetail extends $dara.Model {
  /**
   * @example
   * 200
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * Contact the administrator.
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  validate() {
    if(this.extraContext) {
      $dara.Model.validateMap(this.extraContext);
    }
    if(this.messageMcmsContext) {
      $dara.Model.validateMap(this.messageMcmsContext);
    }
    if(this.proposalMcmsContext) {
      $dara.Model.validateMap(this.proposalMcmsContext);
    }
    if(this.reasonMcmsContext) {
      $dara.Model.validateMap(this.reasonMcmsContext);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartProjectResponseBodyErrorDetail extends $dara.Model {
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * Contact the administrator.
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  validate() {
    if(this.extraContext) {
      $dara.Model.validateMap(this.extraContext);
    }
    if(this.messageMcmsContext) {
      $dara.Model.validateMap(this.messageMcmsContext);
    }
    if(this.proposalMcmsContext) {
      $dara.Model.validateMap(this.proposalMcmsContext);
    }
    if(this.reasonMcmsContext) {
      $dara.Model.validateMap(this.reasonMcmsContext);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartProjectsByLabelResponseBodyData extends $dara.Model {
  failedProjectIds?: string[];
  succeedProjectIds?: string[];
  /**
   * @example
   * 20
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      failedProjectIds: 'FailedProjectIds',
      succeedProjectIds: 'SucceedProjectIds',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failedProjectIds: { 'type': 'array', 'itemType': 'string' },
      succeedProjectIds: { 'type': 'array', 'itemType': 'string' },
      total: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.failedProjectIds)) {
      $dara.Model.validateArray(this.failedProjectIds);
    }
    if(Array.isArray(this.succeedProjectIds)) {
      $dara.Model.validateArray(this.succeedProjectIds);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartProjectsByLabelResponseBodyErrorDetail extends $dara.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * null
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  validate() {
    if(this.extraContext) {
      $dara.Model.validateMap(this.extraContext);
    }
    if(this.messageMcmsContext) {
      $dara.Model.validateMap(this.messageMcmsContext);
    }
    if(this.proposalMcmsContext) {
      $dara.Model.validateMap(this.proposalMcmsContext);
    }
    if(this.reasonMcmsContext) {
      $dara.Model.validateMap(this.reasonMcmsContext);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopProjectResponseBodyErrorDetail extends $dara.Model {
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * Contact the administrator.
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  validate() {
    if(this.extraContext) {
      $dara.Model.validateMap(this.extraContext);
    }
    if(this.messageMcmsContext) {
      $dara.Model.validateMap(this.messageMcmsContext);
    }
    if(this.proposalMcmsContext) {
      $dara.Model.validateMap(this.proposalMcmsContext);
    }
    if(this.reasonMcmsContext) {
      $dara.Model.validateMap(this.reasonMcmsContext);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopProjectModifyRecordsResponseBodyErrorDetail extends $dara.Model {
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * Contact the administrator.
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  validate() {
    if(this.extraContext) {
      $dara.Model.validateMap(this.extraContext);
    }
    if(this.messageMcmsContext) {
      $dara.Model.validateMap(this.messageMcmsContext);
    }
    if(this.proposalMcmsContext) {
      $dara.Model.validateMap(this.proposalMcmsContext);
    }
    if(this.reasonMcmsContext) {
      $dara.Model.validateMap(this.reasonMcmsContext);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopProjectsByLabelResponseBodyData extends $dara.Model {
  failedProjectIds?: string[];
  succeedProjectIds?: string[];
  /**
   * @example
   * 16
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      failedProjectIds: 'FailedProjectIds',
      succeedProjectIds: 'SucceedProjectIds',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failedProjectIds: { 'type': 'array', 'itemType': 'string' },
      succeedProjectIds: { 'type': 'array', 'itemType': 'string' },
      total: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.failedProjectIds)) {
      $dara.Model.validateArray(this.failedProjectIds);
    }
    if(Array.isArray(this.succeedProjectIds)) {
      $dara.Model.validateArray(this.succeedProjectIds);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopProjectsByLabelResponseBodyErrorDetail extends $dara.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * ERROR
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  /**
   * @example
   * Contact the administrator.
   */
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  validate() {
    if(this.extraContext) {
      $dara.Model.validateMap(this.extraContext);
    }
    if(this.messageMcmsContext) {
      $dara.Model.validateMap(this.messageMcmsContext);
    }
    if(this.proposalMcmsContext) {
      $dara.Model.validateMap(this.proposalMcmsContext);
    }
    if(this.reasonMcmsContext) {
      $dara.Model.validateMap(this.reasonMcmsContext);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SwitchoverInstanceResponseBodyData extends $dara.Model {
  /**
   * @remarks
   * The message of the switchover.
   * 
   * @example
   * delete tag-value success
   */
  message?: string;
  /**
   * @remarks
   * Whether the switchover is successful.
   * - true: the switchover succeeded.
   * - false: the switchover failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      message: 'Message',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      message: 'string',
      success: 'boolean',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProjectConfigRequestCommonTransferConfig extends $dara.Model {
  sinkStoreFormat?: string;
  sourceStoreFormat?: string;
  static names(): { [key: string]: string } {
    return {
      sinkStoreFormat: 'SinkStoreFormat',
      sourceStoreFormat: 'SourceStoreFormat',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sinkStoreFormat: 'string',
      sourceStoreFormat: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProjectConfigRequestFullTransferConfig extends $dara.Model {
  indexDDLConcurrencyLimit?: number;
  maxConcurrentIndexDDLs?: number;
  /**
   * @example
   * 64
   */
  readWorkerNum?: number;
  /**
   * @example
   * null
   */
  throttleIOPS?: number;
  /**
   * @example
   * null
   */
  throttleRps?: number;
  /**
   * @example
   * 64
   */
  writeWorkerNum?: number;
  static names(): { [key: string]: string } {
    return {
      indexDDLConcurrencyLimit: 'IndexDDLConcurrencyLimit',
      maxConcurrentIndexDDLs: 'MaxConcurrentIndexDDLs',
      readWorkerNum: 'ReadWorkerNum',
      throttleIOPS: 'ThrottleIOPS',
      throttleRps: 'ThrottleRps',
      writeWorkerNum: 'WriteWorkerNum',
    };
  }

  static types(): { [key: string]: any } {
    return {
      indexDDLConcurrencyLimit: 'number',
      maxConcurrentIndexDDLs: 'number',
      readWorkerNum: 'number',
      throttleIOPS: 'number',
      throttleRps: 'number',
      writeWorkerNum: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProjectConfigRequestIncrTransferConfig extends $dara.Model {
  /**
   * @example
   * 64
   */
  incrSyncThreadCount?: number;
  recordTypeWhiteList?: string[];
  supportDDLTypes?: string[];
  /**
   * @example
   * null
   */
  throttleIOPS?: number;
  /**
   * @example
   * null
   */
  throttleRps?: number;
  static names(): { [key: string]: string } {
    return {
      incrSyncThreadCount: 'IncrSyncThreadCount',
      recordTypeWhiteList: 'RecordTypeWhiteList',
      supportDDLTypes: 'SupportDDLTypes',
      throttleIOPS: 'ThrottleIOPS',
      throttleRps: 'ThrottleRps',
    };
  }

  static types(): { [key: string]: any } {
    return {
      incrSyncThreadCount: 'number',
      recordTypeWhiteList: { 'type': 'array', 'itemType': 'string' },
      supportDDLTypes: { 'type': 'array', 'itemType': 'string' },
      throttleIOPS: 'number',
      throttleRps: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.recordTypeWhiteList)) {
      $dara.Model.validateArray(this.recordTypeWhiteList);
    }
    if(Array.isArray(this.supportDDLTypes)) {
      $dara.Model.validateArray(this.supportDDLTypes);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProjectConfigRequestReverseIncrTransferConfig extends $dara.Model {
  /**
   * @example
   * 64
   */
  incrSyncThreadCount?: number;
  recordTypeWhiteList?: string[];
  supportDDLTypes?: string[];
  /**
   * @example
   * null
   */
  throttleIOPS?: number;
  /**
   * @example
   * null
   */
  throttleRps?: number;
  static names(): { [key: string]: string } {
    return {
      incrSyncThreadCount: 'IncrSyncThreadCount',
      recordTypeWhiteList: 'RecordTypeWhiteList',
      supportDDLTypes: 'SupportDDLTypes',
      throttleIOPS: 'ThrottleIOPS',
      throttleRps: 'ThrottleRps',
    };
  }

  static types(): { [key: string]: any } {
    return {
      incrSyncThreadCount: 'number',
      recordTypeWhiteList: { 'type': 'array', 'itemType': 'string' },
      supportDDLTypes: { 'type': 'array', 'itemType': 'string' },
      throttleIOPS: 'number',
      throttleRps: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.recordTypeWhiteList)) {
      $dara.Model.validateArray(this.recordTypeWhiteList);
    }
    if(Array.isArray(this.supportDDLTypes)) {
      $dara.Model.validateArray(this.supportDDLTypes);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProjectConfigResponseBodyErrorDetail extends $dara.Model {
  /**
   * @example
   * CM-RESOAT1111
   */
  code?: string;
  extraContext?: { [key: string]: any };
  /**
   * @example
   * WARN
   */
  level?: string;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  messageMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  messageMcmsKey?: string;
  proposal?: string;
  proposalMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  proposalMcmsKey?: string;
  /**
   * @example
   * null
   */
  reason?: string;
  reasonMcmsContext?: { [key: string]: string };
  /**
   * @example
   * null
   */
  reasonMcmsKey?: string;
  /**
   * @example
   * null
   */
  upstreamErrorDetail?: any;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      extraContext: 'ExtraContext',
      level: 'Level',
      message: 'Message',
      messageMcmsContext: 'MessageMcmsContext',
      messageMcmsKey: 'MessageMcmsKey',
      proposal: 'Proposal',
      proposalMcmsContext: 'ProposalMcmsContext',
      proposalMcmsKey: 'ProposalMcmsKey',
      reason: 'Reason',
      reasonMcmsContext: 'ReasonMcmsContext',
      reasonMcmsKey: 'ReasonMcmsKey',
      upstreamErrorDetail: 'UpstreamErrorDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      extraContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      level: 'string',
      message: 'string',
      messageMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      messageMcmsKey: 'string',
      proposal: 'string',
      proposalMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      proposalMcmsKey: 'string',
      reason: 'string',
      reasonMcmsContext: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      reasonMcmsKey: 'string',
      upstreamErrorDetail: 'any',
    };
  }

  validate() {
    if(this.extraContext) {
      $dara.Model.validateMap(this.extraContext);
    }
    if(this.messageMcmsContext) {
      $dara.Model.validateMap(this.messageMcmsContext);
    }
    if(this.proposalMcmsContext) {
      $dara.Model.validateMap(this.proposalMcmsContext);
    }
    if(this.reasonMcmsContext) {
      $dara.Model.validateMap(this.reasonMcmsContext);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DataExtraInfoSubCondsValue extends $dara.Model {
  /**
   * @example
   * tenant_name
   */
  tenantName?: string;
  /**
   * @example
   * db_name
   */
  database?: string;
  /**
   * @example
   * dest_db
   */
  destDatabase?: string;
  /**
   * @example
   * table_name
   */
  tableName?: string;
  /**
   * @example
   * dest_name
   */
  destName?: string;
  /**
   * @example
   * id>1
   */
  whereClause?: string;
  filterColumns?: string[];
  shardColumns?: string[];
  /**
   * @example
   * null
   */
  logicTableId?: string;
  /**
   * @example
   * null
   */
  sourceEndpointId?: string;
  /**
   * @example
   * null
   */
  sourceClientId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantName: 'TenantName',
      database: 'Database',
      destDatabase: 'DestDatabase',
      tableName: 'TableName',
      destName: 'DestName',
      whereClause: 'WhereClause',
      filterColumns: 'FilterColumns',
      shardColumns: 'ShardColumns',
      logicTableId: 'LogicTableId',
      sourceEndpointId: 'SourceEndpointId',
      sourceClientId: 'SourceClientId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantName: 'string',
      database: 'string',
      destDatabase: 'string',
      tableName: 'string',
      destName: 'string',
      whereClause: 'string',
      filterColumns: { 'type': 'array', 'itemType': 'string' },
      shardColumns: { 'type': 'array', 'itemType': 'string' },
      logicTableId: 'string',
      sourceEndpointId: 'string',
      sourceClientId: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.filterColumns)) {
      $dara.Model.validateArray(this.filterColumns);
    }
    if(Array.isArray(this.shardColumns)) {
      $dara.Model.validateArray(this.shardColumns);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DataExtraInfoSubDbsValue extends $dara.Model {
  /**
   * @example
   * cluster_name
   */
  clusterName?: string;
  /**
   * @example
   * tenant_name
   */
  tenantName?: string;
  /**
   * @example
   * null
   */
  databaseId?: string;
  /**
   * @example
   * db_name
   */
  databaseName?: string;
  /**
   * @example
   * mapped_db
   */
  mappingDatabaseName?: string;
  /**
   * @example
   * null
   */
  sourceClientId?: string;
  tables?: DataExtraInfoSubDbsValueTables[];
  static names(): { [key: string]: string } {
    return {
      clusterName: 'ClusterName',
      tenantName: 'TenantName',
      databaseId: 'DatabaseId',
      databaseName: 'DatabaseName',
      mappingDatabaseName: 'MappingDatabaseName',
      sourceClientId: 'SourceClientId',
      tables: 'Tables',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterName: 'string',
      tenantName: 'string',
      databaseId: 'string',
      databaseName: 'string',
      mappingDatabaseName: 'string',
      sourceClientId: 'string',
      tables: { 'type': 'array', 'itemType': DataExtraInfoSubDbsValueTables },
    };
  }

  validate() {
    if(Array.isArray(this.tables)) {
      $dara.Model.validateArray(this.tables);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchKillProcessListRequest extends $dara.Model {
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The list of sessions to close.
   * 
   * This parameter is required.
   * 
   * @example
   * [{"ProxySessId":"752113700739156671","SessionId":3221555062,"ServerIp":"10.***.**.***"}]
   */
  sessionList?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * t33h8y08k****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      sessionList: 'SessionList',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      sessionList: 'string',
      tenantId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchKillProcessListResponseBody extends $dara.Model {
  /**
   * @remarks
   * The array of the return result.
   */
  data?: BatchKillProcessListResponseBodyData[];
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': BatchKillProcessListResponseBodyData },
      requestId: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.data)) {
      $dara.Model.validateArray(this.data);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchKillProcessListResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: BatchKillProcessListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchKillProcessListResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchKillSessionListRequest extends $dara.Model {
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The list of sessions, which is concatenated with commas.
   * >The session information is obtained from the result returned by the DescribeSessionList API.
   * 
   * This parameter is required.
   * 
   * @example
   * 342,354,343
   */
  sessionList?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * t4louaeei****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      sessionList: 'SessionList',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      sessionList: 'string',
      tenantId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchKillSessionListResponseBody extends $dara.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchKillSessionListResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: BatchKillSessionListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchKillSessionListResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelProjectModifyRecordRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 344000005
   */
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelProjectModifyRecordResponseBody extends $dara.Model {
  /**
   * @example
   * Contact the administrator.
   */
  advice?: string;
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  /**
   * @example
   * 30
   */
  cost?: string;
  /**
   * @example
   * null
   */
  data?: any;
  errorDetail?: CancelProjectModifyRecordResponseBodyErrorDetail;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 100
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      cost: 'Cost',
      data: 'Data',
      errorDetail: 'ErrorDetail',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      cost: 'string',
      data: 'any',
      errorDetail: CancelProjectModifyRecordResponseBodyErrorDetail,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  validate() {
    if(this.errorDetail && typeof (this.errorDetail as any).validate === 'function') {
      (this.errorDetail as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelProjectModifyRecordResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CancelProjectModifyRecordResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CancelProjectModifyRecordResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateBackupSetDownloadLinkRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * bak-6f****
   */
  backupSetId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * i-bp67acfmxazb4p****
   */
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      backupSetId: 'BackupSetId',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      backupSetId: 'string',
      instanceId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateBackupSetDownloadLinkResponseBody extends $dara.Model {
  /**
   * @example
   * 10000***67
   */
  downloadTaskId?: number;
  /**
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      downloadTaskId: 'DownloadTaskId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      downloadTaskId: 'number',
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateBackupSetDownloadLinkResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateBackupSetDownloadLinkResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateBackupSetDownloadLinkResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDatabaseRequest extends $dara.Model {
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * 123e4567-e89b-12d3-a456-426655440000
   */
  clientToken?: string;
  /**
   * @remarks
   * The encoding standard of the database.
   * For more information, see the Charset field returned by the DescribeCharset operation.
   * 
   * @example
   * utf8mb4_general_ci
   */
  collation?: string;
  /**
   * @remarks
   * Alibaba Cloud CLI
   * 
   * This parameter is required.
   * 
   * @example
   * sms_pre
   */
  databaseName?: string;
  /**
   * @remarks
   * The operation that you want to perform.   
   * Set the value to **CreateDatabase**.
   * 
   * @example
   * this is a test database
   */
  description?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * utf8mb4
   */
  encoding?: string;
  /**
   * @remarks
   * The collation.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The name of the database.   
   * You cannot use reserved keywords, such as test and mysql.
   * 
   * This parameter is required.
   * 
   * @example
   * ob2mr3oae0****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      clientToken: 'ClientToken',
      collation: 'Collation',
      databaseName: 'DatabaseName',
      description: 'Description',
      encoding: 'Encoding',
      instanceId: 'InstanceId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clientToken: 'string',
      collation: 'string',
      databaseName: 'string',
      description: 'string',
      encoding: 'string',
      instanceId: 'string',
      tenantId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDatabaseResponseBody extends $dara.Model {
  /**
   * @remarks
   * CreateDatabase
   * 
   * @example
   * sms_pre
   */
  databaseName?: string;
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      databaseName: 'DatabaseName',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      databaseName: 'string',
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDatabaseResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateDatabaseResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateDatabaseResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateInstanceRequest extends $dara.Model {
  /**
   * @remarks
   * Specifies whether to enable automatic renewal.   
   * This parameter is valid only when the ChargeType parameter is set to PrePaid. Valid values: 
   * - true: enables automatic renewal for the instance.   
   * - false: disables automatic renewal for the instance. This is the default value.
   * 
   * @example
   * true
   */
  autoRenew?: boolean;
  /**
   * @remarks
   * The automatic renewal period of the instance. This parameter is required when the AutoRenew parameter is set to true. Valid values:  
   * - If the PeriodUnit parameter is set to Year: "1", "2", and "3".   
   * - If the PeriodUnit parameter is set to Month: "1", "2", "3", "6", and "12".
   * 
   * @example
   * 2
   */
  autoRenewPeriod?: number;
  /**
   * @remarks
   * The billing method of the instance. Valid values:  
   * - PrePay: the subscription billing method. You must ensure that the remaining balance or credit balance of your account can cover the cost of the subscription. Otherwise, you will receive an InvalidPayMethod error. 
   * - PostPay: the pay-as-you-go billing method. This is the default value. By default, fees are charged on an hourly basis.
   * 
   * This parameter is required.
   * 
   * @example
   * PrePay
   */
  chargeType?: string;
  /**
   * @example
   * x86
   */
  cpuArch?: string;
  /**
   * @remarks
   * The size of the storage space,in GB.    
   * The limits on the storage space vary with the cluster specifications:   
   * - 8C32GB: 100 GB to 10000 GB   
   * - 14C70GB: 200 GB to 10000 GB   
   * - 30C180GB: 400 GB to 10000 GB   
   * - 62C400GB: 800 GB to 10000 GB    
   * The preceding minimum storage space sizes are the default storage space sizes of the corresponding cluster specification plans.
   * 
   * @example
   * 200
   */
  diskSize?: number;
  /**
   * @remarks
   * The type of the storage disk where the cluster is deployed. This parameter takes effect only for Standard Cluster Edition (Cloud Disk).
   * Valid values:
   * - cloud_essd_pl1: ESSD PL1.
   * - cloud_essd_pl0: ESSD PL0. Default value: cloud_essd_pl1.
   * 
   * @example
   * cloud_essd_pl1
   */
  diskType?: string;
  /**
   * @remarks
   * Specifies whether to perform only a dry run for the request. Default value: false. Valid values:
   * - true: Only a dry-run request is sent and the instance is not created. If the dry run succeeds, DryRunResult=true is returned. If the dry run fails, an error code is returned.
   * - false: The actual request is sent and no dry run is performed. The instance is created if the requirements are met. By default, the DryRunResult parameter returns false if you set DryRun to false.
   * 
   * @example
   * false
   */
  dryRun?: boolean;
  /**
   * @remarks
   * The specifications of the cluster.     
   * You can specify one of the following four plans:   
   *  - 8C32GB: indicates 8 CPU cores and 32 GB of memory.    
   *  - 14C70GB: indicates 14 CPU cores and 70 GB of memory. This is the default value.
   * - 30C180GB: indicates 30 CPU cores and 180 GB of memory.     
   * - 62C400GB: indicates 62 CPU cores and 400 GB of memory.
   * 
   * This parameter is required.
   * 
   * @example
   * 14C70GB
   */
  instanceClass?: string;
  /**
   * @remarks
   * The name of the OceanBase cluster.    
   * It must be 1 to 20 characters in length.   
   * If this parameter is not specified, the value is the instance ID of the cluster by default.
   * 
   * @example
   * amap_aos_tx_ob
   */
  instanceName?: string;
  /**
   * @remarks
   * Specifies whether to enable the control group feature.
   * Valid values:
   * - true
   * - false
   * 
   * @example
   * true
   */
  isolationOptimization?: string;
  /**
   * @remarks
   * OceanBase Server version number.
   * 
   * @example
   * 2.2.77
   */
  obVersion?: string;
  /**
   * @remarks
   * The valid duration of the purchased resources. The unit is specified by the PeriodUnit parameter.   
   * This parameter is valid and required only when the InstanceChargeType parameter is set to PrePaid.      
   * Valid values:     
   * - When the PeriodUnit parameter is set to Month: "1", "2", "3", "4", "5", "6", "7", "8", "9". 
   * - When the PeriodUnit parameter is set to Year: "1", "2", "3".
   * 
   * @example
   * 1
   */
  period?: number;
  /**
   * @remarks
   * The unit of the valid duration of the purchased resources.     
   * Valid value for subscription: Month or Year.
   * Default value: Month for subscription, and Hour for pay-as-you-go.
   * 
   * @example
   * Month
   */
  periodUnit?: string;
  /**
   * @remarks
   * Primary instance ID.
   * 
   * @example
   * ob3h8ytroxxxxx
   */
  primaryInstance?: string;
  /**
   * @remarks
   * Primary instance region.
   * 
   * @example
   * cn-hangzhou
   */
  primaryRegion?: string;
  /**
   * @remarks
   * The number of full-featured replicas.
   * - 3F: three full-featured replicas.
   * - 2F1L: two full-featured replicas and one log replica.
   * - 2F1A: two full-featured replicas and one arbitration service.
   * - ApsaraDB for OceanBase earlier than V4.1 supports 3F and 2F1L.
   * - ApsaraDB for OceanBase V4.1 or later supports 3F and 2F1A.
   * - An ApsaraDB for OceanBase instance deployed across three zones supports only 3F.
   * - An ApsaraDB for OceanBase instance deployed across two zones supports 2F1A or 2F1L, depending on the version.
   * - An ApsaraDB for OceanBase instance deployed in a single zone supports 3F, 2F1A, or 2F1L, depending on the version.
   * 
   * @example
   * 3F
   */
  replicaMode?: string;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs.
   * 
   * @example
   * rg-bp67acfmxazb4p****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The series of the OceanBase cluster. Valid values:    
   * - normal: Standard Cluster Edition (Cloud Disk). This is the default value.
   * - normal_ssd: Standard Cluster Edition (Local Disk).
   * - history: History Database Cluster Edition.
   * 
   * This parameter is required.
   * 
   * @example
   * Normal
   */
  series?: string;
  /**
   * @remarks
   * The ID of the zone to which the instance belongs.   
   * For more information about how to obtain the list of zones, see [DescribeZones](https://help.aliyun.com/document_detail/25610.html).
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou-h,cn-hangzhou-i,cn-hangzhou-j
   */
  zones?: string;
  static names(): { [key: string]: string } {
    return {
      autoRenew: 'AutoRenew',
      autoRenewPeriod: 'AutoRenewPeriod',
      chargeType: 'ChargeType',
      cpuArch: 'CpuArch',
      diskSize: 'DiskSize',
      diskType: 'DiskType',
      dryRun: 'DryRun',
      instanceClass: 'InstanceClass',
      instanceName: 'InstanceName',
      isolationOptimization: 'IsolationOptimization',
      obVersion: 'ObVersion',
      period: 'Period',
      periodUnit: 'PeriodUnit',
      primaryInstance: 'PrimaryInstance',
      primaryRegion: 'PrimaryRegion',
      replicaMode: 'ReplicaMode',
      resourceGroupId: 'ResourceGroupId',
      series: 'Series',
      zones: 'Zones',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoRenew: 'boolean',
      autoRenewPeriod: 'number',
      chargeType: 'string',
      cpuArch: 'string',
      diskSize: 'number',
      diskType: 'string',
      dryRun: 'boolean',
      instanceClass: 'string',
      instanceName: 'string',
      isolationOptimization: 'string',
      obVersion: 'string',
      period: 'number',
      periodUnit: 'string',
      primaryInstance: 'string',
      primaryRegion: 'string',
      replicaMode: 'string',
      resourceGroupId: 'string',
      series: 'string',
      zones: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateInstanceResponseBody extends $dara.Model {
  /**
   * @remarks
   * The returned data.
   */
  data?: CreateInstanceResponseBodyData;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: CreateInstanceResponseBodyData,
      requestId: 'string',
    };
  }

  validate() {
    if(this.data && typeof (this.data as any).validate === 'function') {
      (this.data as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateInstanceResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateInstanceResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLabelRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * test
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLabelResponseBody extends $dara.Model {
  /**
   * @example
   * Contact the administrator.
   */
  advice?: string;
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  /**
   * @example
   * 1
   */
  cost?: string;
  /**
   * @example
   * l_****
   */
  data?: string;
  errorDetail?: CreateLabelResponseBodyErrorDetail;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * E3D924FB-52****B253-0C1A7EFB778C
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 24
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      cost: 'Cost',
      data: 'Data',
      errorDetail: 'ErrorDetail',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      cost: 'string',
      data: 'string',
      errorDetail: CreateLabelResponseBodyErrorDetail,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  validate() {
    if(this.errorDetail && typeof (this.errorDetail as any).validate === 'function') {
      (this.errorDetail as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLabelResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateLabelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateLabelResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMySqlDataSourceRequest extends $dara.Model {
  /**
   * @example
   * test
   */
  description?: string;
  /**
   * @example
   * dg-x****
   */
  dgInstanceId?: string;
  /**
   * @example
   * rm-t4****
   */
  instanceId?: string;
  /**
   * @example
   * xxx.xxx.xxx.1
   */
  ip?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * source_name
   */
  name?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * pass_word
   */
  password?: string;
  /**
   * @example
   * 2883
   */
  port?: number;
  /**
   * @example
   * test
   */
  schema?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * VPC
   */
  type?: string;
  useSsl?: boolean;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * user_name
   */
  userName?: string;
  /**
   * @example
   * vpc-bp1d2q3mhg9i23ofi****
   */
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      dgInstanceId: 'DgInstanceId',
      instanceId: 'InstanceId',
      ip: 'Ip',
      name: 'Name',
      password: 'Password',
      port: 'Port',
      schema: 'Schema',
      type: 'Type',
      useSsl: 'UseSsl',
      userName: 'UserName',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      dgInstanceId: 'string',
      instanceId: 'string',
      ip: 'string',
      name: 'string',
      password: 'string',
      port: 'number',
      schema: 'string',
      type: 'string',
      useSsl: 'boolean',
      userName: 'string',
      vpcId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMySqlDataSourceResponseBody extends $dara.Model {
  /**
   * @example
   * Contact the administrator.
   */
  advice?: string;
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  /**
   * @example
   * 1
   */
  cost?: string;
  /**
   * @example
   * e_edz****
   */
  data?: string;
  errorDetail?: CreateMySqlDataSourceResponseBodyErrorDetail;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 24
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      cost: 'Cost',
      data: 'Data',
      errorDetail: 'ErrorDetail',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      cost: 'string',
      data: 'string',
      errorDetail: CreateMySqlDataSourceResponseBodyErrorDetail,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  validate() {
    if(this.errorDetail && typeof (this.errorDetail as any).validate === 'function') {
      (this.errorDetail as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMySqlDataSourceResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateMySqlDataSourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateMySqlDataSourceResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOceanBaseDataSourceRequest extends $dara.Model {
  /**
   * @example
   * cluster_name
   */
  cluster?: string;
  /**
   * @example
   * http://xxx.xxx.xxx.2:2883/services?Action=ObRootServiceInfo&User_ID=alibaba&UID=ocpmaster&ObRegion=ob_1***29.admin
   */
  configUrl?: string;
  /**
   * @example
   * test
   */
  description?: string;
  /**
   * @example
   * pas***
   */
  drcPassword?: string;
  /**
   * @example
   * user_na***
   */
  drcUserName?: string;
  /**
   * @example
   * in***
   */
  innerDrcPassword?: string;
  /**
   * @example
   * xxx.xxx.xxx.1
   */
  ip?: string;
  /**
   * @remarks
   * LogProxy IP。
   * 
   * @example
   * null
   */
  logProxyIp?: string;
  /**
   * @example
   * null
   */
  logProxyPort?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * source_name
   */
  name?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * pass_word
   */
  password?: string;
  /**
   * @example
   * 2883
   */
  port?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * tenant_name
   */
  tenant?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * OB_MYSQL_VPC
   */
  type?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * user_name
   */
  userName?: string;
  /**
   * @example
   * vpc-bp1d2q3mhg9i23ofi****
   */
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      cluster: 'Cluster',
      configUrl: 'ConfigUrl',
      description: 'Description',
      drcPassword: 'DrcPassword',
      drcUserName: 'DrcUserName',
      innerDrcPassword: 'InnerDrcPassword',
      ip: 'Ip',
      logProxyIp: 'LogProxyIp',
      logProxyPort: 'LogProxyPort',
      name: 'Name',
      password: 'Password',
      port: 'Port',
      tenant: 'Tenant',
      type: 'Type',
      userName: 'UserName',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cluster: 'string',
      configUrl: 'string',
      description: 'string',
      drcPassword: 'string',
      drcUserName: 'string',
      innerDrcPassword: 'string',
      ip: 'string',
      logProxyIp: 'string',
      logProxyPort: 'string',
      name: 'string',
      password: 'string',
      port: 'number',
      tenant: 'string',
      type: 'string',
      userName: 'string',
      vpcId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOceanBaseDataSourceResponseBody extends $dara.Model {
  /**
   * @example
   * Contact the administrator.
   */
  advice?: string;
  /**
   * @example
   * null
   */
  code?: string;
  /**
   * @example
   * 1
   */
  cost?: string;
  /**
   * @example
   * e_edz****
   */
  data?: string;
  errorDetail?: CreateOceanBaseDataSourceResponseBodyErrorDetail;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 30
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      cost: 'Cost',
      data: 'Data',
      errorDetail: 'ErrorDetail',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      cost: 'string',
      data: 'string',
      errorDetail: CreateOceanBaseDataSourceResponseBodyErrorDetail,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  validate() {
    if(this.errorDetail && typeof (this.errorDetail as any).validate === 'function') {
      (this.errorDetail as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOceanBaseDataSourceResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateOceanBaseDataSourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateOceanBaseDataSourceResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOmsMysqlDataSourceRequest extends $dara.Model {
  /**
   * @remarks
   * The description of the data source.   
   * 
   * It must be 2 to 256 characters in length. The default value is null.
   * 
   * @example
   * MySQL data source for OMS testing
   */
  description?: string;
  /**
   * @remarks
   * The ID of the database gateway instance.   
   * 
   * > <br>If Type is set to DG, this parameter is required.
   * 
   * @example
   * dg-yhss6sdlaff****
   */
  dgDatabaseId?: string;
  /**
   * @remarks
   * The ID of the ECS instance of the data source.   
   * 
   * > <br>If Type is set to RDS, PolarDB, or DG, this parameter is required.
   * 
   * @example
   * pc-12ab34cd56******
   */
  instanceId?: string;
  /**
   * @remarks
   * The IP address of the data source.   
   * 
   * > <br>If Type is set to INTERNET or VPC, this parameter is required.
   * 
   * @example
   * 10.0.****
   */
  ip?: string;
  /**
   * @remarks
   * The name of the data source.   
   * It must be 2 to 128 characters in length and can contain letters, digits, underscores (_), periods (.), and hyphens (-).   
   * 
   * > <br>Invalid characters, such as slashes (/), are not allowed.
   * 
   * This parameter is required.
   * 
   * @example
   * oms-mysql
   */
  name?: string;
  /**
   * @remarks
   * The password of the username that is used to access the database. It must be Base64 encoded.   
   * For example, for the password abcd123@!, the Base64-encoded value is YWJjZDEyM0Ah.
   * 
   * This parameter is required.
   * 
   * @example
   * YWJjZDEyM0Ah
   */
  password?: string;
  /**
   * @remarks
   * The port number of the data source.   
   * 
   * > <br>If Type is set to INTERNET or VPC, this parameter is required.
   * 
   * @example
   * 3306
   */
  port?: string;
  /**
   * @remarks
   * The name of the database.   
   * 
   * > <br>If you specify this parameter, subsequent migration or synchronization operations will take effect on this database only.
   * 
   * @example
   * test
   */
  schema?: string;
  /**
   * @remarks
   * The type of the MySQL data source.   
   * Valid values: INTERNET, VPC, RDS, PolarDB, and DG.
   * 
   * This parameter is required.
   * 
   * @example
   * INTERNET
   */
  type?: string;
  /**
   * @remarks
   * The username that is used to access the database.
   * 
   * This parameter is required.
   * 
   * @example
   * omsTestUser
   */
  username?: string;
  /**
   * @remarks
   * The ID of the VPC to which the data source belongs.   
   * 
   * > <br>If Type is set to VPC, this parameter is required.
   * 
   * @example
   * vpc-12345abcde*******
   */
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      dgDatabaseId: 'DgDatabaseId',
      instanceId: 'InstanceId',
      ip: 'Ip',
      name: 'Name',
      password: 'Password',
      port: 'Port',
      schema: 'Schema',
      type: 'Type',
      username: 'Username',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      dgDatabaseId: 'string',
      instanceId: 'string',
      ip: 'string',
      name: 'string',
      password: 'string',
      port: 'string',
      schema: 'string',
      type: 'string',
      username: 'string',
      vpcId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOmsMysqlDataSourceResponseBody extends $dara.Model {
  /**
   * @remarks
   * The return result of the request.
   */
  data?: CreateOmsMysqlDataSourceResponseBodyData;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: CreateOmsMysqlDataSourceResponseBodyData,
      requestId: 'string',
    };
  }

  validate() {
    if(this.data && typeof (this.data as any).validate === 'function') {
      (this.data as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOmsMysqlDataSourceResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateOmsMysqlDataSourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateOmsMysqlDataSourceResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectRequest extends $dara.Model {
  commonTransferConfig?: CreateProjectRequestCommonTransferConfig;
  /**
   * @example
   * true
   */
  enableFullTransfer?: boolean;
  /**
   * @example
   * true
   */
  enableFullVerify?: boolean;
  /**
   * @example
   * true
   */
  enableIncrTransfer?: boolean;
  /**
   * @example
   * true
   */
  enableReverseIncrTransfer?: boolean;
  /**
   * @example
   * true
   */
  enableStructTransfer?: boolean;
  fullTransferConfig?: CreateProjectRequestFullTransferConfig;
  /**
   * @remarks
   * This parameter is required.
   */
  id?: string;
  incrTransferConfig?: CreateProjectRequestIncrTransferConfig;
  labelIds?: string[];
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * test
   */
  name?: string;
  /**
   * @example
   * open_api_create_project/oacp_xxx
   */
  ossKey?: string;
  reverseIncrTransferConfig?: CreateProjectRequestReverseIncrTransferConfig;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * e_4j0cz****
   */
  sinkEndpointId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * e_4j0c12z****
   */
  sourceEndpointId?: string;
  structTransferConfig?: CreateProjectRequestStructTransferConfig;
  /**
   * @remarks
   * This parameter is required.
   */
  transferMapping?: CreateProjectRequestTransferMapping;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * MIGRATION
   */
  type?: string;
  /**
   * @example
   * true
   */
  useOss?: boolean;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * g_abcdefj***
   */
  workerGradeId?: string;
  static names(): { [key: string]: string } {
    return {
      commonTransferConfig: 'CommonTransferConfig',
      enableFullTransfer: 'EnableFullTransfer',
      enableFullVerify: 'EnableFullVerify',
      enableIncrTransfer: 'EnableIncrTransfer',
      enableReverseIncrTransfer: 'EnableReverseIncrTransfer',
      enableStructTransfer: 'EnableStructTransfer',
      fullTransferConfig: 'FullTransferConfig',
      id: 'Id',
      incrTransferConfig: 'IncrTransferConfig',
      labelIds: 'LabelIds',
      name: 'Name',
      ossKey: 'OssKey',
      reverseIncrTransferConfig: 'ReverseIncrTransferConfig',
      sinkEndpointId: 'SinkEndpointId',
      sourceEndpointId: 'SourceEndpointId',
      structTransferConfig: 'StructTransferConfig',
      transferMapping: 'TransferMapping',
      type: 'Type',
      useOss: 'UseOss',
      workerGradeId: 'WorkerGradeId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonTransferConfig: CreateProjectRequestCommonTransferConfig,
      enableFullTransfer: 'boolean',
      enableFullVerify: 'boolean',
      enableIncrTransfer: 'boolean',
      enableReverseIncrTransfer: 'boolean',
      enableStructTransfer: 'boolean',
      fullTransferConfig: CreateProjectRequestFullTransferConfig,
      id: 'string',
      incrTransferConfig: CreateProjectRequestIncrTransferConfig,
      labelIds: { 'type': 'array', 'itemType': 'string' },
      name: 'string',
      ossKey: 'string',
      reverseIncrTransferConfig: CreateProjectRequestReverseIncrTransferConfig,
      sinkEndpointId: 'string',
      sourceEndpointId: 'string',
      structTransferConfig: CreateProjectRequestStructTransferConfig,
      transferMapping: CreateProjectRequestTransferMapping,
      type: 'string',
      useOss: 'boolean',
      workerGradeId: 'string',
    };
  }

  validate() {
    if(this.commonTransferConfig && typeof (this.commonTransferConfig as any).validate === 'function') {
      (this.commonTransferConfig as any).validate();
    }
    if(this.fullTransferConfig && typeof (this.fullTransferConfig as any).validate === 'function') {
      (this.fullTransferConfig as any).validate();
    }
    if(this.incrTransferConfig && typeof (this.incrTransferConfig as any).validate === 'function') {
      (this.incrTransferConfig as any).validate();
    }
    if(Array.isArray(this.labelIds)) {
      $dara.Model.validateArray(this.labelIds);
    }
    if(this.reverseIncrTransferConfig && typeof (this.reverseIncrTransferConfig as any).validate === 'function') {
      (this.reverseIncrTransferConfig as any).validate();
    }
    if(this.structTransferConfig && typeof (this.structTransferConfig as any).validate === 'function') {
      (this.structTransferConfig as any).validate();
    }
    if(this.transferMapping && typeof (this.transferMapping as any).validate === 'function') {
      (this.transferMapping as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectShrinkRequest extends $dara.Model {
  commonTransferConfigShrink?: string;
  /**
   * @example
   * true
   */
  enableFullTransfer?: boolean;
  /**
   * @example
   * true
   */
  enableFullVerify?: boolean;
  /**
   * @example
   * true
   */
  enableIncrTransfer?: boolean;
  /**
   * @example
   * true
   */
  enableReverseIncrTransfer?: boolean;
  /**
   * @example
   * true
   */
  enableStructTransfer?: boolean;
  fullTransferConfigShrink?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  id?: string;
  incrTransferConfigShrink?: string;
  labelIdsShrink?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * test
   */
  name?: string;
  /**
   * @example
   * open_api_create_project/oacp_xxx
   */
  ossKey?: string;
  reverseIncrTransferConfigShrink?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * e_4j0cz****
   */
  sinkEndpointId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * e_4j0c12z****
   */
  sourceEndpointId?: string;
  structTransferConfigShrink?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  transferMappingShrink?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * MIGRATION
   */
  type?: string;
  /**
   * @example
   * true
   */
  useOss?: boolean;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * g_abcdefj***
   */
  workerGradeId?: string;
  static names(): { [key: string]: string } {
    return {
      commonTransferConfigShrink: 'CommonTransferConfig',
      enableFullTransfer: 'EnableFullTransfer',
      enableFullVerify: 'EnableFullVerify',
      enableIncrTransfer: 'EnableIncrTransfer',
      enableReverseIncrTransfer: 'EnableReverseIncrTransfer',
      enableStructTransfer: 'EnableStructTransfer',
      fullTransferConfigShrink: 'FullTransferConfig',
      id: 'Id',
      incrTransferConfigShrink: 'IncrTransferConfig',
      labelIdsShrink: 'LabelIds',
      name: 'Name',
      ossKey: 'OssKey',
      reverseIncrTransferConfigShrink: 'ReverseIncrTransferConfig',
      sinkEndpointId: 'SinkEndpointId',
      sourceEndpointId: 'SourceEndpointId',
      structTransferConfigShrink: 'StructTransferConfig',
      transferMappingShrink: 'TransferMapping',
      type: 'Type',
      useOss: 'UseOss',
      workerGradeId: 'WorkerGradeId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonTransferConfigShrink: 'string',
      enableFullTransfer: 'boolean',
      enableFullVerify: 'boolean',
      enableIncrTransfer: 'boolean',
      enableReverseIncrTransfer: 'boolean',
      enableStructTransfer: 'boolean',
      fullTransferConfigShrink: 'string',
      id: 'string',
      incrTransferConfigShrink: 'string',
      labelIdsShrink: 'string',
      name: 'string',
      ossKey: 'string',
      reverseIncrTransferConfigShrink: 'string',
      sinkEndpointId: 'string',
      sourceEndpointId: 'string',
      structTransferConfigShrink: 'string',
      transferMappingShrink: 'string',
      type: 'string',
      useOss: 'boolean',
      workerGradeId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectResponseBody extends $dara.Model {
  /**
   * @example
   * Contact the administrator.
   */
  advice?: string;
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  /**
   * @example
   * 27
   */
  cost?: string;
  /**
   * @example
   * np_****
   */
  data?: string;
  errorDetail?: CreateProjectResponseBodyErrorDetail;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * XCVSADG****DSGDS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 100
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      cost: 'Cost',
      data: 'Data',
      errorDetail: 'ErrorDetail',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      cost: 'string',
      data: 'string',
      errorDetail: CreateProjectResponseBodyErrorDetail,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  validate() {
    if(this.errorDetail && typeof (this.errorDetail as any).validate === 'function') {
      (this.errorDetail as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateProjectResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateProjectResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsRequest extends $dara.Model {
  databases?: CreateProjectModifyRecordsRequestDatabases[];
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * np_fe****
   */
  id?: string;
  transferMapping?: CreateProjectModifyRecordsRequestTransferMapping;
  static names(): { [key: string]: string } {
    return {
      databases: 'Databases',
      id: 'Id',
      transferMapping: 'TransferMapping',
    };
  }

  static types(): { [key: string]: any } {
    return {
      databases: { 'type': 'array', 'itemType': CreateProjectModifyRecordsRequestDatabases },
      id: 'string',
      transferMapping: CreateProjectModifyRecordsRequestTransferMapping,
    };
  }

  validate() {
    if(Array.isArray(this.databases)) {
      $dara.Model.validateArray(this.databases);
    }
    if(this.transferMapping && typeof (this.transferMapping as any).validate === 'function') {
      (this.transferMapping as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsShrinkRequest extends $dara.Model {
  databasesShrink?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * np_fe****
   */
  id?: string;
  transferMappingShrink?: string;
  static names(): { [key: string]: string } {
    return {
      databasesShrink: 'Databases',
      id: 'Id',
      transferMappingShrink: 'TransferMapping',
    };
  }

  static types(): { [key: string]: any } {
    return {
      databasesShrink: 'string',
      id: 'string',
      transferMappingShrink: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsResponseBody extends $dara.Model {
  /**
   * @example
   * Contact the administrator.
   */
  advice?: string;
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  /**
   * @example
   * 28
   */
  cost?: string;
  /**
   * @example
   * 4
   */
  data?: number;
  errorDetail?: CreateProjectModifyRecordsResponseBodyErrorDetail;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 100
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      cost: 'Cost',
      data: 'Data',
      errorDetail: 'ErrorDetail',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      cost: 'string',
      data: 'number',
      errorDetail: CreateProjectModifyRecordsResponseBodyErrorDetail,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  validate() {
    if(this.errorDetail && typeof (this.errorDetail as any).validate === 'function') {
      (this.errorDetail as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectModifyRecordsResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateProjectModifyRecordsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateProjectModifyRecordsResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRdsPostgreSQLDataSourceRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * db_name
   */
  databaseName?: string;
  /**
   * @example
   * this is a test database
   */
  description?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * g_abcdefj***
   */
  instanceId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * data_name
   */
  name?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * pass_word
   */
  password?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * user_name
   */
  userName?: string;
  static names(): { [key: string]: string } {
    return {
      databaseName: 'DatabaseName',
      description: 'Description',
      instanceId: 'InstanceId',
      name: 'Name',
      password: 'Password',
      userName: 'UserName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      databaseName: 'string',
      description: 'string',
      instanceId: 'string',
      name: 'string',
      password: 'string',
      userName: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRdsPostgreSQLDataSourceResponseBody extends $dara.Model {
  /**
   * @example
   * Contact the administrator.
   */
  advice?: string;
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  /**
   * @example
   * 30
   */
  cost?: string;
  /**
   * @example
   * e_5anwndq
   */
  data?: string;
  errorDetail?: CreateRdsPostgreSQLDataSourceResponseBodyErrorDetail;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 100
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      cost: 'Cost',
      data: 'Data',
      errorDetail: 'ErrorDetail',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      cost: 'string',
      data: 'string',
      errorDetail: CreateRdsPostgreSQLDataSourceResponseBodyErrorDetail,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  validate() {
    if(this.errorDetail && typeof (this.errorDetail as any).validate === 'function') {
      (this.errorDetail as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRdsPostgreSQLDataSourceResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateRdsPostgreSQLDataSourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateRdsPostgreSQLDataSourceResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSecurityIpGroupRequest extends $dara.Model {
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The name of the whitelist group.
   * 
   * This parameter is required.
   * 
   * @example
   * pay_online
   */
  securityIpGroupName?: string;
  /**
   * @remarks
   * The return result of the request.
   * 
   * This parameter is required.
   * 
   * @example
   * {"192.168.1.1","192.168.0.0.1/8"}
   */
  securityIps?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      securityIpGroupName: 'SecurityIpGroupName',
      securityIps: 'SecurityIps',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      securityIpGroupName: 'string',
      securityIps: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSecurityIpGroupResponseBody extends $dara.Model {
  /**
   * @remarks
   * The IP addresses or CIDR blocks in the IP address whitelist group.   
   * The return values of SecurityIps are strings that are separated with commas (,).
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @remarks
   * The operation that you want to perform.   
   * Set the value to **CreateSecurityIpGroup**.
   */
  securityIpGroup?: CreateSecurityIpGroupResponseBodySecurityIpGroup;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      securityIpGroup: 'SecurityIpGroup',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      securityIpGroup: CreateSecurityIpGroupResponseBodySecurityIpGroup,
    };
  }

  validate() {
    if(this.securityIpGroup && typeof (this.securityIpGroup as any).validate === 'function') {
      (this.securityIpGroup as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSecurityIpGroupResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateSecurityIpGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateSecurityIpGroupResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTagRequest extends $dara.Model {
  /**
   * @remarks
   * The identifier of the client.
   * 
   * @example
   * 123e4567-e89b-12d3-a456-426655440000
   */
  clientToken?: string;
  /**
   * @remarks
   * The name of the tag group.
   * 
   * This parameter is required.
   * 
   * @example
   * Tag group 1
   */
  key?: string;
  static names(): { [key: string]: string } {
    return {
      clientToken: 'ClientToken',
      key: 'Key',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clientToken: 'string',
      key: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTagResponseBody extends $dara.Model {
  /**
   * @remarks
   * The tag group creation result.
   * 
   * @example
   * Create tag success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 4C91F7BA-xxxx-xxxx-xxxx-846ECA1A9908
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      message: 'string',
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTagResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateTagResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateTagResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTagValueRequest extends $dara.Model {
  /**
   * @remarks
   * The identifier of the client.
   * 
   * @example
   * 123e4567-e89b-12d3-a456-426655440000
   */
  clientToken?: string;
  /**
   * @remarks
   * The name of the tag group.
   * 
   * This parameter is required.
   * 
   * @example
   * Tag group 1
   */
  key?: string;
  /**
   * @remarks
   * The name of the tag.
   * 
   * This parameter is required.
   * 
   * @example
   * Tag 1
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      clientToken: 'ClientToken',
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clientToken: 'string',
      key: 'string',
      value: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTagValueResponseBody extends $dara.Model {
  /**
   * @remarks
   * The tag creation result.
   * 
   * @example
   * create tag value success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 4C91F7BA-xxxx-xxxx-xxxx-846ECA1A9908
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      message: 'string',
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTagValueResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateTagValueResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateTagValueResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTenantRequest extends $dara.Model {
  /**
   * @remarks
   * The character set.    
   * For more information, see [DescribeCharset](https://www.alibabacloud.com/help/en/apsaradb-for-oceanbase/latest/api-oceanbasepro-2019-09-01-describecharset).
   * 
   * This parameter is required.
   * 
   * @example
   * utf8mb4
   */
  charset?: string;
  /**
   * @remarks
   * The number of CPU cores of the tenant.   
   * 
   * > <br>The CPU specification of a single tenant cannot exceed that of the corresponding cluster. <br>For example, if the specification of the cluster is 14 CPU cores and 70 GB of memory, the CPU specification of the tenant cannot exceed 14 cores.
   * 
   * This parameter is required.
   * 
   * @example
   * 2
   */
  cpu?: number;
  /**
   * @remarks
   * The initialization parameters.
   */
  createParams?: { [key: string]: string };
  /**
   * @remarks
   * The description of the database.
   * 
   * @example
   * this is a test database
   */
  description?: string;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The size of the log disk allocated to the tenant, in GB.
   * 
   * @example
   * 128
   */
  logDisk?: number;
  /**
   * @remarks
   * The memory size of the tenant, in GB.   
   * 
   * > <br>The memory size of a single tenant cannot exceed that of the corresponding cluster. <br>For example, if the specification of the cluster is 14 CPU cores and 70 GB of memory, the memory size of the tenant cannot exceed 70 GB.
   * 
   * This parameter is required.
   * 
   * @example
   * 10
   */
  memory?: number;
  /**
   * @remarks
   * The primary zone of the tenant.    
   * It is one of the zones in which the cluster is deployed.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou-h
   */
  primaryZone?: string;
  /**
   * @remarks
   * Specifies to create a read-only zone. Separate the names of multiple zones with commas (,).
   * >Notice: <br>At present, this parameter is unavailable.
   * 
   * @example
   * cn-shanghai-g-ro,cn-shanghai-h-ro
   */
  readOnlyZoneList?: string;
  /**
   * @remarks
   * The tenant mode.    
   * Valid values: Oracle and MySQL.   
   * For more information, see [DescribeInstanceTenantModes](https://www.alibabacloud.com/help/en/apsaradb-for-oceanbase/latest/api-oceanbasepro-2019-09-01-describeinstancetenantmodes).
   * 
   * This parameter is required.
   * 
   * @example
   * Oracle
   */
  tenantMode?: string;
  /**
   * @remarks
   * The name of the tenant.    
   * It must start with a letter or an underscore (_), and contain 2 to 20 characters, which can be uppercase letters, lowercase letters, digits, and underscores (_).  It cannot be set to sys.
   * 
   * This parameter is required.
   * 
   * @example
   * pay_online
   */
  tenantName?: string;
  /**
   * @remarks
   * The time zone of the tenant. For more information, see [DescribeTimeZones](https://www.alibabacloud.com/help/en/apsaradb-for-oceanbase/latest/api-oceanbasepro-2019-09-01-describetimezones).
   * 
   * This parameter is required.
   * 
   * @example
   * Asia/Shanghai
   */
  timeZone?: string;
  /**
   * @remarks
   * The number of resource distribution nodes in the tenant.    
   * The number is determined by the deployment mode of the cluster. If the cluster is deployed in 2-2-2 mode, the maximum number of resource distribution nodes is 2.
   * 
   * @example
   * 2
   */
  unitNum?: number;
  /**
   * @remarks
   * The ID of the vSwitch.    
   * If no suitable vSwitch is available, create a vSwitch as prompted.   
   * For more information, see Use a vSwitch.
   * 
   * This parameter is required.
   * 
   * @example
   * vsw-bp11k1aypnzu1l3whi****
   */
  userVSwitchId?: string;
  /**
   * @remarks
   * The ID of the VPC.   
   *  If no suitable VPC is available, create a VPC as prompted.   
   * For more information, see "What is a VPC".
   * 
   * This parameter is required.
   * 
   * @example
   * vpc-bp1d2q3mhg9i23ofi****
   */
  userVpcId?: string;
  /**
   * @remarks
   * The ID of the VPC owner.
   * 
   * @example
   * vpc-********
   */
  userVpcOwnerId?: string;
  static names(): { [key: string]: string } {
    return {
      charset: 'Charset',
      cpu: 'Cpu',
      createParams: 'CreateParams',
      description: 'Description',
      instanceId: 'InstanceId',
      logDisk: 'LogDisk',
      memory: 'Memory',
      primaryZone: 'PrimaryZone',
      readOnlyZoneList: 'ReadOnlyZoneList',
      tenantMode: 'TenantMode',
      tenantName: 'TenantName',
      timeZone: 'TimeZone',
      unitNum: 'UnitNum',
      userVSwitchId: 'UserVSwitchId',
      userVpcId: 'UserVpcId',
      userVpcOwnerId: 'UserVpcOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      charset: 'string',
      cpu: 'number',
      createParams: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      description: 'string',
      instanceId: 'string',
      logDisk: 'number',
      memory: 'number',
      primaryZone: 'string',
      readOnlyZoneList: 'string',
      tenantMode: 'string',
      tenantName: 'string',
      timeZone: 'string',
      unitNum: 'number',
      userVSwitchId: 'string',
      userVpcId: 'string',
      userVpcOwnerId: 'string',
    };
  }

  validate() {
    if(this.createParams) {
      $dara.Model.validateMap(this.createParams);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTenantShrinkRequest extends $dara.Model {
  /**
   * @remarks
   * The character set.    
   * For more information, see [DescribeCharset](https://www.alibabacloud.com/help/en/apsaradb-for-oceanbase/latest/api-oceanbasepro-2019-09-01-describecharset).
   * 
   * This parameter is required.
   * 
   * @example
   * utf8mb4
   */
  charset?: string;
  /**
   * @remarks
   * The number of CPU cores of the tenant.   
   * 
   * > <br>The CPU specification of a single tenant cannot exceed that of the corresponding cluster. <br>For example, if the specification of the cluster is 14 CPU cores and 70 GB of memory, the CPU specification of the tenant cannot exceed 14 cores.
   * 
   * This parameter is required.
   * 
   * @example
   * 2
   */
  cpu?: number;
  /**
   * @remarks
   * The initialization parameters.
   */
  createParamsShrink?: string;
  /**
   * @remarks
   * The description of the database.
   * 
   * @example
   * this is a test database
   */
  description?: string;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The size of the log disk allocated to the tenant, in GB.
   * 
   * @example
   * 128
   */
  logDisk?: number;
  /**
   * @remarks
   * The memory size of the tenant, in GB.   
   * 
   * > <br>The memory size of a single tenant cannot exceed that of the corresponding cluster. <br>For example, if the specification of the cluster is 14 CPU cores and 70 GB of memory, the memory size of the tenant cannot exceed 70 GB.
   * 
   * This parameter is required.
   * 
   * @example
   * 10
   */
  memory?: number;
  /**
   * @remarks
   * The primary zone of the tenant.    
   * It is one of the zones in which the cluster is deployed.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou-h
   */
  primaryZone?: string;
  /**
   * @remarks
   * Specifies to create a read-only zone. Separate the names of multiple zones with commas (,).
   * >Notice: <br>At present, this parameter is unavailable.
   * 
   * @example
   * cn-shanghai-g-ro,cn-shanghai-h-ro
   */
  readOnlyZoneList?: string;
  /**
   * @remarks
   * The tenant mode.    
   * Valid values: Oracle and MySQL.   
   * For more information, see [DescribeInstanceTenantModes](https://www.alibabacloud.com/help/en/apsaradb-for-oceanbase/latest/api-oceanbasepro-2019-09-01-describeinstancetenantmodes).
   * 
   * This parameter is required.
   * 
   * @example
   * Oracle
   */
  tenantMode?: string;
  /**
   * @remarks
   * The name of the tenant.    
   * It must start with a letter or an underscore (_), and contain 2 to 20 characters, which can be uppercase letters, lowercase letters, digits, and underscores (_).  It cannot be set to sys.
   * 
   * This parameter is required.
   * 
   * @example
   * pay_online
   */
  tenantName?: string;
  /**
   * @remarks
   * The time zone of the tenant. For more information, see [DescribeTimeZones](https://www.alibabacloud.com/help/en/apsaradb-for-oceanbase/latest/api-oceanbasepro-2019-09-01-describetimezones).
   * 
   * This parameter is required.
   * 
   * @example
   * Asia/Shanghai
   */
  timeZone?: string;
  /**
   * @remarks
   * The number of resource distribution nodes in the tenant.    
   * The number is determined by the deployment mode of the cluster. If the cluster is deployed in 2-2-2 mode, the maximum number of resource distribution nodes is 2.
   * 
   * @example
   * 2
   */
  unitNum?: number;
  /**
   * @remarks
   * The ID of the vSwitch.    
   * If no suitable vSwitch is available, create a vSwitch as prompted.   
   * For more information, see Use a vSwitch.
   * 
   * This parameter is required.
   * 
   * @example
   * vsw-bp11k1aypnzu1l3whi****
   */
  userVSwitchId?: string;
  /**
   * @remarks
   * The ID of the VPC.   
   *  If no suitable VPC is available, create a VPC as prompted.   
   * For more information, see "What is a VPC".
   * 
   * This parameter is required.
   * 
   * @example
   * vpc-bp1d2q3mhg9i23ofi****
   */
  userVpcId?: string;
  /**
   * @remarks
   * The ID of the VPC owner.
   * 
   * @example
   * vpc-********
   */
  userVpcOwnerId?: string;
  static names(): { [key: string]: string } {
    return {
      charset: 'Charset',
      cpu: 'Cpu',
      createParamsShrink: 'CreateParams',
      description: 'Description',
      instanceId: 'InstanceId',
      logDisk: 'LogDisk',
      memory: 'Memory',
      primaryZone: 'PrimaryZone',
      readOnlyZoneList: 'ReadOnlyZoneList',
      tenantMode: 'TenantMode',
      tenantName: 'TenantName',
      timeZone: 'TimeZone',
      unitNum: 'UnitNum',
      userVSwitchId: 'UserVSwitchId',
      userVpcId: 'UserVpcId',
      userVpcOwnerId: 'UserVpcOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      charset: 'string',
      cpu: 'number',
      createParamsShrink: 'string',
      description: 'string',
      instanceId: 'string',
      logDisk: 'number',
      memory: 'number',
      primaryZone: 'string',
      readOnlyZoneList: 'string',
      tenantMode: 'string',
      tenantName: 'string',
      timeZone: 'string',
      unitNum: 'number',
      userVSwitchId: 'string',
      userVpcId: 'string',
      userVpcOwnerId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTenantResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * @example
   * t33h8y08k****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      tenantId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTenantResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateTenantResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateTenantResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTenantReadOnlyConnectionRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * ob2mr3oae0****
   */
  tenantId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * vsw-bp11k1aypnzu1l3whi****
   */
  vSwitchId?: string;
  /**
   * @example
   * vpc-bp1d2q3mhg9i23ofi****
   */
  vpcId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou-i
   */
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      tenantId: 'TenantId',
      vSwitchId: 'VSwitchId',
      vpcId: 'VpcId',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      tenantId: 'string',
      vSwitchId: 'string',
      vpcId: 'string',
      zoneId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTenantReadOnlyConnectionResponseBody extends $dara.Model {
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTenantReadOnlyConnectionResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateTenantReadOnlyConnectionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateTenantReadOnlyConnectionResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTenantSecurityIpGroupRequest extends $dara.Model {
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The group name of the whitelist group of IP addresses.
   * 
   * It starts with lowercase letters and ends with lowercase letters or numbers. It can only contain lowercase letters, numbers, and underscores, and should be 2~32 characters in length.
   * 
   * This parameter is required.
   * 
   * @example
   * paytest
   */
  securityIpGroupName?: string;
  /**
   * @remarks
   * The list of IP addresses in the whitelist group.
   * 
   * It is a JSON array. Each object in the array is an IP address or a CIDR block. You can have up to 40 whitelists.
   * 
   * This parameter is required.
   * 
   * @example
   * 192.***.*.*"
   */
  securityIps?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * t4louaeei****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      securityIpGroupName: 'SecurityIpGroupName',
      securityIps: 'SecurityIps',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      securityIpGroupName: 'string',
      securityIps: 'string',
      tenantId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTenantSecurityIpGroupResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @remarks
   * The information of the whitelist group.
   */
  securityIpGroup?: CreateTenantSecurityIpGroupResponseBodySecurityIpGroup;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      securityIpGroup: 'SecurityIpGroup',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      securityIpGroup: CreateTenantSecurityIpGroupResponseBodySecurityIpGroup,
    };
  }

  validate() {
    if(this.securityIpGroup && typeof (this.securityIpGroup as any).validate === 'function') {
      (this.securityIpGroup as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTenantSecurityIpGroupResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateTenantSecurityIpGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateTenantSecurityIpGroupResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTenantUserRequest extends $dara.Model {
  /**
   * @remarks
   * The description of the database.
   * 
   * @example
   * this is a test database
   */
  description?: string;
  /**
   * @remarks
   * 加密方式。
   * 
   * @example
   * RAS
   */
  encryptionType?: string;
  /**
   * @example
   * Encrypt,Decrypt
   */
  globalPermissions?: string;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The role of the user account.  In Oracle mode, this parameter unspecified is left unspecified.  In MySQL mode, the super administrator account has ALL PRIVILEGES, and you can leave this parameter unspecified.  You need to specify the account information for a general user account. By default, the account information is a JSON array that contains the information of the role and the schema (Oracle mode) or database (MySQL mode).  Valid values: ReadWrite: a role that has the read and write privileges, namely ALL PRIVILEGES. ReadOnly: a role that has only the read-only privilege SELECT. DDL: a role that has DDL privileges such as CREATE, DROP, ALTER, SHOW VIEW, and CREATE VIEW. DML: a role that has DML privileges such as SELECT, INSERT, UPDATE, DELETE, and SHOW VIEW.
   * 
   * @example
   * [{"Database":"oceanbase1","Role":"readwrite"},{"Database":"oceanbase2","Role":"readonly"}]
   */
  roles?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * ob2mr3oae0****
   */
  tenantId?: string;
  /**
   * @remarks
   * The name of the database account.  You cannot use reserved keywords, such as SYS and root.
   * 
   * This parameter is required.
   * 
   * @example
   * pay_test
   */
  userName?: string;
  /**
   * @remarks
   * The password of the database account.  It must be 10 to 32 characters in length and contain three types of the following characters: uppercase letters, lowercase letters, digits, and special characters. The special characters are ! @ # $ % \\ ^ \\ & \\ * ( ) _ + - =
   * 
   * This parameter is required.
   * 
   * @example
   * !Aliyun4Oceanbase
   */
  userPassword?: string;
  /**
   * @remarks
   * The type of the database account. Valid values: Admin: the super administrator account. Normal: a general account.
   * 
   * This parameter is required.
   * 
   * @example
   * Normal
   */
  userType?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      encryptionType: 'EncryptionType',
      globalPermissions: 'GlobalPermissions',
      instanceId: 'InstanceId',
      roles: 'Roles',
      tenantId: 'TenantId',
      userName: 'UserName',
      userPassword: 'UserPassword',
      userType: 'UserType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      encryptionType: 'string',
      globalPermissions: 'string',
      instanceId: 'string',
      roles: 'string',
      tenantId: 'string',
      userName: 'string',
      userPassword: 'string',
      userType: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTenantUserResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @remarks
   * The list of database accounts in the tenant.
   */
  tenantUser?: CreateTenantUserResponseBodyTenantUser;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      tenantUser: 'TenantUser',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      tenantUser: CreateTenantUserResponseBodyTenantUser,
    };
  }

  validate() {
    if(this.tenantUser && typeof (this.tenantUser as any).validate === 'function') {
      (this.tenantUser as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTenantUserResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateTenantUserResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateTenantUserResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDataSourceRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * e_5anwndq
   */
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDataSourceResponseBody extends $dara.Model {
  /**
   * @example
   * Contact the administrator.
   */
  advice?: string;
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  /**
   * @example
   * 28
   */
  cost?: string;
  /**
   * @example
   * null
   */
  data?: any;
  errorDetail?: DeleteDataSourceResponseBodyErrorDetail;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * E3D924FB-52****B253-0C1A7EFB778C
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 100
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      cost: 'Cost',
      data: 'Data',
      errorDetail: 'ErrorDetail',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      cost: 'string',
      data: 'any',
      errorDetail: DeleteDataSourceResponseBodyErrorDetail,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  validate() {
    if(this.errorDetail && typeof (this.errorDetail as any).validate === 'function') {
      (this.errorDetail as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDataSourceResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteDataSourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteDataSourceResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDatabasesRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * ["sms_pre", "pay_pre"]
   */
  databaseNames?: string;
  /**
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * ob2mr3oae0****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      databaseNames: 'DatabaseNames',
      instanceId: 'InstanceId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      databaseNames: 'string',
      instanceId: 'string',
      tenantId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDatabasesResponseBody extends $dara.Model {
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDatabasesResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteDatabasesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteDatabasesResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteInstancesRequest extends $dara.Model {
  /**
   * @remarks
   * The backup retention strategy for cluster deletion. Valid values:  
   * - receive_all: retains all backup sets.   
   * - delete_all: deletes all backup sets.   
   * - receive_last: retains the last backup set.    
   * 
   * > <br>Default value: delete_all.
   * 
   * @example
   * delete_all
   */
  backupRetainMode?: string;
  /**
   * @remarks
   * Specifies whether to perform only a dry run for the request. Default value: false. Valid values:
   * - true: Only a dry-run request is sent and the instance is not deleted. If the dry run succeeds, DryRunResult=true is returned. If the dry run fails, an error code is returned.
   * - false: The actual request is sent and no dry run is performed. The instance is deleted if the requirements are met. By default, false is returned for the parameter DryRunResult if you set DryRun to false.
   * 
   * @example
   * false
   */
  dryRun?: boolean;
  /**
   * @remarks
   * The ID of the cluster to be deleted.   
   * The value is a string in the JSON format.
   * 
   * This parameter is required.
   * 
   * @example
   * [”ob ob3f6yhv9uxxxx“]
   */
  instanceIds?: string;
  static names(): { [key: string]: string } {
    return {
      backupRetainMode: 'BackupRetainMode',
      dryRun: 'DryRun',
      instanceIds: 'InstanceIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      backupRetainMode: 'string',
      dryRun: 'boolean',
      instanceIds: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteInstancesResponseBody extends $dara.Model {
  /**
   * @remarks
   * The returned data.
   */
  data?: DeleteInstancesResponseBodyData;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 473469C7-****-****-B3DB-A3DC0DE3C83E
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: DeleteInstancesResponseBodyData,
      requestId: 'string',
    };
  }

  validate() {
    if(this.data && typeof (this.data as any).validate === 'function') {
      (this.data as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteInstancesResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteInstancesResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProjectRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * np_4w3a****
   */
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProjectResponseBody extends $dara.Model {
  /**
   * @example
   * Contact the administrator.
   */
  advice?: string;
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  /**
   * @example
   * 1
   */
  cost?: string;
  /**
   * @example
   * null
   */
  data?: any;
  errorDetail?: DeleteProjectResponseBodyErrorDetail;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * 473469C7-XXXX-XXX-B3DB-A3DC0DE
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 24
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      cost: 'Cost',
      data: 'Data',
      errorDetail: 'ErrorDetail',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      cost: 'string',
      data: 'any',
      errorDetail: DeleteProjectResponseBodyErrorDetail,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  validate() {
    if(this.errorDetail && typeof (this.errorDetail as any).validate === 'function') {
      (this.errorDetail as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProjectResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteProjectResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteProjectResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSecurityIpGroupRequest extends $dara.Model {
  /**
   * @remarks
   * The name of the IP address whitelist group.    
   * It must be 2 to 32 characters in length, start with a lowercase letter, end with a lowercase letter or digit, and contain only lowercase letters, digits, and underscores (_).
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The information of the deleted IP whitelist group.
   * 
   * This parameter is required.
   * 
   * @example
   * paytest
   */
  securityIpGroupName?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      securityIpGroupName: 'SecurityIpGroupName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      securityIpGroupName: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSecurityIpGroupResponseBody extends $dara.Model {
  /**
   * @remarks
   * Example 1
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  securityIpGroup?: DeleteSecurityIpGroupResponseBodySecurityIpGroup;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      securityIpGroup: 'SecurityIpGroup',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      securityIpGroup: DeleteSecurityIpGroupResponseBodySecurityIpGroup,
    };
  }

  validate() {
    if(this.securityIpGroup && typeof (this.securityIpGroup as any).validate === 'function') {
      (this.securityIpGroup as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSecurityIpGroupResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteSecurityIpGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteSecurityIpGroupResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTagRequest extends $dara.Model {
  /**
   * @remarks
   * The name of the tag group.
   * 
   * This parameter is required.
   * 
   * @example
   * Tag group 2
   */
  key?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTagResponseBody extends $dara.Model {
  /**
   * @remarks
   * The tag group deletion result.
   * 
   * @example
   * delete tag success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 4C91F7BA-xxxx-xxxx-xxxx-846ECA1A9908
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      message: 'string',
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTagResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteTagResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteTagResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTagValueRequest extends $dara.Model {
  /**
   * @remarks
   * The name of the tag group.
   * 
   * This parameter is required.
   * 
   * @example
   * Tag group 1
   */
  key?: string;
  /**
   * @remarks
   * The name of the tag.
   * 
   * This parameter is required.
   * 
   * @example
   * Tag 2
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTagValueResponseBody extends $dara.Model {
  /**
   * @remarks
   * The tag deletion result.
   * 
   * @example
   * delete tag-value success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 4C91F7BA-xxxx-xxxx-xxxx-846ECA1A9908
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      message: 'string',
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTagValueResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteTagValueResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteTagValueResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTenantSecurityIpGroupRequest extends $dara.Model {
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The group name of the whitelist group of IP addresses.
   * 
   * It starts with lowercase letters and ends with lowercase letters or numbers. It can only contain lowercase letters, numbers, and underscores, and should be 2~32 characters in length.
   * 
   * This parameter is required.
   * 
   * @example
   * paytest
   */
  securityIpGroupName?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * t4louaeei****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      securityIpGroupName: 'SecurityIpGroupName',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      securityIpGroupName: 'string',
      tenantId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTenantSecurityIpGroupResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @remarks
   * The information of the whitelist group.
   */
  securityIpGroup?: DeleteTenantSecurityIpGroupResponseBodySecurityIpGroup;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      securityIpGroup: 'SecurityIpGroup',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      securityIpGroup: DeleteTenantSecurityIpGroupResponseBodySecurityIpGroup,
    };
  }

  validate() {
    if(this.securityIpGroup && typeof (this.securityIpGroup as any).validate === 'function') {
      (this.securityIpGroup as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTenantSecurityIpGroupResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteTenantSecurityIpGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteTenantSecurityIpGroupResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTenantUsersRequest extends $dara.Model {
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * ob2mr3oae0****
   */
  tenantId?: string;
  /**
   * @remarks
   * A list of usernames.
   * 
   * This parameter is required.
   * 
   * @example
   * ["testUser"]
   */
  users?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      tenantId: 'TenantId',
      users: 'Users',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      tenantId: 'string',
      users: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTenantUsersResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTenantUsersResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteTenantUsersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteTenantUsersResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTenantsRequest extends $dara.Model {
  /**
   * @remarks
   * You can call this operation to delete one or more tenants from an OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * ```
   * http(s)://[Endpoint]/?Action=DeleteTenants
   * &TenantIds=["ob2mr3oae0****", "ob2mr3oae1****"]
   * &InstanceId=ob317v4uif****
   * &Common request parameters
   * ```
   * 
   * This parameter is required.
   * 
   * @example
   * ["ob2mr3oae0****", "ob2mr3oae1****"]
   */
  tenantIds?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      tenantIds: 'TenantIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      tenantIds: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTenantsResponseBody extends $dara.Model {
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  tenantIds?: string[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      tenantIds: 'TenantIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      tenantIds: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(Array.isArray(this.tenantIds)) {
      $dara.Model.validateArray(this.tenantIds);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTenantsResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteTenantsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteTenantsResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAnomalySQLListRequest extends $dara.Model {
  /**
   * @remarks
   * The language of the returned data.   
   * Default value: CN for a China site and EN for an International site.
   * 
   * @example
   * zh-CN
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * testdb
   */
  dbName?: string;
  /**
   * @remarks
   * The end time of the time range for querying suspicious SQL statements.   
   * The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
   * 
   * This parameter is required.
   * 
   * @example
   * 2021-09-13T15:40:43Z
   */
  endTime?: string;
  /**
   * @remarks
   * The filter condition.   
   * > <br> - All fields in OceanBase Database support filtering. <br> - You can write the key-value pair of a parameter in a JSON string in the JSON format to filter the parameter.
   * 
   * @example
   * {
   *   "UserName":testUser
   * }
   */
  filterCondition?: { [key: string]: any };
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * obsd23j4f****
   */
  instanceId?: string;
  /**
   * @remarks
   * The IP address of the node.
   * 
   * @example
   * i-bp19y05uq6xpacyqnlrc
   */
  nodeIp?: string;
  /**
   * @remarks
   * The number of the page to return.    
   * - Start value: 1   
   * - Default value: 1
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of rows to return on each page.    
   * - Maximum value: 100   
   * - Default value: 10
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * SQLID.
   * 
   * @example
   * 8D6E84****0B8FB1823D199E2CA1****
   */
  SQLId?: string;
  /**
   * @remarks
   * The search keyword.
   * 
   * @example
   * update
   */
  searchKeyWord?: string;
  /**
   * @remarks
   * The search parameter.
   * 
   * @example
   * cputime
   */
  searchParameter?: string;
  /**
   * @remarks
   * The search rule.   
   * Valid values: "=", ">", ">=", "<", and "<="
   * 
   * @example
   * >
   */
  searchRule?: string;
  /**
   * @remarks
   * The search value.
   * 
   * @example
   * 0.01
   */
  searchValue?: string;
  /**
   * @remarks
   * The sorted column.
   * 
   * @example
   * cputime
   */
  sortColumn?: string;
  /**
   * @remarks
   * The sorting rule.
   * 
   * @example
   * desc
   */
  sortOrder?: string;
  /**
   * @remarks
   * The start time of the time range for querying suspicious SQL statements.   
   * The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
   * 
   * This parameter is required.
   * 
   * @example
   * 2021-06-13T15:40:43Z
   */
  startTime?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * t2mr3oae0****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      dbName: 'DbName',
      endTime: 'EndTime',
      filterCondition: 'FilterCondition',
      instanceId: 'InstanceId',
      nodeIp: 'NodeIp',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      SQLId: 'SQLId',
      searchKeyWord: 'SearchKeyWord',
      searchParameter: 'SearchParameter',
      searchRule: 'SearchRule',
      searchValue: 'SearchValue',
      sortColumn: 'SortColumn',
      sortOrder: 'SortOrder',
      startTime: 'StartTime',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      dbName: 'string',
      endTime: 'string',
      filterCondition: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      instanceId: 'string',
      nodeIp: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      SQLId: 'string',
      searchKeyWord: 'string',
      searchParameter: 'string',
      searchRule: 'string',
      searchValue: 'string',
      sortColumn: 'string',
      sortOrder: 'string',
      startTime: 'string',
      tenantId: 'string',
    };
  }

  validate() {
    if(this.filterCondition) {
      $dara.Model.validateMap(this.filterCondition);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAnomalySQLListShrinkRequest extends $dara.Model {
  /**
   * @remarks
   * The language of the returned data.   
   * Default value: CN for a China site and EN for an International site.
   * 
   * @example
   * zh-CN
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * testdb
   */
  dbName?: string;
  /**
   * @remarks
   * The end time of the time range for querying suspicious SQL statements.   
   * The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
   * 
   * This parameter is required.
   * 
   * @example
   * 2021-09-13T15:40:43Z
   */
  endTime?: string;
  /**
   * @remarks
   * The filter condition.   
   * > <br> - All fields in OceanBase Database support filtering. <br> - You can write the key-value pair of a parameter in a JSON string in the JSON format to filter the parameter.
   * 
   * @example
   * {
   *   "UserName":testUser
   * }
   */
  filterConditionShrink?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * obsd23j4f****
   */
  instanceId?: string;
  /**
   * @remarks
   * The IP address of the node.
   * 
   * @example
   * i-bp19y05uq6xpacyqnlrc
   */
  nodeIp?: string;
  /**
   * @remarks
   * The number of the page to return.    
   * - Start value: 1   
   * - Default value: 1
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of rows to return on each page.    
   * - Maximum value: 100   
   * - Default value: 10
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * SQLID.
   * 
   * @example
   * 8D6E84****0B8FB1823D199E2CA1****
   */
  SQLId?: string;
  /**
   * @remarks
   * The search keyword.
   * 
   * @example
   * update
   */
  searchKeyWord?: string;
  /**
   * @remarks
   * The search parameter.
   * 
   * @example
   * cputime
   */
  searchParameter?: string;
  /**
   * @remarks
   * The search rule.   
   * Valid values: "=", ">", ">=", "<", and "<="
   * 
   * @example
   * >
   */
  searchRule?: string;
  /**
   * @remarks
   * The search value.
   * 
   * @example
   * 0.01
   */
  searchValue?: string;
  /**
   * @remarks
   * The sorted column.
   * 
   * @example
   * cputime
   */
  sortColumn?: string;
  /**
   * @remarks
   * The sorting rule.
   * 
   * @example
   * desc
   */
  sortOrder?: string;
  /**
   * @remarks
   * The start time of the time range for querying suspicious SQL statements.   
   * The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
   * 
   * This parameter is required.
   * 
   * @example
   * 2021-06-13T15:40:43Z
   */
  startTime?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * t2mr3oae0****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      dbName: 'DbName',
      endTime: 'EndTime',
      filterConditionShrink: 'FilterCondition',
      instanceId: 'InstanceId',
      nodeIp: 'NodeIp',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      SQLId: 'SQLId',
      searchKeyWord: 'SearchKeyWord',
      searchParameter: 'SearchParameter',
      searchRule: 'SearchRule',
      searchValue: 'SearchValue',
      sortColumn: 'SortColumn',
      sortOrder: 'SortOrder',
      startTime: 'StartTime',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      dbName: 'string',
      endTime: 'string',
      filterConditionShrink: 'string',
      instanceId: 'string',
      nodeIp: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      SQLId: 'string',
      searchKeyWord: 'string',
      searchParameter: 'string',
      searchRule: 'string',
      searchValue: 'string',
      sortColumn: 'string',
      sortOrder: 'string',
      startTime: 'string',
      tenantId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAnomalySQLListResponseBody extends $dara.Model {
  /**
   * @remarks
   * The list of suspicious SQL statements.
   */
  anomalySQLList?: DescribeAnomalySQLListResponseBodyAnomalySQLList[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E
   */
  requestId?: string;
  /**
   * @remarks
   * The total count.
   * 
   * @example
   * 2
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      anomalySQLList: 'AnomalySQLList',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      anomalySQLList: { 'type': 'array', 'itemType': DescribeAnomalySQLListResponseBodyAnomalySQLList },
      requestId: 'string',
      totalCount: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.anomalySQLList)) {
      $dara.Model.validateArray(this.anomalySQLList);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAnomalySQLListResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAnomalySQLListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAnomalySQLListResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAvailableCpuResourceRequest extends $dara.Model {
  /**
   * @remarks
   * The CPU resources available.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * ```
   * http(s)://[Endpoint]/?Action=DescribeAvailableCpuResource
   * &InstanceId=ob317v4uif****
   * &TenantId=ob2mr3oae0****
   * &ModifyType=update
   * &Common request parameters
   * ```
   * 
   * @example
   * update
   */
  modifyType?: string;
  /**
   * @remarks
   * The operation that you want to perform.   
   * Set the value to **DescribeAvailableCpuResource**.
   * 
   * @example
   * ob2mr3oae0****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      modifyType: 'ModifyType',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      modifyType: 'string',
      tenantId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAvailableCpuResourceResponseBody extends $dara.Model {
  data?: DescribeAvailableCpuResourceResponseBodyData[];
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': DescribeAvailableCpuResourceResponseBodyData },
      requestId: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.data)) {
      $dara.Model.validateArray(this.data);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAvailableCpuResourceResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAvailableCpuResourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAvailableCpuResourceResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAvailableMemResourceRequest extends $dara.Model {
  /**
   * @remarks
   * The number of CPU cores.
   * 
   * This parameter is required.
   * 
   * @example
   * 14
   */
  cpuNum?: number;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * @example
   * ob2mr3oae0****
   */
  tenantId?: string;
  /**
   * @remarks
   * The number of resource distribution nodes in the tenant.   
   * The number is determined by the deployment mode of the cluster. If the cluster is deployed in 2-2-2 mode, the maximum number of resource distribution nodes is 2.
   * 
   * This parameter is required.
   * 
   * @example
   * 2
   */
  unitNum?: number;
  static names(): { [key: string]: string } {
    return {
      cpuNum: 'CpuNum',
      instanceId: 'InstanceId',
      tenantId: 'TenantId',
      unitNum: 'UnitNum',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cpuNum: 'number',
      instanceId: 'string',
      tenantId: 'string',
      unitNum: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAvailableMemResourceResponseBody extends $dara.Model {
  /**
   * @remarks
   * The available memory size.
   */
  data?: DescribeAvailableMemResourceResponseBodyData;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: DescribeAvailableMemResourceResponseBodyData,
      requestId: 'string',
    };
  }

  validate() {
    if(this.data && typeof (this.data as any).validate === 'function') {
      (this.data as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAvailableMemResourceResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAvailableMemResourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAvailableMemResourceResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAvailableSpecRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @example
   * oceanbase.cluster.cd8.xlarge
   */
  spec?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * upgradespec
   */
  upgradeType?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      spec: 'Spec',
      upgradeType: 'UpgradeType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      spec: 'string',
      upgradeType: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAvailableSpecResponseBody extends $dara.Model {
  data?: DescribeAvailableSpecResponseBodyData;
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: DescribeAvailableSpecResponseBodyData,
      requestId: 'string',
    };
  }

  validate() {
    if(this.data && typeof (this.data as any).validate === 'function') {
      (this.data as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAvailableSpecResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAvailableSpecResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAvailableSpecResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAvailableZoneRequest extends $dara.Model {
  /**
   * @example
   * x86
   */
  cpuArch?: string;
  /**
   * @example
   * multiple
   */
  deployType?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * cluster
   */
  instanceType?: string;
  /**
   * @example
   * 3.2.4.4
   */
  obVersion?: string;
  /**
   * @example
   * normal
   */
  series?: string;
  /**
   * @example
   * oceanbase.cluster.cd8.xlarge
   */
  spec?: string;
  static names(): { [key: string]: string } {
    return {
      cpuArch: 'CpuArch',
      deployType: 'DeployType',
      instanceType: 'InstanceType',
      obVersion: 'ObVersion',
      series: 'Series',
      spec: 'Spec',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cpuArch: 'string',
      deployType: 'string',
      instanceType: 'string',
      obVersion: 'string',
      series: 'string',
      spec: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAvailableZoneResponseBody extends $dara.Model {
  data?: DescribeAvailableZoneResponseBodyData;
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: DescribeAvailableZoneResponseBodyData,
      requestId: 'string',
    };
  }

  validate() {
    if(this.data && typeof (this.data as any).validate === 'function') {
      (this.data as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAvailableZoneResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAvailableZoneResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAvailableZoneResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackupEncryptedStringRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * ob4wibn0abo9uo
   */
  instanceId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * txxxxxxx
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      tenantId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackupEncryptedStringResponseBody extends $dara.Model {
  data?: DescribeBackupEncryptedStringResponseBodyData;
  /**
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: DescribeBackupEncryptedStringResponseBodyData,
      requestId: 'string',
    };
  }

  validate() {
    if(this.data && typeof (this.data as any).validate === 'function') {
      (this.data as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackupEncryptedStringResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeBackupEncryptedStringResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeBackupEncryptedStringResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackupSetDownloadLinkRequest extends $dara.Model {
  /**
   * @remarks
   * The ID of the download task corresponding to the target backup set.
   * 
   * This parameter is required.
   * 
   * @example
   * 1000002
   */
  downloadTaskId?: string;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      downloadTaskId: 'DownloadTaskId',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      downloadTaskId: 'string',
      instanceId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackupSetDownloadLinkResponseBody extends $dara.Model {
  /**
   * @remarks
   * The returned data.
   */
  data?: DescribeBackupSetDownloadLinkResponseBodyData;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: DescribeBackupSetDownloadLinkResponseBodyData,
      requestId: 'string',
    };
  }

  validate() {
    if(this.data && typeof (this.data as any).validate === 'function') {
      (this.data as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackupSetDownloadLinkResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeBackupSetDownloadLinkResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeBackupSetDownloadLinkResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCharsetRequest extends $dara.Model {
  instanceId?: string;
  /**
   * @remarks
   * 实例的系列  - normal（默认）：标准集群版（云盘）  - normal_ssd：标准集群版（本地盘） - history：历史库集群版。
   * 
   * @example
   * normal
   */
  series?: string;
  /**
   * @remarks
   * The return result of the request.
   * 
   * This parameter is required.
   * 
   * @example
   * Oracle
   */
  tenantMode?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      series: 'Series',
      tenantMode: 'TenantMode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      series: 'string',
      tenantMode: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCharsetResponseBody extends $dara.Model {
  /**
   * @remarks
   * ```
   * http(s)://[Endpoint]/?Action=DescribeCharset
   * &TenantMode=Oracle
   * &Common request parameters
   * ```
   */
  charset?: DescribeCharsetResponseBodyCharset[];
  /**
   * @remarks
   * The operation that you want to perform.   
   * Set the value to **DescribeCharset**.
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      charset: 'Charset',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      charset: { 'type': 'array', 'itemType': DescribeCharsetResponseBodyCharset },
      requestId: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.charset)) {
      $dara.Model.validateArray(this.charset);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCharsetResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeCharsetResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeCharsetResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDataBackupSetRequest extends $dara.Model {
  /**
   * @example
   * tenant
   */
  backupObjectType?: string;
  /**
   * @example
   * 2023-01-06T15:59:59Z
   */
  endTime?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * 2022-12-27T16:00:00Z
   */
  startTime?: string;
  /**
   * @example
   * DONE
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      backupObjectType: 'BackupObjectType',
      endTime: 'EndTime',
      instanceId: 'InstanceId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      startTime: 'StartTime',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      backupObjectType: 'string',
      endTime: 'string',
      instanceId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      startTime: 'string',
      status: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDataBackupSetResponseBody extends $dara.Model {
  data?: DescribeDataBackupSetResponseBodyData[];
  /**
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @example
   * 2
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': DescribeDataBackupSetResponseBodyData },
      requestId: 'string',
      totalCount: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.data)) {
      $dara.Model.validateArray(this.data);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDataBackupSetResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDataBackupSetResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDataBackupSetResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDatabasesRequest extends $dara.Model {
  /**
   * @remarks
   * The name of the database.    
   * You cannot use reserved keywords, such as test and mysql.
   * 
   * @example
   * sms_pre
   */
  databaseName?: string;
  /**
   * @remarks
   * The ID of the cluster.
   * 
   * @example
   * ob****n0abo9uo
   */
  instanceId?: string;
  /**
   * @remarks
   * The number of the page returned.  
   * - Start value: 1   
   * - Default value: 1
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of rows returned on each page.  
   * - Maximum value: 100.  
   * - Default value: 10
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The search keyword.
   * 
   * @example
   * pay
   */
  searchKey?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * @example
   * ob2mr3oae0****
   */
  tenantId?: string;
  /**
   * @remarks
   * Specifies whether to return the information about tables in the database.
   * Default value: false. 
   * > The operation may time out if the database contains a large number of tables.
   * 
   * @example
   * true
   */
  withTables?: boolean;
  static names(): { [key: string]: string } {
    return {
      databaseName: 'DatabaseName',
      instanceId: 'InstanceId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      searchKey: 'SearchKey',
      tenantId: 'TenantId',
      withTables: 'WithTables',
    };
  }

  static types(): { [key: string]: any } {
    return {
      databaseName: 'string',
      instanceId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      searchKey: 'string',
      tenantId: 'string',
      withTables: 'boolean',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDatabasesResponseBody extends $dara.Model {
  /**
   * @remarks
   * The list of databases in the tenant.
   */
  databases?: DescribeDatabasesResponseBodyDatabases[];
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of databases in the tenant.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      databases: 'Databases',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      databases: { 'type': 'array', 'itemType': DescribeDatabasesResponseBodyDatabases },
      requestId: 'string',
      totalCount: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.databases)) {
      $dara.Model.validateArray(this.databases);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDatabasesResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDatabasesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDatabasesResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceRequest extends $dara.Model {
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The number of the page to return.
   * - Pages start from page 1.
   * - Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      pageNumber: 'PageNumber',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      pageNumber: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceResponseBody extends $dara.Model {
  /**
   * @remarks
   * The information of the OceanBase cluster.
   */
  instance?: DescribeInstanceResponseBodyInstance;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      instance: 'Instance',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instance: DescribeInstanceResponseBodyInstance,
      requestId: 'string',
    };
  }

  validate() {
    if(this.instance && typeof (this.instance as any).validate === 'function') {
      (this.instance as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeInstanceResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceCreatableZoneRequest extends $dara.Model {
  /**
   * @remarks
   * The ID of the zone.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceCreatableZoneResponseBody extends $dara.Model {
  /**
   * @remarks
   * Indicates whether the cluster is deployed in the zone.
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @remarks
   * The operation that you want to perform.   
   * Set the value to **DescribeInstanceCreatableZone**.
   */
  zoneList?: DescribeInstanceCreatableZoneResponseBodyZoneList[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      zoneList: 'ZoneList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      zoneList: { 'type': 'array', 'itemType': DescribeInstanceCreatableZoneResponseBodyZoneList },
    };
  }

  validate() {
    if(Array.isArray(this.zoneList)) {
      $dara.Model.validateArray(this.zoneList);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceCreatableZoneResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeInstanceCreatableZoneResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeInstanceCreatableZoneResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceSSLRequest extends $dara.Model {
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      tenantId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceSSLResponseBody extends $dara.Model {
  /**
   * @remarks
   * The SSL setting of the OceanBase cluster instance.
   */
  instanceSSL?: DescribeInstanceSSLResponseBodyInstanceSSL;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * EE205C00-30E4-xxxx-xxxx-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceSSL: 'InstanceSSL',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceSSL: DescribeInstanceSSLResponseBodyInstanceSSL,
      requestId: 'string',
    };
  }

  validate() {
    if(this.instanceSSL && typeof (this.instanceSSL as any).validate === 'function') {
      (this.instanceSSL as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceSSLResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeInstanceSSLResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeInstanceSSLResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceSecurityConfigsRequest extends $dara.Model {
  /**
   * @remarks
   * The unique identifier of the check.
   * 
   * @example
   * xxx
   */
  checkId?: string;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      checkId: 'CheckId',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkId: 'string',
      instanceId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceSecurityConfigsResponseBody extends $dara.Model {
  /**
   * @remarks
   * The return result of the request.
   */
  instanceSecurityConfigs?: DescribeInstanceSecurityConfigsResponseBodyInstanceSecurityConfigs;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceSecurityConfigs: 'InstanceSecurityConfigs',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceSecurityConfigs: DescribeInstanceSecurityConfigsResponseBodyInstanceSecurityConfigs,
      requestId: 'string',
    };
  }

  validate() {
    if(this.instanceSecurityConfigs && typeof (this.instanceSecurityConfigs as any).validate === 'function') {
      (this.instanceSecurityConfigs as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceSecurityConfigsResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeInstanceSecurityConfigsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeInstanceSecurityConfigsResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceSummaryRequest extends $dara.Model {
  /**
   * @remarks
   * The number of the page to return.    
   * - Start value: 1   
   * - Default value: 1
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of rows to return on each page.
   * - Maximum value: 100.
   * - Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceSummaryResponseBody extends $dara.Model {
  /**
   * @remarks
   * The overview information about OceanBase instances.
   */
  instanceSummary?: DescribeInstanceSummaryResponseBodyInstanceSummary;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceSummary: 'InstanceSummary',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceSummary: DescribeInstanceSummaryResponseBodyInstanceSummary,
      requestId: 'string',
    };
  }

  validate() {
    if(this.instanceSummary && typeof (this.instanceSummary as any).validate === 'function') {
      (this.instanceSummary as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceSummaryResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeInstanceSummaryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeInstanceSummaryResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTagsRequest extends $dara.Model {
  /**
   * @remarks
   * The list of cluster IDs.
   * 
   * @example
   * ["ob3za5w73as8rk"]
   */
  instanceIds?: string;
  /**
   * @remarks
   * The tags.
   * 
   * @example
   * [{"Key": "xxx", "Value", "xxx"},{}]
   */
  tags?: string;
  static names(): { [key: string]: string } {
    return {
      instanceIds: 'InstanceIds',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceIds: 'string',
      tags: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTagsResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @remarks
   * The list of tags.
   */
  tagResources?: DescribeInstanceTagsResponseBodyTagResources[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      tagResources: 'TagResources',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      tagResources: { 'type': 'array', 'itemType': DescribeInstanceTagsResponseBodyTagResources },
    };
  }

  validate() {
    if(Array.isArray(this.tagResources)) {
      $dara.Model.validateArray(this.tagResources);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTagsResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeInstanceTagsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeInstanceTagsResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTenantModesRequest extends $dara.Model {
  /**
   * @remarks
   * The operation that you want to perform.   
   * Set the value to **DescribeInstanceTenantModes**.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTenantModesResponseBody extends $dara.Model {
  instanceModes?: string[];
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceModes: 'InstanceModes',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceModes: { 'type': 'array', 'itemType': 'string' },
      requestId: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.instanceModes)) {
      $dara.Model.validateArray(this.instanceModes);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTenantModesResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeInstanceTenantModesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeInstanceTenantModesResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTopologyRequest extends $dara.Model {
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTopologyResponseBody extends $dara.Model {
  /**
   * @remarks
   * The topology of the cluster.
   */
  instanceTopology?: DescribeInstanceTopologyResponseBodyInstanceTopology;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceTopology: 'InstanceTopology',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceTopology: DescribeInstanceTopologyResponseBodyInstanceTopology,
      requestId: 'string',
    };
  }

  validate() {
    if(this.instanceTopology && typeof (this.instanceTopology as any).validate === 'function') {
      (this.instanceTopology as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTopologyResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeInstanceTopologyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeInstanceTopologyResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesRequest extends $dara.Model {
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The name of the OceanBase cluster. It must be 1 to 20 characters in length. If this parameter is not specified, the value is the instance ID of the cluster by default.
   * 
   * @example
   * ob4prod
   */
  instanceName?: string;
  /**
   * @remarks
   * The number of the page to return.
   * - Pages start from page 1.
   * - Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of rows to return on each page.
   * - Maximum value: 100.
   * - Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the resource group. If you do not specify this parameter, all resources are returned.
   * 
   * @example
   * group1
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The keyword for fuzzy search, which can be an instance ID, instance name, tenant ID, or tenant name.
   * 
   * @example
   * pay
   */
  searchKey?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      resourceGroupId: 'ResourceGroupId',
      searchKey: 'SearchKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      instanceName: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      resourceGroupId: 'string',
      searchKey: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesResponseBody extends $dara.Model {
  /**
   * @remarks
   * The information of the OceanBase cluster.
   */
  instances?: DescribeInstancesResponseBodyInstances[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @remarks
   * The number of OceanBase clusters queried.
   * 
   * @example
   * 2
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      instances: 'Instances',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instances: { 'type': 'array', 'itemType': DescribeInstancesResponseBodyInstances },
      requestId: 'string',
      totalCount: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.instances)) {
      $dara.Model.validateArray(this.instances);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeInstancesResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricsDataRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 2021-06-13T15:40:43Z
   */
  endTime?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * app,clusterId
   */
  groupByLabels?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * app:OB,clusterId:ob***
   */
  labels?: string;
  /**
   * @example
   * 5
   */
  limit?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * tps
   */
  metrics?: string;
  replicaType?: string;
  /**
   * @example
   * tps
   */
  sortMetricKey?: string;
  /**
   * @example
   * DESC
   */
  sortOrder?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 2021-06-13T15:40:43Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      groupByLabels: 'GroupByLabels',
      instanceId: 'InstanceId',
      labels: 'Labels',
      limit: 'Limit',
      metrics: 'Metrics',
      replicaType: 'ReplicaType',
      sortMetricKey: 'SortMetricKey',
      sortOrder: 'SortOrder',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      groupByLabels: 'string',
      instanceId: 'string',
      labels: 'string',
      limit: 'string',
      metrics: 'string',
      replicaType: 'string',
      sortMetricKey: 'string',
      sortOrder: 'string',
      startTime: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricsDataResponseBody extends $dara.Model {
  /**
   * @example
   * [
   *                 {
   *                     "sql_select_count":75.****15****1515,
   *                     "timestamp":165079****
   *                 },
   *                 ......
   *             ]
   */
  data?: string[];
  /**
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': 'string' },
      requestId: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.data)) {
      $dara.Model.validateArray(this.data);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricsDataResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeMetricsDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeMetricsDataResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNodeMetricsRequest extends $dara.Model {
  /**
   * @remarks
   * $.parameters[7].schema.description
   * 
   * This parameter is required.
   * 
   * @example
   * 2021-09-13T15:40:43Z
   */
  endTime?: string;
  /**
   * @remarks
   * The list of nodes.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * $.parameters[7].schema.enumValueTitles
   * 
   * This parameter is required.
   * 
   * @example
   * tps
   */
  metrics?: string;
  /**
   * @remarks
   * $.parameters[10].schema.description
   * 
   * @example
   * [i-bp16niirq4zdmgvm****,i-bp16n56hq4z4fgvm****]
   */
  nodeIdList?: string;
  /**
   * @remarks
   * $.parameters[8].schema.example
   * 
   * @example
   * i-bp16niirq4zdmgvm****
   */
  nodeName?: string;
  /**
   * @remarks
   * $.parameters[6].schema.description
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * $.parameters[9].schema.example
   * 
   * This parameter is required.
   * 
   * @example
   * 2021-06-13T15:40:43Z
   */
  startTime?: string;
  /**
   * @remarks
   * $.parameters[6].schema.enumValueTitles
   * 
   * @example
   * tfafd34fs****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      instanceId: 'InstanceId',
      metrics: 'Metrics',
      nodeIdList: 'NodeIdList',
      nodeName: 'NodeName',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      startTime: 'StartTime',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      instanceId: 'string',
      metrics: 'string',
      nodeIdList: 'string',
      nodeName: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      startTime: 'string',
      tenantId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNodeMetricsResponseBody extends $dara.Model {
  /**
   * @example
   * -
   */
  nodeMetrics?: string;
  /**
   * @remarks
   * You can call this operation to query the detailed metrics information of an OceanBase Database node.
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @remarks
   * ```
   * http(s)://[Endpoint]/?Action=DescribeNodeMetrics
   * &InstanceId=ob317v4uif****
   * &PageSize=10
   * &PageNumber=1
   * &TenantId=ob2mr3oae0****
   * &StartTime=2021-06-13 15:40:43
   * &EndTime=2021-09-13 15:40:43
   * &Metrics=tps
   * &NodeName=i-bp16niirq4zdmgvm****
   * &NodeIdList=["i-bp19y05uq6xpacyqnlrc","i-bp1blcr3htr3g3u2vqvu","i-bp1392ikhayhr3hi4fli"]
   * &Common request parameters
   * ```
   * 
   * @example
   * 9
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      nodeMetrics: 'NodeMetrics',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeMetrics: 'string',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNodeMetricsResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeNodeMetricsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeNodeMetricsResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOasAnomalySQLListRequest extends $dara.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * - zh: Chinese
   * - en: English
   * 
   * @example
   * zh-CN
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The current page.
   * 
   * @example
   * 1
   */
  current?: number;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * db_****
   */
  dbName?: string;
  /**
   * @remarks
   * Specifies whether the specified SQL statements are dynamic SQL statements.
   * > This parameter specifies whether the values of the `SqlId` parameter are the IDs of dynamic SQL statements.
   * 
   * @example
   * false
   */
  dynamicSql?: boolean;
  /**
   * @remarks
   * The end time of the monitoring data.   
   * The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-04-12T05:38:38Z
   */
  endTime?: string;
  /**
   * @remarks
   * All parameters are referenced by the symbol @. For a list of available parameters, refer to the returned parameters in [Query performance indicators of an SQL statement](https://en.oceanbase.com/docs/community-ocp-en-10000000000840290).
   * 
   * @example
   * @avgCpuTime > 20 and @executions > 100
   */
  filterCondition?: string;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * Specifies whether to merge dynamic SQL statements in the return result. 
   * 
   * > This parameter specifies whether to aggregate the results of IN queries.
   * 
   * @example
   * false
   */
  mergeDynamicSql?: boolean;
  /**
   * @remarks
   * The node IP.
   * 
   * @example
   * i-bp19y05uq6x*********
   */
  nodeIp?: string;
  /**
   * @remarks
   * Page size.
   * - Start value: 1
   * - Default value: 1
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The search keyword.
   * 
   * @example
   * update
   */
  searchKeyWord?: string;
  /**
   * @remarks
   * The search parameter.
   * 
   * @example
   * cputime
   */
  searchParam?: string;
  /**
   * @remarks
   * The search rule.   
   * Valid values: "=", ">", ">=", "<", and "<="
   * 
   * @example
   * >
   */
  searchRule?: string;
  /**
   * @remarks
   * The search value.
   * 
   * @example
   * 0.01
   */
  searchValue?: string;
  /**
   * @remarks
   * SQL ID.
   * 
   * @example
   * 8D6E84****0B8FB1823D199E2CA1****
   */
  sqlId?: string;
  /**
   * @remarks
   * Max length of the returned SQL text.
   * 
   * @example
   * 65535
   */
  sqlTextLength?: number;
  /**
   * @remarks
   * The start time of the monitoring data.   
   * The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-04-12T04:38:38Z
   */
  startTime?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * t4louaeei****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      current: 'Current',
      dbName: 'DbName',
      dynamicSql: 'DynamicSql',
      endTime: 'EndTime',
      filterCondition: 'FilterCondition',
      instanceId: 'InstanceId',
      mergeDynamicSql: 'MergeDynamicSql',
      nodeIp: 'NodeIp',
      pageSize: 'PageSize',
      searchKeyWord: 'SearchKeyWord',
      searchParam: 'SearchParam',
      searchRule: 'SearchRule',
      searchValue: 'SearchValue',
      sqlId: 'SqlId',
      sqlTextLength: 'SqlTextLength',
      startTime: 'StartTime',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      current: 'number',
      dbName: 'string',
      dynamicSql: 'boolean',
      endTime: 'string',
      filterCondition: 'string',
      instanceId: 'string',
      mergeDynamicSql: 'boolean',
      nodeIp: 'string',
      pageSize: 'number',
      searchKeyWord: 'string',
      searchParam: 'string',
      searchRule: 'string',
      searchValue: 'string',
      sqlId: 'string',
      sqlTextLength: 'number',
      startTime: 'string',
      tenantId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOasAnomalySQLListResponseBody extends $dara.Model {
  /**
   * @remarks
   * The information about suspicious SQL statements.
   */
  data?: DescribeOasAnomalySQLListResponseBodyData[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 473469**-AA6F-4D**-B3DB-A***********
   */
  requestId?: string;
  /**
   * @remarks
   * The total count.
   * 
   * @example
   * 9
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': DescribeOasAnomalySQLListResponseBodyData },
      requestId: 'string',
      totalCount: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.data)) {
      $dara.Model.validateArray(this.data);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOasAnomalySQLListResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeOasAnomalySQLListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeOasAnomalySQLListResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOasSQLDetailsRequest extends $dara.Model {
  /**
   * @remarks
   * The name of the database.
   * 
   * This parameter is required.
   * 
   * @example
   * test_db
   */
  dbName?: string;
  dynamicSql?: boolean;
  /**
   * @remarks
   * The end time of querying the SQL execution plan.   
   * The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-04-12T05:38:38Z
   */
  endTime?: string;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  parseTable?: boolean;
  /**
   * @remarks
   * SQL ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 8D6E84****0B8FB1823D199E2CA1****
   */
  sqlId?: string;
  /**
   * @remarks
   * The start time of querying the SQL execution plan.   
   * The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-04-12T04:38:38Z
   */
  startTime?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * t4louaeei****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      dbName: 'DbName',
      dynamicSql: 'DynamicSql',
      endTime: 'EndTime',
      instanceId: 'InstanceId',
      parseTable: 'ParseTable',
      sqlId: 'SqlId',
      startTime: 'StartTime',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbName: 'string',
      dynamicSql: 'boolean',
      endTime: 'string',
      instanceId: 'string',
      parseTable: 'boolean',
      sqlId: 'string',
      startTime: 'string',
      tenantId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOasSQLDetailsResponseBody extends $dara.Model {
  /**
   * @remarks
   * The list of the SQL execution plan.
   */
  data?: DescribeOasSQLDetailsResponseBodyData;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: DescribeOasSQLDetailsResponseBodyData,
      requestId: 'string',
    };
  }

  validate() {
    if(this.data && typeof (this.data as any).validate === 'function') {
      (this.data as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOasSQLDetailsResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeOasSQLDetailsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeOasSQLDetailsResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOasSQLHistoryListRequest extends $dara.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * - zh: Chinese
   * - en: English
   * 
   * @example
   * zh-CN
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * test_db
   */
  dbName?: string;
  /**
   * @remarks
   * Specifies whether the SQL statement is a dynamic SQL statement.
   * 
   * @example
   * false
   */
  dynamicSql?: boolean;
  /**
   * @remarks
   * The end time of querying the execution history of the SQL statement.   
   * The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-04-12T05:38:38Z
   */
  endTime?: string;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The IP address of the node.
   * 
   * @example
   * i-bp19y05uq6x*********
   */
  nodeIp?: string;
  /**
   * @remarks
   * SQL ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 8D6E84****0B8FB1823D199E2CA1****
   */
  sqlId?: string;
  /**
   * @remarks
   * The start time of querying the execution history of the SQL statement.   
   * The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-04-12T04:38:38Z
   */
  startTime?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * t4louaeei****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      dbName: 'DbName',
      dynamicSql: 'DynamicSql',
      endTime: 'EndTime',
      instanceId: 'InstanceId',
      nodeIp: 'NodeIp',
      sqlId: 'SqlId',
      startTime: 'StartTime',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      dbName: 'string',
      dynamicSql: 'boolean',
      endTime: 'string',
      instanceId: 'string',
      nodeIp: 'string',
      sqlId: 'string',
      startTime: 'string',
      tenantId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOasSQLHistoryListResponseBody extends $dara.Model {
  /**
   * @remarks
   * The list of SQL execution history.
   */
  data?: DescribeOasSQLHistoryListResponseBodyData[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': DescribeOasSQLHistoryListResponseBodyData },
      requestId: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.data)) {
      $dara.Model.validateArray(this.data);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOasSQLHistoryListResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeOasSQLHistoryListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeOasSQLHistoryListResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOasSQLPlansRequest extends $dara.Model {
  /**
   * @remarks
   * Supported language. Valid values:
   * - zh-CN: Chinese
   * - en-US: English
   * 
   * @example
   * zh-CN
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The name of the database.
   * 
   * This parameter is required.
   * 
   * @example
   * test_db
   */
  dbName?: string;
  /**
   * @remarks
   * Specifies whether the SQL statement is dynamic.
   * 
   * @example
   * false
   */
  dynamicSql?: boolean;
  /**
   * @remarks
   * The end time of querying the SQL execution plan.   
   * The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-04-12T05:38:38Z
   */
  endTime?: string;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The unique identifier of the execution plan.
   * 
   * @example
   * c4e9aaa797428df9a5a41828********
   */
  planUnionHash?: string;
  /**
   * @remarks
   * Specifies whether to return an overview of the execution plan.
   * 
   * @example
   * true
   */
  returnBriefInfo?: boolean;
  /**
   * @remarks
   * SQL ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 8D6E84****0B8FB1823D199E2CA1****
   */
  sqlId?: string;
  /**
   * @remarks
   * The start time of querying the SQL execution plan.   
   * The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-04-12T04:38:38Z
   */
  startTime?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * t4louaeei****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      dbName: 'DbName',
      dynamicSql: 'DynamicSql',
      endTime: 'EndTime',
      instanceId: 'InstanceId',
      planUnionHash: 'PlanUnionHash',
      returnBriefInfo: 'ReturnBriefInfo',
      sqlId: 'SqlId',
      startTime: 'StartTime',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      dbName: 'string',
      dynamicSql: 'boolean',
      endTime: 'string',
      instanceId: 'string',
      planUnionHash: 'string',
      returnBriefInfo: 'boolean',
      sqlId: 'string',
      startTime: 'string',
      tenantId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOasSQLPlansResponseBody extends $dara.Model {
  /**
   * @remarks
   * The list of SQL execution plan.
   */
  data?: DescribeOasSQLPlansResponseBodyData[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': DescribeOasSQLPlansResponseBodyData },
      requestId: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.data)) {
      $dara.Model.validateArray(this.data);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOasSQLPlansResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeOasSQLPlansResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeOasSQLPlansResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOasSlowSQLListRequest extends $dara.Model {
  /**
   * @remarks
   * The language of the response.
   * 
   * @example
   * zh-CN
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * test_db
   */
  dbName?: string;
  dynamicSql?: boolean;
  /**
   * @remarks
   * The end time of querying slow SQL historical parameters.   
   * The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-04-12T05:38:38Z
   */
  endTime?: string;
  /**
   * @remarks
   * All parameters are referenced by the symbol @. For a list of available parameters, refer to the returned parameters in [Query performance indicators of an SQL statement](https://en.oceanbase.com/docs/community-ocp-en-10000000000840290).
   * 
   * @example
   * @avgCpuTime > 20 and @executions > 100
   */
  filterCondition?: string;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  mergeDynamicSql?: boolean;
  /**
   * @remarks
   * The IP of the database node.
   * 
   * @example
   * i-bp18qljorblo8es*****
   */
  nodeIp?: string;
  /**
   * @remarks
   * The search keyword.
   * 
   * @example
   * update
   */
  searchKeyWord?: string;
  /**
   * @remarks
   * The search parameter.
   * 
   * @example
   * cputime
   */
  searchParam?: string;
  /**
   * @remarks
   * The search rule.
   * 
   * @example
   * >
   */
  searchRule?: string;
  /**
   * @remarks
   * The search value.
   * 
   * @example
   * 0.01
   */
  searchValue?: string;
  /**
   * @remarks
   * SQL ID, the unique identifier of the SQL.
   * 
   * @example
   * 8D6E84****0B8FB1823D199E2CA1****
   */
  sqlId?: string;
  /**
   * @remarks
   * Max length of the returned SQL text.
   * 
   * @example
   * 65535
   */
  sqlTextLength?: number;
  /**
   * @remarks
   * The start time of querying slow SQL historical parameters.   
   * The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-04-12T04:38:38Z
   */
  startTime?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * t4louaeei****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      dbName: 'DbName',
      dynamicSql: 'DynamicSql',
      endTime: 'EndTime',
      filterCondition: 'FilterCondition',
      instanceId: 'InstanceId',
      mergeDynamicSql: 'MergeDynamicSql',
      nodeIp: 'NodeIp',
      searchKeyWord: 'SearchKeyWord',
      searchParam: 'SearchParam',
      searchRule: 'SearchRule',
      searchValue: 'SearchValue',
      sqlId: 'SqlId',
      sqlTextLength: 'SqlTextLength',
      startTime: 'StartTime',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      dbName: 'string',
      dynamicSql: 'boolean',
      endTime: 'string',
      filterCondition: 'string',
      instanceId: 'string',
      mergeDynamicSql: 'boolean',
      nodeIp: 'string',
      searchKeyWord: 'string',
      searchParam: 'string',
      searchRule: 'string',
      searchValue: 'string',
      sqlId: 'string',
      sqlTextLength: 'number',
      startTime: 'string',
      tenantId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOasSlowSQLListResponseBody extends $dara.Model {
  /**
   * @remarks
   * The list of slow queries.
   */
  data?: DescribeOasSlowSQLListResponseBodyData[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': DescribeOasSlowSQLListResponseBodyData },
      requestId: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.data)) {
      $dara.Model.validateArray(this.data);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOasSlowSQLListResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeOasSlowSQLListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeOasSlowSQLListResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOasTopSQLListRequest extends $dara.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * - zh: Chinese
   * - en: English
   * 
   * @example
   * zh-CN
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * test_db
   */
  dbName?: string;
  dynamicSql?: boolean;
  /**
   * @remarks
   * The end time of querying the TOPSQL parameter.
   * The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-04-12T05:38:38Z
   */
  endTime?: string;
  /**
   * @remarks
   * All parameters are referenced by the symbol @. For a list of available parameters, refer to the returned parameters in [Query performance indicators of an SQL statement](https://en.oceanbase.com/docs/community-ocp-en-10000000000840290).
   * 
   * @example
   * @avgCpuTime > 20 and @executions > 100
   */
  filterCondition?: string;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  mergeDynamicSql?: boolean;
  /**
   * @remarks
   * The node IP.
   * 
   * @example
   * i-bp18l4****str4uk03
   */
  nodeIp?: string;
  /**
   * @remarks
   * The search keyword.
   * 
   * @example
   * update
   */
  searchKeyWord?: string;
  /**
   * @remarks
   * The search parameter.
   * 
   * @example
   * cputime
   */
  searchParam?: string;
  /**
   * @remarks
   * The search rule.
   * 
   * @example
   * >
   */
  searchRule?: string;
  /**
   * @remarks
   * The search value.
   * 
   * @example
   * 0.01
   */
  searchValue?: string;
  /**
   * @remarks
   * SQL ID.
   * > When the SQL ID is provided, the system collects all the request data for the target SQL ID. When the SQL ID is empty, the system collects all the request data for the entire database instance.
   * 
   * @example
   * 8D6E84****0B8FB1823D199E2CA1****
   */
  sqlId?: string;
  /**
   * @remarks
   * Max length of the returned SQL text.
   * 
   * @example
   * 65535
   */
  sqlTextLength?: number;
  /**
   * @remarks
   * The start time of querying the TOPSQL parameter.   
   * The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-04-12T04:38:38Z
   */
  startTime?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * t4louaeei****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      dbName: 'DbName',
      dynamicSql: 'DynamicSql',
      endTime: 'EndTime',
      filterCondition: 'FilterCondition',
      instanceId: 'InstanceId',
      mergeDynamicSql: 'MergeDynamicSql',
      nodeIp: 'NodeIp',
      searchKeyWord: 'SearchKeyWord',
      searchParam: 'SearchParam',
      searchRule: 'SearchRule',
      searchValue: 'SearchValue',
      sqlId: 'SqlId',
      sqlTextLength: 'SqlTextLength',
      startTime: 'StartTime',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      dbName: 'string',
      dynamicSql: 'boolean',
      endTime: 'string',
      filterCondition: 'string',
      instanceId: 'string',
      mergeDynamicSql: 'boolean',
      nodeIp: 'string',
      searchKeyWord: 'string',
      searchParam: 'string',
      searchRule: 'string',
      searchValue: 'string',
      sqlId: 'string',
      sqlTextLength: 'number',
      startTime: 'string',
      tenantId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOasTopSQLListResponseBody extends $dara.Model {
  /**
   * @remarks
   * The list of Top SQL.
   */
  data?: DescribeOasTopSQLListResponseBodyData[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': DescribeOasTopSQLListResponseBodyData },
      requestId: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.data)) {
      $dara.Model.validateArray(this.data);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOasTopSQLListResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeOasTopSQLListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeOasTopSQLListResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOutlineBindingRequest extends $dara.Model {
  /**
   * @remarks
   * The name of the database.
   * 
   * This parameter is required.
   * 
   * @example
   * testdb
   */
  databaseName?: string;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * - When the value is set to True, the throttling information in the database is queried based on the SQL ID.   
   * - When the value is set to False, the bound index or execution plan in the database is queried based on the SQL ID.
   * 
   * @example
   * false
   */
  isConcurrentLimit?: boolean;
  /**
   * @remarks
   * SQLID.
   * 
   * This parameter is required.
   * 
   * @example
   * 8D6E84****0B8FB1823D199E2CA1****
   */
  SQLId?: string;
  /**
   * @remarks
   * The name of the tenant.    
   * It must start with a letter or an underscore (_), and contain 2 to 20 characters, which can be uppercase letters, lowercase letters, digits, and underscores (_). It cannot be set to SYS.
   * 
   * This parameter is required.
   * 
   * @example
   * pay_online
   */
  tableName?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * t2mr3oae0****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      databaseName: 'DatabaseName',
      instanceId: 'InstanceId',
      isConcurrentLimit: 'IsConcurrentLimit',
      SQLId: 'SQLId',
      tableName: 'TableName',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      databaseName: 'string',
      instanceId: 'string',
      isConcurrentLimit: 'boolean',
      SQLId: 'string',
      tableName: 'string',
      tenantId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOutlineBindingResponseBody extends $dara.Model {
  /**
   * @remarks
   * The binding information.
   */
  outlineBinding?: DescribeOutlineBindingResponseBodyOutlineBinding;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      outlineBinding: 'OutlineBinding',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      outlineBinding: DescribeOutlineBindingResponseBodyOutlineBinding,
      requestId: 'string',
    };
  }

  validate() {
    if(this.outlineBinding && typeof (this.outlineBinding as any).validate === 'function') {
      (this.outlineBinding as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOutlineBindingResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeOutlineBindingResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeOutlineBindingResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeParametersRequest extends $dara.Model {
  /**
   * @remarks
   * It is an online CLI tool that allows you to quickly retrieve and debug APIs. It can dynamically generate executable SDK code samples.
   * 
   * This parameter is required.
   * 
   * @example
   * TENANT
   */
  dimension?: string;
  /**
   * @remarks
   * Alibaba Cloud CLI
   * 
   * @example
   * ob2mr3oae0****
   */
  dimensionValue?: string;
  /**
   * @remarks
   * 498529
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      dimension: 'Dimension',
      dimensionValue: 'DimensionValue',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dimension: 'string',
      dimensionValue: 'string',
      instanceId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeParametersResponseBody extends $dara.Model {
  /**
   * @remarks
   * Indicates whether a restart is required for changes to the parameter to take effect. Valid values:   
   * - true: A restart is required.   
   * - false: A restart is not required.
   */
  parameters?: DescribeParametersResponseBodyParameters[];
  /**
   * @remarks
   * The return result of the request.
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      parameters: 'Parameters',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      parameters: { 'type': 'array', 'itemType': DescribeParametersResponseBodyParameters },
      requestId: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.parameters)) {
      $dara.Model.validateArray(this.parameters);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeParametersResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeParametersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeParametersResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeParametersHistoryRequest extends $dara.Model {
  /**
   * @remarks
   * The type of the parameter.    
   * Valid values: CLUSTER and TENANT.
   * 
   * This parameter is required.
   * 
   * @example
   * TENANT
   */
  dimension?: string;
  /**
   * @remarks
   * The resource ID of the parameter type.   
   * You can leave this parameter unspecified when you call this operation to query cluster parameters. In the case of tenant parameters, pass the tenant ID.
   * 
   * @example
   * t4qx8****
   */
  dimensionValue?: string;
  /**
   * @remarks
   * The end time of the time range for querying the SQL execution history.   
   * The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
   * 
   * This parameter is required.
   * 
   * @example
   * 2021-09-13 15:40:43
   */
  endTime?: string;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The number of the page to return.    
   * - Start value: 1   
   * - Default value: 1
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of rows to return on each page.   
   * - Maximum value: 100.
   * - Default value: 10
   * 
   * This parameter is required.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The start time of querying the slow query execution.
   * The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
   * 
   * This parameter is required.
   * 
   * @example
   * 2021-06-13 15:40:43
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      dimension: 'Dimension',
      dimensionValue: 'DimensionValue',
      endTime: 'EndTime',
      instanceId: 'InstanceId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dimension: 'string',
      dimensionValue: 'string',
      endTime: 'string',
      instanceId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      startTime: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeParametersHistoryResponseBody extends $dara.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @remarks
   * The list of parameter modification records.
   */
  respond?: DescribeParametersHistoryResponseBodyRespond;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      respond: 'Respond',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      respond: DescribeParametersHistoryResponseBodyRespond,
    };
  }

  validate() {
    if(this.respond && typeof (this.respond as any).validate === 'function') {
      (this.respond as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeParametersHistoryResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeParametersHistoryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeParametersHistoryResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProcessStatsCompositionRequest extends $dara.Model {
  /**
   * @remarks
   * The IP address of the client.
   * 
   * @example
   * 127.*.*.*
   */
  clientIp?: string;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The IP address of the server.
   * 
   * @example
   * 127.*.*.*
   */
  serverIp?: string;
  /**
   * @remarks
   * The SQL statement, which can contain LIKE clauses. You can specify only part of the clauses in the SQL statement.
   * 
   * @example
   * SELECT  ****   FROM ****   WHERE **** = ? AND **** = ?   ORDER BY **** ASC
   */
  sqlText?: string;
  /**
   * @remarks
   * The status of the session.
   * 
   * @example
   * ACTIVE
   */
  status?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * @example
   * t33h8y08k****
   */
  tenantId?: string;
  /**
   * @remarks
   * The user identifier (UID) of the OceanBase database.
   * 
   * @example
   * 139*************
   */
  UId?: string;
  /**
   * @remarks
   * The username of the database.
   * 
   * @example
   * ["test_user"]
   */
  users?: string;
  static names(): { [key: string]: string } {
    return {
      clientIp: 'ClientIp',
      instanceId: 'InstanceId',
      serverIp: 'ServerIp',
      sqlText: 'SqlText',
      status: 'Status',
      tenantId: 'TenantId',
      UId: 'UId',
      users: 'Users',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clientIp: 'string',
      instanceId: 'string',
      serverIp: 'string',
      sqlText: 'string',
      status: 'string',
      tenantId: 'string',
      UId: 'string',
      users: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProcessStatsCompositionResponseBody extends $dara.Model {
  /**
   * @remarks
   * The return result.
   */
  data?: DescribeProcessStatsCompositionResponseBodyData;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: DescribeProcessStatsCompositionResponseBodyData,
      requestId: 'string',
    };
  }

  validate() {
    if(this.data && typeof (this.data as any).validate === 'function') {
      (this.data as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProcessStatsCompositionResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeProcessStatsCompositionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeProcessStatsCompositionResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * np_fe****
   */
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponseBody extends $dara.Model {
  /**
   * @example
   * Contact the administrator.
   */
  advice?: string;
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  /**
   * @example
   * 1
   */
  cost?: string;
  data?: DescribeProjectResponseBodyData;
  errorDetail?: DescribeProjectResponseBodyErrorDetail;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * 473469C7-XXXX-XXXX-B3DB-A3DC0DE3C83E
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 2
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      cost: 'Cost',
      data: 'Data',
      errorDetail: 'ErrorDetail',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      cost: 'string',
      data: DescribeProjectResponseBodyData,
      errorDetail: DescribeProjectResponseBodyErrorDetail,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  validate() {
    if(this.data && typeof (this.data as any).validate === 'function') {
      (this.data as any).validate();
    }
    if(this.errorDetail && typeof (this.errorDetail as any).validate === 'function') {
      (this.errorDetail as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeProjectResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeProjectResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectComponentsRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * np_4w3a****
   */
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectComponentsResponseBody extends $dara.Model {
  /**
   * @example
   * Contact the administrator.
   */
  advice?: string;
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  /**
   * @example
   * 48
   */
  cost?: string;
  data?: DescribeProjectComponentsResponseBodyData;
  errorDetail?: DescribeProjectComponentsResponseBodyErrorDetail;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 9
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      cost: 'Cost',
      data: 'Data',
      errorDetail: 'ErrorDetail',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      cost: 'string',
      data: DescribeProjectComponentsResponseBodyData,
      errorDetail: DescribeProjectComponentsResponseBodyErrorDetail,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  validate() {
    if(this.data && typeof (this.data as any).validate === 'function') {
      (this.data as any).validate();
    }
    if(this.errorDetail && typeof (this.errorDetail as any).validate === 'function') {
      (this.errorDetail as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectComponentsResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeProjectComponentsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeProjectComponentsResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectProgressRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * np_4w3a****
   */
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectProgressResponseBody extends $dara.Model {
  /**
   * @example
   * Contact the administrator.
   */
  advice?: string;
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  /**
   * @example
   * 1
   */
  cost?: string;
  data?: DescribeProjectProgressResponseBodyData;
  errorDetail?: DescribeProjectProgressResponseBodyErrorDetail;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 1
   */
  pageSize?: number;
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      cost: 'Cost',
      data: 'Data',
      errorDetail: 'ErrorDetail',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      cost: 'string',
      data: DescribeProjectProgressResponseBodyData,
      errorDetail: DescribeProjectProgressResponseBodyErrorDetail,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  validate() {
    if(this.data && typeof (this.data as any).validate === 'function') {
      (this.data as any).validate();
    }
    if(this.errorDetail && typeof (this.errorDetail as any).validate === 'function') {
      (this.errorDetail as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectProgressResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeProjectProgressResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeProjectProgressResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectStepMetricRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * AVG
   */
  aggregator?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1689244696
   */
  beginTimestamp?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1689254646
   */
  endTimestamp?: number;
  /**
   * @example
   * 6
   */
  maxPointNum?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * RPS
   */
  metricType?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * np_dr****
   */
  projectId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * FULL_TRANSFER
   */
  stepName?: string;
  static names(): { [key: string]: string } {
    return {
      aggregator: 'Aggregator',
      beginTimestamp: 'BeginTimestamp',
      endTimestamp: 'EndTimestamp',
      maxPointNum: 'MaxPointNum',
      metricType: 'MetricType',
      projectId: 'ProjectId',
      stepName: 'StepName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aggregator: 'string',
      beginTimestamp: 'number',
      endTimestamp: 'number',
      maxPointNum: 'number',
      metricType: 'string',
      projectId: 'string',
      stepName: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectStepMetricResponseBody extends $dara.Model {
  /**
   * @example
   * Contact the administrator.
   */
  advice?: string;
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  /**
   * @example
   * 1
   */
  cost?: string;
  data?: DescribeProjectStepMetricResponseBodyData;
  errorDetail?: DescribeProjectStepMetricResponseBodyErrorDetail;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      cost: 'Cost',
      data: 'Data',
      errorDetail: 'ErrorDetail',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      cost: 'string',
      data: DescribeProjectStepMetricResponseBodyData,
      errorDetail: DescribeProjectStepMetricResponseBodyErrorDetail,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  validate() {
    if(this.data && typeof (this.data as any).validate === 'function') {
      (this.data as any).validate();
    }
    if(this.errorDetail && typeof (this.errorDetail as any).validate === 'function') {
      (this.errorDetail as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectStepMetricResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeProjectStepMetricResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeProjectStepMetricResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectStepsRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * np_4w3a****
   */
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectStepsResponseBody extends $dara.Model {
  /**
   * @example
   * Contact the administrator.
   */
  advice?: string;
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  /**
   * @example
   * 1
   */
  cost?: string;
  data?: DescribeProjectStepsResponseBodyData[];
  errorDetail?: DescribeProjectStepsResponseBodyErrorDetail;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 4
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      cost: 'Cost',
      data: 'Data',
      errorDetail: 'ErrorDetail',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      cost: 'string',
      data: { 'type': 'array', 'itemType': DescribeProjectStepsResponseBodyData },
      errorDetail: DescribeProjectStepsResponseBodyErrorDetail,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.data)) {
      $dara.Model.validateArray(this.data);
    }
    if(this.errorDetail && typeof (this.errorDetail as any).validate === 'function') {
      (this.errorDetail as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProjectStepsResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeProjectStepsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeProjectStepsResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProxyServiceRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProxyServiceResponseBody extends $dara.Model {
  data?: DescribeProxyServiceResponseBodyData;
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: DescribeProxyServiceResponseBodyData,
      requestId: 'string',
    };
  }

  validate() {
    if(this.data && typeof (this.data as any).validate === 'function') {
      (this.data as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeProxyServiceResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeProxyServiceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeProxyServiceResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRecommendIndexRequest extends $dara.Model {
  /**
   * @remarks
   * The return result of the request.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * 8D6E84****0B8FB1823D199E2CA1****
   */
  SQLId?: string;
  /**
   * @remarks
   * The index recommended for the SQL statement after calculation by the diagnostic system.   
   * - If the recommended index is the primary key, PRIMARY is returned.  
   * - If an index created by the user is recommended, the index name is returned.   
   * The system recommends only one index for an SQL statement. You can call the DescribeIndexes operation to view the indexes of a table.
   * 
   * This parameter is required.
   * 
   * @example
   * t2mr3oae0****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      SQLId: 'SQLId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      SQLId: 'string',
      tenantId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRecommendIndexResponseBody extends $dara.Model {
  /**
   * @remarks
   * The information about the recommended index.
   */
  recommendIndex?: DescribeRecommendIndexResponseBodyRecommendIndex;
  /**
   * @remarks
   * The tenant mode.   Valid values:  
   * Oracle   
   * MySQL
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      recommendIndex: 'RecommendIndex',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      recommendIndex: DescribeRecommendIndexResponseBodyRecommendIndex,
      requestId: 'string',
    };
  }

  validate() {
    if(this.recommendIndex && typeof (this.recommendIndex as any).validate === 'function') {
      (this.recommendIndex as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRecommendIndexResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeRecommendIndexResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeRecommendIndexResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRestorableTenantsRequest extends $dara.Model {
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * Specifies whether the target cluster is online. **Note** This parameter is used for compatibility with earlier versions and can be left empty. When left empty, it specifies negation for the value of `isRemote`.
   * 
   * @example
   * true
   */
  isOnline?: boolean;
  /**
   * @remarks
   * This parameter is provided for compatibility with earlier versions and can be left empty.
   * 
   * @example
   * true
   */
  isRemote?: boolean;
  /**
   * @remarks
   * The backup method.
   * 
   * @example
   * native_logical
   */
  method?: string;
  /**
   * @remarks
   * The restore method. This parameter is required when `IsRemote` is set to `true`, and is optional otherwise.
   * 
   * @example
   * from_time_point
   */
  restoreMode?: string;
  /**
   * @remarks
   * The type of the restore object.
   * 
   * @example
   * tenant
   */
  restoreObjectType?: string;
  /**
   * @remarks
   * The ID of the backup set.
   * 
   * @example
   * bak-xxxxx
   */
  setId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      isOnline: 'IsOnline',
      isRemote: 'IsRemote',
      method: 'Method',
      restoreMode: 'RestoreMode',
      restoreObjectType: 'RestoreObjectType',
      setId: 'SetId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      isOnline: 'boolean',
      isRemote: 'boolean',
      method: 'string',
      restoreMode: 'string',
      restoreObjectType: 'string',
      setId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRestorableTenantsResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @remarks
   * The information about the tenants.
   */
  tenants?: DescribeRestorableTenantsResponseBodyTenants[];
  /**
   * @remarks
   * The total number.
   * 
   * @example
   * 6
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      tenants: 'Tenants',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      tenants: { 'type': 'array', 'itemType': DescribeRestorableTenantsResponseBodyTenants },
      totalCount: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.tenants)) {
      $dara.Model.validateArray(this.tenants);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRestorableTenantsResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeRestorableTenantsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeRestorableTenantsResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSQLDetailsRequest extends $dara.Model {
  /**
   * @remarks
   * The SQL text.
   * 
   * This parameter is required.
   * 
   * @example
   * 8D6E84****0B8FB1823D199E2CA1****
   */
  SQLId?: string;
  /**
   * @remarks
   * SQLID.
   * 
   * This parameter is required.
   * 
   * @example
   * t2mr3oae0****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      SQLId: 'SQLId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      SQLId: 'string',
      tenantId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSQLDetailsResponseBody extends $dara.Model {
  /**
   * @remarks
   * The operation that you want to perform.   
   * Set the value to **DescribeSQLDetails**.
   * 
   * @example
   * 473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E
   */
  requestId?: string;
  /**
   * @remarks
   * ```
   * http(s)://[Endpoint]/?Action=DescribeSQLDetails
   * &TenantId=t2mr3oae0****
   * &SQLId=8D6E84****0B8FB1823D199E2CA1****
   * &Common request parameters
   * ```
   */
  SQLDetails?: DescribeSQLDetailsResponseBodySQLDetails[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      SQLDetails: 'SQLDetails',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      SQLDetails: { 'type': 'array', 'itemType': DescribeSQLDetailsResponseBodySQLDetails },
    };
  }

  validate() {
    if(Array.isArray(this.SQLDetails)) {
      $dara.Model.validateArray(this.SQLDetails);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSQLDetailsResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeSQLDetailsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSQLDetailsResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSQLHistoryListRequest extends $dara.Model {
  /**
   * @remarks
   * The end time of the time range for querying the SQL execution history.   
   * The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
   * 
   * This parameter is required.
   * 
   * @example
   * 2021-09-13T15:40:43Z
   */
  endTime?: string;
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned on each page.   
   * Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * SQLID.
   * 
   * This parameter is required.
   * 
   * @example
   * 8D6E84****0B8FB1823D199E2CA1****
   */
  SQLId?: string;
  /**
   * @remarks
   * The start time of the time range for querying the SQL execution history.   
   * The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
   * 
   * This parameter is required.
   * 
   * @example
   * 2021-06-13T15:40:43Z
   */
  startTime?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * t2mr3oae0****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      SQLId: 'SQLId',
      startTime: 'StartTime',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      SQLId: 'string',
      startTime: 'string',
      tenantId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSQLHistoryListResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E
   */
  requestId?: string;
  /**
   * @remarks
   * The execution history of the SQL statement.
   */
  SQLHistoryList?: DescribeSQLHistoryListResponseBodySQLHistoryList;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      SQLHistoryList: 'SQLHistoryList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      SQLHistoryList: DescribeSQLHistoryListResponseBodySQLHistoryList,
    };
  }

  validate() {
    if(this.SQLHistoryList && typeof (this.SQLHistoryList as any).validate === 'function') {
      (this.SQLHistoryList as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSQLHistoryListResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeSQLHistoryListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSQLHistoryListResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSQLPlansRequest extends $dara.Model {
  /**
   * @remarks
   * SQLID.
   * 
   * This parameter is required.
   * 
   * @example
   * 8D6E84****0B8FB1823D199E2CA1****
   */
  SQLId?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * t2mr3oae0****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      SQLId: 'SQLId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      SQLId: 'string',
      tenantId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSQLPlansResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @remarks
   * The information about the execution plan.
   */
  SQLPlans?: DescribeSQLPlansResponseBodySQLPlans[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      SQLPlans: 'SQLPlans',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      SQLPlans: { 'type': 'array', 'itemType': DescribeSQLPlansResponseBodySQLPlans },
    };
  }

  validate() {
    if(Array.isArray(this.SQLPlans)) {
      $dara.Model.validateArray(this.SQLPlans);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSQLPlansResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeSQLPlansResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSQLPlansResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSQLSamplesRequest extends $dara.Model {
  /**
   * @remarks
   * The database name.
   * 
   * This parameter is required.
   * 
   * @example
   * test_db
   */
  dbName?: string;
  /**
   * @remarks
   * The end time of querying the slow query execution.
   * The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-04-12T05:38:38Z
   */
  endTime?: string;
  /**
   * @remarks
   * The instance ID.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * Specifies whether to return the SQL text.
   * 
   * @example
   * true
   */
  returnSqlText?: boolean;
  /**
   * @remarks
   * SQL ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 8D6E84****0B8FB1823D199E2CA1****
   */
  sqlId?: string;
  /**
   * @remarks
   * The start time of querying the slow query execution.
   * The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-04-12T04:38:38Z
   */
  startTime?: string;
  /**
   * @remarks
   * The tenant ID.
   * 
   * @example
   * t4louaeei****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      dbName: 'DbName',
      endTime: 'EndTime',
      instanceId: 'InstanceId',
      returnSqlText: 'ReturnSqlText',
      sqlId: 'SqlId',
      startTime: 'StartTime',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbName: 'string',
      endTime: 'string',
      instanceId: 'string',
      returnSqlText: 'boolean',
      sqlId: 'string',
      startTime: 'string',
      tenantId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSQLSamplesResponseBody extends $dara.Model {
  /**
   * @remarks
   * The list of sample data of slow query execution details.
   */
  data?: DescribeSQLSamplesResponseBodyData[];
  /**
   * @remarks
   * Request ID.
   * 
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': DescribeSQLSamplesResponseBodyData },
      requestId: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.data)) {
      $dara.Model.validateArray(this.data);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSQLSamplesResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeSQLSamplesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSQLSamplesResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSQLTuningAdvicesRequest extends $dara.Model {
  /**
   * @example
   * zh-CN
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * testdb
   */
  dbName?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 2023-04-12T05:38:38Z
   */
  endTime?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * obsdf43****
   */
  instanceId?: string;
  /**
   * @remarks
   * SqlId
   * 
   * This parameter is required.
   * 
   * @example
   * 123456
   */
  sqlId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 2023-04-12T04:38:38Z
   */
  startTime?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * tsdc2s2****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      dbName: 'DbName',
      endTime: 'EndTime',
      instanceId: 'InstanceId',
      sqlId: 'SqlId',
      startTime: 'StartTime',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      dbName: 'string',
      endTime: 'string',
      instanceId: 'string',
      sqlId: 'string',
      startTime: 'string',
      tenantId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSQLTuningAdvicesResponseBody extends $dara.Model {
  data?: DescribeSQLTuningAdvicesResponseBodyData[];
  /**
   * @example
   * 473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': DescribeSQLTuningAdvicesResponseBodyData },
      requestId: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.data)) {
      $dara.Model.validateArray(this.data);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSQLTuningAdvicesResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeSQLTuningAdvicesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSQLTuningAdvicesResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSampleSqlRawTextsRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * test_db
   */
  dbName?: string;
  dynamicSql?: boolean;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 2023-04-12T05:38:38Z
   */
  endTime?: string;
  /**
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @example
   * 20
   */
  limit?: string;
  /**
   * @remarks
   * SQL ID。
   * 
   * This parameter is required.
   * 
   * @example
   * 8D6E84****0B8FB1823D199E2CA1****
   */
  sqlId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 2023-04-12T04:38:38Z
   */
  startTime?: string;
  /**
   * @example
   * ob2mr3oae0****
   */
  tenantId?: string;
  /**
   * @example
   * YB420A700EFB-00060D53E42D0C61-0-0
   */
  traceId?: string;
  static names(): { [key: string]: string } {
    return {
      dbName: 'DbName',
      dynamicSql: 'DynamicSql',
      endTime: 'EndTime',
      instanceId: 'InstanceId',
      limit: 'Limit',
      sqlId: 'SqlId',
      startTime: 'StartTime',
      tenantId: 'TenantId',
      traceId: 'TraceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbName: 'string',
      dynamicSql: 'boolean',
      endTime: 'string',
      instanceId: 'string',
      limit: 'string',
      sqlId: 'string',
      startTime: 'string',
      tenantId: 'string',
      traceId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSampleSqlRawTextsResponseBody extends $dara.Model {
  data?: DescribeSampleSqlRawTextsResponseBodyData;
  /**
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: DescribeSampleSqlRawTextsResponseBodyData,
      requestId: 'string',
    };
  }

  validate() {
    if(this.data && typeof (this.data as any).validate === 'function') {
      (this.data as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSampleSqlRawTextsResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeSampleSqlRawTextsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSampleSqlRawTextsResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSecurityIpGroupsRequest extends $dara.Model {
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * i-bp67acfmxazb4p****
   */
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSecurityIpGroupsResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  securityIpGroups?: DescribeSecurityIpGroupsResponseBodySecurityIpGroups[];
  /**
   * @remarks
   * Example 1
   * 
   * @example
   * 2
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      securityIpGroups: 'SecurityIpGroups',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      securityIpGroups: { 'type': 'array', 'itemType': DescribeSecurityIpGroupsResponseBodySecurityIpGroups },
      totalCount: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.securityIpGroups)) {
      $dara.Model.validateArray(this.securityIpGroups);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSecurityIpGroupsResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeSecurityIpGroupsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSecurityIpGroupsResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSessionListRequest extends $dara.Model {
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * t4louaeei****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      tenantId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSessionListResponseBody extends $dara.Model {
  /**
   * @remarks
   * The object information.
   */
  data?: DescribeSessionListResponseBodyData[];
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': DescribeSessionListResponseBodyData },
      requestId: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.data)) {
      $dara.Model.validateArray(this.data);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSessionListResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeSessionListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSessionListResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSlowSQLHistoryListRequest extends $dara.Model {
  /**
   * @remarks
   * The end time of the time range for querying the execution history of the slow SQL statement.   
   * The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
   * 
   * This parameter is required.
   * 
   * @example
   * 2021-12-14T08:34:49Z
   */
  endTime?: string;
  /**
   * @remarks
   * The number of the page to return.    
   * - Start value: 1   
   * - Default value: 1
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of rows to return on each page.  
   * - Maximum value: 100   
   * - Default value: 10
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The SQL ID, which uniquely identifies an SQL statement.
   * 
   * This parameter is required.
   * 
   * @example
   * 8D6E84735C0****1823D199E2CA1****
   */
  SQLId?: string;
  /**
   * @remarks
   * The start time of the time range for querying the execution history of the slow SQL statement.   
   * The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
   * 
   * This parameter is required.
   * 
   * @example
   * 2021-12-14T02:34:49Z
   */
  startTime?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * t384tolsj****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      SQLId: 'SQLId',
      startTime: 'StartTime',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      SQLId: 'string',
      startTime: 'string',
      tenantId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSlowSQLHistoryListResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @remarks
   * The execution history of the slow SQL statement.
   */
  slowSQLHistoryList?: DescribeSlowSQLHistoryListResponseBodySlowSQLHistoryList;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      slowSQLHistoryList: 'SlowSQLHistoryList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      slowSQLHistoryList: DescribeSlowSQLHistoryListResponseBodySlowSQLHistoryList,
    };
  }

  validate() {
    if(this.slowSQLHistoryList && typeof (this.slowSQLHistoryList as any).validate === 'function') {
      (this.slowSQLHistoryList as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSlowSQLHistoryListResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeSlowSQLHistoryListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSlowSQLHistoryListResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSlowSQLListRequest extends $dara.Model {
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * testdb
   */
  dbName?: string;
  /**
   * @remarks
   * The end time of the time range for querying slow SQL statements.   
   * The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
   * 
   * This parameter is required.
   * 
   * @example
   * 2021-09-13T15:40:43Z
   */
  endTime?: string;
  /**
   * @remarks
   * The filter condition.
   * 
   * @example
   * [dbName:sys]
   */
  filterCondition?: { [key: string]: any };
  /**
   * @remarks
   * The IP address of the database node.
   * 
   * @example
   * i-bp18qljorblo8es*****
   */
  nodeIp?: string;
  /**
   * @remarks
   * The number of rows to return on each page.  
   * - Maximum value: 100  
   * - Default value: 10
   * 
   * @example
   * 10
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of the page to return.    
   * - Start value: 1   
   * - Default value: 1
   * 
   * @example
   * 1
   */
  pageSize?: number;
  /**
   * @remarks
   * The SQL ID, which uniquely identifies an SQL statement.
   * 
   * @example
   * 8D6E84****0B8FB1823D199E2CA1****
   */
  SQLId?: string;
  /**
   * @remarks
   * The search keyword.
   * 
   * @example
   * update
   */
  searchKeyWord?: string;
  /**
   * @remarks
   * The search parameter.
   * 
   * @example
   * cputime
   */
  searchParameter?: string;
  /**
   * @remarks
   * The search rule.
   * 
   * @example
   * >
   */
  searchRule?: string;
  /**
   * @remarks
   * The search value.
   * 
   * @example
   * 0.01
   */
  searchValue?: string;
  /**
   * @remarks
   * The sorted column.
   * 
   * @example
   * cputime
   */
  sortColumn?: string;
  /**
   * @remarks
   * The sorting rule.
   * 
   * @example
   * desc
   */
  sortOrder?: string;
  /**
   * @remarks
   * The start time of the time range for querying slow SQL statements.   
   * The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
   * 
   * This parameter is required.
   * 
   * @example
   * 2021-06-13T15:40:43Z
   */
  startTime?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * t2mr3oae0****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      dbName: 'DbName',
      endTime: 'EndTime',
      filterCondition: 'FilterCondition',
      nodeIp: 'NodeIp',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      SQLId: 'SQLId',
      searchKeyWord: 'SearchKeyWord',
      searchParameter: 'SearchParameter',
      searchRule: 'SearchRule',
      searchValue: 'SearchValue',
      sortColumn: 'SortColumn',
      sortOrder: 'SortOrder',
      startTime: 'StartTime',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbName: 'string',
      endTime: 'string',
      filterCondition: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      nodeIp: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      SQLId: 'string',
      searchKeyWord: 'string',
      searchParameter: 'string',
      searchRule: 'string',
      searchValue: 'string',
      sortColumn: 'string',
      sortOrder: 'string',
      startTime: 'string',
      tenantId: 'string',
    };
  }

  validate() {
    if(this.filterCondition) {
      $dara.Model.validateMap(this.filterCondition);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSlowSQLListShrinkRequest extends $dara.Model {
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * testdb
   */
  dbName?: string;
  /**
   * @remarks
   * The end time of the time range for querying slow SQL statements.   
   * The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
   * 
   * This parameter is required.
   * 
   * @example
   * 2021-09-13T15:40:43Z
   */
  endTime?: string;
  /**
   * @remarks
   * The filter condition.
   * 
   * @example
   * [dbName:sys]
   */
  filterConditionShrink?: string;
  /**
   * @remarks
   * The IP address of the database node.
   * 
   * @example
   * i-bp18qljorblo8es*****
   */
  nodeIp?: string;
  /**
   * @remarks
   * The number of rows to return on each page.  
   * - Maximum value: 100  
   * - Default value: 10
   * 
   * @example
   * 10
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of the page to return.    
   * - Start value: 1   
   * - Default value: 1
   * 
   * @example
   * 1
   */
  pageSize?: number;
  /**
   * @remarks
   * The SQL ID, which uniquely identifies an SQL statement.
   * 
   * @example
   * 8D6E84****0B8FB1823D199E2CA1****
   */
  SQLId?: string;
  /**
   * @remarks
   * The search keyword.
   * 
   * @example
   * update
   */
  searchKeyWord?: string;
  /**
   * @remarks
   * The search parameter.
   * 
   * @example
   * cputime
   */
  searchParameter?: string;
  /**
   * @remarks
   * The search rule.
   * 
   * @example
   * >
   */
  searchRule?: string;
  /**
   * @remarks
   * The search value.
   * 
   * @example
   * 0.01
   */
  searchValue?: string;
  /**
   * @remarks
   * The sorted column.
   * 
   * @example
   * cputime
   */
  sortColumn?: string;
  /**
   * @remarks
   * The sorting rule.
   * 
   * @example
   * desc
   */
  sortOrder?: string;
  /**
   * @remarks
   * The start time of the time range for querying slow SQL statements.   
   * The value must be UTC time in the format of YYYY-MM-DDThh:mm:ssZ.
   * 
   * This parameter is required.
   * 
   * @example
   * 2021-06-13T15:40:43Z
   */
  startTime?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * t2mr3oae0****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      dbName: 'DbName',
      endTime: 'EndTime',
      filterConditionShrink: 'FilterCondition',
      nodeIp: 'NodeIp',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      SQLId: 'SQLId',
      searchKeyWord: 'SearchKeyWord',
      searchParameter: 'SearchParameter',
      searchRule: 'SearchRule',
      searchValue: 'SearchValue',
      sortColumn: 'SortColumn',
      sortOrder: 'SortOrder',
      startTime: 'StartTime',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbName: 'string',
      endTime: 'string',
      filterConditionShrink: 'string',
      nodeIp: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      SQLId: 'string',
      searchKeyWord: 'string',
      searchParameter: 'string',
      searchRule: 'string',
      searchValue: 'string',
      sortColumn: 'string',
      sortOrder: 'string',
      startTime: 'string',
      tenantId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSlowSQLListResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E
   */
  requestId?: string;
  /**
   * @remarks
   * The list of slow SQL statements.
   */
  slowSQLList?: DescribeSlowSQLListResponseBodySlowSQLList[];
  /**
   * @remarks
   * The total count.
   * 
   * @example
   * 2
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      slowSQLList: 'SlowSQLList',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      slowSQLList: { 'type': 'array', 'itemType': DescribeSlowSQLListResponseBodySlowSQLList },
      totalCount: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.slowSQLList)) {
      $dara.Model.validateArray(this.slowSQLList);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSlowSQLListResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeSlowSQLListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSlowSQLListResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSqlAuditStatRequest extends $dara.Model {
  /**
   * @example
   * 2025-01-14T03:34:49Z
   */
  endTime?: string;
  /**
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 1
   */
  pageSize?: number;
  /**
   * @example
   * 2025-01-14T02:34:49Z
   */
  startTime?: string;
  /**
   * @example
   * t33h8y08k****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      instanceId: 'InstanceId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      startTime: 'StartTime',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      instanceId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      startTime: 'string',
      tenantId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSqlAuditStatResponseBody extends $dara.Model {
  data?: DescribeSqlAuditStatResponseBodyData[];
  /**
   * @remarks
   * Id of the request
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': DescribeSqlAuditStatResponseBodyData },
      requestId: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.data)) {
      $dara.Model.validateArray(this.data);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSqlAuditStatResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeSqlAuditStatResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSqlAuditStatResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStandbyCreateModeRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * ob4wibn0abo9uo
   */
  instanceId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * txxxxxxx
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      tenantId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStandbyCreateModeResponseBody extends $dara.Model {
  data?: DescribeStandbyCreateModeResponseBodyData;
  /**
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: DescribeStandbyCreateModeResponseBodyData,
      requestId: 'string',
    };
  }

  validate() {
    if(this.data && typeof (this.data as any).validate === 'function') {
      (this.data as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStandbyCreateModeResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeStandbyCreateModeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeStandbyCreateModeResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTagValuesRequest extends $dara.Model {
  /**
   * @remarks
   * The type of the resource.
   * 
   * This parameter is required.
   * 
   * @example
   * tag
   */
  resourceType?: string;
  static names(): { [key: string]: string } {
    return {
      resourceType: 'ResourceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceType: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTagValuesResponseBody extends $dara.Model {
  /**
   * @remarks
   * The mappings between tag groups and tags.
   * 
   * @example
   * "{\\"Tag group 2\\":[\\"Tag 2-1\\",\\"Tag 2-2\\"],\\"Tag group 1\\":[\\"Tag 1-1\\"]}"
   */
  map?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 4C91F7BA-xxxx-xxxx-xxxx-846ECA1A9908
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      map: 'Map',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      map: 'string',
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTagValuesResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeTagValuesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeTagValuesResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantRequest extends $dara.Model {
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * ob2mr3oae0****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      tenantId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantResponseBody extends $dara.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @remarks
   * The information about the tenant.
   */
  tenant?: DescribeTenantResponseBodyTenant;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      tenant: 'Tenant',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      tenant: DescribeTenantResponseBodyTenant,
    };
  }

  validate() {
    if(this.tenant && typeof (this.tenant as any).validate === 'function') {
      (this.tenant as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeTenantResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeTenantResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantEncryptionRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * t4louaeei****
   */
  tenantId?: string;
  /**
   * @example
   * forMySQLTenant
   */
  tenantName?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      tenantId: 'TenantId',
      tenantName: 'TenantName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      tenantId: 'string',
      tenantName: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantEncryptionResponseBody extends $dara.Model {
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  tenantEncryptions?: DescribeTenantEncryptionResponseBodyTenantEncryptions[];
  /**
   * @example
   * 8
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      tenantEncryptions: 'TenantEncryptions',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      tenantEncryptions: { 'type': 'array', 'itemType': DescribeTenantEncryptionResponseBodyTenantEncryptions },
      totalCount: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.tenantEncryptions)) {
      $dara.Model.validateArray(this.tenantEncryptions);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantEncryptionResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeTenantEncryptionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeTenantEncryptionResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantMetricsRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 2021-06-13T15:45:43Z
   */
  endTime?: string;
  /**
   * @remarks
   * 2021-06-13T15:40:43Z
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * {"name":"DescribeTenantMetrics","product":"OceanBasePro","version":"2019-09-01","path":"/","deprecated":0,"method":"POST|GET","protocol":"HTTP|HTTPS","hidden":0,"timeout":10000,"parameter_type":"Single","params":"[{\\"name\\":\\"Action\\",\\"position\\":\\"Query\\",\\"required\\":true,\\"checkBlank\\":false,\\"visibility\\":\\"Public\\",\\"deprecated\\":false,\\"type\\":\\"String\\",\\"description\\":\\"\\",\\"example\\":\\"DescribeTenantMetrics\\"},{\\"name\\":\\"InstanceId\\",\\"position\\":\\"Body\\",\\"required\\":true,\\"checkBlank\\":false,\\"visibility\\":\\"Public\\",\\"deprecated\\":false,\\"type\\":\\"String\\",\\"title\\":\\"\\",\\"description\\":\\"\\",\\"example\\":\\"ob317v4uif****\\"},{\\"name\\":\\"PageSize\\",\\"position\\":\\"Body\\",\\"required\\":false,\\"checkBlank\\":false,\\"visibility\\":\\"Public\\",\\"deprecated\\":false,\\"type\\":\\"Integer\\",\\"title\\":\\"\\",\\"description\\":\\"\\",\\"example\\":\\"10\\"},{\\"name\\":\\"PageNumber\\",\\"position\\":\\"Body\\",\\"required\\":false,\\"checkBlank\\":false,\\"visibility\\":\\"Public\\",\\"deprecated\\":false,\\"type\\":\\"Integer\\",\\"title\\":\\"\\",\\"description\\":\\"\\",\\"example\\":\\"1\\"},{\\"name\\":\\"TenantName\\",\\"position\\":\\"Body\\",\\"required\\":false,\\"checkBlank\\":false,\\"visibility\\":\\"Public\\",\\"deprecated\\":true,\\"type\\":\\"String\\",\\"title\\":\\"\\",\\"description\\":\\"\\",\\"example\\":\\"pay_online\\"},{\\"name\\":\\"StartTime\\",\\"position\\":\\"Body\\",\\"required\\":true,\\"checkBlank\\":false,\\"visibility\\":\\"Public\\",\\"deprecated\\":false,\\"type\\":\\"String\\",\\"title\\":\\"\\",\\"description\\":\\"\\",\\"example\\":\\"2021-06-13T15:40:43Z\\"},{\\"name\\":\\"EndTime\\",\\"position\\":\\"Body\\",\\"required\\":true,\\"checkBlank\\":false,\\"visibility\\":\\"Public\\",\\"deprecated\\":false,\\"type\\":\\"String\\",\\"title\\":\\"\\",\\"description\\":\\"\\",\\"example\\":\\"2021-06-13T15:45:43Z\\"},{\\"name\\":\\"Metrics\\",\\"position\\":\\"Body\\",\\"required\\":true,\\"checkBlank\\":false,\\"visibility\\":\\"Public\\",\\"deprecated\\":false,\\"type\\":\\"String\\",\\"title\\":\\"\\",\\"description\\":\\"\\",\\"example\\":\\"tps\\"},{\\"name\\":\\"TenantId\\",\\"position\\":\\"Body\\",\\"required\\":false,\\"checkBlank\\":false,\\"visibility\\":\\"Public\\",\\"deprecated\\":true,\\"type\\":\\"String\\",\\"title\\":\\"\\",\\"description\\":\\"\\",\\"example\\":\\"tfafd34fs****\\"},{\\"name\\":\\"TenantIdList\\",\\"position\\":\\"Body\\",\\"required\\":false,\\"checkBlank\\":false,\\"visibility\\":\\"Public\\",\\"deprecated\\":false,\\"type\\":\\"String\\",\\"title\\":\\"\\",\\"description\\":\\"\\",\\"example\\":\\"[tdak3nac****,tdakc42df****]\\"}]","response_headers":"[]","response":"{\\"type\\":\\"Object\\",\\"children\\":[{\\"name\\":\\"TotalCount\\",\\"required\\":false,\\"checkBlank\\":false,\\"visibility\\":\\"Public\\",\\"deprecated\\":false,\\"type\\":\\"Integer\\",\\"title\\":\\"\\",\\"description\\":\\"\\",\\"example\\":\\"9\\"},{\\"name\\":\\"RequestId\\",\\"required\\":false,\\"checkBlank\\":false,\\"visibility\\":\\"Public\\",\\"deprecated\\":false,\\"type\\":\\"String\\",\\"title\\":\\"\\",\\"description\\":\\"\\",\\"example\\":\\"EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C\\"},{\\"name\\":\\"TenantMetrics\\",\\"required\\":false,\\"checkBlank\\":false,\\"visibility\\":\\"Public\\",\\"deprecated\\":false,\\"type\\":\\"String\\",\\"title\\":\\"\\",\\"description\\":\\"\\",\\"example\\":\\"\\\\\\"Metrics\\\\\\":[ {\\\\\\"request_queue_rt\\\\\\":0.0,\\\\\\"TimeStamp\\\\\\":\\\\\\"2022-02-23T01:58:00Z\\\\\\"}]\\"}],\\"title\\":\\"\\",\\"description\\":\\"\\"}","errors":"{}"}
   * 
   * This parameter is required.
   * 
   * @example
   * tps
   */
  metrics?: string;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * tfafd34fs****
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * Example 1
   * 
   * This parameter is required.
   * 
   * @example
   * 2021-06-13T15:40:43Z
   */
  startTime?: string;
  /**
   * @example
   * tfafd34fs****
   * 
   * @deprecated
   */
  tenantId?: string;
  /**
   * @example
   * [tdak3nac****,tdakc42df****]
   */
  tenantIdList?: string;
  /**
   * @remarks
   * 2021-06-13T15:45:43Z
   * 
   * @example
   * pay_online
   * 
   * @deprecated
   */
  tenantName?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      instanceId: 'InstanceId',
      metrics: 'Metrics',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      startTime: 'StartTime',
      tenantId: 'TenantId',
      tenantIdList: 'TenantIdList',
      tenantName: 'TenantName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      instanceId: 'string',
      metrics: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      startTime: 'string',
      tenantId: 'string',
      tenantIdList: 'string',
      tenantName: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantMetricsResponseBody extends $dara.Model {
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @example
   * "Metrics":[ {"request_queue_rt":0.0,"TimeStamp":"2022-02-23T01:58:00Z"}]
   */
  tenantMetrics?: string;
  /**
   * @example
   * 9
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      tenantMetrics: 'TenantMetrics',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      tenantMetrics: 'string',
      totalCount: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantMetricsResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeTenantMetricsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeTenantMetricsResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantReadableScnRequest extends $dara.Model {
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * t33h8y08k****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      tenantId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantReadableScnResponseBody extends $dara.Model {
  /**
   * @remarks
   * The data in the return result of the request.
   */
  data?: DescribeTenantReadableScnResponseBodyData;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 8442BB1E-3171-1192-B9DC-F6F4E53B2673
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: DescribeTenantReadableScnResponseBodyData,
      requestId: 'string',
    };
  }

  validate() {
    if(this.data && typeof (this.data as any).validate === 'function') {
      (this.data as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantReadableScnResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeTenantReadableScnResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeTenantReadableScnResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantSecurityConfigsRequest extends $dara.Model {
  /**
   * @remarks
   * The unique identifier of the security check.
   * 
   * @example
   * ****
   */
  checkId?: string;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * @example
   * t4louaeei****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      checkId: 'CheckId',
      instanceId: 'InstanceId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkId: 'string',
      instanceId: 'string',
      tenantId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantSecurityConfigsResponseBody extends $dara.Model {
  /**
   * @remarks
   * The list of parameters.
   */
  configs?: DescribeTenantSecurityConfigsResponseBodyConfigs;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 523E7183-****-590D-****-12DFD316614B
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      configs: 'Configs',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configs: DescribeTenantSecurityConfigsResponseBodyConfigs,
      requestId: 'string',
    };
  }

  validate() {
    if(this.configs && typeof (this.configs as any).validate === 'function') {
      (this.configs as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantSecurityConfigsResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeTenantSecurityConfigsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeTenantSecurityConfigsResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantSecurityIpGroupsRequest extends $dara.Model {
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * t4louaeei****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      tenantId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantSecurityIpGroupsResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 473469**-AA6F-4D**-B3DB-A***********
   */
  requestId?: string;
  /**
   * @remarks
   * The list of the whitelist groups.
   */
  securityIpGroups?: DescribeTenantSecurityIpGroupsResponseBodySecurityIpGroups[];
  /**
   * @remarks
   * The total number of the whitelist groups.
   * 
   * @example
   * 2
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      securityIpGroups: 'SecurityIpGroups',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      securityIpGroups: { 'type': 'array', 'itemType': DescribeTenantSecurityIpGroupsResponseBodySecurityIpGroups },
      totalCount: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.securityIpGroups)) {
      $dara.Model.validateArray(this.securityIpGroups);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantSecurityIpGroupsResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeTenantSecurityIpGroupsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeTenantSecurityIpGroupsResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantTagsRequest extends $dara.Model {
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The tags.
   * 
   * @example
   * [{"Key": "xxx", "Value", "xxx"}]
   */
  tags?: string;
  /**
   * @remarks
   * The JSON string of the tenant ID.
   * 
   * This parameter is required.
   * 
   * @example
   * ["t5r0x2f6q****", "t33h8y08k****", "t5r41rtl7****"]
   */
  tenantIds?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      tags: 'Tags',
      tenantIds: 'TenantIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      tags: 'string',
      tenantIds: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantTagsResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @remarks
   * The list of tags.
   */
  tagResources?: DescribeTenantTagsResponseBodyTagResources[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      tagResources: 'TagResources',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      tagResources: { 'type': 'array', 'itemType': DescribeTenantTagsResponseBodyTagResources },
    };
  }

  validate() {
    if(Array.isArray(this.tagResources)) {
      $dara.Model.validateArray(this.tagResources);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantTagsResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeTenantTagsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeTenantTagsResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantUserRolesRequest extends $dara.Model {
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The ID of the tenant. If you specify the ID of a tenant in MySQL mode, the privilege configuration of the regular user in MySQL mode is returned. If you specify the ID of a tenant in Oracle mode, the privilege configuration of the regular user in Oracle mode is returned.
   * 
   * @example
   * t4pnum****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      tenantId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantUserRolesResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @remarks
   * The list of roles of the user.   
   * Valid values: 
   * 
   * ReadWrite: a role that has the read and write privileges, namely ALL PRIVILEGES.
   * ReadOnly: a role that has only the read-only privilege SELECT.
   * DDL: a role that has DDL privileges such as CREATE, DROP, ALTER, SHOW VIEW, and CREATE VIEW.
   * DML: a role that has DML privileges such as SELECT, INSERT, UPDATE, DELETE, and SHOW VIEW.
   */
  role?: string[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      role: 'Role',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      role: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(Array.isArray(this.role)) {
      $dara.Model.validateArray(this.role);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantUserRolesResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeTenantUserRolesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeTenantUserRolesResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantUsersRequest extends $dara.Model {
  /**
   * @remarks
   * The database privileges of the account.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The return result of the request.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The return result of the request.
   * 
   * @example
   * pay
   */
  searchKey?: string;
  /**
   * @remarks
   * The return result of the request.
   * 
   * This parameter is required.
   * 
   * @example
   * ob2mr3oae0****
   */
  tenantId?: string;
  /**
   * @remarks
   * The operation that you want to perform.   
   * Set the value to **DescribeTenantUsers**.
   * 
   * @example
   * pay_test
   */
  userName?: string;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      searchKey: 'SearchKey',
      tenantId: 'TenantId',
      userName: 'UserName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      searchKey: 'string',
      tenantId: 'string',
      userName: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantUsersResponseBody extends $dara.Model {
  /**
   * @remarks
   * The name of the database account.
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @remarks
   * The type of the database account. Valid values:    
   * - Admin: the super administrator account.   
   * - NORMAL: a general account.
   */
  tenantUsers?: DescribeTenantUsersResponseBodyTenantUsers[];
  /**
   * @remarks
   * The role of the account.   
   * In Oracle mode, a role is a schema-level role. Valid values:  
   * - ReadWrite: a role that has the read and write privileges, including: CREATE TABLE, CREATE VIEW, CREATE PROCEDURE, CREATE SYNONYM, CREATE SEQUENCE, CREATE TRIGGER, CREATE TYPE, CREATE SESSION, EXECUTE ANY PROCEDURE, CREATE ANY OUTLINE, ALTER ANY OUTLINE, DROP ANY OUTLINE, CREATE ANY PROCEDURE, ALTER ANY PROCEDURE, DROP ANY PROCEDURE, CREATE ANY SEQUENCE, ALTER ANY SEQUENCE, DROP ANY SEQUENCE, CREATE ANY TYPE, ALTER ANY TYPE, DROP ANY TYPE, SYSKM, CREATE ANY TRIGGER, ALTER ANY TRIGGER, DROP ANY TRIGGER, CREATE PROFILE, ALTER PROFILE, and DROP PROFILE.  
   * - ReadOnly: a role that has only the read-only privilege SELECT.
   * In MySQL mode, a role is a database-level role. Valid values: 
   * - ReadWrite: a role that has the read and write privileges, namely ALL PRIVILEGES.   
   * - ReadOnly: a role that has only the read-only privilege SELECT.   
   * - DDL: a role that has the DDL privileges such as CREATE, DROP, ALTER, SHOW VIEW, and CREATE VIEW.   
   * - DML: a role that has the DML privileges such as SELECT, INSERT, UPDATE, DELETE, and SHOW VIEW.   
   * 
   * > <br>By default, an Oracle account has the read and write privileges on its own schema, which are not listed here.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      tenantUsers: 'TenantUsers',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      tenantUsers: { 'type': 'array', 'itemType': DescribeTenantUsersResponseBodyTenantUsers },
      totalCount: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.tenantUsers)) {
      $dara.Model.validateArray(this.tenantUsers);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantUsersResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeTenantUsersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeTenantUsersResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantZonesReadRequest extends $dara.Model {
  /**
   * @remarks
   * The zone information of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The return result of the request.
   * 
   * This parameter is required.
   * 
   * @example
   * ob2mr3oae0****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      tenantId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantZonesReadResponseBody extends $dara.Model {
  /**
   * @remarks
   * Indicates whether a read-only connection needs to be created for the zone.
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @remarks
   * The request ID.
   */
  tenantZones?: DescribeTenantZonesReadResponseBodyTenantZones[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      tenantZones: 'TenantZones',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      tenantZones: { 'type': 'array', 'itemType': DescribeTenantZonesReadResponseBodyTenantZones },
    };
  }

  validate() {
    if(Array.isArray(this.tenantZones)) {
      $dara.Model.validateArray(this.tenantZones);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantZonesReadResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeTenantZonesReadResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeTenantZonesReadResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantsRequest extends $dara.Model {
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The number of the page to return.   
   * Start value: 1
   * - Default value: 1
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of rows to return on each page.   
   * - Maximum value: 100.
   * - Default value: 10
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The search keyword.
   * 
   * @example
   * pay
   */
  searchKey?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * @example
   * ob2mr3oae0****
   */
  tenantId?: string;
  /**
   * @remarks
   * The name of the tenant.   
   * It must start with a letter or an underscore (_), and contain 2 to 20 characters, which can be uppercase letters, lowercase letters, digits, and underscores (_).  It cannot be set to sys.
   * 
   * @example
   * pay_online
   */
  tenantName?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      searchKey: 'SearchKey',
      tenantId: 'TenantId',
      tenantName: 'TenantName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      searchKey: 'string',
      tenantId: 'string',
      tenantName: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantsResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @remarks
   * The information of tenants.
   */
  tenants?: DescribeTenantsResponseBodyTenants[];
  /**
   * @remarks
   * The total number of tenants in the specified OceanBase cluster.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      tenants: 'Tenants',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      tenants: { 'type': 'array', 'itemType': DescribeTenantsResponseBodyTenants },
      totalCount: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.tenants)) {
      $dara.Model.validateArray(this.tenants);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTenantsResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeTenantsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeTenantsResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTimeZonesResponseBody extends $dara.Model {
  /**
   * @remarks
   * DescribeTimeZones
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @remarks
   * The description of the time zone.
   */
  timeZones?: DescribeTimeZonesResponseBodyTimeZones;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      timeZones: 'TimeZones',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      timeZones: DescribeTimeZonesResponseBodyTimeZones,
    };
  }

  validate() {
    if(this.timeZones && typeof (this.timeZones as any).validate === 'function') {
      (this.timeZones as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTimeZonesResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeTimeZonesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeTimeZonesResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTopSQLListRequest extends $dara.Model {
  /**
   * @remarks
   * The number of block index cache hits.
   * 
   * @example
   * testdb
   */
  dbName?: string;
  /**
   * @remarks
   * The SQL type.
   * 
   * This parameter is required.
   * 
   * @example
   * 2021-09-13T15:40:43Z
   */
  endTime?: string;
  /**
   * @remarks
   * The average number of logical reads of the SQL statement during the specified period of time.   
   * The value covers the numbers of reads of different caches and the number of disk I/Os. It is an important metric for measuring the SQL filtering performance.   
   * 
   * > <br> A higher ratio of the number of logical reads to the number of returned rows indicates poorer filtering performance. General causes include non-standard content written by SQL statements, non-standard table indexes created, and non-standard SQL execution plans.
   * 
   * @example
   * [dbName:sys]
   */
  filterCondition?: { [key: string]: any };
  /**
   * @remarks
   * The number of failures.
   * 
   * @example
   * i-bp19y05uq6xpacyqnlrc
   */
  nodeIp?: string;
  /**
   * @remarks
   * The queuing time, in ms.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of row cache hits.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The I/O wait time, in ms.
   * 
   * @example
   * 8D6E84****0B8FB1823D199E2CA1****
   */
  SQLId?: string;
  /**
   * @remarks
   * The number of retries.
   * 
   * @example
   * update
   */
  searchKeyWord?: string;
  /**
   * @remarks
   * SQLID.
   * 
   * @example
   * cputime
   */
  searchParameter?: string;
  /**
   * @remarks
   * The IP address of the client.
   * 
   * @example
   * >
   */
  searchRule?: string;
  /**
   * @remarks
   * The number of Bloom filter cache hits.
   * 
   * @example
   * 0.01
   */
  searchValue?: string;
  /**
   * @remarks
   * The number of rows read from the disk.
   * 
   * @example
   * cputime
   */
  sortColumn?: string;
  /**
   * @remarks
   * The list of top SQL statements.
   * 
   * @example
   * desc
   */
  sortOrder?: string;
  /**
   * @remarks
   * The maximum response time, in ms.
   * 
   * This parameter is required.
   * 
   * @example
   * 2021-06-13T15:40:43Z
   */
  startTime?: string;
  /**
   * @remarks
   * The average CPU time, in ms.
   * 
   * This parameter is required.
   * 
   * @example
   * t2mr3oae0****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      dbName: 'DbName',
      endTime: 'EndTime',
      filterCondition: 'FilterCondition',
      nodeIp: 'NodeIp',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      SQLId: 'SQLId',
      searchKeyWord: 'SearchKeyWord',
      searchParameter: 'SearchParameter',
      searchRule: 'SearchRule',
      searchValue: 'SearchValue',
      sortColumn: 'SortColumn',
      sortOrder: 'SortOrder',
      startTime: 'StartTime',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbName: 'string',
      endTime: 'string',
      filterCondition: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      nodeIp: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      SQLId: 'string',
      searchKeyWord: 'string',
      searchParameter: 'string',
      searchRule: 'string',
      searchValue: 'string',
      sortColumn: 'string',
      sortOrder: 'string',
      startTime: 'string',
      tenantId: 'string',
    };
  }

  validate() {
    if(this.filterCondition) {
      $dara.Model.validateMap(this.filterCondition);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTopSQLListShrinkRequest extends $dara.Model {
  /**
   * @remarks
   * The number of block index cache hits.
   * 
   * @example
   * testdb
   */
  dbName?: string;
  /**
   * @remarks
   * The SQL type.
   * 
   * This parameter is required.
   * 
   * @example
   * 2021-09-13T15:40:43Z
   */
  endTime?: string;
  /**
   * @remarks
   * The average number of logical reads of the SQL statement during the specified period of time.   
   * The value covers the numbers of reads of different caches and the number of disk I/Os. It is an important metric for measuring the SQL filtering performance.   
   * 
   * > <br> A higher ratio of the number of logical reads to the number of returned rows indicates poorer filtering performance. General causes include non-standard content written by SQL statements, non-standard table indexes created, and non-standard SQL execution plans.
   * 
   * @example
   * [dbName:sys]
   */
  filterConditionShrink?: string;
  /**
   * @remarks
   * The number of failures.
   * 
   * @example
   * i-bp19y05uq6xpacyqnlrc
   */
  nodeIp?: string;
  /**
   * @remarks
   * The queuing time, in ms.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of row cache hits.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The I/O wait time, in ms.
   * 
   * @example
   * 8D6E84****0B8FB1823D199E2CA1****
   */
  SQLId?: string;
  /**
   * @remarks
   * The number of retries.
   * 
   * @example
   * update
   */
  searchKeyWord?: string;
  /**
   * @remarks
   * SQLID.
   * 
   * @example
   * cputime
   */
  searchParameter?: string;
  /**
   * @remarks
   * The IP address of the client.
   * 
   * @example
   * >
   */
  searchRule?: string;
  /**
   * @remarks
   * The number of Bloom filter cache hits.
   * 
   * @example
   * 0.01
   */
  searchValue?: string;
  /**
   * @remarks
   * The number of rows read from the disk.
   * 
   * @example
   * cputime
   */
  sortColumn?: string;
  /**
   * @remarks
   * The list of top SQL statements.
   * 
   * @example
   * desc
   */
  sortOrder?: string;
  /**
   * @remarks
   * The maximum response time, in ms.
   * 
   * This parameter is required.
   * 
   * @example
   * 2021-06-13T15:40:43Z
   */
  startTime?: string;
  /**
   * @remarks
   * The average CPU time, in ms.
   * 
   * This parameter is required.
   * 
   * @example
   * t2mr3oae0****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      dbName: 'DbName',
      endTime: 'EndTime',
      filterConditionShrink: 'FilterCondition',
      nodeIp: 'NodeIp',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      SQLId: 'SQLId',
      searchKeyWord: 'SearchKeyWord',
      searchParameter: 'SearchParameter',
      searchRule: 'SearchRule',
      searchValue: 'SearchValue',
      sortColumn: 'SortColumn',
      sortOrder: 'SortOrder',
      startTime: 'StartTime',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbName: 'string',
      endTime: 'string',
      filterConditionShrink: 'string',
      nodeIp: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      SQLId: 'string',
      searchKeyWord: 'string',
      searchParameter: 'string',
      searchRule: 'string',
      searchValue: 'string',
      sortColumn: 'string',
      sortOrder: 'string',
      startTime: 'string',
      tenantId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTopSQLListResponseBody extends $dara.Model {
  /**
   * @remarks
   * Alibaba Cloud CLI
   * 
   * @example
   * 473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E
   */
  requestId?: string;
  /**
   * @remarks
   * The I/O wait time, in ms.
   */
  topSQLList?: DescribeTopSQLListResponseBodyTopSQLList[];
  /**
   * @remarks
   * It is an online CLI tool that allows you to quickly retrieve and debug APIs. It can dynamically generate executable SDK code samples.
   * 
   * @example
   * 9
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      topSQLList: 'TopSQLList',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      topSQLList: { 'type': 'array', 'itemType': DescribeTopSQLListResponseBodyTopSQLList },
      totalCount: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.topSQLList)) {
      $dara.Model.validateArray(this.topSQLList);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTopSQLListResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeTopSQLListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeTopSQLListResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeZonesRequest extends $dara.Model {
  /**
   * @example
   * x86
   */
  cpuArch?: string;
  /**
   * @remarks
   * The operation that you want to perform.   
   * Set the value to **DescribeZones**.
   * 
   * @example
   * single
   */
  deployType?: string;
  /**
   * @remarks
   * The deployment mode.
   * 
   * @example
   * NORMAL
   */
  series?: string;
  static names(): { [key: string]: string } {
    return {
      cpuArch: 'CpuArch',
      deployType: 'DeployType',
      series: 'Series',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cpuArch: 'string',
      deployType: 'string',
      series: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeZonesResponseBody extends $dara.Model {
  /**
   * @remarks
   * ```
   * http(s)://[Endpoint]/?Action=DescribeZones
   * &Series=normal
   * &DeployType=single
   * &Common request parameters
   * ```
   * 
   * @example
   * 473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E
   */
  requestId?: string;
  /**
   * @remarks
   * You can call this operation to learn of zones where a cluster can be created in an Alibaba Cloud region.
   */
  zones?: DescribeZonesResponseBodyZones[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      zones: 'Zones',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      zones: { 'type': 'array', 'itemType': DescribeZonesResponseBodyZones },
    };
  }

  validate() {
    if(Array.isArray(this.zones)) {
      $dara.Model.validateArray(this.zones);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeZonesResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeZonesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeZonesResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUploadOssUrlRequest extends $dara.Model {
  /**
   * @example
   * 10
   */
  effectiveTimeMinutes?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * CREATE_PROJECT
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      effectiveTimeMinutes: 'EffectiveTimeMinutes',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      effectiveTimeMinutes: 'number',
      type: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUploadOssUrlResponseBody extends $dara.Model {
  /**
   * @example
   * Contact the administrator.
   */
  advice?: string;
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  /**
   * @example
   * 278
   */
  cost?: string;
  data?: GetUploadOssUrlResponseBodyData;
  errorDetail?: GetUploadOssUrlResponseBodyErrorDetail;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 11
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      cost: 'Cost',
      data: 'Data',
      errorDetail: 'ErrorDetail',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      cost: 'string',
      data: GetUploadOssUrlResponseBodyData,
      errorDetail: GetUploadOssUrlResponseBodyErrorDetail,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  validate() {
    if(this.data && typeof (this.data as any).validate === 'function') {
      (this.data as any).validate();
    }
    if(this.errorDetail && typeof (this.errorDetail as any).validate === 'function') {
      (this.errorDetail as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUploadOssUrlResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetUploadOssUrlResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetUploadOssUrlResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class KillProcessListRequest extends $dara.Model {
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The list of the sessions that need to be closed.
   * 
   * This parameter is required.
   * 
   * @example
   * [{"ServerIp":"192.168.13.119","SessionId":"3221614618"}]
   */
  sessionList?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * t4louaeei****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      sessionList: 'SessionList',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      sessionList: 'string',
      tenantId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class KillProcessListResponseBody extends $dara.Model {
  /**
   * @remarks
   * The data returned.
   */
  data?: KillProcessListResponseBodyData[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': KillProcessListResponseBodyData },
      requestId: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.data)) {
      $dara.Model.validateArray(this.data);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class KillProcessListResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: KillProcessListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: KillProcessListResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAllLabelsResponseBody extends $dara.Model {
  /**
   * @example
   * Contact the administrator.
   */
  advice?: string;
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  /**
   * @example
   * 1
   */
  cost?: string;
  data?: ListAllLabelsResponseBodyData[];
  errorDetail?: ListAllLabelsResponseBodyErrorDetail;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 29
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      cost: 'Cost',
      data: 'Data',
      errorDetail: 'ErrorDetail',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      cost: 'string',
      data: { 'type': 'array', 'itemType': ListAllLabelsResponseBodyData },
      errorDetail: ListAllLabelsResponseBodyErrorDetail,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.data)) {
      $dara.Model.validateArray(this.data);
    }
    if(this.errorDetail && typeof (this.errorDetail as any).validate === 'function') {
      (this.errorDetail as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAllLabelsResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListAllLabelsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListAllLabelsResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataSourceRequest extends $dara.Model {
  /**
   * @example
   * descend
   */
  order?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: string;
  /**
   * @example
   * 10
   */
  pageSize?: string;
  /**
   * @example
   * GRATI****89278244
   */
  searchKey?: string;
  /**
   * @example
   * gmtCreate
   */
  sortField?: string;
  types?: string[];
  static names(): { [key: string]: string } {
    return {
      order: 'Order',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      searchKey: 'SearchKey',
      sortField: 'SortField',
      types: 'Types',
    };
  }

  static types(): { [key: string]: any } {
    return {
      order: 'string',
      pageNumber: 'string',
      pageSize: 'string',
      searchKey: 'string',
      sortField: 'string',
      types: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(Array.isArray(this.types)) {
      $dara.Model.validateArray(this.types);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataSourceShrinkRequest extends $dara.Model {
  /**
   * @example
   * descend
   */
  order?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: string;
  /**
   * @example
   * 10
   */
  pageSize?: string;
  /**
   * @example
   * GRATI****89278244
   */
  searchKey?: string;
  /**
   * @example
   * gmtCreate
   */
  sortField?: string;
  typesShrink?: string;
  static names(): { [key: string]: string } {
    return {
      order: 'Order',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      searchKey: 'SearchKey',
      sortField: 'SortField',
      typesShrink: 'Types',
    };
  }

  static types(): { [key: string]: any } {
    return {
      order: 'string',
      pageNumber: 'string',
      pageSize: 'string',
      searchKey: 'string',
      sortField: 'string',
      typesShrink: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataSourceResponseBody extends $dara.Model {
  /**
   * @example
   * Contact the administrator.
   */
  advice?: string;
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  /**
   * @example
   * 28
   */
  cost?: string;
  data?: ListDataSourceResponseBodyData[];
  errorDetail?: ListDataSourceResponseBodyErrorDetail;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 132
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      cost: 'Cost',
      data: 'Data',
      errorDetail: 'ErrorDetail',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      cost: 'string',
      data: { 'type': 'array', 'itemType': ListDataSourceResponseBodyData },
      errorDetail: ListDataSourceResponseBodyErrorDetail,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.data)) {
      $dara.Model.validateArray(this.data);
    }
    if(this.errorDetail && typeof (this.errorDetail as any).validate === 'function') {
      (this.errorDetail as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataSourceResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListDataSourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListDataSourceResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectFullVerifyResultRequest extends $dara.Model {
  destSchemas?: string[];
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  pageSize?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * np_4w5abs****
   */
  projectId?: string;
  sourceSchemas?: string[];
  /**
   * @example
   * FINISHED
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      destSchemas: 'DestSchemas',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      projectId: 'ProjectId',
      sourceSchemas: 'SourceSchemas',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      destSchemas: { 'type': 'array', 'itemType': 'string' },
      pageNumber: 'number',
      pageSize: 'number',
      projectId: 'string',
      sourceSchemas: { 'type': 'array', 'itemType': 'string' },
      status: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.destSchemas)) {
      $dara.Model.validateArray(this.destSchemas);
    }
    if(Array.isArray(this.sourceSchemas)) {
      $dara.Model.validateArray(this.sourceSchemas);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectFullVerifyResultShrinkRequest extends $dara.Model {
  destSchemasShrink?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  pageSize?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * np_4w5abs****
   */
  projectId?: string;
  sourceSchemasShrink?: string;
  /**
   * @example
   * FINISHED
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      destSchemasShrink: 'DestSchemas',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      projectId: 'ProjectId',
      sourceSchemasShrink: 'SourceSchemas',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      destSchemasShrink: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      projectId: 'string',
      sourceSchemasShrink: 'string',
      status: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectFullVerifyResultResponseBody extends $dara.Model {
  /**
   * @example
   * Contact the administrator.
   */
  advice?: string;
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  /**
   * @example
   * 1
   */
  cost?: string;
  data?: ListProjectFullVerifyResultResponseBodyData;
  errorDetail?: ListProjectFullVerifyResultResponseBodyErrorDetail;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      cost: 'Cost',
      data: 'Data',
      errorDetail: 'ErrorDetail',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      cost: 'string',
      data: ListProjectFullVerifyResultResponseBodyData,
      errorDetail: ListProjectFullVerifyResultResponseBodyErrorDetail,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  validate() {
    if(this.data && typeof (this.data as any).validate === 'function') {
      (this.data as any).validate();
    }
    if(this.errorDetail && typeof (this.errorDetail as any).validate === 'function') {
      (this.errorDetail as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectFullVerifyResultResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListProjectFullVerifyResultResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListProjectFullVerifyResultResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectModifyRecordsRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * np_598jmu****
   */
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectModifyRecordsResponseBody extends $dara.Model {
  /**
   * @example
   * Contact the administrator.
   */
  advice?: string;
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  /**
   * @example
   * 30
   */
  cost?: string;
  data?: ListProjectModifyRecordsResponseBodyData[];
  errorDetail?: ListProjectModifyRecordsResponseBodyErrorDetail;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 100
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      cost: 'Cost',
      data: 'Data',
      errorDetail: 'ErrorDetail',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      cost: 'string',
      data: { 'type': 'array', 'itemType': ListProjectModifyRecordsResponseBodyData },
      errorDetail: ListProjectModifyRecordsResponseBodyErrorDetail,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.data)) {
      $dara.Model.validateArray(this.data);
    }
    if(this.errorDetail && typeof (this.errorDetail as any).validate === 'function') {
      (this.errorDetail as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectModifyRecordsResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListProjectModifyRecordsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListProjectModifyRecordsResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectsRequest extends $dara.Model {
  labelIds?: string[];
  needRelatedInfo?: boolean;
  /**
   * @example
   * descend
   */
  order?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * np_4w****
   */
  searchKey?: string;
  sinkEndpointTypes?: string[];
  /**
   * @example
   * gmtCreate
   */
  sortField?: string;
  sourceEndpointTypes?: string[];
  status?: string[];
  /**
   * @example
   * MIGRATION
   */
  type?: string;
  /**
   * @example
   * false
   */
  visibleSubProject?: boolean;
  static names(): { [key: string]: string } {
    return {
      labelIds: 'LabelIds',
      needRelatedInfo: 'NeedRelatedInfo',
      order: 'Order',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      searchKey: 'SearchKey',
      sinkEndpointTypes: 'SinkEndpointTypes',
      sortField: 'SortField',
      sourceEndpointTypes: 'SourceEndpointTypes',
      status: 'Status',
      type: 'Type',
      visibleSubProject: 'VisibleSubProject',
    };
  }

  static types(): { [key: string]: any } {
    return {
      labelIds: { 'type': 'array', 'itemType': 'string' },
      needRelatedInfo: 'boolean',
      order: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      searchKey: 'string',
      sinkEndpointTypes: { 'type': 'array', 'itemType': 'string' },
      sortField: 'string',
      sourceEndpointTypes: { 'type': 'array', 'itemType': 'string' },
      status: { 'type': 'array', 'itemType': 'string' },
      type: 'string',
      visibleSubProject: 'boolean',
    };
  }

  validate() {
    if(Array.isArray(this.labelIds)) {
      $dara.Model.validateArray(this.labelIds);
    }
    if(Array.isArray(this.sinkEndpointTypes)) {
      $dara.Model.validateArray(this.sinkEndpointTypes);
    }
    if(Array.isArray(this.sourceEndpointTypes)) {
      $dara.Model.validateArray(this.sourceEndpointTypes);
    }
    if(Array.isArray(this.status)) {
      $dara.Model.validateArray(this.status);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectsShrinkRequest extends $dara.Model {
  labelIdsShrink?: string;
  needRelatedInfo?: boolean;
  /**
   * @example
   * descend
   */
  order?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * np_4w****
   */
  searchKey?: string;
  sinkEndpointTypesShrink?: string;
  /**
   * @example
   * gmtCreate
   */
  sortField?: string;
  sourceEndpointTypesShrink?: string;
  statusShrink?: string;
  /**
   * @example
   * MIGRATION
   */
  type?: string;
  /**
   * @example
   * false
   */
  visibleSubProject?: boolean;
  static names(): { [key: string]: string } {
    return {
      labelIdsShrink: 'LabelIds',
      needRelatedInfo: 'NeedRelatedInfo',
      order: 'Order',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      searchKey: 'SearchKey',
      sinkEndpointTypesShrink: 'SinkEndpointTypes',
      sortField: 'SortField',
      sourceEndpointTypesShrink: 'SourceEndpointTypes',
      statusShrink: 'Status',
      type: 'Type',
      visibleSubProject: 'VisibleSubProject',
    };
  }

  static types(): { [key: string]: any } {
    return {
      labelIdsShrink: 'string',
      needRelatedInfo: 'boolean',
      order: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      searchKey: 'string',
      sinkEndpointTypesShrink: 'string',
      sortField: 'string',
      sourceEndpointTypesShrink: 'string',
      statusShrink: 'string',
      type: 'string',
      visibleSubProject: 'boolean',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectsResponseBody extends $dara.Model {
  /**
   * @example
   * Contact the administrator.
   */
  advice?: string;
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  /**
   * @example
   * 1
   */
  cost?: string;
  data?: ListProjectsResponseBodyData[];
  errorDetail?: ListProjectsResponseBodyErrorDetail;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 4
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      cost: 'Cost',
      data: 'Data',
      errorDetail: 'ErrorDetail',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      cost: 'string',
      data: { 'type': 'array', 'itemType': ListProjectsResponseBodyData },
      errorDetail: ListProjectsResponseBodyErrorDetail,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.data)) {
      $dara.Model.validateArray(this.data);
    }
    if(this.errorDetail && typeof (this.errorDetail as any).validate === 'function') {
      (this.errorDetail as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectsResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListProjectsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListProjectsResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkerInstancesRequest extends $dara.Model {
  /**
   * @example
   * KAFKA
   */
  destType?: string;
  /**
   * @example
   * i4katz****
   */
  instanceName?: string;
  /**
   * @example
   * true
   */
  onlyBindable?: boolean;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * OCEANBASE
   */
  sourceType?: string;
  specs?: string[];
  static names(): { [key: string]: string } {
    return {
      destType: 'DestType',
      instanceName: 'InstanceName',
      onlyBindable: 'OnlyBindable',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      sourceType: 'SourceType',
      specs: 'Specs',
    };
  }

  static types(): { [key: string]: any } {
    return {
      destType: 'string',
      instanceName: 'string',
      onlyBindable: 'boolean',
      pageNumber: 'number',
      pageSize: 'number',
      sourceType: 'string',
      specs: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(Array.isArray(this.specs)) {
      $dara.Model.validateArray(this.specs);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkerInstancesShrinkRequest extends $dara.Model {
  /**
   * @example
   * KAFKA
   */
  destType?: string;
  /**
   * @example
   * i4katz****
   */
  instanceName?: string;
  /**
   * @example
   * true
   */
  onlyBindable?: boolean;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * OCEANBASE
   */
  sourceType?: string;
  specsShrink?: string;
  static names(): { [key: string]: string } {
    return {
      destType: 'DestType',
      instanceName: 'InstanceName',
      onlyBindable: 'OnlyBindable',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      sourceType: 'SourceType',
      specsShrink: 'Specs',
    };
  }

  static types(): { [key: string]: any } {
    return {
      destType: 'string',
      instanceName: 'string',
      onlyBindable: 'boolean',
      pageNumber: 'number',
      pageSize: 'number',
      sourceType: 'string',
      specsShrink: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkerInstancesResponseBody extends $dara.Model {
  /**
   * @example
   * null
   */
  advice?: string;
  /**
   * @example
   * 200
   */
  code?: string;
  /**
   * @example
   * 71
   */
  cost?: string;
  data?: ListWorkerInstancesResponseBodyData[];
  errorDetail?: ListWorkerInstancesResponseBodyErrorDetail;
  /**
   * @example
   * successful
   */
  message?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 237
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      cost: 'Cost',
      data: 'Data',
      errorDetail: 'ErrorDetail',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      cost: 'string',
      data: { 'type': 'array', 'itemType': ListWorkerInstancesResponseBodyData },
      errorDetail: ListWorkerInstancesResponseBodyErrorDetail,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.data)) {
      $dara.Model.validateArray(this.data);
    }
    if(this.errorDetail && typeof (this.errorDetail as any).validate === 'function') {
      (this.errorDetail as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkerInstancesResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListWorkerInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListWorkerInstancesResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDatabaseDescriptionRequest extends $dara.Model {
  /**
   * @remarks
   * Example 1
   * 
   * This parameter is required.
   * 
   * @example
   * sms_pre
   */
  databaseName?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * this is a test database
   */
  description?: string;
  /**
   * @remarks
   * The description of the database.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The operation that you want to perform.   
   * Set the value to **ModifyDatabaseDescription**.
   * 
   * This parameter is required.
   * 
   * @example
   * ob2mr3oae0****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      databaseName: 'DatabaseName',
      description: 'Description',
      instanceId: 'InstanceId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      databaseName: 'string',
      description: 'string',
      instanceId: 'string',
      tenantId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDatabaseDescriptionResponseBody extends $dara.Model {
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDatabaseDescriptionResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyDatabaseDescriptionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyDatabaseDescriptionResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDatabaseUserRolesRequest extends $dara.Model {
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * sms_pre
   */
  databaseName?: string;
  /**
   * @remarks
   * The account information.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * A list of usernames and their respective roles.
   * 
   * This parameter is required.
   * 
   * @example
   * ob2mr3oae0****
   */
  tenantId?: string;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * [{"UserName":"omstest","Role":"readwrite"}]
   */
  users?: string;
  static names(): { [key: string]: string } {
    return {
      databaseName: 'DatabaseName',
      instanceId: 'InstanceId',
      tenantId: 'TenantId',
      users: 'Users',
    };
  }

  static types(): { [key: string]: any } {
    return {
      databaseName: 'string',
      instanceId: 'string',
      tenantId: 'string',
      users: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDatabaseUserRolesResponseBody extends $dara.Model {
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @remarks
   * The name of the database.
   */
  tenantUser?: ModifyDatabaseUserRolesResponseBodyTenantUser;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      tenantUser: 'TenantUser',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      tenantUser: ModifyDatabaseUserRolesResponseBodyTenantUser,
    };
  }

  validate() {
    if(this.tenantUser && typeof (this.tenantUser as any).validate === 'function') {
      (this.tenantUser as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDatabaseUserRolesResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyDatabaseUserRolesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyDatabaseUserRolesResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceNameRequest extends $dara.Model {
  /**
   * @remarks
   * It is an Alibaba Cloud asset management and configuration tool, with which you can manage multiple Alibaba Cloud products and services by using commands. It is easy to use and a good helper in migration to cloud.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob4prod
   */
  instanceName?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      instanceName: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceNameResponseBody extends $dara.Model {
  /**
   * @remarks
   * The operation that you want to perform.   
   * Set the value to **ModifyInstanceName**.
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceNameResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyInstanceNameResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyInstanceNameResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceNodeNumRequest extends $dara.Model {
  /**
   * @remarks
   * Specifies whether to perform only a dry run for the request. Default value: false. Valid values:
   * - true: Only a dry-run request is sent and the number of nodes in the instance is not modified. If the dry run succeeds, DryRunResult=true is returned. If the dry run fails, an error code is returned.
   * - false: The actual request is sent and no dry run is performed. The number of nodes is changed if the requirements are met. By default, the DryRunResult parameter returns false if you set DryRun to false.
   * 
   * @example
   * true
   */
  dryRun?: boolean;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The number of nodes in the cluster. If the cluster is deployed in n-n-n mode, the number of nodes in the cluster equals n × 3.
   * 
   * This parameter is required.
   * 
   * @example
   * 6
   */
  nodeNum?: string;
  static names(): { [key: string]: string } {
    return {
      dryRun: 'DryRun',
      instanceId: 'InstanceId',
      nodeNum: 'NodeNum',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dryRun: 'boolean',
      instanceId: 'string',
      nodeNum: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceNodeNumResponseBody extends $dara.Model {
  /**
   * @remarks
   * The return result of the request.
   */
  data?: ModifyInstanceNodeNumResponseBodyData;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: ModifyInstanceNodeNumResponseBodyData,
      requestId: 'string',
    };
  }

  validate() {
    if(this.data && typeof (this.data as any).validate === 'function') {
      (this.data as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceNodeNumResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyInstanceNodeNumResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyInstanceNodeNumResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceSSLRequest extends $dara.Model {
  /**
   * @remarks
   * The operation to modify the SSL status. Valid values:
   * 
   * - open: Enable SSL encryption.
   * 
   * - update: Update the CA certificate.
   * 
   * - close: Disable SSL encryption.
   * 
   * This parameter is required.
   * 
   * @example
   * open
   */
  enableSSL?: string;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      enableSSL: 'EnableSSL',
      instanceId: 'InstanceId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enableSSL: 'string',
      instanceId: 'string',
      tenantId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceSSLResponseBody extends $dara.Model {
  /**
   * @remarks
   * The SSL setting of the OceanBase cluster instance.
   */
  instanceSSL?: ModifyInstanceSSLResponseBodyInstanceSSL;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceSSL: 'InstanceSSL',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceSSL: ModifyInstanceSSLResponseBodyInstanceSSL,
      requestId: 'string',
    };
  }

  validate() {
    if(this.instanceSSL && typeof (this.instanceSSL as any).validate === 'function') {
      (this.instanceSSL as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceSSLResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyInstanceSSLResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyInstanceSSLResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceSpecRequest extends $dara.Model {
  /**
   * @remarks
   * The size of the storage space, in GB. The required storage space varies based on the cluster specifications:
   * - 8C32G: 100 GB to 10 TB.
   * - 14C70G: 200 GB to 10 TB.
   * - 30C180G: 400 GB to 10 TB.
   * - 62C400G: 800 GB to 10 TB. The preceding minimum storage space sizes are the default storage space sizes of the corresponding cluster specification plans.
   * 
   * @example
   * 200
   */
  diskSize?: number;
  /**
   * @remarks
   * Disk type.
   * 
   * @example
   * cloud_essd_pl1
   */
  diskType?: string;
  /**
   * @remarks
   * Specifies whether to perform only a dry run for the request. Default value: false. Valid values:
   * - true: Only a dry-run request is sent and the instance settings are not modified. If the dry run succeeds, DryRunResult=true is returned. If the dry run fails, an error code is returned.
   * - false: If the DryRun parameter is set to false, no dry run is performed and the DryRunResult parameter returns false.
   * 
   * @example
   * false
   */
  dryRun?: boolean;
  /**
   * @remarks
   * The specifications of the cluster. You can specify one of the following four plans:
   * - 8C32GB: indicates 8 CPU cores and 32 GB of memory.
   * - 14C70GB: indicates 14 CPU cores and 70 GB of memory. This is the default value.
   * - 30C180GB: indicates 30 CPU cores and 180 GB of memory.
   * - 62C400GB: indicates 62 CPU cores and 400 GB of memory.
   * 
   * @example
   * 14C70GB
   */
  instanceClass?: string;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob3h8ytroxxxxx
   */
  instanceId?: string;
  upgradeSpecNative?: boolean;
  static names(): { [key: string]: string } {
    return {
      diskSize: 'DiskSize',
      diskType: 'DiskType',
      dryRun: 'DryRun',
      instanceClass: 'InstanceClass',
      instanceId: 'InstanceId',
      upgradeSpecNative: 'UpgradeSpecNative',
    };
  }

  static types(): { [key: string]: any } {
    return {
      diskSize: 'number',
      diskType: 'string',
      dryRun: 'boolean',
      instanceClass: 'string',
      instanceId: 'string',
      upgradeSpecNative: 'boolean',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceSpecResponseBody extends $dara.Model {
  /**
   * @remarks
   * The return data of the request.
   * 
   * @example
   * 1234567890
   */
  data?: ModifyInstanceSpecResponseBodyData;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: ModifyInstanceSpecResponseBodyData,
      requestId: 'string',
    };
  }

  validate() {
    if(this.data && typeof (this.data as any).validate === 'function') {
      (this.data as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceSpecResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyInstanceSpecResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyInstanceSpecResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceTagsRequest extends $dara.Model {
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The tags.
   * 
   * This parameter is required.
   * 
   * @example
   * [{"Key": "xxx", "Value", "xxx"},{}]
   */
  tags?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      tags: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceTagsResponseBody extends $dara.Model {
  /**
   * @remarks
   * The tag modification result.
   * 
   * @example
   * done
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      message: 'string',
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceTagsResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyInstanceTagsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyInstanceTagsResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceTemporaryCapacityRequest extends $dara.Model {
  /**
   * @example
   * zh-CN
   */
  acceptLanguage?: string;
  /**
   * @remarks
   * The disk size. Unit: GB.
   * 
   * @example
   * 400
   */
  diskSize?: string;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * Specification.
   * 
   * This parameter is required.
   * 
   * @example
   * oceanbase.cluster.i2.small
   */
  spec?: string;
  static names(): { [key: string]: string } {
    return {
      acceptLanguage: 'AcceptLanguage',
      diskSize: 'DiskSize',
      instanceId: 'InstanceId',
      spec: 'Spec',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptLanguage: 'string',
      diskSize: 'string',
      instanceId: 'string',
      spec: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceTemporaryCapacityResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceTemporaryCapacityResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyInstanceTemporaryCapacityResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyInstanceTemporaryCapacityResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyParametersRequest extends $dara.Model {
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * TENANT
   */
  dimension?: string;
  /**
   * @remarks
   * The cause of the modification failure.
   * 
   * @example
   * ob2mr3oae0****
   */
  dimensionValue?: string;
  /**
   * @remarks
   * Alibaba Cloud CLI
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The resource ID of the parameter type.    
   * You can leave this parameter unspecified when you call this operation to modify cluster parameters. In the case of tenant parameters, pass the tenant ID.
   * 
   * This parameter is required.
   * 
   * @example
   * [{"Name":"connect_timeout","Value":"20"}]
   */
  parameters?: string;
  static names(): { [key: string]: string } {
    return {
      dimension: 'Dimension',
      dimensionValue: 'DimensionValue',
      instanceId: 'InstanceId',
      parameters: 'Parameters',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dimension: 'string',
      dimensionValue: 'string',
      instanceId: 'string',
      parameters: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyParametersResponseBody extends $dara.Model {
  /**
   * @remarks
   * The operation that you want to perform.   
   * Set the value to **ModifyParameters**.
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @remarks
   * Example 1
   */
  results?: ModifyParametersResponseBodyResults;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      results: 'Results',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      results: ModifyParametersResponseBodyResults,
    };
  }

  validate() {
    if(this.results && typeof (this.results as any).validate === 'function') {
      (this.results as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyParametersResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyParametersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyParametersResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifySecurityIpsRequest extends $dara.Model {
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The information of the IP address whitelist group.
   * 
   * @example
   * paytest
   */
  securityIpGroupName?: string;
  /**
   * @remarks
   * The list of IP addresses and CIDR blocks in the whitelist.   
   * It is a JSON array. Each object in the array is an IP address or CIDR block. You can specify at most 40 IP addresses or CIDR blocks.
   * 
   * @example
   * ["192.168.0.0/20","192.169.1.1"]
   */
  securityIps?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      securityIpGroupName: 'SecurityIpGroupName',
      securityIps: 'SecurityIps',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      securityIpGroupName: 'string',
      securityIps: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifySecurityIpsResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @remarks
   * Example 1
   */
  securityIpGroup?: ModifySecurityIpsResponseBodySecurityIpGroup;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      securityIpGroup: 'SecurityIpGroup',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      securityIpGroup: ModifySecurityIpsResponseBodySecurityIpGroup,
    };
  }

  validate() {
    if(this.securityIpGroup && typeof (this.securityIpGroup as any).validate === 'function') {
      (this.securityIpGroup as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifySecurityIpsResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifySecurityIpsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifySecurityIpsResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTagNameRequest extends $dara.Model {
  /**
   * @remarks
   * The name of the tag group.
   * 
   * This parameter is required.
   * 
   * @example
   * Tag group 1
   */
  key?: string;
  /**
   * @remarks
   * The new name of the tag group.
   * 
   * This parameter is required.
   * 
   * @example
   * Tag group 2
   */
  newKey?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      newKey: 'NewKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      newKey: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTagNameResponseBody extends $dara.Model {
  /**
   * @remarks
   * The tag group renaming result.
   * 
   * @example
   * update tag name success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 4C91F7BA-xxxx-xxxx-xxxx-846ECA1A9908
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      message: 'string',
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTagNameResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyTagNameResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyTagNameResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTagValueNameRequest extends $dara.Model {
  /**
   * @remarks
   * The name of the tag group.
   * 
   * This parameter is required.
   * 
   * @example
   * Tag group 1
   */
  key?: string;
  /**
   * @remarks
   * The new name of the tag.
   * 
   * This parameter is required.
   * 
   * @example
   * Tag 2
   */
  newValue?: string;
  /**
   * @remarks
   * The name of the tag.
   * 
   * This parameter is required.
   * 
   * @example
   * Tag 1
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      newValue: 'NewValue',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      newValue: 'string',
      value: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTagValueNameResponseBody extends $dara.Model {
  /**
   * @remarks
   * The tag renaming result.
   * 
   * @example
   * update tag-value name success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 4C91F7BA-xxxx-xxxx-xxxx-846ECA1A9908
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      message: 'string',
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTagValueNameResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyTagValueNameResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyTagValueNameResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantEncryptionRequest extends $dara.Model {
  /**
   * @example
   * key-shh322****470h8v0-g2ll85****
   */
  encryptionKeyId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * EncryptionKey
   */
  encryptionType?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * ob2mr3oae0****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      encryptionKeyId: 'EncryptionKeyId',
      encryptionType: 'EncryptionType',
      instanceId: 'InstanceId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      encryptionKeyId: 'string',
      encryptionType: 'string',
      instanceId: 'string',
      tenantId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantEncryptionResponseBody extends $dara.Model {
  /**
   * @remarks
   * Id of the request
   * 
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @remarks
   * job
   */
  tenantEncryption?: ModifyTenantEncryptionResponseBodyTenantEncryption;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      tenantEncryption: 'TenantEncryption',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      tenantEncryption: ModifyTenantEncryptionResponseBodyTenantEncryption,
    };
  }

  validate() {
    if(this.tenantEncryption && typeof (this.tenantEncryption as any).validate === 'function') {
      (this.tenantEncryption as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantEncryptionResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyTenantEncryptionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyTenantEncryptionResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantPrimaryZoneRequest extends $dara.Model {
  /**
   * @remarks
   * The primary zone of the tenant.    
   * It is one of the zones in which the cluster is deployed.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * ```
   * http(s)://[Endpoint]/?Action=ModifyTenantPrimaryZone
   * &TenantId=ob2mr3oae0****
   * &InstanceId=ob317v4uif****
   * &PrimaryZone=cn-hangzhou-h
   * &Common request parameters
   * ```
   * 
   * @example
   * cn-hangzhou-h
   */
  masterIntranetAddressZone?: string;
  /**
   * @remarks
   * The ID of the vSwitch.
   * 
   * @example
   * cn-hangzhou-h
   */
  primaryZone?: string;
  tenantEndpointDirectId?: string;
  /**
   * @example
   * obe-4tw51gp7****
   */
  tenantEndpointId?: string;
  /**
   * @remarks
   * The return result of the request.
   * 
   * This parameter is required.
   * 
   * @example
   * ob2mr3oae0****
   */
  tenantId?: string;
  userDirectVSwitchId?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * vsw-xxx
   */
  userVSwitchId?: string;
  userVpcOwnerId?: string;
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      masterIntranetAddressZone: 'MasterIntranetAddressZone',
      primaryZone: 'PrimaryZone',
      tenantEndpointDirectId: 'TenantEndpointDirectId',
      tenantEndpointId: 'TenantEndpointId',
      tenantId: 'TenantId',
      userDirectVSwitchId: 'UserDirectVSwitchId',
      userVSwitchId: 'UserVSwitchId',
      userVpcOwnerId: 'UserVpcOwnerId',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      masterIntranetAddressZone: 'string',
      primaryZone: 'string',
      tenantEndpointDirectId: 'string',
      tenantEndpointId: 'string',
      tenantId: 'string',
      userDirectVSwitchId: 'string',
      userVSwitchId: 'string',
      userVpcOwnerId: 'string',
      vpcId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantPrimaryZoneResponseBody extends $dara.Model {
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantPrimaryZoneResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyTenantPrimaryZoneResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyTenantPrimaryZoneResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantResourceRequest extends $dara.Model {
  /**
   * @remarks
   * The information about the CPU resources of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * 2
   */
  cpu?: number;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The size of the log disk allocated to the tenant, in GB.
   * 
   * @example
   * 128
   */
  logDisk?: number;
  /**
   * @remarks
   * The memory size of the tenant, in GB.
   * 
   * This parameter is required.
   * 
   * @example
   * 2
   */
  memory?: number;
  /**
   * @remarks
   * Specifies to create a read-only zone. Separate the names of multiple zones with commas (,).
   * 
   * @example
   * cn-shanghai-g-ro,cn-shanghai-h-ro
   * 
   * @deprecated
   */
  readOnlyZoneList?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * ob2mr3oae0****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      cpu: 'Cpu',
      instanceId: 'InstanceId',
      logDisk: 'LogDisk',
      memory: 'Memory',
      readOnlyZoneList: 'ReadOnlyZoneList',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cpu: 'number',
      instanceId: 'string',
      logDisk: 'number',
      memory: 'number',
      readOnlyZoneList: 'string',
      tenantId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantResourceResponseBody extends $dara.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * @example
   * t33h8y08k****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      tenantId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantResourceResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyTenantResourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyTenantResourceResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantSecurityIpGroupRequest extends $dara.Model {
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The group name of the whitelist group of IP addresses.
   * 
   * It starts with lowercase letters and ends with lowercase letters or numbers. It can only contain lowercase letters, numbers, and underscores, and should be 2~32 characters in length.
   * 
   * This parameter is required.
   * 
   * @example
   * paytest
   */
  securityIpGroupName?: string;
  /**
   * @remarks
   * The list of IP addresses in the whitelist group.
   * 
   * It is a JSON array. Each object in the array is an IP address or a CIDR block. You can have up to 40 whitelists.
   * 
   * This parameter is required.
   * 
   * @example
   * 192.***.*.*"
   */
  securityIps?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * t4louaeei****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      securityIpGroupName: 'SecurityIpGroupName',
      securityIps: 'SecurityIps',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      securityIpGroupName: 'string',
      securityIps: 'string',
      tenantId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantSecurityIpGroupResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @remarks
   * The information of the IP address whitelist group.
   */
  securityIpGroup?: ModifyTenantSecurityIpGroupResponseBodySecurityIpGroup;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      securityIpGroup: 'SecurityIpGroup',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      securityIpGroup: ModifyTenantSecurityIpGroupResponseBodySecurityIpGroup,
    };
  }

  validate() {
    if(this.securityIpGroup && typeof (this.securityIpGroup as any).validate === 'function') {
      (this.securityIpGroup as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantSecurityIpGroupResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyTenantSecurityIpGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyTenantSecurityIpGroupResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantTagsRequest extends $dara.Model {
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The tags.
   * 
   * This parameter is required.
   * 
   * @example
   * [{"Key": "xxx", "Value", "xxx"}]
   */
  tags?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * t33h8y08k****
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      tags: 'Tags',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      tags: 'string',
      tenantId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantTagsResponseBody extends $dara.Model {
  /**
   * @remarks
   * The tag modification result.
   * 
   * @example
   * done
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      message: 'string',
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantTagsResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyTenantTagsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyTenantTagsResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantUserDescriptionRequest extends $dara.Model {
  /**
   * @remarks
   * The operation that you want to perform.   
   * Set the value to **ModifyTenantUserDescription**.
   * 
   * This parameter is required.
   * 
   * @example
   * this is a test database
   */
  description?: string;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * ob2mr3oae0****
   */
  tenantId?: string;
  /**
   * @remarks
   * The description of the database.
   * 
   * This parameter is required.
   * 
   * @example
   * pay_test
   */
  userName?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      instanceId: 'InstanceId',
      tenantId: 'TenantId',
      userName: 'UserName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      instanceId: 'string',
      tenantId: 'string',
      userName: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantUserDescriptionResponseBody extends $dara.Model {
  /**
   * @remarks
   * You can call this operation to modify the description of a specified account in a tenant.
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantUserDescriptionResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyTenantUserDescriptionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyTenantUserDescriptionResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantUserPasswordRequest extends $dara.Model {
  /**
   * @remarks
   * 加密方式。
   * 
   * @example
   * RSA
   */
  encryptionType?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * ```
   * http(s)://[Endpoint]/?Action=ModifyTenantUserPassword
   * &UserName=pay_test
   * &TenantId=ob2mr3oae0****
   * &UserPassword=!Aliyun4Oceanbase
   * &InstanceId=ob317v4uif****
   * &Common request parameters
   * ```
   * 
   * This parameter is required.
   * 
   * @example
   * ob2mr3oae0****
   */
  tenantId?: string;
  /**
   * @remarks
   * The ID of the OceanBase cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * pay_test
   */
  userName?: string;
  /**
   * @remarks
   * You can call this operation to change the logon password of a specified account in a tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * !Aliyun4Oceanbase
   */
  userPassword?: string;
  static names(): { [key: string]: string } {
    return {
      encryptionType: 'EncryptionType',
      instanceId: 'InstanceId',
      tenantId: 'TenantId',
      userName: 'UserName',
      userPassword: 'UserPassword',
    };
  }

  static types(): { [key: string]: any } {
    return {
      encryptionType: 'string',
      instanceId: 'string',
      tenantId: 'string',
      userName: 'string',
      userPassword: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantUserPasswordResponseBody extends $dara.Model {
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantUserPasswordResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyTenantUserPasswordResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyTenantUserPasswordResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantUserRolesRequest extends $dara.Model {
  globalPermissions?: string;
  /**
   * @remarks
   * The type of the privilege modification operation.   
   * Valid values:  
   * update: updates all privileges. This is the default value.  
   * add: adds a privilege.  
   * delete: deletes a privilege.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The name of the table.
   * 
   * @example
   * update
   */
  modifyType?: string;
  /**
   * @remarks
   * The operation that you want to perform.   
   * Set the value to **ModifyTenantUserRoles**.
   * 
   * This parameter is required.
   * 
   * @example
   * ob2mr3oae0****
   */
  tenantId?: string;
  /**
   * @remarks
   * The role of the database account.
   * 
   * This parameter is required.
   * 
   * @example
   * pay_test
   */
  userName?: string;
  /**
   * @remarks
   * The type of the account. Valid values:   
   * - Admin: the super administrator account.   
   * - Normal: a general account.
   * 
   * This parameter is required.
   * 
   * @example
   * [{"Database":"20210824160559","Role":"readwrite"}]
   */
  userRole?: string;
  /**
   * @example
   * Normal
   */
  userType?: string;
  static names(): { [key: string]: string } {
    return {
      globalPermissions: 'GlobalPermissions',
      instanceId: 'InstanceId',
      modifyType: 'ModifyType',
      tenantId: 'TenantId',
      userName: 'UserName',
      userRole: 'UserRole',
      userType: 'UserType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      globalPermissions: 'string',
      instanceId: 'string',
      modifyType: 'string',
      tenantId: 'string',
      userName: 'string',
      userRole: 'string',
      userType: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantUserRolesResponseBody extends $dara.Model {
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @remarks
   * The ID of the tenant.
   */
  tenantUser?: ModifyTenantUserRolesResponseBodyTenantUser;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      tenantUser: 'TenantUser',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      tenantUser: ModifyTenantUserRolesResponseBodyTenantUser,
    };
  }

  validate() {
    if(this.tenantUser && typeof (this.tenantUser as any).validate === 'function') {
      (this.tenantUser as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantUserRolesResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyTenantUserRolesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyTenantUserRolesResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantUserStatusRequest extends $dara.Model {
  /**
   * @remarks
   * The operation that you want to perform.   
   * Set the value to **ModifyTenantUserStatus**.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * ob2mr3oae0****
   */
  tenantId?: string;
  /**
   * @remarks
   * The list of database accounts in the tenant.
   * 
   * This parameter is required.
   * 
   * @example
   * pay_test
   */
  userName?: string;
  /**
   * @remarks
   * The status of the database account. Valid values:   
   * - Locked: The account is locked. 
   * - Online: The account is unlocked.
   * 
   * This parameter is required.
   * 
   * @example
   * The ID of the tenant.
   */
  userStatus?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      tenantId: 'TenantId',
      userName: 'UserName',
      userStatus: 'UserStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      tenantId: 'string',
      userName: 'string',
      userStatus: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantUserStatusResponseBody extends $dara.Model {
  /**
   * @remarks
   * Example 1
   * 
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  tenantUser?: ModifyTenantUserStatusResponseBodyTenantUser[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      tenantUser: 'TenantUser',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      tenantUser: { 'type': 'array', 'itemType': ModifyTenantUserStatusResponseBodyTenantUser },
    };
  }

  validate() {
    if(Array.isArray(this.tenantUser)) {
      $dara.Model.validateArray(this.tenantUser);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTenantUserStatusResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyTenantUserStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyTenantUserStatusResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleaseProjectRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * np_4w3a****
   */
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleaseProjectResponseBody extends $dara.Model {
  /**
   * @example
   * Contact the administrator.
   */
  advice?: string;
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  /**
   * @example
   * 1
   */
  cost?: string;
  /**
   * @example
   * null
   */
  data?: any;
  errorDetail?: ReleaseProjectResponseBodyErrorDetail;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 50
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      cost: 'Cost',
      data: 'Data',
      errorDetail: 'ErrorDetail',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      cost: 'string',
      data: 'any',
      errorDetail: ReleaseProjectResponseBodyErrorDetail,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  validate() {
    if(this.errorDetail && typeof (this.errorDetail as any).validate === 'function') {
      (this.errorDetail as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleaseProjectResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ReleaseProjectResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ReleaseProjectResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleaseWorkerInstanceRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * g_abcdefj***
   */
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleaseWorkerInstanceResponseBody extends $dara.Model {
  /**
   * @example
   * Contact the administrator.
   */
  advice?: string;
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  /**
   * @example
   * 30
   */
  cost?: string;
  /**
   * @example
   * null
   */
  data?: string;
  errorDetail?: ReleaseWorkerInstanceResponseBodyErrorDetail;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 100
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      cost: 'Cost',
      data: 'Data',
      errorDetail: 'ErrorDetail',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      cost: 'string',
      data: 'string',
      errorDetail: ReleaseWorkerInstanceResponseBodyErrorDetail,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  validate() {
    if(this.errorDetail && typeof (this.errorDetail as any).validate === 'function') {
      (this.errorDetail as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReleaseWorkerInstanceResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ReleaseWorkerInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ReleaseWorkerInstanceResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveStandbyInstanceRequest extends $dara.Model {
  /**
   * @example
   * false
   */
  forced?: boolean;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * ob608fgj1q****
   */
  instanceId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * ob4bv8o7sp****
   */
  targetInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      forced: 'Forced',
      instanceId: 'InstanceId',
      targetInstanceId: 'TargetInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      forced: 'boolean',
      instanceId: 'string',
      targetInstanceId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveStandbyInstanceResponseBody extends $dara.Model {
  /**
   * @remarks
   * Id of the request
   * 
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveStandbyInstanceResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RemoveStandbyInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RemoveStandbyInstanceResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResumeProjectRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * np_4w3a****
   */
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResumeProjectResponseBody extends $dara.Model {
  /**
   * @example
   * Contact the administrator.
   */
  advice?: string;
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  /**
   * @example
   * 1
   */
  cost?: string;
  /**
   * @example
   * null
   */
  data?: any;
  errorDetail?: ResumeProjectResponseBodyErrorDetail;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 50
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      cost: 'Cost',
      data: 'Data',
      errorDetail: 'ErrorDetail',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      cost: 'string',
      data: 'any',
      errorDetail: ResumeProjectResponseBodyErrorDetail,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  validate() {
    if(this.errorDetail && typeof (this.errorDetail as any).validate === 'function') {
      (this.errorDetail as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResumeProjectResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ResumeProjectResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ResumeProjectResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RetryProjectModifyRecordsRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 344000005
   */
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RetryProjectModifyRecordsResponseBody extends $dara.Model {
  /**
   * @example
   * Contact the administrator.
   */
  advice?: string;
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  /**
   * @example
   * 30
   */
  cost?: string;
  /**
   * @example
   * null
   */
  data?: any;
  errorDetail?: RetryProjectModifyRecordsResponseBodyErrorDetail;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 100
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      cost: 'Cost',
      data: 'Data',
      errorDetail: 'ErrorDetail',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      cost: 'string',
      data: 'any',
      errorDetail: RetryProjectModifyRecordsResponseBodyErrorDetail,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  validate() {
    if(this.errorDetail && typeof (this.errorDetail as any).validate === 'function') {
      (this.errorDetail as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RetryProjectModifyRecordsResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RetryProjectModifyRecordsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RetryProjectModifyRecordsResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartProjectRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * np_4w3a****
   */
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartProjectResponseBody extends $dara.Model {
  /**
   * @example
   * Contact the administrator.
   */
  advice?: string;
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  /**
   * @example
   * 1
   */
  cost?: string;
  /**
   * @example
   * null
   */
  data?: string;
  errorDetail?: StartProjectResponseBodyErrorDetail;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * XCVSADG****DSGDS
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 100
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      cost: 'Cost',
      data: 'Data',
      errorDetail: 'ErrorDetail',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      cost: 'string',
      data: 'string',
      errorDetail: StartProjectResponseBodyErrorDetail,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  validate() {
    if(this.errorDetail && typeof (this.errorDetail as any).validate === 'function') {
      (this.errorDetail as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartProjectResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: StartProjectResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StartProjectResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartProjectsByLabelRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * l_****
   */
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartProjectsByLabelResponseBody extends $dara.Model {
  /**
   * @example
   * Contact the administrator.
   */
  advice?: string;
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  /**
   * @example
   * 1
   */
  cost?: string;
  data?: StartProjectsByLabelResponseBodyData;
  errorDetail?: StartProjectsByLabelResponseBodyErrorDetail;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 79
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      cost: 'Cost',
      data: 'Data',
      errorDetail: 'ErrorDetail',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      cost: 'string',
      data: StartProjectsByLabelResponseBodyData,
      errorDetail: StartProjectsByLabelResponseBodyErrorDetail,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  validate() {
    if(this.data && typeof (this.data as any).validate === 'function') {
      (this.data as any).validate();
    }
    if(this.errorDetail && typeof (this.errorDetail as any).validate === 'function') {
      (this.errorDetail as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartProjectsByLabelResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: StartProjectsByLabelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StartProjectsByLabelResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopProjectRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * np_4w3a****
   */
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopProjectResponseBody extends $dara.Model {
  /**
   * @example
   * Contact the administrator.
   */
  advice?: string;
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  /**
   * @example
   * 27 ms
   */
  cost?: string;
  /**
   * @example
   * null
   */
  data?: string;
  errorDetail?: StopProjectResponseBodyErrorDetail;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * 473469**-AA6F-4D**-B3DB-A***********
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 100
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      cost: 'Cost',
      data: 'Data',
      errorDetail: 'ErrorDetail',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      cost: 'string',
      data: 'string',
      errorDetail: StopProjectResponseBodyErrorDetail,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  validate() {
    if(this.errorDetail && typeof (this.errorDetail as any).validate === 'function') {
      (this.errorDetail as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopProjectResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: StopProjectResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StopProjectResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopProjectModifyRecordsRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 344000005
   */
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopProjectModifyRecordsResponseBody extends $dara.Model {
  /**
   * @example
   * Contact the administrator.
   */
  advice?: string;
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  /**
   * @example
   * 30
   */
  cost?: string;
  /**
   * @example
   * null
   */
  data?: any;
  errorDetail?: StopProjectModifyRecordsResponseBodyErrorDetail;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * EE205C00-30E4-****-****-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 100
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      cost: 'Cost',
      data: 'Data',
      errorDetail: 'ErrorDetail',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      cost: 'string',
      data: 'any',
      errorDetail: StopProjectModifyRecordsResponseBodyErrorDetail,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  validate() {
    if(this.errorDetail && typeof (this.errorDetail as any).validate === 'function') {
      (this.errorDetail as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopProjectModifyRecordsResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: StopProjectModifyRecordsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StopProjectModifyRecordsResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopProjectsByLabelRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * l_****
   */
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopProjectsByLabelResponseBody extends $dara.Model {
  /**
   * @example
   * Contact the administrator.
   */
  advice?: string;
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  /**
   * @example
   * 1
   */
  cost?: string;
  data?: StopProjectsByLabelResponseBodyData;
  errorDetail?: StopProjectsByLabelResponseBodyErrorDetail;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * A595F34C-XXXX-5D0C-8DA8-B3ED76
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 140
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      cost: 'Cost',
      data: 'Data',
      errorDetail: 'ErrorDetail',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      cost: 'string',
      data: StopProjectsByLabelResponseBodyData,
      errorDetail: StopProjectsByLabelResponseBodyErrorDetail,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  validate() {
    if(this.data && typeof (this.data as any).validate === 'function') {
      (this.data as any).validate();
    }
    if(this.errorDetail && typeof (this.errorDetail as any).validate === 'function') {
      (this.errorDetail as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopProjectsByLabelResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: StopProjectsByLabelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StopProjectsByLabelResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SwitchoverInstanceRequest extends $dara.Model {
  /**
   * @remarks
   * Whether to force the switchover.
   * - true: Force the switchover.
   * - false: Do not force the switchover.
   * 
   * @example
   * true
   */
  forced?: boolean;
  /**
   * @remarks
   * The instance ID of the primary/standby instance. You can set the default value to the instance ID of the instance to be switched to the primary instance.
   * 
   * This parameter is required.
   * 
   * @example
   * ob317v4uif****
   */
  instanceId?: string;
  /**
   * @remarks
   * The instance ID of the instance to be switched to the primary instance.
   * 
   * This parameter is required.
   * 
   * @example
   * ob4bv8o7sp****
   */
  targetInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      forced: 'Forced',
      instanceId: 'InstanceId',
      targetInstanceId: 'TargetInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      forced: 'boolean',
      instanceId: 'string',
      targetInstanceId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SwitchoverInstanceResponseBody extends $dara.Model {
  /**
   * @remarks
   * The list of data for the switchover.
   */
  data?: SwitchoverInstanceResponseBodyData;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 473469**-AA6F-4D**-B3DB-A***********
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: SwitchoverInstanceResponseBodyData,
      requestId: 'string',
    };
  }

  validate() {
    if(this.data && typeof (this.data as any).validate === 'function') {
      (this.data as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SwitchoverInstanceResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SwitchoverInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SwitchoverInstanceResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProjectConfigRequest extends $dara.Model {
  commonTransferConfig?: UpdateProjectConfigRequestCommonTransferConfig;
  fullTransferConfig?: UpdateProjectConfigRequestFullTransferConfig;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * np_fe****
   */
  id?: string;
  incrTransferConfig?: UpdateProjectConfigRequestIncrTransferConfig;
  reverseIncrTransferConfig?: UpdateProjectConfigRequestReverseIncrTransferConfig;
  static names(): { [key: string]: string } {
    return {
      commonTransferConfig: 'CommonTransferConfig',
      fullTransferConfig: 'FullTransferConfig',
      id: 'Id',
      incrTransferConfig: 'IncrTransferConfig',
      reverseIncrTransferConfig: 'ReverseIncrTransferConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonTransferConfig: UpdateProjectConfigRequestCommonTransferConfig,
      fullTransferConfig: UpdateProjectConfigRequestFullTransferConfig,
      id: 'string',
      incrTransferConfig: UpdateProjectConfigRequestIncrTransferConfig,
      reverseIncrTransferConfig: UpdateProjectConfigRequestReverseIncrTransferConfig,
    };
  }

  validate() {
    if(this.commonTransferConfig && typeof (this.commonTransferConfig as any).validate === 'function') {
      (this.commonTransferConfig as any).validate();
    }
    if(this.fullTransferConfig && typeof (this.fullTransferConfig as any).validate === 'function') {
      (this.fullTransferConfig as any).validate();
    }
    if(this.incrTransferConfig && typeof (this.incrTransferConfig as any).validate === 'function') {
      (this.incrTransferConfig as any).validate();
    }
    if(this.reverseIncrTransferConfig && typeof (this.reverseIncrTransferConfig as any).validate === 'function') {
      (this.reverseIncrTransferConfig as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProjectConfigShrinkRequest extends $dara.Model {
  commonTransferConfigShrink?: string;
  fullTransferConfigShrink?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * np_fe****
   */
  id?: string;
  incrTransferConfigShrink?: string;
  reverseIncrTransferConfigShrink?: string;
  static names(): { [key: string]: string } {
    return {
      commonTransferConfigShrink: 'CommonTransferConfig',
      fullTransferConfigShrink: 'FullTransferConfig',
      id: 'Id',
      incrTransferConfigShrink: 'IncrTransferConfig',
      reverseIncrTransferConfigShrink: 'ReverseIncrTransferConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonTransferConfigShrink: 'string',
      fullTransferConfigShrink: 'string',
      id: 'string',
      incrTransferConfigShrink: 'string',
      reverseIncrTransferConfigShrink: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProjectConfigResponseBody extends $dara.Model {
  /**
   * @example
   * Contact the administrator.
   */
  advice?: string;
  /**
   * @example
   * INNER_ERROR
   */
  code?: string;
  /**
   * @example
   * 1
   */
  cost?: string;
  /**
   * @example
   * null
   */
  data?: string;
  errorDetail?: UpdateProjectConfigResponseBodyErrorDetail;
  /**
   * @example
   * A system error occurred.
   */
  message?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * EE205C00-30E4-XXXX-XXXX-87E3A8A2AA0C
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 100
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      cost: 'Cost',
      data: 'Data',
      errorDetail: 'ErrorDetail',
      message: 'Message',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      cost: 'string',
      data: 'string',
      errorDetail: UpdateProjectConfigResponseBodyErrorDetail,
      message: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  validate() {
    if(this.errorDetail && typeof (this.errorDetail as any).validate === 'function') {
      (this.errorDetail as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateProjectConfigResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateProjectConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateProjectConfigResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}


export default class Client extends OpenApi {

  constructor(config: $OpenApiUtil.Config) {
    super(config);
    this._endpointRule = "regional";
    this.checkConfig(config);
    this._endpoint = this.getEndpoint("oceanbasepro", this._regionId, this._endpointRule, this._network, this._suffix, this._endpointMap, this._endpoint);
  }


  getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: {[key: string ]: string}, endpoint: string): string {
    if (!$dara.isNull(endpoint)) {
      return endpoint;
    }

    if (!$dara.isNull(endpointMap) && !$dara.isNull(endpointMap[regionId])) {
      return endpointMap[regionId];
    }

    return OpenApiUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
  }

  /**
   * You can call this operation to close sessions in batches. Please note that this operation is executed asynchronously. After calling this operation, you need to verify it by calling DescribeProcessStatsComposition.
   * 
   * @param request - BatchKillProcessListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns BatchKillProcessListResponse
   */
  async batchKillProcessListWithOptions(request: BatchKillProcessListRequest, runtime: $dara.RuntimeOptions): Promise<BatchKillProcessListResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.sessionList)) {
      body["SessionList"] = request.sessionList;
    }

    if (!$dara.isNull(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "BatchKillProcessList",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<BatchKillProcessListResponse>(await this.callApi(params, req, runtime), new BatchKillProcessListResponse({}));
    } else {
      return $dara.cast<BatchKillProcessListResponse>(await this.execute(params, req, runtime), new BatchKillProcessListResponse({}));
    }

  }

  /**
   * You can call this operation to close sessions in batches. Please note that this operation is executed asynchronously. After calling this operation, you need to verify it by calling DescribeProcessStatsComposition.
   * 
   * @param request - BatchKillProcessListRequest
   * @returns BatchKillProcessListResponse
   */
  async batchKillProcessList(request: BatchKillProcessListRequest): Promise<BatchKillProcessListResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.batchKillProcessListWithOptions(request, runtime);
  }

  /**
   * You can call this operation to close sessions between the ApsaraDB for OceanBase and the application in batches. Please note that this operation is executed asynchronously. After calling this operation, you need to verify it by calling DescribeSessionList.
   * 
   * @param request - BatchKillSessionListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns BatchKillSessionListResponse
   */
  async batchKillSessionListWithOptions(request: BatchKillSessionListRequest, runtime: $dara.RuntimeOptions): Promise<BatchKillSessionListResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.sessionList)) {
      body["SessionList"] = request.sessionList;
    }

    if (!$dara.isNull(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "BatchKillSessionList",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<BatchKillSessionListResponse>(await this.callApi(params, req, runtime), new BatchKillSessionListResponse({}));
    } else {
      return $dara.cast<BatchKillSessionListResponse>(await this.execute(params, req, runtime), new BatchKillSessionListResponse({}));
    }

  }

  /**
   * You can call this operation to close sessions between the ApsaraDB for OceanBase and the application in batches. Please note that this operation is executed asynchronously. After calling this operation, you need to verify it by calling DescribeSessionList.
   * 
   * @param request - BatchKillSessionListRequest
   * @returns BatchKillSessionListResponse
   */
  async batchKillSessionList(request: BatchKillSessionListRequest): Promise<BatchKillSessionListResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.batchKillSessionListWithOptions(request, runtime);
  }

  /**
   * 根据记录id取消修改操作 （仅支持处于 PENDING 状态的修改记录）
   * 
   * @param request - CancelProjectModifyRecordRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CancelProjectModifyRecordResponse
   */
  async cancelProjectModifyRecordWithOptions(request: CancelProjectModifyRecordRequest, runtime: $dara.RuntimeOptions): Promise<CancelProjectModifyRecordResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.id)) {
      body["Id"] = request.id;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "CancelProjectModifyRecord",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<CancelProjectModifyRecordResponse>(await this.callApi(params, req, runtime), new CancelProjectModifyRecordResponse({}));
    } else {
      return $dara.cast<CancelProjectModifyRecordResponse>(await this.execute(params, req, runtime), new CancelProjectModifyRecordResponse({}));
    }

  }

  /**
   * 根据记录id取消修改操作 （仅支持处于 PENDING 状态的修改记录）
   * 
   * @param request - CancelProjectModifyRecordRequest
   * @returns CancelProjectModifyRecordResponse
   */
  async cancelProjectModifyRecord(request: CancelProjectModifyRecordRequest): Promise<CancelProjectModifyRecordResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.cancelProjectModifyRecordWithOptions(request, runtime);
  }

  /**
   * 创建备份任务下载链接
   * 
   * @param request - CreateBackupSetDownloadLinkRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateBackupSetDownloadLinkResponse
   */
  async createBackupSetDownloadLinkWithOptions(request: CreateBackupSetDownloadLinkRequest, runtime: $dara.RuntimeOptions): Promise<CreateBackupSetDownloadLinkResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.backupSetId)) {
      body["BackupSetId"] = request.backupSetId;
    }

    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateBackupSetDownloadLink",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<CreateBackupSetDownloadLinkResponse>(await this.callApi(params, req, runtime), new CreateBackupSetDownloadLinkResponse({}));
    } else {
      return $dara.cast<CreateBackupSetDownloadLinkResponse>(await this.execute(params, req, runtime), new CreateBackupSetDownloadLinkResponse({}));
    }

  }

  /**
   * 创建备份任务下载链接
   * 
   * @param request - CreateBackupSetDownloadLinkRequest
   * @returns CreateBackupSetDownloadLinkResponse
   */
  async createBackupSetDownloadLink(request: CreateBackupSetDownloadLinkRequest): Promise<CreateBackupSetDownloadLinkResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createBackupSetDownloadLinkWithOptions(request, runtime);
  }

  /**
   * The request ID.
   * 
   * @param request - CreateDatabaseRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateDatabaseResponse
   */
  async createDatabaseWithOptions(request: CreateDatabaseRequest, runtime: $dara.RuntimeOptions): Promise<CreateDatabaseResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.clientToken)) {
      body["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.collation)) {
      body["Collation"] = request.collation;
    }

    if (!$dara.isNull(request.databaseName)) {
      body["DatabaseName"] = request.databaseName;
    }

    if (!$dara.isNull(request.description)) {
      body["Description"] = request.description;
    }

    if (!$dara.isNull(request.encoding)) {
      body["Encoding"] = request.encoding;
    }

    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateDatabase",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<CreateDatabaseResponse>(await this.callApi(params, req, runtime), new CreateDatabaseResponse({}));
    } else {
      return $dara.cast<CreateDatabaseResponse>(await this.execute(params, req, runtime), new CreateDatabaseResponse({}));
    }

  }

  /**
   * The request ID.
   * 
   * @param request - CreateDatabaseRequest
   * @returns CreateDatabaseResponse
   */
  async createDatabase(request: CreateDatabaseRequest): Promise<CreateDatabaseResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createDatabaseWithOptions(request, runtime);
  }

  /**
   * You can call this operation to create an OceanBase cluster.
   * 
   * @param request - CreateInstanceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateInstanceResponse
   */
  async createInstanceWithOptions(request: CreateInstanceRequest, runtime: $dara.RuntimeOptions): Promise<CreateInstanceResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.autoRenew)) {
      body["AutoRenew"] = request.autoRenew;
    }

    if (!$dara.isNull(request.autoRenewPeriod)) {
      body["AutoRenewPeriod"] = request.autoRenewPeriod;
    }

    if (!$dara.isNull(request.chargeType)) {
      body["ChargeType"] = request.chargeType;
    }

    if (!$dara.isNull(request.cpuArch)) {
      body["CpuArch"] = request.cpuArch;
    }

    if (!$dara.isNull(request.diskSize)) {
      body["DiskSize"] = request.diskSize;
    }

    if (!$dara.isNull(request.diskType)) {
      body["DiskType"] = request.diskType;
    }

    if (!$dara.isNull(request.dryRun)) {
      body["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.instanceClass)) {
      body["InstanceClass"] = request.instanceClass;
    }

    if (!$dara.isNull(request.instanceName)) {
      body["InstanceName"] = request.instanceName;
    }

    if (!$dara.isNull(request.isolationOptimization)) {
      body["IsolationOptimization"] = request.isolationOptimization;
    }

    if (!$dara.isNull(request.obVersion)) {
      body["ObVersion"] = request.obVersion;
    }

    if (!$dara.isNull(request.period)) {
      body["Period"] = request.period;
    }

    if (!$dara.isNull(request.periodUnit)) {
      body["PeriodUnit"] = request.periodUnit;
    }

    if (!$dara.isNull(request.primaryInstance)) {
      body["PrimaryInstance"] = request.primaryInstance;
    }

    if (!$dara.isNull(request.primaryRegion)) {
      body["PrimaryRegion"] = request.primaryRegion;
    }

    if (!$dara.isNull(request.replicaMode)) {
      body["ReplicaMode"] = request.replicaMode;
    }

    if (!$dara.isNull(request.resourceGroupId)) {
      body["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!$dara.isNull(request.series)) {
      body["Series"] = request.series;
    }

    if (!$dara.isNull(request.zones)) {
      body["Zones"] = request.zones;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateInstance",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<CreateInstanceResponse>(await this.callApi(params, req, runtime), new CreateInstanceResponse({}));
    } else {
      return $dara.cast<CreateInstanceResponse>(await this.execute(params, req, runtime), new CreateInstanceResponse({}));
    }

  }

  /**
   * You can call this operation to create an OceanBase cluster.
   * 
   * @param request - CreateInstanceRequest
   * @returns CreateInstanceResponse
   */
  async createInstance(request: CreateInstanceRequest): Promise<CreateInstanceResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createInstanceWithOptions(request, runtime);
  }

  /**
   * 创建标签
   * 
   * @param request - CreateLabelRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateLabelResponse
   */
  async createLabelWithOptions(request: CreateLabelRequest, runtime: $dara.RuntimeOptions): Promise<CreateLabelResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.name)) {
      body["Name"] = request.name;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateLabel",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<CreateLabelResponse>(await this.callApi(params, req, runtime), new CreateLabelResponse({}));
    } else {
      return $dara.cast<CreateLabelResponse>(await this.execute(params, req, runtime), new CreateLabelResponse({}));
    }

  }

  /**
   * 创建标签
   * 
   * @param request - CreateLabelRequest
   * @returns CreateLabelResponse
   */
  async createLabel(request: CreateLabelRequest): Promise<CreateLabelResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createLabelWithOptions(request, runtime);
  }

  /**
   * 创建 MySQL 数据源
   * 
   * @param request - CreateMySqlDataSourceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateMySqlDataSourceResponse
   */
  async createMySqlDataSourceWithOptions(request: CreateMySqlDataSourceRequest, runtime: $dara.RuntimeOptions): Promise<CreateMySqlDataSourceResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.description)) {
      body["Description"] = request.description;
    }

    if (!$dara.isNull(request.dgInstanceId)) {
      body["DgInstanceId"] = request.dgInstanceId;
    }

    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.ip)) {
      body["Ip"] = request.ip;
    }

    if (!$dara.isNull(request.name)) {
      body["Name"] = request.name;
    }

    if (!$dara.isNull(request.password)) {
      body["Password"] = request.password;
    }

    if (!$dara.isNull(request.port)) {
      body["Port"] = request.port;
    }

    if (!$dara.isNull(request.schema)) {
      body["Schema"] = request.schema;
    }

    if (!$dara.isNull(request.type)) {
      body["Type"] = request.type;
    }

    if (!$dara.isNull(request.useSsl)) {
      body["UseSsl"] = request.useSsl;
    }

    if (!$dara.isNull(request.userName)) {
      body["UserName"] = request.userName;
    }

    if (!$dara.isNull(request.vpcId)) {
      body["VpcId"] = request.vpcId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateMySqlDataSource",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<CreateMySqlDataSourceResponse>(await this.callApi(params, req, runtime), new CreateMySqlDataSourceResponse({}));
    } else {
      return $dara.cast<CreateMySqlDataSourceResponse>(await this.execute(params, req, runtime), new CreateMySqlDataSourceResponse({}));
    }

  }

  /**
   * 创建 MySQL 数据源
   * 
   * @param request - CreateMySqlDataSourceRequest
   * @returns CreateMySqlDataSourceResponse
   */
  async createMySqlDataSource(request: CreateMySqlDataSourceRequest): Promise<CreateMySqlDataSourceResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createMySqlDataSourceWithOptions(request, runtime);
  }

  /**
   * 创建 OceanBase 数据源
   * 
   * @param request - CreateOceanBaseDataSourceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateOceanBaseDataSourceResponse
   */
  async createOceanBaseDataSourceWithOptions(request: CreateOceanBaseDataSourceRequest, runtime: $dara.RuntimeOptions): Promise<CreateOceanBaseDataSourceResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.cluster)) {
      body["Cluster"] = request.cluster;
    }

    if (!$dara.isNull(request.configUrl)) {
      body["ConfigUrl"] = request.configUrl;
    }

    if (!$dara.isNull(request.description)) {
      body["Description"] = request.description;
    }

    if (!$dara.isNull(request.drcPassword)) {
      body["DrcPassword"] = request.drcPassword;
    }

    if (!$dara.isNull(request.drcUserName)) {
      body["DrcUserName"] = request.drcUserName;
    }

    if (!$dara.isNull(request.innerDrcPassword)) {
      body["InnerDrcPassword"] = request.innerDrcPassword;
    }

    if (!$dara.isNull(request.ip)) {
      body["Ip"] = request.ip;
    }

    if (!$dara.isNull(request.logProxyIp)) {
      body["LogProxyIp"] = request.logProxyIp;
    }

    if (!$dara.isNull(request.logProxyPort)) {
      body["LogProxyPort"] = request.logProxyPort;
    }

    if (!$dara.isNull(request.name)) {
      body["Name"] = request.name;
    }

    if (!$dara.isNull(request.password)) {
      body["Password"] = request.password;
    }

    if (!$dara.isNull(request.port)) {
      body["Port"] = request.port;
    }

    if (!$dara.isNull(request.tenant)) {
      body["Tenant"] = request.tenant;
    }

    if (!$dara.isNull(request.type)) {
      body["Type"] = request.type;
    }

    if (!$dara.isNull(request.userName)) {
      body["UserName"] = request.userName;
    }

    if (!$dara.isNull(request.vpcId)) {
      body["VpcId"] = request.vpcId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateOceanBaseDataSource",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<CreateOceanBaseDataSourceResponse>(await this.callApi(params, req, runtime), new CreateOceanBaseDataSourceResponse({}));
    } else {
      return $dara.cast<CreateOceanBaseDataSourceResponse>(await this.execute(params, req, runtime), new CreateOceanBaseDataSourceResponse({}));
    }

  }

  /**
   * 创建 OceanBase 数据源
   * 
   * @param request - CreateOceanBaseDataSourceRequest
   * @returns CreateOceanBaseDataSourceResponse
   */
  async createOceanBaseDataSource(request: CreateOceanBaseDataSourceRequest): Promise<CreateOceanBaseDataSourceResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createOceanBaseDataSourceWithOptions(request, runtime);
  }

  /**
   * You can call this operation to create a MySQL data source.
   * 
   * @remarks
   * To call this operation, you must add the IP address of the OceanBase Migration Service (OMS) server to the whitelist of the Alibaba Cloud database instance, the security rules of the ECS instance, or the security settings of your self-managed database (usually the firewall of your self-managed database) to ensure that OMS can successfully access your database instance. To obtain the IP address of the OMS server, go to the OMS data source management page in the OMS console.
   * 
   * @param request - CreateOmsMysqlDataSourceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateOmsMysqlDataSourceResponse
   */
  async createOmsMysqlDataSourceWithOptions(request: CreateOmsMysqlDataSourceRequest, runtime: $dara.RuntimeOptions): Promise<CreateOmsMysqlDataSourceResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.description)) {
      body["Description"] = request.description;
    }

    if (!$dara.isNull(request.dgDatabaseId)) {
      body["DgDatabaseId"] = request.dgDatabaseId;
    }

    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.ip)) {
      body["Ip"] = request.ip;
    }

    if (!$dara.isNull(request.name)) {
      body["Name"] = request.name;
    }

    if (!$dara.isNull(request.password)) {
      body["Password"] = request.password;
    }

    if (!$dara.isNull(request.port)) {
      body["Port"] = request.port;
    }

    if (!$dara.isNull(request.schema)) {
      body["Schema"] = request.schema;
    }

    if (!$dara.isNull(request.type)) {
      body["Type"] = request.type;
    }

    if (!$dara.isNull(request.username)) {
      body["Username"] = request.username;
    }

    if (!$dara.isNull(request.vpcId)) {
      body["VpcId"] = request.vpcId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateOmsMysqlDataSource",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<CreateOmsMysqlDataSourceResponse>(await this.callApi(params, req, runtime), new CreateOmsMysqlDataSourceResponse({}));
    } else {
      return $dara.cast<CreateOmsMysqlDataSourceResponse>(await this.execute(params, req, runtime), new CreateOmsMysqlDataSourceResponse({}));
    }

  }

  /**
   * You can call this operation to create a MySQL data source.
   * 
   * @remarks
   * To call this operation, you must add the IP address of the OceanBase Migration Service (OMS) server to the whitelist of the Alibaba Cloud database instance, the security rules of the ECS instance, or the security settings of your self-managed database (usually the firewall of your self-managed database) to ensure that OMS can successfully access your database instance. To obtain the IP address of the OMS server, go to the OMS data source management page in the OMS console.
   * 
   * @param request - CreateOmsMysqlDataSourceRequest
   * @returns CreateOmsMysqlDataSourceResponse
   */
  async createOmsMysqlDataSource(request: CreateOmsMysqlDataSourceRequest): Promise<CreateOmsMysqlDataSourceResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createOmsMysqlDataSourceWithOptions(request, runtime);
  }

  /**
   * 创建项目
   * 
   * @param tmpReq - CreateProjectRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateProjectResponse
   */
  async createProjectWithOptions(tmpReq: CreateProjectRequest, runtime: $dara.RuntimeOptions): Promise<CreateProjectResponse> {
    tmpReq.validate();
    let request = new CreateProjectShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!$dara.isNull(tmpReq.commonTransferConfig)) {
      request.commonTransferConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.commonTransferConfig, "CommonTransferConfig", "json");
    }

    if (!$dara.isNull(tmpReq.fullTransferConfig)) {
      request.fullTransferConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.fullTransferConfig, "FullTransferConfig", "json");
    }

    if (!$dara.isNull(tmpReq.incrTransferConfig)) {
      request.incrTransferConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.incrTransferConfig, "IncrTransferConfig", "json");
    }

    if (!$dara.isNull(tmpReq.labelIds)) {
      request.labelIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.labelIds, "LabelIds", "json");
    }

    if (!$dara.isNull(tmpReq.reverseIncrTransferConfig)) {
      request.reverseIncrTransferConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.reverseIncrTransferConfig, "ReverseIncrTransferConfig", "json");
    }

    if (!$dara.isNull(tmpReq.structTransferConfig)) {
      request.structTransferConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.structTransferConfig, "StructTransferConfig", "json");
    }

    if (!$dara.isNull(tmpReq.transferMapping)) {
      request.transferMappingShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.transferMapping, "TransferMapping", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.commonTransferConfigShrink)) {
      body["CommonTransferConfig"] = request.commonTransferConfigShrink;
    }

    if (!$dara.isNull(request.enableFullTransfer)) {
      body["EnableFullTransfer"] = request.enableFullTransfer;
    }

    if (!$dara.isNull(request.enableFullVerify)) {
      body["EnableFullVerify"] = request.enableFullVerify;
    }

    if (!$dara.isNull(request.enableIncrTransfer)) {
      body["EnableIncrTransfer"] = request.enableIncrTransfer;
    }

    if (!$dara.isNull(request.enableReverseIncrTransfer)) {
      body["EnableReverseIncrTransfer"] = request.enableReverseIncrTransfer;
    }

    if (!$dara.isNull(request.enableStructTransfer)) {
      body["EnableStructTransfer"] = request.enableStructTransfer;
    }

    if (!$dara.isNull(request.fullTransferConfigShrink)) {
      body["FullTransferConfig"] = request.fullTransferConfigShrink;
    }

    if (!$dara.isNull(request.id)) {
      body["Id"] = request.id;
    }

    if (!$dara.isNull(request.incrTransferConfigShrink)) {
      body["IncrTransferConfig"] = request.incrTransferConfigShrink;
    }

    if (!$dara.isNull(request.labelIdsShrink)) {
      body["LabelIds"] = request.labelIdsShrink;
    }

    if (!$dara.isNull(request.name)) {
      body["Name"] = request.name;
    }

    if (!$dara.isNull(request.ossKey)) {
      body["OssKey"] = request.ossKey;
    }

    if (!$dara.isNull(request.reverseIncrTransferConfigShrink)) {
      body["ReverseIncrTransferConfig"] = request.reverseIncrTransferConfigShrink;
    }

    if (!$dara.isNull(request.sinkEndpointId)) {
      body["SinkEndpointId"] = request.sinkEndpointId;
    }

    if (!$dara.isNull(request.sourceEndpointId)) {
      body["SourceEndpointId"] = request.sourceEndpointId;
    }

    if (!$dara.isNull(request.structTransferConfigShrink)) {
      body["StructTransferConfig"] = request.structTransferConfigShrink;
    }

    if (!$dara.isNull(request.transferMappingShrink)) {
      body["TransferMapping"] = request.transferMappingShrink;
    }

    if (!$dara.isNull(request.type)) {
      body["Type"] = request.type;
    }

    if (!$dara.isNull(request.useOss)) {
      body["UseOss"] = request.useOss;
    }

    if (!$dara.isNull(request.workerGradeId)) {
      body["WorkerGradeId"] = request.workerGradeId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateProject",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<CreateProjectResponse>(await this.callApi(params, req, runtime), new CreateProjectResponse({}));
    } else {
      return $dara.cast<CreateProjectResponse>(await this.execute(params, req, runtime), new CreateProjectResponse({}));
    }

  }

  /**
   * 创建项目
   * 
   * @param request - CreateProjectRequest
   * @returns CreateProjectResponse
   */
  async createProject(request: CreateProjectRequest): Promise<CreateProjectResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createProjectWithOptions(request, runtime);
  }

  /**
   * 修改传输对象（加减表）(仅支持处于 RUNNING/FAILED/SUSPEND 状态的项目)
   * 
   * @param tmpReq - CreateProjectModifyRecordsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateProjectModifyRecordsResponse
   */
  async createProjectModifyRecordsWithOptions(tmpReq: CreateProjectModifyRecordsRequest, runtime: $dara.RuntimeOptions): Promise<CreateProjectModifyRecordsResponse> {
    tmpReq.validate();
    let request = new CreateProjectModifyRecordsShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!$dara.isNull(tmpReq.databases)) {
      request.databasesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.databases, "Databases", "json");
    }

    if (!$dara.isNull(tmpReq.transferMapping)) {
      request.transferMappingShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.transferMapping, "TransferMapping", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.databasesShrink)) {
      body["Databases"] = request.databasesShrink;
    }

    if (!$dara.isNull(request.id)) {
      body["Id"] = request.id;
    }

    if (!$dara.isNull(request.transferMappingShrink)) {
      body["TransferMapping"] = request.transferMappingShrink;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateProjectModifyRecords",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<CreateProjectModifyRecordsResponse>(await this.callApi(params, req, runtime), new CreateProjectModifyRecordsResponse({}));
    } else {
      return $dara.cast<CreateProjectModifyRecordsResponse>(await this.execute(params, req, runtime), new CreateProjectModifyRecordsResponse({}));
    }

  }

  /**
   * 修改传输对象（加减表）(仅支持处于 RUNNING/FAILED/SUSPEND 状态的项目)
   * 
   * @param request - CreateProjectModifyRecordsRequest
   * @returns CreateProjectModifyRecordsResponse
   */
  async createProjectModifyRecords(request: CreateProjectModifyRecordsRequest): Promise<CreateProjectModifyRecordsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createProjectModifyRecordsWithOptions(request, runtime);
  }

  /**
   * 创建RDS PG 数据源
   * 
   * @param request - CreateRdsPostgreSQLDataSourceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateRdsPostgreSQLDataSourceResponse
   */
  async createRdsPostgreSQLDataSourceWithOptions(request: CreateRdsPostgreSQLDataSourceRequest, runtime: $dara.RuntimeOptions): Promise<CreateRdsPostgreSQLDataSourceResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.databaseName)) {
      body["DatabaseName"] = request.databaseName;
    }

    if (!$dara.isNull(request.description)) {
      body["Description"] = request.description;
    }

    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.name)) {
      body["Name"] = request.name;
    }

    if (!$dara.isNull(request.password)) {
      body["Password"] = request.password;
    }

    if (!$dara.isNull(request.userName)) {
      body["UserName"] = request.userName;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateRdsPostgreSQLDataSource",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<CreateRdsPostgreSQLDataSourceResponse>(await this.callApi(params, req, runtime), new CreateRdsPostgreSQLDataSourceResponse({}));
    } else {
      return $dara.cast<CreateRdsPostgreSQLDataSourceResponse>(await this.execute(params, req, runtime), new CreateRdsPostgreSQLDataSourceResponse({}));
    }

  }

  /**
   * 创建RDS PG 数据源
   * 
   * @param request - CreateRdsPostgreSQLDataSourceRequest
   * @returns CreateRdsPostgreSQLDataSourceResponse
   */
  async createRdsPostgreSQLDataSource(request: CreateRdsPostgreSQLDataSourceRequest): Promise<CreateRdsPostgreSQLDataSourceResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createRdsPostgreSQLDataSourceWithOptions(request, runtime);
  }

  /**
   * The name of the whitelist group.
   * 
   * @param request - CreateSecurityIpGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateSecurityIpGroupResponse
   */
  async createSecurityIpGroupWithOptions(request: CreateSecurityIpGroupRequest, runtime: $dara.RuntimeOptions): Promise<CreateSecurityIpGroupResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.securityIpGroupName)) {
      body["SecurityIpGroupName"] = request.securityIpGroupName;
    }

    if (!$dara.isNull(request.securityIps)) {
      body["SecurityIps"] = request.securityIps;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateSecurityIpGroup",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<CreateSecurityIpGroupResponse>(await this.callApi(params, req, runtime), new CreateSecurityIpGroupResponse({}));
    } else {
      return $dara.cast<CreateSecurityIpGroupResponse>(await this.execute(params, req, runtime), new CreateSecurityIpGroupResponse({}));
    }

  }

  /**
   * The name of the whitelist group.
   * 
   * @param request - CreateSecurityIpGroupRequest
   * @returns CreateSecurityIpGroupResponse
   */
  async createSecurityIpGroup(request: CreateSecurityIpGroupRequest): Promise<CreateSecurityIpGroupResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createSecurityIpGroupWithOptions(request, runtime);
  }

  /**
   * You can call this operation to create a tag group.
   * 
   * @param request - CreateTagRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateTagResponse
   */
  async createTagWithOptions(request: CreateTagRequest, runtime: $dara.RuntimeOptions): Promise<CreateTagResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.clientToken)) {
      body["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.key)) {
      body["Key"] = request.key;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateTag",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<CreateTagResponse>(await this.callApi(params, req, runtime), new CreateTagResponse({}));
    } else {
      return $dara.cast<CreateTagResponse>(await this.execute(params, req, runtime), new CreateTagResponse({}));
    }

  }

  /**
   * You can call this operation to create a tag group.
   * 
   * @param request - CreateTagRequest
   * @returns CreateTagResponse
   */
  async createTag(request: CreateTagRequest): Promise<CreateTagResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createTagWithOptions(request, runtime);
  }

  /**
   * You can call this operation to create a tag.
   * 
   * @param request - CreateTagValueRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateTagValueResponse
   */
  async createTagValueWithOptions(request: CreateTagValueRequest, runtime: $dara.RuntimeOptions): Promise<CreateTagValueResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.clientToken)) {
      body["ClientToken"] = request.clientToken;
    }

    if (!$dara.isNull(request.key)) {
      body["Key"] = request.key;
    }

    if (!$dara.isNull(request.value)) {
      body["Value"] = request.value;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateTagValue",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<CreateTagValueResponse>(await this.callApi(params, req, runtime), new CreateTagValueResponse({}));
    } else {
      return $dara.cast<CreateTagValueResponse>(await this.execute(params, req, runtime), new CreateTagValueResponse({}));
    }

  }

  /**
   * You can call this operation to create a tag.
   * 
   * @param request - CreateTagValueRequest
   * @returns CreateTagValueResponse
   */
  async createTagValue(request: CreateTagValueRequest): Promise<CreateTagValueResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createTagValueWithOptions(request, runtime);
  }

  /**
   * You can call this operation to create a tenant.
   * 
   * @param tmpReq - CreateTenantRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateTenantResponse
   */
  async createTenantWithOptions(tmpReq: CreateTenantRequest, runtime: $dara.RuntimeOptions): Promise<CreateTenantResponse> {
    tmpReq.validate();
    let request = new CreateTenantShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!$dara.isNull(tmpReq.createParams)) {
      request.createParamsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.createParams, "CreateParams", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.charset)) {
      body["Charset"] = request.charset;
    }

    if (!$dara.isNull(request.cpu)) {
      body["Cpu"] = request.cpu;
    }

    if (!$dara.isNull(request.createParamsShrink)) {
      body["CreateParams"] = request.createParamsShrink;
    }

    if (!$dara.isNull(request.description)) {
      body["Description"] = request.description;
    }

    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.logDisk)) {
      body["LogDisk"] = request.logDisk;
    }

    if (!$dara.isNull(request.memory)) {
      body["Memory"] = request.memory;
    }

    if (!$dara.isNull(request.primaryZone)) {
      body["PrimaryZone"] = request.primaryZone;
    }

    if (!$dara.isNull(request.readOnlyZoneList)) {
      body["ReadOnlyZoneList"] = request.readOnlyZoneList;
    }

    if (!$dara.isNull(request.tenantMode)) {
      body["TenantMode"] = request.tenantMode;
    }

    if (!$dara.isNull(request.tenantName)) {
      body["TenantName"] = request.tenantName;
    }

    if (!$dara.isNull(request.timeZone)) {
      body["TimeZone"] = request.timeZone;
    }

    if (!$dara.isNull(request.unitNum)) {
      body["UnitNum"] = request.unitNum;
    }

    if (!$dara.isNull(request.userVSwitchId)) {
      body["UserVSwitchId"] = request.userVSwitchId;
    }

    if (!$dara.isNull(request.userVpcId)) {
      body["UserVpcId"] = request.userVpcId;
    }

    if (!$dara.isNull(request.userVpcOwnerId)) {
      body["UserVpcOwnerId"] = request.userVpcOwnerId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateTenant",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<CreateTenantResponse>(await this.callApi(params, req, runtime), new CreateTenantResponse({}));
    } else {
      return $dara.cast<CreateTenantResponse>(await this.execute(params, req, runtime), new CreateTenantResponse({}));
    }

  }

  /**
   * You can call this operation to create a tenant.
   * 
   * @param request - CreateTenantRequest
   * @returns CreateTenantResponse
   */
  async createTenant(request: CreateTenantRequest): Promise<CreateTenantResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createTenantWithOptions(request, runtime);
  }

  /**
   * The request ID.
   * 
   * @param request - CreateTenantReadOnlyConnectionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateTenantReadOnlyConnectionResponse
   */
  async createTenantReadOnlyConnectionWithOptions(request: CreateTenantReadOnlyConnectionRequest, runtime: $dara.RuntimeOptions): Promise<CreateTenantReadOnlyConnectionResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    if (!$dara.isNull(request.vSwitchId)) {
      body["VSwitchId"] = request.vSwitchId;
    }

    if (!$dara.isNull(request.vpcId)) {
      body["VpcId"] = request.vpcId;
    }

    if (!$dara.isNull(request.zoneId)) {
      body["ZoneId"] = request.zoneId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateTenantReadOnlyConnection",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<CreateTenantReadOnlyConnectionResponse>(await this.callApi(params, req, runtime), new CreateTenantReadOnlyConnectionResponse({}));
    } else {
      return $dara.cast<CreateTenantReadOnlyConnectionResponse>(await this.execute(params, req, runtime), new CreateTenantReadOnlyConnectionResponse({}));
    }

  }

  /**
   * The request ID.
   * 
   * @param request - CreateTenantReadOnlyConnectionRequest
   * @returns CreateTenantReadOnlyConnectionResponse
   */
  async createTenantReadOnlyConnection(request: CreateTenantReadOnlyConnectionRequest): Promise<CreateTenantReadOnlyConnectionResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createTenantReadOnlyConnectionWithOptions(request, runtime);
  }

  /**
   * You can call this operation to create the security whitelist for the tenant.
   * 
   * @param request - CreateTenantSecurityIpGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateTenantSecurityIpGroupResponse
   */
  async createTenantSecurityIpGroupWithOptions(request: CreateTenantSecurityIpGroupRequest, runtime: $dara.RuntimeOptions): Promise<CreateTenantSecurityIpGroupResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.securityIpGroupName)) {
      body["SecurityIpGroupName"] = request.securityIpGroupName;
    }

    if (!$dara.isNull(request.securityIps)) {
      body["SecurityIps"] = request.securityIps;
    }

    if (!$dara.isNull(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateTenantSecurityIpGroup",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<CreateTenantSecurityIpGroupResponse>(await this.callApi(params, req, runtime), new CreateTenantSecurityIpGroupResponse({}));
    } else {
      return $dara.cast<CreateTenantSecurityIpGroupResponse>(await this.execute(params, req, runtime), new CreateTenantSecurityIpGroupResponse({}));
    }

  }

  /**
   * You can call this operation to create the security whitelist for the tenant.
   * 
   * @param request - CreateTenantSecurityIpGroupRequest
   * @returns CreateTenantSecurityIpGroupResponse
   */
  async createTenantSecurityIpGroup(request: CreateTenantSecurityIpGroupRequest): Promise<CreateTenantSecurityIpGroupResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createTenantSecurityIpGroupWithOptions(request, runtime);
  }

  /**
   * CreateTenantUser
   * 
   * @param request - CreateTenantUserRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateTenantUserResponse
   */
  async createTenantUserWithOptions(request: CreateTenantUserRequest, runtime: $dara.RuntimeOptions): Promise<CreateTenantUserResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.description)) {
      body["Description"] = request.description;
    }

    if (!$dara.isNull(request.encryptionType)) {
      body["EncryptionType"] = request.encryptionType;
    }

    if (!$dara.isNull(request.globalPermissions)) {
      body["GlobalPermissions"] = request.globalPermissions;
    }

    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.roles)) {
      body["Roles"] = request.roles;
    }

    if (!$dara.isNull(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    if (!$dara.isNull(request.userName)) {
      body["UserName"] = request.userName;
    }

    if (!$dara.isNull(request.userPassword)) {
      body["UserPassword"] = request.userPassword;
    }

    if (!$dara.isNull(request.userType)) {
      body["UserType"] = request.userType;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateTenantUser",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<CreateTenantUserResponse>(await this.callApi(params, req, runtime), new CreateTenantUserResponse({}));
    } else {
      return $dara.cast<CreateTenantUserResponse>(await this.execute(params, req, runtime), new CreateTenantUserResponse({}));
    }

  }

  /**
   * CreateTenantUser
   * 
   * @param request - CreateTenantUserRequest
   * @returns CreateTenantUserResponse
   */
  async createTenantUser(request: CreateTenantUserRequest): Promise<CreateTenantUserResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createTenantUserWithOptions(request, runtime);
  }

  /**
   * 删除数据源
   * 
   * @param request - DeleteDataSourceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteDataSourceResponse
   */
  async deleteDataSourceWithOptions(request: DeleteDataSourceRequest, runtime: $dara.RuntimeOptions): Promise<DeleteDataSourceResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.id)) {
      body["Id"] = request.id;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteDataSource",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DeleteDataSourceResponse>(await this.callApi(params, req, runtime), new DeleteDataSourceResponse({}));
    } else {
      return $dara.cast<DeleteDataSourceResponse>(await this.execute(params, req, runtime), new DeleteDataSourceResponse({}));
    }

  }

  /**
   * 删除数据源
   * 
   * @param request - DeleteDataSourceRequest
   * @returns DeleteDataSourceResponse
   */
  async deleteDataSource(request: DeleteDataSourceRequest): Promise<DeleteDataSourceResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteDataSourceWithOptions(request, runtime);
  }

  /**
   * The request ID.
   * 
   * @param request - DeleteDatabasesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteDatabasesResponse
   */
  async deleteDatabasesWithOptions(request: DeleteDatabasesRequest, runtime: $dara.RuntimeOptions): Promise<DeleteDatabasesResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.databaseNames)) {
      body["DatabaseNames"] = request.databaseNames;
    }

    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteDatabases",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DeleteDatabasesResponse>(await this.callApi(params, req, runtime), new DeleteDatabasesResponse({}));
    } else {
      return $dara.cast<DeleteDatabasesResponse>(await this.execute(params, req, runtime), new DeleteDatabasesResponse({}));
    }

  }

  /**
   * The request ID.
   * 
   * @param request - DeleteDatabasesRequest
   * @returns DeleteDatabasesResponse
   */
  async deleteDatabases(request: DeleteDatabasesRequest): Promise<DeleteDatabasesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteDatabasesWithOptions(request, runtime);
  }

  /**
   * You can call this operation to release an OceanBase cluster.
   * 
   * @remarks
   * Before you call this operation, ensure that the following requirements are met:
   * - The cluster is in the Running state.
   * - The cluster is a primary cluster and the billing method is pay-as-you-go.
   * 
   * @param request - DeleteInstancesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteInstancesResponse
   */
  async deleteInstancesWithOptions(request: DeleteInstancesRequest, runtime: $dara.RuntimeOptions): Promise<DeleteInstancesResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.backupRetainMode)) {
      body["BackupRetainMode"] = request.backupRetainMode;
    }

    if (!$dara.isNull(request.dryRun)) {
      body["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.instanceIds)) {
      body["InstanceIds"] = request.instanceIds;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteInstances",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DeleteInstancesResponse>(await this.callApi(params, req, runtime), new DeleteInstancesResponse({}));
    } else {
      return $dara.cast<DeleteInstancesResponse>(await this.execute(params, req, runtime), new DeleteInstancesResponse({}));
    }

  }

  /**
   * You can call this operation to release an OceanBase cluster.
   * 
   * @remarks
   * Before you call this operation, ensure that the following requirements are met:
   * - The cluster is in the Running state.
   * - The cluster is a primary cluster and the billing method is pay-as-you-go.
   * 
   * @param request - DeleteInstancesRequest
   * @returns DeleteInstancesResponse
   */
  async deleteInstances(request: DeleteInstancesRequest): Promise<DeleteInstancesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteInstancesWithOptions(request, runtime);
  }

  /**
   * 删除项目
   * 
   * @param request - DeleteProjectRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteProjectResponse
   */
  async deleteProjectWithOptions(request: DeleteProjectRequest, runtime: $dara.RuntimeOptions): Promise<DeleteProjectResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.id)) {
      body["Id"] = request.id;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteProject",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DeleteProjectResponse>(await this.callApi(params, req, runtime), new DeleteProjectResponse({}));
    } else {
      return $dara.cast<DeleteProjectResponse>(await this.execute(params, req, runtime), new DeleteProjectResponse({}));
    }

  }

  /**
   * 删除项目
   * 
   * @param request - DeleteProjectRequest
   * @returns DeleteProjectResponse
   */
  async deleteProject(request: DeleteProjectRequest): Promise<DeleteProjectResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteProjectWithOptions(request, runtime);
  }

  /**
   * The name of the deleted IP address whitelist group.
   * 
   * @param request - DeleteSecurityIpGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteSecurityIpGroupResponse
   */
  async deleteSecurityIpGroupWithOptions(request: DeleteSecurityIpGroupRequest, runtime: $dara.RuntimeOptions): Promise<DeleteSecurityIpGroupResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.securityIpGroupName)) {
      body["SecurityIpGroupName"] = request.securityIpGroupName;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteSecurityIpGroup",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DeleteSecurityIpGroupResponse>(await this.callApi(params, req, runtime), new DeleteSecurityIpGroupResponse({}));
    } else {
      return $dara.cast<DeleteSecurityIpGroupResponse>(await this.execute(params, req, runtime), new DeleteSecurityIpGroupResponse({}));
    }

  }

  /**
   * The name of the deleted IP address whitelist group.
   * 
   * @param request - DeleteSecurityIpGroupRequest
   * @returns DeleteSecurityIpGroupResponse
   */
  async deleteSecurityIpGroup(request: DeleteSecurityIpGroupRequest): Promise<DeleteSecurityIpGroupResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteSecurityIpGroupWithOptions(request, runtime);
  }

  /**
   * You can call this operation to delete a tag group.
   * 
   * @param request - DeleteTagRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteTagResponse
   */
  async deleteTagWithOptions(request: DeleteTagRequest, runtime: $dara.RuntimeOptions): Promise<DeleteTagResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.key)) {
      body["Key"] = request.key;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteTag",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DeleteTagResponse>(await this.callApi(params, req, runtime), new DeleteTagResponse({}));
    } else {
      return $dara.cast<DeleteTagResponse>(await this.execute(params, req, runtime), new DeleteTagResponse({}));
    }

  }

  /**
   * You can call this operation to delete a tag group.
   * 
   * @param request - DeleteTagRequest
   * @returns DeleteTagResponse
   */
  async deleteTag(request: DeleteTagRequest): Promise<DeleteTagResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteTagWithOptions(request, runtime);
  }

  /**
   * You can call this operation to delete a tag from a tag group.
   * 
   * @param request - DeleteTagValueRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteTagValueResponse
   */
  async deleteTagValueWithOptions(request: DeleteTagValueRequest, runtime: $dara.RuntimeOptions): Promise<DeleteTagValueResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.key)) {
      body["Key"] = request.key;
    }

    if (!$dara.isNull(request.value)) {
      body["Value"] = request.value;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteTagValue",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DeleteTagValueResponse>(await this.callApi(params, req, runtime), new DeleteTagValueResponse({}));
    } else {
      return $dara.cast<DeleteTagValueResponse>(await this.execute(params, req, runtime), new DeleteTagValueResponse({}));
    }

  }

  /**
   * You can call this operation to delete a tag from a tag group.
   * 
   * @param request - DeleteTagValueRequest
   * @returns DeleteTagValueResponse
   */
  async deleteTagValue(request: DeleteTagValueRequest): Promise<DeleteTagValueResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteTagValueWithOptions(request, runtime);
  }

  /**
   * You can call this operation to delete the information on the whitelist group of the tenant.
   * 
   * @param request - DeleteTenantSecurityIpGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteTenantSecurityIpGroupResponse
   */
  async deleteTenantSecurityIpGroupWithOptions(request: DeleteTenantSecurityIpGroupRequest, runtime: $dara.RuntimeOptions): Promise<DeleteTenantSecurityIpGroupResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.securityIpGroupName)) {
      body["SecurityIpGroupName"] = request.securityIpGroupName;
    }

    if (!$dara.isNull(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteTenantSecurityIpGroup",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DeleteTenantSecurityIpGroupResponse>(await this.callApi(params, req, runtime), new DeleteTenantSecurityIpGroupResponse({}));
    } else {
      return $dara.cast<DeleteTenantSecurityIpGroupResponse>(await this.execute(params, req, runtime), new DeleteTenantSecurityIpGroupResponse({}));
    }

  }

  /**
   * You can call this operation to delete the information on the whitelist group of the tenant.
   * 
   * @param request - DeleteTenantSecurityIpGroupRequest
   * @returns DeleteTenantSecurityIpGroupResponse
   */
  async deleteTenantSecurityIpGroup(request: DeleteTenantSecurityIpGroupRequest): Promise<DeleteTenantSecurityIpGroupResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteTenantSecurityIpGroupWithOptions(request, runtime);
  }

  /**
   * You can call this operation to delete one or more database accounts.
   * 
   * @param request - DeleteTenantUsersRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteTenantUsersResponse
   */
  async deleteTenantUsersWithOptions(request: DeleteTenantUsersRequest, runtime: $dara.RuntimeOptions): Promise<DeleteTenantUsersResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    if (!$dara.isNull(request.users)) {
      body["Users"] = request.users;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteTenantUsers",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DeleteTenantUsersResponse>(await this.callApi(params, req, runtime), new DeleteTenantUsersResponse({}));
    } else {
      return $dara.cast<DeleteTenantUsersResponse>(await this.execute(params, req, runtime), new DeleteTenantUsersResponse({}));
    }

  }

  /**
   * You can call this operation to delete one or more database accounts.
   * 
   * @param request - DeleteTenantUsersRequest
   * @returns DeleteTenantUsersResponse
   */
  async deleteTenantUsers(request: DeleteTenantUsersRequest): Promise<DeleteTenantUsersResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteTenantUsersWithOptions(request, runtime);
  }

  /**
   * The return result of the request.
   * 
   * @param request - DeleteTenantsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteTenantsResponse
   */
  async deleteTenantsWithOptions(request: DeleteTenantsRequest, runtime: $dara.RuntimeOptions): Promise<DeleteTenantsResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.tenantIds)) {
      body["TenantIds"] = request.tenantIds;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteTenants",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DeleteTenantsResponse>(await this.callApi(params, req, runtime), new DeleteTenantsResponse({}));
    } else {
      return $dara.cast<DeleteTenantsResponse>(await this.execute(params, req, runtime), new DeleteTenantsResponse({}));
    }

  }

  /**
   * The return result of the request.
   * 
   * @param request - DeleteTenantsRequest
   * @returns DeleteTenantsResponse
   */
  async deleteTenants(request: DeleteTenantsRequest): Promise<DeleteTenantsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteTenantsWithOptions(request, runtime);
  }

  /**
   * You can call this operation to obtain the list of SQL statements that may have performance problems according to the diagnostic system.
   * 
   * @param tmpReq - DescribeAnomalySQLListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeAnomalySQLListResponse
   */
  async describeAnomalySQLListWithOptions(tmpReq: DescribeAnomalySQLListRequest, runtime: $dara.RuntimeOptions): Promise<DescribeAnomalySQLListResponse> {
    tmpReq.validate();
    let request = new DescribeAnomalySQLListShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!$dara.isNull(tmpReq.filterCondition)) {
      request.filterConditionShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.filterCondition, "FilterCondition", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.acceptLanguage)) {
      body["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!$dara.isNull(request.dbName)) {
      body["DbName"] = request.dbName;
    }

    if (!$dara.isNull(request.endTime)) {
      body["EndTime"] = request.endTime;
    }

    if (!$dara.isNull(request.filterConditionShrink)) {
      body["FilterCondition"] = request.filterConditionShrink;
    }

    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.nodeIp)) {
      body["NodeIp"] = request.nodeIp;
    }

    if (!$dara.isNull(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.SQLId)) {
      body["SQLId"] = request.SQLId;
    }

    if (!$dara.isNull(request.searchKeyWord)) {
      body["SearchKeyWord"] = request.searchKeyWord;
    }

    if (!$dara.isNull(request.searchParameter)) {
      body["SearchParameter"] = request.searchParameter;
    }

    if (!$dara.isNull(request.searchRule)) {
      body["SearchRule"] = request.searchRule;
    }

    if (!$dara.isNull(request.searchValue)) {
      body["SearchValue"] = request.searchValue;
    }

    if (!$dara.isNull(request.sortColumn)) {
      body["SortColumn"] = request.sortColumn;
    }

    if (!$dara.isNull(request.sortOrder)) {
      body["SortOrder"] = request.sortOrder;
    }

    if (!$dara.isNull(request.startTime)) {
      body["StartTime"] = request.startTime;
    }

    if (!$dara.isNull(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeAnomalySQLList",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeAnomalySQLListResponse>(await this.callApi(params, req, runtime), new DescribeAnomalySQLListResponse({}));
    } else {
      return $dara.cast<DescribeAnomalySQLListResponse>(await this.execute(params, req, runtime), new DescribeAnomalySQLListResponse({}));
    }

  }

  /**
   * You can call this operation to obtain the list of SQL statements that may have performance problems according to the diagnostic system.
   * 
   * @param request - DescribeAnomalySQLListRequest
   * @returns DescribeAnomalySQLListResponse
   */
  async describeAnomalySQLList(request: DescribeAnomalySQLListRequest): Promise<DescribeAnomalySQLListResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeAnomalySQLListWithOptions(request, runtime);
  }

  /**
   * The maximum number of CPU cores per resource unit.
   * 
   * @param request - DescribeAvailableCpuResourceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeAvailableCpuResourceResponse
   */
  async describeAvailableCpuResourceWithOptions(request: DescribeAvailableCpuResourceRequest, runtime: $dara.RuntimeOptions): Promise<DescribeAvailableCpuResourceResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.modifyType)) {
      body["ModifyType"] = request.modifyType;
    }

    if (!$dara.isNull(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeAvailableCpuResource",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeAvailableCpuResourceResponse>(await this.callApi(params, req, runtime), new DescribeAvailableCpuResourceResponse({}));
    } else {
      return $dara.cast<DescribeAvailableCpuResourceResponse>(await this.execute(params, req, runtime), new DescribeAvailableCpuResourceResponse({}));
    }

  }

  /**
   * The maximum number of CPU cores per resource unit.
   * 
   * @param request - DescribeAvailableCpuResourceRequest
   * @returns DescribeAvailableCpuResourceResponse
   */
  async describeAvailableCpuResource(request: DescribeAvailableCpuResourceRequest): Promise<DescribeAvailableCpuResourceResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeAvailableCpuResourceWithOptions(request, runtime);
  }

  /**
   * You can call this operation to query the available memory resource of an OceanBase Database tenant.
   * 
   * @param request - DescribeAvailableMemResourceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeAvailableMemResourceResponse
   */
  async describeAvailableMemResourceWithOptions(request: DescribeAvailableMemResourceRequest, runtime: $dara.RuntimeOptions): Promise<DescribeAvailableMemResourceResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.cpuNum)) {
      body["CpuNum"] = request.cpuNum;
    }

    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    if (!$dara.isNull(request.unitNum)) {
      body["UnitNum"] = request.unitNum;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeAvailableMemResource",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeAvailableMemResourceResponse>(await this.callApi(params, req, runtime), new DescribeAvailableMemResourceResponse({}));
    } else {
      return $dara.cast<DescribeAvailableMemResourceResponse>(await this.execute(params, req, runtime), new DescribeAvailableMemResourceResponse({}));
    }

  }

  /**
   * You can call this operation to query the available memory resource of an OceanBase Database tenant.
   * 
   * @param request - DescribeAvailableMemResourceRequest
   * @returns DescribeAvailableMemResourceResponse
   */
  async describeAvailableMemResource(request: DescribeAvailableMemResourceRequest): Promise<DescribeAvailableMemResourceResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeAvailableMemResourceWithOptions(request, runtime);
  }

  /**
   * 获取集群变配页可选配置
   * 
   * @param request - DescribeAvailableSpecRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeAvailableSpecResponse
   */
  async describeAvailableSpecWithOptions(request: DescribeAvailableSpecRequest, runtime: $dara.RuntimeOptions): Promise<DescribeAvailableSpecResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.spec)) {
      body["Spec"] = request.spec;
    }

    if (!$dara.isNull(request.upgradeType)) {
      body["UpgradeType"] = request.upgradeType;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeAvailableSpec",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeAvailableSpecResponse>(await this.callApi(params, req, runtime), new DescribeAvailableSpecResponse({}));
    } else {
      return $dara.cast<DescribeAvailableSpecResponse>(await this.execute(params, req, runtime), new DescribeAvailableSpecResponse({}));
    }

  }

  /**
   * 获取集群变配页可选配置
   * 
   * @param request - DescribeAvailableSpecRequest
   * @returns DescribeAvailableSpecResponse
   */
  async describeAvailableSpec(request: DescribeAvailableSpecRequest): Promise<DescribeAvailableSpecResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeAvailableSpecWithOptions(request, runtime);
  }

  /**
   * 获取集群售卖页可选配置
   * 
   * @param request - DescribeAvailableZoneRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeAvailableZoneResponse
   */
  async describeAvailableZoneWithOptions(request: DescribeAvailableZoneRequest, runtime: $dara.RuntimeOptions): Promise<DescribeAvailableZoneResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.cpuArch)) {
      body["CpuArch"] = request.cpuArch;
    }

    if (!$dara.isNull(request.deployType)) {
      body["DeployType"] = request.deployType;
    }

    if (!$dara.isNull(request.instanceType)) {
      body["InstanceType"] = request.instanceType;
    }

    if (!$dara.isNull(request.obVersion)) {
      body["ObVersion"] = request.obVersion;
    }

    if (!$dara.isNull(request.series)) {
      body["Series"] = request.series;
    }

    if (!$dara.isNull(request.spec)) {
      body["Spec"] = request.spec;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeAvailableZone",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeAvailableZoneResponse>(await this.callApi(params, req, runtime), new DescribeAvailableZoneResponse({}));
    } else {
      return $dara.cast<DescribeAvailableZoneResponse>(await this.execute(params, req, runtime), new DescribeAvailableZoneResponse({}));
    }

  }

  /**
   * 获取集群售卖页可选配置
   * 
   * @param request - DescribeAvailableZoneRequest
   * @returns DescribeAvailableZoneResponse
   */
  async describeAvailableZone(request: DescribeAvailableZoneRequest): Promise<DescribeAvailableZoneResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeAvailableZoneWithOptions(request, runtime);
  }

  /**
   * DescribeBackupEncryptedString
   * 
   * @param request - DescribeBackupEncryptedStringRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeBackupEncryptedStringResponse
   */
  async describeBackupEncryptedStringWithOptions(request: DescribeBackupEncryptedStringRequest, runtime: $dara.RuntimeOptions): Promise<DescribeBackupEncryptedStringResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeBackupEncryptedString",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeBackupEncryptedStringResponse>(await this.callApi(params, req, runtime), new DescribeBackupEncryptedStringResponse({}));
    } else {
      return $dara.cast<DescribeBackupEncryptedStringResponse>(await this.execute(params, req, runtime), new DescribeBackupEncryptedStringResponse({}));
    }

  }

  /**
   * DescribeBackupEncryptedString
   * 
   * @param request - DescribeBackupEncryptedStringRequest
   * @returns DescribeBackupEncryptedStringResponse
   */
  async describeBackupEncryptedString(request: DescribeBackupEncryptedStringRequest): Promise<DescribeBackupEncryptedStringResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeBackupEncryptedStringWithOptions(request, runtime);
  }

  /**
   * You can call this operation to query the link for downloading a backup set of OceanBase Database.
   * 
   * @param request - DescribeBackupSetDownloadLinkRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeBackupSetDownloadLinkResponse
   */
  async describeBackupSetDownloadLinkWithOptions(request: DescribeBackupSetDownloadLinkRequest, runtime: $dara.RuntimeOptions): Promise<DescribeBackupSetDownloadLinkResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.downloadTaskId)) {
      body["DownloadTaskId"] = request.downloadTaskId;
    }

    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeBackupSetDownloadLink",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeBackupSetDownloadLinkResponse>(await this.callApi(params, req, runtime), new DescribeBackupSetDownloadLinkResponse({}));
    } else {
      return $dara.cast<DescribeBackupSetDownloadLinkResponse>(await this.execute(params, req, runtime), new DescribeBackupSetDownloadLinkResponse({}));
    }

  }

  /**
   * You can call this operation to query the link for downloading a backup set of OceanBase Database.
   * 
   * @param request - DescribeBackupSetDownloadLinkRequest
   * @returns DescribeBackupSetDownloadLinkResponse
   */
  async describeBackupSetDownloadLink(request: DescribeBackupSetDownloadLinkRequest): Promise<DescribeBackupSetDownloadLinkResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeBackupSetDownloadLinkWithOptions(request, runtime);
  }

  /**
   * You can call this operation to query the character sets of an OceanBase Database tenant.
   * 
   * @param request - DescribeCharsetRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeCharsetResponse
   */
  async describeCharsetWithOptions(request: DescribeCharsetRequest, runtime: $dara.RuntimeOptions): Promise<DescribeCharsetResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.series)) {
      body["Series"] = request.series;
    }

    if (!$dara.isNull(request.tenantMode)) {
      body["TenantMode"] = request.tenantMode;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeCharset",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeCharsetResponse>(await this.callApi(params, req, runtime), new DescribeCharsetResponse({}));
    } else {
      return $dara.cast<DescribeCharsetResponse>(await this.execute(params, req, runtime), new DescribeCharsetResponse({}));
    }

  }

  /**
   * You can call this operation to query the character sets of an OceanBase Database tenant.
   * 
   * @param request - DescribeCharsetRequest
   * @returns DescribeCharsetResponse
   */
  async describeCharset(request: DescribeCharsetRequest): Promise<DescribeCharsetResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeCharsetWithOptions(request, runtime);
  }

  /**
   * 查询备份集信息
   * 
   * @param request - DescribeDataBackupSetRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDataBackupSetResponse
   */
  async describeDataBackupSetWithOptions(request: DescribeDataBackupSetRequest, runtime: $dara.RuntimeOptions): Promise<DescribeDataBackupSetResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.backupObjectType)) {
      body["BackupObjectType"] = request.backupObjectType;
    }

    if (!$dara.isNull(request.endTime)) {
      body["EndTime"] = request.endTime;
    }

    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.startTime)) {
      body["StartTime"] = request.startTime;
    }

    if (!$dara.isNull(request.status)) {
      body["Status"] = request.status;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeDataBackupSet",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeDataBackupSetResponse>(await this.callApi(params, req, runtime), new DescribeDataBackupSetResponse({}));
    } else {
      return $dara.cast<DescribeDataBackupSetResponse>(await this.execute(params, req, runtime), new DescribeDataBackupSetResponse({}));
    }

  }

  /**
   * 查询备份集信息
   * 
   * @param request - DescribeDataBackupSetRequest
   * @returns DescribeDataBackupSetResponse
   */
  async describeDataBackupSet(request: DescribeDataBackupSetRequest): Promise<DescribeDataBackupSetResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeDataBackupSetWithOptions(request, runtime);
  }

  /**
   * You can call this operation to query databases in a tenant.
   * 
   * @param request - DescribeDatabasesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDatabasesResponse
   */
  async describeDatabasesWithOptions(request: DescribeDatabasesRequest, runtime: $dara.RuntimeOptions): Promise<DescribeDatabasesResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.databaseName)) {
      body["DatabaseName"] = request.databaseName;
    }

    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.searchKey)) {
      body["SearchKey"] = request.searchKey;
    }

    if (!$dara.isNull(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    if (!$dara.isNull(request.withTables)) {
      body["WithTables"] = request.withTables;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeDatabases",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeDatabasesResponse>(await this.callApi(params, req, runtime), new DescribeDatabasesResponse({}));
    } else {
      return $dara.cast<DescribeDatabasesResponse>(await this.execute(params, req, runtime), new DescribeDatabasesResponse({}));
    }

  }

  /**
   * You can call this operation to query databases in a tenant.
   * 
   * @param request - DescribeDatabasesRequest
   * @returns DescribeDatabasesResponse
   */
  async describeDatabases(request: DescribeDatabasesRequest): Promise<DescribeDatabasesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeDatabasesWithOptions(request, runtime);
  }

  /**
   * You can call this operation to query the detailed information of an OceanBase cluster.
   * 
   * @param request - DescribeInstanceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeInstanceResponse
   */
  async describeInstanceWithOptions(request: DescribeInstanceRequest, runtime: $dara.RuntimeOptions): Promise<DescribeInstanceResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeInstance",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeInstanceResponse>(await this.callApi(params, req, runtime), new DescribeInstanceResponse({}));
    } else {
      return $dara.cast<DescribeInstanceResponse>(await this.execute(params, req, runtime), new DescribeInstanceResponse({}));
    }

  }

  /**
   * You can call this operation to query the detailed information of an OceanBase cluster.
   * 
   * @param request - DescribeInstanceRequest
   * @returns DescribeInstanceResponse
   */
  async describeInstance(request: DescribeInstanceRequest): Promise<DescribeInstanceResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeInstanceWithOptions(request, runtime);
  }

  /**
   * The ID of the zone.
   * 
   * @param request - DescribeInstanceCreatableZoneRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeInstanceCreatableZoneResponse
   */
  async describeInstanceCreatableZoneWithOptions(request: DescribeInstanceCreatableZoneRequest, runtime: $dara.RuntimeOptions): Promise<DescribeInstanceCreatableZoneResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeInstanceCreatableZone",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeInstanceCreatableZoneResponse>(await this.callApi(params, req, runtime), new DescribeInstanceCreatableZoneResponse({}));
    } else {
      return $dara.cast<DescribeInstanceCreatableZoneResponse>(await this.execute(params, req, runtime), new DescribeInstanceCreatableZoneResponse({}));
    }

  }

  /**
   * The ID of the zone.
   * 
   * @param request - DescribeInstanceCreatableZoneRequest
   * @returns DescribeInstanceCreatableZoneResponse
   */
  async describeInstanceCreatableZone(request: DescribeInstanceCreatableZoneRequest): Promise<DescribeInstanceCreatableZoneResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeInstanceCreatableZoneWithOptions(request, runtime);
  }

  /**
   * 查询集群SSL配置
   * 
   * @param request - DescribeInstanceSSLRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeInstanceSSLResponse
   */
  async describeInstanceSSLWithOptions(request: DescribeInstanceSSLRequest, runtime: $dara.RuntimeOptions): Promise<DescribeInstanceSSLResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeInstanceSSL",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeInstanceSSLResponse>(await this.callApi(params, req, runtime), new DescribeInstanceSSLResponse({}));
    } else {
      return $dara.cast<DescribeInstanceSSLResponse>(await this.execute(params, req, runtime), new DescribeInstanceSSLResponse({}));
    }

  }

  /**
   * 查询集群SSL配置
   * 
   * @param request - DescribeInstanceSSLRequest
   * @returns DescribeInstanceSSLResponse
   */
  async describeInstanceSSL(request: DescribeInstanceSSLRequest): Promise<DescribeInstanceSSLResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeInstanceSSLWithOptions(request, runtime);
  }

  /**
   * You can call this operation to query security check items of an OceanBase cluster.
   * 
   * @param request - DescribeInstanceSecurityConfigsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeInstanceSecurityConfigsResponse
   */
  async describeInstanceSecurityConfigsWithOptions(request: DescribeInstanceSecurityConfigsRequest, runtime: $dara.RuntimeOptions): Promise<DescribeInstanceSecurityConfigsResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.checkId)) {
      body["CheckId"] = request.checkId;
    }

    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeInstanceSecurityConfigs",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeInstanceSecurityConfigsResponse>(await this.callApi(params, req, runtime), new DescribeInstanceSecurityConfigsResponse({}));
    } else {
      return $dara.cast<DescribeInstanceSecurityConfigsResponse>(await this.execute(params, req, runtime), new DescribeInstanceSecurityConfigsResponse({}));
    }

  }

  /**
   * You can call this operation to query security check items of an OceanBase cluster.
   * 
   * @param request - DescribeInstanceSecurityConfigsRequest
   * @returns DescribeInstanceSecurityConfigsResponse
   */
  async describeInstanceSecurityConfigs(request: DescribeInstanceSecurityConfigsRequest): Promise<DescribeInstanceSecurityConfigsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeInstanceSecurityConfigsWithOptions(request, runtime);
  }

  /**
   * Obtains the overview information about OceanBase instances.
   * 
   * @param request - DescribeInstanceSummaryRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeInstanceSummaryResponse
   */
  async describeInstanceSummaryWithOptions(request: DescribeInstanceSummaryRequest, runtime: $dara.RuntimeOptions): Promise<DescribeInstanceSummaryResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeInstanceSummary",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeInstanceSummaryResponse>(await this.callApi(params, req, runtime), new DescribeInstanceSummaryResponse({}));
    } else {
      return $dara.cast<DescribeInstanceSummaryResponse>(await this.execute(params, req, runtime), new DescribeInstanceSummaryResponse({}));
    }

  }

  /**
   * Obtains the overview information about OceanBase instances.
   * 
   * @param request - DescribeInstanceSummaryRequest
   * @returns DescribeInstanceSummaryResponse
   */
  async describeInstanceSummary(request: DescribeInstanceSummaryRequest): Promise<DescribeInstanceSummaryResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeInstanceSummaryWithOptions(request, runtime);
  }

  /**
   * You can call this operation to query the tags of clusters.
   * 
   * @param request - DescribeInstanceTagsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeInstanceTagsResponse
   */
  async describeInstanceTagsWithOptions(request: DescribeInstanceTagsRequest, runtime: $dara.RuntimeOptions): Promise<DescribeInstanceTagsResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.instanceIds)) {
      body["InstanceIds"] = request.instanceIds;
    }

    if (!$dara.isNull(request.tags)) {
      body["Tags"] = request.tags;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeInstanceTags",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeInstanceTagsResponse>(await this.callApi(params, req, runtime), new DescribeInstanceTagsResponse({}));
    } else {
      return $dara.cast<DescribeInstanceTagsResponse>(await this.execute(params, req, runtime), new DescribeInstanceTagsResponse({}));
    }

  }

  /**
   * You can call this operation to query the tags of clusters.
   * 
   * @param request - DescribeInstanceTagsRequest
   * @returns DescribeInstanceTagsResponse
   */
  async describeInstanceTags(request: DescribeInstanceTagsRequest): Promise<DescribeInstanceTagsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeInstanceTagsWithOptions(request, runtime);
  }

  /**
   * The return result of the request.
   * 
   * @param request - DescribeInstanceTenantModesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeInstanceTenantModesResponse
   */
  async describeInstanceTenantModesWithOptions(request: DescribeInstanceTenantModesRequest, runtime: $dara.RuntimeOptions): Promise<DescribeInstanceTenantModesResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeInstanceTenantModes",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeInstanceTenantModesResponse>(await this.callApi(params, req, runtime), new DescribeInstanceTenantModesResponse({}));
    } else {
      return $dara.cast<DescribeInstanceTenantModesResponse>(await this.execute(params, req, runtime), new DescribeInstanceTenantModesResponse({}));
    }

  }

  /**
   * The return result of the request.
   * 
   * @param request - DescribeInstanceTenantModesRequest
   * @returns DescribeInstanceTenantModesResponse
   */
  async describeInstanceTenantModes(request: DescribeInstanceTenantModesRequest): Promise<DescribeInstanceTenantModesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeInstanceTenantModesWithOptions(request, runtime);
  }

  /**
   * You can call this operation to query the topology of an OceanBase cluster.
   * 
   * @param request - DescribeInstanceTopologyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeInstanceTopologyResponse
   */
  async describeInstanceTopologyWithOptions(request: DescribeInstanceTopologyRequest, runtime: $dara.RuntimeOptions): Promise<DescribeInstanceTopologyResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeInstanceTopology",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeInstanceTopologyResponse>(await this.callApi(params, req, runtime), new DescribeInstanceTopologyResponse({}));
    } else {
      return $dara.cast<DescribeInstanceTopologyResponse>(await this.execute(params, req, runtime), new DescribeInstanceTopologyResponse({}));
    }

  }

  /**
   * You can call this operation to query the topology of an OceanBase cluster.
   * 
   * @param request - DescribeInstanceTopologyRequest
   * @returns DescribeInstanceTopologyResponse
   */
  async describeInstanceTopology(request: DescribeInstanceTopologyRequest): Promise<DescribeInstanceTopologyResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeInstanceTopologyWithOptions(request, runtime);
  }

  /**
   * You can call this operation to obtain the list of OceanBase clusters.
   * 
   * @param request - DescribeInstancesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeInstancesResponse
   */
  async describeInstancesWithOptions(request: DescribeInstancesRequest, runtime: $dara.RuntimeOptions): Promise<DescribeInstancesResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.instanceName)) {
      body["InstanceName"] = request.instanceName;
    }

    if (!$dara.isNull(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.resourceGroupId)) {
      body["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!$dara.isNull(request.searchKey)) {
      body["SearchKey"] = request.searchKey;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeInstances",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeInstancesResponse>(await this.callApi(params, req, runtime), new DescribeInstancesResponse({}));
    } else {
      return $dara.cast<DescribeInstancesResponse>(await this.execute(params, req, runtime), new DescribeInstancesResponse({}));
    }

  }

  /**
   * You can call this operation to obtain the list of OceanBase clusters.
   * 
   * @param request - DescribeInstancesRequest
   * @returns DescribeInstancesResponse
   */
  async describeInstances(request: DescribeInstancesRequest): Promise<DescribeInstancesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeInstancesWithOptions(request, runtime);
  }

  /**
   * 查询监控指标数据
   * 
   * @param request - DescribeMetricsDataRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeMetricsDataResponse
   */
  async describeMetricsDataWithOptions(request: DescribeMetricsDataRequest, runtime: $dara.RuntimeOptions): Promise<DescribeMetricsDataResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!$dara.isNull(request.groupByLabels)) {
      query["GroupByLabels"] = request.groupByLabels;
    }

    if (!$dara.isNull(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.labels)) {
      query["Labels"] = request.labels;
    }

    if (!$dara.isNull(request.limit)) {
      query["Limit"] = request.limit;
    }

    if (!$dara.isNull(request.metrics)) {
      query["Metrics"] = request.metrics;
    }

    if (!$dara.isNull(request.sortMetricKey)) {
      query["SortMetricKey"] = request.sortMetricKey;
    }

    if (!$dara.isNull(request.sortOrder)) {
      query["SortOrder"] = request.sortOrder;
    }

    if (!$dara.isNull(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.replicaType)) {
      body["ReplicaType"] = request.replicaType;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeMetricsData",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeMetricsDataResponse>(await this.callApi(params, req, runtime), new DescribeMetricsDataResponse({}));
    } else {
      return $dara.cast<DescribeMetricsDataResponse>(await this.execute(params, req, runtime), new DescribeMetricsDataResponse({}));
    }

  }

  /**
   * 查询监控指标数据
   * 
   * @param request - DescribeMetricsDataRequest
   * @returns DescribeMetricsDataResponse
   */
  async describeMetricsData(request: DescribeMetricsDataRequest): Promise<DescribeMetricsDataResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeMetricsDataWithOptions(request, runtime);
  }

  /**
   * The list of nodes.
   * 
   * @param request - DescribeNodeMetricsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeNodeMetricsResponse
   */
  async describeNodeMetricsWithOptions(request: DescribeNodeMetricsRequest, runtime: $dara.RuntimeOptions): Promise<DescribeNodeMetricsResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.endTime)) {
      body["EndTime"] = request.endTime;
    }

    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.metrics)) {
      body["Metrics"] = request.metrics;
    }

    if (!$dara.isNull(request.nodeIdList)) {
      body["NodeIdList"] = request.nodeIdList;
    }

    if (!$dara.isNull(request.nodeName)) {
      body["NodeName"] = request.nodeName;
    }

    if (!$dara.isNull(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.startTime)) {
      body["StartTime"] = request.startTime;
    }

    if (!$dara.isNull(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeNodeMetrics",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeNodeMetricsResponse>(await this.callApi(params, req, runtime), new DescribeNodeMetricsResponse({}));
    } else {
      return $dara.cast<DescribeNodeMetricsResponse>(await this.execute(params, req, runtime), new DescribeNodeMetricsResponse({}));
    }

  }

  /**
   * The list of nodes.
   * 
   * @param request - DescribeNodeMetricsRequest
   * @returns DescribeNodeMetricsResponse
   */
  async describeNodeMetrics(request: DescribeNodeMetricsRequest): Promise<DescribeNodeMetricsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeNodeMetricsWithOptions(request, runtime);
  }

  /**
   * You can call this API to view the list of SQL statements that are identified as having performance issues by the diagnostic system.
   * 
   * @param request - DescribeOasAnomalySQLListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeOasAnomalySQLListResponse
   */
  async describeOasAnomalySQLListWithOptions(request: DescribeOasAnomalySQLListRequest, runtime: $dara.RuntimeOptions): Promise<DescribeOasAnomalySQLListResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.acceptLanguage)) {
      body["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!$dara.isNull(request.current)) {
      body["Current"] = request.current;
    }

    if (!$dara.isNull(request.dbName)) {
      body["DbName"] = request.dbName;
    }

    if (!$dara.isNull(request.dynamicSql)) {
      body["DynamicSql"] = request.dynamicSql;
    }

    if (!$dara.isNull(request.endTime)) {
      body["EndTime"] = request.endTime;
    }

    if (!$dara.isNull(request.filterCondition)) {
      body["FilterCondition"] = request.filterCondition;
    }

    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.mergeDynamicSql)) {
      body["MergeDynamicSql"] = request.mergeDynamicSql;
    }

    if (!$dara.isNull(request.nodeIp)) {
      body["NodeIp"] = request.nodeIp;
    }

    if (!$dara.isNull(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.searchKeyWord)) {
      body["SearchKeyWord"] = request.searchKeyWord;
    }

    if (!$dara.isNull(request.searchParam)) {
      body["SearchParam"] = request.searchParam;
    }

    if (!$dara.isNull(request.searchRule)) {
      body["SearchRule"] = request.searchRule;
    }

    if (!$dara.isNull(request.searchValue)) {
      body["SearchValue"] = request.searchValue;
    }

    if (!$dara.isNull(request.sqlId)) {
      body["SqlId"] = request.sqlId;
    }

    if (!$dara.isNull(request.sqlTextLength)) {
      body["SqlTextLength"] = request.sqlTextLength;
    }

    if (!$dara.isNull(request.startTime)) {
      body["StartTime"] = request.startTime;
    }

    if (!$dara.isNull(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeOasAnomalySQLList",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeOasAnomalySQLListResponse>(await this.callApi(params, req, runtime), new DescribeOasAnomalySQLListResponse({}));
    } else {
      return $dara.cast<DescribeOasAnomalySQLListResponse>(await this.execute(params, req, runtime), new DescribeOasAnomalySQLListResponse({}));
    }

  }

  /**
   * You can call this API to view the list of SQL statements that are identified as having performance issues by the diagnostic system.
   * 
   * @param request - DescribeOasAnomalySQLListRequest
   * @returns DescribeOasAnomalySQLListResponse
   */
  async describeOasAnomalySQLList(request: DescribeOasAnomalySQLListRequest): Promise<DescribeOasAnomalySQLListResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeOasAnomalySQLListWithOptions(request, runtime);
  }

  /**
   * You can call this API to query detailed information about the SQL, including the SQL text, related table names, and so on.
   * 
   * @param request - DescribeOasSQLDetailsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeOasSQLDetailsResponse
   */
  async describeOasSQLDetailsWithOptions(request: DescribeOasSQLDetailsRequest, runtime: $dara.RuntimeOptions): Promise<DescribeOasSQLDetailsResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.dbName)) {
      body["DbName"] = request.dbName;
    }

    if (!$dara.isNull(request.dynamicSql)) {
      body["DynamicSql"] = request.dynamicSql;
    }

    if (!$dara.isNull(request.endTime)) {
      body["EndTime"] = request.endTime;
    }

    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.parseTable)) {
      body["ParseTable"] = request.parseTable;
    }

    if (!$dara.isNull(request.sqlId)) {
      body["SqlId"] = request.sqlId;
    }

    if (!$dara.isNull(request.startTime)) {
      body["StartTime"] = request.startTime;
    }

    if (!$dara.isNull(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeOasSQLDetails",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeOasSQLDetailsResponse>(await this.callApi(params, req, runtime), new DescribeOasSQLDetailsResponse({}));
    } else {
      return $dara.cast<DescribeOasSQLDetailsResponse>(await this.execute(params, req, runtime), new DescribeOasSQLDetailsResponse({}));
    }

  }

  /**
   * You can call this API to query detailed information about the SQL, including the SQL text, related table names, and so on.
   * 
   * @param request - DescribeOasSQLDetailsRequest
   * @returns DescribeOasSQLDetailsResponse
   */
  async describeOasSQLDetails(request: DescribeOasSQLDetailsRequest): Promise<DescribeOasSQLDetailsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeOasSQLDetailsWithOptions(request, runtime);
  }

  /**
   * You can call this API to view the SQL execution history.
   * 
   * @param request - DescribeOasSQLHistoryListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeOasSQLHistoryListResponse
   */
  async describeOasSQLHistoryListWithOptions(request: DescribeOasSQLHistoryListRequest, runtime: $dara.RuntimeOptions): Promise<DescribeOasSQLHistoryListResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.acceptLanguage)) {
      body["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!$dara.isNull(request.dbName)) {
      body["DbName"] = request.dbName;
    }

    if (!$dara.isNull(request.dynamicSql)) {
      body["DynamicSql"] = request.dynamicSql;
    }

    if (!$dara.isNull(request.endTime)) {
      body["EndTime"] = request.endTime;
    }

    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.nodeIp)) {
      body["NodeIp"] = request.nodeIp;
    }

    if (!$dara.isNull(request.sqlId)) {
      body["SqlId"] = request.sqlId;
    }

    if (!$dara.isNull(request.startTime)) {
      body["StartTime"] = request.startTime;
    }

    if (!$dara.isNull(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeOasSQLHistoryList",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeOasSQLHistoryListResponse>(await this.callApi(params, req, runtime), new DescribeOasSQLHistoryListResponse({}));
    } else {
      return $dara.cast<DescribeOasSQLHistoryListResponse>(await this.execute(params, req, runtime), new DescribeOasSQLHistoryListResponse({}));
    }

  }

  /**
   * You can call this API to view the SQL execution history.
   * 
   * @param request - DescribeOasSQLHistoryListRequest
   * @returns DescribeOasSQLHistoryListResponse
   */
  async describeOasSQLHistoryList(request: DescribeOasSQLHistoryListRequest): Promise<DescribeOasSQLHistoryListResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeOasSQLHistoryListWithOptions(request, runtime);
  }

  /**
   * You can call this API to retrieve information about the SQL execution plan stored in the diagnostic system based on the SQL ID.
   * 
   * @param request - DescribeOasSQLPlansRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeOasSQLPlansResponse
   */
  async describeOasSQLPlansWithOptions(request: DescribeOasSQLPlansRequest, runtime: $dara.RuntimeOptions): Promise<DescribeOasSQLPlansResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.acceptLanguage)) {
      body["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!$dara.isNull(request.dbName)) {
      body["DbName"] = request.dbName;
    }

    if (!$dara.isNull(request.dynamicSql)) {
      body["DynamicSql"] = request.dynamicSql;
    }

    if (!$dara.isNull(request.endTime)) {
      body["EndTime"] = request.endTime;
    }

    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.planUnionHash)) {
      body["PlanUnionHash"] = request.planUnionHash;
    }

    if (!$dara.isNull(request.returnBriefInfo)) {
      body["ReturnBriefInfo"] = request.returnBriefInfo;
    }

    if (!$dara.isNull(request.sqlId)) {
      body["SqlId"] = request.sqlId;
    }

    if (!$dara.isNull(request.startTime)) {
      body["StartTime"] = request.startTime;
    }

    if (!$dara.isNull(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeOasSQLPlans",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeOasSQLPlansResponse>(await this.callApi(params, req, runtime), new DescribeOasSQLPlansResponse({}));
    } else {
      return $dara.cast<DescribeOasSQLPlansResponse>(await this.execute(params, req, runtime), new DescribeOasSQLPlansResponse({}));
    }

  }

  /**
   * You can call this API to retrieve information about the SQL execution plan stored in the diagnostic system based on the SQL ID.
   * 
   * @param request - DescribeOasSQLPlansRequest
   * @returns DescribeOasSQLPlansResponse
   */
  async describeOasSQLPlans(request: DescribeOasSQLPlansRequest): Promise<DescribeOasSQLPlansResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeOasSQLPlansWithOptions(request, runtime);
  }

  /**
   * You can call this API to view a list of slow queries.
   * 
   * @param request - DescribeOasSlowSQLListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeOasSlowSQLListResponse
   */
  async describeOasSlowSQLListWithOptions(request: DescribeOasSlowSQLListRequest, runtime: $dara.RuntimeOptions): Promise<DescribeOasSlowSQLListResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.acceptLanguage)) {
      body["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!$dara.isNull(request.dbName)) {
      body["DbName"] = request.dbName;
    }

    if (!$dara.isNull(request.dynamicSql)) {
      body["DynamicSql"] = request.dynamicSql;
    }

    if (!$dara.isNull(request.endTime)) {
      body["EndTime"] = request.endTime;
    }

    if (!$dara.isNull(request.filterCondition)) {
      body["FilterCondition"] = request.filterCondition;
    }

    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.mergeDynamicSql)) {
      body["MergeDynamicSql"] = request.mergeDynamicSql;
    }

    if (!$dara.isNull(request.nodeIp)) {
      body["NodeIp"] = request.nodeIp;
    }

    if (!$dara.isNull(request.searchKeyWord)) {
      body["SearchKeyWord"] = request.searchKeyWord;
    }

    if (!$dara.isNull(request.searchParam)) {
      body["SearchParam"] = request.searchParam;
    }

    if (!$dara.isNull(request.searchRule)) {
      body["SearchRule"] = request.searchRule;
    }

    if (!$dara.isNull(request.searchValue)) {
      body["SearchValue"] = request.searchValue;
    }

    if (!$dara.isNull(request.sqlId)) {
      body["SqlId"] = request.sqlId;
    }

    if (!$dara.isNull(request.sqlTextLength)) {
      body["SqlTextLength"] = request.sqlTextLength;
    }

    if (!$dara.isNull(request.startTime)) {
      body["StartTime"] = request.startTime;
    }

    if (!$dara.isNull(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeOasSlowSQLList",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeOasSlowSQLListResponse>(await this.callApi(params, req, runtime), new DescribeOasSlowSQLListResponse({}));
    } else {
      return $dara.cast<DescribeOasSlowSQLListResponse>(await this.execute(params, req, runtime), new DescribeOasSlowSQLListResponse({}));
    }

  }

  /**
   * You can call this API to view a list of slow queries.
   * 
   * @param request - DescribeOasSlowSQLListRequest
   * @returns DescribeOasSlowSQLListResponse
   */
  async describeOasSlowSQLList(request: DescribeOasSlowSQLListRequest): Promise<DescribeOasSlowSQLListResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeOasSlowSQLListWithOptions(request, runtime);
  }

  /**
   * You can call this API to retrieve the list of data on the SQL execution performance collected by the diagnostic system.
   * 
   * @param request - DescribeOasTopSQLListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeOasTopSQLListResponse
   */
  async describeOasTopSQLListWithOptions(request: DescribeOasTopSQLListRequest, runtime: $dara.RuntimeOptions): Promise<DescribeOasTopSQLListResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.acceptLanguage)) {
      body["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!$dara.isNull(request.dbName)) {
      body["DbName"] = request.dbName;
    }

    if (!$dara.isNull(request.dynamicSql)) {
      body["DynamicSql"] = request.dynamicSql;
    }

    if (!$dara.isNull(request.endTime)) {
      body["EndTime"] = request.endTime;
    }

    if (!$dara.isNull(request.filterCondition)) {
      body["FilterCondition"] = request.filterCondition;
    }

    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.mergeDynamicSql)) {
      body["MergeDynamicSql"] = request.mergeDynamicSql;
    }

    if (!$dara.isNull(request.nodeIp)) {
      body["NodeIp"] = request.nodeIp;
    }

    if (!$dara.isNull(request.searchKeyWord)) {
      body["SearchKeyWord"] = request.searchKeyWord;
    }

    if (!$dara.isNull(request.searchParam)) {
      body["SearchParam"] = request.searchParam;
    }

    if (!$dara.isNull(request.searchRule)) {
      body["SearchRule"] = request.searchRule;
    }

    if (!$dara.isNull(request.searchValue)) {
      body["SearchValue"] = request.searchValue;
    }

    if (!$dara.isNull(request.sqlId)) {
      body["SqlId"] = request.sqlId;
    }

    if (!$dara.isNull(request.sqlTextLength)) {
      body["SqlTextLength"] = request.sqlTextLength;
    }

    if (!$dara.isNull(request.startTime)) {
      body["StartTime"] = request.startTime;
    }

    if (!$dara.isNull(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeOasTopSQLList",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeOasTopSQLListResponse>(await this.callApi(params, req, runtime), new DescribeOasTopSQLListResponse({}));
    } else {
      return $dara.cast<DescribeOasTopSQLListResponse>(await this.execute(params, req, runtime), new DescribeOasTopSQLListResponse({}));
    }

  }

  /**
   * You can call this API to retrieve the list of data on the SQL execution performance collected by the diagnostic system.
   * 
   * @param request - DescribeOasTopSQLListRequest
   * @returns DescribeOasTopSQLListResponse
   */
  async describeOasTopSQLList(request: DescribeOasTopSQLListRequest): Promise<DescribeOasTopSQLListResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeOasTopSQLListWithOptions(request, runtime);
  }

  /**
   * You can call this operation to query the outline binding information or throttling information of an SQL statement in the database based on an SQLID.
   * 
   * @param request - DescribeOutlineBindingRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeOutlineBindingResponse
   */
  async describeOutlineBindingWithOptions(request: DescribeOutlineBindingRequest, runtime: $dara.RuntimeOptions): Promise<DescribeOutlineBindingResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.databaseName)) {
      body["DatabaseName"] = request.databaseName;
    }

    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.isConcurrentLimit)) {
      body["IsConcurrentLimit"] = request.isConcurrentLimit;
    }

    if (!$dara.isNull(request.SQLId)) {
      body["SQLId"] = request.SQLId;
    }

    if (!$dara.isNull(request.tableName)) {
      body["TableName"] = request.tableName;
    }

    if (!$dara.isNull(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeOutlineBinding",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeOutlineBindingResponse>(await this.callApi(params, req, runtime), new DescribeOutlineBindingResponse({}));
    } else {
      return $dara.cast<DescribeOutlineBindingResponse>(await this.execute(params, req, runtime), new DescribeOutlineBindingResponse({}));
    }

  }

  /**
   * You can call this operation to query the outline binding information or throttling information of an SQL statement in the database based on an SQLID.
   * 
   * @param request - DescribeOutlineBindingRequest
   * @returns DescribeOutlineBindingResponse
   */
  async describeOutlineBinding(request: DescribeOutlineBindingRequest): Promise<DescribeOutlineBindingResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeOutlineBindingWithOptions(request, runtime);
  }

  /**
   * Indicates whether a restart is required for changes to the parameter to take effect. Valid values: - true: A restart is required. - false: A restart is not required.
   * 
   * @param request - DescribeParametersRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeParametersResponse
   */
  async describeParametersWithOptions(request: DescribeParametersRequest, runtime: $dara.RuntimeOptions): Promise<DescribeParametersResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.dimension)) {
      body["Dimension"] = request.dimension;
    }

    if (!$dara.isNull(request.dimensionValue)) {
      body["DimensionValue"] = request.dimensionValue;
    }

    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeParameters",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeParametersResponse>(await this.callApi(params, req, runtime), new DescribeParametersResponse({}));
    } else {
      return $dara.cast<DescribeParametersResponse>(await this.execute(params, req, runtime), new DescribeParametersResponse({}));
    }

  }

  /**
   * Indicates whether a restart is required for changes to the parameter to take effect. Valid values: - true: A restart is required. - false: A restart is not required.
   * 
   * @param request - DescribeParametersRequest
   * @returns DescribeParametersResponse
   */
  async describeParameters(request: DescribeParametersRequest): Promise<DescribeParametersResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeParametersWithOptions(request, runtime);
  }

  /**
   * You can call this operation to query the modification history of cluster or tenant parameters.
   * 
   * @param request - DescribeParametersHistoryRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeParametersHistoryResponse
   */
  async describeParametersHistoryWithOptions(request: DescribeParametersHistoryRequest, runtime: $dara.RuntimeOptions): Promise<DescribeParametersHistoryResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.dimension)) {
      body["Dimension"] = request.dimension;
    }

    if (!$dara.isNull(request.dimensionValue)) {
      body["DimensionValue"] = request.dimensionValue;
    }

    if (!$dara.isNull(request.endTime)) {
      body["EndTime"] = request.endTime;
    }

    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.startTime)) {
      body["StartTime"] = request.startTime;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeParametersHistory",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeParametersHistoryResponse>(await this.callApi(params, req, runtime), new DescribeParametersHistoryResponse({}));
    } else {
      return $dara.cast<DescribeParametersHistoryResponse>(await this.execute(params, req, runtime), new DescribeParametersHistoryResponse({}));
    }

  }

  /**
   * You can call this operation to query the modification history of cluster or tenant parameters.
   * 
   * @param request - DescribeParametersHistoryRequest
   * @returns DescribeParametersHistoryResponse
   */
  async describeParametersHistory(request: DescribeParametersHistoryRequest): Promise<DescribeParametersHistoryResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeParametersHistoryWithOptions(request, runtime);
  }

  /**
   * You can call this operation to query session information.
   * 
   * @param request - DescribeProcessStatsCompositionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeProcessStatsCompositionResponse
   */
  async describeProcessStatsCompositionWithOptions(request: DescribeProcessStatsCompositionRequest, runtime: $dara.RuntimeOptions): Promise<DescribeProcessStatsCompositionResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.clientIp)) {
      body["ClientIp"] = request.clientIp;
    }

    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.serverIp)) {
      body["ServerIp"] = request.serverIp;
    }

    if (!$dara.isNull(request.sqlText)) {
      body["SqlText"] = request.sqlText;
    }

    if (!$dara.isNull(request.status)) {
      body["Status"] = request.status;
    }

    if (!$dara.isNull(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    if (!$dara.isNull(request.UId)) {
      body["UId"] = request.UId;
    }

    if (!$dara.isNull(request.users)) {
      body["Users"] = request.users;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeProcessStatsComposition",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeProcessStatsCompositionResponse>(await this.callApi(params, req, runtime), new DescribeProcessStatsCompositionResponse({}));
    } else {
      return $dara.cast<DescribeProcessStatsCompositionResponse>(await this.execute(params, req, runtime), new DescribeProcessStatsCompositionResponse({}));
    }

  }

  /**
   * You can call this operation to query session information.
   * 
   * @param request - DescribeProcessStatsCompositionRequest
   * @returns DescribeProcessStatsCompositionResponse
   */
  async describeProcessStatsComposition(request: DescribeProcessStatsCompositionRequest): Promise<DescribeProcessStatsCompositionResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeProcessStatsCompositionWithOptions(request, runtime);
  }

  /**
   * 查询项目详情
   * 
   * @param request - DescribeProjectRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeProjectResponse
   */
  async describeProjectWithOptions(request: DescribeProjectRequest, runtime: $dara.RuntimeOptions): Promise<DescribeProjectResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.id)) {
      body["Id"] = request.id;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeProject",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeProjectResponse>(await this.callApi(params, req, runtime), new DescribeProjectResponse({}));
    } else {
      return $dara.cast<DescribeProjectResponse>(await this.execute(params, req, runtime), new DescribeProjectResponse({}));
    }

  }

  /**
   * 查询项目详情
   * 
   * @param request - DescribeProjectRequest
   * @returns DescribeProjectResponse
   */
  async describeProject(request: DescribeProjectRequest): Promise<DescribeProjectResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeProjectWithOptions(request, runtime);
  }

  /**
   * 获取项目的组件信息
   * 
   * @param request - DescribeProjectComponentsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeProjectComponentsResponse
   */
  async describeProjectComponentsWithOptions(request: DescribeProjectComponentsRequest, runtime: $dara.RuntimeOptions): Promise<DescribeProjectComponentsResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.id)) {
      body["Id"] = request.id;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeProjectComponents",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeProjectComponentsResponse>(await this.callApi(params, req, runtime), new DescribeProjectComponentsResponse({}));
    } else {
      return $dara.cast<DescribeProjectComponentsResponse>(await this.execute(params, req, runtime), new DescribeProjectComponentsResponse({}));
    }

  }

  /**
   * 获取项目的组件信息
   * 
   * @param request - DescribeProjectComponentsRequest
   * @returns DescribeProjectComponentsResponse
   */
  async describeProjectComponents(request: DescribeProjectComponentsRequest): Promise<DescribeProjectComponentsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeProjectComponentsWithOptions(request, runtime);
  }

  /**
   * 获取迁移/同步项目 Progress 信息
   * 
   * @param request - DescribeProjectProgressRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeProjectProgressResponse
   */
  async describeProjectProgressWithOptions(request: DescribeProjectProgressRequest, runtime: $dara.RuntimeOptions): Promise<DescribeProjectProgressResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.id)) {
      body["Id"] = request.id;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeProjectProgress",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeProjectProgressResponse>(await this.callApi(params, req, runtime), new DescribeProjectProgressResponse({}));
    } else {
      return $dara.cast<DescribeProjectProgressResponse>(await this.execute(params, req, runtime), new DescribeProjectProgressResponse({}));
    }

  }

  /**
   * 获取迁移/同步项目 Progress 信息
   * 
   * @param request - DescribeProjectProgressRequest
   * @returns DescribeProjectProgressResponse
   */
  async describeProjectProgress(request: DescribeProjectProgressRequest): Promise<DescribeProjectProgressResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeProjectProgressWithOptions(request, runtime);
  }

  /**
   * 查询项目步骤指标
   * 
   * @param request - DescribeProjectStepMetricRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeProjectStepMetricResponse
   */
  async describeProjectStepMetricWithOptions(request: DescribeProjectStepMetricRequest, runtime: $dara.RuntimeOptions): Promise<DescribeProjectStepMetricResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.aggregator)) {
      body["Aggregator"] = request.aggregator;
    }

    if (!$dara.isNull(request.beginTimestamp)) {
      body["BeginTimestamp"] = request.beginTimestamp;
    }

    if (!$dara.isNull(request.endTimestamp)) {
      body["EndTimestamp"] = request.endTimestamp;
    }

    if (!$dara.isNull(request.maxPointNum)) {
      body["MaxPointNum"] = request.maxPointNum;
    }

    if (!$dara.isNull(request.metricType)) {
      body["MetricType"] = request.metricType;
    }

    if (!$dara.isNull(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!$dara.isNull(request.stepName)) {
      body["StepName"] = request.stepName;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeProjectStepMetric",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeProjectStepMetricResponse>(await this.callApi(params, req, runtime), new DescribeProjectStepMetricResponse({}));
    } else {
      return $dara.cast<DescribeProjectStepMetricResponse>(await this.execute(params, req, runtime), new DescribeProjectStepMetricResponse({}));
    }

  }

  /**
   * 查询项目步骤指标
   * 
   * @param request - DescribeProjectStepMetricRequest
   * @returns DescribeProjectStepMetricResponse
   */
  async describeProjectStepMetric(request: DescribeProjectStepMetricRequest): Promise<DescribeProjectStepMetricResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeProjectStepMetricWithOptions(request, runtime);
  }

  /**
   * 查询项目步骤
   * 
   * @param request - DescribeProjectStepsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeProjectStepsResponse
   */
  async describeProjectStepsWithOptions(request: DescribeProjectStepsRequest, runtime: $dara.RuntimeOptions): Promise<DescribeProjectStepsResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.id)) {
      body["Id"] = request.id;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeProjectSteps",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeProjectStepsResponse>(await this.callApi(params, req, runtime), new DescribeProjectStepsResponse({}));
    } else {
      return $dara.cast<DescribeProjectStepsResponse>(await this.execute(params, req, runtime), new DescribeProjectStepsResponse({}));
    }

  }

  /**
   * 查询项目步骤
   * 
   * @param request - DescribeProjectStepsRequest
   * @returns DescribeProjectStepsResponse
   */
  async describeProjectSteps(request: DescribeProjectStepsRequest): Promise<DescribeProjectStepsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeProjectStepsWithOptions(request, runtime);
  }

  /**
   * 查询代理服务信息
   * 
   * @param request - DescribeProxyServiceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeProxyServiceResponse
   */
  async describeProxyServiceWithOptions(request: DescribeProxyServiceRequest, runtime: $dara.RuntimeOptions): Promise<DescribeProxyServiceResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeProxyService",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeProxyServiceResponse>(await this.callApi(params, req, runtime), new DescribeProxyServiceResponse({}));
    } else {
      return $dara.cast<DescribeProxyServiceResponse>(await this.execute(params, req, runtime), new DescribeProxyServiceResponse({}));
    }

  }

  /**
   * 查询代理服务信息
   * 
   * @param request - DescribeProxyServiceRequest
   * @returns DescribeProxyServiceResponse
   */
  async describeProxyService(request: DescribeProxyServiceRequest): Promise<DescribeProxyServiceResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeProxyServiceWithOptions(request, runtime);
  }

  /**
   * The tenant mode.   Valid values:  
   * Oracle   
   * MySQL
   * 
   * @param request - DescribeRecommendIndexRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeRecommendIndexResponse
   */
  async describeRecommendIndexWithOptions(request: DescribeRecommendIndexRequest, runtime: $dara.RuntimeOptions): Promise<DescribeRecommendIndexResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.SQLId)) {
      body["SQLId"] = request.SQLId;
    }

    if (!$dara.isNull(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeRecommendIndex",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeRecommendIndexResponse>(await this.callApi(params, req, runtime), new DescribeRecommendIndexResponse({}));
    } else {
      return $dara.cast<DescribeRecommendIndexResponse>(await this.execute(params, req, runtime), new DescribeRecommendIndexResponse({}));
    }

  }

  /**
   * The tenant mode.   Valid values:  
   * Oracle   
   * MySQL
   * 
   * @param request - DescribeRecommendIndexRequest
   * @returns DescribeRecommendIndexResponse
   */
  async describeRecommendIndex(request: DescribeRecommendIndexRequest): Promise<DescribeRecommendIndexResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeRecommendIndexWithOptions(request, runtime);
  }

  /**
   * Queries information about restorable OceanBase Database tenants.
   * 
   * @param request - DescribeRestorableTenantsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeRestorableTenantsResponse
   */
  async describeRestorableTenantsWithOptions(request: DescribeRestorableTenantsRequest, runtime: $dara.RuntimeOptions): Promise<DescribeRestorableTenantsResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.isOnline)) {
      body["IsOnline"] = request.isOnline;
    }

    if (!$dara.isNull(request.isRemote)) {
      body["IsRemote"] = request.isRemote;
    }

    if (!$dara.isNull(request.method)) {
      body["Method"] = request.method;
    }

    if (!$dara.isNull(request.restoreMode)) {
      body["RestoreMode"] = request.restoreMode;
    }

    if (!$dara.isNull(request.restoreObjectType)) {
      body["RestoreObjectType"] = request.restoreObjectType;
    }

    if (!$dara.isNull(request.setId)) {
      body["SetId"] = request.setId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeRestorableTenants",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeRestorableTenantsResponse>(await this.callApi(params, req, runtime), new DescribeRestorableTenantsResponse({}));
    } else {
      return $dara.cast<DescribeRestorableTenantsResponse>(await this.execute(params, req, runtime), new DescribeRestorableTenantsResponse({}));
    }

  }

  /**
   * Queries information about restorable OceanBase Database tenants.
   * 
   * @param request - DescribeRestorableTenantsRequest
   * @returns DescribeRestorableTenantsResponse
   */
  async describeRestorableTenants(request: DescribeRestorableTenantsRequest): Promise<DescribeRestorableTenantsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeRestorableTenantsWithOptions(request, runtime);
  }

  /**
   * The username.
   * 
   * @param request - DescribeSQLDetailsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeSQLDetailsResponse
   */
  async describeSQLDetailsWithOptions(request: DescribeSQLDetailsRequest, runtime: $dara.RuntimeOptions): Promise<DescribeSQLDetailsResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.SQLId)) {
      body["SQLId"] = request.SQLId;
    }

    if (!$dara.isNull(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeSQLDetails",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeSQLDetailsResponse>(await this.callApi(params, req, runtime), new DescribeSQLDetailsResponse({}));
    } else {
      return $dara.cast<DescribeSQLDetailsResponse>(await this.execute(params, req, runtime), new DescribeSQLDetailsResponse({}));
    }

  }

  /**
   * The username.
   * 
   * @param request - DescribeSQLDetailsRequest
   * @returns DescribeSQLDetailsResponse
   */
  async describeSQLDetails(request: DescribeSQLDetailsRequest): Promise<DescribeSQLDetailsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeSQLDetailsWithOptions(request, runtime);
  }

  /**
   * You can call this operation to query the execution history of an SQL statement in a specified period based on an SQL ID.
   * 
   * @param request - DescribeSQLHistoryListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeSQLHistoryListResponse
   */
  async describeSQLHistoryListWithOptions(request: DescribeSQLHistoryListRequest, runtime: $dara.RuntimeOptions): Promise<DescribeSQLHistoryListResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.endTime)) {
      body["EndTime"] = request.endTime;
    }

    if (!$dara.isNull(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.SQLId)) {
      body["SQLId"] = request.SQLId;
    }

    if (!$dara.isNull(request.startTime)) {
      body["StartTime"] = request.startTime;
    }

    if (!$dara.isNull(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeSQLHistoryList",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeSQLHistoryListResponse>(await this.callApi(params, req, runtime), new DescribeSQLHistoryListResponse({}));
    } else {
      return $dara.cast<DescribeSQLHistoryListResponse>(await this.execute(params, req, runtime), new DescribeSQLHistoryListResponse({}));
    }

  }

  /**
   * You can call this operation to query the execution history of an SQL statement in a specified period based on an SQL ID.
   * 
   * @param request - DescribeSQLHistoryListRequest
   * @returns DescribeSQLHistoryListResponse
   */
  async describeSQLHistoryList(request: DescribeSQLHistoryListRequest): Promise<DescribeSQLHistoryListResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeSQLHistoryListWithOptions(request, runtime);
  }

  /**
   * You can call this operation to query the information about the SQL execution plans stored in the diagnostic system based on an SQL ID.
   * 
   * @param request - DescribeSQLPlansRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeSQLPlansResponse
   */
  async describeSQLPlansWithOptions(request: DescribeSQLPlansRequest, runtime: $dara.RuntimeOptions): Promise<DescribeSQLPlansResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.SQLId)) {
      body["SQLId"] = request.SQLId;
    }

    if (!$dara.isNull(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeSQLPlans",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeSQLPlansResponse>(await this.callApi(params, req, runtime), new DescribeSQLPlansResponse({}));
    } else {
      return $dara.cast<DescribeSQLPlansResponse>(await this.execute(params, req, runtime), new DescribeSQLPlansResponse({}));
    }

  }

  /**
   * You can call this operation to query the information about the SQL execution plans stored in the diagnostic system based on an SQL ID.
   * 
   * @param request - DescribeSQLPlansRequest
   * @returns DescribeSQLPlansResponse
   */
  async describeSQLPlans(request: DescribeSQLPlansRequest): Promise<DescribeSQLPlansResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeSQLPlansWithOptions(request, runtime);
  }

  /**
   * You can call this API to view the sample data of the execution details of the slow queries.
   * 
   * @param request - DescribeSQLSamplesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeSQLSamplesResponse
   */
  async describeSQLSamplesWithOptions(request: DescribeSQLSamplesRequest, runtime: $dara.RuntimeOptions): Promise<DescribeSQLSamplesResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.dbName)) {
      body["DbName"] = request.dbName;
    }

    if (!$dara.isNull(request.endTime)) {
      body["EndTime"] = request.endTime;
    }

    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.returnSqlText)) {
      body["ReturnSqlText"] = request.returnSqlText;
    }

    if (!$dara.isNull(request.sqlId)) {
      body["SqlId"] = request.sqlId;
    }

    if (!$dara.isNull(request.startTime)) {
      body["StartTime"] = request.startTime;
    }

    if (!$dara.isNull(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeSQLSamples",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeSQLSamplesResponse>(await this.callApi(params, req, runtime), new DescribeSQLSamplesResponse({}));
    } else {
      return $dara.cast<DescribeSQLSamplesResponse>(await this.execute(params, req, runtime), new DescribeSQLSamplesResponse({}));
    }

  }

  /**
   * You can call this API to view the sample data of the execution details of the slow queries.
   * 
   * @param request - DescribeSQLSamplesRequest
   * @returns DescribeSQLSamplesResponse
   */
  async describeSQLSamples(request: DescribeSQLSamplesRequest): Promise<DescribeSQLSamplesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeSQLSamplesWithOptions(request, runtime);
  }

  /**
   * 获取单个 SQL 的调优建议，包括计划推荐和索引推荐
   * 
   * @param request - DescribeSQLTuningAdvicesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeSQLTuningAdvicesResponse
   */
  async describeSQLTuningAdvicesWithOptions(request: DescribeSQLTuningAdvicesRequest, runtime: $dara.RuntimeOptions): Promise<DescribeSQLTuningAdvicesResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.acceptLanguage)) {
      body["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!$dara.isNull(request.dbName)) {
      body["DbName"] = request.dbName;
    }

    if (!$dara.isNull(request.endTime)) {
      body["EndTime"] = request.endTime;
    }

    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.sqlId)) {
      body["SqlId"] = request.sqlId;
    }

    if (!$dara.isNull(request.startTime)) {
      body["StartTime"] = request.startTime;
    }

    if (!$dara.isNull(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeSQLTuningAdvices",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeSQLTuningAdvicesResponse>(await this.callApi(params, req, runtime), new DescribeSQLTuningAdvicesResponse({}));
    } else {
      return $dara.cast<DescribeSQLTuningAdvicesResponse>(await this.execute(params, req, runtime), new DescribeSQLTuningAdvicesResponse({}));
    }

  }

  /**
   * 获取单个 SQL 的调优建议，包括计划推荐和索引推荐
   * 
   * @param request - DescribeSQLTuningAdvicesRequest
   * @returns DescribeSQLTuningAdvicesResponse
   */
  async describeSQLTuningAdvices(request: DescribeSQLTuningAdvicesRequest): Promise<DescribeSQLTuningAdvicesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeSQLTuningAdvicesWithOptions(request, runtime);
  }

  /**
   * 查询采样SQL的原始文本
   * 
   * @param request - DescribeSampleSqlRawTextsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeSampleSqlRawTextsResponse
   */
  async describeSampleSqlRawTextsWithOptions(request: DescribeSampleSqlRawTextsRequest, runtime: $dara.RuntimeOptions): Promise<DescribeSampleSqlRawTextsResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.dbName)) {
      body["DbName"] = request.dbName;
    }

    if (!$dara.isNull(request.dynamicSql)) {
      body["DynamicSql"] = request.dynamicSql;
    }

    if (!$dara.isNull(request.endTime)) {
      body["EndTime"] = request.endTime;
    }

    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.limit)) {
      body["Limit"] = request.limit;
    }

    if (!$dara.isNull(request.sqlId)) {
      body["SqlId"] = request.sqlId;
    }

    if (!$dara.isNull(request.startTime)) {
      body["StartTime"] = request.startTime;
    }

    if (!$dara.isNull(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    if (!$dara.isNull(request.traceId)) {
      body["TraceId"] = request.traceId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeSampleSqlRawTexts",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeSampleSqlRawTextsResponse>(await this.callApi(params, req, runtime), new DescribeSampleSqlRawTextsResponse({}));
    } else {
      return $dara.cast<DescribeSampleSqlRawTextsResponse>(await this.execute(params, req, runtime), new DescribeSampleSqlRawTextsResponse({}));
    }

  }

  /**
   * 查询采样SQL的原始文本
   * 
   * @param request - DescribeSampleSqlRawTextsRequest
   * @returns DescribeSampleSqlRawTextsResponse
   */
  async describeSampleSqlRawTexts(request: DescribeSampleSqlRawTextsRequest): Promise<DescribeSampleSqlRawTextsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeSampleSqlRawTextsWithOptions(request, runtime);
  }

  /**
   * The name of the security group.
   * 
   * @param request - DescribeSecurityIpGroupsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeSecurityIpGroupsResponse
   */
  async describeSecurityIpGroupsWithOptions(request: DescribeSecurityIpGroupsRequest, runtime: $dara.RuntimeOptions): Promise<DescribeSecurityIpGroupsResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeSecurityIpGroups",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeSecurityIpGroupsResponse>(await this.callApi(params, req, runtime), new DescribeSecurityIpGroupsResponse({}));
    } else {
      return $dara.cast<DescribeSecurityIpGroupsResponse>(await this.execute(params, req, runtime), new DescribeSecurityIpGroupsResponse({}));
    }

  }

  /**
   * The name of the security group.
   * 
   * @param request - DescribeSecurityIpGroupsRequest
   * @returns DescribeSecurityIpGroupsResponse
   */
  async describeSecurityIpGroups(request: DescribeSecurityIpGroupsRequest): Promise<DescribeSecurityIpGroupsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeSecurityIpGroupsWithOptions(request, runtime);
  }

  /**
   * You can call this operation to query sessions between the ApsaraDB for OceanBase and the application.
   * 
   * @param request - DescribeSessionListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeSessionListResponse
   */
  async describeSessionListWithOptions(request: DescribeSessionListRequest, runtime: $dara.RuntimeOptions): Promise<DescribeSessionListResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeSessionList",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeSessionListResponse>(await this.callApi(params, req, runtime), new DescribeSessionListResponse({}));
    } else {
      return $dara.cast<DescribeSessionListResponse>(await this.execute(params, req, runtime), new DescribeSessionListResponse({}));
    }

  }

  /**
   * You can call this operation to query sessions between the ApsaraDB for OceanBase and the application.
   * 
   * @param request - DescribeSessionListRequest
   * @returns DescribeSessionListResponse
   */
  async describeSessionList(request: DescribeSessionListRequest): Promise<DescribeSessionListResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeSessionListWithOptions(request, runtime);
  }

  /**
   * You can call this operation to query the execution history of an SQL statement by SQL ID that is determined as a slow SQL statement during a specified period of time.
   * 
   * @param request - DescribeSlowSQLHistoryListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeSlowSQLHistoryListResponse
   */
  async describeSlowSQLHistoryListWithOptions(request: DescribeSlowSQLHistoryListRequest, runtime: $dara.RuntimeOptions): Promise<DescribeSlowSQLHistoryListResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.endTime)) {
      body["EndTime"] = request.endTime;
    }

    if (!$dara.isNull(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.SQLId)) {
      body["SQLId"] = request.SQLId;
    }

    if (!$dara.isNull(request.startTime)) {
      body["StartTime"] = request.startTime;
    }

    if (!$dara.isNull(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeSlowSQLHistoryList",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeSlowSQLHistoryListResponse>(await this.callApi(params, req, runtime), new DescribeSlowSQLHistoryListResponse({}));
    } else {
      return $dara.cast<DescribeSlowSQLHistoryListResponse>(await this.execute(params, req, runtime), new DescribeSlowSQLHistoryListResponse({}));
    }

  }

  /**
   * You can call this operation to query the execution history of an SQL statement by SQL ID that is determined as a slow SQL statement during a specified period of time.
   * 
   * @param request - DescribeSlowSQLHistoryListRequest
   * @returns DescribeSlowSQLHistoryListResponse
   */
  async describeSlowSQLHistoryList(request: DescribeSlowSQLHistoryListRequest): Promise<DescribeSlowSQLHistoryListResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeSlowSQLHistoryListWithOptions(request, runtime);
  }

  /**
   * You can call this operation to query the list of slow SQL statements
   * 
   * @param tmpReq - DescribeSlowSQLListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeSlowSQLListResponse
   */
  async describeSlowSQLListWithOptions(tmpReq: DescribeSlowSQLListRequest, runtime: $dara.RuntimeOptions): Promise<DescribeSlowSQLListResponse> {
    tmpReq.validate();
    let request = new DescribeSlowSQLListShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!$dara.isNull(tmpReq.filterCondition)) {
      request.filterConditionShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.filterCondition, "FilterCondition", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.dbName)) {
      body["DbName"] = request.dbName;
    }

    if (!$dara.isNull(request.endTime)) {
      body["EndTime"] = request.endTime;
    }

    if (!$dara.isNull(request.filterConditionShrink)) {
      body["FilterCondition"] = request.filterConditionShrink;
    }

    if (!$dara.isNull(request.nodeIp)) {
      body["NodeIp"] = request.nodeIp;
    }

    if (!$dara.isNull(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.SQLId)) {
      body["SQLId"] = request.SQLId;
    }

    if (!$dara.isNull(request.searchKeyWord)) {
      body["SearchKeyWord"] = request.searchKeyWord;
    }

    if (!$dara.isNull(request.searchParameter)) {
      body["SearchParameter"] = request.searchParameter;
    }

    if (!$dara.isNull(request.searchRule)) {
      body["SearchRule"] = request.searchRule;
    }

    if (!$dara.isNull(request.searchValue)) {
      body["SearchValue"] = request.searchValue;
    }

    if (!$dara.isNull(request.sortColumn)) {
      body["SortColumn"] = request.sortColumn;
    }

    if (!$dara.isNull(request.sortOrder)) {
      body["SortOrder"] = request.sortOrder;
    }

    if (!$dara.isNull(request.startTime)) {
      body["StartTime"] = request.startTime;
    }

    if (!$dara.isNull(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeSlowSQLList",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeSlowSQLListResponse>(await this.callApi(params, req, runtime), new DescribeSlowSQLListResponse({}));
    } else {
      return $dara.cast<DescribeSlowSQLListResponse>(await this.execute(params, req, runtime), new DescribeSlowSQLListResponse({}));
    }

  }

  /**
   * You can call this operation to query the list of slow SQL statements
   * 
   * @param request - DescribeSlowSQLListRequest
   * @returns DescribeSlowSQLListResponse
   */
  async describeSlowSQLList(request: DescribeSlowSQLListRequest): Promise<DescribeSlowSQLListResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeSlowSQLListWithOptions(request, runtime);
  }

  /**
   * 按照客户端IP、用户、SQLID的维度统计SQL数据执行情况
   * 
   * @param request - DescribeSqlAuditStatRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeSqlAuditStatResponse
   */
  async describeSqlAuditStatWithOptions(request: DescribeSqlAuditStatRequest, runtime: $dara.RuntimeOptions): Promise<DescribeSqlAuditStatResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.endTime)) {
      body["EndTime"] = request.endTime;
    }

    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.startTime)) {
      body["StartTime"] = request.startTime;
    }

    if (!$dara.isNull(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeSqlAuditStat",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeSqlAuditStatResponse>(await this.callApi(params, req, runtime), new DescribeSqlAuditStatResponse({}));
    } else {
      return $dara.cast<DescribeSqlAuditStatResponse>(await this.execute(params, req, runtime), new DescribeSqlAuditStatResponse({}));
    }

  }

  /**
   * 按照客户端IP、用户、SQLID的维度统计SQL数据执行情况
   * 
   * @param request - DescribeSqlAuditStatRequest
   * @returns DescribeSqlAuditStatResponse
   */
  async describeSqlAuditStat(request: DescribeSqlAuditStatRequest): Promise<DescribeSqlAuditStatResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeSqlAuditStatWithOptions(request, runtime);
  }

  /**
   * DescribeStandbyCreateMode
   * 
   * @param request - DescribeStandbyCreateModeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeStandbyCreateModeResponse
   */
  async describeStandbyCreateModeWithOptions(request: DescribeStandbyCreateModeRequest, runtime: $dara.RuntimeOptions): Promise<DescribeStandbyCreateModeResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeStandbyCreateMode",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeStandbyCreateModeResponse>(await this.callApi(params, req, runtime), new DescribeStandbyCreateModeResponse({}));
    } else {
      return $dara.cast<DescribeStandbyCreateModeResponse>(await this.execute(params, req, runtime), new DescribeStandbyCreateModeResponse({}));
    }

  }

  /**
   * DescribeStandbyCreateMode
   * 
   * @param request - DescribeStandbyCreateModeRequest
   * @returns DescribeStandbyCreateModeResponse
   */
  async describeStandbyCreateMode(request: DescribeStandbyCreateModeRequest): Promise<DescribeStandbyCreateModeResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeStandbyCreateModeWithOptions(request, runtime);
  }

  /**
   * You can call this operation to query tags.
   * 
   * @param request - DescribeTagValuesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeTagValuesResponse
   */
  async describeTagValuesWithOptions(request: DescribeTagValuesRequest, runtime: $dara.RuntimeOptions): Promise<DescribeTagValuesResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.resourceType)) {
      body["ResourceType"] = request.resourceType;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeTagValues",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeTagValuesResponse>(await this.callApi(params, req, runtime), new DescribeTagValuesResponse({}));
    } else {
      return $dara.cast<DescribeTagValuesResponse>(await this.execute(params, req, runtime), new DescribeTagValuesResponse({}));
    }

  }

  /**
   * You can call this operation to query tags.
   * 
   * @param request - DescribeTagValuesRequest
   * @returns DescribeTagValuesResponse
   */
  async describeTagValues(request: DescribeTagValuesRequest): Promise<DescribeTagValuesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeTagValuesWithOptions(request, runtime);
  }

  /**
   * You can call this operation to query the information of a specific tenant in a specific cluster.
   * 
   * @param request - DescribeTenantRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeTenantResponse
   */
  async describeTenantWithOptions(request: DescribeTenantRequest, runtime: $dara.RuntimeOptions): Promise<DescribeTenantResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeTenant",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeTenantResponse>(await this.callApi(params, req, runtime), new DescribeTenantResponse({}));
    } else {
      return $dara.cast<DescribeTenantResponse>(await this.execute(params, req, runtime), new DescribeTenantResponse({}));
    }

  }

  /**
   * You can call this operation to query the information of a specific tenant in a specific cluster.
   * 
   * @param request - DescribeTenantRequest
   * @returns DescribeTenantResponse
   */
  async describeTenant(request: DescribeTenantRequest): Promise<DescribeTenantResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeTenantWithOptions(request, runtime);
  }

  /**
   * 查询租户加密信息
   * 
   * @param request - DescribeTenantEncryptionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeTenantEncryptionResponse
   */
  async describeTenantEncryptionWithOptions(request: DescribeTenantEncryptionRequest, runtime: $dara.RuntimeOptions): Promise<DescribeTenantEncryptionResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    if (!$dara.isNull(request.tenantName)) {
      body["TenantName"] = request.tenantName;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeTenantEncryption",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeTenantEncryptionResponse>(await this.callApi(params, req, runtime), new DescribeTenantEncryptionResponse({}));
    } else {
      return $dara.cast<DescribeTenantEncryptionResponse>(await this.execute(params, req, runtime), new DescribeTenantEncryptionResponse({}));
    }

  }

  /**
   * 查询租户加密信息
   * 
   * @param request - DescribeTenantEncryptionRequest
   * @returns DescribeTenantEncryptionResponse
   */
  async describeTenantEncryption(request: DescribeTenantEncryptionRequest): Promise<DescribeTenantEncryptionResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeTenantEncryptionWithOptions(request, runtime);
  }

  /**
   * The list of tenant IDs.
   * 
   * @param request - DescribeTenantMetricsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeTenantMetricsResponse
   */
  async describeTenantMetricsWithOptions(request: DescribeTenantMetricsRequest, runtime: $dara.RuntimeOptions): Promise<DescribeTenantMetricsResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.endTime)) {
      body["EndTime"] = request.endTime;
    }

    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.metrics)) {
      body["Metrics"] = request.metrics;
    }

    if (!$dara.isNull(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.startTime)) {
      body["StartTime"] = request.startTime;
    }

    if (!$dara.isNull(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    if (!$dara.isNull(request.tenantIdList)) {
      body["TenantIdList"] = request.tenantIdList;
    }

    if (!$dara.isNull(request.tenantName)) {
      body["TenantName"] = request.tenantName;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeTenantMetrics",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeTenantMetricsResponse>(await this.callApi(params, req, runtime), new DescribeTenantMetricsResponse({}));
    } else {
      return $dara.cast<DescribeTenantMetricsResponse>(await this.execute(params, req, runtime), new DescribeTenantMetricsResponse({}));
    }

  }

  /**
   * The list of tenant IDs.
   * 
   * @param request - DescribeTenantMetricsRequest
   * @returns DescribeTenantMetricsResponse
   */
  async describeTenantMetrics(request: DescribeTenantMetricsRequest): Promise<DescribeTenantMetricsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeTenantMetricsWithOptions(request, runtime);
  }

  /**
   * You can call this operation to query the maximum readable timestamp of a tenant.
   * 
   * @param request - DescribeTenantReadableScnRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeTenantReadableScnResponse
   */
  async describeTenantReadableScnWithOptions(request: DescribeTenantReadableScnRequest, runtime: $dara.RuntimeOptions): Promise<DescribeTenantReadableScnResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeTenantReadableScn",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeTenantReadableScnResponse>(await this.callApi(params, req, runtime), new DescribeTenantReadableScnResponse({}));
    } else {
      return $dara.cast<DescribeTenantReadableScnResponse>(await this.execute(params, req, runtime), new DescribeTenantReadableScnResponse({}));
    }

  }

  /**
   * You can call this operation to query the maximum readable timestamp of a tenant.
   * 
   * @param request - DescribeTenantReadableScnRequest
   * @returns DescribeTenantReadableScnResponse
   */
  async describeTenantReadableScn(request: DescribeTenantReadableScnRequest): Promise<DescribeTenantReadableScnResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeTenantReadableScnWithOptions(request, runtime);
  }

  /**
   * You can call this operation to query security check items of an OceanBase Database tenant.
   * 
   * @param request - DescribeTenantSecurityConfigsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeTenantSecurityConfigsResponse
   */
  async describeTenantSecurityConfigsWithOptions(request: DescribeTenantSecurityConfigsRequest, runtime: $dara.RuntimeOptions): Promise<DescribeTenantSecurityConfigsResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.checkId)) {
      body["CheckId"] = request.checkId;
    }

    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeTenantSecurityConfigs",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeTenantSecurityConfigsResponse>(await this.callApi(params, req, runtime), new DescribeTenantSecurityConfigsResponse({}));
    } else {
      return $dara.cast<DescribeTenantSecurityConfigsResponse>(await this.execute(params, req, runtime), new DescribeTenantSecurityConfigsResponse({}));
    }

  }

  /**
   * You can call this operation to query security check items of an OceanBase Database tenant.
   * 
   * @param request - DescribeTenantSecurityConfigsRequest
   * @returns DescribeTenantSecurityConfigsResponse
   */
  async describeTenantSecurityConfigs(request: DescribeTenantSecurityConfigsRequest): Promise<DescribeTenantSecurityConfigsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeTenantSecurityConfigsWithOptions(request, runtime);
  }

  /**
   * You can call this operation to view the list of whitelist groups of the tenant.
   * 
   * @param request - DescribeTenantSecurityIpGroupsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeTenantSecurityIpGroupsResponse
   */
  async describeTenantSecurityIpGroupsWithOptions(request: DescribeTenantSecurityIpGroupsRequest, runtime: $dara.RuntimeOptions): Promise<DescribeTenantSecurityIpGroupsResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeTenantSecurityIpGroups",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeTenantSecurityIpGroupsResponse>(await this.callApi(params, req, runtime), new DescribeTenantSecurityIpGroupsResponse({}));
    } else {
      return $dara.cast<DescribeTenantSecurityIpGroupsResponse>(await this.execute(params, req, runtime), new DescribeTenantSecurityIpGroupsResponse({}));
    }

  }

  /**
   * You can call this operation to view the list of whitelist groups of the tenant.
   * 
   * @param request - DescribeTenantSecurityIpGroupsRequest
   * @returns DescribeTenantSecurityIpGroupsResponse
   */
  async describeTenantSecurityIpGroups(request: DescribeTenantSecurityIpGroupsRequest): Promise<DescribeTenantSecurityIpGroupsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeTenantSecurityIpGroupsWithOptions(request, runtime);
  }

  /**
   * You can call this operation to query the tags of tenants in a cluster.
   * 
   * @param request - DescribeTenantTagsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeTenantTagsResponse
   */
  async describeTenantTagsWithOptions(request: DescribeTenantTagsRequest, runtime: $dara.RuntimeOptions): Promise<DescribeTenantTagsResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.tags)) {
      body["Tags"] = request.tags;
    }

    if (!$dara.isNull(request.tenantIds)) {
      body["TenantIds"] = request.tenantIds;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeTenantTags",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeTenantTagsResponse>(await this.callApi(params, req, runtime), new DescribeTenantTagsResponse({}));
    } else {
      return $dara.cast<DescribeTenantTagsResponse>(await this.execute(params, req, runtime), new DescribeTenantTagsResponse({}));
    }

  }

  /**
   * You can call this operation to query the tags of tenants in a cluster.
   * 
   * @param request - DescribeTenantTagsRequest
   * @returns DescribeTenantTagsResponse
   */
  async describeTenantTags(request: DescribeTenantTagsRequest): Promise<DescribeTenantTagsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeTenantTagsWithOptions(request, runtime);
  }

  /**
   * You can call this operation to obtain the account authorization information of the tenant.
   * 
   * @param request - DescribeTenantUserRolesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeTenantUserRolesResponse
   */
  async describeTenantUserRolesWithOptions(request: DescribeTenantUserRolesRequest, runtime: $dara.RuntimeOptions): Promise<DescribeTenantUserRolesResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeTenantUserRoles",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeTenantUserRolesResponse>(await this.callApi(params, req, runtime), new DescribeTenantUserRolesResponse({}));
    } else {
      return $dara.cast<DescribeTenantUserRolesResponse>(await this.execute(params, req, runtime), new DescribeTenantUserRolesResponse({}));
    }

  }

  /**
   * You can call this operation to obtain the account authorization information of the tenant.
   * 
   * @param request - DescribeTenantUserRolesRequest
   * @returns DescribeTenantUserRolesResponse
   */
  async describeTenantUserRoles(request: DescribeTenantUserRolesRequest): Promise<DescribeTenantUserRolesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeTenantUserRolesWithOptions(request, runtime);
  }

  /**
   * The return result of the request.
   * 
   * @param request - DescribeTenantUsersRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeTenantUsersResponse
   */
  async describeTenantUsersWithOptions(request: DescribeTenantUsersRequest, runtime: $dara.RuntimeOptions): Promise<DescribeTenantUsersResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.searchKey)) {
      body["SearchKey"] = request.searchKey;
    }

    if (!$dara.isNull(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    if (!$dara.isNull(request.userName)) {
      body["UserName"] = request.userName;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeTenantUsers",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeTenantUsersResponse>(await this.callApi(params, req, runtime), new DescribeTenantUsersResponse({}));
    } else {
      return $dara.cast<DescribeTenantUsersResponse>(await this.execute(params, req, runtime), new DescribeTenantUsersResponse({}));
    }

  }

  /**
   * The return result of the request.
   * 
   * @param request - DescribeTenantUsersRequest
   * @returns DescribeTenantUsersResponse
   */
  async describeTenantUsers(request: DescribeTenantUsersRequest): Promise<DescribeTenantUsersResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeTenantUsersWithOptions(request, runtime);
  }

  /**
   * Indicates whether a read-only connection has been created.
   * 
   * @param request - DescribeTenantZonesReadRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeTenantZonesReadResponse
   */
  async describeTenantZonesReadWithOptions(request: DescribeTenantZonesReadRequest, runtime: $dara.RuntimeOptions): Promise<DescribeTenantZonesReadResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeTenantZonesRead",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeTenantZonesReadResponse>(await this.callApi(params, req, runtime), new DescribeTenantZonesReadResponse({}));
    } else {
      return $dara.cast<DescribeTenantZonesReadResponse>(await this.execute(params, req, runtime), new DescribeTenantZonesReadResponse({}));
    }

  }

  /**
   * Indicates whether a read-only connection has been created.
   * 
   * @param request - DescribeTenantZonesReadRequest
   * @returns DescribeTenantZonesReadResponse
   */
  async describeTenantZonesRead(request: DescribeTenantZonesReadRequest): Promise<DescribeTenantZonesReadResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeTenantZonesReadWithOptions(request, runtime);
  }

  /**
   * You can call this operation to query the tenants in an OceanBase cluster.
   * 
   * @param request - DescribeTenantsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeTenantsResponse
   */
  async describeTenantsWithOptions(request: DescribeTenantsRequest, runtime: $dara.RuntimeOptions): Promise<DescribeTenantsResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.searchKey)) {
      body["SearchKey"] = request.searchKey;
    }

    if (!$dara.isNull(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    if (!$dara.isNull(request.tenantName)) {
      body["TenantName"] = request.tenantName;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeTenants",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeTenantsResponse>(await this.callApi(params, req, runtime), new DescribeTenantsResponse({}));
    } else {
      return $dara.cast<DescribeTenantsResponse>(await this.execute(params, req, runtime), new DescribeTenantsResponse({}));
    }

  }

  /**
   * You can call this operation to query the tenants in an OceanBase cluster.
   * 
   * @param request - DescribeTenantsRequest
   * @returns DescribeTenantsResponse
   */
  async describeTenants(request: DescribeTenantsRequest): Promise<DescribeTenantsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeTenantsWithOptions(request, runtime);
  }

  /**
   * The time zones supported by the tenant.
   * 
   * @param request - DescribeTimeZonesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeTimeZonesResponse
   */
  async describeTimeZonesWithOptions(runtime: $dara.RuntimeOptions): Promise<DescribeTimeZonesResponse> {
    let req = new $OpenApiUtil.OpenApiRequest({ });
    let params = new $OpenApiUtil.Params({
      action: "DescribeTimeZones",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeTimeZonesResponse>(await this.callApi(params, req, runtime), new DescribeTimeZonesResponse({}));
    } else {
      return $dara.cast<DescribeTimeZonesResponse>(await this.execute(params, req, runtime), new DescribeTimeZonesResponse({}));
    }

  }

  /**
   * The time zones supported by the tenant.
   * @returns DescribeTimeZonesResponse
   */
  async describeTimeZones(): Promise<DescribeTimeZonesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeTimeZonesWithOptions(runtime);
  }

  /**
   * The name of the database.
   * 
   * @param tmpReq - DescribeTopSQLListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeTopSQLListResponse
   */
  async describeTopSQLListWithOptions(tmpReq: DescribeTopSQLListRequest, runtime: $dara.RuntimeOptions): Promise<DescribeTopSQLListResponse> {
    tmpReq.validate();
    let request = new DescribeTopSQLListShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!$dara.isNull(tmpReq.filterCondition)) {
      request.filterConditionShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.filterCondition, "FilterCondition", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.dbName)) {
      body["DbName"] = request.dbName;
    }

    if (!$dara.isNull(request.endTime)) {
      body["EndTime"] = request.endTime;
    }

    if (!$dara.isNull(request.filterConditionShrink)) {
      body["FilterCondition"] = request.filterConditionShrink;
    }

    if (!$dara.isNull(request.nodeIp)) {
      body["NodeIp"] = request.nodeIp;
    }

    if (!$dara.isNull(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.SQLId)) {
      body["SQLId"] = request.SQLId;
    }

    if (!$dara.isNull(request.searchKeyWord)) {
      body["SearchKeyWord"] = request.searchKeyWord;
    }

    if (!$dara.isNull(request.searchParameter)) {
      body["SearchParameter"] = request.searchParameter;
    }

    if (!$dara.isNull(request.searchRule)) {
      body["SearchRule"] = request.searchRule;
    }

    if (!$dara.isNull(request.searchValue)) {
      body["SearchValue"] = request.searchValue;
    }

    if (!$dara.isNull(request.sortColumn)) {
      body["SortColumn"] = request.sortColumn;
    }

    if (!$dara.isNull(request.sortOrder)) {
      body["SortOrder"] = request.sortOrder;
    }

    if (!$dara.isNull(request.startTime)) {
      body["StartTime"] = request.startTime;
    }

    if (!$dara.isNull(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeTopSQLList",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeTopSQLListResponse>(await this.callApi(params, req, runtime), new DescribeTopSQLListResponse({}));
    } else {
      return $dara.cast<DescribeTopSQLListResponse>(await this.execute(params, req, runtime), new DescribeTopSQLListResponse({}));
    }

  }

  /**
   * The name of the database.
   * 
   * @param request - DescribeTopSQLListRequest
   * @returns DescribeTopSQLListResponse
   */
  async describeTopSQLList(request: DescribeTopSQLListRequest): Promise<DescribeTopSQLListResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeTopSQLListWithOptions(request, runtime);
  }

  /**
   * The deployment mode.
   * 
   * @param request - DescribeZonesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeZonesResponse
   */
  async describeZonesWithOptions(request: DescribeZonesRequest, runtime: $dara.RuntimeOptions): Promise<DescribeZonesResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.cpuArch)) {
      body["CpuArch"] = request.cpuArch;
    }

    if (!$dara.isNull(request.deployType)) {
      body["DeployType"] = request.deployType;
    }

    if (!$dara.isNull(request.series)) {
      body["Series"] = request.series;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeZones",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeZonesResponse>(await this.callApi(params, req, runtime), new DescribeZonesResponse({}));
    } else {
      return $dara.cast<DescribeZonesResponse>(await this.execute(params, req, runtime), new DescribeZonesResponse({}));
    }

  }

  /**
   * The deployment mode.
   * 
   * @param request - DescribeZonesRequest
   * @returns DescribeZonesResponse
   */
  async describeZones(request: DescribeZonesRequest): Promise<DescribeZonesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeZonesWithOptions(request, runtime);
  }

  /**
   * 公有云上传OSS 获取一个临时上传url
   * 
   * @param request - GetUploadOssUrlRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetUploadOssUrlResponse
   */
  async getUploadOssUrlWithOptions(request: GetUploadOssUrlRequest, runtime: $dara.RuntimeOptions): Promise<GetUploadOssUrlResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.effectiveTimeMinutes)) {
      body["EffectiveTimeMinutes"] = request.effectiveTimeMinutes;
    }

    if (!$dara.isNull(request.type)) {
      body["Type"] = request.type;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetUploadOssUrl",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<GetUploadOssUrlResponse>(await this.callApi(params, req, runtime), new GetUploadOssUrlResponse({}));
    } else {
      return $dara.cast<GetUploadOssUrlResponse>(await this.execute(params, req, runtime), new GetUploadOssUrlResponse({}));
    }

  }

  /**
   * 公有云上传OSS 获取一个临时上传url
   * 
   * @param request - GetUploadOssUrlRequest
   * @returns GetUploadOssUrlResponse
   */
  async getUploadOssUrl(request: GetUploadOssUrlRequest): Promise<GetUploadOssUrlResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getUploadOssUrlWithOptions(request, runtime);
  }

  /**
   * You can call this operation to close a session.
   * 
   * @param request - KillProcessListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns KillProcessListResponse
   */
  async killProcessListWithOptions(request: KillProcessListRequest, runtime: $dara.RuntimeOptions): Promise<KillProcessListResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.sessionList)) {
      body["SessionList"] = request.sessionList;
    }

    if (!$dara.isNull(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "KillProcessList",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<KillProcessListResponse>(await this.callApi(params, req, runtime), new KillProcessListResponse({}));
    } else {
      return $dara.cast<KillProcessListResponse>(await this.execute(params, req, runtime), new KillProcessListResponse({}));
    }

  }

  /**
   * You can call this operation to close a session.
   * 
   * @param request - KillProcessListRequest
   * @returns KillProcessListResponse
   */
  async killProcessList(request: KillProcessListRequest): Promise<KillProcessListResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.killProcessListWithOptions(request, runtime);
  }

  /**
   * 查询标签列表
   * 
   * @param request - ListAllLabelsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListAllLabelsResponse
   */
  async listAllLabelsWithOptions(runtime: $dara.RuntimeOptions): Promise<ListAllLabelsResponse> {
    let req = new $OpenApiUtil.OpenApiRequest({ });
    let params = new $OpenApiUtil.Params({
      action: "ListAllLabels",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ListAllLabelsResponse>(await this.callApi(params, req, runtime), new ListAllLabelsResponse({}));
    } else {
      return $dara.cast<ListAllLabelsResponse>(await this.execute(params, req, runtime), new ListAllLabelsResponse({}));
    }

  }

  /**
   * 查询标签列表
   * @returns ListAllLabelsResponse
   */
  async listAllLabels(): Promise<ListAllLabelsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listAllLabelsWithOptions(runtime);
  }

  /**
   * 查询数据源列表 (MySql、OB_MYSQL、OB_ORACLE)
   * 
   * @param tmpReq - ListDataSourceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListDataSourceResponse
   */
  async listDataSourceWithOptions(tmpReq: ListDataSourceRequest, runtime: $dara.RuntimeOptions): Promise<ListDataSourceResponse> {
    tmpReq.validate();
    let request = new ListDataSourceShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!$dara.isNull(tmpReq.types)) {
      request.typesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.types, "Types", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.order)) {
      body["Order"] = request.order;
    }

    if (!$dara.isNull(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.searchKey)) {
      body["SearchKey"] = request.searchKey;
    }

    if (!$dara.isNull(request.sortField)) {
      body["SortField"] = request.sortField;
    }

    if (!$dara.isNull(request.typesShrink)) {
      body["Types"] = request.typesShrink;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListDataSource",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ListDataSourceResponse>(await this.callApi(params, req, runtime), new ListDataSourceResponse({}));
    } else {
      return $dara.cast<ListDataSourceResponse>(await this.execute(params, req, runtime), new ListDataSourceResponse({}));
    }

  }

  /**
   * 查询数据源列表 (MySql、OB_MYSQL、OB_ORACLE)
   * 
   * @param request - ListDataSourceRequest
   * @returns ListDataSourceResponse
   */
  async listDataSource(request: ListDataSourceRequest): Promise<ListDataSourceResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listDataSourceWithOptions(request, runtime);
  }

  /**
   * 查询项目的全量校验结果
   * 
   * @param tmpReq - ListProjectFullVerifyResultRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListProjectFullVerifyResultResponse
   */
  async listProjectFullVerifyResultWithOptions(tmpReq: ListProjectFullVerifyResultRequest, runtime: $dara.RuntimeOptions): Promise<ListProjectFullVerifyResultResponse> {
    tmpReq.validate();
    let request = new ListProjectFullVerifyResultShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!$dara.isNull(tmpReq.destSchemas)) {
      request.destSchemasShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.destSchemas, "DestSchemas", "json");
    }

    if (!$dara.isNull(tmpReq.sourceSchemas)) {
      request.sourceSchemasShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sourceSchemas, "SourceSchemas", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.destSchemasShrink)) {
      body["DestSchemas"] = request.destSchemasShrink;
    }

    if (!$dara.isNull(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!$dara.isNull(request.sourceSchemasShrink)) {
      body["SourceSchemas"] = request.sourceSchemasShrink;
    }

    if (!$dara.isNull(request.status)) {
      body["Status"] = request.status;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListProjectFullVerifyResult",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ListProjectFullVerifyResultResponse>(await this.callApi(params, req, runtime), new ListProjectFullVerifyResultResponse({}));
    } else {
      return $dara.cast<ListProjectFullVerifyResultResponse>(await this.execute(params, req, runtime), new ListProjectFullVerifyResultResponse({}));
    }

  }

  /**
   * 查询项目的全量校验结果
   * 
   * @param request - ListProjectFullVerifyResultRequest
   * @returns ListProjectFullVerifyResultResponse
   */
  async listProjectFullVerifyResult(request: ListProjectFullVerifyResultRequest): Promise<ListProjectFullVerifyResultResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listProjectFullVerifyResultWithOptions(request, runtime);
  }

  /**
   * 根据项目 ID 查询项目的修改记录
   * 
   * @param request - ListProjectModifyRecordsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListProjectModifyRecordsResponse
   */
  async listProjectModifyRecordsWithOptions(request: ListProjectModifyRecordsRequest, runtime: $dara.RuntimeOptions): Promise<ListProjectModifyRecordsResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.id)) {
      body["Id"] = request.id;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListProjectModifyRecords",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ListProjectModifyRecordsResponse>(await this.callApi(params, req, runtime), new ListProjectModifyRecordsResponse({}));
    } else {
      return $dara.cast<ListProjectModifyRecordsResponse>(await this.execute(params, req, runtime), new ListProjectModifyRecordsResponse({}));
    }

  }

  /**
   * 根据项目 ID 查询项目的修改记录
   * 
   * @param request - ListProjectModifyRecordsRequest
   * @returns ListProjectModifyRecordsResponse
   */
  async listProjectModifyRecords(request: ListProjectModifyRecordsRequest): Promise<ListProjectModifyRecordsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listProjectModifyRecordsWithOptions(request, runtime);
  }

  /**
   * 查询项目列表
   * 
   * @param tmpReq - ListProjectsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListProjectsResponse
   */
  async listProjectsWithOptions(tmpReq: ListProjectsRequest, runtime: $dara.RuntimeOptions): Promise<ListProjectsResponse> {
    tmpReq.validate();
    let request = new ListProjectsShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!$dara.isNull(tmpReq.labelIds)) {
      request.labelIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.labelIds, "LabelIds", "json");
    }

    if (!$dara.isNull(tmpReq.sinkEndpointTypes)) {
      request.sinkEndpointTypesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sinkEndpointTypes, "SinkEndpointTypes", "json");
    }

    if (!$dara.isNull(tmpReq.sourceEndpointTypes)) {
      request.sourceEndpointTypesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sourceEndpointTypes, "SourceEndpointTypes", "json");
    }

    if (!$dara.isNull(tmpReq.status)) {
      request.statusShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.status, "Status", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.labelIdsShrink)) {
      body["LabelIds"] = request.labelIdsShrink;
    }

    if (!$dara.isNull(request.needRelatedInfo)) {
      body["NeedRelatedInfo"] = request.needRelatedInfo;
    }

    if (!$dara.isNull(request.order)) {
      body["Order"] = request.order;
    }

    if (!$dara.isNull(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.searchKey)) {
      body["SearchKey"] = request.searchKey;
    }

    if (!$dara.isNull(request.sinkEndpointTypesShrink)) {
      body["SinkEndpointTypes"] = request.sinkEndpointTypesShrink;
    }

    if (!$dara.isNull(request.sortField)) {
      body["SortField"] = request.sortField;
    }

    if (!$dara.isNull(request.sourceEndpointTypesShrink)) {
      body["SourceEndpointTypes"] = request.sourceEndpointTypesShrink;
    }

    if (!$dara.isNull(request.statusShrink)) {
      body["Status"] = request.statusShrink;
    }

    if (!$dara.isNull(request.type)) {
      body["Type"] = request.type;
    }

    if (!$dara.isNull(request.visibleSubProject)) {
      body["VisibleSubProject"] = request.visibleSubProject;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListProjects",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ListProjectsResponse>(await this.callApi(params, req, runtime), new ListProjectsResponse({}));
    } else {
      return $dara.cast<ListProjectsResponse>(await this.execute(params, req, runtime), new ListProjectsResponse({}));
    }

  }

  /**
   * 查询项目列表
   * 
   * @param request - ListProjectsRequest
   * @returns ListProjectsResponse
   */
  async listProjects(request: ListProjectsRequest): Promise<ListProjectsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listProjectsWithOptions(request, runtime);
  }

  /**
   * 查询传输实例列表
   * 
   * @param tmpReq - ListWorkerInstancesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListWorkerInstancesResponse
   */
  async listWorkerInstancesWithOptions(tmpReq: ListWorkerInstancesRequest, runtime: $dara.RuntimeOptions): Promise<ListWorkerInstancesResponse> {
    tmpReq.validate();
    let request = new ListWorkerInstancesShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!$dara.isNull(tmpReq.specs)) {
      request.specsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.specs, "Specs", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.destType)) {
      body["DestType"] = request.destType;
    }

    if (!$dara.isNull(request.instanceName)) {
      body["InstanceName"] = request.instanceName;
    }

    if (!$dara.isNull(request.onlyBindable)) {
      body["OnlyBindable"] = request.onlyBindable;
    }

    if (!$dara.isNull(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.sourceType)) {
      body["SourceType"] = request.sourceType;
    }

    if (!$dara.isNull(request.specsShrink)) {
      body["Specs"] = request.specsShrink;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListWorkerInstances",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ListWorkerInstancesResponse>(await this.callApi(params, req, runtime), new ListWorkerInstancesResponse({}));
    } else {
      return $dara.cast<ListWorkerInstancesResponse>(await this.execute(params, req, runtime), new ListWorkerInstancesResponse({}));
    }

  }

  /**
   * 查询传输实例列表
   * 
   * @param request - ListWorkerInstancesRequest
   * @returns ListWorkerInstancesResponse
   */
  async listWorkerInstances(request: ListWorkerInstancesRequest): Promise<ListWorkerInstancesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listWorkerInstancesWithOptions(request, runtime);
  }

  /**
   * The request ID.
   * 
   * @param request - ModifyDatabaseDescriptionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyDatabaseDescriptionResponse
   */
  async modifyDatabaseDescriptionWithOptions(request: ModifyDatabaseDescriptionRequest, runtime: $dara.RuntimeOptions): Promise<ModifyDatabaseDescriptionResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.databaseName)) {
      body["DatabaseName"] = request.databaseName;
    }

    if (!$dara.isNull(request.description)) {
      body["Description"] = request.description;
    }

    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyDatabaseDescription",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ModifyDatabaseDescriptionResponse>(await this.callApi(params, req, runtime), new ModifyDatabaseDescriptionResponse({}));
    } else {
      return $dara.cast<ModifyDatabaseDescriptionResponse>(await this.execute(params, req, runtime), new ModifyDatabaseDescriptionResponse({}));
    }

  }

  /**
   * The request ID.
   * 
   * @param request - ModifyDatabaseDescriptionRequest
   * @returns ModifyDatabaseDescriptionResponse
   */
  async modifyDatabaseDescription(request: ModifyDatabaseDescriptionRequest): Promise<ModifyDatabaseDescriptionResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyDatabaseDescriptionWithOptions(request, runtime);
  }

  /**
   * The accounts that have privileges on the database.
   * 
   * @param request - ModifyDatabaseUserRolesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyDatabaseUserRolesResponse
   */
  async modifyDatabaseUserRolesWithOptions(request: ModifyDatabaseUserRolesRequest, runtime: $dara.RuntimeOptions): Promise<ModifyDatabaseUserRolesResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.databaseName)) {
      body["DatabaseName"] = request.databaseName;
    }

    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    if (!$dara.isNull(request.users)) {
      body["Users"] = request.users;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyDatabaseUserRoles",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ModifyDatabaseUserRolesResponse>(await this.callApi(params, req, runtime), new ModifyDatabaseUserRolesResponse({}));
    } else {
      return $dara.cast<ModifyDatabaseUserRolesResponse>(await this.execute(params, req, runtime), new ModifyDatabaseUserRolesResponse({}));
    }

  }

  /**
   * The accounts that have privileges on the database.
   * 
   * @param request - ModifyDatabaseUserRolesRequest
   * @returns ModifyDatabaseUserRolesResponse
   */
  async modifyDatabaseUserRoles(request: ModifyDatabaseUserRolesRequest): Promise<ModifyDatabaseUserRolesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyDatabaseUserRolesWithOptions(request, runtime);
  }

  /**
   * The name of the OceanBase cluster.
   * 
   * @param request - ModifyInstanceNameRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyInstanceNameResponse
   */
  async modifyInstanceNameWithOptions(request: ModifyInstanceNameRequest, runtime: $dara.RuntimeOptions): Promise<ModifyInstanceNameResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.instanceName)) {
      body["InstanceName"] = request.instanceName;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyInstanceName",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ModifyInstanceNameResponse>(await this.callApi(params, req, runtime), new ModifyInstanceNameResponse({}));
    } else {
      return $dara.cast<ModifyInstanceNameResponse>(await this.execute(params, req, runtime), new ModifyInstanceNameResponse({}));
    }

  }

  /**
   * The name of the OceanBase cluster.
   * 
   * @param request - ModifyInstanceNameRequest
   * @returns ModifyInstanceNameResponse
   */
  async modifyInstanceName(request: ModifyInstanceNameRequest): Promise<ModifyInstanceNameResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyInstanceNameWithOptions(request, runtime);
  }

  /**
   * You can call this operation to modify the number of nodes in a cluster.
   * 
   * @param request - ModifyInstanceNodeNumRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyInstanceNodeNumResponse
   */
  async modifyInstanceNodeNumWithOptions(request: ModifyInstanceNodeNumRequest, runtime: $dara.RuntimeOptions): Promise<ModifyInstanceNodeNumResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.dryRun)) {
      body["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.nodeNum)) {
      body["NodeNum"] = request.nodeNum;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyInstanceNodeNum",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ModifyInstanceNodeNumResponse>(await this.callApi(params, req, runtime), new ModifyInstanceNodeNumResponse({}));
    } else {
      return $dara.cast<ModifyInstanceNodeNumResponse>(await this.execute(params, req, runtime), new ModifyInstanceNodeNumResponse({}));
    }

  }

  /**
   * You can call this operation to modify the number of nodes in a cluster.
   * 
   * @param request - ModifyInstanceNodeNumRequest
   * @returns ModifyInstanceNodeNumResponse
   */
  async modifyInstanceNodeNum(request: ModifyInstanceNodeNumRequest): Promise<ModifyInstanceNodeNumResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyInstanceNodeNumWithOptions(request, runtime);
  }

  /**
   * You can call this operation to modify the Secure Sockets Layer (SSL) setting for an OceanBase cluster instance.
   * 
   * @remarks
   * There is currently no authorization information disclosed in the API.
   * 
   * @param request - ModifyInstanceSSLRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyInstanceSSLResponse
   */
  async modifyInstanceSSLWithOptions(request: ModifyInstanceSSLRequest, runtime: $dara.RuntimeOptions): Promise<ModifyInstanceSSLResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.enableSSL)) {
      body["EnableSSL"] = request.enableSSL;
    }

    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyInstanceSSL",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ModifyInstanceSSLResponse>(await this.callApi(params, req, runtime), new ModifyInstanceSSLResponse({}));
    } else {
      return $dara.cast<ModifyInstanceSSLResponse>(await this.execute(params, req, runtime), new ModifyInstanceSSLResponse({}));
    }

  }

  /**
   * You can call this operation to modify the Secure Sockets Layer (SSL) setting for an OceanBase cluster instance.
   * 
   * @remarks
   * There is currently no authorization information disclosed in the API.
   * 
   * @param request - ModifyInstanceSSLRequest
   * @returns ModifyInstanceSSLResponse
   */
  async modifyInstanceSSL(request: ModifyInstanceSSLRequest): Promise<ModifyInstanceSSLResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyInstanceSSLWithOptions(request, runtime);
  }

  /**
   * You can call this operation to modify the cluster specifications and storage space.
   * 
   * @param request - ModifyInstanceSpecRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyInstanceSpecResponse
   */
  async modifyInstanceSpecWithOptions(request: ModifyInstanceSpecRequest, runtime: $dara.RuntimeOptions): Promise<ModifyInstanceSpecResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.diskSize)) {
      body["DiskSize"] = request.diskSize;
    }

    if (!$dara.isNull(request.diskType)) {
      body["DiskType"] = request.diskType;
    }

    if (!$dara.isNull(request.dryRun)) {
      body["DryRun"] = request.dryRun;
    }

    if (!$dara.isNull(request.instanceClass)) {
      body["InstanceClass"] = request.instanceClass;
    }

    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.upgradeSpecNative)) {
      body["UpgradeSpecNative"] = request.upgradeSpecNative;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyInstanceSpec",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ModifyInstanceSpecResponse>(await this.callApi(params, req, runtime), new ModifyInstanceSpecResponse({}));
    } else {
      return $dara.cast<ModifyInstanceSpecResponse>(await this.execute(params, req, runtime), new ModifyInstanceSpecResponse({}));
    }

  }

  /**
   * You can call this operation to modify the cluster specifications and storage space.
   * 
   * @param request - ModifyInstanceSpecRequest
   * @returns ModifyInstanceSpecResponse
   */
  async modifyInstanceSpec(request: ModifyInstanceSpecRequest): Promise<ModifyInstanceSpecResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyInstanceSpecWithOptions(request, runtime);
  }

  /**
   * You can call this operation to modify the tags of a cluster.
   * 
   * @param request - ModifyInstanceTagsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyInstanceTagsResponse
   */
  async modifyInstanceTagsWithOptions(request: ModifyInstanceTagsRequest, runtime: $dara.RuntimeOptions): Promise<ModifyInstanceTagsResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.tags)) {
      body["Tags"] = request.tags;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyInstanceTags",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ModifyInstanceTagsResponse>(await this.callApi(params, req, runtime), new ModifyInstanceTagsResponse({}));
    } else {
      return $dara.cast<ModifyInstanceTagsResponse>(await this.execute(params, req, runtime), new ModifyInstanceTagsResponse({}));
    }

  }

  /**
   * You can call this operation to modify the tags of a cluster.
   * 
   * @param request - ModifyInstanceTagsRequest
   * @returns ModifyInstanceTagsResponse
   */
  async modifyInstanceTags(request: ModifyInstanceTagsRequest): Promise<ModifyInstanceTagsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyInstanceTagsWithOptions(request, runtime);
  }

  /**
   * You can call this operation to modify the temporary capacity of the OceanBase cluster.
   * 
   * @param request - ModifyInstanceTemporaryCapacityRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyInstanceTemporaryCapacityResponse
   */
  async modifyInstanceTemporaryCapacityWithOptions(request: ModifyInstanceTemporaryCapacityRequest, runtime: $dara.RuntimeOptions): Promise<ModifyInstanceTemporaryCapacityResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.acceptLanguage)) {
      body["AcceptLanguage"] = request.acceptLanguage;
    }

    if (!$dara.isNull(request.diskSize)) {
      body["DiskSize"] = request.diskSize;
    }

    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.spec)) {
      body["Spec"] = request.spec;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyInstanceTemporaryCapacity",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ModifyInstanceTemporaryCapacityResponse>(await this.callApi(params, req, runtime), new ModifyInstanceTemporaryCapacityResponse({}));
    } else {
      return $dara.cast<ModifyInstanceTemporaryCapacityResponse>(await this.execute(params, req, runtime), new ModifyInstanceTemporaryCapacityResponse({}));
    }

  }

  /**
   * You can call this operation to modify the temporary capacity of the OceanBase cluster.
   * 
   * @param request - ModifyInstanceTemporaryCapacityRequest
   * @returns ModifyInstanceTemporaryCapacityResponse
   */
  async modifyInstanceTemporaryCapacity(request: ModifyInstanceTemporaryCapacityRequest): Promise<ModifyInstanceTemporaryCapacityResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyInstanceTemporaryCapacityWithOptions(request, runtime);
  }

  /**
   * The modification results.
   * 
   * @param request - ModifyParametersRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyParametersResponse
   */
  async modifyParametersWithOptions(request: ModifyParametersRequest, runtime: $dara.RuntimeOptions): Promise<ModifyParametersResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.dimension)) {
      body["Dimension"] = request.dimension;
    }

    if (!$dara.isNull(request.dimensionValue)) {
      body["DimensionValue"] = request.dimensionValue;
    }

    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.parameters)) {
      body["Parameters"] = request.parameters;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyParameters",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ModifyParametersResponse>(await this.callApi(params, req, runtime), new ModifyParametersResponse({}));
    } else {
      return $dara.cast<ModifyParametersResponse>(await this.execute(params, req, runtime), new ModifyParametersResponse({}));
    }

  }

  /**
   * The modification results.
   * 
   * @param request - ModifyParametersRequest
   * @returns ModifyParametersResponse
   */
  async modifyParameters(request: ModifyParametersRequest): Promise<ModifyParametersResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyParametersWithOptions(request, runtime);
  }

  /**
   * The name of the security group.
   * 
   * @param request - ModifySecurityIpsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifySecurityIpsResponse
   */
  async modifySecurityIpsWithOptions(request: ModifySecurityIpsRequest, runtime: $dara.RuntimeOptions): Promise<ModifySecurityIpsResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.securityIpGroupName)) {
      body["SecurityIpGroupName"] = request.securityIpGroupName;
    }

    if (!$dara.isNull(request.securityIps)) {
      body["SecurityIps"] = request.securityIps;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifySecurityIps",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ModifySecurityIpsResponse>(await this.callApi(params, req, runtime), new ModifySecurityIpsResponse({}));
    } else {
      return $dara.cast<ModifySecurityIpsResponse>(await this.execute(params, req, runtime), new ModifySecurityIpsResponse({}));
    }

  }

  /**
   * The name of the security group.
   * 
   * @param request - ModifySecurityIpsRequest
   * @returns ModifySecurityIpsResponse
   */
  async modifySecurityIps(request: ModifySecurityIpsRequest): Promise<ModifySecurityIpsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifySecurityIpsWithOptions(request, runtime);
  }

  /**
   * @param request - ModifyTagNameRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyTagNameResponse
   */
  async modifyTagNameWithOptions(request: ModifyTagNameRequest, runtime: $dara.RuntimeOptions): Promise<ModifyTagNameResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.key)) {
      body["Key"] = request.key;
    }

    if (!$dara.isNull(request.newKey)) {
      body["NewKey"] = request.newKey;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyTagName",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ModifyTagNameResponse>(await this.callApi(params, req, runtime), new ModifyTagNameResponse({}));
    } else {
      return $dara.cast<ModifyTagNameResponse>(await this.execute(params, req, runtime), new ModifyTagNameResponse({}));
    }

  }

  /**
   * @param request - ModifyTagNameRequest
   * @returns ModifyTagNameResponse
   */
  async modifyTagName(request: ModifyTagNameRequest): Promise<ModifyTagNameResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyTagNameWithOptions(request, runtime);
  }

  /**
   * You can call this operation to rename a tag.
   * 
   * @param request - ModifyTagValueNameRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyTagValueNameResponse
   */
  async modifyTagValueNameWithOptions(request: ModifyTagValueNameRequest, runtime: $dara.RuntimeOptions): Promise<ModifyTagValueNameResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.key)) {
      body["Key"] = request.key;
    }

    if (!$dara.isNull(request.newValue)) {
      body["NewValue"] = request.newValue;
    }

    if (!$dara.isNull(request.value)) {
      body["Value"] = request.value;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyTagValueName",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ModifyTagValueNameResponse>(await this.callApi(params, req, runtime), new ModifyTagValueNameResponse({}));
    } else {
      return $dara.cast<ModifyTagValueNameResponse>(await this.execute(params, req, runtime), new ModifyTagValueNameResponse({}));
    }

  }

  /**
   * You can call this operation to rename a tag.
   * 
   * @param request - ModifyTagValueNameRequest
   * @returns ModifyTagValueNameResponse
   */
  async modifyTagValueName(request: ModifyTagValueNameRequest): Promise<ModifyTagValueNameResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyTagValueNameWithOptions(request, runtime);
  }

  /**
   * 租户加密变更
   * 
   * @param request - ModifyTenantEncryptionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyTenantEncryptionResponse
   */
  async modifyTenantEncryptionWithOptions(request: ModifyTenantEncryptionRequest, runtime: $dara.RuntimeOptions): Promise<ModifyTenantEncryptionResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.encryptionKeyId)) {
      body["EncryptionKeyId"] = request.encryptionKeyId;
    }

    if (!$dara.isNull(request.encryptionType)) {
      body["EncryptionType"] = request.encryptionType;
    }

    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyTenantEncryption",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ModifyTenantEncryptionResponse>(await this.callApi(params, req, runtime), new ModifyTenantEncryptionResponse({}));
    } else {
      return $dara.cast<ModifyTenantEncryptionResponse>(await this.execute(params, req, runtime), new ModifyTenantEncryptionResponse({}));
    }

  }

  /**
   * 租户加密变更
   * 
   * @param request - ModifyTenantEncryptionRequest
   * @returns ModifyTenantEncryptionResponse
   */
  async modifyTenantEncryption(request: ModifyTenantEncryptionRequest): Promise<ModifyTenantEncryptionResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyTenantEncryptionWithOptions(request, runtime);
  }

  /**
   * The return result of the request.
   * 
   * @param request - ModifyTenantPrimaryZoneRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyTenantPrimaryZoneResponse
   */
  async modifyTenantPrimaryZoneWithOptions(request: ModifyTenantPrimaryZoneRequest, runtime: $dara.RuntimeOptions): Promise<ModifyTenantPrimaryZoneResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.masterIntranetAddressZone)) {
      body["MasterIntranetAddressZone"] = request.masterIntranetAddressZone;
    }

    if (!$dara.isNull(request.primaryZone)) {
      body["PrimaryZone"] = request.primaryZone;
    }

    if (!$dara.isNull(request.tenantEndpointDirectId)) {
      body["TenantEndpointDirectId"] = request.tenantEndpointDirectId;
    }

    if (!$dara.isNull(request.tenantEndpointId)) {
      body["TenantEndpointId"] = request.tenantEndpointId;
    }

    if (!$dara.isNull(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    if (!$dara.isNull(request.userDirectVSwitchId)) {
      body["UserDirectVSwitchId"] = request.userDirectVSwitchId;
    }

    if (!$dara.isNull(request.userVSwitchId)) {
      body["UserVSwitchId"] = request.userVSwitchId;
    }

    if (!$dara.isNull(request.userVpcOwnerId)) {
      body["UserVpcOwnerId"] = request.userVpcOwnerId;
    }

    if (!$dara.isNull(request.vpcId)) {
      body["VpcId"] = request.vpcId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyTenantPrimaryZone",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ModifyTenantPrimaryZoneResponse>(await this.callApi(params, req, runtime), new ModifyTenantPrimaryZoneResponse({}));
    } else {
      return $dara.cast<ModifyTenantPrimaryZoneResponse>(await this.execute(params, req, runtime), new ModifyTenantPrimaryZoneResponse({}));
    }

  }

  /**
   * The return result of the request.
   * 
   * @param request - ModifyTenantPrimaryZoneRequest
   * @returns ModifyTenantPrimaryZoneResponse
   */
  async modifyTenantPrimaryZone(request: ModifyTenantPrimaryZoneRequest): Promise<ModifyTenantPrimaryZoneResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyTenantPrimaryZoneWithOptions(request, runtime);
  }

  /**
   * You can call this operation to modify the specifications of a tenant in an OceanBase cluster.
   * 
   * @param request - ModifyTenantResourceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyTenantResourceResponse
   */
  async modifyTenantResourceWithOptions(request: ModifyTenantResourceRequest, runtime: $dara.RuntimeOptions): Promise<ModifyTenantResourceResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.cpu)) {
      body["Cpu"] = request.cpu;
    }

    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.logDisk)) {
      body["LogDisk"] = request.logDisk;
    }

    if (!$dara.isNull(request.memory)) {
      body["Memory"] = request.memory;
    }

    if (!$dara.isNull(request.readOnlyZoneList)) {
      body["ReadOnlyZoneList"] = request.readOnlyZoneList;
    }

    if (!$dara.isNull(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyTenantResource",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ModifyTenantResourceResponse>(await this.callApi(params, req, runtime), new ModifyTenantResourceResponse({}));
    } else {
      return $dara.cast<ModifyTenantResourceResponse>(await this.execute(params, req, runtime), new ModifyTenantResourceResponse({}));
    }

  }

  /**
   * You can call this operation to modify the specifications of a tenant in an OceanBase cluster.
   * 
   * @param request - ModifyTenantResourceRequest
   * @returns ModifyTenantResourceResponse
   */
  async modifyTenantResource(request: ModifyTenantResourceRequest): Promise<ModifyTenantResourceResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyTenantResourceWithOptions(request, runtime);
  }

  /**
   * You can call this operation to modify the information on the whitelist group of the tenant.
   * 
   * @param request - ModifyTenantSecurityIpGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyTenantSecurityIpGroupResponse
   */
  async modifyTenantSecurityIpGroupWithOptions(request: ModifyTenantSecurityIpGroupRequest, runtime: $dara.RuntimeOptions): Promise<ModifyTenantSecurityIpGroupResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.securityIpGroupName)) {
      body["SecurityIpGroupName"] = request.securityIpGroupName;
    }

    if (!$dara.isNull(request.securityIps)) {
      body["SecurityIps"] = request.securityIps;
    }

    if (!$dara.isNull(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyTenantSecurityIpGroup",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ModifyTenantSecurityIpGroupResponse>(await this.callApi(params, req, runtime), new ModifyTenantSecurityIpGroupResponse({}));
    } else {
      return $dara.cast<ModifyTenantSecurityIpGroupResponse>(await this.execute(params, req, runtime), new ModifyTenantSecurityIpGroupResponse({}));
    }

  }

  /**
   * You can call this operation to modify the information on the whitelist group of the tenant.
   * 
   * @param request - ModifyTenantSecurityIpGroupRequest
   * @returns ModifyTenantSecurityIpGroupResponse
   */
  async modifyTenantSecurityIpGroup(request: ModifyTenantSecurityIpGroupRequest): Promise<ModifyTenantSecurityIpGroupResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyTenantSecurityIpGroupWithOptions(request, runtime);
  }

  /**
   * You can call this operation to modify the tags of a tenant.
   * 
   * @param request - ModifyTenantTagsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyTenantTagsResponse
   */
  async modifyTenantTagsWithOptions(request: ModifyTenantTagsRequest, runtime: $dara.RuntimeOptions): Promise<ModifyTenantTagsResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.tags)) {
      body["Tags"] = request.tags;
    }

    if (!$dara.isNull(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyTenantTags",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ModifyTenantTagsResponse>(await this.callApi(params, req, runtime), new ModifyTenantTagsResponse({}));
    } else {
      return $dara.cast<ModifyTenantTagsResponse>(await this.execute(params, req, runtime), new ModifyTenantTagsResponse({}));
    }

  }

  /**
   * You can call this operation to modify the tags of a tenant.
   * 
   * @param request - ModifyTenantTagsRequest
   * @returns ModifyTenantTagsResponse
   */
  async modifyTenantTags(request: ModifyTenantTagsRequest): Promise<ModifyTenantTagsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyTenantTagsWithOptions(request, runtime);
  }

  /**
   * The description of the database.
   * 
   * @param request - ModifyTenantUserDescriptionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyTenantUserDescriptionResponse
   */
  async modifyTenantUserDescriptionWithOptions(request: ModifyTenantUserDescriptionRequest, runtime: $dara.RuntimeOptions): Promise<ModifyTenantUserDescriptionResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.description)) {
      body["Description"] = request.description;
    }

    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    if (!$dara.isNull(request.userName)) {
      body["UserName"] = request.userName;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyTenantUserDescription",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ModifyTenantUserDescriptionResponse>(await this.callApi(params, req, runtime), new ModifyTenantUserDescriptionResponse({}));
    } else {
      return $dara.cast<ModifyTenantUserDescriptionResponse>(await this.execute(params, req, runtime), new ModifyTenantUserDescriptionResponse({}));
    }

  }

  /**
   * The description of the database.
   * 
   * @param request - ModifyTenantUserDescriptionRequest
   * @returns ModifyTenantUserDescriptionResponse
   */
  async modifyTenantUserDescription(request: ModifyTenantUserDescriptionRequest): Promise<ModifyTenantUserDescriptionResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyTenantUserDescriptionWithOptions(request, runtime);
  }

  /**
   * The request ID.
   * 
   * @param request - ModifyTenantUserPasswordRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyTenantUserPasswordResponse
   */
  async modifyTenantUserPasswordWithOptions(request: ModifyTenantUserPasswordRequest, runtime: $dara.RuntimeOptions): Promise<ModifyTenantUserPasswordResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.encryptionType)) {
      body["EncryptionType"] = request.encryptionType;
    }

    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    if (!$dara.isNull(request.userName)) {
      body["UserName"] = request.userName;
    }

    if (!$dara.isNull(request.userPassword)) {
      body["UserPassword"] = request.userPassword;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyTenantUserPassword",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ModifyTenantUserPasswordResponse>(await this.callApi(params, req, runtime), new ModifyTenantUserPasswordResponse({}));
    } else {
      return $dara.cast<ModifyTenantUserPasswordResponse>(await this.execute(params, req, runtime), new ModifyTenantUserPasswordResponse({}));
    }

  }

  /**
   * The request ID.
   * 
   * @param request - ModifyTenantUserPasswordRequest
   * @returns ModifyTenantUserPasswordResponse
   */
  async modifyTenantUserPassword(request: ModifyTenantUserPasswordRequest): Promise<ModifyTenantUserPasswordResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyTenantUserPasswordWithOptions(request, runtime);
  }

  /**
   * Indicates whether the privilege was granted to the role.
   * 
   * @param request - ModifyTenantUserRolesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyTenantUserRolesResponse
   */
  async modifyTenantUserRolesWithOptions(request: ModifyTenantUserRolesRequest, runtime: $dara.RuntimeOptions): Promise<ModifyTenantUserRolesResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.globalPermissions)) {
      body["GlobalPermissions"] = request.globalPermissions;
    }

    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.modifyType)) {
      body["ModifyType"] = request.modifyType;
    }

    if (!$dara.isNull(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    if (!$dara.isNull(request.userName)) {
      body["UserName"] = request.userName;
    }

    if (!$dara.isNull(request.userRole)) {
      body["UserRole"] = request.userRole;
    }

    if (!$dara.isNull(request.userType)) {
      body["UserType"] = request.userType;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyTenantUserRoles",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ModifyTenantUserRolesResponse>(await this.callApi(params, req, runtime), new ModifyTenantUserRolesResponse({}));
    } else {
      return $dara.cast<ModifyTenantUserRolesResponse>(await this.execute(params, req, runtime), new ModifyTenantUserRolesResponse({}));
    }

  }

  /**
   * Indicates whether the privilege was granted to the role.
   * 
   * @param request - ModifyTenantUserRolesRequest
   * @returns ModifyTenantUserRolesResponse
   */
  async modifyTenantUserRoles(request: ModifyTenantUserRolesRequest): Promise<ModifyTenantUserRolesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyTenantUserRolesWithOptions(request, runtime);
  }

  /**
   * The ID of the tenant.
   * 
   * @param request - ModifyTenantUserStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyTenantUserStatusResponse
   */
  async modifyTenantUserStatusWithOptions(request: ModifyTenantUserStatusRequest, runtime: $dara.RuntimeOptions): Promise<ModifyTenantUserStatusResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    if (!$dara.isNull(request.userName)) {
      body["UserName"] = request.userName;
    }

    if (!$dara.isNull(request.userStatus)) {
      body["UserStatus"] = request.userStatus;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "ModifyTenantUserStatus",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ModifyTenantUserStatusResponse>(await this.callApi(params, req, runtime), new ModifyTenantUserStatusResponse({}));
    } else {
      return $dara.cast<ModifyTenantUserStatusResponse>(await this.execute(params, req, runtime), new ModifyTenantUserStatusResponse({}));
    }

  }

  /**
   * The ID of the tenant.
   * 
   * @param request - ModifyTenantUserStatusRequest
   * @returns ModifyTenantUserStatusResponse
   */
  async modifyTenantUserStatus(request: ModifyTenantUserStatusRequest): Promise<ModifyTenantUserStatusResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.modifyTenantUserStatusWithOptions(request, runtime);
  }

  /**
   * 释放项目
   * 
   * @param request - ReleaseProjectRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ReleaseProjectResponse
   */
  async releaseProjectWithOptions(request: ReleaseProjectRequest, runtime: $dara.RuntimeOptions): Promise<ReleaseProjectResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.id)) {
      body["Id"] = request.id;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "ReleaseProject",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ReleaseProjectResponse>(await this.callApi(params, req, runtime), new ReleaseProjectResponse({}));
    } else {
      return $dara.cast<ReleaseProjectResponse>(await this.execute(params, req, runtime), new ReleaseProjectResponse({}));
    }

  }

  /**
   * 释放项目
   * 
   * @param request - ReleaseProjectRequest
   * @returns ReleaseProjectResponse
   */
  async releaseProject(request: ReleaseProjectRequest): Promise<ReleaseProjectResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.releaseProjectWithOptions(request, runtime);
  }

  /**
   * 释放传输实例 （未绑定项目时才可以释放）
   * 
   * @param request - ReleaseWorkerInstanceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ReleaseWorkerInstanceResponse
   */
  async releaseWorkerInstanceWithOptions(request: ReleaseWorkerInstanceRequest, runtime: $dara.RuntimeOptions): Promise<ReleaseWorkerInstanceResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.id)) {
      body["Id"] = request.id;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "ReleaseWorkerInstance",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ReleaseWorkerInstanceResponse>(await this.callApi(params, req, runtime), new ReleaseWorkerInstanceResponse({}));
    } else {
      return $dara.cast<ReleaseWorkerInstanceResponse>(await this.execute(params, req, runtime), new ReleaseWorkerInstanceResponse({}));
    }

  }

  /**
   * 释放传输实例 （未绑定项目时才可以释放）
   * 
   * @param request - ReleaseWorkerInstanceRequest
   * @returns ReleaseWorkerInstanceResponse
   */
  async releaseWorkerInstance(request: ReleaseWorkerInstanceRequest): Promise<ReleaseWorkerInstanceResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.releaseWorkerInstanceWithOptions(request, runtime);
  }

  /**
   * 备实例解耦
   * 
   * @param request - RemoveStandbyInstanceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RemoveStandbyInstanceResponse
   */
  async removeStandbyInstanceWithOptions(request: RemoveStandbyInstanceRequest, runtime: $dara.RuntimeOptions): Promise<RemoveStandbyInstanceResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.forced)) {
      body["Forced"] = request.forced;
    }

    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.targetInstanceId)) {
      body["TargetInstanceId"] = request.targetInstanceId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "RemoveStandbyInstance",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<RemoveStandbyInstanceResponse>(await this.callApi(params, req, runtime), new RemoveStandbyInstanceResponse({}));
    } else {
      return $dara.cast<RemoveStandbyInstanceResponse>(await this.execute(params, req, runtime), new RemoveStandbyInstanceResponse({}));
    }

  }

  /**
   * 备实例解耦
   * 
   * @param request - RemoveStandbyInstanceRequest
   * @returns RemoveStandbyInstanceResponse
   */
  async removeStandbyInstance(request: RemoveStandbyInstanceRequest): Promise<RemoveStandbyInstanceResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.removeStandbyInstanceWithOptions(request, runtime);
  }

  /**
   * 恢复项目
   * 
   * @param request - ResumeProjectRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ResumeProjectResponse
   */
  async resumeProjectWithOptions(request: ResumeProjectRequest, runtime: $dara.RuntimeOptions): Promise<ResumeProjectResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.id)) {
      body["Id"] = request.id;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "ResumeProject",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ResumeProjectResponse>(await this.callApi(params, req, runtime), new ResumeProjectResponse({}));
    } else {
      return $dara.cast<ResumeProjectResponse>(await this.execute(params, req, runtime), new ResumeProjectResponse({}));
    }

  }

  /**
   * 恢复项目
   * 
   * @param request - ResumeProjectRequest
   * @returns ResumeProjectResponse
   */
  async resumeProject(request: ResumeProjectRequest): Promise<ResumeProjectResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.resumeProjectWithOptions(request, runtime);
  }

  /**
   * 根据修改记录 ID 重试修改操作（仅支持处于 FAILED 状态的修改记录）
   * 
   * @param request - RetryProjectModifyRecordsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RetryProjectModifyRecordsResponse
   */
  async retryProjectModifyRecordsWithOptions(request: RetryProjectModifyRecordsRequest, runtime: $dara.RuntimeOptions): Promise<RetryProjectModifyRecordsResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.id)) {
      body["Id"] = request.id;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "RetryProjectModifyRecords",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<RetryProjectModifyRecordsResponse>(await this.callApi(params, req, runtime), new RetryProjectModifyRecordsResponse({}));
    } else {
      return $dara.cast<RetryProjectModifyRecordsResponse>(await this.execute(params, req, runtime), new RetryProjectModifyRecordsResponse({}));
    }

  }

  /**
   * 根据修改记录 ID 重试修改操作（仅支持处于 FAILED 状态的修改记录）
   * 
   * @param request - RetryProjectModifyRecordsRequest
   * @returns RetryProjectModifyRecordsResponse
   */
  async retryProjectModifyRecords(request: RetryProjectModifyRecordsRequest): Promise<RetryProjectModifyRecordsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.retryProjectModifyRecordsWithOptions(request, runtime);
  }

  /**
   * 启动项目
   * 
   * @param request - StartProjectRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns StartProjectResponse
   */
  async startProjectWithOptions(request: StartProjectRequest, runtime: $dara.RuntimeOptions): Promise<StartProjectResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.id)) {
      body["Id"] = request.id;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "StartProject",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<StartProjectResponse>(await this.callApi(params, req, runtime), new StartProjectResponse({}));
    } else {
      return $dara.cast<StartProjectResponse>(await this.execute(params, req, runtime), new StartProjectResponse({}));
    }

  }

  /**
   * 启动项目
   * 
   * @param request - StartProjectRequest
   * @returns StartProjectResponse
   */
  async startProject(request: StartProjectRequest): Promise<StartProjectResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.startProjectWithOptions(request, runtime);
  }

  /**
   * 启动该label下的所有未启动项目
   * 
   * @param request - StartProjectsByLabelRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns StartProjectsByLabelResponse
   */
  async startProjectsByLabelWithOptions(request: StartProjectsByLabelRequest, runtime: $dara.RuntimeOptions): Promise<StartProjectsByLabelResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.id)) {
      body["Id"] = request.id;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "StartProjectsByLabel",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<StartProjectsByLabelResponse>(await this.callApi(params, req, runtime), new StartProjectsByLabelResponse({}));
    } else {
      return $dara.cast<StartProjectsByLabelResponse>(await this.execute(params, req, runtime), new StartProjectsByLabelResponse({}));
    }

  }

  /**
   * 启动该label下的所有未启动项目
   * 
   * @param request - StartProjectsByLabelRequest
   * @returns StartProjectsByLabelResponse
   */
  async startProjectsByLabel(request: StartProjectsByLabelRequest): Promise<StartProjectsByLabelResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.startProjectsByLabelWithOptions(request, runtime);
  }

  /**
   * 暂停项目
   * 
   * @param request - StopProjectRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns StopProjectResponse
   */
  async stopProjectWithOptions(request: StopProjectRequest, runtime: $dara.RuntimeOptions): Promise<StopProjectResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.id)) {
      body["Id"] = request.id;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "StopProject",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<StopProjectResponse>(await this.callApi(params, req, runtime), new StopProjectResponse({}));
    } else {
      return $dara.cast<StopProjectResponse>(await this.execute(params, req, runtime), new StopProjectResponse({}));
    }

  }

  /**
   * 暂停项目
   * 
   * @param request - StopProjectRequest
   * @returns StopProjectResponse
   */
  async stopProject(request: StopProjectRequest): Promise<StopProjectResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.stopProjectWithOptions(request, runtime);
  }

  /**
   * 根据修改记录 ID 终止修改操作，不可恢复（仅支持处于 RUNNING / FAILED 状态的修改记录）
   * 
   * @param request - StopProjectModifyRecordsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns StopProjectModifyRecordsResponse
   */
  async stopProjectModifyRecordsWithOptions(request: StopProjectModifyRecordsRequest, runtime: $dara.RuntimeOptions): Promise<StopProjectModifyRecordsResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.id)) {
      body["Id"] = request.id;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "StopProjectModifyRecords",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<StopProjectModifyRecordsResponse>(await this.callApi(params, req, runtime), new StopProjectModifyRecordsResponse({}));
    } else {
      return $dara.cast<StopProjectModifyRecordsResponse>(await this.execute(params, req, runtime), new StopProjectModifyRecordsResponse({}));
    }

  }

  /**
   * 根据修改记录 ID 终止修改操作，不可恢复（仅支持处于 RUNNING / FAILED 状态的修改记录）
   * 
   * @param request - StopProjectModifyRecordsRequest
   * @returns StopProjectModifyRecordsResponse
   */
  async stopProjectModifyRecords(request: StopProjectModifyRecordsRequest): Promise<StopProjectModifyRecordsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.stopProjectModifyRecordsWithOptions(request, runtime);
  }

  /**
   * 暂停该label下的所有运行中项目
   * 
   * @param request - StopProjectsByLabelRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns StopProjectsByLabelResponse
   */
  async stopProjectsByLabelWithOptions(request: StopProjectsByLabelRequest, runtime: $dara.RuntimeOptions): Promise<StopProjectsByLabelResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.id)) {
      body["Id"] = request.id;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "StopProjectsByLabel",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<StopProjectsByLabelResponse>(await this.callApi(params, req, runtime), new StopProjectsByLabelResponse({}));
    } else {
      return $dara.cast<StopProjectsByLabelResponse>(await this.execute(params, req, runtime), new StopProjectsByLabelResponse({}));
    }

  }

  /**
   * 暂停该label下的所有运行中项目
   * 
   * @param request - StopProjectsByLabelRequest
   * @returns StopProjectsByLabelResponse
   */
  async stopProjectsByLabel(request: StopProjectsByLabelRequest): Promise<StopProjectsByLabelResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.stopProjectsByLabelWithOptions(request, runtime);
  }

  /**
   * You can call this operation to switch between the primary and standby instances of OceanBase.
   * 
   * @param request - SwitchoverInstanceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SwitchoverInstanceResponse
   */
  async switchoverInstanceWithOptions(request: SwitchoverInstanceRequest, runtime: $dara.RuntimeOptions): Promise<SwitchoverInstanceResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.forced)) {
      body["Forced"] = request.forced;
    }

    if (!$dara.isNull(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.targetInstanceId)) {
      body["TargetInstanceId"] = request.targetInstanceId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "SwitchoverInstance",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<SwitchoverInstanceResponse>(await this.callApi(params, req, runtime), new SwitchoverInstanceResponse({}));
    } else {
      return $dara.cast<SwitchoverInstanceResponse>(await this.execute(params, req, runtime), new SwitchoverInstanceResponse({}));
    }

  }

  /**
   * You can call this operation to switch between the primary and standby instances of OceanBase.
   * 
   * @param request - SwitchoverInstanceRequest
   * @returns SwitchoverInstanceResponse
   */
  async switchoverInstance(request: SwitchoverInstanceRequest): Promise<SwitchoverInstanceResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.switchoverInstanceWithOptions(request, runtime);
  }

  /**
   * 更新项目配置 Action=UpdateProjectConfig
   * 
   * @param tmpReq - UpdateProjectConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateProjectConfigResponse
   */
  async updateProjectConfigWithOptions(tmpReq: UpdateProjectConfigRequest, runtime: $dara.RuntimeOptions): Promise<UpdateProjectConfigResponse> {
    tmpReq.validate();
    let request = new UpdateProjectConfigShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!$dara.isNull(tmpReq.commonTransferConfig)) {
      request.commonTransferConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.commonTransferConfig, "CommonTransferConfig", "json");
    }

    if (!$dara.isNull(tmpReq.fullTransferConfig)) {
      request.fullTransferConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.fullTransferConfig, "FullTransferConfig", "json");
    }

    if (!$dara.isNull(tmpReq.incrTransferConfig)) {
      request.incrTransferConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.incrTransferConfig, "IncrTransferConfig", "json");
    }

    if (!$dara.isNull(tmpReq.reverseIncrTransferConfig)) {
      request.reverseIncrTransferConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.reverseIncrTransferConfig, "ReverseIncrTransferConfig", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.commonTransferConfigShrink)) {
      body["CommonTransferConfig"] = request.commonTransferConfigShrink;
    }

    if (!$dara.isNull(request.fullTransferConfigShrink)) {
      body["FullTransferConfig"] = request.fullTransferConfigShrink;
    }

    if (!$dara.isNull(request.id)) {
      body["Id"] = request.id;
    }

    if (!$dara.isNull(request.incrTransferConfigShrink)) {
      body["IncrTransferConfig"] = request.incrTransferConfigShrink;
    }

    if (!$dara.isNull(request.reverseIncrTransferConfigShrink)) {
      body["ReverseIncrTransferConfig"] = request.reverseIncrTransferConfigShrink;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "UpdateProjectConfig",
      version: "2019-09-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<UpdateProjectConfigResponse>(await this.callApi(params, req, runtime), new UpdateProjectConfigResponse({}));
    } else {
      return $dara.cast<UpdateProjectConfigResponse>(await this.execute(params, req, runtime), new UpdateProjectConfigResponse({}));
    }

  }

  /**
   * 更新项目配置 Action=UpdateProjectConfig
   * 
   * @param request - UpdateProjectConfigRequest
   * @returns UpdateProjectConfigResponse
   */
  async updateProjectConfig(request: UpdateProjectConfigRequest): Promise<UpdateProjectConfigResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.updateProjectConfigWithOptions(request, runtime);
  }

}
