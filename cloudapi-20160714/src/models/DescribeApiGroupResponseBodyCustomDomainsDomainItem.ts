// This file is auto-generated, don't edit it
import * as $dara from '@darabonba/typescript';


export class DescribeApiGroupResponseBodyCustomDomainsDomainItem extends $dara.Model {
  /**
   * @remarks
   * The alias of the associated environment.
   * 
   * @example
   * TEST1
   */
  bindStageAlias?: string;
  /**
   * @remarks
   * The environment in which the associated API group runs.
   * 
   * @example
   * TEST
   */
  bindStageName?: string;
  /**
   * @remarks
   * The SSL certificate ID, which is automatically generated by the system.
   * 
   * @example
   * 6EF60BEC-0242-43AF-BB20-270359FB54A7
   */
  certificateId?: string;
  /**
   * @remarks
   * The name of the SSL certificate.
   * 
   * @example
   * myCertificate
   */
  certificateName?: string;
  /**
   * @remarks
   * The time when the certificate expires.
   * 
   * @example
   * 2635123476000
   */
  certificateValidEnd?: number;
  /**
   * @remarks
   * The time when the certificate takes effect.
   * 
   * @example
   * 1689043476000
   */
  certificateValidStart?: number;
  /**
   * @remarks
   * The type of the custom domain name.
   * 
   * @example
   * intranet
   */
  customDomainType?: string;
  /**
   * @remarks
   * The binding status of the custom domain name. Valid values:
   * 
   * *   **BINDING**: The domain name is bound.
   * *   **BOUND**: The domain name is not bound.
   * 
   * @example
   * BINDING
   */
  domainBindingStatus?: string;
  /**
   * @remarks
   * The domain name resolution status. Valid values:
   * 
   * *   **RESOLVED**
   * *   **UNRESOLVED**
   * 
   * @example
   * RESOLVED
   */
  domainCNAMEStatus?: string;
  /**
   * @remarks
   * The validity status of the domain name. Valid values:
   * 
   * *   **NORMAL**: The domain name is valid.
   * *   **ABNORMAL**: The domain name is invalid. This status affects API calls and needs to be rectified as soon as possible.
   * 
   * @example
   * ABNORMAL
   */
  domainLegalStatus?: string;
  /**
   * @remarks
   * The domain name.
   * 
   * @example
   * api.demo.com
   */
  domainName?: string;
  /**
   * @remarks
   * Remarks about the domain name, such as the cause of an exception.
   * 
   * @example
   * Indicates that the domain name does not have an ICP filing.
   */
  domainRemark?: string;
  /**
   * @remarks
   * The status of the domain that uses the WebSocket feature.
   * 
   * @example
   * CLOSE
   */
  domainWebSocketStatus?: string;
  /**
   * @remarks
   * Indicates whether to redirect HTTP requests to HTTPS.
   * 
   * @example
   * false
   */
  isHttpRedirectToHttps?: boolean;
  /**
   * @remarks
   * The wildcard domain name mode.
   * 
   * @example
   * [\\"{test}.test.com\\"]
   */
  wildcardDomainPatterns?: string;
  static names(): { [key: string]: string } {
    return {
      bindStageAlias: 'BindStageAlias',
      bindStageName: 'BindStageName',
      certificateId: 'CertificateId',
      certificateName: 'CertificateName',
      certificateValidEnd: 'CertificateValidEnd',
      certificateValidStart: 'CertificateValidStart',
      customDomainType: 'CustomDomainType',
      domainBindingStatus: 'DomainBindingStatus',
      domainCNAMEStatus: 'DomainCNAMEStatus',
      domainLegalStatus: 'DomainLegalStatus',
      domainName: 'DomainName',
      domainRemark: 'DomainRemark',
      domainWebSocketStatus: 'DomainWebSocketStatus',
      isHttpRedirectToHttps: 'IsHttpRedirectToHttps',
      wildcardDomainPatterns: 'WildcardDomainPatterns',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bindStageAlias: 'string',
      bindStageName: 'string',
      certificateId: 'string',
      certificateName: 'string',
      certificateValidEnd: 'number',
      certificateValidStart: 'number',
      customDomainType: 'string',
      domainBindingStatus: 'string',
      domainCNAMEStatus: 'string',
      domainLegalStatus: 'string',
      domainName: 'string',
      domainRemark: 'string',
      domainWebSocketStatus: 'string',
      isHttpRedirectToHttps: 'boolean',
      wildcardDomainPatterns: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

