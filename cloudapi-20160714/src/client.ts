// This file is auto-generated, don't edit it
/**
 */
import Util, * as $Util from '@alicloud/tea-util';
import OpenApi, * as $OpenApi from '@alicloud/openapi-client';
import OpenApiUtil from '@alicloud/openapi-util';
import EndpointUtil from '@alicloud/endpoint-util';
import * as $tea from '@alicloud/tea-typescript';

export class AbolishApiRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the specified API.
   * 
   * This parameter is required.
   * 
   * @example
   * d6f679aeb3be4b91b3688e887ca1fe16
   */
  apiId?: string;
  /**
   * @remarks
   * The ID of the API group.
   * 
   * @example
   * 123
   */
  groupId?: string;
  securityToken?: string;
  /**
   * @remarks
   * The name of the runtime environment. Valid values:
   * 
   * *   **RELEASE**
   * *   **TEST**
   * 
   * This parameter is required.
   * 
   * @example
   * RELEASE
   */
  stageName?: string;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      groupId: 'GroupId',
      securityToken: 'SecurityToken',
      stageName: 'StageName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'string',
      groupId: 'string',
      securityToken: 'string',
      stageName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AbolishApiResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ016
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AbolishApiResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AbolishApiResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AbolishApiResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddAccessControlListEntryRequest extends $tea.Model {
  /**
   * @remarks
   * The ACL settings.
   * 
   * *   entry: the entries that you want to add to the ACL. You can add CIDR blocks. Separate multiple CIDR blocks with commas (,).
   * *   comment: the description of the ACL.
   * 
   * > You can add at most 50 IP addresses or CIDR blocks to an ACL in each call. If the IP address or CIDR block that you want to add to an ACL already exists, the IP address or CIDR block is not added. The entries that you add must be CIDR blocks.
   * 
   * @example
   * [{\\"entry\\": \\"192.168.1.0/24\\", \\"comment\\": \\"test\\"}]
   */
  aclEntrys?: string;
  /**
   * @remarks
   * The ID of the access control list (ACL).
   * 
   * This parameter is required.
   * 
   * @example
   * acl-bp1ohqkonqybecf4llbrc
   */
  aclId?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      aclEntrys: 'AclEntrys',
      aclId: 'AclId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aclEntrys: 'string',
      aclId: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddAccessControlListEntryResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CEB6EC62-B6C7-5082-A45A-45A204724AC2
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddAccessControlListEntryResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddAccessControlListEntryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddAccessControlListEntryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddIpControlPolicyItemRequest extends $tea.Model {
  /**
   * @remarks
   * The restriction policy on app IDs for a specific policy. You can restrict app IDs only for whitelists. The IpControlType values of whitelists are ALLOW.
   * 
   * *   You can add only one app ID restriction policy at a time.
   * *   If this parameter is empty, no restriction is imposed on the app IDs.
   * *   If this parameter is not empty, there is restriction not only on IP addresses, but also on apps.
   * *   Please note that if this parameter is not empty and the security authentication method of the API is No Authentication, all API calls are restricted.
   * *   If this parameter is not empty for a blacklist, API Gateway automatically skips this parameter and sets only restriction on IP addresses. The IpControlType value of a blacklist is REFUSE.
   * 
   * @example
   * 1111111
   */
  appId?: string;
  /**
   * @remarks
   * The IP addresses or CIDR blocks involved in the policy. Separate multiple IP addresses or CIDR blocks with semicolons (;). You can specify a maximum of 10 IP addresses or CIDR blocks.
   * 
   * This parameter is required.
   * 
   * @example
   * 113.125.1.101;101.11.1.1
   */
  cidrIp?: string;
  /**
   * @remarks
   * The ID of the ACL. The ID is unique.
   * 
   * This parameter is required.
   * 
   * @example
   * 7ea91319a34d48a09b5c9c871d9768b1
   */
  ipControlId?: string;
  /**
   * @remarks
   * The security token included in the WebSocket request header. The system uses this token to authenticate the request.
   * 
   * @example
   * 4223a10e-eed3-46a6-8b7c-23003f488153
   */
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      cidrIp: 'CidrIp',
      ipControlId: 'IpControlId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      cidrIp: 'string',
      ipControlId: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddIpControlPolicyItemResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the policy. The ID is unique.
   * 
   * @example
   * P151617000829241
   */
  policyItemId?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ004
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      policyItemId: 'PolicyItemId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      policyItemId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddIpControlPolicyItemResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddIpControlPolicyItemResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddIpControlPolicyItemResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddTrafficSpecialControlRequest extends $tea.Model {
  /**
   * @remarks
   * The security token included in the WebSocket request header. The system uses this token to authenticate the request.
   * 
   * @example
   * fa876ffb-caab-4f0a-93b3-3409f2fa5199
   */
  securityToken?: string;
  /**
   * @remarks
   * The ID of the app or Alibaba Cloud account. Specify this parameter based on the value of the **SpecialType** parameter. You can view your account ID on the [Account Management](https://account.console.aliyun.com/?spm=a2c4g.11186623.2.15.3f053654YpMPwo#/secure) page.
   * 
   * This parameter is required.
   * 
   * @example
   * 3382463
   */
  specialKey?: string;
  /**
   * @remarks
   * The type of the special throttling policy. Valid values:
   * 
   * *   **APP**
   * *   **USER**
   * 
   * This parameter is required.
   * 
   * @example
   * APP
   */
  specialType?: string;
  /**
   * @remarks
   * The ID of the specified throttling policy.
   * 
   * This parameter is required.
   * 
   * @example
   * tf123456
   */
  trafficControlId?: string;
  /**
   * @remarks
   * The special throttling value.
   * 
   * This parameter is required.
   * 
   * @example
   * 10000
   */
  trafficValue?: number;
  static names(): { [key: string]: string } {
    return {
      securityToken: 'SecurityToken',
      specialKey: 'SpecialKey',
      specialType: 'SpecialType',
      trafficControlId: 'TrafficControlId',
      trafficValue: 'TrafficValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      securityToken: 'string',
      specialKey: 'string',
      specialType: 'string',
      trafficControlId: 'string',
      trafficValue: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddTrafficSpecialControlResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ004
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddTrafficSpecialControlResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddTrafficSpecialControlResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddTrafficSpecialControlResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AssociateInstanceWithPrivateDNSRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * apigateway-hz-ead4f4b0bac8
   */
  instanceId?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  intranetDomains?: string[];
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      intranetDomains: 'IntranetDomains',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      intranetDomains: { 'type': 'array', 'itemType': 'string' },
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AssociateInstanceWithPrivateDNSShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * apigateway-hz-ead4f4b0bac8
   */
  instanceId?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  intranetDomainsShrink?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      intranetDomainsShrink: 'IntranetDomains',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      intranetDomainsShrink: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AssociateInstanceWithPrivateDNSResponseBody extends $tea.Model {
  /**
   * @example
   * 03442A3D-3B7D-434C-8A95-A5FEB999B529
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AssociateInstanceWithPrivateDNSResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AssociateInstanceWithPrivateDNSResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AssociateInstanceWithPrivateDNSResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AttachApiProductRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the API product.
   * 
   * This parameter is required.
   * 
   * @example
   * 117b7a64a8b3f064eaa4a47ac62aac5e
   */
  apiProductId?: string;
  /**
   * @remarks
   * The APIs to be attached.
   * 
   * This parameter is required.
   */
  apis?: AttachApiProductRequestApis[];
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      apiProductId: 'ApiProductId',
      apis: 'Apis',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiProductId: 'string',
      apis: { 'type': 'array', 'itemType': AttachApiProductRequestApis },
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AttachApiProductResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * BA20890E-75C7-41BC-9C8B-73276B58F550
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AttachApiProductResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AttachApiProductResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AttachApiProductResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AttachPluginRequest extends $tea.Model {
  /**
   * @remarks
   * The number of the API to be bound.
   * 
   * @example
   * 8afff6c8c4c6447abb035812e4d66b65
   */
  apiId?: string;
  /**
   * @remarks
   * The number of the API to be operated. Separate multiple numbers with commas (,). A maximum of 100 numbers can be entered.
   * 
   * @example
   * xxx
   */
  apiIds?: string;
  /**
   * @remarks
   * The ID of the API group that contains the API to which the plug-in is to be bound.
   * 
   * @example
   * 285bb759342649a1b70c2093a772e087
   */
  groupId?: string;
  /**
   * @remarks
   * The ID of the plug-in to be bound.
   * 
   * This parameter is required.
   * 
   * @example
   * 9a3f1a5279434f2ba74ccd91c295af9f
   */
  pluginId?: string;
  securityToken?: string;
  /**
   * @remarks
   * The name of the runtime environment. Valid values:
   * 
   * *   **RELEASE**
   * *   **PRE: the pre-release environment**
   * *   **TEST**
   * 
   * This parameter is required.
   * 
   * @example
   * TEST
   */
  stageName?: string;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      apiIds: 'ApiIds',
      groupId: 'GroupId',
      pluginId: 'PluginId',
      securityToken: 'SecurityToken',
      stageName: 'StageName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'string',
      apiIds: 'string',
      groupId: 'string',
      pluginId: 'string',
      securityToken: 'string',
      stageName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AttachPluginResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * EF924FE4-2EDD-4CD3-89EC-34E4708574E7
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AttachPluginResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AttachPluginResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AttachPluginResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchAbolishApisRequest extends $tea.Model {
  /**
   * @remarks
   * The APIs that you want to operate.
   * 
   * This parameter is required.
   */
  api?: BatchAbolishApisRequestApi[];
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      api: 'Api',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      api: { 'type': 'array', 'itemType': BatchAbolishApisRequestApi },
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchAbolishApisResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the operation.
   * 
   * @example
   * f7834d74be4e41aa8e607b0fafae9b33
   */
  operationId?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * E7FE7172-AA75-5880-B6F7-C00893E9BC06
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      operationId: 'OperationId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      operationId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchAbolishApisResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: BatchAbolishApisResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchAbolishApisResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchDeployApisRequest extends $tea.Model {
  /**
   * @remarks
   * The APIs that you want to publish.
   */
  api?: BatchDeployApisRequestApi[];
  /**
   * @remarks
   * The description.
   * 
   * This parameter is required.
   * 
   * @example
   * test
   */
  description?: string;
  securityToken?: string;
  /**
   * @remarks
   * The name of the runtime environment. Valid values:
   * 
   * *   **RELEASE**
   * *   **TEST**
   * *   PRE: the pre-release environment
   * 
   * This parameter is required.
   * 
   * @example
   * RELEASE
   */
  stageName?: string;
  static names(): { [key: string]: string } {
    return {
      api: 'Api',
      description: 'Description',
      securityToken: 'SecurityToken',
      stageName: 'StageName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      api: { 'type': 'array', 'itemType': BatchDeployApisRequestApi },
      description: 'string',
      securityToken: 'string',
      stageName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchDeployApisResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the operation.
   * 
   * @example
   * 2a322599-8e38-428a-a306-9b21ea2129bf
   */
  operationId?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * E7FE7172-AA75-5880-B6F7-C00893E9BC06
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      operationId: 'OperationId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      operationId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchDeployApisResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: BatchDeployApisResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchDeployApisResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAccessControlListRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the ACL. The name must be 1 to 30 characters in length, and can contain letters, digits, periods (.), hyphens (-), forward slashes (/), and underscores (_). The name must be unique within the region.
   * 
   * This parameter is required.
   * 
   * @example
   * testAcl
   */
  aclName?: string;
  /**
   * @remarks
   * The IP protocol version of the ACL. Valid values:
   * 
   * *   **IPv4**
   * *   **IPv6**
   * 
   * @example
   * ipv4
   */
  addressIPVersion?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      aclName: 'AclName',
      addressIPVersion: 'AddressIPVersion',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aclName: 'string',
      addressIPVersion: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAccessControlListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ACL ID.
   * 
   * @example
   * acl-bp1uqwgwmkbutnzq2r59z
   */
  aclId?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ015
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      aclId: 'AclId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aclId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAccessControlListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateAccessControlListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateAccessControlListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateApiRequest extends $tea.Model {
  /**
   * @remarks
   * The type of the two-way communication API.
   * 
   * *   **COMMON**: normal APIs
   * *   **REGISTER**: registered APIs
   * *   **UNREGISTER**: unregistered APIs
   * *   **NOTIFY**: downstream notification APIs
   * 
   * @example
   * HmacSHA256
   */
  allowSignatureMethod?: string;
  /**
   * @remarks
   * The name of the API that you want to create. The name must be unique within the API group. The name must be 4 to 50 characters in length. It must start with a letter and can contain letters, digits, and underscores (_).
   * 
   * This parameter is required.
   * 
   * @example
   * ApiName
   */
  apiName?: string;
  /**
   * @remarks
   * The IDof the backend service
   * 
   * @example
   * HEADER
   */
  appCodeAuthType?: string;
  /**
   * @remarks
   * The configuration items of API requests sent by the consumer to API Gateway.
   * 
   * For more information, see [RequestConfig](https://help.aliyun.com/document_detail/43985.html).
   * 
   * @example
   * APP
   */
  authType?: string;
  /**
   * @remarks
   * Specifies whether to enable backend services.
   * 
   * @example
   * true
   */
  backendEnable?: boolean;
  /**
   * @remarks
   * Specifies whether to enable backend services.
   * 
   * @example
   * a0305308908c4740aba9cbfd63ba99b7
   */
  backendId?: string;
  constantParameters?: string;
  /**
   * @remarks
   * The description of the API. The description can be up to 180 characters in length.
   * 
   * @example
   * Api description
   */
  description?: string;
  /**
   * @remarks
   * If **AuthType** is set to **APP**, the valid values are:
   * 
   * *   **DEFAULT**: The default value that is used if no other values are passed. This value means that the setting of the group is used.
   * *   **DISABLE**: The authentication is disabled.
   * *   **HEADER**: AppCode can be placed in the Header parameter for authentication.
   * *   **HEADER_QUERY**: AppCode can be placed in the Header or Query parameter for authentication.
   * 
   * @example
   * true
   */
  disableInternet?: boolean;
  errorCodeSamples?: string;
  failResultSample?: string;
  /**
   * @remarks
   * *   Specifies whether to set **DisableInternet** to **true** to limit API calls to within the VPC.
   * *   If you set **DisableInternet** to **false**, the limit is lifted. The default value is false when you create an API.
   * 
   * @example
   * true
   */
  forceNonceCheck?: boolean;
  /**
   * @remarks
   * The ID of the API group.
   * 
   * This parameter is required.
   * 
   * @example
   * 08ae4aa0f95e4321849ee57f4e0b3077
   */
  groupId?: string;
  /**
   * @remarks
   * If the **AuthType** is **APP** authentication, you need to pass this value to specify the signature algorithm. If you do not specify this parameter, the default value HmacSHA256 is used. Valid values:
   * 
   * *   HmacSHA256
   * *   HmacSHA1,HmacSHA256
   * 
   * @example
   * {\\"openIdApiType\\":null,\\"idTokenParamName\\":null,\\"publicKeyId\\":null,\\"publicKey\\":null}
   */
  openIdConnectConfig?: string;
  /**
   * @remarks
   * The configuration items of API requests sent by API Gateway to the backend service.
   * 
   * For more information, see [ServiceConfig](https://help.aliyun.com/document_detail/43987.html).
   * 
   * This parameter is required.
   * 
   * @example
   * {"RequestProtocol":"HTTP","RequestHttpMethod":"GET","RequestPath":"/v3/getUserTest/[userId]","BodyFormat":"FORM","PostBodyDescription":""}
   */
  requestConfig?: string;
  requestParameters?: string;
  /**
   * @remarks
   * *   Specifies whether to set **ForceNonceCheck** to **true** to force the check of X-Ca-Nonce during the request. This is the unique identifier of the request and is generally identified by UUID. After receiving this parameter, API Gateway verifies the validity of this parameter. The same value can be used only once within 15 minutes. This helps prevent replay attacks.
   * *   If you set **ForceNonceCheck** to **false**, the check is not performed. The default value is false when you create an API.
   * 
   * @example
   * {}
   */
  resultBodyModel?: string;
  resultDescriptions?: string;
  resultSample?: string;
  /**
   * @remarks
   * The sample response from the backend service.
   * 
   * @example
   * HTML
   */
  resultType?: string;
  securityToken?: string;
  /**
   * @remarks
   * The parameters of API requests sent by the consumer to API Gateway.
   * 
   * For more information, see [RequestParameter](https://help.aliyun.com/document_detail/43986.html).
   * 
   * This parameter is required.
   * 
   * @example
   * {"ServiceProtocol":"HTTP","ServiceHttpMethod":"GET","ServiceAddress":"http://www.customerdomain.com","ServiceTimeout":"1000","ServicePath":"/v3/getUserTest/[userId]"}
   */
  serviceConfig?: string;
  serviceParameters?: string;
  serviceParametersMap?: string;
  systemParameters?: string;
  /**
   * @remarks
   * The list of tags.
   */
  tag?: CreateApiRequestTag[];
  /**
   * @remarks
   * Specifies whether to make the API public. Valid values:
   * 
   * *   **PUBLIC**: Make the API public. If you set this parameter to PUBLIC, this API is displayed on the APIs page for all users after the API is published to the production environment.
   * *   **PRIVATE**: Make the API private. Private APIs are not displayed in the Alibaba Cloud Marketplace after the API group to which they belong is made available.
   * 
   * This parameter is required.
   * 
   * @example
   * PUBLIC
   */
  visibility?: string;
  /**
   * @remarks
   * The return description of the API.
   * 
   * @example
   * COMMON
   */
  webSocketApiType?: string;
  static names(): { [key: string]: string } {
    return {
      allowSignatureMethod: 'AllowSignatureMethod',
      apiName: 'ApiName',
      appCodeAuthType: 'AppCodeAuthType',
      authType: 'AuthType',
      backendEnable: 'BackendEnable',
      backendId: 'BackendId',
      constantParameters: 'ConstantParameters',
      description: 'Description',
      disableInternet: 'DisableInternet',
      errorCodeSamples: 'ErrorCodeSamples',
      failResultSample: 'FailResultSample',
      forceNonceCheck: 'ForceNonceCheck',
      groupId: 'GroupId',
      openIdConnectConfig: 'OpenIdConnectConfig',
      requestConfig: 'RequestConfig',
      requestParameters: 'RequestParameters',
      resultBodyModel: 'ResultBodyModel',
      resultDescriptions: 'ResultDescriptions',
      resultSample: 'ResultSample',
      resultType: 'ResultType',
      securityToken: 'SecurityToken',
      serviceConfig: 'ServiceConfig',
      serviceParameters: 'ServiceParameters',
      serviceParametersMap: 'ServiceParametersMap',
      systemParameters: 'SystemParameters',
      tag: 'Tag',
      visibility: 'Visibility',
      webSocketApiType: 'WebSocketApiType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allowSignatureMethod: 'string',
      apiName: 'string',
      appCodeAuthType: 'string',
      authType: 'string',
      backendEnable: 'boolean',
      backendId: 'string',
      constantParameters: 'string',
      description: 'string',
      disableInternet: 'boolean',
      errorCodeSamples: 'string',
      failResultSample: 'string',
      forceNonceCheck: 'boolean',
      groupId: 'string',
      openIdConnectConfig: 'string',
      requestConfig: 'string',
      requestParameters: 'string',
      resultBodyModel: 'string',
      resultDescriptions: 'string',
      resultSample: 'string',
      resultType: 'string',
      securityToken: 'string',
      serviceConfig: 'string',
      serviceParameters: 'string',
      serviceParametersMap: 'string',
      systemParameters: 'string',
      tag: { 'type': 'array', 'itemType': CreateApiRequestTag },
      visibility: 'string',
      webSocketApiType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateApiResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the API.
   * 
   * @example
   * 8afff6c8c4c6447abb035812e4d66b65
   */
  apiId?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 6C87A26A-6A18-4B8E-8099-705278381A2C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateApiResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateApiResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateApiResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateApiGroupRequest extends $tea.Model {
  /**
   * @example
   * /qqq
   */
  basePath?: string;
  /**
   * @example
   * The weather informations.
   */
  description?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * Weather
   */
  groupName?: string;
  /**
   * @example
   * apigateway-cn-v6419k43xxxxx
   */
  instanceId?: string;
  securityToken?: string;
  /**
   * @example
   * Key， Value
   */
  tag?: CreateApiGroupRequestTag[];
  static names(): { [key: string]: string } {
    return {
      basePath: 'BasePath',
      description: 'Description',
      groupName: 'GroupName',
      instanceId: 'InstanceId',
      securityToken: 'SecurityToken',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      basePath: 'string',
      description: 'string',
      groupName: 'string',
      instanceId: 'string',
      securityToken: 'string',
      tag: { 'type': 'array', 'itemType': CreateApiGroupRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateApiGroupResponseBody extends $tea.Model {
  /**
   * @example
   * /qqq
   */
  basePath?: string;
  /**
   * @example
   * The weather informations
   */
  description?: string;
  /**
   * @example
   * 523e8dc7bbe04613b5b1d726c2a7xx
   */
  groupId?: string;
  /**
   * @example
   * Weather
   */
  groupName?: string;
  /**
   * @example
   * apigateway-cn-v6419k43xxxxx
   */
  instanceId?: string;
  /**
   * @example
   * VPC_SHARED
   */
  instanceType?: string;
  /**
   * @example
   * FF3B7D81-66AE-47E0-BF69-157DCF187514
   */
  requestId?: string;
  /**
   * @example
   * 523e8dc7bbe04613b5b1d726xxxxxxxx-cn-hangzhou.alicloudapi.com
   */
  subDomain?: string;
  /**
   * @example
   * True
   */
  tagStatus?: boolean;
  static names(): { [key: string]: string } {
    return {
      basePath: 'BasePath',
      description: 'Description',
      groupId: 'GroupId',
      groupName: 'GroupName',
      instanceId: 'InstanceId',
      instanceType: 'InstanceType',
      requestId: 'RequestId',
      subDomain: 'SubDomain',
      tagStatus: 'TagStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      basePath: 'string',
      description: 'string',
      groupId: 'string',
      groupName: 'string',
      instanceId: 'string',
      instanceType: 'string',
      requestId: 'string',
      subDomain: 'string',
      tagStatus: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateApiGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateApiGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateApiGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateApiStageVariableRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the API group.
   * 
   * This parameter is required.
   * 
   * @example
   * 523e8dc7bbe04613b5b1d726c2a7889d
   */
  groupId?: string;
  securityToken?: string;
  /**
   * @remarks
   * The ID of the runtime environment.
   * 
   * This parameter is required.
   * 
   * @example
   * 6EF60BEC-0242-43AF-BB20-270359FB54A7
   */
  stageId?: string;
  /**
   * @remarks
   * The routing model of the environment.
   * 
   * @example
   * {
   *     "location": "HEAD",
   *     "parameterCatalog": "CUSTOM",
   *     "parameterType": "String",
   *     "serviceParameterName": "TestConstant",
   *     "routeMatchSymbol": "IN",
   *     "routeRules": [
   *         {
   *             "conditionValue": "aaa,bbb",
   *             "resultValue": "apigateway-test.com"
   *         }
   *     ]
   * }
   * 
   * @deprecated
   */
  stageRouteModel?: string;
  /**
   * @remarks
   * Specifies whether routing is supported.
   * 
   * @example
   * true
   */
  supportRoute?: boolean;
  /**
   * @remarks
   * The name of the variable to be added. This parameter is case-sensitive.
   * 
   * This parameter is required.
   * 
   * @example
   * serverName
   */
  variableName?: string;
  /**
   * @remarks
   * The value of the variable.
   * 
   * @example
   * api.domain.com
   */
  variableValue?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      securityToken: 'SecurityToken',
      stageId: 'StageId',
      stageRouteModel: 'StageRouteModel',
      supportRoute: 'SupportRoute',
      variableName: 'VariableName',
      variableValue: 'VariableValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      securityToken: 'string',
      stageId: 'string',
      stageRouteModel: 'string',
      supportRoute: 'boolean',
      variableName: 'string',
      variableValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateApiStageVariableResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 03442A3D-3B7D-434C-8A95-A5FEB999B529
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateApiStageVariableResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateApiStageVariableResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateApiStageVariableResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAppRequest extends $tea.Model {
  /**
   * @remarks
   * The AppCode of the application.
   * 
   * @example
   * 3aaf905a0a1f4f0eabc6d891dfa08afc
   */
  appCode?: string;
  /**
   * @remarks
   * The key of the application that is used to make an API call.
   * 
   * @example
   * 60030986
   */
  appKey?: string;
  /**
   * @remarks
   * The name of the application. The name must be 4 to 26 characters in length. The name can contain letters, digits, and underscores (_), and must start with a letter.
   * 
   * This parameter is required.
   * 
   * @example
   * CreateAppTest
   */
  appName?: string;
  /**
   * @remarks
   * The password of the application.
   * 
   * @example
   * nzyNqFkRWB2uLw86
   */
  appSecret?: string;
  /**
   * @remarks
   * The description of the application. The description can be up to 180 characters in length.
   * 
   * @example
   * test
   */
  description?: string;
  /**
   * @remarks
   * The extended information.
   * 
   * @example
   * 110210264071
   */
  extend?: string;
  securityToken?: string;
  /**
   * @remarks
   * The tag of objects that match the rule. You can specify multiple tags.
   * 
   * @example
   * Key， Value
   */
  tag?: CreateAppRequestTag[];
  static names(): { [key: string]: string } {
    return {
      appCode: 'AppCode',
      appKey: 'AppKey',
      appName: 'AppName',
      appSecret: 'AppSecret',
      description: 'Description',
      extend: 'Extend',
      securityToken: 'SecurityToken',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appCode: 'string',
      appKey: 'string',
      appName: 'string',
      appSecret: 'string',
      description: 'string',
      extend: 'string',
      securityToken: 'string',
      tag: { 'type': 'array', 'itemType': CreateAppRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAppResponseBody extends $tea.Model {
  /**
   * @remarks
   * The unique ID of the application.
   * 
   * @example
   * 20112314518278
   */
  appId?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * BA20890E-75C7-41BC-9C8B-73276B58F550
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the tag exists. If the value is **true**, the tag exists. If the value is **false**, the tag does not exist.
   * 
   * @example
   * false
   */
  tagStatus?: boolean;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      requestId: 'RequestId',
      tagStatus: 'TagStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'number',
      requestId: 'string',
      tagStatus: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAppResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateAppResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateAppResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAppCodeRequest extends $tea.Model {
  /**
   * @remarks
   * The application AppCode.
   * 
   * @example
   * 3aaf905a0a1f4f0eabc6d891dfa08afc
   */
  appCode?: string;
  /**
   * @remarks
   * The application ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 111203109
   */
  appId?: string;
  static names(): { [key: string]: string } {
    return {
      appCode: 'AppCode',
      appId: 'AppId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appCode: 'string',
      appId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAppCodeResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 418DAAE7-A0C2-5E9C-ADFF-4CD14A474F88
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAppCodeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateAppCodeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateAppCodeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAppKeyRequest extends $tea.Model {
  /**
   * @remarks
   * The application ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 111053351
   */
  appId?: string;
  /**
   * @remarks
   * The application AppKey.
   * 
   * @example
   * 204203237
   */
  appKey?: string;
  /**
   * @remarks
   * The application AppSecret.
   * 
   * @example
   * 6f0a4ad7918a4b41a57fc087d5b066d0
   */
  appSecret?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      appKey: 'AppKey',
      appSecret: 'AppSecret',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      appKey: 'string',
      appSecret: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAppKeyResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 5D524309-6BED-5BB4-A735-F7D9F98B7B88
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAppKeyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateAppKeyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateAppKeyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateBackendRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the backend service.
   * 
   * This parameter is required.
   * 
   * @example
   * testBackendService
   */
  backendName?: string;
  /**
   * @remarks
   * The type of the backend service.
   * 
   * This parameter is required.
   * 
   * @example
   * HTTP
   */
  backendType?: string;
  /**
   * @remarks
   * Specifies to create a EventBridge service-linked role.
   * 
   * @example
   * true
   */
  createEventBridgeServiceLinkedRole?: boolean;
  /**
   * @remarks
   * Specifies to create a service-linked role.
   * 
   * @example
   * true
   */
  createSlr?: boolean;
  /**
   * @remarks
   * The description.
   * 
   * @example
   * release data api 411055691504981
   */
  description?: string;
  securityToken?: string;
  /**
   * @remarks
   * The tag of objects that match the rule. You can specify multiple tags.
   */
  tag?: CreateBackendRequestTag[];
  static names(): { [key: string]: string } {
    return {
      backendName: 'BackendName',
      backendType: 'BackendType',
      createEventBridgeServiceLinkedRole: 'CreateEventBridgeServiceLinkedRole',
      createSlr: 'CreateSlr',
      description: 'Description',
      securityToken: 'SecurityToken',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      backendName: 'string',
      backendType: 'string',
      createEventBridgeServiceLinkedRole: 'boolean',
      createSlr: 'boolean',
      description: 'string',
      securityToken: 'string',
      tag: { 'type': 'array', 'itemType': CreateBackendRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateBackendResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the backend service.
   * 
   * @example
   * 0d105f80a8f340408bd34954d4e4ff22
   */
  backendId?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 66D84355-164D-53ED-81FF-03DCF181DE24
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      backendId: 'BackendId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      backendId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateBackendResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateBackendResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateBackendResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateBackendModelRequest extends $tea.Model {
  /**
   * @example
   * 34e94fcd3e2e47a49824a89b8f92cb5e
   */
  backendId?: string;
  /**
   * @example
   * {\\"ServiceAddress\\":\\"http://apigateway-echo-redux.alicloudapi.com:8080\\"}
   */
  backendModelData?: string;
  /**
   * @example
   * HTTP
   */
  backendType?: string;
  /**
   * @example
   * model description
   */
  description?: string;
  securityToken?: string;
  /**
   * @example
   * TEST
   */
  stageName?: string;
  static names(): { [key: string]: string } {
    return {
      backendId: 'BackendId',
      backendModelData: 'BackendModelData',
      backendType: 'BackendType',
      description: 'Description',
      securityToken: 'SecurityToken',
      stageName: 'StageName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      backendId: 'string',
      backendModelData: 'string',
      backendType: 'string',
      description: 'string',
      securityToken: 'string',
      stageName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateBackendModelResponseBody extends $tea.Model {
  /**
   * @example
   * 4be6b110b7aa40b0bf0c83cc00b3bd86
   */
  backendModelId?: string;
  /**
   * @example
   * 64411ECF-FAF7-5E3C-BA7B-E4A1F15A28CA
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      backendModelId: 'BackendModelId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      backendModelId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateBackendModelResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateBackendModelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateBackendModelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDatasetRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the dataset.
   * 
   * This parameter is required.
   * 
   * @example
   * DatasetName
   */
  datasetName?: string;
  /**
   * @remarks
   * The type of the dataset. Valid values:
   * 
   * * JWT_BLOCKING: a JSON Web Token (JWT) blacklist
   * * IP_WHITELIST_CIDR : an IP address whitelist
   * * PARAMETER_ACCESS : parameter-based access control
   * 
   * This parameter is required.
   * 
   * @example
   * JWT_BLOCKING
   */
  datasetType?: string;
  securityToken?: string;
  /**
   * @remarks
   * The tag of objects that match the rule. You can specify multiple tags.
   */
  tag?: CreateDatasetRequestTag[];
  static names(): { [key: string]: string } {
    return {
      datasetName: 'DatasetName',
      datasetType: 'DatasetType',
      securityToken: 'SecurityToken',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      datasetName: 'string',
      datasetType: 'string',
      securityToken: 'string',
      tag: { 'type': 'array', 'itemType': CreateDatasetRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDatasetResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the dataset.
   * 
   * @example
   * a25a6589b2584ff490e891cc********
   */
  datasetId?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 4173F95B-360C-460C-9F6C-4A96********
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      datasetId: 'DatasetId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      datasetId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDatasetResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateDatasetResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateDatasetResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDatasetItemRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * a25a6589b2584ff490e891cc********
   */
  datasetId?: string;
  description?: string;
  /**
   * @example
   * 2022-09-22T12:00:00Z
   */
  expiredTime?: string;
  securityToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 106.43.XXX.XXX
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      datasetId: 'DatasetId',
      description: 'Description',
      expiredTime: 'ExpiredTime',
      securityToken: 'SecurityToken',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      datasetId: 'string',
      description: 'string',
      expiredTime: 'string',
      securityToken: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDatasetItemResponseBody extends $tea.Model {
  /**
   * @example
   * 5045****
   */
  datasetItemId?: string;
  /**
   * @example
   * 8A5E2053-4D9F-5280-B7A9-D357********
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      datasetItemId: 'DatasetItemId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      datasetItemId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDatasetItemResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateDatasetItemResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateDatasetItemResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateInstanceRequest extends $tea.Model {
  /**
   * @remarks
   * Whether to automatically pay when renewing. Value:
   * 
   * - True: Automatic payment. Please ensure that your account has sufficient balance.
   * - False: Console manual payment. The specific operation is to log in to the console, select Expenses in the upper right corner, enter the Expense Center, and find the target order in Order Management to make payment.
   * 
   * Default value: False.
   * 
   * @example
   * false
   */
  autoPay?: boolean;
  /**
   * @remarks
   * The billing method of the instance. Valid values: PostPaid (pay-as-you-go) and PrePaid (subscription).
   * 
   * This parameter is required.
   * 
   * @example
   * PostPaid
   * PrePaid
   */
  chargeType?: string;
  /**
   * @remarks
   * The subscription duration of the instance.
   * 
   * *   If PricingCycle is set to **Month**, set this parameter to an integer ranges from **1** to **9**.
   * *   If PricingCycle is set to **Year**, set this parameter to an integer ranges from **1** to **3**.
   * 
   * >  This parameter is valid and required only if the ChargeType parameter is set to **PrePaid**.
   * 
   * @example
   * 1
   */
  duration?: number;
  /**
   * @remarks
   * The HTTPS policy.
   * 
   * @example
   * HTTPS2_TLS1_2
   */
  httpsPolicy?: string;
  /**
   * @remarks
   * The CIDR block of the VPC integration instance.
   * 
   * *   192.168.0.0/16
   * *   172.16.0.0/12
   * 
   * **
   * 
   * **Warning** The VPC integration instance is connected to the specified CIDR block. Plan your CIDR block carefully to prevent overlaps with the private IP addresses of cloud services.
   * 
   * >  This parameter is in invitational preview and not available for public use.
   * 
   * @example
   * 172.16.0.0/12
   */
  instanceCidr?: string;
  /**
   * @remarks
   * Instance Name
   * 
   * This parameter is required.
   * 
   * @example
   * ApigatewayInstance
   */
  instanceName?: string;
  /**
   * @remarks
   * Instance specifications
   * 
   * This parameter is required.
   * 
   * @example
   * api.s1.small
   */
  instanceSpec?: string;
  /**
   * @remarks
   * The type of the dedicated instance. Valid values:
   * 
   * *   vpc_connect: a VPC integration instance
   * *   normal: a conventional dedicated instance
   * 
   * >  This parameter is in invitational preview and not available for public use.
   * 
   * @example
   * vpc_connect
   */
  instanceType?: string;
  /**
   * @remarks
   * The unit of the subscription duration of the subscription instance. Valid values:
   * 
   * *   **year**
   * *   **month**
   * 
   * >  This parameter is required if the ChargeType parameter is set to Prepaid.
   * 
   * @example
   * Month
   */
  pricingCycle?: string;
  /**
   * @remarks
   * The tags that you want to add to the instance.
   */
  tag?: CreateInstanceRequestTag[];
  /**
   * @remarks
   * Passwords are used to prevent duplicate requests from being submitted, please do not reuse them.
   * 
   * This parameter is required.
   * 
   * @example
   * c20d86c4-1eb3-4d0b-afe9-c586df1e2136
   */
  token?: string;
  /**
   * @remarks
   * The ID of the user\\"s VPC to be connected by the VPC integration instance.
   * 
   * >  This parameter is in invitational preview and not available for public use.
   * 
   * @example
   * vpc-m5eo7khlb4h4f8y9egsdg
   */
  userVpcId?: string;
  /**
   * @remarks
   * The zone in which you want to create the instance. This parameter is required for a conventional dedicated instance and optional for a virtual private cloud (VPC) integration instance.
   * 
   * @example
   * cn-beijing-MAZ3(c,e)
   */
  zoneId?: string;
  /**
   * @remarks
   * The network information when the instance is a VPC integration instance, such as the zone, vSwitch, and security group.
   * 
   * >  This parameter is in invitational preview and not available for public use.
   */
  zoneVSwitchSecurityGroup?: CreateInstanceRequestZoneVSwitchSecurityGroup[];
  static names(): { [key: string]: string } {
    return {
      autoPay: 'AutoPay',
      chargeType: 'ChargeType',
      duration: 'Duration',
      httpsPolicy: 'HttpsPolicy',
      instanceCidr: 'InstanceCidr',
      instanceName: 'InstanceName',
      instanceSpec: 'InstanceSpec',
      instanceType: 'InstanceType',
      pricingCycle: 'PricingCycle',
      tag: 'Tag',
      token: 'Token',
      userVpcId: 'UserVpcId',
      zoneId: 'ZoneId',
      zoneVSwitchSecurityGroup: 'ZoneVSwitchSecurityGroup',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoPay: 'boolean',
      chargeType: 'string',
      duration: 'number',
      httpsPolicy: 'string',
      instanceCidr: 'string',
      instanceName: 'string',
      instanceSpec: 'string',
      instanceType: 'string',
      pricingCycle: 'string',
      tag: { 'type': 'array', 'itemType': CreateInstanceRequestTag },
      token: 'string',
      userVpcId: 'string',
      zoneId: 'string',
      zoneVSwitchSecurityGroup: { 'type': 'array', 'itemType': CreateInstanceRequestZoneVSwitchSecurityGroup },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateInstanceResponseBody extends $tea.Model {
  /**
   * @remarks
   * Instance ID
   * 
   * @example
   * apigateway-hz-b3c5dadd5***
   */
  instanceId?: string;
  /**
   * @remarks
   * Request ID
   * 
   * @example
   * CEB6EC62-B6C7-5082-A45A-45A204724AC2
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the tag exists. Valid values: **true** and **false**.
   * 
   * @example
   * True
   */
  tagStatus?: boolean;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      requestId: 'RequestId',
      tagStatus: 'TagStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      requestId: 'string',
      tagStatus: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateInstanceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateIntranetDomainRequest extends $tea.Model {
  /**
   * @remarks
   * The custom domain name.
   * 
   * This parameter is required.
   * 
   * @example
   * 927d50c0f2e54b359919923d908bb015
   */
  groupId?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateIntranetDomainResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * api.demo.com
   */
  domainName?: string;
  /**
   * @remarks
   * auditing
   * 
   * @example
   * 20D942A5-EDC6-5DA3-93F9-257888399E22
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateIntranetDomainResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateIntranetDomainResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateIntranetDomainResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateIpControlRequest extends $tea.Model {
  /**
   * @remarks
   * The description. The description can be up to 200 characters in length.
   * 
   * @example
   * test
   */
  description?: string;
  /**
   * @remarks
   * The name of the ACL. The name must be 4 to 50 characters in length, and can contain letters, digits, and underscores (_). The name cannot start with an underscore (_).``
   * 
   * This parameter is required.
   * 
   * @example
   * controlNameTest
   */
  ipControlName?: string;
  /**
   * @remarks
   * The information about the policies. The information is an array of ipcontrolpolicys data.
   */
  ipControlPolicys?: CreateIpControlRequestIpControlPolicys[];
  /**
   * @remarks
   * The type of the ACL. Valid values:
   * 
   * *   **ALLOW**: an IP address whitelist
   * *   **REFUSE**: an IP address blacklist
   * 
   * This parameter is required.
   * 
   * @example
   * ALLOW
   */
  ipControlType?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      ipControlName: 'IpControlName',
      ipControlPolicys: 'IpControlPolicys',
      ipControlType: 'IpControlType',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      ipControlName: 'string',
      ipControlPolicys: { 'type': 'array', 'itemType': CreateIpControlRequestIpControlPolicys },
      ipControlType: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateIpControlResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the ACL.
   * 
   * @example
   * 7ea91319a34d48a09b5c9c871d9768b1
   */
  ipControlId?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CE5722A6-AE78-4741-A9B0-6C817D360510
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      ipControlId: 'IpControlId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ipControlId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateIpControlResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateIpControlResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateIpControlResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLogConfigRequest extends $tea.Model {
  /**
   * @example
   * PROVIDER
   */
  logType?: string;
  securityToken?: string;
  /**
   * @remarks
   * slslogstore
   * 
   * This parameter is required.
   * 
   * @example
   * api-gateway
   */
  slsLogStore?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * rec-lq-sls
   */
  slsProject?: string;
  static names(): { [key: string]: string } {
    return {
      logType: 'LogType',
      securityToken: 'SecurityToken',
      slsLogStore: 'SlsLogStore',
      slsProject: 'SlsProject',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logType: 'string',
      securityToken: 'string',
      slsLogStore: 'string',
      slsProject: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLogConfigResponseBody extends $tea.Model {
  /**
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BA984
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLogConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateLogConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateLogConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateModelRequest extends $tea.Model {
  /**
   * @remarks
   * The description of the model definition.
   * 
   * @example
   * Model Description
   */
  description?: string;
  /**
   * @remarks
   * The ID of the API group to which the model belongs.
   * 
   * This parameter is required.
   * 
   * @example
   * 30e792398d6c4569b04c0e53a3494381
   */
  groupId?: string;
  /**
   * @remarks
   * The name of the model. The name must be unique within the group.
   * 
   * This parameter is required.
   * 
   * @example
   * Test
   */
  modelName?: string;
  /**
   * @remarks
   * The definition of the model in JSON Schema.
   * 
   * This parameter is required.
   * 
   * @example
   * {"type":"object","properties":{"id":{"format":"int64","maximum":100,"exclusiveMaximum":true,"type":"integer"},"name":{"maxLength":10,"type":"string"}}}
   */
  schema?: string;
  /**
   * @remarks
   * The object tags that match the lifecycle rule. You can specify multiple tags.
   */
  tag?: CreateModelRequestTag[];
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      groupId: 'GroupId',
      modelName: 'ModelName',
      schema: 'Schema',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      groupId: 'string',
      modelName: 'string',
      schema: 'string',
      tag: { 'type': 'array', 'itemType': CreateModelRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateModelResponseBody extends $tea.Model {
  /**
   * @remarks
   * The time when the model was created.
   * 
   * @example
   * 2019-01-29T09:33:01Z
   */
  createdTime?: string;
  /**
   * @remarks
   * The description of the created model.
   * 
   * @example
   * Model Description
   */
  description?: string;
  /**
   * @remarks
   * The ID of the API group to which the created model belongs.
   * 
   * @example
   * 30e792398d6c4569b04c0e53a3494381
   */
  groupId?: string;
  /**
   * @remarks
   * The ID of the created model.
   * 
   * @example
   * 766c0b9538a04bdf974953b5576783ba
   */
  modelId?: string;
  /**
   * @remarks
   * The name of the created model.
   * 
   * @example
   * Test
   */
  modelName?: string;
  /**
   * @remarks
   * The URI of the created model.
   * 
   * @example
   * https://apigateway.aliyun.com/models/30e792398d6c4569b04c0e53a3494381/766c0b9538a04bdf974953b5576783ba
   */
  modelRef?: string;
  /**
   * @remarks
   * The time when the model is last modified.
   * 
   * @example
   * 2019-01-29T09:33:01Z
   */
  modifiedTime?: string;
  /**
   * @remarks
   * The region to which the created model belongs.
   * 
   * @example
   * cn-qingdao
   */
  regionId?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 4173F95B-360C-460C-9F6C-4A960B904411
   */
  requestId?: string;
  /**
   * @remarks
   * The definition of the created model.
   * 
   * @example
   * {\\"type\\":\\"object\\",\\"properties\\":{\\"id\\":{\\"format\\":\\"int64\\",\\"maximum\\":100,\\"exclusiveMaximum\\":true,\\"type\\":\\"integer\\"},\\"name\\":{\\"maxLength\\":10,\\"type\\":\\"string\\"}}}
   */
  schema?: string;
  static names(): { [key: string]: string } {
    return {
      createdTime: 'CreatedTime',
      description: 'Description',
      groupId: 'GroupId',
      modelId: 'ModelId',
      modelName: 'ModelName',
      modelRef: 'ModelRef',
      modifiedTime: 'ModifiedTime',
      regionId: 'RegionId',
      requestId: 'RequestId',
      schema: 'Schema',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createdTime: 'string',
      description: 'string',
      groupId: 'string',
      modelId: 'string',
      modelName: 'string',
      modelRef: 'string',
      modifiedTime: 'string',
      regionId: 'string',
      requestId: 'string',
      schema: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateModelResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateModelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateModelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMonitorGroupRequest extends $tea.Model {
  /**
   * @remarks
   * The caller authentication status of the API. Valid values: **ok**: The authentication is successful. **mismatch**: The request is redirected. **servicenotfound**: A request error occurred. **Unknown**: An unknown error occurred.
   * 
   * This parameter is required.
   * 
   * @example
   * false
   */
  auth?: string;
  /**
   * @remarks
   * The ID of the API group.
   * 
   * This parameter is required.
   * 
   * @example
   * 6735211ab9094c818f32f27bc545b6c8
   */
  groupId?: string;
  /**
   * @remarks
   * The ID of the monitoring group.
   * 
   * @example
   * 166636221
   */
  rawMonitorGroupId?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      auth: 'Auth',
      groupId: 'GroupId',
      rawMonitorGroupId: 'RawMonitorGroupId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      auth: 'string',
      groupId: 'string',
      rawMonitorGroupId: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMonitorGroupResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the API group. This ID is generated by the system and is unique globally.
   * 
   * @example
   * 187421794
   */
  monitorGroupId?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 5D7136F7-9D67-5D4D-8418-6A512CCEE3A2
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      monitorGroupId: 'MonitorGroupId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      monitorGroupId: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMonitorGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateMonitorGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateMonitorGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePluginRequest extends $tea.Model {
  /**
   * @remarks
   * The description of the plug-in. The description can contain a maximum of 200 characters in length.
   * 
   * @example
   * createPlugin
   */
  description?: string;
  /**
   * @remarks
   * The plug-in definition. Supported formats: JSON and YAML.
   * 
   * This parameter is required.
   * 
   * @example
   * Plugin definition
   */
  pluginData?: string;
  /**
   * @remarks
   * The name of the plug-in. The name must be 4 to 50 characters in length and can contain letters, digits, and underscores (_). However, it cannot start with an underscore.
   * 
   * This parameter is required.
   * 
   * @example
   * NewCors
   */
  pluginName?: string;
  /**
   * @remarks
   * The type of the plug-in. Valid values:
   * 
   * *   **ipControl: IP address-based access control**
   * *   **trafficControl: throttling**
   * *   **backendSignature: backend signature**
   * *   **jwtAuth** :JWT (OpenId Connect) authentication
   * *   **cors** :cross-origin resource sharing (CORS)
   * *   **caching**
   * 
   * This parameter is required.
   * 
   * @example
   * cors
   */
  pluginType?: string;
  securityToken?: string;
  /**
   * @remarks
   * The tag of objects that match the rule. You can specify multiple tags.
   * 
   * @example
   * Key， Value
   */
  tag?: CreatePluginRequestTag[];
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      pluginData: 'PluginData',
      pluginName: 'PluginName',
      pluginType: 'PluginType',
      securityToken: 'SecurityToken',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      pluginData: 'string',
      pluginName: 'string',
      pluginType: 'string',
      securityToken: 'string',
      tag: { 'type': 'array', 'itemType': CreatePluginRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePluginResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the plug-in.
   * 
   * @example
   * 1f3bde29b43d4d53989248327ff737f2
   */
  pluginId?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * EF924FE4-2EDD-4CD3-89EC-34E4708574E7
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the plug-in is successfully marked.
   * 
   * @example
   * true
   */
  tagStatus?: boolean;
  static names(): { [key: string]: string } {
    return {
      pluginId: 'PluginId',
      requestId: 'RequestId',
      tagStatus: 'TagStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pluginId: 'string',
      requestId: 'string',
      tagStatus: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePluginResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreatePluginResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreatePluginResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePrivateDNSRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * api.demo.com
   */
  intranetDomain?: string;
  records?: CreatePrivateDNSRequestRecords[];
  securityToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * A
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      intranetDomain: 'IntranetDomain',
      records: 'Records',
      securityToken: 'SecurityToken',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      intranetDomain: 'string',
      records: { 'type': 'array', 'itemType': CreatePrivateDNSRequestRecords },
      securityToken: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePrivateDNSShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * api.demo.com
   */
  intranetDomain?: string;
  recordsShrink?: string;
  securityToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * A
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      intranetDomain: 'IntranetDomain',
      recordsShrink: 'Records',
      securityToken: 'SecurityToken',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      intranetDomain: 'string',
      recordsShrink: 'string',
      securityToken: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePrivateDNSResponseBody extends $tea.Model {
  /**
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ015
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePrivateDNSResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreatePrivateDNSResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreatePrivateDNSResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSignatureRequest extends $tea.Model {
  /**
   * @remarks
   * The security token included in the WebSocket request header. The system uses this token to authenticate the request.
   * 
   * @example
   * fa876ffb-caab-4f0a-93b3-3409f2fa5199
   */
  securityToken?: string;
  /**
   * @remarks
   * The Key value of the key. The value must be 6 to 20 characters in length and can contain letters, digits, and underscores (_). It must start with a letter.
   * 
   * This parameter is required.
   * 
   * @example
   * qwertyuiop
   */
  signatureKey?: string;
  /**
   * @remarks
   * The displayed name of the key. The name must be 4 to 50 characters in length and can contain letters, digits, and underscores (_). It must start with a letter.
   * 
   * This parameter is required.
   * 
   * @example
   * backendsignature
   */
  signatureName?: string;
  /**
   * @remarks
   * The Secret value of the key. The value must be 6 to 30 characters in length and can contain letters, digits, and special characters. Special characters include underscores (_), at signs (@), number signs (#), exclamation points (!), and asterisks (\\*). The value must start with a letter.
   * 
   * This parameter is required.
   * 
   * @example
   * asdfghjkl
   */
  signatureSecret?: string;
  static names(): { [key: string]: string } {
    return {
      securityToken: 'SecurityToken',
      signatureKey: 'SignatureKey',
      signatureName: 'SignatureName',
      signatureSecret: 'SignatureSecret',
    };
  }

  static types(): { [key: string]: any } {
    return {
      securityToken: 'string',
      signatureKey: 'string',
      signatureName: 'string',
      signatureSecret: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSignatureResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ004
   */
  requestId?: string;
  /**
   * @remarks
   * The ID of the back-end signature key.
   * 
   * @example
   * dd05f1c54d6749eda95f9fa6d491449a
   */
  signatureId?: string;
  /**
   * @remarks
   * The name of the back-end signature key.
   * 
   * @example
   * backendsignature
   */
  signatureName?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      signatureId: 'SignatureId',
      signatureName: 'SignatureName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      signatureId: 'string',
      signatureName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSignatureResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateSignatureResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateSignatureResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTrafficControlRequest extends $tea.Model {
  /**
   * @remarks
   * The default throttling value for each API.
   * 
   * This parameter is required.
   * 
   * @example
   * 10000
   */
  apiDefault?: number;
  /**
   * @remarks
   * The default throttling value for each app.
   * 
   * @example
   * 10000
   */
  appDefault?: number;
  /**
   * @remarks
   * The description of the throttling policy.
   * 
   * @example
   * ThrottlingTestDescription
   */
  description?: string;
  /**
   * @remarks
   * The security token included in the WebSocket request header. The system uses this token to authenticate the request.
   * 
   * @example
   * 436fa39b-b3b9-40c5-ae5d-ce3e000e38c5
   */
  securityToken?: string;
  /**
   * @remarks
   * The name of the throttling policy. The name must be 4 to 50 characters in length and can contain letters, digits, and underscores (_). It cannot start with an underscore.
   * 
   * This parameter is required.
   * 
   * @example
   * ThrottlingTest
   */
  trafficControlName?: string;
  /**
   * @remarks
   * The unit to be used in the throttling policy. Valid values:
   * 
   * *   **SECOND**
   * *   **MINUTE**
   * *   **HOUR**
   * *   **DAY**
   * 
   * This parameter is required.
   * 
   * @example
   * MINUTE
   */
  trafficControlUnit?: string;
  /**
   * @remarks
   * The default throttling value for each user.
   * 
   * @example
   * 10000
   */
  userDefault?: number;
  static names(): { [key: string]: string } {
    return {
      apiDefault: 'ApiDefault',
      appDefault: 'AppDefault',
      description: 'Description',
      securityToken: 'SecurityToken',
      trafficControlName: 'TrafficControlName',
      trafficControlUnit: 'TrafficControlUnit',
      userDefault: 'UserDefault',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiDefault: 'number',
      appDefault: 'number',
      description: 'string',
      securityToken: 'string',
      trafficControlName: 'string',
      trafficControlUnit: 'string',
      userDefault: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTrafficControlResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ004
   */
  requestId?: string;
  /**
   * @remarks
   * The ID of the throttling policy.
   * 
   * @example
   * tf123456
   */
  trafficControlId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      trafficControlId: 'TrafficControlId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      trafficControlId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTrafficControlResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateTrafficControlResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateTrafficControlResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAccessControlListRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the access control policy.
   * 
   * This parameter is required.
   * 
   * @example
   * acl-uf6fpfdg3b5muska7uqem
   */
  aclId?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      aclId: 'AclId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aclId: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAccessControlListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * EF924FE4-2EDD-4CD3-89EC-34E4708574E7
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAccessControlListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteAccessControlListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteAccessControlListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAllTrafficSpecialControlRequest extends $tea.Model {
  /**
   * @remarks
   * The security token included in the WebSocket request header. The system uses this token to authenticate the request.
   * 
   * @example
   * fa876ffb-caab-4f0a-93b3-3409f2fa5199
   */
  securityToken?: string;
  /**
   * @remarks
   * The ID of the throttling policy.
   * 
   * This parameter is required.
   * 
   * @example
   * tf123456
   */
  trafficControlId?: string;
  static names(): { [key: string]: string } {
    return {
      securityToken: 'SecurityToken',
      trafficControlId: 'TrafficControlId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      securityToken: 'string',
      trafficControlId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAllTrafficSpecialControlResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ004
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAllTrafficSpecialControlResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteAllTrafficSpecialControlResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteAllTrafficSpecialControlResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteApiRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the API.
   * 
   * This parameter is required.
   * 
   * @example
   * d6f679aeb3be4b91b3688e887ca1fe16
   */
  apiId?: string;
  /**
   * @remarks
   * The ID of the API group.
   * 
   * @example
   * 08ae4aa0f95e4321849ee57f4e0b3077
   */
  groupId?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      groupId: 'GroupId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'string',
      groupId: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteApiResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ017
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteApiResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteApiResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteApiResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteApiGroupRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the API group. This ID is generated by the system and globally unique.
   * 
   * This parameter is required.
   * 
   * @example
   * 523e8dc7bbe04613b5b1d726c2a7889d
   */
  groupId?: string;
  securityToken?: string;
  /**
   * @remarks
   * The object tags that match the lifecycle rule. You can specify multiple tags.
   * 
   * @example
   * Key， Value
   */
  tag?: DeleteApiGroupRequestTag[];
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      securityToken: 'SecurityToken',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      securityToken: 'string',
      tag: { 'type': 'array', 'itemType': DeleteApiGroupRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteApiGroupResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * E8515BA6-81CD-4191-A7CF-C4FCDD3C0D99
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteApiGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteApiGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteApiGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteApiProductRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the API product.
   * 
   * This parameter is required.
   * 
   * @example
   * 117b7a64a8b3f064eaa4a47ac62aac5e
   */
  apiProductId?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      apiProductId: 'ApiProductId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiProductId: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteApiProductResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ002
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteApiProductResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteApiProductResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteApiProductResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteApiStageVariableRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the API group.
   * 
   * This parameter is required.
   * 
   * @example
   * 523e8dc7bbe04613b5b1d726c2a7889d
   */
  groupId?: string;
  securityToken?: string;
  /**
   * @remarks
   * The ID of the environment.
   * 
   * This parameter is required.
   * 
   * @example
   * 6EF60BEC-0242-43AF-BB20-270359FB54A7
   */
  stageId?: string;
  /**
   * @remarks
   * The name of the variable to be deleted. This parameter is case-sensitive.
   * 
   * This parameter is required.
   * 
   * @example
   * serverName
   */
  variableName?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      securityToken: 'SecurityToken',
      stageId: 'StageId',
      variableName: 'VariableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      securityToken: 'string',
      stageId: 'string',
      variableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteApiStageVariableResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 03442A3D-3B7D-434C-8A95-A5FEB969B529
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteApiStageVariableResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteApiStageVariableResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteApiStageVariableResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAppRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the application.
   * 
   * This parameter is required.
   * 
   * @example
   * 110840611
   */
  appId?: number;
  securityToken?: string;
  /**
   * @remarks
   * The tags. Up to 20 tags are allowed.
   * 
   * @example
   * test2
   */
  tag?: DeleteAppRequestTag[];
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      securityToken: 'SecurityToken',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'number',
      securityToken: 'string',
      tag: { 'type': 'array', 'itemType': DeleteAppRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAppResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ015
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAppResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteAppResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteAppResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAppCodeRequest extends $tea.Model {
  /**
   * @remarks
   * The application AppCode.
   * 
   * This parameter is required.
   * 
   * @example
   * 0d13f021c5cd4997831a9717e75b0663
   */
  appCode?: string;
  /**
   * @remarks
   * The application ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 111265074
   */
  appId?: string;
  static names(): { [key: string]: string } {
    return {
      appCode: 'AppCode',
      appId: 'AppId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appCode: 'string',
      appId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAppCodeResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * E8515BA6-81CD-4191-A7CF-C4FCDD3C0D99
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAppCodeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteAppCodeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteAppCodeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAppKeyRequest extends $tea.Model {
  /**
   * @remarks
   * The application ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 110840611
   */
  appId?: string;
  /**
   * @remarks
   * The AppKey of the application. The AppKey is used for calling an API.
   * 
   * This parameter is required.
   * 
   * @example
   * 203708622
   */
  appKey?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      appKey: 'AppKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      appKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAppKeyResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 79EF055D-AC00-5161-8F35-6A36AAED7422
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAppKeyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteAppKeyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteAppKeyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteBackendRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the backend service.
   * 
   * @example
   * 27be0dd9ebbc467b9e86c0d250d0b92e
   */
  backendId?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      backendId: 'BackendId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      backendId: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteBackendResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * AD00F8C0-311B-54A9-ADE2-2436771012DA
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteBackendResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteBackendResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteBackendResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteBackendModelRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the backend service.
   * 
   * @example
   * 20bcdc9453524b78a8beb1f6de21edb7
   */
  backendId?: string;
  /**
   * @remarks
   * The ID of the backend model.
   * 
   * This parameter is required.
   * 
   * @example
   * 4be6b110b7aa40b0bf0c83cc00b3bd86
   */
  backendModelId?: string;
  securityToken?: string;
  /**
   * @remarks
   * The name of the runtime environment. Valid values:
   * 
   * *   **RELEASE**
   * *   **PRE**
   * *   **TEST**
   * 
   * @example
   * TEST
   */
  stageName?: string;
  static names(): { [key: string]: string } {
    return {
      backendId: 'BackendId',
      backendModelId: 'BackendModelId',
      securityToken: 'SecurityToken',
      stageName: 'StageName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      backendId: 'string',
      backendModelId: 'string',
      securityToken: 'string',
      stageName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteBackendModelResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the operation.
   * 
   * @example
   * f7834d74be4e41aa8e607b0fafae9b33
   */
  operationId?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * D1B18FFE-4A81-59D8-AA02-1817098977CD
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      operationId: 'OperationId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      operationId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteBackendModelResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteBackendModelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteBackendModelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDatasetRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * a25a6589b2584ff490e891cc********
   */
  datasetId?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      datasetId: 'DatasetId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      datasetId: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDatasetResponseBody extends $tea.Model {
  /**
   * @example
   * 048C8EFB-528F-5E97-8A3D-D17B********
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDatasetResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteDatasetResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteDatasetResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDatasetItemRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the dataset.
   * 
   * This parameter is required.
   * 
   * @example
   * a25a6589b2584ff490e891cc********
   */
  datasetId?: string;
  /**
   * @remarks
   * The ID of the data entry.
   * 
   * This parameter is required.
   * 
   * @example
   * 5045****
   */
  datasetItemId?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      datasetId: 'DatasetId',
      datasetItemId: 'DatasetItemId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      datasetId: 'string',
      datasetItemId: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDatasetItemResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * FF433E09-663A-5F5D-9DBA-A611********
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDatasetItemResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteDatasetItemResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteDatasetItemResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDomainRequest extends $tea.Model {
  /**
   * @remarks
   * The custom domain name.
   * 
   * This parameter is required.
   * 
   * @example
   * api.demo.com
   */
  domainName?: string;
  /**
   * @remarks
   * The ID of the API group to which the domain name to be unbound is bound. This ID is generated by the system and globally unique.
   * 
   * This parameter is required.
   * 
   * @example
   * 927d50c0f2e54b359919923d908bb015
   */
  groupId?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      groupId: 'GroupId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      groupId: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDomainResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 6EF60BEC-0242-43AF-BB20-270359FB54A7
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDomainResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteDomainResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteDomainResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDomainCertificateRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the SSL certificate that you want to delete. The ID is automatically generated by the system and globally unique.
   * 
   * This parameter is required.
   * 
   * @example
   * c621720d1eb34843822b7fb5148e6926
   */
  certificateId?: string;
  /**
   * @remarks
   * The custom domain name.
   * 
   * This parameter is required.
   * 
   * @example
   * api.demo.com
   */
  domainName?: string;
  /**
   * @remarks
   * The ID of the API group. This ID is generated by the system and globally unique.
   * 
   * This parameter is required.
   * 
   * @example
   * 927d50c0f2e54b359919923d908bb015
   */
  groupId?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      certificateId: 'CertificateId',
      domainName: 'DomainName',
      groupId: 'GroupId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      certificateId: 'string',
      domainName: 'string',
      groupId: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDomainCertificateResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CE5722A6-AE78-4741-A9B0-6C817D360510
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDomainCertificateResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteDomainCertificateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteDomainCertificateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteInstanceRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * apigateway-sh-ae502ee79ef8
   */
  instanceId?: string;
  /**
   * @remarks
   * The tag of objects that match the lifecycle rule. You can specify multiple tags.
   * 
   * @example
   * Key， Value
   */
  tag?: DeleteInstanceRequestTag[];
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      tag: { 'type': 'array', 'itemType': DeleteInstanceRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteInstanceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CA4B3261-F14A-5E33-8608-F75A1DF27AD4
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteInstanceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteIpControlRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the ACL. The ID is unique.
   * 
   * This parameter is required.
   * 
   * @example
   * 7ea91319a34d48a09b5c9c871d9768b1
   */
  ipControlId?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      ipControlId: 'IpControlId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ipControlId: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteIpControlResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ004
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteIpControlResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteIpControlResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteIpControlResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLogConfigRequest extends $tea.Model {
  /**
   * @remarks
   * The log type. Valid values: **log** and **survey**.
   * 
   * @example
   * log
   */
  logType?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      logType: 'LogType',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logType: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLogConfigResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ016
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLogConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteLogConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteLogConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteModelRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the API group to which the model belongs.
   * 
   * This parameter is required.
   * 
   * @example
   * 30e792398d6c4569b04c0e53a3494381
   */
  groupId?: string;
  /**
   * @remarks
   * The name of the model.
   * 
   * This parameter is required.
   * 
   * @example
   * Test
   */
  modelName?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      modelName: 'ModelName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      modelName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteModelResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 4173F95B-360C-460C-9F6C-4A960B904411
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteModelResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteModelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteModelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMonitorGroupRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the API group. This ID is generated by the system and globally unique.
   * 
   * This parameter is required.
   * 
   * @example
   * 42925e7f5209438186d5560239af5286
   */
  groupId?: string;
  /**
   * @remarks
   * The ID of the monitoring group.
   * 
   * @example
   * 166636221
   */
  rawMonitorGroupId?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      rawMonitorGroupId: 'RawMonitorGroupId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      rawMonitorGroupId: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMonitorGroupResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * C7E2CBAA-47FF-569F-AF12-B14B80E25422
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMonitorGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteMonitorGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteMonitorGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePluginRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the plug-in to be deleted.
   * 
   * This parameter is required.
   * 
   * @example
   * 9a3f1a5279434f2ba74ccd91c295af9f
   */
  pluginId?: string;
  securityToken?: string;
  /**
   * @remarks
   * The tag of objects that match the rule. You can specify multiple tags.
   */
  tag?: DeletePluginRequestTag[];
  static names(): { [key: string]: string } {
    return {
      pluginId: 'PluginId',
      securityToken: 'SecurityToken',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pluginId: 'string',
      securityToken: 'string',
      tag: { 'type': 'array', 'itemType': DeletePluginRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePluginResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BA984
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePluginResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeletePluginResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeletePluginResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePrivateDNSRequest extends $tea.Model {
  /**
   * @example
   * false
   */
  force?: boolean;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * api.demo.com
   */
  intranetDomain?: string;
  securityToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * A
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      force: 'Force',
      intranetDomain: 'IntranetDomain',
      securityToken: 'SecurityToken',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      force: 'boolean',
      intranetDomain: 'string',
      securityToken: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePrivateDNSResponseBody extends $tea.Model {
  /**
   * @example
   * EF924FE4-2EDD-4CD3-89EC-34E4708574E7
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePrivateDNSResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeletePrivateDNSResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeletePrivateDNSResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSignatureRequest extends $tea.Model {
  /**
   * @remarks
   * The security token included in the WebSocket request header. The system uses this token to authenticate the request.
   * 
   * @example
   * 9abe3317-3e22-4957-ab9f-dd893d0ac956
   */
  securityToken?: string;
  /**
   * @remarks
   * The ID of the key to be deleted.
   * 
   * This parameter is required.
   * 
   * @example
   * dd05f1c54d6749eda95f9fa6d491449a
   */
  signatureId?: string;
  static names(): { [key: string]: string } {
    return {
      securityToken: 'SecurityToken',
      signatureId: 'SignatureId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      securityToken: 'string',
      signatureId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSignatureResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ004
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSignatureResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteSignatureResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteSignatureResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTrafficControlRequest extends $tea.Model {
  securityToken?: string;
  /**
   * @remarks
   * The ID of the throttling policy.
   * 
   * This parameter is required.
   * 
   * @example
   * tf123456
   */
  trafficControlId?: string;
  static names(): { [key: string]: string } {
    return {
      securityToken: 'SecurityToken',
      trafficControlId: 'TrafficControlId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      securityToken: 'string',
      trafficControlId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTrafficControlResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ004
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTrafficControlResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteTrafficControlResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteTrafficControlResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTrafficSpecialControlRequest extends $tea.Model {
  /**
   * @remarks
   * The security token included in the WebSocket request header. The system uses this token to authenticate the request.
   * 
   * @example
   * 7c51b234-48d3-44e1-9b36-e2ddccc738e3
   */
  securityToken?: string;
  /**
   * @remarks
   * The ID of the app or Alibaba Cloud account. You can view your account ID on the [Account Management](https://account.console.aliyun.com/?spm=a2c4g.11186623.2.15.343130a8sDi8cO#/secure) page.
   * 
   * This parameter is required.
   * 
   * @example
   * 3382463
   */
  specialKey?: string;
  /**
   * @remarks
   * The type of the special throttling policy. Valid values:
   * 
   * *   **APP**
   * *   **USER**
   * 
   * This parameter is required.
   * 
   * @example
   * APP
   */
  specialType?: string;
  /**
   * @remarks
   * The ID of the throttling policy.
   * 
   * This parameter is required.
   * 
   * @example
   * tf123456
   */
  trafficControlId?: string;
  static names(): { [key: string]: string } {
    return {
      securityToken: 'SecurityToken',
      specialKey: 'SpecialKey',
      specialType: 'SpecialType',
      trafficControlId: 'TrafficControlId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      securityToken: 'string',
      specialKey: 'string',
      specialType: 'string',
      trafficControlId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTrafficSpecialControlResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ004
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTrafficSpecialControlResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteTrafficSpecialControlResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteTrafficSpecialControlResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeployApiRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the API.
   * 
   * This parameter is required.
   * 
   * @example
   * d6f679aeb3be4b91b3688e887ca1fe16
   */
  apiId?: string;
  /**
   * @remarks
   * The publishing remarks.
   * 
   * This parameter is required.
   * 
   * @example
   * for_test1
   */
  description?: string;
  /**
   * @remarks
   * The ID of the API group.
   * 
   * @example
   * 63be9002440b4778a61122f14c2b2bbb
   */
  groupId?: string;
  securityToken?: string;
  /**
   * @remarks
   * The name of the runtime environment. Valid values:
   * 
   * *   **RELEASE**
   * *   **PRE**: the pre-release environment
   * *   **TEST**
   * 
   * This parameter is required.
   * 
   * @example
   * RELEASE
   */
  stageName?: string;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      description: 'Description',
      groupId: 'GroupId',
      securityToken: 'SecurityToken',
      stageName: 'StageName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'string',
      description: 'string',
      groupId: 'string',
      securityToken: 'string',
      stageName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeployApiResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ015
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeployApiResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeployApiResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeployApiResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAbolishApiTaskRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the unpublishing operation.
   * 
   * This parameter is required.
   * 
   * @example
   * fc54****dd4c4***ad7edd7****39401
   */
  operationUid?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      operationUid: 'OperationUid',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      operationUid: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAbolishApiTaskResponseBody extends $tea.Model {
  /**
   * @remarks
   * The result returned.
   */
  apiAbolishResults?: DescribeAbolishApiTaskResponseBodyApiAbolishResults;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * E8515BA6-81CD-4191-A7CF-C4FCDD3C0D99
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      apiAbolishResults: 'ApiAbolishResults',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiAbolishResults: DescribeAbolishApiTaskResponseBodyApiAbolishResults,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAbolishApiTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAbolishApiTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAbolishApiTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAccessControlListAttributeRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the access control policy.
   * 
   * @example
   * acl-3nsohdozz0ru8fi5onwz1
   */
  aclId?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      aclId: 'AclId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aclId: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAccessControlListAttributeResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the access control policy.
   */
  aclEntrys?: DescribeAccessControlListAttributeResponseBodyAclEntrys;
  /**
   * @remarks
   * The ID of the access control policy.
   * 
   * @example
   * acl-uf6fpfdg3b5muska7uqem
   */
  aclId?: string;
  /**
   * @remarks
   * The name of the access control policy.
   * 
   * @example
   * testAcl
   */
  aclName?: string;
  /**
   * @remarks
   * The IP protocol version. Valid values: **ipv4** and **ipv6**.
   * 
   * @example
   * ipv4
   */
  addressIPVersion?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ015
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      aclEntrys: 'AclEntrys',
      aclId: 'AclId',
      aclName: 'AclName',
      addressIPVersion: 'AddressIPVersion',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aclEntrys: DescribeAccessControlListAttributeResponseBodyAclEntrys,
      aclId: 'string',
      aclName: 'string',
      addressIPVersion: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAccessControlListAttributeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAccessControlListAttributeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAccessControlListAttributeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAccessControlListsRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the access control policy.
   * 
   * @example
   * testAcl
   */
  aclName?: string;
  /**
   * @remarks
   * IP版本，可以设置为**ipv4**或者**ipv6**。
   * 
   * @example
   * ipv6
   */
  addressIPVersion?: string;
  /**
   * @remarks
   * The page number of the current page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      aclName: 'AclName',
      addressIPVersion: 'AddressIPVersion',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aclName: 'string',
      addressIPVersion: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAccessControlListsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ACLs.
   */
  acls?: DescribeAccessControlListsResponseBodyAcls;
  /**
   * @remarks
   * The page number of the current page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned on each page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ015
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 3
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      acls: 'Acls',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acls: DescribeAccessControlListsResponseBodyAcls,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAccessControlListsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAccessControlListsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAccessControlListsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the API.
   * 
   * This parameter is required.
   * 
   * @example
   * 8afff6c8c4c6447abb035812e4d66b65
   */
  apiId?: string;
  /**
   * @remarks
   * The ID of the API group.
   * 
   * @example
   * 123
   */
  groupId?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      groupId: 'GroupId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'string',
      groupId: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiResponseBody extends $tea.Model {
  /**
   * @remarks
   * If **AuthType** is set to **APP**, this value must be passed to specify the signature algorithm. If you do not specify a value, HmacSHA256 is used by default. Valid values:
   * 
   * *   HmacSHA256
   * *   HmacSHA1,HmacSHA256
   * 
   * @example
   * HmacSHA256
   */
  allowSignatureMethod?: string;
  /**
   * @remarks
   * The ID of the API.
   * 
   * @example
   * 8afff6c8c4c6447abb035812e4d66b65
   */
  apiId?: string;
  /**
   * @remarks
   * The name of the API, which is unique in the group.
   * 
   * @example
   * ApiName
   */
  apiName?: string;
  /**
   * @remarks
   * If **AuthType** is set to **APP**, the valid values are:
   * 
   * *   **DEFAULT**: The default value that is used if no other values are passed. This value means that the setting of the group is used.
   * *   **DISABLE**: The authentication is disabled.
   * *   **HEADER**: AppCode can be placed in the Header parameter for authentication.
   * *   **HEADER_QUERY**: AppCode can be placed in the Header or Query parameter for authentication.
   * 
   * @example
   * HEADER
   */
  appCodeAuthType?: string;
  /**
   * @remarks
   * The security authentication method of the API. Valid values:
   * 
   * *   **APP**: Only authorized applications can call the API.
   * 
   * *   **ANONYMOUS**: The API can be anonymously called. In this mode, you must take note of the following rules:
   * 
   *     *   All users who have obtained the API service information can call this API. API Gateway does not authenticate callers and cannot set user-specific throttling policies. If you make this API public, set API-specific throttling policies.
   *     *   We recommend that you do not make the API whose security authentication method is ANONYMOUS available in Alibaba Cloud Marketplace because API Gateway cannot meter calls on the caller or limit the number of calls on the API. If you want to make the API group to which the API belongs available in Alibaba Cloud Marketplace, we recommend that you move the API to another group, set its type to PRIVATE, or set its security authentication method to APP.
   * 
   * *   **APPOPENID**: The OpenID Connect account authentication method is used. Only applications authorized by OpenID Connect can call the API. If this method is selected, the OpenIdConnectConfig parameter is required.
   * 
   * @example
   * APP
   */
  authType?: string;
  /**
   * @remarks
   * Backend configurations
   */
  backendConfig?: DescribeApiResponseBodyBackendConfig;
  /**
   * @remarks
   * Specifies whether to enable backend services.
   * 
   * @example
   * true
   */
  backendEnable?: boolean;
  /**
   * @remarks
   * System parameters sent by API Gateway to the backend service
   */
  constantParameters?: DescribeApiResponseBodyConstantParameters;
  /**
   * @remarks
   * The creation time of the API.
   * 
   * @example
   * 2016-07-28T09:50:43Z
   */
  createdTime?: string;
  /**
   * @remarks
   * Custom system parameters
   */
  customSystemParameters?: DescribeApiResponseBodyCustomSystemParameters;
  /**
   * @remarks
   * The API publishing status.
   */
  deployedInfos?: DescribeApiResponseBodyDeployedInfos;
  /**
   * @remarks
   * The description of the API.
   * 
   * @example
   * Api description
   */
  description?: string;
  /**
   * @remarks
   * Specifies whether to limit API calls to within the VPC. Valid values:
   * 
   * *   **true**: Only API calls from the VPC are supported.
   * *   **false**: API calls from the VPC and Internet are both supported.
   * 
   * @example
   * false
   */
  disableInternet?: boolean;
  /**
   * @remarks
   * The sample error codes returned by the backend service.
   */
  errorCodeSamples?: DescribeApiResponseBodyErrorCodeSamples;
  /**
   * @remarks
   * The sample error response from the backend service.
   * 
   * @example
   * 400
   */
  failResultSample?: string;
  /**
   * @remarks
   * Specifies whether to carry the header : X-Ca-Nonce when calling an API. This is the unique identifier of the request and is generally identified by UUID. After receiving this parameter, API Gateway verifies the validity of this parameter. The same value can be used only once within 15 minutes. This helps prevent reply attacks. Valid values:
   * 
   * *   **true**: This field is forcibly checked when an API is requested to prevent replay attacks.
   * *   **false**: This field is not checked.
   * 
   * @example
   * true
   */
  forceNonceCheck?: boolean;
  /**
   * @remarks
   * The ID of the API group.
   * 
   * @example
   * 08ae4aa0f95e4321849ee57f4e0b3077
   */
  groupId?: string;
  /**
   * @remarks
   * The name of the API group.
   * 
   * @example
   * ApiTest
   */
  groupName?: string;
  /**
   * @remarks
   * Specifies whether to enable the Mock mode. Valid values:
   * 
   * *   OPEN: The Mock mode is enabled.
   * *   CLOSED: The Mock mode is not enabled.
   * 
   * @example
   * CLOSED
   */
  mock?: string;
  /**
   * @remarks
   * The result returned for service mocking.
   * 
   * @example
   * test result
   */
  mockResult?: string;
  /**
   * @remarks
   * The last modification time of the API.
   * 
   * @example
   * 2016-07-28T13:13:12Z
   */
  modifiedTime?: string;
  /**
   * @remarks
   * Configuration items of the third-party OpenID Connect authentication method
   */
  openIdConnectConfig?: DescribeApiResponseBodyOpenIdConnectConfig;
  /**
   * @remarks
   * The region ID of the API.
   * 
   * @example
   * cn-qingdao
   */
  regionId?: string;
  /**
   * @remarks
   * The configuration items of API requests sent by the consumer to API Gateway.
   */
  requestConfig?: DescribeApiResponseBodyRequestConfig;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * D0FF585F-7966-40CF-BC60-75DB070B23D5<
   */
  requestId?: string;
  /**
   * @remarks
   * The parameters of API requests sent by the consumer to API Gateway.
   */
  requestParameters?: DescribeApiResponseBodyRequestParameters;
  /**
   * @remarks
   * The returned description of the API.
   * 
   * @example
   * {}
   */
  resultBodyModel?: string;
  /**
   * @remarks
   * The sample response from the backend service.
   * 
   * @example
   * 200
   */
  resultSample?: string;
  /**
   * @remarks
   * The format of the response from the backend service. Valid values: JSON, TEXT, BINARY, XML, and HTML.
   * 
   * @example
   * JSON
   */
  resultType?: string;
  /**
   * @remarks
   * The configuration items of API requests that API Gateway sends to the backend service.
   */
  serviceConfig?: DescribeApiResponseBodyServiceConfig;
  /**
   * @remarks
   * The parameters of API requests sent by API Gateway to the backend service.
   */
  serviceParameters?: DescribeApiResponseBodyServiceParameters;
  /**
   * @remarks
   * The mappings between parameters of requests sent by the consumer to API Gateway and parameters of requests sent by API Gateway to the backend service.
   */
  serviceParametersMap?: DescribeApiResponseBodyServiceParametersMap;
  /**
   * @remarks
   * System parameters sent by API Gateway to the backend service
   */
  systemParameters?: DescribeApiResponseBodySystemParameters;
  /**
   * @remarks
   * Tag List.
   */
  tagList?: DescribeApiResponseBodyTagList;
  /**
   * @remarks
   * Specifies whether to make the API public. Valid values:
   * 
   * *   **PUBLIC**: Make the API public. If you set this parameter to PUBLIC, this API is displayed on the APIs page for all users after the API is published to the production environment.
   * *   **PRIVATE**: Make the API private. Private APIs are not displayed in the Alibaba Cloud Marketplace after the API group to which they belong is made available.
   * 
   * @example
   * PUBLIC
   */
  visibility?: string;
  /**
   * @remarks
   * The type of the two-way communication API.
   * 
   * *   **COMMON**: common API
   * *   **REGISTER**: registered API
   * *   **UNREGISTER**: unregistered API
   * *   **NOTIFY**: downstream notification API
   * 
   * @example
   * COMMON
   */
  webSocketApiType?: string;
  static names(): { [key: string]: string } {
    return {
      allowSignatureMethod: 'AllowSignatureMethod',
      apiId: 'ApiId',
      apiName: 'ApiName',
      appCodeAuthType: 'AppCodeAuthType',
      authType: 'AuthType',
      backendConfig: 'BackendConfig',
      backendEnable: 'BackendEnable',
      constantParameters: 'ConstantParameters',
      createdTime: 'CreatedTime',
      customSystemParameters: 'CustomSystemParameters',
      deployedInfos: 'DeployedInfos',
      description: 'Description',
      disableInternet: 'DisableInternet',
      errorCodeSamples: 'ErrorCodeSamples',
      failResultSample: 'FailResultSample',
      forceNonceCheck: 'ForceNonceCheck',
      groupId: 'GroupId',
      groupName: 'GroupName',
      mock: 'Mock',
      mockResult: 'MockResult',
      modifiedTime: 'ModifiedTime',
      openIdConnectConfig: 'OpenIdConnectConfig',
      regionId: 'RegionId',
      requestConfig: 'RequestConfig',
      requestId: 'RequestId',
      requestParameters: 'RequestParameters',
      resultBodyModel: 'ResultBodyModel',
      resultSample: 'ResultSample',
      resultType: 'ResultType',
      serviceConfig: 'ServiceConfig',
      serviceParameters: 'ServiceParameters',
      serviceParametersMap: 'ServiceParametersMap',
      systemParameters: 'SystemParameters',
      tagList: 'TagList',
      visibility: 'Visibility',
      webSocketApiType: 'WebSocketApiType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allowSignatureMethod: 'string',
      apiId: 'string',
      apiName: 'string',
      appCodeAuthType: 'string',
      authType: 'string',
      backendConfig: DescribeApiResponseBodyBackendConfig,
      backendEnable: 'boolean',
      constantParameters: DescribeApiResponseBodyConstantParameters,
      createdTime: 'string',
      customSystemParameters: DescribeApiResponseBodyCustomSystemParameters,
      deployedInfos: DescribeApiResponseBodyDeployedInfos,
      description: 'string',
      disableInternet: 'boolean',
      errorCodeSamples: DescribeApiResponseBodyErrorCodeSamples,
      failResultSample: 'string',
      forceNonceCheck: 'boolean',
      groupId: 'string',
      groupName: 'string',
      mock: 'string',
      mockResult: 'string',
      modifiedTime: 'string',
      openIdConnectConfig: DescribeApiResponseBodyOpenIdConnectConfig,
      regionId: 'string',
      requestConfig: DescribeApiResponseBodyRequestConfig,
      requestId: 'string',
      requestParameters: DescribeApiResponseBodyRequestParameters,
      resultBodyModel: 'string',
      resultSample: 'string',
      resultType: 'string',
      serviceConfig: DescribeApiResponseBodyServiceConfig,
      serviceParameters: DescribeApiResponseBodyServiceParameters,
      serviceParametersMap: DescribeApiResponseBodyServiceParametersMap,
      systemParameters: DescribeApiResponseBodySystemParameters,
      tagList: DescribeApiResponseBodyTagList,
      visibility: 'string',
      webSocketApiType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeApiResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeApiResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiDocRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the API.
   * 
   * This parameter is required.
   * 
   * @example
   * 3b81fd160f5645e097cc8855d75a1cf6
   */
  apiId?: string;
  /**
   * @remarks
   * The ID of the API group.
   * 
   * @example
   * 123
   */
  groupId?: string;
  securityToken?: string;
  /**
   * @remarks
   * The environment name. Valid values:
   * 
   * *   **RELEASE**
   * *   **TEST**
   * 
   * If this parameter is not specified, the default value RELEASE is used.
   * 
   * @example
   * RELEASE
   */
  stageName?: string;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      groupId: 'GroupId',
      securityToken: 'SecurityToken',
      stageName: 'StageName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'string',
      groupId: 'string',
      securityToken: 'string',
      stageName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiDocResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the API.
   * 
   * @example
   * b24be7e59a104e52bffbf432cc9272af
   */
  apiId?: string;
  /**
   * @remarks
   * The name of the API
   * 
   * @example
   * ObtainKeywordQRCodeAddress
   */
  apiName?: string;
  /**
   * @remarks
   * The security authentication method. Valid values: APP, ANONYMOUS, and APPOPENID, indicating respectively Alibaba Cloud application authentication, anonymous authentication, and third-party OpenID Connect account authentication.
   * 
   * @example
   * APP
   */
  authType?: string;
  /**
   * @remarks
   * The publishing time.
   * 
   * @example
   * 2022-07-13T16:00:33Z
   */
  deployedTime?: string;
  /**
   * @remarks
   * The API description.
   * 
   * @example
   * Lynk\\&Co Digital Mall OMS-UAT
   */
  description?: string;
  /**
   * @remarks
   * *   Specifies whether to set **DisableInternet** to **true** to limit API calls to within the VPC.
   * *   If you set **DisableInternet** to **false**, the limit is lifted. The default value is false when you create an API.
   * 
   * @example
   * true
   */
  disableInternet?: boolean;
  /**
   * @remarks
   * The sample error codes returned by the backend service.
   */
  errorCodeSamples?: DescribeApiDocResponseBodyErrorCodeSamples;
  /**
   * @remarks
   * The sample error response from the backend service.
   * 
   * @example
   * {"errorCode":"fail","errorMessage":"param invalid"}
   */
  failResultSample?: string;
  /**
   * @remarks
   * *   Specifies whether to set **ForceNonceCheck** to **true** to force the check of X-Ca-Nonce during the request. This is the unique identifier of the request and is generally identified by UUID. After receiving this parameter, API Gateway verifies the validity of this parameter. The same value can be used only once within 15 minutes. This helps prevent replay attacks.
   * *   If you set **ForceNonceCheck** to **false**, the check is not performed. The default value is false when you create an API.
   * 
   * @example
   * true
   */
  forceNonceCheck?: boolean;
  /**
   * @remarks
   * The ID of the API group.
   * 
   * @example
   * f51d08c5b7c84342905544ebaec26d35
   */
  groupId?: string;
  /**
   * @remarks
   * The name of the API group.
   * 
   * @example
   * Member Age Transaction Service
   */
  groupName?: string;
  /**
   * @remarks
   * The region ID of the API group.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The returned API frontend definition. It is an array consisting of RequestConfig data.
   */
  requestConfig?: DescribeApiDocResponseBodyRequestConfig;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * F253FB5F-9AE1-5DDA-99B5-46BE00A3719E
   */
  requestId?: string;
  /**
   * @remarks
   * The returned frontend input parameters in the API. It is an array consisting of RequestParameter data.
   */
  requestParameters?: DescribeApiDocResponseBodyRequestParameters;
  /**
   * @remarks
   * The sample response.
   * 
   * @example
   * {\\n  \\"status\\": 0,\\n  \\"data\\": {\\n    \\"count\\": 1,\\n    \\"list\\": [\\n      \\"352\\"\\n    ]\\n  },\\n  \\"message\\": \\"success\\"\\n}
   */
  resultSample?: string;
  /**
   * @remarks
   * The return value type.
   * 
   * @example
   * JSON
   */
  resultType?: string;
  /**
   * @remarks
   * The name of the runtime environment. Valid values:
   * 
   * *   **RELEASE**
   * *   **TEST**
   * 
   * @example
   * RELEASE
   */
  stageName?: string;
  /**
   * @remarks
   * Indicates whether the API is public. Valid values: PUBLIC and PRIVATE.
   * 
   * @example
   * PUBLIC
   */
  visibility?: string;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      apiName: 'ApiName',
      authType: 'AuthType',
      deployedTime: 'DeployedTime',
      description: 'Description',
      disableInternet: 'DisableInternet',
      errorCodeSamples: 'ErrorCodeSamples',
      failResultSample: 'FailResultSample',
      forceNonceCheck: 'ForceNonceCheck',
      groupId: 'GroupId',
      groupName: 'GroupName',
      regionId: 'RegionId',
      requestConfig: 'RequestConfig',
      requestId: 'RequestId',
      requestParameters: 'RequestParameters',
      resultSample: 'ResultSample',
      resultType: 'ResultType',
      stageName: 'StageName',
      visibility: 'Visibility',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'string',
      apiName: 'string',
      authType: 'string',
      deployedTime: 'string',
      description: 'string',
      disableInternet: 'boolean',
      errorCodeSamples: DescribeApiDocResponseBodyErrorCodeSamples,
      failResultSample: 'string',
      forceNonceCheck: 'boolean',
      groupId: 'string',
      groupName: 'string',
      regionId: 'string',
      requestConfig: DescribeApiDocResponseBodyRequestConfig,
      requestId: 'string',
      requestParameters: DescribeApiDocResponseBodyRequestParameters,
      resultSample: 'string',
      resultType: 'string',
      stageName: 'string',
      visibility: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiDocResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeApiDocResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeApiDocResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiGroupRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the API group. This ID is generated by the system and globally unique.
   * 
   * This parameter is required.
   * 
   * @example
   * 523e8dc7bbe04613b5b1d726c2a7889d
   */
  groupId?: string;
  securityToken?: string;
  /**
   * @remarks
   * The object tags that match the lifecycle rule. You can specify multiple tags.
   * 
   * @example
   * Key， Value
   */
  tag?: DescribeApiGroupRequestTag[];
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      securityToken: 'SecurityToken',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      securityToken: 'string',
      tag: { 'type': 'array', 'itemType': DescribeApiGroupRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiGroupResponseBody extends $tea.Model {
  /**
   * @remarks
   * The root path of the API.
   * 
   * @example
   * /qqq
   */
  basePath?: string;
  /**
   * @remarks
   * The billing status of the API group.
   * 
   * *   **NORMAL**: The API group is normal.
   * *   **LOCKED**: The API group is locked due to overdue payments.
   * 
   * @example
   * NORMAL
   */
  billingStatus?: string;
  /**
   * @remarks
   * The products on Alibaba Cloud Marketplace.
   * 
   * @example
   * false
   */
  cloudMarketCommodity?: boolean;
  /**
   * @remarks
   * The CloudMonitor application group.
   * 
   * @example
   * 217008423
   */
  cmsMonitorGroup?: string;
  /**
   * @remarks
   * The list of associated tags. Separate multiple tags with commas (,).
   * 
   * @example
   * depart:dep1
   */
  compatibleFlags?: string;
  /**
   * @remarks
   * The creation time (UTC) of the API group.
   * 
   * @example
   * 2016-08-01T06:53:02Z
   */
  createdTime?: string;
  /**
   * @remarks
   * The details about the custom domain name.
   */
  customDomains?: DescribeApiGroupResponseBodyCustomDomains;
  /**
   * @remarks
   * The custom trace configuration.
   * 
   * @example
   * {\\"parameterLocation\\":\\"HEADER\\",\\"parameterName\\":\\"traceId\\"}
   */
  customTraceConfig?: string;
  /**
   * @remarks
   * The list of custom configuration items.
   * 
   * @example
   * removeResponseServerHeader
   */
  customerConfigs?: string;
  /**
   * @remarks
   * The type of exclusive instance where the group is located
   * 
   * - VPC fusion type exclusive instance: vpc_connect
   * - Traditional type exclusive instance: normal
   * 
   * @example
   * normal
   */
  dedicatedInstanceType?: string;
  /**
   * @remarks
   * The default domain name.
   * 
   * @example
   * mkt.api.gaore.com
   */
  defaultDomain?: string;
  /**
   * @remarks
   * The description of the API group.
   * 
   * @example
   * New weather informations.
   */
  description?: string;
  /**
   * @remarks
   * Indicates whether access over the public second-level domain name is enabled. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * false
   */
  disableInnerDomain?: boolean;
  /**
   * @remarks
   * The ID of the API group. This ID is generated by the system and globally unique.
   * 
   * @example
   * 523e8dc7bbe04613b5b1d726c2a7889d
   */
  groupId?: string;
  /**
   * @remarks
   * The name of the group to which the API belongs.
   * 
   * @example
   * NewWeather
   */
  groupName?: string;
  /**
   * @remarks
   * The HTTPS policy.
   * 
   * @example
   * HTTPS2_TLS1_0
   */
  httpsPolicy?: string;
  /**
   * @remarks
   * The validity status of the API group. Valid values:
   * 
   * *   **NORMAL**: The API group is normal.
   * *   **LOCKED**: The API group is locked because it is not valid.
   * 
   * @example
   * NORMAL
   */
  illegalStatus?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * apigateway-cn-v6419k43xxxxx
   */
  instanceId?: string;
  /**
   * @remarks
   * The type of the instance.
   * 
   * *   CLASSIC_SHARED: shared instance that uses the classic network configuration
   * *   VPC_SHARED: shared instance that uses VPC
   * *   VPC_DEDICATED: dedicated instance that uses VPC
   * 
   * @example
   * VPC_SHARED
   */
  instanceType?: string;
  /**
   * @remarks
   * The IPv6 status.
   * 
   * @example
   * UNBIND
   */
  ipv6Status?: string;
  /**
   * @remarks
   * The reason for the failure of the group migration instance task. When the value of the MigrationStatus parameter is Failed, it is not empty.
   * 
   * @example
   * The current instance conflicts with the target instance.
   */
  migrationError?: string;
  /**
   * @remarks
   * Group migration instance task status
   * 
   * - Running
   * - Success
   * - Failed
   * 
   * @example
   * Fail
   */
  migrationStatus?: string;
  /**
   * @remarks
   * The last modification time (UTC) of the API group.
   * 
   * @example
   * 2016-08-01T06:54:32Z
   */
  modifiedTime?: string;
  /**
   * @remarks
   * Specifies whether to pass headers.
   * 
   * @example
   * eagleeye-rpcid,x-b3-traceid
   */
  passthroughHeaders?: string;
  /**
   * @remarks
   * The region to which the API group belongs.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 03442A3D-3B7D-434C-8A95-A5FEB989B519
   */
  requestId?: string;
  /**
   * @remarks
   * The runtime environment information.
   */
  stageItems?: DescribeApiGroupResponseBodyStageItems;
  /**
   * @remarks
   * The status of the API group.
   * 
   * *   **NORMAL**: The API group is normal.
   * *   **DELETE**: The API group is deleted.
   * 
   * @example
   * NORMAL
   */
  status?: string;
  /**
   * @remarks
   * The second-level domain name automatically assigned to the API group.
   * 
   * @example
   * 27d50c0f2e54b359919923d908bb015-cn-hangzhou.alicloudapi.com
   */
  subDomain?: string;
  /**
   * @remarks
   * The upper QPS limit of the API group. The default value is 500. You can increase the upper limit by submitting an application.
   * 
   * @example
   * 500
   */
  trafficLimit?: number;
  /**
   * @remarks
   * The user log settings.
   * 
   * @example
   * {\\"requestBody\\":true,\\"responseBody\\":true,\\"queryString\\":\\"test\\",\\"requestHeaders\\":\\"test\\",\\"responseHeaders\\":\\"test\\",\\"jwtClaims\\":\\"test\\"}
   */
  userLogConfig?: string;
  /**
   * @remarks
   * The VPC domain name.
   * 
   * @example
   * e4****7151954***acbd9f7****1058a-ap-southeast-1-vpc.alicloudapi.com
   */
  vpcDomain?: string;
  /**
   * @remarks
   * The VPC SLB domain name.
   * 
   * @example
   * 257e9d450e924d00b976b0ecfb7184c2-cn-beijing-intranet.alicloudapi.com
   */
  vpcSlbIntranetDomain?: string;
  static names(): { [key: string]: string } {
    return {
      basePath: 'BasePath',
      billingStatus: 'BillingStatus',
      cloudMarketCommodity: 'CloudMarketCommodity',
      cmsMonitorGroup: 'CmsMonitorGroup',
      compatibleFlags: 'CompatibleFlags',
      createdTime: 'CreatedTime',
      customDomains: 'CustomDomains',
      customTraceConfig: 'CustomTraceConfig',
      customerConfigs: 'CustomerConfigs',
      dedicatedInstanceType: 'DedicatedInstanceType',
      defaultDomain: 'DefaultDomain',
      description: 'Description',
      disableInnerDomain: 'DisableInnerDomain',
      groupId: 'GroupId',
      groupName: 'GroupName',
      httpsPolicy: 'HttpsPolicy',
      illegalStatus: 'IllegalStatus',
      instanceId: 'InstanceId',
      instanceType: 'InstanceType',
      ipv6Status: 'Ipv6Status',
      migrationError: 'MigrationError',
      migrationStatus: 'MigrationStatus',
      modifiedTime: 'ModifiedTime',
      passthroughHeaders: 'PassthroughHeaders',
      regionId: 'RegionId',
      requestId: 'RequestId',
      stageItems: 'StageItems',
      status: 'Status',
      subDomain: 'SubDomain',
      trafficLimit: 'TrafficLimit',
      userLogConfig: 'UserLogConfig',
      vpcDomain: 'VpcDomain',
      vpcSlbIntranetDomain: 'VpcSlbIntranetDomain',
    };
  }

  static types(): { [key: string]: any } {
    return {
      basePath: 'string',
      billingStatus: 'string',
      cloudMarketCommodity: 'boolean',
      cmsMonitorGroup: 'string',
      compatibleFlags: 'string',
      createdTime: 'string',
      customDomains: DescribeApiGroupResponseBodyCustomDomains,
      customTraceConfig: 'string',
      customerConfigs: 'string',
      dedicatedInstanceType: 'string',
      defaultDomain: 'string',
      description: 'string',
      disableInnerDomain: 'boolean',
      groupId: 'string',
      groupName: 'string',
      httpsPolicy: 'string',
      illegalStatus: 'string',
      instanceId: 'string',
      instanceType: 'string',
      ipv6Status: 'string',
      migrationError: 'string',
      migrationStatus: 'string',
      modifiedTime: 'string',
      passthroughHeaders: 'string',
      regionId: 'string',
      requestId: 'string',
      stageItems: DescribeApiGroupResponseBodyStageItems,
      status: 'string',
      subDomain: 'string',
      trafficLimit: 'number',
      userLogConfig: 'string',
      vpcDomain: 'string',
      vpcSlbIntranetDomain: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeApiGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeApiGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiGroupVpcWhitelistRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the API group.
   * 
   * This parameter is required.
   * 
   * @example
   * f6c64214dc27400196eef954575d60d3
   */
  groupId?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiGroupVpcWhitelistResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ016
   */
  requestId?: string;
  /**
   * @remarks
   * The ID of the VPC.
   * 
   * @example
   * vpc-bp11w979o2s9rcr962w25
   */
  vpcIds?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      vpcIds: 'VpcIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      vpcIds: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiGroupVpcWhitelistResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeApiGroupVpcWhitelistResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeApiGroupVpcWhitelistResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiGroupsRequest extends $tea.Model {
  /**
   * @remarks
   * Specifies whether to enable tag verification.
   * 
   * @example
   * true
   */
  enableTagAuth?: boolean;
  /**
   * @remarks
   * The ID of the API group. This ID is generated by the system and globally unique.
   * 
   * @example
   * be6d2abcc0dd4f749fc2d2edd6567164
   */
  groupId?: string;
  /**
   * @remarks
   * The keyword that can be specified in the name of the API group.
   * 
   * @example
   * Traffic
   */
  groupName?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * apigateway-cn-v6419k43245xx
   */
  instanceId?: string;
  /**
   * @remarks
   * The number of the page to return. Pages start from page 1. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Maximum value: 50. Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  securityToken?: string;
  /**
   * @remarks
   * The order. Valid values: asc and desc. Default value: desc.
   * 
   * *   asc: The API groups are displayed in ascending order of modification time.
   * *   desc: The API groups are displayed in descending order of modification time.
   * 
   * @example
   * desc
   */
  sort?: string;
  /**
   * @remarks
   * The list of tags.
   */
  tag?: DescribeApiGroupsRequestTag[];
  static names(): { [key: string]: string } {
    return {
      enableTagAuth: 'EnableTagAuth',
      groupId: 'GroupId',
      groupName: 'GroupName',
      instanceId: 'InstanceId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      securityToken: 'SecurityToken',
      sort: 'Sort',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enableTagAuth: 'boolean',
      groupId: 'string',
      groupName: 'string',
      instanceId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      securityToken: 'string',
      sort: 'string',
      tag: { 'type': 'array', 'itemType': DescribeApiGroupsRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiGroupsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned group set.
   */
  apiGroupAttributes?: DescribeApiGroupsResponseBodyApiGroupAttributes;
  /**
   * @remarks
   * The number of pages to return the results on.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * D6E46F10-F26C-4AA0-BB69-FE2743D9AE62
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of returned entries.
   * 
   * @example
   * 2
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      apiGroupAttributes: 'ApiGroupAttributes',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiGroupAttributes: DescribeApiGroupsResponseBodyApiGroupAttributes,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiGroupsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeApiGroupsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeApiGroupsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiHistoriesRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the API.
   * 
   * @example
   * c076144d7878437b8f82fb85890ce6a0
   */
  apiId?: string;
  /**
   * @remarks
   * The name of the API. The name is used for fuzzy match.
   * 
   * @example
   * weather
   */
  apiName?: string;
  /**
   * @remarks
   * The ID of the API group.
   * 
   * This parameter is required.
   * 
   * @example
   * 1084f9034c744137901057206b39d2b6
   */
  groupId?: string;
  /**
   * @remarks
   * The number of the page to return. Pages start from page 1. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Maximum value: 100. Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  securityToken?: string;
  /**
   * @remarks
   * The name of the runtime environment. Valid values:
   * 
   * *   **RELEASE**
   * *   **TEST**
   * 
   * @example
   * RELEASE
   */
  stageName?: string;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      apiName: 'ApiName',
      groupId: 'GroupId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      securityToken: 'SecurityToken',
      stageName: 'StageName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'string',
      apiName: 'string',
      groupId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      securityToken: 'string',
      stageName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiHistoriesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned API information. It is an array consisting of ApiHisItem data.
   */
  apiHisItems?: DescribeApiHistoriesResponseBodyApiHisItems;
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 3
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 15
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ003
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of returned entries.
   * 
   * @example
   * 32
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      apiHisItems: 'ApiHisItems',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiHisItems: DescribeApiHistoriesResponseBodyApiHisItems,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiHistoriesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeApiHistoriesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeApiHistoriesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiHistoryRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the API.
   * 
   * This parameter is required.
   * 
   * @example
   * dc6e17ee3120404c839bbcd7622ab6ed
   */
  apiId?: string;
  /**
   * @remarks
   * The ID of the API group. This ID is generated by the system and globally unique.
   * 
   * @example
   * 3013a55c0c44483f984d26df27120513
   */
  groupId?: string;
  /**
   * @remarks
   * Specifies the version number that you want to query.
   * 
   * This parameter is required.
   * 
   * @example
   * 20211122155403834
   */
  historyVersion?: string;
  securityToken?: string;
  /**
   * @remarks
   * The name of the runtime environment. Valid values:
   * 
   * *   **RELEASE**
   * *   **TEST**: the test environment
   * *   **PRE**: the pre-release environment
   * 
   * This parameter is required.
   * 
   * @example
   * RELEASE
   */
  stageName?: string;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      groupId: 'GroupId',
      historyVersion: 'HistoryVersion',
      securityToken: 'SecurityToken',
      stageName: 'StageName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'string',
      groupId: 'string',
      historyVersion: 'string',
      securityToken: 'string',
      stageName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiHistoryResponseBody extends $tea.Model {
  /**
   * @remarks
   * If **AuthType** is set to **APP**, this value must be passed to specify the signature algorithm. If you do not specify a value, HmacSHA256 is used by default. Valid values:
   * 
   * *   HmacSHA256
   * *   HmacSHA1,HmacSHA256
   * 
   * @example
   * HmacSHA256
   */
  allowSignatureMethod?: string;
  /**
   * @remarks
   * The ID of the API.
   * 
   * @example
   * bebf996e4b3d445d83078094b72b0d91
   */
  apiId?: string;
  /**
   * @remarks
   * The name of the API.
   * 
   * @example
   * Backstage_MengMeng Broadcast_Seven Niu Cloud Push Stream Callback_Official
   */
  apiName?: string;
  /**
   * @remarks
   * The AppCode authentication type supported. Valid values:
   * 
   * *   DEFAULT: supported after being made available in Alibaba Cloud Marketplace
   * *   DISABLE: not supported.
   * *   HEADER : supported only in the Header parameter
   * *   HEADER_QUERY : supported in the Header or Query parameter.
   * 
   * @example
   * HEADER
   */
  appCodeAuthType?: string;
  /**
   * @remarks
   * The security authentication method of the API. Valid values:
   * 
   * *   **APP: Only authorized applications can call the API.**
   * 
   * *   **ANONYMOUS: The API can be anonymously called. In this mode, you must take note of the following rules:**
   * 
   *     *   All users who have obtained the API service information can call this API. API Gateway does not authenticate callers and cannot set user-specific throttling policies. If you make this API public, set API-specific throttling policies.
   * 
   * @example
   * APP
   */
  authType?: string;
  /**
   * @remarks
   * Backend configurations
   */
  backendConfig?: DescribeApiHistoryResponseBodyBackendConfig;
  /**
   * @remarks
   * Specifies whether to enable backend services.
   * 
   * @example
   * true
   */
  backendEnable?: boolean;
  /**
   * @remarks
   * The constant parameters.
   */
  constantParameters?: DescribeApiHistoryResponseBodyConstantParameters;
  /**
   * @remarks
   * The custom system parameters.
   */
  customSystemParameters?: DescribeApiHistoryResponseBodyCustomSystemParameters;
  /**
   * @remarks
   * The publishing time (UTC) of the API.
   * 
   * @example
   * 2021-06-1113:57:38
   */
  deployedTime?: string;
  /**
   * @remarks
   * The description of the API.
   * 
   * @example
   * Queries weather based on the region name
   */
  description?: string;
  /**
   * @remarks
   * *   Specifies whether to set **DisableInternet** to **true** to limit API calls to within the VPC.
   * *   If you set **DisableInternet** to **false**, the limit is lifted. The default value is false when you create an API.
   * 
   * @example
   * true
   */
  disableInternet?: boolean;
  /**
   * @remarks
   * The sample error codes returned by the backend service.
   * 
   * For more information, see [ErrorCodeSample](https://help.aliyun.com/document_detail/44392.html).
   */
  errorCodeSamples?: DescribeApiHistoryResponseBodyErrorCodeSamples;
  /**
   * @remarks
   * The sample error response from the backend service.
   * 
   * @example
   * {"errorCode":"fail","errorMessage":"param invalid"}
   */
  failResultSample?: string;
  /**
   * @remarks
   * *   Specifies whether to set **ForceNonceCheck** to **true** to force the check of X-Ca-Nonce during the request. This is the unique identifier of the request and is generally identified by UUID. After receiving this parameter, API Gateway verifies the validity of this parameter. The same value can be used only once within 15 minutes. This helps prevent replay attacks.
   * *   If you set **ForceNonceCheck** to **false**, the check is not performed. The default value is false when you create an API.
   * 
   * @example
   * true
   */
  forceNonceCheck?: boolean;
  /**
   * @remarks
   * The ID of the API group.
   * 
   * @example
   * cfb6ef799bf54fffabb0f02019ad2581
   */
  groupId?: string;
  /**
   * @remarks
   * The name of the API group.
   * 
   * @example
   * dev_api
   */
  groupName?: string;
  /**
   * @remarks
   * The historical version number.
   * 
   * @example
   * 20211022134156663
   */
  historyVersion?: string;
  /**
   * @remarks
   * The configuration items of the third-party OpenID Connect authentication method.
   */
  openIdConnectConfig?: DescribeApiHistoryResponseBodyOpenIdConnectConfig;
  /**
   * @remarks
   * The region where the API is located.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The configuration items of API requests sent by the consumer to API Gateway.
   * 
   * For more information, see [RequestConfig](https://help.aliyun.com/document_detail/43985.html).
   */
  requestConfig?: DescribeApiHistoryResponseBodyRequestConfig;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 6C87A26A-6A18-4B8E-8099-705278381A2C
   */
  requestId?: string;
  /**
   * @remarks
   * The parameters of API requests sent by the consumer to API Gateway.
   * 
   * For more information, see [RequestParameter](https://help.aliyun.com/document_detail/43986.html).
   */
  requestParameters?: DescribeApiHistoryResponseBodyRequestParameters;
  /**
   * @remarks
   * The return description of the API.
   * 
   * @example
   * {}
   */
  resultBodyModel?: string;
  /**
   * @remarks
   * The return description of the API.
   */
  resultDescriptions?: DescribeApiHistoryResponseBodyResultDescriptions;
  /**
   * @remarks
   * The sample response.
   * 
   * @example
   * {\\n  \\"status\\": 0,\\n  \\"data\\": {\\n    \\"count\\": 1,\\n    \\"list\\": [\\n      \\"352\\"\\n    ]\\n  },\\n  \\"message\\": \\"success\\"\\n}
   */
  resultSample?: string;
  /**
   * @remarks
   * The type of the data to return.
   * 
   * @example
   * JSON
   */
  resultType?: string;
  /**
   * @remarks
   * The information about a backend service call.
   */
  serviceConfig?: DescribeApiHistoryResponseBodyServiceConfig;
  /**
   * @remarks
   * The parameters of API requests sent by API Gateway to the backend service.
   * 
   * For more information, see [ServiceParameter](https://help.aliyun.com/document_detail/43988.html).
   */
  serviceParameters?: DescribeApiHistoryResponseBodyServiceParameters;
  /**
   * @remarks
   * The mappings between parameters of requests sent by the consumer to API Gateway and parameters of requests sent by API Gateway to the backend service.
   * 
   * For more information, see [ServiceParameterMap](https://help.aliyun.com/document_detail/43989.html).
   */
  serviceParametersMap?: DescribeApiHistoryResponseBodyServiceParametersMap;
  /**
   * @remarks
   * The environment in which the API is requested. Valid values:
   * 
   * *   **RELEASE**: the production environment
   * *   **PRE**: the pre-release environment
   * *   **TEST**: the test environment
   * 
   * @example
   * RELEASE
   */
  stageName?: string;
  /**
   * @remarks
   * The invocation status of the API.
   * 
   * @example
   * 200
   */
  status?: string;
  /**
   * @remarks
   * The common parameters of the APIs, in JSON format.
   */
  systemParameters?: DescribeApiHistoryResponseBodySystemParameters;
  /**
   * @remarks
   * Specifies whether to make the API public. Valid values:
   * 
   * *   **PUBLIC**: Make the API public. If you set this parameter to PUBLIC, this API is displayed on the APIs page for all users after the API is published to the production environment.
   * *   **PRIVATE**: Make the API private. Private APIs are not displayed in the Alibaba Cloud Marketplace after the API group to which they belong is made available.
   * 
   * @example
   * PUBLIC
   */
  visibility?: string;
  /**
   * @remarks
   * The type of the two-way communication API. Valid values:
   * 
   * *   **COMMON**: general APIs
   * *   **REGISTER**: registered APIs
   * *   **UNREGISTER**: unregistered APIs
   * *   **NOTIFY**: downstream notification
   * 
   * @example
   * COMMON
   */
  webSocketApiType?: string;
  static names(): { [key: string]: string } {
    return {
      allowSignatureMethod: 'AllowSignatureMethod',
      apiId: 'ApiId',
      apiName: 'ApiName',
      appCodeAuthType: 'AppCodeAuthType',
      authType: 'AuthType',
      backendConfig: 'BackendConfig',
      backendEnable: 'BackendEnable',
      constantParameters: 'ConstantParameters',
      customSystemParameters: 'CustomSystemParameters',
      deployedTime: 'DeployedTime',
      description: 'Description',
      disableInternet: 'DisableInternet',
      errorCodeSamples: 'ErrorCodeSamples',
      failResultSample: 'FailResultSample',
      forceNonceCheck: 'ForceNonceCheck',
      groupId: 'GroupId',
      groupName: 'GroupName',
      historyVersion: 'HistoryVersion',
      openIdConnectConfig: 'OpenIdConnectConfig',
      regionId: 'RegionId',
      requestConfig: 'RequestConfig',
      requestId: 'RequestId',
      requestParameters: 'RequestParameters',
      resultBodyModel: 'ResultBodyModel',
      resultDescriptions: 'ResultDescriptions',
      resultSample: 'ResultSample',
      resultType: 'ResultType',
      serviceConfig: 'ServiceConfig',
      serviceParameters: 'ServiceParameters',
      serviceParametersMap: 'ServiceParametersMap',
      stageName: 'StageName',
      status: 'Status',
      systemParameters: 'SystemParameters',
      visibility: 'Visibility',
      webSocketApiType: 'WebSocketApiType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allowSignatureMethod: 'string',
      apiId: 'string',
      apiName: 'string',
      appCodeAuthType: 'string',
      authType: 'string',
      backendConfig: DescribeApiHistoryResponseBodyBackendConfig,
      backendEnable: 'boolean',
      constantParameters: DescribeApiHistoryResponseBodyConstantParameters,
      customSystemParameters: DescribeApiHistoryResponseBodyCustomSystemParameters,
      deployedTime: 'string',
      description: 'string',
      disableInternet: 'boolean',
      errorCodeSamples: DescribeApiHistoryResponseBodyErrorCodeSamples,
      failResultSample: 'string',
      forceNonceCheck: 'boolean',
      groupId: 'string',
      groupName: 'string',
      historyVersion: 'string',
      openIdConnectConfig: DescribeApiHistoryResponseBodyOpenIdConnectConfig,
      regionId: 'string',
      requestConfig: DescribeApiHistoryResponseBodyRequestConfig,
      requestId: 'string',
      requestParameters: DescribeApiHistoryResponseBodyRequestParameters,
      resultBodyModel: 'string',
      resultDescriptions: DescribeApiHistoryResponseBodyResultDescriptions,
      resultSample: 'string',
      resultType: 'string',
      serviceConfig: DescribeApiHistoryResponseBodyServiceConfig,
      serviceParameters: DescribeApiHistoryResponseBodyServiceParameters,
      serviceParametersMap: DescribeApiHistoryResponseBodyServiceParametersMap,
      stageName: 'string',
      status: 'string',
      systemParameters: DescribeApiHistoryResponseBodySystemParameters,
      visibility: 'string',
      webSocketApiType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiHistoryResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeApiHistoryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeApiHistoryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiIpControlsRequest extends $tea.Model {
  /**
   * @remarks
   * The IDs of APIs. Separate multiple API IDs with commas (,). A maximum of 100 API IDs can be entered.
   * 
   * @example
   * 123,234
   */
  apiIds?: string;
  /**
   * @remarks
   * The ID of the API group.
   * 
   * This parameter is required.
   * 
   * @example
   * 0009db9c828549768a200320714b8930
   */
  groupId?: string;
  /**
   * @remarks
   * The number of the page to return. Pages start from page 1. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Maximum value: 100. Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  securityToken?: string;
  /**
   * @remarks
   * The runtime environment. Valid values:
   * 
   * *   **RELEASE**
   * *   **TEST**
   * 
   * This parameter is required.
   * 
   * @example
   * test
   */
  stageName?: string;
  static names(): { [key: string]: string } {
    return {
      apiIds: 'ApiIds',
      groupId: 'GroupId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      securityToken: 'SecurityToken',
      stageName: 'StageName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiIds: 'string',
      groupId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      securityToken: 'string',
      stageName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiIpControlsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the ACLs. The information is an array of ApiIpControlItem data.
   */
  apiIpControls?: DescribeApiIpControlsResponseBodyApiIpControls;
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ004
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of returned entries.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      apiIpControls: 'ApiIpControls',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiIpControls: DescribeApiIpControlsResponseBodyApiIpControls,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiIpControlsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeApiIpControlsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeApiIpControlsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiLatencyDataRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the API.
   * 
   * This parameter is required.
   * 
   * @example
   * d6f679aeb3be4b91b3688e887ca1fe16
   */
  apiId?: string;
  /**
   * @remarks
   * The end time in UTC. Format: YYYY-MM-DDThh:mm:ssZ
   * 
   * This parameter is required.
   * 
   * @example
   * 2016-07-23T09:28:48Z
   */
  endTime?: string;
  /**
   * @remarks
   * The ID of the API group.
   * 
   * @example
   * 63be9002440b4778a61122f14c2b2bbb
   */
  groupId?: string;
  securityToken?: string;
  /**
   * @remarks
   * The environment. Valid values:
   * 
   * *   **RELEASE**
   * *   **PRE**: the pre-release environment
   * *   **TEST**
   * 
   * @example
   * RELEASE
   */
  stageName?: string;
  /**
   * @remarks
   * The start time in UTC. Format: YYYY-MM-DDThh:mm:ssZ
   * 
   * This parameter is required.
   * 
   * @example
   * 2016-07-23T08:28:48Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      endTime: 'EndTime',
      groupId: 'GroupId',
      securityToken: 'SecurityToken',
      stageName: 'StageName',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'string',
      endTime: 'string',
      groupId: 'string',
      securityToken: 'string',
      stageName: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiLatencyDataResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned information about API call latency. It is an array consisting of MonitorItem data.
   */
  callLatencys?: DescribeApiLatencyDataResponseBodyCallLatencys;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ001
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      callLatencys: 'CallLatencys',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      callLatencys: DescribeApiLatencyDataResponseBodyCallLatencys,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiLatencyDataResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeApiLatencyDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeApiLatencyDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiMarketAttributesRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the API.
   * 
   * This parameter is required.
   * 
   * @example
   * 1f9b5e9ba80943099cac52e040b7e160
   */
  apiId?: string;
  /**
   * @remarks
   * The ID of the API group.
   * 
   * This parameter is required.
   * 
   * @example
   * b693252f3f19445e9a01dac177c4454c
   */
  groupId?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      groupId: 'GroupId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'string',
      groupId: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiMarketAttributesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the API.
   * 
   * @example
   * 6318cd8f6a304cac9318dea8d9a78f7a
   */
  apiId?: string;
  /**
   * @remarks
   * The billing method used by the Alibaba Cloud Marketplace.
   * 
   * @example
   * PREPAID_BY_USAGE
   */
  marketChargingMode?: string;
  /**
   * @remarks
   * Indicates whether fees are charged.
   * 
   * @example
   * true
   */
  needCharging?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 545D4E52-4F77-5EC4-BB7E-7344CEC7B5E6
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      marketChargingMode: 'MarketChargingMode',
      needCharging: 'NeedCharging',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'string',
      marketChargingMode: 'string',
      needCharging: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiMarketAttributesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeApiMarketAttributesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeApiMarketAttributesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiProductApisRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the API product.
   * 
   * This parameter is required.
   * 
   * @example
   * 117b7a64a8b3f064eaa4a47ac62aac5e
   */
  apiProductId?: string;
  /**
   * @remarks
   * The number of the page to return. Pages start from page 1. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      apiProductId: 'ApiProductId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiProductId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiProductApisResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the returned APIs.
   */
  apiInfoList?: DescribeApiProductApisResponseBodyApiInfoList;
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 03442A3D-3B7D-434C-8A95-A5FEB989B519
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of returned entries.
   * 
   * @example
   * 4
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      apiInfoList: 'ApiInfoList',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiInfoList: DescribeApiProductApisResponseBodyApiInfoList,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiProductApisResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeApiProductApisResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeApiProductApisResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiProductsByAppRequest extends $tea.Model {
  /**
   * @remarks
   * The application ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 110962435
   */
  appId?: number;
  /**
   * @remarks
   * The number of the page to return. Pages start from page 1. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiProductsByAppResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about API products.
   */
  apiProductInfoList?: DescribeApiProductsByAppResponseBodyApiProductInfoList;
  /**
   * @remarks
   * The page number. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0B805201-AF4C-5788-AC9E-C3EEC83DC82A
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of returned entries.
   * 
   * @example
   * 4
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      apiProductInfoList: 'ApiProductInfoList',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiProductInfoList: DescribeApiProductsByAppResponseBodyApiProductInfoList,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiProductsByAppResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeApiProductsByAppResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeApiProductsByAppResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiQpsDataRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the API.
   * 
   * This parameter is required.
   * 
   * @example
   * d6f679aeb3be4b91b3688e887ca1fe16
   */
  apiId?: string;
  /**
   * @remarks
   * The end time in UTC. Format: YYYY-MM-DDThh:mm:ssZ
   * 
   * This parameter is required.
   * 
   * @example
   * 2016-07-23T09:28:48Z
   */
  endTime?: string;
  /**
   * @remarks
   * The ID of the API group.
   * 
   * @example
   * 63be9002440b4778a61122f14c2b2bbb
   */
  groupId?: string;
  securityToken?: string;
  /**
   * @remarks
   * The environment. Valid values:
   * 
   * *   **RELEASE**
   * *   **PRE**: the pre-release environment
   * *   **TEST**
   * 
   * @example
   * RELEASE
   */
  stageName?: string;
  /**
   * @remarks
   * The start time in UTC. Format: YYYY-MM-DDThh:mm:ssZ
   * 
   * This parameter is required.
   * 
   * @example
   * 2016-07-23T08:28:48Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      endTime: 'EndTime',
      groupId: 'GroupId',
      securityToken: 'SecurityToken',
      stageName: 'StageName',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'string',
      endTime: 'string',
      groupId: 'string',
      securityToken: 'string',
      stageName: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiQpsDataResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned information about failed API calls. It is an array consisting of MonitorItem data.
   */
  callFails?: DescribeApiQpsDataResponseBodyCallFails;
  /**
   * @remarks
   * The returned information about successful API calls. It is an array consisting of MonitorItem data.
   */
  callSuccesses?: DescribeApiQpsDataResponseBodyCallSuccesses;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ001
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      callFails: 'CallFails',
      callSuccesses: 'CallSuccesses',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      callFails: DescribeApiQpsDataResponseBodyCallFails,
      callSuccesses: DescribeApiQpsDataResponseBodyCallSuccesses,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiQpsDataResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeApiQpsDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeApiQpsDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiSignaturesRequest extends $tea.Model {
  /**
   * @remarks
   * The IDs of the APIs that you want to query. Separate multiple API IDs with commas (,). A maximum of 100 API IDs can be entered.
   * 
   * @example
   * 123
   */
  apiIds?: string;
  /**
   * @remarks
   * The ID of the API group.
   * 
   * This parameter is required.
   * 
   * @example
   * 0009db9c828549768a200320714b8930
   */
  groupId?: string;
  /**
   * @remarks
   * The number of the page to return. Pages start from page 1. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Maximum value: 100. Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  securityToken?: string;
  /**
   * @remarks
   * The runtime environment. Valid values:
   * 
   * *   **RELEASE**
   * *   **TEST**
   * 
   * This parameter is required.
   * 
   * @example
   * TEST
   */
  stageName?: string;
  static names(): { [key: string]: string } {
    return {
      apiIds: 'ApiIds',
      groupId: 'GroupId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      securityToken: 'SecurityToken',
      stageName: 'StageName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiIds: 'string',
      groupId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      securityToken: 'string',
      stageName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiSignaturesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned signature key information. It is an array consisting of ApiSignatureItem data.
   */
  apiSignatures?: DescribeApiSignaturesResponseBodyApiSignatures;
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ004
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of returned entries.
   * 
   * @example
   * 20
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      apiSignatures: 'ApiSignatures',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiSignatures: DescribeApiSignaturesResponseBodyApiSignatures,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiSignaturesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeApiSignaturesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeApiSignaturesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiTrafficControlsRequest extends $tea.Model {
  /**
   * @remarks
   * The IDs of APIs that you want to query. Separate multiple API IDs with commas (,). A maximum of 100 API IDs can be entered.
   * 
   * @example
   * 123,234
   */
  apiIds?: string;
  /**
   * @remarks
   * The ID of the API group that you want to query.
   * 
   * This parameter is required.
   * 
   * @example
   * 0009db9c828549768a200320714b8930
   */
  groupId?: string;
  /**
   * @remarks
   * The number of the page to return. Pages start from page 1. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Maximum value: 100. Default value: 10.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  securityToken?: string;
  /**
   * @remarks
   * The runtime environment of the API. Valid values:
   * 
   * *   **RELEASE**
   * *   **TEST**: the test environment
   * 
   * This parameter is required.
   * 
   * @example
   * RELEASE
   */
  stageName?: string;
  static names(): { [key: string]: string } {
    return {
      apiIds: 'ApiIds',
      groupId: 'GroupId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      securityToken: 'SecurityToken',
      stageName: 'StageName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiIds: 'string',
      groupId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      securityToken: 'string',
      stageName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiTrafficControlsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned throttling policy information. It is an array consisting of ApiTrafficControlItem data.
   */
  apiTrafficControls?: DescribeApiTrafficControlsResponseBodyApiTrafficControls;
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ004
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of returned entries.
   * 
   * @example
   * 20
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      apiTrafficControls: 'ApiTrafficControls',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiTrafficControls: DescribeApiTrafficControlsResponseBodyApiTrafficControls,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiTrafficControlsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeApiTrafficControlsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeApiTrafficControlsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiTrafficDataRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the API.
   * 
   * This parameter is required.
   * 
   * @example
   * d6f679aeb3be4b91b3688e887ca1fe16
   */
  apiId?: string;
  /**
   * @remarks
   * The end time in UTC. Format: YYYY-MM-DDThh:mm:ssZ
   * 
   * This parameter is required.
   * 
   * @example
   * 2016-07-23T09:28:48Z
   */
  endTime?: string;
  /**
   * @remarks
   * The ID of the API group.
   * 
   * @example
   * 63be9002440b4778a61122f14c2b2bbb
   */
  groupId?: string;
  securityToken?: string;
  /**
   * @remarks
   * The environment. Valid values:
   * 
   * *   **RELEASE**
   * *   **TEST**: the test environment
   * *   PRE: the pre-release environment
   * 
   * @example
   * RELEASE
   */
  stageName?: string;
  /**
   * @remarks
   * The start time in UTC. Format: YYYY-MM-DDThh:mm:ssZ
   * 
   * This parameter is required.
   * 
   * @example
   * 2016-07-23T08:28:48Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      endTime: 'EndTime',
      groupId: 'GroupId',
      securityToken: 'SecurityToken',
      stageName: 'StageName',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'string',
      endTime: 'string',
      groupId: 'string',
      securityToken: 'string',
      stageName: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiTrafficDataResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned downlink traffic data of API calls. It is an array consisting of MonitorItem data.
   */
  callDownloads?: DescribeApiTrafficDataResponseBodyCallDownloads;
  /**
   * @remarks
   * The returned uplink traffic data of API calls. It is an array consisting of MonitorItem data.
   */
  callUploads?: DescribeApiTrafficDataResponseBodyCallUploads;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ001
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      callDownloads: 'CallDownloads',
      callUploads: 'CallUploads',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      callDownloads: DescribeApiTrafficDataResponseBodyCallDownloads,
      callUploads: DescribeApiTrafficDataResponseBodyCallUploads,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiTrafficDataResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeApiTrafficDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeApiTrafficDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApisRequest extends $tea.Model {
  /**
   * @remarks
   * The API ID.
   * 
   * @example
   * f68c19ee3bd1478fb58aa05ce8ae9b5a
   */
  apiId?: string;
  /**
   * @remarks
   * The HTTP method of the API request.
   * 
   * @example
   * GET
   */
  apiMethod?: string;
  /**
   * @remarks
   * The API name. The name is used for fuzzy match.
   * 
   * @example
   * weather
   */
  apiName?: string;
  /**
   * @remarks
   * The request path of the API.
   * 
   * @example
   * /illegal/query
   */
  apiPath?: string;
  /**
   * @remarks
   * The category ID.
   * 
   * @example
   * 1553414085247362
   */
  catalogId?: string;
  /**
   * @remarks
   * Specifies whether to enable tag verification.
   * 
   * @example
   * true
   */
  enableTagAuth?: boolean;
  /**
   * @remarks
   * The API group ID.
   * 
   * @example
   * c4a4d2de657548a2bd485d5d4df42b4a
   */
  groupId?: string;
  /**
   * @remarks
   * The number of the page to return. Pages start from page 1. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  securityToken?: string;
  /**
   * @remarks
   * The environment in which you want to perform this operation. Valid values:
   * 
   * *   **RELEASE**: the production environment
   * *   **PRE**: the staging environment
   * *   **TEST**: the test environment
   * 
   * @example
   * RELEASE
   */
  stageName?: string;
  /**
   * @remarks
   * The tags of objects that match the rule.
   * 
   * @example
   * Key， Value
   */
  tag?: DescribeApisRequestTag[];
  /**
   * @remarks
   * Specifies whether to filter unpublished APIs.
   * 
   * @example
   * true
   */
  unDeployed?: boolean;
  /**
   * @remarks
   * Specifies whether the API is public. Valid values:
   * 
   * *   **PUBLIC**: The API is public. If you publish the definition of a public API to the production environment, the definition is displayed on the APIs page for all users.
   * *   **PRIVATE**: The API is private. If you publish an API group that contains a private API in Alibaba Cloud Marketplace, the API is not displayed in Alibaba Cloud Marketplace.
   * 
   * @example
   * PUBLIC
   */
  visibility?: string;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      apiMethod: 'ApiMethod',
      apiName: 'ApiName',
      apiPath: 'ApiPath',
      catalogId: 'CatalogId',
      enableTagAuth: 'EnableTagAuth',
      groupId: 'GroupId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      securityToken: 'SecurityToken',
      stageName: 'StageName',
      tag: 'Tag',
      unDeployed: 'UnDeployed',
      visibility: 'Visibility',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'string',
      apiMethod: 'string',
      apiName: 'string',
      apiPath: 'string',
      catalogId: 'string',
      enableTagAuth: 'boolean',
      groupId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      securityToken: 'string',
      stageName: 'string',
      tag: { 'type': 'array', 'itemType': DescribeApisRequestTag },
      unDeployed: 'boolean',
      visibility: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApisResponseBody extends $tea.Model {
  /**
   * @remarks
   * The queried API definitions.
   */
  apiSummarys?: DescribeApisResponseBodyApiSummarys;
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 3
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 15
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ002
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of returned entries.
   * 
   * @example
   * 32
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      apiSummarys: 'ApiSummarys',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiSummarys: DescribeApisResponseBodyApiSummarys,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApisResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeApisResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeApisResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApisByAppRequest extends $tea.Model {
  /**
   * @example
   * getPersonInfo
   */
  apiName?: string;
  /**
   * @example
   * b19240592b1b4e74961fb8438ed7550c
   */
  apiUid?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 333486644
   */
  appId?: number;
  /**
   * @example
   * test
   */
  description?: string;
  /**
   * @example
   * POST
   */
  method?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * /tt
   */
  path?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      apiName: 'ApiName',
      apiUid: 'ApiUid',
      appId: 'AppId',
      description: 'Description',
      method: 'Method',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      path: 'Path',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiName: 'string',
      apiUid: 'string',
      appId: 'number',
      description: 'string',
      method: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      path: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApisByAppResponseBody extends $tea.Model {
  /**
   * @remarks
   * The API authorizations.
   */
  appApiRelationInfos?: DescribeApisByAppResponseBodyAppApiRelationInfos;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ015
   */
  requestId?: string;
  /**
   * @example
   * 2
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      appApiRelationInfos: 'AppApiRelationInfos',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appApiRelationInfos: DescribeApisByAppResponseBodyAppApiRelationInfos,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApisByAppResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeApisByAppResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeApisByAppResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApisByBackendRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the backend service.
   * 
   * This parameter is required.
   * 
   * @example
   * 4ac69b7a17524781b275ed4c5eb25c54
   */
  backendId?: string;
  /**
   * @remarks
   * The number of the current page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  securityToken?: string;
  /**
   * @remarks
   * The environment to which the API is published. Valid values:
   * 
   * *   **RELEASE**
   * *   **PRE**
   * *   **TEST**
   * 
   * If you do not specify this parameter, APIs in the draft state are returned.
   * 
   * @example
   * PRE
   */
  stageName?: string;
  static names(): { [key: string]: string } {
    return {
      backendId: 'BackendId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      securityToken: 'SecurityToken',
      stageName: 'StageName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      backendId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      securityToken: 'string',
      stageName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApisByBackendResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the returned API list.
   */
  apiInfoList?: DescribeApisByBackendResponseBodyApiInfoList;
  /**
   * @remarks
   * The number of the current page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned on each page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CEB6EC62-B6C7-5082-A45A-45A204724AC2
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      apiInfoList: 'ApiInfoList',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiInfoList: DescribeApisByBackendResponseBodyApiInfoList,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApisByBackendResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeApisByBackendResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeApisByBackendResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApisByIpControlRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the ACL.
   * 
   * This parameter is required.
   * 
   * @example
   * dd05f1c54d6749eda95f9fa6d491449a
   */
  ipControlId?: string;
  /**
   * @remarks
   * The number of the page to return. Pages start from page 1. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Maximum value: 100. Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      ipControlId: 'IpControlId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ipControlId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApisByIpControlResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned API information. It is an array of ApiInfo data.
   */
  apiInfos?: DescribeApisByIpControlResponseBodyApiInfos;
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ004
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of returned entries.
   * 
   * @example
   * 20
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      apiInfos: 'ApiInfos',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiInfos: DescribeApisByIpControlResponseBodyApiInfos,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApisByIpControlResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeApisByIpControlResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeApisByIpControlResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApisBySignatureRequest extends $tea.Model {
  /**
   * @remarks
   * The number of the page to return. Pages start from page 1. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Maximum value: 100. Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  securityToken?: string;
  /**
   * @remarks
   * The ID of the signature key.
   * 
   * This parameter is required.
   * 
   * @example
   * dd05f1c54d6749eda95f9fa6d491449a
   */
  signatureId?: string;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      securityToken: 'SecurityToken',
      signatureId: 'SignatureId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      securityToken: 'string',
      signatureId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApisBySignatureResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned API information. It is an array consisting of ApiInfo data.
   */
  apiInfos?: DescribeApisBySignatureResponseBodyApiInfos;
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ004
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of returned entries.
   * 
   * @example
   * 20
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      apiInfos: 'ApiInfos',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiInfos: DescribeApisBySignatureResponseBodyApiInfos,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApisBySignatureResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeApisBySignatureResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeApisBySignatureResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApisByTrafficControlRequest extends $tea.Model {
  /**
   * @remarks
   * The number of the page to return. Pages start from page 1. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Maximum value: 100. Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The security token included in the WebSocket request header. The system uses this token to authenticate the request.
   * 
   * @example
   * 9abe3317-3e22-4957-ab9f-dd893d0ac956
   */
  securityToken?: string;
  /**
   * @remarks
   * The ID of the throttling policy that you want to query.
   * 
   * This parameter is required.
   * 
   * @example
   * dd05f1c54d6749eda95f9fa6d491449a
   */
  trafficControlId?: string;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      securityToken: 'SecurityToken',
      trafficControlId: 'TrafficControlId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      securityToken: 'string',
      trafficControlId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApisByTrafficControlResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned API information. It is an array consisting of ApiInfo data.
   */
  apiInfos?: DescribeApisByTrafficControlResponseBodyApiInfos;
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ004
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of returned entries.
   * 
   * @example
   * 20
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      apiInfos: 'ApiInfos',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiInfos: DescribeApisByTrafficControlResponseBodyApiInfos,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApisByTrafficControlResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeApisByTrafficControlResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeApisByTrafficControlResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApisByVpcAccessRequest extends $tea.Model {
  /**
   * @remarks
   * The page number. Pages start from page 1. Default value: 1.
   * 
   * @example
   * 2
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Valid values: 1 to 100. Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  securityToken?: string;
  /**
   * @remarks
   * The name of the VPC access authorization.
   * 
   * @example
   * lynkco-iov-uat
   */
  vpcName?: string;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      securityToken: 'SecurityToken',
      vpcName: 'VpcName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      securityToken: 'string',
      vpcName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApisByVpcAccessResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned API information. It is an array consisting of ApiInfo data.
   */
  apiVpcAccessInfos?: DescribeApisByVpcAccessResponseBodyApiVpcAccessInfos;
  /**
   * @remarks
   * The page number. Pages start from page 1. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Valid values: 1 to 100. Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 4E707B25-5119-5ACF-9D26-7D2A2762F05C
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 12
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      apiVpcAccessInfos: 'ApiVpcAccessInfos',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiVpcAccessInfos: DescribeApisByVpcAccessResponseBodyApiVpcAccessInfos,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApisByVpcAccessResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeApisByVpcAccessResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeApisByVpcAccessResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApisWithStageNameIntegratedByAppRequest extends $tea.Model {
  /**
   * @remarks
   * The API name.
   * 
   * @example
   * ApiName
   */
  apiName?: string;
  /**
   * @remarks
   * The API ID.
   * 
   * @example
   * b19240592b1b4e74961fb8438ed7550c
   */
  apiUid?: string;
  /**
   * @remarks
   * The application ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 2386789
   */
  appId?: number;
  /**
   * @remarks
   * The API description. The description can be up to 200 characters in length.
   * 
   * @example
   * test
   */
  description?: string;
  /**
   * @remarks
   * The request HTTP method of the API.
   * 
   * @example
   * POST
   */
  method?: string;
  /**
   * @remarks
   * The page number of the page to return.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The request path of the API.
   * 
   * @example
   * /tt
   */
  path?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      apiName: 'ApiName',
      apiUid: 'ApiUid',
      appId: 'AppId',
      description: 'Description',
      method: 'Method',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      path: 'Path',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiName: 'string',
      apiUid: 'string',
      appId: 'number',
      description: 'string',
      method: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      path: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApisWithStageNameIntegratedByAppResponseBody extends $tea.Model {
  /**
   * @remarks
   * The authorization information of the API.
   */
  appApiRelationInfos?: DescribeApisWithStageNameIntegratedByAppResponseBodyAppApiRelationInfos;
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 6C87A26A-6A18-4B8E-8099-705278381A2C
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 2
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      appApiRelationInfos: 'AppApiRelationInfos',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appApiRelationInfos: DescribeApisWithStageNameIntegratedByAppResponseBodyAppApiRelationInfos,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApisWithStageNameIntegratedByAppResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeApisWithStageNameIntegratedByAppResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeApisWithStageNameIntegratedByAppResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAppRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the app. The ID is generated by the system and globally unique.
   * 
   * @example
   * 110843374
   */
  appId?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAppResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the app.
   * 
   * @example
   * 110843374
   */
  appId?: number;
  /**
   * @remarks
   * The name of the app.
   * 
   * @example
   * CreateApptest
   */
  appName?: string;
  /**
   * @remarks
   * The time when the app was created.
   * 
   * @example
   * 2019-01-29T09:33:01Z
   */
  createdTime?: string;
  /**
   * @remarks
   * The description of the app.
   * 
   * @example
   * Estimated on October 15, 2021 at 10:20:27
   */
  description?: string;
  /**
   * @remarks
   * 扩展信息
   * 
   * @example
   * 110243810311
   */
  extend?: string;
  /**
   * @remarks
   * The time when the app was modified.
   * 
   * @example
   * 2019-01-29T09:33:01Z
   */
  modifiedTime?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * DBDB3B0F-EC61-5F33-88AD-EC2446FA1DDB
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      appName: 'AppName',
      createdTime: 'CreatedTime',
      description: 'Description',
      extend: 'Extend',
      modifiedTime: 'ModifiedTime',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'number',
      appName: 'string',
      createdTime: 'string',
      description: 'string',
      extend: 'string',
      modifiedTime: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAppResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAppResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAppResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAppAttributesRequest extends $tea.Model {
  /**
   * @remarks
   * The AppCode of the app.
   * 
   * @example
   * 23552160
   */
  appCode?: string;
  /**
   * @remarks
   * The ID of the app.
   * 
   * @example
   * 20112314518278
   */
  appId?: number;
  /**
   * @remarks
   * The app key that is used to make an API call.
   * 
   * @example
   * 203708622
   */
  appKey?: string;
  /**
   * @remarks
   * The name of the app.
   * 
   * @example
   * testApp
   */
  appName?: string;
  /**
   * @remarks
   * Specifies whether to enable tag verification.
   * 
   * @example
   * true
   */
  enableTagAuth?: boolean;
  /**
   * @remarks
   * 扩展信息
   * 
   * @example
   * 110243810311
   */
  extend?: string;
  /**
   * @remarks
   * The number of the page to return. Pages start from page 1. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Maximum value: 100. Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  securityToken?: string;
  /**
   * @remarks
   * The order. Valid values: asc and desc. Default value: desc.
   * 
   * *   asc: The apps are displayed in ascending order of modification time.
   * *   desc: The apps are displayed in descending order of modification time.
   * 
   * @example
   * desc
   */
  sort?: string;
  /**
   * @remarks
   * The tag of objects that match the rule. You can specify multiple tags.
   * 
   * @example
   * Key， Value
   */
  tag?: DescribeAppAttributesRequestTag[];
  static names(): { [key: string]: string } {
    return {
      appCode: 'AppCode',
      appId: 'AppId',
      appKey: 'AppKey',
      appName: 'AppName',
      enableTagAuth: 'EnableTagAuth',
      extend: 'Extend',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      securityToken: 'SecurityToken',
      sort: 'Sort',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appCode: 'string',
      appId: 'number',
      appKey: 'string',
      appName: 'string',
      enableTagAuth: 'boolean',
      extend: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      securityToken: 'string',
      sort: 'string',
      tag: { 'type': 'array', 'itemType': DescribeAppAttributesRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAppAttributesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned app information. It is an array that consists of AppAttribute data.
   */
  apps?: DescribeAppAttributesResponseBodyApps;
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 8883AC74-259D-4C0B-99FC-0B7F9A588B2F
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of returned entries.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      apps: 'Apps',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apps: DescribeAppAttributesResponseBodyApps,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAppAttributesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAppAttributesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAppAttributesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAppSecuritiesRequest extends $tea.Model {
  /**
   * @remarks
   * The application ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 110862931
   */
  appId?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAppSecuritiesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The associated security policy information.
   */
  appSecuritys?: DescribeAppSecuritiesResponseBodyAppSecuritys;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EF924FE4-2EDD-4CD3-89EC-34E4708574E7
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      appSecuritys: 'AppSecuritys',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appSecuritys: DescribeAppSecuritiesResponseBodyAppSecuritys,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAppSecuritiesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAppSecuritiesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAppSecuritiesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAppSecurityRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the app.
   * 
   * This parameter is required.
   * 
   * @example
   * 20112314518278
   */
  appId?: number;
  securityToken?: string;
  /**
   * @remarks
   * The tag of objects that match the rule. You can specify multiple tags.
   * 
   * @example
   * Key， Value
   */
  tag?: DescribeAppSecurityRequestTag[];
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      securityToken: 'SecurityToken',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'number',
      securityToken: 'string',
      tag: { 'type': 'array', 'itemType': DescribeAppSecurityRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAppSecurityResponseBody extends $tea.Model {
  /**
   * @remarks
   * The AppCode of the app.
   * 
   * @example
   * 3aaf905a0a1f4f0eabc6d891dfa08afc
   */
  appCode?: string;
  /**
   * @remarks
   * The key of the app.
   * 
   * @example
   * 60030986
   */
  appKey?: string;
  /**
   * @remarks
   * The password of the app.
   * 
   * @example
   * c1ae97aaa7e45f21d10824bc44678fee
   */
  appSecret?: string;
  /**
   * @remarks
   * The creation time (UTC) of the key, which is the same as the app creation time.
   * 
   * @example
   * 2016-07-31T04:10:19Z
   */
  createdTime?: string;
  /**
   * @remarks
   * The modification time (UTC) of the key.
   * 
   * @example
   * 2016-07-31T04:10:19Z
   */
  modifiedTime?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ015
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      appCode: 'AppCode',
      appKey: 'AppKey',
      appSecret: 'AppSecret',
      createdTime: 'CreatedTime',
      modifiedTime: 'ModifiedTime',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appCode: 'string',
      appKey: 'string',
      appSecret: 'string',
      createdTime: 'string',
      modifiedTime: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAppSecurityResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAppSecurityResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAppSecurityResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAppsRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the app.
   * 
   * @example
   * 20112314518278
   */
  appId?: number;
  /**
   * @remarks
   * The Alibaba Cloud account of the app owner. For more information, see [Account Management](https://account.console.aliyun.com/?spm=a2c4g.11186623.2.15.3a8c196eVWxvQB#/secure).
   * 
   * @example
   * 1546564
   */
  appOwner?: number;
  /**
   * @remarks
   * The number of the page to return. Pages start from page 1. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Maximum value: 100. Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      appOwner: 'AppOwner',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'number',
      appOwner: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAppsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned app information. It is an array consisting of AppItem data.
   */
  apps?: DescribeAppsResponseBodyApps;
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ015
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of returned entries.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      apps: 'Apps',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apps: DescribeAppsResponseBodyApps,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAppsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAppsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAppsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAppsByApiProductRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the API product.
   * 
   * This parameter is required.
   * 
   * @example
   * 117b7a64a8b3f064eaa4a47ac62aac5e
   */
  apiProductId?: string;
  /**
   * @remarks
   * The application name.
   * 
   * @example
   * testApp
   */
  appName?: string;
  /**
   * @remarks
   * The number of the page to return. Pages start from page 1. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Maximum value: 100. Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      apiProductId: 'ApiProductId',
      appName: 'AppName',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiProductId: 'string',
      appName: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAppsByApiProductResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about authorized applications.
   */
  authorizedApps?: DescribeAppsByApiProductResponseBodyAuthorizedApps;
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * AC866798-62D3-52F4-8AB5-CA149A53984F
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of returned entries.
   * 
   * @example
   * 4
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      authorizedApps: 'AuthorizedApps',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authorizedApps: DescribeAppsByApiProductResponseBodyAuthorizedApps,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAppsByApiProductResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAppsByApiProductResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAppsByApiProductResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAuthorizedApisRequest extends $tea.Model {
  /**
   * @remarks
   * The application ID, which is generated by the system and globally unique.
   * 
   * This parameter is required.
   * 
   * @example
   * 2386789
   */
  appId?: number;
  /**
   * @remarks
   * The number of the page to return. Pages start from page 1. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Maximum value: 100. Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAuthorizedApisResponseBody extends $tea.Model {
  /**
   * @remarks
   * The authorized API set.
   */
  authorizedApis?: DescribeAuthorizedApisResponseBodyAuthorizedApis;
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * D6E46F10-F26C-4AA0-BB69-FE2743D9AE62
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of returned entries.
   * 
   * @example
   * 2
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      authorizedApis: 'AuthorizedApis',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authorizedApis: DescribeAuthorizedApisResponseBodyAuthorizedApis,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAuthorizedApisResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAuthorizedApisResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAuthorizedApisResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAuthorizedAppsRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the API. This ID is generated by the system and globally unique.
   * 
   * This parameter is required.
   * 
   * @example
   * baacc592e63a4cb6a41920d9d3f91f38
   */
  apiId?: string;
  /**
   * @remarks
   * The ID of the app.
   * 
   * @example
   * 20112314518278
   */
  appId?: number;
  /**
   * @remarks
   * The name of the app.
   * 
   * @example
   * CreateApptest
   */
  appName?: string;
  /**
   * @remarks
   * The Alibaba Cloud account of the app owner.
   * 
   * @example
   * 1546564
   */
  appOwnerId?: number;
  /**
   * @remarks
   * The ID of the API group. This ID is generated by the system and globally unique.
   * 
   * @example
   * 523e8dc7bbe04613b5b1d726c2a7889d
   */
  groupId?: string;
  /**
   * @remarks
   * The number of the page to return. Pages start from page 1. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Maximum value: 100. Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  securityToken?: string;
  /**
   * @remarks
   * The environment. Valid values:
   * 
   * *   **RELEASE**: the production environment
   * *   **PRE**: the staging environment
   * *   **TEST**: the test environment
   * 
   * @example
   * RELEASE
   */
  stageName?: string;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      appId: 'AppId',
      appName: 'AppName',
      appOwnerId: 'AppOwnerId',
      groupId: 'GroupId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      securityToken: 'SecurityToken',
      stageName: 'StageName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'string',
      appId: 'number',
      appName: 'string',
      appOwnerId: 'number',
      groupId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      securityToken: 'string',
      stageName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAuthorizedAppsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The authorized applications.
   */
  authorizedApps?: DescribeAuthorizedAppsResponseBodyAuthorizedApps;
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * D6E46F10-F26C-4AA0-BB69-FE2743D9AE62
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of returned entries.
   * 
   * @example
   * 2
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      authorizedApps: 'AuthorizedApps',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authorizedApps: DescribeAuthorizedAppsResponseBodyAuthorizedApps,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAuthorizedAppsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAuthorizedAppsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAuthorizedAppsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackendInfoRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the backend service.
   * 
   * @example
   * 739b68751c0b4e899e04d0c92b6d0be7
   */
  backendId?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      backendId: 'BackendId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      backendId: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackendInfoResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the backend service.
   */
  backendInfo?: DescribeBackendInfoResponseBodyBackendInfo;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0AA90E87-3506-5AA6-AFFB-A4D53B4F6231
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      backendInfo: 'BackendInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      backendInfo: DescribeBackendInfoResponseBodyBackendInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackendInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeBackendInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeBackendInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackendListRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the backend service. You can use \\* to perform fuzzy queries.
   * 
   * @example
   * test
   */
  backendName?: string;
  /**
   * @remarks
   * The type of the backend service.
   * 
   * @example
   * HTTP
   */
  backendType?: string;
  /**
   * @remarks
   * The number of the current page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  securityToken?: string;
  /**
   * @remarks
   * The list of the tag.
   */
  tag?: DescribeBackendListRequestTag[];
  static names(): { [key: string]: string } {
    return {
      backendName: 'BackendName',
      backendType: 'BackendType',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      securityToken: 'SecurityToken',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      backendName: 'string',
      backendType: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      securityToken: 'string',
      tag: { 'type': 'array', 'itemType': DescribeBackendListRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackendListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The backend services.
   */
  backendInfoList?: DescribeBackendListResponseBodyBackendInfoList[];
  /**
   * @remarks
   * The number of the current page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned on each page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 090A0DF9-9144-5236-8CBA-E18DE317722D
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      backendInfoList: 'BackendInfoList',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      backendInfoList: { 'type': 'array', 'itemType': DescribeBackendListResponseBodyBackendInfoList },
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackendListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeBackendListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeBackendListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDatasetInfoRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the dataset.
   * 
   * This parameter is required.
   * 
   * @example
   * a25a6589b2584ff490e891cc********
   */
  datasetId?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      datasetId: 'DatasetId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      datasetId: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDatasetInfoResponseBody extends $tea.Model {
  datasetInfo?: DescribeDatasetInfoResponseBodyDatasetInfo;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * A2C8F75E-EE84-5C64-960F-45C8********
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      datasetInfo: 'DatasetInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      datasetInfo: DescribeDatasetInfoResponseBodyDatasetInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDatasetInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDatasetInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDatasetInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDatasetItemInfoRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the dataset.
   * 
   * This parameter is required.
   * 
   * @example
   * 62b91a790a693238********
   */
  datasetId?: string;
  /**
   * @remarks
   * The ID of the data entry.
   * 
   * @example
   * 5045****
   */
  datasetItemId?: string;
  securityToken?: string;
  /**
   * @remarks
   * The value of the data entry.
   * 
   * @example
   * 106.43.XXX.XXX
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      datasetId: 'DatasetId',
      datasetItemId: 'DatasetItemId',
      securityToken: 'SecurityToken',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      datasetId: 'string',
      datasetItemId: 'string',
      securityToken: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDatasetItemInfoResponseBody extends $tea.Model {
  /**
   * @remarks
   * The Dataset information.
   */
  datasetItemInfo?: DescribeDatasetItemInfoResponseBodyDatasetItemInfo;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 5BAFA85F-38E3-5D9E-9E32-4B09********
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      datasetItemInfo: 'DatasetItemInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      datasetItemInfo: DescribeDatasetItemInfoResponseBodyDatasetItemInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDatasetItemInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDatasetItemInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDatasetItemInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDatasetItemListRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the dataset.
   * 
   * This parameter is required.
   * 
   * @example
   * 602e1f6b3543200eaab0a89e********
   */
  datasetId?: string;
  /**
   * @remarks
   * The ID of the data entry. You can enter multiple IDs. Separate them with commas (,).
   * 
   * @example
   * 5045****
   */
  datasetItemIds?: string;
  /**
   * @remarks
   * The number of the page to return. Pages start from page 1. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      datasetId: 'DatasetId',
      datasetItemIds: 'DatasetItemIds',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      datasetId: 'string',
      datasetItemIds: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDatasetItemListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The Dataset information.
   */
  datasetItemInfoList?: DescribeDatasetItemListResponseBodyDatasetItemInfoList[];
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * C6E9C6E4-608B-5C0F-9783-E288********
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 20
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      datasetItemInfoList: 'DatasetItemInfoList',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      datasetItemInfoList: { 'type': 'array', 'itemType': DescribeDatasetItemListResponseBodyDatasetItemInfoList },
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDatasetItemListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDatasetItemListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDatasetItemListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDatasetListRequest extends $tea.Model {
  /**
   * @remarks
   * The IDs of the datasets.
   * 
   * @example
   * 4add6a61804e47858266883e********
   */
  datasetIds?: string;
  /**
   * @remarks
   * The number of the page to return. Pages start from page 1. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  securityToken?: string;
  /**
   * @remarks
   * 指定规则所适用的对象标签，可设置多个
   */
  tag?: DescribeDatasetListRequestTag[];
  static names(): { [key: string]: string } {
    return {
      datasetIds: 'DatasetIds',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      securityToken: 'SecurityToken',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      datasetIds: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      securityToken: 'string',
      tag: { 'type': 'array', 'itemType': DescribeDatasetListRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDatasetListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned dataset information. It is an array consisting of datasetinfo.
   */
  datasetInfoList?: DescribeDatasetListResponseBodyDatasetInfoList[];
  /**
   * @remarks
   * The number of the page to return. Pages start from page 1. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * D403C6E6-21B3-5B78-82DA-E3B6********
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 20
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      datasetInfoList: 'DatasetInfoList',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      datasetInfoList: { 'type': 'array', 'itemType': DescribeDatasetListResponseBodyDatasetInfoList },
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDatasetListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDatasetListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDatasetListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDeployApiTaskRequest extends $tea.Model {
  /**
   * @remarks
   * The task ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 51524fb8f12846d694d0a1de9a0cf274
   */
  operationUid?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      operationUid: 'OperationUid',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      operationUid: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDeployApiTaskResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned result.
   */
  deployedResults?: DescribeDeployApiTaskResponseBodyDeployedResults;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CA4B3261-F14A-5E33-8608-F75A1DF27AD4
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      deployedResults: 'DeployedResults',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deployedResults: DescribeDeployApiTaskResponseBodyDeployedResults,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDeployApiTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDeployApiTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDeployApiTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDeployedApiRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the API.
   * 
   * This parameter is required.
   * 
   * @example
   * ab7c95a01a7e42f28718f34497bbf47c
   */
  apiId?: string;
  /**
   * @remarks
   * The ID of the API group. This ID is generated by the system and globally unique.
   * 
   * @example
   * 81750604ccff48c48f34d6c0165e09db
   */
  groupId?: string;
  securityToken?: string;
  /**
   * @remarks
   * The name of the runtime environment. Valid values:
   * 
   * *   **RELEASE**
   * *   **PRE: the pre-release environment**
   * *   **TEST**
   * 
   * This parameter is required.
   * 
   * @example
   * RELEASE
   */
  stageName?: string;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      groupId: 'GroupId',
      securityToken: 'SecurityToken',
      stageName: 'StageName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'string',
      groupId: 'string',
      securityToken: 'string',
      stageName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDeployedApiResponseBody extends $tea.Model {
  /**
   * @remarks
   * The signature method used by the client. Valid values:
   * 
   * *   HmacSHA256
   * *   HmacSHA1,HmacSHA256
   * 
   * @example
   * HmacSHA256
   */
  allowSignatureMethod?: string;
  /**
   * @remarks
   * The ID of the API.
   * 
   * @example
   * 4eed13a57d4e42fbb51316be8a5329ff
   */
  apiId?: string;
  /**
   * @remarks
   * The name of the API
   * 
   * @example
   * weather
   */
  apiName?: string;
  /**
   * @remarks
   * The security authentication method of the API. Valid values:
   * 
   * *   **APP: Only authorized applications can call the API.**
   * 
   * *   **ANONYMOUS: The API can be anonymously called. In this mode, you must take note of the following rules:**
   * 
   *     *   All users who have obtained the API service information can call this API. API Gateway does not authenticate callers and cannot set user-specific throttling policies. If you make this API public, set API-specific throttling policies.
   * 
   * @example
   * APP
   */
  authType?: string;
  /**
   * @remarks
   * The constant parameters.
   */
  constantParameters?: DescribeDeployedApiResponseBodyConstantParameters;
  /**
   * @remarks
   * The custom system parameters.
   */
  customSystemParameters?: DescribeDeployedApiResponseBodyCustomSystemParameters;
  /**
   * @remarks
   * The deployment time. Format: yyyy-mm-ddhh:mm:ss.
   * 
   * @example
   * 2022-07-25T17:47:51Z
   */
  deployedTime?: string;
  /**
   * @remarks
   * The description.
   * 
   * @example
   * Api description
   */
  description?: string;
  /**
   * @remarks
   * *   Specifies whether to set DisableInternet to **true** to limit API calls to within the VPC.
   * *   If you set DisableInternet to **false**, the limit is lifted.
   * 
   * >  If you do not set this parameter, the original value is not modified.
   * 
   * @example
   * true
   */
  disableInternet?: boolean;
  /**
   * @remarks
   * The sample error codes returned by the backend service.
   * 
   * For more information, see [ErrorCodeSample](https://help.aliyun.com/document_detail/44392.html).
   */
  errorCodeSamples?: DescribeDeployedApiResponseBodyErrorCodeSamples;
  /**
   * @remarks
   * The sample error response from the backend service.
   * 
   * @example
   * {"errorCode":"fail","errorMessage":"param invalid"}
   */
  failResultSample?: string;
  /**
   * @remarks
   * *   Specifies whether to set **ForceNonceCheck** to **true** to force the check of X-Ca-Nonce during the request. This is the unique identifier of the request and is generally identified by UUID. After receiving this parameter, API Gateway verifies the validity of this parameter. The same value can be used only once within 15 minutes. This helps prevent replay attacks.
   * *   If you set **ForceNonceCheck** to **false**, the check is not performed. The default value is false when you create an API.
   * 
   * @example
   * true
   */
  forceNonceCheck?: boolean;
  /**
   * @remarks
   * The ID of the API group.
   * 
   * @example
   * bc77f5b49c974437a9912ea3755cd834
   */
  groupId?: string;
  /**
   * @remarks
   * The name of the API group.
   * 
   * @example
   * Weather
   */
  groupName?: string;
  /**
   * @remarks
   * The configuration items of the third-party OpenID Connect authentication method.
   */
  openIdConnectConfig?: DescribeDeployedApiResponseBodyOpenIdConnectConfig;
  /**
   * @remarks
   * The region to which the API group belongs.
   * 
   * @example
   * cn-beijing
   */
  regionId?: string;
  /**
   * @remarks
   * Configuration items of API requests sent by the consumer to API Gateway.
   * 
   * For more information, see [RequestConfig](https://help.aliyun.com/document_detail/43985.html).
   */
  requestConfig?: DescribeDeployedApiResponseBodyRequestConfig;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * EF924FE4-2EDD-4CD3-89EC-34E4708574E7
   */
  requestId?: string;
  /**
   * @remarks
   * The parameters of API requests sent by the consumer to API Gateway.
   * 
   * For more information, see [RequestParameter](https://help.aliyun.com/document_detail/43986.html).
   */
  requestParameters?: DescribeDeployedApiResponseBodyRequestParameters;
  /**
   * @remarks
   * The return description of the API.
   * 
   * @example
   * {}
   */
  resultBodyModel?: string;
  /**
   * @remarks
   * The return description of the API.
   */
  resultDescriptions?: DescribeDeployedApiResponseBodyResultDescriptions;
  /**
   * @remarks
   * The sample response from the backend service.
   * 
   * @example
   * {code: 200, message:\\"success\\", data: \\"\\"}
   */
  resultSample?: string;
  /**
   * @remarks
   * The format of the response from the backend service. Valid values: JSON, TEXT, BINARY, XML, and HTML. Default value: JSON.
   * 
   * @example
   * HTML
   */
  resultType?: string;
  /**
   * @remarks
   * The configuration items of API requests sent by API Gateway to the backend service.
   * 
   * For more information, see [ServiceConfig](https://help.aliyun.com/document_detail/43987.html).
   */
  serviceConfig?: DescribeDeployedApiResponseBodyServiceConfig;
  /**
   * @remarks
   * The parameters of API requests sent by API Gateway to the backend service.
   * 
   * For more information, see [ServiceParameter](https://help.aliyun.com/document_detail/43988.html).
   */
  serviceParameters?: DescribeDeployedApiResponseBodyServiceParameters;
  /**
   * @remarks
   * The mappings between parameters of requests sent by the consumer to API Gateway and parameters of requests sent by API Gateway to the backend service.
   * 
   * For more information, see [ServiceParameterMap](https://help.aliyun.com/document_detail/43989.html).
   */
  serviceParametersMap?: DescribeDeployedApiResponseBodyServiceParametersMap;
  /**
   * @remarks
   * The name of the runtime environment. Valid values:
   * 
   * *   **RELEASE**
   * *   **PRE: the pre-release environment**
   * *   **TEST**
   * 
   * @example
   * RELEASE
   */
  stageName?: string;
  /**
   * @remarks
   * System parameters
   */
  systemParameters?: DescribeDeployedApiResponseBodySystemParameters;
  /**
   * @remarks
   * Specifies whether to make the API public. Valid values:
   * 
   * *   **PUBLIC**: Make the API public. If you set this parameter to PUBLIC, this API is displayed on the APIs page for all users after the API is published to the production environment.**
   * *   **PRIVATE**: Make the API private. Private APIs are not displayed in the Alibaba Cloud Marketplace after the API group to which they belong is made available.
   * 
   * @example
   * PUBLIC
   */
  visibility?: string;
  static names(): { [key: string]: string } {
    return {
      allowSignatureMethod: 'AllowSignatureMethod',
      apiId: 'ApiId',
      apiName: 'ApiName',
      authType: 'AuthType',
      constantParameters: 'ConstantParameters',
      customSystemParameters: 'CustomSystemParameters',
      deployedTime: 'DeployedTime',
      description: 'Description',
      disableInternet: 'DisableInternet',
      errorCodeSamples: 'ErrorCodeSamples',
      failResultSample: 'FailResultSample',
      forceNonceCheck: 'ForceNonceCheck',
      groupId: 'GroupId',
      groupName: 'GroupName',
      openIdConnectConfig: 'OpenIdConnectConfig',
      regionId: 'RegionId',
      requestConfig: 'RequestConfig',
      requestId: 'RequestId',
      requestParameters: 'RequestParameters',
      resultBodyModel: 'ResultBodyModel',
      resultDescriptions: 'ResultDescriptions',
      resultSample: 'ResultSample',
      resultType: 'ResultType',
      serviceConfig: 'ServiceConfig',
      serviceParameters: 'ServiceParameters',
      serviceParametersMap: 'ServiceParametersMap',
      stageName: 'StageName',
      systemParameters: 'SystemParameters',
      visibility: 'Visibility',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allowSignatureMethod: 'string',
      apiId: 'string',
      apiName: 'string',
      authType: 'string',
      constantParameters: DescribeDeployedApiResponseBodyConstantParameters,
      customSystemParameters: DescribeDeployedApiResponseBodyCustomSystemParameters,
      deployedTime: 'string',
      description: 'string',
      disableInternet: 'boolean',
      errorCodeSamples: DescribeDeployedApiResponseBodyErrorCodeSamples,
      failResultSample: 'string',
      forceNonceCheck: 'boolean',
      groupId: 'string',
      groupName: 'string',
      openIdConnectConfig: DescribeDeployedApiResponseBodyOpenIdConnectConfig,
      regionId: 'string',
      requestConfig: DescribeDeployedApiResponseBodyRequestConfig,
      requestId: 'string',
      requestParameters: DescribeDeployedApiResponseBodyRequestParameters,
      resultBodyModel: 'string',
      resultDescriptions: DescribeDeployedApiResponseBodyResultDescriptions,
      resultSample: 'string',
      resultType: 'string',
      serviceConfig: DescribeDeployedApiResponseBodyServiceConfig,
      serviceParameters: DescribeDeployedApiResponseBodyServiceParameters,
      serviceParametersMap: DescribeDeployedApiResponseBodyServiceParametersMap,
      stageName: 'string',
      systemParameters: DescribeDeployedApiResponseBodySystemParameters,
      visibility: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDeployedApiResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDeployedApiResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDeployedApiResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDeployedApisRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the API.
   * 
   * @example
   * c076144d7878437b8f82fb85890ce6a0
   */
  apiId?: string;
  /**
   * @example
   * POST
   */
  apiMethod?: string;
  /**
   * @remarks
   * The name of the API. The name is used for fuzzy match.
   * 
   * @example
   * weather
   */
  apiName?: string;
  /**
   * @example
   * /st4
   */
  apiPath?: string;
  /**
   * @remarks
   * Specifies whether to enable tag verification.
   * 
   * @example
   * true
   */
  enableTagAuth?: boolean;
  /**
   * @remarks
   * The ID of the API group.
   * 
   * @example
   * 63be9002440b4778a61122f14c2b2bbb
   */
  groupId?: string;
  /**
   * @remarks
   * The number of the page to return. Pages start from page 1. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Maximum value: 100. Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  securityToken?: string;
  /**
   * @remarks
   * The name of the runtime environment. Valid values:
   * 
   * *   **RELEASE**
   * *   **TEST**
   * 
   * @example
   * RELEASE
   */
  stageName?: string;
  /**
   * @remarks
   * The tags.
   */
  tag?: DescribeDeployedApisRequestTag[];
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      apiMethod: 'ApiMethod',
      apiName: 'ApiName',
      apiPath: 'ApiPath',
      enableTagAuth: 'EnableTagAuth',
      groupId: 'GroupId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      securityToken: 'SecurityToken',
      stageName: 'StageName',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'string',
      apiMethod: 'string',
      apiName: 'string',
      apiPath: 'string',
      enableTagAuth: 'boolean',
      groupId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      securityToken: 'string',
      stageName: 'string',
      tag: { 'type': 'array', 'itemType': DescribeDeployedApisRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDeployedApisResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned API information. It is an array consisting of DeployedApiItem data.
   */
  deployedApis?: DescribeDeployedApisResponseBodyDeployedApis;
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ002
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of returned entries.
   * 
   * @example
   * 2
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      deployedApis: 'DeployedApis',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deployedApis: DescribeDeployedApisResponseBodyDeployedApis,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDeployedApisResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDeployedApisResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDeployedApisResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainRequest extends $tea.Model {
  /**
   * @remarks
   * The custom domain name.
   * 
   * This parameter is required.
   * 
   * @example
   * api.demo.com
   */
  domainName?: string;
  /**
   * @remarks
   * The ID of the API group. This ID is generated by the system and globally unique.
   * 
   * This parameter is required.
   * 
   * @example
   * 927d50c0f2e54b359919923d908bb015
   */
  groupId?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      groupId: 'GroupId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      groupId: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainResponseBody extends $tea.Model {
  /**
   * @remarks
   * The content of the certificate.
   * 
   * @example
   * xxx
   */
  certificateBody?: string;
  /**
   * @remarks
   * The unique ID of the SSL certificate, which is automatically generated by the system.
   * 
   * @example
   * 6EF60BEC-0242-43AF-BB20-270359FB54A7
   */
  certificateId?: string;
  /**
   * @remarks
   * The name of the SSL certificate.
   * 
   * @example
   * myCertificate
   */
  certificateName?: string;
  /**
   * @remarks
   * The private key of the SSL certificate.
   * 
   * @example
   * xxx
   */
  certificatePrivateKey?: string;
  /**
   * @remarks
   * 证书失效时间戳（毫秒）
   * 
   * @example
   * 1704038400000
   */
  certificateValidEnd?: number;
  /**
   * @remarks
   * 证书生效时间戳（毫秒）
   * 
   * @example
   * 1672502400000
   */
  certificateValidStart?: number;
  /**
   * @remarks
   * The binding status of the custom domain name. Valid values:
   * 
   * *   BINDING: The domain name has been bound.
   * *   BOUND: The domain name has not been bound.
   * 
   * @example
   * BINDING
   */
  domainBindingStatus?: string;
  /**
   * @remarks
   * The domain name resolution status. Valid values:
   * 
   * *   RESOLVED: The domain name has been resolved.
   * *   UNRESOLVED: The domain name has not been resolved.
   * 
   * @example
   * RESOLVED
   */
  domainCNAMEStatus?: string;
  /**
   * @remarks
   * The validity status of the domain name. Valid values:
   * 
   * *   NORMAL
   * *   ABNORMAL: This status affects API calls and must be resolved as soon as possible.
   * 
   * @example
   * NORMAL
   */
  domainLegalStatus?: string;
  /**
   * @remarks
   * The custom domain name.
   * 
   * @example
   * api.demo.com
   */
  domainName?: string;
  /**
   * @remarks
   * Remarks about the domain name, such as the cause of an exception.
   * 
   * @example
   * The domain name does not have an ICP filing.
   */
  domainRemark?: string;
  /**
   * @remarks
   * The status of the domain name that uses WebSocket.
   * 
   * @example
   * NORMAL
   */
  domainWebSocketStatus?: string;
  /**
   * @remarks
   * The ID of the API group. This ID is generated by the system and globally unique.
   * 
   * @example
   * 927d50c0f2e54b359919923d908bb015
   */
  groupId?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 6EF60BEC-0242-43AF-BB20-270359FB54A7
   */
  requestId?: string;
  /**
   * @remarks
   * The second-level domain name that is automatically assigned to the API group.
   * 
   * @example
   * xxx-cn-hangzhou.alicloudapi.com
   */
  subDomain?: string;
  static names(): { [key: string]: string } {
    return {
      certificateBody: 'CertificateBody',
      certificateId: 'CertificateId',
      certificateName: 'CertificateName',
      certificatePrivateKey: 'CertificatePrivateKey',
      certificateValidEnd: 'CertificateValidEnd',
      certificateValidStart: 'CertificateValidStart',
      domainBindingStatus: 'DomainBindingStatus',
      domainCNAMEStatus: 'DomainCNAMEStatus',
      domainLegalStatus: 'DomainLegalStatus',
      domainName: 'DomainName',
      domainRemark: 'DomainRemark',
      domainWebSocketStatus: 'DomainWebSocketStatus',
      groupId: 'GroupId',
      requestId: 'RequestId',
      subDomain: 'SubDomain',
    };
  }

  static types(): { [key: string]: any } {
    return {
      certificateBody: 'string',
      certificateId: 'string',
      certificateName: 'string',
      certificatePrivateKey: 'string',
      certificateValidEnd: 'number',
      certificateValidStart: 'number',
      domainBindingStatus: 'string',
      domainCNAMEStatus: 'string',
      domainLegalStatus: 'string',
      domainName: 'string',
      domainRemark: 'string',
      domainWebSocketStatus: 'string',
      groupId: 'string',
      requestId: 'string',
      subDomain: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDomainResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDomainResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGroupLatencyRequest extends $tea.Model {
  /**
   * @remarks
   * The end time of the time range to query. The time follows the ISO 8601 standard and UTC time is used. Format: YYYY-MM-DDThh:mm:ssZ.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-04-14T06:26:14Z
   */
  endTime?: string;
  /**
   * @remarks
   * The ID of the API group.
   * 
   * This parameter is required.
   * 
   * @example
   * d825094fdd114a869f5adb443d9b7ead
   */
  groupId?: string;
  securityToken?: string;
  /**
   * @remarks
   * The environment in which you want to perform the query. Valid values:
   * 
   * *   **RELEASE**: the production environment
   * *   **PRE**: the staging environment
   * *   **TEST**: the test environment
   * 
   * This parameter is required.
   * 
   * @example
   * RELEASE
   */
  stageName?: string;
  /**
   * @remarks
   * The start time of the time range to query. The time follows the ISO 8601 standard and UTC time is used. Format: YYYY-MM-DDThh:mm:ssZ.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-03-30T16:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      groupId: 'GroupId',
      securityToken: 'SecurityToken',
      stageName: 'StageName',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      groupId: 'string',
      securityToken: 'string',
      stageName: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGroupLatencyResponseBody extends $tea.Model {
  /**
   * @remarks
   * The latency information.
   */
  latencyPacket?: DescribeGroupLatencyResponseBodyLatencyPacket;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 75DC3AB0-421C-5371-8170-86AEABF77AD0
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      latencyPacket: 'LatencyPacket',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      latencyPacket: DescribeGroupLatencyResponseBodyLatencyPacket,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGroupLatencyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeGroupLatencyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeGroupLatencyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGroupQpsRequest extends $tea.Model {
  /**
   * @remarks
   * The end time. The time follows the ISO 8601 standard and UTC time is used. Format: YYYY-MM-DDThh:mm:ssZ
   * 
   * This parameter is required.
   * 
   * @example
   * 2022-08-23T07:27:44Z
   */
  endTime?: string;
  /**
   * @remarks
   * The API group ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 264c60db9f764345a13ac5c825b229b9
   */
  groupId?: string;
  securityToken?: string;
  /**
   * @remarks
   * The environment to which the API group is published. Valid values:
   * 
   * *   **RELEASE**: the production environment
   * *   **PRE**: the staging environment
   * *   **TEST**: the test environment
   * 
   * This parameter is required.
   * 
   * @example
   * RELEASE
   */
  stageName?: string;
  /**
   * @remarks
   * The start time. The time follows the ISO 8601 standard and UTC time is used. Format: YYYY-MM-DDThh:mm:ssZ
   * 
   * This parameter is required.
   * 
   * @example
   * 2022-08-12T06:09:52Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      groupId: 'GroupId',
      securityToken: 'SecurityToken',
      stageName: 'StageName',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      groupId: 'string',
      securityToken: 'string',
      stageName: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGroupQpsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The number of requests directed to the API group.
   */
  groupQps?: DescribeGroupQpsResponseBodyGroupQps;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * D6E46F10-F26C-4AA0-BB69-FE2743D9AE62
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      groupQps: 'GroupQps',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupQps: DescribeGroupQpsResponseBodyGroupQps,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGroupQpsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeGroupQpsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeGroupQpsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGroupTrafficRequest extends $tea.Model {
  /**
   * @remarks
   * The end time for the query. The time follows the ISO 8601 standard and UTC time is used. Format: YYYY-MM-DDThh:mm:ssZ.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-06-16T02:16:53Z
   */
  endTime?: string;
  /**
   * @remarks
   * The ID of the API group.
   * 
   * This parameter is required.
   * 
   * @example
   * 16df9d11caa04900bcafe23b38a81600
   */
  groupId?: string;
  securityToken?: string;
  /**
   * @remarks
   * The environment to which the APIs in the API group are published. Valid values:
   * 
   * *   **RELEASE**: the production environment
   * *   **PRE**: the staging environment
   * *   **TEST**: the test environment
   * 
   * This parameter is required.
   * 
   * @example
   * RELEASE
   */
  stageName?: string;
  /**
   * @remarks
   * The start time for the query. The time follows the ISO 8601 standard and UTC time is used. Format: YYYY-MM-DDThh:mm:ssZ.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-01-29T01:27:43Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      groupId: 'GroupId',
      securityToken: 'SecurityToken',
      stageName: 'StageName',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      groupId: 'string',
      securityToken: 'string',
      stageName: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGroupTrafficResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EF924FE4-2EDD-4CD3-89EC-34E4708574E7
   */
  requestId?: string;
  /**
   * @remarks
   * The traffic information per second.
   */
  trafficPerSecond?: DescribeGroupTrafficResponseBodyTrafficPerSecond;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      trafficPerSecond: 'TrafficPerSecond',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      trafficPerSecond: DescribeGroupTrafficResponseBodyTrafficPerSecond,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGroupTrafficResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeGroupTrafficResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeGroupTrafficResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHistoryApisRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the API.
   * 
   * @example
   * a12068f555964ca8a0c9c33288f1e5a7
   */
  apiId?: string;
  /**
   * @remarks
   * The name of the API. The name is used for fuzzy match.
   * 
   * @example
   * getPersonInfo
   */
  apiName?: string;
  /**
   * @remarks
   * The ID of the API group.
   * 
   * This parameter is required.
   * 
   * @example
   * 0ccb66aadb5345b78a40f57d192d8aa4
   */
  groupId?: string;
  /**
   * @remarks
   * The page number of the current page.
   * 
   * @example
   * 2
   */
  pageNumber?: string;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * @example
   * 10
   */
  pageSize?: string;
  securityToken?: string;
  /**
   * @remarks
   * The name of the runtime environment. Valid values:
   * 
   * *   **RELEASE**
   * *   **TEST**
   * 
   * @example
   * RELEASE
   */
  stageName?: string;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      apiName: 'ApiName',
      groupId: 'GroupId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      securityToken: 'SecurityToken',
      stageName: 'StageName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'string',
      apiName: 'string',
      groupId: 'string',
      pageNumber: 'string',
      pageSize: 'string',
      securityToken: 'string',
      stageName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHistoryApisResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned API information. It is an array consisting of ApiHisItems.
   */
  apiHisItems?: DescribeHistoryApisResponseBodyApiHisItems;
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Maximum value: 50. Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 6C87A26A-6A18-4B8E-8099-705278381A2C
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of returned entries.
   * 
   * @example
   * 20
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      apiHisItems: 'ApiHisItems',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiHisItems: DescribeHistoryApisResponseBodyApiHisItems,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHistoryApisResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeHistoryApisResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeHistoryApisResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImportOASTaskRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the asynchronous API import task that was generated during the import operation. This ID is used to query the execution status of the API import task.
   * 
   * This parameter is required.
   * 
   * @example
   * 4c53ccf1d40c489686d1adf5c2644a7f
   */
  operationId?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      operationId: 'OperationId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      operationId: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImportOASTaskResponseBody extends $tea.Model {
  /**
   * @remarks
   * The execution status of the subtask. Valid values:
   * 
   * *   RUNNING
   * *   WAIT
   * *   OVER
   * *   FAIL
   * *   CANCEL
   */
  apiResults?: DescribeImportOASTaskResponseBodyApiResults;
  /**
   * @remarks
   * The execution status of the subtask. Valid values:
   * 
   * *   RUNNING
   * *   WAIT
   * *   OVER
   * *   FAIL
   * *   CANCEL
   */
  modelResults?: DescribeImportOASTaskResponseBodyModelResults;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * CE5722A6-AE78-4741-A9B0-6C817D360510
   */
  requestId?: string;
  /**
   * @remarks
   * The status of the import task. Valid values:
   * 
   * *   Running
   * *   Finished
   * 
   * @example
   * Finished
   */
  taskStatus?: string;
  static names(): { [key: string]: string } {
    return {
      apiResults: 'ApiResults',
      modelResults: 'ModelResults',
      requestId: 'RequestId',
      taskStatus: 'TaskStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiResults: DescribeImportOASTaskResponseBodyApiResults,
      modelResults: DescribeImportOASTaskResponseBodyModelResults,
      requestId: 'string',
      taskStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImportOASTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeImportOASTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeImportOASTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceClusterInfoRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the dedicated instance cluster.
   * 
   * @example
   * testvpc
   */
  instanceClusterName?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      instanceClusterName: 'InstanceClusterName',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceClusterName: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceClusterInfoResponseBody extends $tea.Model {
  /**
   * @remarks
   * The time when the cluster was created.
   * 
   * @example
   * 2022-10-10T18:29:27
   */
  createdTime?: string;
  /**
   * @remarks
   * The cluster description, which can be up to 200 characters in length.
   * 
   * @example
   * v0.0.4
   */
  description?: string;
  /**
   * @remarks
   * The cluster details.
   */
  instanceClusterAttribute?: DescribeInstanceClusterInfoResponseBodyInstanceClusterAttribute;
  /**
   * @remarks
   * The cluster ID.
   * 
   * @example
   * apigateway-ht-04e41d95e9c1
   */
  instanceClusterId?: string;
  /**
   * @remarks
   * The cluster name.
   * 
   * @example
   * test
   */
  instanceClusterName?: string;
  /**
   * @remarks
   * The cluster status.
   * 
   * @example
   * RUNNING
   */
  instanceClusterStatus?: string;
  /**
   * @remarks
   * The cluster type.
   * 
   * @example
   * normal
   */
  instanceClusterType?: string;
  /**
   * @remarks
   * The cluster version.
   * 
   * @example
   * 3.5.3.856
   */
  instanceClusterVersion?: string;
  /**
   * @remarks
   * The dedicated instances contained in the cluster.
   */
  instanceList?: DescribeInstanceClusterInfoResponseBodyInstanceList;
  /**
   * @remarks
   * The time when the cluster was last modified.
   * 
   * @example
   * 2023-06-19 10:40:29 +0800
   */
  modifiedTime?: string;
  /**
   * @remarks
   * The region ID of the cluster.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ015
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      createdTime: 'CreatedTime',
      description: 'Description',
      instanceClusterAttribute: 'InstanceClusterAttribute',
      instanceClusterId: 'InstanceClusterId',
      instanceClusterName: 'InstanceClusterName',
      instanceClusterStatus: 'InstanceClusterStatus',
      instanceClusterType: 'InstanceClusterType',
      instanceClusterVersion: 'InstanceClusterVersion',
      instanceList: 'InstanceList',
      modifiedTime: 'ModifiedTime',
      regionId: 'RegionId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createdTime: 'string',
      description: 'string',
      instanceClusterAttribute: DescribeInstanceClusterInfoResponseBodyInstanceClusterAttribute,
      instanceClusterId: 'string',
      instanceClusterName: 'string',
      instanceClusterStatus: 'string',
      instanceClusterType: 'string',
      instanceClusterVersion: 'string',
      instanceList: DescribeInstanceClusterInfoResponseBodyInstanceList,
      modifiedTime: 'string',
      regionId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceClusterInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeInstanceClusterInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeInstanceClusterInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceClusterListRequest extends $tea.Model {
  /**
   * @remarks
   * The cluster ID.
   * 
   * @example
   * apigateway-cluster-hz-xxxxxxxxxxxx
   */
  instanceClusterId?: string;
  /**
   * @remarks
   * The cluster name.
   * 
   * @example
   * test-cluster
   */
  instanceClusterName?: string;
  /**
   * @remarks
   * The page number of the page to return.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      instanceClusterId: 'InstanceClusterId',
      instanceClusterName: 'InstanceClusterName',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceClusterId: 'string',
      instanceClusterName: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceClusterListResponseBody extends $tea.Model {
  instanceClusters?: DescribeInstanceClusterListResponseBodyInstanceClusters;
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ015
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 2
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      instanceClusters: 'InstanceClusters',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceClusters: DescribeInstanceClusterListResponseBodyInstanceClusters,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceClusterListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeInstanceClusterListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeInstanceClusterListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceDropConnectionsRequest extends $tea.Model {
  /**
   * @remarks
   * The end time. The time follows the ISO 8601 standard and UTC time is used. Format: YYYY-MM-DDThh:mm:ssZ
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-01-31T07:00:09Z
   */
  endTime?: string;
  /**
   * @remarks
   * The ID of the dedicated instance.
   * 
   * This parameter is required.
   * 
   * @example
   * apigateway-cn-n6w1v1234501
   */
  instanceId?: string;
  /**
   * @remarks
   * The statistical metric. Valid values:
   * 
   * *   Maximum
   * *   Minimum
   * *   Average
   * 
   * This parameter is required.
   * 
   * @example
   * Maximum
   */
  sbcName?: string;
  securityToken?: string;
  /**
   * @remarks
   * The start time. The time follows the ISO 8601 standard and UTC time is used. Format: YYYY-MM-DDThh:mm:ssZ
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-01-31T06:00:09Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      instanceId: 'InstanceId',
      sbcName: 'SbcName',
      securityToken: 'SecurityToken',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      instanceId: 'string',
      sbcName: 'string',
      securityToken: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceDropConnectionsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The list of dropped connections in the instance.
   */
  instanceDropConnections?: DescribeInstanceDropConnectionsResponseBodyInstanceDropConnections;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BA984
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceDropConnections: 'InstanceDropConnections',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceDropConnections: DescribeInstanceDropConnectionsResponseBodyInstanceDropConnections,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceDropConnectionsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeInstanceDropConnectionsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeInstanceDropConnectionsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceDropPacketRequest extends $tea.Model {
  /**
   * @remarks
   * The end time. The time follows the ISO 8601 standard and UTC time is used. Format: YYYY-MM-DDThh:mm:ssZ
   * 
   * This parameter is required.
   * 
   * @example
   * 2022-12-16T02:04:36Z
   */
  endTime?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * apigateway-cn-v641b9dxc00p
   */
  instanceId?: string;
  /**
   * @remarks
   * The statistical metric. Valid values:
   * 
   * *   Maximum
   * *   Minimum
   * *   Average
   * 
   * This parameter is required.
   * 
   * @example
   * Maximum
   */
  sbcName?: string;
  securityToken?: string;
  /**
   * @remarks
   * The start time. The time follows the ISO 8601 standard and UTC time is used. Format: YYYY-MM-DDThh:mm:ssZ
   * 
   * This parameter is required.
   * 
   * @example
   * 2022-09-06T04:00:36Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      instanceId: 'InstanceId',
      sbcName: 'SbcName',
      securityToken: 'SecurityToken',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      instanceId: 'string',
      sbcName: 'string',
      securityToken: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceDropPacketResponseBody extends $tea.Model {
  /**
   * @remarks
   * The list of dropped packets in the instance.
   */
  instanceDropPacket?: DescribeInstanceDropPacketResponseBodyInstanceDropPacket;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ001
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceDropPacket: 'InstanceDropPacket',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceDropPacket: DescribeInstanceDropPacketResponseBodyInstanceDropPacket,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceDropPacketResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeInstanceDropPacketResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeInstanceDropPacketResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceHttpCodeRequest extends $tea.Model {
  /**
   * @remarks
   * The end time. The time follows the ISO 8601 standard and UTC time is used. Format: YYYY-MM-DDThh:mm:ssZ
   * 
   * This parameter is required.
   * 
   * @example
   * 2022-07-21T06:05:52Z
   */
  endTime?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * apigateway-cn-m7r227yy2004
   */
  instanceId?: string;
  securityToken?: string;
  /**
   * @remarks
   * The environment in which the API is requested. Valid values:
   * 
   * *   **RELEASE**: the production environment
   * *   **PRE**: the pre-release environment
   * *   **TEST**: the test environment
   * 
   * This parameter is required.
   * 
   * @example
   * RELEASE
   */
  stageName?: string;
  /**
   * @remarks
   * The start time. The time follows the ISO 8601 standard and UTC time is used. Format: YYYY-MM-DDThh:mm:ssZ
   * 
   * This parameter is required.
   * 
   * @example
   * 2022-04-14T02:12:10Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      instanceId: 'InstanceId',
      securityToken: 'SecurityToken',
      stageName: 'StageName',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      instanceId: 'string',
      securityToken: 'string',
      stageName: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceHttpCodeResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status codes.
   */
  instanceHttpCode?: DescribeInstanceHttpCodeResponseBodyInstanceHttpCode;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * AD00F8C0-311B-54A9-ADE2-2436771012DA
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceHttpCode: 'InstanceHttpCode',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceHttpCode: DescribeInstanceHttpCodeResponseBodyInstanceHttpCode,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceHttpCodeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeInstanceHttpCodeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeInstanceHttpCodeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceLatencyRequest extends $tea.Model {
  /**
   * @remarks
   * The end time. The time follows the ISO 8601 standard and UTC time is used. Format: YYYY-MM-DDThh:mm:ssZ
   * 
   * This parameter is required.
   * 
   * @example
   * 2022-09-06T02:05:13Z
   */
  endTime?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * apigateway-cn-v641jf5tt01v
   */
  instanceId?: string;
  securityToken?: string;
  /**
   * @remarks
   * The environment in which the API is requested. Valid values:
   * 
   * *   **RELEASE**: the production environment
   * *   **PRE**: the pre-release environment
   * *   **TEST**: the test environment
   * 
   * This parameter is required.
   * 
   * @example
   * RELEASE
   */
  stageName?: string;
  /**
   * @remarks
   * The start time. The time follows the ISO 8601 standard and UTC time is used. Format: YYYY-MM-DDThh:mm:ssZ
   * 
   * This parameter is required.
   * 
   * @example
   * 2022-09-15T11:07:05Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      instanceId: 'InstanceId',
      securityToken: 'SecurityToken',
      stageName: 'StageName',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      instanceId: 'string',
      securityToken: 'string',
      stageName: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceLatencyResponseBody extends $tea.Model {
  /**
   * @remarks
   * The list of average latencies in the instance.
   */
  instanceLatency?: DescribeInstanceLatencyResponseBodyInstanceLatency;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ004
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceLatency: 'InstanceLatency',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceLatency: DescribeInstanceLatencyResponseBodyInstanceLatency,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceLatencyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeInstanceLatencyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeInstanceLatencyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceNewConnectionsRequest extends $tea.Model {
  /**
   * @remarks
   * The end time. The time follows the ISO 8601 standard and UTC time is used. Format: YYYY-MM-DDThh:mm:ssZ
   * 
   * This parameter is required.
   * 
   * @example
   * 2022-10-08T02:08:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * apigateway-cn-2r426lavr001
   */
  instanceId?: string;
  /**
   * @remarks
   * The statistical metric. Valid values:
   * 
   * *   Maximum
   * *   Minimum
   * *   Average
   * 
   * This parameter is required.
   * 
   * @example
   * Maximum
   */
  sbcName?: string;
  securityToken?: string;
  /**
   * @remarks
   * The start time. The time follows the ISO 8601 standard and UTC time is used. Format: YYYY-MM-DDThh:mm:ssZ
   * 
   * This parameter is required.
   * 
   * @example
   * 2022-10-01T02:08:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      instanceId: 'InstanceId',
      sbcName: 'SbcName',
      securityToken: 'SecurityToken',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      instanceId: 'string',
      sbcName: 'string',
      securityToken: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceNewConnectionsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The list of new connections in the instance.
   */
  instanceNewConnections?: DescribeInstanceNewConnectionsResponseBodyInstanceNewConnections;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ004
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceNewConnections: 'InstanceNewConnections',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceNewConnections: DescribeInstanceNewConnectionsResponseBodyInstanceNewConnections,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceNewConnectionsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeInstanceNewConnectionsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeInstanceNewConnectionsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancePacketsRequest extends $tea.Model {
  /**
   * @remarks
   * The end time. The time follows the ISO 8601 standard and UTC time is used. Format: YYYY-MM-DDThh:mm:ssZ
   * 
   * This parameter is required.
   * 
   * @example
   * 2022-05-24T10:14:53Z
   */
  endTime?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * apigateway-cn-2r426lavr001
   */
  instanceId?: string;
  /**
   * @remarks
   * The statistical metric. Valid values:
   * 
   * *   Maximum
   * *   Minimum
   * *   Average
   * 
   * This parameter is required.
   * 
   * @example
   * Maximum
   */
  sbcName?: string;
  securityToken?: string;
  /**
   * @remarks
   * The start time. The time follows the ISO 8601 standard and UTC time is used. Format: YYYY-MM-DDThh:mm:ssZ
   * 
   * This parameter is required.
   * 
   * @example
   * 2022-05-18T01:14:26Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      instanceId: 'InstanceId',
      sbcName: 'SbcName',
      securityToken: 'SecurityToken',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      instanceId: 'string',
      sbcName: 'string',
      securityToken: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancePacketsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The list of inbound and outbound data packets in the instance.
   */
  instancePackets?: DescribeInstancePacketsResponseBodyInstancePackets;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ004
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      instancePackets: 'InstancePackets',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instancePackets: DescribeInstancePacketsResponseBodyInstancePackets,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancePacketsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeInstancePacketsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeInstancePacketsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceQpsRequest extends $tea.Model {
  /**
   * @remarks
   * The end time. The time follows the ISO 8601 standard and UTC time is used. Format: YYYY-MM-DDThh:mm:ssZ
   * 
   * This parameter is required.
   * 
   * @example
   * 2022-03-29T06:25:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * apigateway-bj-6c219f1fd5d4
   */
  instanceId?: string;
  securityToken?: string;
  /**
   * @remarks
   * The environment in which the API is requested. Valid values:
   * 
   * *   **RELEASE**: the production environment
   * *   **PRE**: the pre-release environment
   * *   **TEST**: the test environment
   * 
   * This parameter is required.
   * 
   * @example
   * RELEASE
   */
  stageName?: string;
  /**
   * @remarks
   * The start time. The time follows the ISO 8601 standard and UTC time is used. Format: YYYY-MM-DDThh:mm:ssZ
   * 
   * This parameter is required.
   * 
   * @example
   * 2022-02-10T06:03:47Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      instanceId: 'InstanceId',
      securityToken: 'SecurityToken',
      stageName: 'StageName',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      instanceId: 'string',
      securityToken: 'string',
      stageName: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceQpsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The list of requests sent to the APIs in the instance.
   */
  instanceQps?: DescribeInstanceQpsResponseBodyInstanceQps;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ004
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceQps: 'InstanceQps',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceQps: DescribeInstanceQpsResponseBodyInstanceQps,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceQpsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeInstanceQpsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeInstanceQpsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceSlbConnectRequest extends $tea.Model {
  /**
   * @remarks
   * The end time. The time follows the ISO 8601 standard and UTC time is used. Format: YYYY-MM-DDThh:mm:ssZ
   * 
   * This parameter is required.
   * 
   * @example
   * 2022-09-15T15:07:06Z
   */
  endTime?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * apigateway-sz-1574cc7c5a31
   */
  instanceId?: string;
  /**
   * @remarks
   * The statistical metric. Valid values:
   * 
   * *   Maximum
   * *   Minimum
   * *   Average
   * 
   * This parameter is required.
   * 
   * @example
   * Maximum
   */
  sbcName?: string;
  securityToken?: string;
  /**
   * @remarks
   * The start time. The time follows the ISO 8601 standard and UTC time is used. Format: YYYY-MM-DDThh:mm:ssZ
   * 
   * This parameter is required.
   * 
   * @example
   * 2022-09-01T02:09:33Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      instanceId: 'InstanceId',
      sbcName: 'SbcName',
      securityToken: 'SecurityToken',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      instanceId: 'string',
      sbcName: 'string',
      securityToken: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceSlbConnectResponseBody extends $tea.Model {
  /**
   * @remarks
   * The list of concurrent connections in the instance.
   */
  instanceSlbConnect?: DescribeInstanceSlbConnectResponseBodyInstanceSlbConnect;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * E7FE7172-AA75-5880-B6F7-C00893E9BC06
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceSlbConnect: 'InstanceSlbConnect',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceSlbConnect: DescribeInstanceSlbConnectResponseBodyInstanceSlbConnect,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceSlbConnectResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeInstanceSlbConnectResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeInstanceSlbConnectResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTrafficRequest extends $tea.Model {
  /**
   * @remarks
   * The end time. The time follows the ISO 8601 standard and UTC time is used. Format: YYYY-MM-DDThh:mm:ssZ
   * 
   * This parameter is required.
   * 
   * @example
   * 2022-04-01T06:34:03Z
   */
  endTime?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * apigateway-cn-2r426lavr001
   */
  instanceId?: string;
  securityToken?: string;
  /**
   * @remarks
   * The environment in which the API runs. Valid values:
   * 
   * *   **RELEASE**: the production environment
   * *   **PRE**: the pre-release environment
   * *   **TEST: the test environment**
   * 
   * This parameter is required.
   * 
   * @example
   * RELEASE
   */
  stageName?: string;
  /**
   * @remarks
   * The start time. The time follows the ISO 8601 standard and UTC time is used. Format: YYYY-MM-DDThh:mm:ssZ
   * 
   * This parameter is required.
   * 
   * @example
   * 2022-03-31T03:42:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      instanceId: 'InstanceId',
      securityToken: 'SecurityToken',
      stageName: 'StageName',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      instanceId: 'string',
      securityToken: 'string',
      stageName: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTrafficResponseBody extends $tea.Model {
  /**
   * @remarks
   * The traffic consumed by the requests and responses in the instance.
   */
  instanceTraffic?: DescribeInstanceTrafficResponseBodyInstanceTraffic;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ004
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceTraffic: 'InstanceTraffic',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceTraffic: DescribeInstanceTrafficResponseBodyInstanceTraffic,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTrafficResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeInstanceTrafficResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeInstanceTrafficResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesRequest extends $tea.Model {
  /**
   * @remarks
   * Specifies whether tag authorization is enabled.
   * 
   * @example
   * false
   */
  enableTagAuthorization?: boolean;
  /**
   * @remarks
   * The instance ID. If you do not specify this parameter, all instances are returned.
   * 
   * @example
   * api-shared-vpc-001
   */
  instanceId?: string;
  /**
   * @remarks
   * The language in which you want the description of the system policy to be returned. Valid values:
   * 
   * *   en: English
   * *   zh: Chinese
   * *   ja: Japanese
   * 
   * @example
   * zh
   */
  language?: string;
  securityToken?: string;
  /**
   * @remarks
   * The tag that is bound to the instance.
   */
  tag?: DescribeInstancesRequestTag[];
  static names(): { [key: string]: string } {
    return {
      enableTagAuthorization: 'EnableTagAuthorization',
      instanceId: 'InstanceId',
      language: 'Language',
      securityToken: 'SecurityToken',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enableTagAuthorization: 'boolean',
      instanceId: 'string',
      language: 'string',
      securityToken: 'string',
      tag: { 'type': 'array', 'itemType': DescribeInstancesRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the instances.
   */
  instances?: DescribeInstancesResponseBodyInstances;
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * CEB6EC62-B6C7-5082-A45A-45A204724AC2
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      instances: 'Instances',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instances: DescribeInstancesResponseBodyInstances,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeInstancesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeIpControlPolicyItemsRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the ACL. The ID is unique.
   * 
   * @example
   * 7ea91319a34d48a09b5c9c871d9768b1
   */
  ipControlId?: string;
  /**
   * @remarks
   * The number of the page to return. Pages start from page 1. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Maximum value: 100. Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the policy.
   * 
   * @example
   * P151617000829241
   */
  policyItemId?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      ipControlId: 'IpControlId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      policyItemId: 'PolicyItemId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ipControlId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      policyItemId: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeIpControlPolicyItemsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about policies. The information is an array of IpControlPolicyItem data.
   */
  ipControlPolicyItems?: DescribeIpControlPolicyItemsResponseBodyIpControlPolicyItems;
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ004
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of returned entries.
   * 
   * @example
   * 2
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      ipControlPolicyItems: 'IpControlPolicyItems',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ipControlPolicyItems: DescribeIpControlPolicyItemsResponseBodyIpControlPolicyItems,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeIpControlPolicyItemsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeIpControlPolicyItemsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeIpControlPolicyItemsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeIpControlsRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the ACL. The ID is unique.
   * 
   * @example
   * 7ea91319a34d48a09b5c9c871d9768b1
   */
  ipControlId?: string;
  /**
   * @remarks
   * The name of the ACL.
   * 
   * @example
   * ACL test
   */
  ipControlName?: string;
  /**
   * @remarks
   * The type of the ACL. Valid values:
   * 
   * *   **ALLOW**: a whitelist
   * *   **REFUSE**: a blacklist
   * 
   * @example
   * ALLOW
   */
  ipControlType?: string;
  /**
   * @remarks
   * The number of the page to return. Pages start from page 1. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Maximum value: 100. Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      ipControlId: 'IpControlId',
      ipControlName: 'IpControlName',
      ipControlType: 'IpControlType',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ipControlId: 'string',
      ipControlName: 'string',
      ipControlType: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeIpControlsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the ACL. The information is an array that consists of IpControlInfo data. The information does not include specific policies.
   */
  ipControlInfos?: DescribeIpControlsResponseBodyIpControlInfos;
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ004
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of returned entries.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      ipControlInfos: 'IpControlInfos',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ipControlInfos: DescribeIpControlsResponseBodyIpControlInfos,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeIpControlsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeIpControlsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeIpControlsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLogConfigRequest extends $tea.Model {
  /**
   * @example
   * PROVIDER
   */
  logType?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      logType: 'LogType',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logType: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLogConfigResponseBody extends $tea.Model {
  logInfos?: DescribeLogConfigResponseBodyLogInfos;
  /**
   * @example
   * E3BC2706-ABDB-5B64-A12F-08DFD9E3F339
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      logInfos: 'LogInfos',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logInfos: DescribeLogConfigResponseBodyLogInfos,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLogConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeLogConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLogConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMarketRemainsQuotaRequest extends $tea.Model {
  /**
   * @remarks
   * The custom domain name.
   * 
   * This parameter is required.
   * 
   * @example
   * *.demo.com
   */
  domainName?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMarketRemainsQuotaResponseBody extends $tea.Model {
  /**
   * @remarks
   * The remaining quota.
   * 
   * @example
   * 1000
   */
  remainsQuota?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * E7FE7172-AA75-5880-B6F7-C00893E9BC06
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      remainsQuota: 'RemainsQuota',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      remainsQuota: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMarketRemainsQuotaResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeMarketRemainsQuotaResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeMarketRemainsQuotaResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeModelsRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the API group.
   * 
   * This parameter is required.
   * 
   * @example
   * 30e792398d6c4569b04c0e53a3494381
   */
  groupId?: string;
  /**
   * @remarks
   * The ID of the model.
   * 
   * @example
   * 123
   */
  modelId?: string;
  /**
   * @remarks
   * The name of the model.
   * 
   * @example
   * Test
   */
  modelName?: string;
  /**
   * @remarks
   * The number of the page to return. Pages start from page 1. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Maximum value: 100. Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The tag of objects that match the rule. You can specify multiple tags.
   */
  tag?: DescribeModelsRequestTag[];
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      modelId: 'ModelId',
      modelName: 'ModelName',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      modelId: 'string',
      modelName: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      tag: { 'type': 'array', 'itemType': DescribeModelsRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeModelsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned information about models. It is an array consisting of ModelDetail data.
   */
  modelDetails?: DescribeModelsResponseBodyModelDetails;
  /**
   * @remarks
   * The page number of the page to return.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 40306469-2FB5-417A-B723-AF1F4A4FA204
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of returned entries.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      modelDetails: 'ModelDetails',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      modelDetails: DescribeModelsResponseBodyModelDetails,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeModelsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeModelsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeModelsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePluginApisRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the API.
   * 
   * @example
   * c6b0dd188b0e4e408e12f926********
   */
  apiId?: string;
  /**
   * @remarks
   * The name of the API.
   * 
   * @example
   * API
   */
  apiName?: string;
  /**
   * @remarks
   * The description of the API.
   * 
   * @example
   * API description
   */
  description?: string;
  /**
   * @remarks
   * The ID of the API group.
   * 
   * @example
   * 231a4bb81ee94da785733c29********
   */
  groupId?: string;
  /**
   * @remarks
   * The request HTTP method of the API.
   * 
   * @example
   * GET
   */
  method?: string;
  /**
   * @remarks
   * The number of the page to return. Pages start from page 1. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * Default value:10.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The request path of the API.
   * 
   * @example
   * /sendVerifyCode
   */
  path?: string;
  /**
   * @remarks
   * The ID of the gateway plug-in.
   * 
   * This parameter is required.
   * 
   * @example
   * bf6583efcef44c51adb00c4e********
   */
  pluginId?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      apiName: 'ApiName',
      description: 'Description',
      groupId: 'GroupId',
      method: 'Method',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      path: 'Path',
      pluginId: 'PluginId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'string',
      apiName: 'string',
      description: 'string',
      groupId: 'string',
      method: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      path: 'string',
      pluginId: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePluginApisResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about APIs.
   */
  apiSummarys?: DescribePluginApisResponseBodyApiSummarys;
  /**
   * @remarks
   * The page number of the page to return.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * F9C5C4A5-BC6C-57A3-839F-AB08********
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of returned entries.
   * 
   * @example
   * 7
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      apiSummarys: 'ApiSummarys',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiSummarys: DescribePluginApisResponseBodyApiSummarys,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePluginApisResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribePluginApisResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribePluginApisResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePluginSchemasRequest extends $tea.Model {
  /**
   * @example
   * en
   */
  language?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      language: 'Language',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      language: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePluginSchemasResponseBody extends $tea.Model {
  pluginSchemas?: DescribePluginSchemasResponseBodyPluginSchemas;
  /**
   * @example
   * 2D39D1B3-8548-508A-9CE2-7F4A3F2A7989
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      pluginSchemas: 'PluginSchemas',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pluginSchemas: DescribePluginSchemasResponseBodyPluginSchemas,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePluginSchemasResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribePluginSchemasResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribePluginSchemasResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePluginTemplatesRequest extends $tea.Model {
  /**
   * @remarks
   * The language that is used to return the description of the system policy. Valid values:
   * 
   * *   en: English
   * *   zh-CN: Chinese.
   * *   ja: Japanese
   * 
   * @example
   * zh
   */
  language?: string;
  /**
   * @remarks
   * The name of the plug-in.
   * 
   * @example
   * jwtAuth
   */
  pluginName?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      language: 'Language',
      pluginName: 'PluginName',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      language: 'string',
      pluginName: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePluginTemplatesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * EF924FE4-2EDD-4CD3-89EC-34E4708574E7
   */
  requestId?: string;
  /**
   * @remarks
   * The templates.
   */
  templates?: DescribePluginTemplatesResponseBodyTemplates;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      templates: 'Templates',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      templates: DescribePluginTemplatesResponseBodyTemplates,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePluginTemplatesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribePluginTemplatesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribePluginTemplatesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePluginsRequest extends $tea.Model {
  /**
   * @remarks
   * The number of the page to return. Pages start from page 1. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Maximum value: 100. Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the plug-in.
   * 
   * @example
   * a96926e82f994915a8da40a119374537
   */
  pluginId?: string;
  /**
   * @remarks
   * The name of the plug-in.
   * 
   * @example
   * testPlugin
   */
  pluginName?: string;
  /**
   * @remarks
   * The business type of the plug-in.
   * 
   * @example
   * cors
   */
  pluginType?: string;
  securityToken?: string;
  /**
   * @remarks
   * The tag of objects that match the lifecycle rule. You can specify multiple tags.
   * 
   * @example
   * Key， Value
   */
  tag?: DescribePluginsRequestTag[];
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      pluginId: 'PluginId',
      pluginName: 'PluginName',
      pluginType: 'PluginType',
      securityToken: 'SecurityToken',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      pluginId: 'string',
      pluginName: 'string',
      pluginType: 'string',
      securityToken: 'string',
      tag: { 'type': 'array', 'itemType': DescribePluginsRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePluginsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The returned information about the plug-in. It is an array consisting of PluginAttribute data.
   */
  plugins?: DescribePluginsResponseBodyPlugins;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 46373DC4-19F1-4DC8-8C31-1107289BB5E0
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of returned entries.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      plugins: 'Plugins',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      plugins: DescribePluginsResponseBodyPlugins,
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePluginsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribePluginsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribePluginsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePluginsByApiRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the API.
   * 
   * This parameter is required.
   * 
   * @example
   * 93f4ead4080c4b2da70b7f81f50ae459
   */
  apiId?: string;
  /**
   * @remarks
   * The ID of the group to which the API belongs.
   * 
   * This parameter is required.
   * 
   * @example
   * 3c7a38392e764718ad7673e7b7f535d4
   */
  groupId?: string;
  /**
   * @remarks
   * The number of the page to return. Pages start from page 1. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  securityToken?: string;
  /**
   * @remarks
   * The environment in which the API is running. Valid values:
   * 
   * *   **RELEASE**: production
   * *   **PRE**: staging
   * *   **TEST**: test
   * 
   * This parameter is required.
   * 
   * @example
   * RELEASE
   */
  stageName?: string;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      groupId: 'GroupId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      securityToken: 'SecurityToken',
      stageName: 'StageName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'string',
      groupId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      securityToken: 'string',
      stageName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePluginsByApiResponseBody extends $tea.Model {
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The plug-in information. The information is an array that consists of PluginAttribute data.
   */
  plugins?: DescribePluginsByApiResponseBodyPlugins;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 46373DC4-19F1-4DC8-8C31-1107289BB5E0
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of returned entries.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      plugins: 'Plugins',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      plugins: DescribePluginsByApiResponseBodyPlugins,
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePluginsByApiResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribePluginsByApiResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribePluginsByApiResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePurchasedApiGroupRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the API group. This ID is generated by the system and globally unique.
   * 
   * This parameter is required.
   * 
   * @example
   * 102b631ae1094e33a77c45312226184e
   */
  groupId?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePurchasedApiGroupResponseBody extends $tea.Model {
  /**
   * @remarks
   * The description of the API group.
   * 
   * @example
   * api group description
   */
  description?: string;
  /**
   * @remarks
   * The list of domain names.
   */
  domains?: DescribePurchasedApiGroupResponseBodyDomains;
  /**
   * @remarks
   * The ID of the API group.
   * 
   * @example
   * 48977d7b96074966a7c9c2a8872d7e06
   */
  groupId?: string;
  /**
   * @remarks
   * The name of the API group.
   * 
   * @example
   * Weather
   */
  groupName?: string;
  /**
   * @remarks
   * The time when the API group was purchased.
   * 
   * @example
   * 2021-12-19T00:00:00
   */
  purchasedTime?: string;
  /**
   * @remarks
   * The region where the API group is located.
   * 
   * @example
   * cn-qingdao
   */
  regionId?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 61A16D46-EC04-5288-8A18-811B0F536CC2
   */
  requestId?: string;
  /**
   * @remarks
   * The status of the API group.
   * 
   * *   **NORMAL**: The API group is normal.
   * *   **DELETE**: The API group is deleted.
   * 
   * @example
   * NORMAL
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      domains: 'Domains',
      groupId: 'GroupId',
      groupName: 'GroupName',
      purchasedTime: 'PurchasedTime',
      regionId: 'RegionId',
      requestId: 'RequestId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      domains: DescribePurchasedApiGroupResponseBodyDomains,
      groupId: 'string',
      groupName: 'string',
      purchasedTime: 'string',
      regionId: 'string',
      requestId: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePurchasedApiGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribePurchasedApiGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribePurchasedApiGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePurchasedApiGroupsRequest extends $tea.Model {
  /**
   * @remarks
   * The number of the page to return. Pages start from page 1. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Maximum value: 100. Default value: 10.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePurchasedApiGroupsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned on each page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The attributes of the API group.
   */
  purchasedApiGroupAttributes?: DescribePurchasedApiGroupsResponseBodyPurchasedApiGroupAttributes;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 36BBBAD4-1CFB-489F-841A-8CA52EEA787E
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 2
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      purchasedApiGroupAttributes: 'PurchasedApiGroupAttributes',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      purchasedApiGroupAttributes: DescribePurchasedApiGroupsResponseBodyPurchasedApiGroupAttributes,
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePurchasedApiGroupsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribePurchasedApiGroupsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribePurchasedApiGroupsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePurchasedApisRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the API.
   * 
   * @example
   * 3b81fd160f5645e097cc8855d75a1cf6
   */
  apiId?: string;
  /**
   * @remarks
   * The name of the API.
   * 
   * @example
   * Cz88IpQuery
   */
  apiName?: string;
  /**
   * @remarks
   * The ID of the API group.
   * 
   * @example
   * d27ad517be5f4c95ac3631780a8f4d50
   */
  groupId?: string;
  /**
   * @remarks
   * The page number of the page to return.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  securityToken?: string;
  /**
   * @remarks
   * The name of the runtime environment. Valid values:
   * 
   * *   **RELEASE**
   * *   **PRE**
   * *   **TEST**
   * 
   * @example
   * RELEASE
   */
  stageName?: string;
  /**
   * @remarks
   * Specifies whether the API is public. Valid values:
   * 
   * *   **PUBLIC**: indicates that the API is public. If you set this parameter to PUBLIC, this API is displayed on the API List page in the console for all users after the API is published to the production environment.
   * *   **PRIVATE**: indicates that the API is private. If you set this parameter to PRIVATE, this API is not displayed in Alibaba Cloud Marketplace after the API group to which this API belongs is made available.
   * 
   * @example
   * PUBLIC
   */
  visibility?: string;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      apiName: 'ApiName',
      groupId: 'GroupId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      securityToken: 'SecurityToken',
      stageName: 'StageName',
      visibility: 'Visibility',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'string',
      apiName: 'string',
      groupId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      securityToken: 'string',
      stageName: 'string',
      visibility: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePurchasedApisResponseBody extends $tea.Model {
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned on each page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The monitoring information about API call delays. The returned information is an array consisting of purchased APIs.
   */
  purchasedApis?: DescribePurchasedApisResponseBodyPurchasedApis;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CE5722A6-AE78-4741-A9B0-6C817D360510
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of returned entries.
   * 
   * @example
   * 20
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      purchasedApis: 'PurchasedApis',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      purchasedApis: DescribePurchasedApisResponseBodyPurchasedApis,
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePurchasedApisResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribePurchasedApisResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribePurchasedApisResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRegionsRequest extends $tea.Model {
  /**
   * @remarks
   * The language in which you want to return the descriptions of the access control policies. Valid values:
   * 
   * *   zh-CN (default value): Chinese
   * *   en: English
   * *   ja: Japanese
   * 
   * @example
   * zh
   */
  language?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      language: 'Language',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      language: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRegionsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned region information. It is an array that consists of Region data.
   * 
   * @example
   * cn-huhehaote
   */
  regions?: DescribeRegionsResponseBodyRegions;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 36BBBAD4-1CFB-489F-841A-8CA52EEA787E
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      regions: 'Regions',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regions: DescribeRegionsResponseBodyRegions,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRegionsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeRegionsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeRegionsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSignaturesRequest extends $tea.Model {
  /**
   * @remarks
   * The number of the page to return. Pages start from page 1. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Maximum value: 100. Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  securityToken?: string;
  /**
   * @remarks
   * The IDs of the keys to query.
   * 
   * @example
   * dd05f1c54d6749eda95f9fa6d491449a
   */
  signatureId?: string;
  /**
   * @remarks
   * The names of the keys to query.
   * 
   * @example
   * backendsignature
   */
  signatureName?: string;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      securityToken: 'SecurityToken',
      signatureId: 'SignatureId',
      signatureName: 'SignatureName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      securityToken: 'string',
      signatureId: 'string',
      signatureName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSignaturesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ004
   */
  requestId?: string;
  /**
   * @remarks
   * The returned signature information. It is an array consisting of SignatureInfo data.
   */
  signatureInfos?: DescribeSignaturesResponseBodySignatureInfos;
  /**
   * @remarks
   * The total number of returned entries.
   * 
   * @example
   * 20
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      signatureInfos: 'SignatureInfos',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      signatureInfos: DescribeSignaturesResponseBodySignatureInfos,
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSignaturesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeSignaturesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSignaturesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSignaturesByApiRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the API.
   * 
   * This parameter is required.
   * 
   * @example
   * 3b81fd160f5645e097cc8855d75a1cf6
   */
  apiId?: string;
  /**
   * @remarks
   * The ID of the group to which the API belongs.
   * 
   * This parameter is required.
   * 
   * @example
   * 0009db9c828549768a200320714b8930
   */
  groupId?: string;
  securityToken?: string;
  /**
   * @remarks
   * The runtime environment. Valid values:
   * 
   * *   **RELEASE**
   * *   **TEST**
   * 
   * This parameter is required.
   * 
   * @example
   * TEST
   */
  stageName?: string;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      groupId: 'GroupId',
      securityToken: 'SecurityToken',
      stageName: 'StageName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'string',
      groupId: 'string',
      securityToken: 'string',
      stageName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSignaturesByApiResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ004
   */
  requestId?: string;
  /**
   * @remarks
   * The returned signature key information. It is an array consisting of SignatureItem data.
   */
  signatures?: DescribeSignaturesByApiResponseBodySignatures;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      signatures: 'Signatures',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      signatures: DescribeSignaturesByApiResponseBodySignatures,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSignaturesByApiResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeSignaturesByApiResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSignaturesByApiResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSummaryDataRequest extends $tea.Model {
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSummaryDataResponseBody extends $tea.Model {
  /**
   * @remarks
   * The number of subscription dedicated instances that expire in 14 days or less.
   * 
   * @example
   * 1
   */
  expireInstanceNum?: number;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  region?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ004
   */
  requestId?: string;
  /**
   * @remarks
   * The number of APIs.
   * 
   * @example
   * 10
   */
  usageApiNum?: number;
  /**
   * @remarks
   * The number of API groups.
   * 
   * @example
   * 1
   */
  usageGroupNum?: number;
  /**
   * @remarks
   * The number of running dedicated instances.
   * 
   * @example
   * 1
   */
  usageInstanceNum?: number;
  static names(): { [key: string]: string } {
    return {
      expireInstanceNum: 'ExpireInstanceNum',
      region: 'Region',
      requestId: 'RequestId',
      usageApiNum: 'UsageApiNum',
      usageGroupNum: 'UsageGroupNum',
      usageInstanceNum: 'UsageInstanceNum',
    };
  }

  static types(): { [key: string]: any } {
    return {
      expireInstanceNum: 'number',
      region: 'string',
      requestId: 'string',
      usageApiNum: 'number',
      usageGroupNum: 'number',
      usageInstanceNum: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSummaryDataResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeSummaryDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSummaryDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSystemParametersRequest extends $tea.Model {
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSystemParametersResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0CCDF65E-6050-412D-AD68-FA3D9196836C
   */
  requestId?: string;
  /**
   * @remarks
   * The returned information about system parameters. It is an array that consists of SystemParam data.
   */
  systemParams?: DescribeSystemParametersResponseBodySystemParams;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      systemParams: 'SystemParams',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      systemParams: DescribeSystemParametersResponseBodySystemParams,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSystemParametersResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeSystemParametersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSystemParametersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTrafficControlsRequest extends $tea.Model {
  /**
   * @remarks
   * The specified API ID. This parameter must be specified together with GroupId and StageName.
   * 
   * @example
   * 3b81fd160f5645e097cc8855d75a1cf6
   */
  apiId?: string;
  /**
   * @remarks
   * The specified group ID. This parameter must be specified together with ApiId and StageName.
   * 
   * @example
   * 0009db9c828549768a200320714b8930
   */
  groupId?: string;
  /**
   * @remarks
   * The number of the page to return. Pages start from page 1. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Maximum value: 100. Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The security token included in the WebSocket request header. The system uses this token to authenticate the request.
   * 
   * @example
   * 436fa39b-b3b9-40c5-ae5d-ce3e000e38c5
   */
  securityToken?: string;
  /**
   * @remarks
   * The environment name. This parameter must be specified together with GroupId and ApiId. Valid values:********
   * 
   * *   **RELEASE**
   * *   **TEST**
   * 
   * @example
   * RELEASE
   */
  stageName?: string;
  /**
   * @remarks
   * The ID of the throttling policy.
   * 
   * @example
   * tf123456
   */
  trafficControlId?: string;
  /**
   * @remarks
   * The name of the throttling policy.
   * 
   * @example
   * ThrottlingTest
   */
  trafficControlName?: string;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      groupId: 'GroupId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      securityToken: 'SecurityToken',
      stageName: 'StageName',
      trafficControlId: 'TrafficControlId',
      trafficControlName: 'TrafficControlName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'string',
      groupId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      securityToken: 'string',
      stageName: 'string',
      trafficControlId: 'string',
      trafficControlName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTrafficControlsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 93D91A99-F093-4596-87BA-3C4FBFD3FD8A
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of returned entries.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  /**
   * @remarks
   * The returned throttling policy information. It is an array consisting of TrafficControl data.
   */
  trafficControls?: DescribeTrafficControlsResponseBodyTrafficControls;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
      trafficControls: 'TrafficControls',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
      trafficControls: DescribeTrafficControlsResponseBodyTrafficControls,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTrafficControlsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeTrafficControlsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeTrafficControlsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTrafficControlsByApiRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the API.
   * 
   * This parameter is required.
   * 
   * @example
   * 3b81fd160f5645e097cc8855d75a1cf6
   */
  apiId?: string;
  /**
   * @remarks
   * The ID of the group to which the API to be queried belongs.
   * 
   * This parameter is required.
   * 
   * @example
   * 0009db9c828549768a200320714b8930
   */
  groupId?: string;
  /**
   * @remarks
   * The security token included in the WebSocket request header. The system uses this token to authenticate the request.
   * 
   * @example
   * 7c51b234-48d3-44e1-9b36-e2ddccc738e3
   */
  securityToken?: string;
  /**
   * @remarks
   * The runtime environment of the API. Valid values:
   * 
   * *   **RELEASE**
   * *   **TEST**
   * 
   * This parameter is required.
   * 
   * @example
   * RELEASE
   */
  stageName?: string;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      groupId: 'GroupId',
      securityToken: 'SecurityToken',
      stageName: 'StageName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'string',
      groupId: 'string',
      securityToken: 'string',
      stageName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTrafficControlsByApiResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ004
   */
  requestId?: string;
  /**
   * @remarks
   * The returned throttling policy information. It is an array consisting of TrafficControlItem data.
   */
  trafficControlItems?: DescribeTrafficControlsByApiResponseBodyTrafficControlItems;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      trafficControlItems: 'TrafficControlItems',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      trafficControlItems: DescribeTrafficControlsByApiResponseBodyTrafficControlItems,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTrafficControlsByApiResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeTrafficControlsByApiResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeTrafficControlsByApiResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUpdateBackendTaskRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 4e13c3e0c44c4a4ebb5231264eeb9bc1
   */
  operationUid?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      operationUid: 'OperationUid',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      operationUid: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUpdateBackendTaskResponseBody extends $tea.Model {
  apiUpdateBackendResults?: DescribeUpdateBackendTaskResponseBodyApiUpdateBackendResults;
  /**
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ016
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      apiUpdateBackendResults: 'ApiUpdateBackendResults',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiUpdateBackendResults: DescribeUpdateBackendTaskResponseBodyApiUpdateBackendResults,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUpdateBackendTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeUpdateBackendTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeUpdateBackendTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUpdateVpcInfoTaskRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 7d341787517a47afaaef9cc1bdb7acce
   */
  operationUid?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      operationUid: 'OperationUid',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      operationUid: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUpdateVpcInfoTaskResponseBody extends $tea.Model {
  apiUpdateVpcInfoResults?: DescribeUpdateVpcInfoTaskResponseBodyApiUpdateVpcInfoResults;
  /**
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ015
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      apiUpdateVpcInfoResults: 'ApiUpdateVpcInfoResults',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiUpdateVpcInfoResults: DescribeUpdateVpcInfoTaskResponseBodyApiUpdateVpcInfoResults,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUpdateVpcInfoTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeUpdateVpcInfoTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeUpdateVpcInfoTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVpcAccessesRequest extends $tea.Model {
  /**
   * @remarks
   * Whether to conduct precise queries
   * 
   * @example
   * false
   */
  accurateQuery?: boolean;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * 10.199.26.***
   */
  instanceId?: string;
  /**
   * @remarks
   * The name of the authorization. The name must be unique.
   * 
   * @example
   * wuying-edm-svc
   */
  name?: string;
  /**
   * @remarks
   * The number of the page to return. Pages start from page 1. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Maximum value: 100. Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The service port.
   * 
   * @example
   * 8080
   */
  port?: string;
  securityToken?: string;
  /**
   * @remarks
   * The port number.
   */
  tag?: DescribeVpcAccessesRequestTag[];
  /**
   * @remarks
   * The ID of the VPC authorization.
   * 
   * @example
   * vpc-*****ssds24
   */
  vpcAccessId?: string;
  /**
   * @remarks
   * The ID of the VPC.
   * 
   * @example
   * vpc-uf657qec7lx42paw3qxxx
   */
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      accurateQuery: 'AccurateQuery',
      instanceId: 'InstanceId',
      name: 'Name',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      port: 'Port',
      securityToken: 'SecurityToken',
      tag: 'Tag',
      vpcAccessId: 'VpcAccessId',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accurateQuery: 'boolean',
      instanceId: 'string',
      name: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      port: 'string',
      securityToken: 'string',
      tag: { 'type': 'array', 'itemType': DescribeVpcAccessesRequestTag },
      vpcAccessId: 'string',
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVpcAccessesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned on each page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 8883AC74-259D-4C0B-99FC-0B7F9A588B2F
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of returned entries.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  /**
   * @remarks
   * The information about the VPC access authorization. The information is an array consisting of VpcAccessAttribute data.
   */
  vpcAccessAttributes?: DescribeVpcAccessesResponseBodyVpcAccessAttributes;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
      vpcAccessAttributes: 'VpcAccessAttributes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
      vpcAccessAttributes: DescribeVpcAccessesResponseBodyVpcAccessAttributes,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVpcAccessesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeVpcAccessesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeVpcAccessesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeZonesRequest extends $tea.Model {
  /**
   * @remarks
   * The language in which you want to use to return the description of the system policy. Valid values:
   * 
   * *   en: English
   * *   zh-CN: Chinese
   * *   ja: Japanese
   * 
   * @example
   * zh
   */
  language?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      language: 'Language',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      language: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeZonesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 9324B68F-9863-5722-A0FD-0798E2B02A0E
   */
  requestId?: string;
  /**
   * @remarks
   * The zones available in the current region.
   * 
   * @example
   * {\\"Zone\\": [{\\"ZoneId\\": \\"cn-hangzhou-i\\"}]}
   */
  zones?: DescribeZonesResponseBodyZones;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      zones: 'Zones',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      zones: DescribeZonesResponseBodyZones,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeZonesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeZonesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeZonesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DetachApiProductRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the API product.
   * 
   * This parameter is required.
   * 
   * @example
   * 117b7a64a8b3f064eaa4a47ac62aac5e
   */
  apiProductId?: string;
  /**
   * @remarks
   * The APIs that you want to detach from the API product.
   * 
   * This parameter is required.
   */
  apis?: DetachApiProductRequestApis[];
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      apiProductId: 'ApiProductId',
      apis: 'Apis',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiProductId: 'string',
      apis: { 'type': 'array', 'itemType': DetachApiProductRequestApis },
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DetachApiProductResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 98E4A7DC-1EA6-5E6A-ACFE-91B60CE7D4BB
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DetachApiProductResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DetachApiProductResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DetachApiProductResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DetachPluginRequest extends $tea.Model {
  /**
   * @example
   * 19a2846d8e8541c788c6be740035eb68
   */
  apiId?: string;
  /**
   * @example
   * 93b87279e54c4c0baeb7113cdf9c67f5
   */
  groupId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 05df2b52a3644a3a8b1935ab8ab59e9d
   */
  pluginId?: string;
  securityToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * RELEASE
   */
  stageName?: string;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      groupId: 'GroupId',
      pluginId: 'PluginId',
      securityToken: 'SecurityToken',
      stageName: 'StageName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'string',
      groupId: 'string',
      pluginId: 'string',
      securityToken: 'string',
      stageName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DetachPluginResponseBody extends $tea.Model {
  /**
   * @example
   * AD00F8C0-311B-54A9-ADE2-2436771012DA
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DetachPluginResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DetachPluginResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DetachPluginResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableInstanceAccessControlRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the access control policy.
   * 
   * This parameter is required.
   * 
   * @example
   * acl-grgqc0mnuhkqciwtam
   */
  aclId?: string;
  /**
   * @remarks
   * The IP version. Valid values: **ipv4** and **ipv6**.
   * 
   * @example
   * ipv4
   */
  addressIPVersion?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * apigateway-cn-v6419k43xxxxx
   */
  instanceId?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      aclId: 'AclId',
      addressIPVersion: 'AddressIPVersion',
      instanceId: 'InstanceId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aclId: 'string',
      addressIPVersion: 'string',
      instanceId: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableInstanceAccessControlResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ016
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableInstanceAccessControlResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DisableInstanceAccessControlResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DisableInstanceAccessControlResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DissociateInstanceWithPrivateDNSRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * apigateway-hz-ead4f4b0bac8
   */
  instanceId?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  intranetDomains?: string[];
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      intranetDomains: 'IntranetDomains',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      intranetDomains: { 'type': 'array', 'itemType': 'string' },
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DissociateInstanceWithPrivateDNSShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * apigateway-hz-ead4f4b0bac8
   */
  instanceId?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  intranetDomainsShrink?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      intranetDomainsShrink: 'IntranetDomains',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      intranetDomainsShrink: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DissociateInstanceWithPrivateDNSResponseBody extends $tea.Model {
  /**
   * @example
   * 6C87A26A-6A18-4B8E-8099-705278381A2C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DissociateInstanceWithPrivateDNSResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DissociateInstanceWithPrivateDNSResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DissociateInstanceWithPrivateDNSResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DryRunSwaggerRequest extends $tea.Model {
  /**
   * @remarks
   * The Swagger text content.
   * 
   * This parameter is required.
   * 
   * @example
   * "A Swagger API definition in YAML"
   */
  data?: string;
  /**
   * @remarks
   * The Swagger text format:
   * 
   * *   json
   * *   yaml
   * 
   * This parameter is required.
   * 
   * @example
   * yaml
   */
  dataFormat?: string;
  /**
   * @remarks
   * The global condition.
   * 
   * @example
   * {}
   */
  globalCondition?: { [key: string]: any };
  /**
   * @remarks
   * The ID of the API group.
   * 
   * This parameter is required.
   * 
   * @example
   * d633cf5524f841b9950e245b191bdabf
   */
  groupId?: string;
  /**
   * @remarks
   * Specifies whether to overwrite the existing API.
   * 
   * APIs with the same HTTP request type and backend request path are considered the same.
   * 
   * This parameter is required.
   * 
   * @example
   * true
   */
  overwrite?: boolean;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      dataFormat: 'DataFormat',
      globalCondition: 'GlobalCondition',
      groupId: 'GroupId',
      overwrite: 'Overwrite',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'string',
      dataFormat: 'string',
      globalCondition: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      groupId: 'string',
      overwrite: 'boolean',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DryRunSwaggerShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The Swagger text content.
   * 
   * This parameter is required.
   * 
   * @example
   * "A Swagger API definition in YAML"
   */
  data?: string;
  /**
   * @remarks
   * The Swagger text format:
   * 
   * *   json
   * *   yaml
   * 
   * This parameter is required.
   * 
   * @example
   * yaml
   */
  dataFormat?: string;
  /**
   * @remarks
   * The global condition.
   * 
   * @example
   * {}
   */
  globalConditionShrink?: string;
  /**
   * @remarks
   * The ID of the API group.
   * 
   * This parameter is required.
   * 
   * @example
   * d633cf5524f841b9950e245b191bdabf
   */
  groupId?: string;
  /**
   * @remarks
   * Specifies whether to overwrite the existing API.
   * 
   * APIs with the same HTTP request type and backend request path are considered the same.
   * 
   * This parameter is required.
   * 
   * @example
   * true
   */
  overwrite?: boolean;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      dataFormat: 'DataFormat',
      globalConditionShrink: 'GlobalCondition',
      groupId: 'GroupId',
      overwrite: 'Overwrite',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'string',
      dataFormat: 'string',
      globalConditionShrink: 'string',
      groupId: 'string',
      overwrite: 'boolean',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DryRunSwaggerResponseBody extends $tea.Model {
  /**
   * @remarks
   * The APIs that failed to be created based on the Swagger-compliant data imported this time.
   */
  failed?: DryRunSwaggerResponseBodyFailed;
  /**
   * @remarks
   * The global condition.
   * 
   * @example
   * {}
   */
  globalCondition?: string;
  /**
   * @remarks
   * The models that failed to be imported through the Swagger-compliant data this time.
   */
  modelFailed?: DryRunSwaggerResponseBodyModelFailed;
  /**
   * @remarks
   * The models that failed to be imported through the Swagger-compliant data this time.
   */
  modelSuccess?: DryRunSwaggerResponseBodyModelSuccess;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * EF924FE4-2EDD-4CD3-89EC-34E4708574E7
   */
  requestId?: string;
  /**
   * @remarks
   * The APIs that are created based on the Swagger-compliant data imported this time.
   */
  success?: DryRunSwaggerResponseBodySuccess;
  static names(): { [key: string]: string } {
    return {
      failed: 'Failed',
      globalCondition: 'GlobalCondition',
      modelFailed: 'ModelFailed',
      modelSuccess: 'ModelSuccess',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failed: DryRunSwaggerResponseBodyFailed,
      globalCondition: 'string',
      modelFailed: DryRunSwaggerResponseBodyModelFailed,
      modelSuccess: DryRunSwaggerResponseBodyModelSuccess,
      requestId: 'string',
      success: DryRunSwaggerResponseBodySuccess,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DryRunSwaggerResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DryRunSwaggerResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DryRunSwaggerResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableInstanceAccessControlRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * acl-bp11escro2et2tioscy52
   */
  aclId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * black
   */
  aclType?: string;
  addressIPVersion?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * apigateway-cn-v6419k43xxxxx
   */
  instanceId?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      aclId: 'AclId',
      aclType: 'AclType',
      addressIPVersion: 'AddressIPVersion',
      instanceId: 'InstanceId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aclId: 'string',
      aclType: 'string',
      addressIPVersion: 'string',
      instanceId: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableInstanceAccessControlResponseBody extends $tea.Model {
  /**
   * @example
   * CE5722A6-AE78-4741-A9B0-6C817D360510
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableInstanceAccessControlResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: EnableInstanceAccessControlResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: EnableInstanceAccessControlResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportOASRequest extends $tea.Model {
  /**
   * @remarks
   * The APIs that you want to export.
   */
  apiIdList?: string[];
  /**
   * @remarks
   * The exported format:
   * 
   * *   json
   * *   yaml
   * 
   * @example
   * yaml
   */
  dataFormat?: string;
  /**
   * @remarks
   * The API group ID.
   * 
   * @example
   * 42925e7f5209438186d5560239af5xxx
   */
  groupId?: string;
  /**
   * @remarks
   * The OAS version. Valid values:
   * 
   * *   **oas2**
   * *   **oas3**
   * 
   * @example
   * oas2
   */
  oasVersion?: string;
  /**
   * @remarks
   * The number of pages in which you want to export the APIs.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  securityToken?: string;
  /**
   * @remarks
   * The environment to which the API is published. Valid values:
   * 
   * *   **RELEASE**: the production environment
   * *   **PRE**: the pre-release environment
   * *   **TEST**: the test environment
   * 
   * @example
   * RELEASE
   */
  stageName?: string;
  /**
   * @remarks
   * Specifies whether to export API Gateway extensions at the same time.
   * 
   * @example
   * true
   */
  withXExtensions?: boolean;
  static names(): { [key: string]: string } {
    return {
      apiIdList: 'ApiIdList',
      dataFormat: 'DataFormat',
      groupId: 'GroupId',
      oasVersion: 'OasVersion',
      pageNumber: 'PageNumber',
      securityToken: 'SecurityToken',
      stageName: 'StageName',
      withXExtensions: 'WithXExtensions',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiIdList: { 'type': 'array', 'itemType': 'string' },
      dataFormat: 'string',
      groupId: 'string',
      oasVersion: 'string',
      pageNumber: 'number',
      securityToken: 'string',
      stageName: 'string',
      withXExtensions: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportOASShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The APIs that you want to export.
   */
  apiIdListShrink?: string;
  /**
   * @remarks
   * The exported format:
   * 
   * *   json
   * *   yaml
   * 
   * @example
   * yaml
   */
  dataFormat?: string;
  /**
   * @remarks
   * The API group ID.
   * 
   * @example
   * 42925e7f5209438186d5560239af5xxx
   */
  groupId?: string;
  /**
   * @remarks
   * The OAS version. Valid values:
   * 
   * *   **oas2**
   * *   **oas3**
   * 
   * @example
   * oas2
   */
  oasVersion?: string;
  /**
   * @remarks
   * The number of pages in which you want to export the APIs.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  securityToken?: string;
  /**
   * @remarks
   * The environment to which the API is published. Valid values:
   * 
   * *   **RELEASE**: the production environment
   * *   **PRE**: the pre-release environment
   * *   **TEST**: the test environment
   * 
   * @example
   * RELEASE
   */
  stageName?: string;
  /**
   * @remarks
   * Specifies whether to export API Gateway extensions at the same time.
   * 
   * @example
   * true
   */
  withXExtensions?: boolean;
  static names(): { [key: string]: string } {
    return {
      apiIdListShrink: 'ApiIdList',
      dataFormat: 'DataFormat',
      groupId: 'GroupId',
      oasVersion: 'OasVersion',
      pageNumber: 'PageNumber',
      securityToken: 'SecurityToken',
      stageName: 'StageName',
      withXExtensions: 'WithXExtensions',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiIdListShrink: 'string',
      dataFormat: 'string',
      groupId: 'string',
      oasVersion: 'string',
      pageNumber: 'number',
      securityToken: 'string',
      stageName: 'string',
      withXExtensions: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportOASResponseBody extends $tea.Model {
  /**
   * @remarks
   * The Base64-encoded data of the exported Swagger file. You can obtain the file by using Base64 decoding.
   * 
   * @example
   * UEsDBBQACAAIAABc8FgAAAAAAAAAAAAAAAA...
   */
  data?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876xxxxxxxx
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportOASResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ExportOASResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ExportOASResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportOASRequest extends $tea.Model {
  /**
   * @remarks
   * The security authentication method of the API. Valid values:
   * 
   * *   **APP: Only authorized applications can call the API.**
   * 
   * *   **ANONYMOUS: The API can be anonymously called. In this mode, you must take note of the following rules:**
   * 
   *     *   All users who have obtained the API service information can call this API. API Gateway does not authenticate callers and cannot set user-specific throttling policies. If you make this API public, set API-specific throttling policies.
   * 
   * @example
   * APP
   */
  authType?: string;
  /**
   * @remarks
   * The name of the backend service.
   * 
   * @example
   * testBackendService
   */
  backendName?: string;
  /**
   * @remarks
   * The OAS-compliant text file or OSS object URL.
   * 
   * This parameter is required.
   * 
   * @example
   * swagger: "2.0"
   * info:
   *   version: "1.0.0"
   *   title: "Swagger Petstore 2.0"
   * basePath: "/"
   * schemes:
   * - "https"
   * - "http"
   * paths:
   *   /pet/findByStatus:
   *     get:
   *       tags:
   *       - "pet"
   *       summary: "Finds Pets by status"
   *       operationId: "findPetsByStatus"
   *       parameters:
   *       - name: "status"
   *         in: "query"
   *         required: true
   *         type: "array"
   *         items:
   *           type: "string"
   *           enum:
   *           - "available"
   *           - "pending"
   *           - "sold"
   *           default: "available"
   *         collectionFormat: "multi"
   *       responses:
   *         "200":
   *           description: "successful operation"
   *           schema:
   *             type: "array"
   *             items:
   *               $ref: "#/definitions/Pet"
   *         "400":
   *           description: "Invalid status value"
   * definitions:
   *   Category:
   *     type: "object"
   *     properties:
   *       id:
   *         type: "integer"
   *         format: "int64"
   *       name:
   *         type: "string"
   *   Tag:
   *     type: "object"
   *     properties:
   *       id:
   *         type: "integer"
   *         format: "int64"
   *       name:
   *         type: "string"
   *   Pet:
   *     type: "object"
   *     required:
   *     - "name"
   *     - "photoUrls"
   *     properties:
   *       id:
   *         type: "integer"
   *         format: "int64"
   *       category:
   *         $ref: "#/definitions/Category"
   *       name:
   *         type: "string"
   *         example: "doggie"
   *       photoUrls:
   *         type: "array"
   *         items:
   *           type: "string"
   *       tags:
   *         type: "array"
   *         items:
   *           $ref: "#/definitions/Tag"
   *       status:
   *         type: "string"
   *         description: "pet status in the store"
   *         enum:
   *         - "available"
   *         - "pending"
   *         - "sold"
   */
  data?: string;
  /**
   * @remarks
   * The ID of the API group.
   * 
   * This parameter is required.
   * 
   * @example
   * 08ae4aa0f95e4321849ee57f4e0b3077
   */
  groupId?: string;
  /**
   * @remarks
   * Specifies whether to ignore alerts.
   * 
   * @example
   * true
   */
  ignoreWarning?: boolean;
  /**
   * @remarks
   * The OAS version.
   * 
   * @example
   * OAS2
   */
  OASVersion?: string;
  /**
   * @remarks
   * Specifies whether to overwrite an existing API.
   * 
   * If an existing API has the same HTTP request type and backend request path as the API to be imported, the existing API is overwritten.
   * 
   * This parameter is required.
   * 
   * @example
   * true
   */
  overwrite?: boolean;
  /**
   * @remarks
   * The request mode. Valid values:
   * 
   * *   MAPPING: Parameters are mapped. Unknown parameters are filtered out.
   * *   PASSTHROUGH: Parameters are passed through.
   * 
   * @example
   * PASSTHROUGH
   */
  requestMode?: string;
  securityToken?: string;
  /**
   * @remarks
   * Specifies whether to directly import the API without performing a precheck.
   * 
   * @example
   * true
   */
  skipDryRun?: boolean;
  static names(): { [key: string]: string } {
    return {
      authType: 'AuthType',
      backendName: 'BackendName',
      data: 'Data',
      groupId: 'GroupId',
      ignoreWarning: 'IgnoreWarning',
      OASVersion: 'OASVersion',
      overwrite: 'Overwrite',
      requestMode: 'RequestMode',
      securityToken: 'SecurityToken',
      skipDryRun: 'SkipDryRun',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authType: 'string',
      backendName: 'string',
      data: 'string',
      groupId: 'string',
      ignoreWarning: 'boolean',
      OASVersion: 'string',
      overwrite: 'boolean',
      requestMode: 'string',
      securityToken: 'string',
      skipDryRun: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportOASResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error messages that appear due to the invalid data in the imported file.
   */
  errorMessages?: ImportOASResponseBodyErrorMessages;
  /**
   * @remarks
   * The APIs that failed to pass the precheck.
   */
  failedApis?: ImportOASResponseBodyFailedApis;
  /**
   * @remarks
   * The information about the models that failed to pass the precheck.
   */
  failedModels?: ImportOASResponseBodyFailedModels;
  /**
   * @remarks
   * The ID of the asynchronous API import task that was generated during the import operation. This ID is used to query the execution status of the API import task.
   * 
   * @example
   * c16a1880f5164d779f6a54f64d997cd9
   */
  operationId?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * E7FE7172-AA75-5880-B6F7-C00893E9BC06
   */
  requestId?: string;
  /**
   * @remarks
   * The information about the APIs that have passed the precheck.
   */
  successApis?: ImportOASResponseBodySuccessApis;
  /**
   * @remarks
   * The information about the models that have passed the precheck.
   */
  successModels?: ImportOASResponseBodySuccessModels;
  /**
   * @remarks
   * The warning messages that appear due to the invalid data in the imported file.
   */
  warningMessages?: ImportOASResponseBodyWarningMessages;
  static names(): { [key: string]: string } {
    return {
      errorMessages: 'ErrorMessages',
      failedApis: 'FailedApis',
      failedModels: 'FailedModels',
      operationId: 'OperationId',
      requestId: 'RequestId',
      successApis: 'SuccessApis',
      successModels: 'SuccessModels',
      warningMessages: 'WarningMessages',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorMessages: ImportOASResponseBodyErrorMessages,
      failedApis: ImportOASResponseBodyFailedApis,
      failedModels: ImportOASResponseBodyFailedModels,
      operationId: 'string',
      requestId: 'string',
      successApis: ImportOASResponseBodySuccessApis,
      successModels: ImportOASResponseBodySuccessModels,
      warningMessages: ImportOASResponseBodyWarningMessages,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportOASResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ImportOASResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ImportOASResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportSwaggerRequest extends $tea.Model {
  /**
   * @remarks
   * The Swagger text content.
   * 
   * This parameter is required.
   * 
   * @example
   * "A Swagger API definition in YAML"
   */
  data?: string;
  /**
   * @remarks
   * The Swagger text format:
   * 
   * *   json
   * *   yaml
   * 
   * This parameter is required.
   * 
   * @example
   * yaml
   */
  dataFormat?: string;
  /**
   * @remarks
   * The pre-inspection.
   * 
   * @example
   * true
   */
  dryRun?: boolean;
  /**
   * @remarks
   * The global conditions.
   * 
   * @example
   * {}
   */
  globalCondition?: { [key: string]: any };
  /**
   * @remarks
   * The ID of the API group to which the Swagger is imported.
   * 
   * This parameter is required.
   * 
   * @example
   * 0009db9c828549768a200320714b8930
   */
  groupId?: string;
  /**
   * @remarks
   * Specifies whether to overwrite the existing API.
   * 
   * APIs with the same HTTP request type and backend request path are considered the same.
   * 
   * This parameter is required.
   * 
   * @example
   * true
   */
  overwrite?: boolean;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      dataFormat: 'DataFormat',
      dryRun: 'DryRun',
      globalCondition: 'GlobalCondition',
      groupId: 'GroupId',
      overwrite: 'Overwrite',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'string',
      dataFormat: 'string',
      dryRun: 'boolean',
      globalCondition: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      groupId: 'string',
      overwrite: 'boolean',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportSwaggerShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The Swagger text content.
   * 
   * This parameter is required.
   * 
   * @example
   * "A Swagger API definition in YAML"
   */
  data?: string;
  /**
   * @remarks
   * The Swagger text format:
   * 
   * *   json
   * *   yaml
   * 
   * This parameter is required.
   * 
   * @example
   * yaml
   */
  dataFormat?: string;
  /**
   * @remarks
   * The pre-inspection.
   * 
   * @example
   * true
   */
  dryRun?: boolean;
  /**
   * @remarks
   * The global conditions.
   * 
   * @example
   * {}
   */
  globalConditionShrink?: string;
  /**
   * @remarks
   * The ID of the API group to which the Swagger is imported.
   * 
   * This parameter is required.
   * 
   * @example
   * 0009db9c828549768a200320714b8930
   */
  groupId?: string;
  /**
   * @remarks
   * Specifies whether to overwrite the existing API.
   * 
   * APIs with the same HTTP request type and backend request path are considered the same.
   * 
   * This parameter is required.
   * 
   * @example
   * true
   */
  overwrite?: boolean;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      dataFormat: 'DataFormat',
      dryRun: 'DryRun',
      globalConditionShrink: 'GlobalCondition',
      groupId: 'GroupId',
      overwrite: 'Overwrite',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'string',
      dataFormat: 'string',
      dryRun: 'boolean',
      globalConditionShrink: 'string',
      groupId: 'string',
      overwrite: 'boolean',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportSwaggerResponseBody extends $tea.Model {
  /**
   * @remarks
   * The APIs that failed to be created based on the Swagger-compliant data imported this time.
   */
  failed?: ImportSwaggerResponseBodyFailed;
  /**
   * @remarks
   * The models that failed to be imported based on the Swagger-compliant data imported this time.
   */
  modelFailed?: ImportSwaggerResponseBodyModelFailed;
  /**
   * @remarks
   * The models that were imported based on the Swagger-compliant data imported this time.
   */
  modelSuccess?: ImportSwaggerResponseBodyModelSuccess;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 647CEF05-404C-4125-B3D7-44792EB77392
   */
  requestId?: string;
  /**
   * @remarks
   * The APIs that were created based on the Swagger-compliant data imported this time.
   */
  success?: ImportSwaggerResponseBodySuccess;
  static names(): { [key: string]: string } {
    return {
      failed: 'Failed',
      modelFailed: 'ModelFailed',
      modelSuccess: 'ModelSuccess',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failed: ImportSwaggerResponseBodyFailed,
      modelFailed: ImportSwaggerResponseBodyModelFailed,
      modelSuccess: ImportSwaggerResponseBodyModelSuccess,
      requestId: 'string',
      success: ImportSwaggerResponseBodySuccess,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportSwaggerResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ImportSwaggerResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ImportSwaggerResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPrivateDNSRequest extends $tea.Model {
  /**
   * @example
   * api.demo.com
   */
  intranetDomain?: string;
  securityToken?: string;
  /**
   * @example
   * A
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      intranetDomain: 'IntranetDomain',
      securityToken: 'SecurityToken',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      intranetDomain: 'string',
      securityToken: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPrivateDNSResponseBody extends $tea.Model {
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  privateDNSList?: ListPrivateDNSResponseBodyPrivateDNSList[];
  /**
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ016
   */
  requestId?: string;
  /**
   * @example
   * 2
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      privateDNSList: 'PrivateDNSList',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      privateDNSList: { 'type': 'array', 'itemType': ListPrivateDNSResponseBodyPrivateDNSList },
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPrivateDNSResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListPrivateDNSResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListPrivateDNSResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTagResourcesRequest extends $tea.Model {
  /**
   * @remarks
   * The token used to start the next query.
   * 
   * @example
   * 1d2db86sca4384811e0b5e8707e68181f
   */
  nextToken?: string;
  /**
   * @remarks
   * The ID of the resource.
   * 
   * Valid values of N: `[1,50]`.
   * 
   * @example
   * 285bb759342649a1b70c2093a772e087
   */
  resourceId?: string[];
  /**
   * @remarks
   * The type of the resource.
   * 
   * Currently, tags are supported for API groups, plug-ins, and apps. Operations performed on APIs are based on the tags of API groups.
   * 
   * *   **apiGroup**
   * *   **plugin**
   * *   **app**
   * *   **api**
   * 
   * This parameter is required.
   * 
   * @example
   * apiGroup
   */
  resourceType?: string;
  /**
   * @remarks
   * The tag of objects that match the lifecycle rule. You can specify multiple tags.
   */
  tag?: ListTagResourcesRequestTag[];
  static names(): { [key: string]: string } {
    return {
      nextToken: 'NextToken',
      resourceId: 'ResourceId',
      resourceType: 'ResourceType',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nextToken: 'string',
      resourceId: { 'type': 'array', 'itemType': 'string' },
      resourceType: 'string',
      tag: { 'type': 'array', 'itemType': ListTagResourcesRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTagResourcesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The token that determines the start point of the next query.
   * 
   * A NextToken value of -1 indicates that a next query does not exist.
   * 
   * @example
   * 1d2db86sca4384811e0b5e8707e68181f
   */
  nextToken?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 2D69A58F-345C-4FDE-88E4-BF5189484043
   */
  requestId?: string;
  /**
   * @remarks
   * The resource list.
   */
  tagResources?: ListTagResourcesResponseBodyTagResources;
  static names(): { [key: string]: string } {
    return {
      nextToken: 'NextToken',
      requestId: 'RequestId',
      tagResources: 'TagResources',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nextToken: 'string',
      requestId: 'string',
      tagResources: ListTagResourcesResponseBodyTagResources,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTagResourcesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListTagResourcesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListTagResourcesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyApiRequest extends $tea.Model {
  /**
   * @remarks
   * The type of the two-way communication API. Valid values:
   * 
   * *   **COMMON**: general APIs
   * *   **REGISTER**: registered APIs
   * *   **UNREGISTER**: unregistered APIs
   * *   **NOTIFY**: downstream notification
   * 
   * @example
   * HmacSHA256
   */
  allowSignatureMethod?: string;
  /**
   * @remarks
   * The ID of the API.
   * 
   * This parameter is required.
   * 
   * @example
   * 8afff6c8c4c6447abb035812e4d66b65
   */
  apiId?: string;
  /**
   * @remarks
   * The name of the API. The name must be unique within the API group. The name must be 4 to 50 characters in length. It must start with a letter and can contain letters, digits, and underscores (_).
   * 
   * This parameter is required.
   * 
   * @example
   * ApiName
   */
  apiName?: string;
  /**
   * @remarks
   * The ID of the backend service.
   * 
   * @example
   * DEFAULT
   */
  appCodeAuthType?: string;
  /**
   * @remarks
   * The configuration items of API requests sent by the consumer to API Gateway.
   * 
   * @example
   * APP
   */
  authType?: string;
  /**
   * @remarks
   * Configuration Mode
   * 
   * @example
   * true
   */
  backendEnable?: boolean;
  /**
   * @remarks
   * Specifies whether to enable backend services.
   * 
   * @example
   * 0d105f80a8f340408bd34954d4e4ff22
   */
  backendId?: string;
  constantParameters?: string;
  /**
   * @remarks
   * The description of the API. The description can be up to 180 characters in length.
   * 
   * @example
   * Api description
   */
  description?: string;
  /**
   * @remarks
   * The AppCode authentication type supported. Valid values:
   * 
   * *   DEFAULT: supported after being made available in Alibaba Cloud Marketplace
   * *   DISABLE: not supported
   * *   HEADER : supported only in the Header parameter
   * *   HEADER_QUERY: supported in the Header or Query parameter
   * 
   * @example
   * true
   */
  disableInternet?: boolean;
  errorCodeSamples?: string;
  failResultSample?: string;
  /**
   * @remarks
   * *   Specifies whether to set DisableInternet to **true** to limit API calls to within the VPC.
   * *   If you set DisableInternet to **false**, the limit if lifted.
   * 
   * >  If you do not set this parameter, the original value is used.
   * 
   * @example
   * true
   */
  forceNonceCheck?: boolean;
  /**
   * @remarks
   * The ID of the API group.
   * 
   * @example
   * 927d50c0f2e54b359919923d908bb015
   */
  groupId?: string;
  /**
   * @remarks
   * The client-side request signature method of the API. Valid values:
   * 
   * *   HmacSHA256
   * *   HmacSHA1,HmacSHA256
   * 
   * @example
   * {\\"OpenIdApiType\\":\\"IDTOKEN\\",\\"PublicKey\\":\\"lzlj1573\\",\\"IdTokenParamName\\":\\"\\",\\"PublicKeyId\\":\\"lzljorders\\"}
   */
  openIdConnectConfig?: string;
  /**
   * @remarks
   * The configuration items of API requests sent by API Gateway to the backend service.
   * 
   * This parameter is required.
   * 
   * @example
   * {"RequestProtocol":"HTTP","RequestHttpMethod":"GET","RequestPath":"/v3/getUserTest/[userId]","BodyFormat":"FORM","PostBodyDescription":""}
   */
  requestConfig?: string;
  requestParameters?: string;
  /**
   * @remarks
   * *   Specifies whether to set **ForceNonceCheck** to **true** to force the check of X-Ca-Nonce during the request. This is the unique identifier of the request and is generally identified by UUID. After receiving this parameter, API Gateway verifies the validity of this parameter. The same value can be used only once within 15 minutes. This helps prevent replay attacks.
   * *   If you set **ForceNonceCheck** to **false**, the check is not performed. If you do not set this parameter, the original value is used.
   * 
   * @example
   * {}
   */
  resultBodyModel?: string;
  resultDescriptions?: string;
  resultSample?: string;
  /**
   * @remarks
   * The sample response from the backend service.
   * 
   * @example
   * HTML
   */
  resultType?: string;
  securityToken?: string;
  /**
   * @remarks
   * The parameters of API requests sent by the consumer to API Gateway.
   * 
   * This parameter is required.
   * 
   * @example
   * {"ServiceProtocol":"HTTP","ServiceHttpMethod":"GET","ServiceAddress":"http://www.customerdomain.com","ServiceTimeout":"1000","ServicePath":"/v3/getUserTest/[userId]"}
   */
  serviceConfig?: string;
  serviceParameters?: string;
  serviceParametersMap?: string;
  systemParameters?: string;
  /**
   * @remarks
   * Specifies whether the API is public. Valid values:
   * 
   * *   **PUBLIC**: Make the API public. If you set this parameter to PUBLIC, this API is displayed on the APIs page for all users after the API is published to the production environment.
   * *   **PRIVATE**: Make the API private. Private APIs are not displayed in the Alibaba Cloud Marketplace after the API group to which they belong is made available.
   * 
   * This parameter is required.
   * 
   * @example
   * PUBLIC
   */
  visibility?: string;
  /**
   * @remarks
   * The returned description of the API.
   * 
   * @example
   * COMMON
   */
  webSocketApiType?: string;
  static names(): { [key: string]: string } {
    return {
      allowSignatureMethod: 'AllowSignatureMethod',
      apiId: 'ApiId',
      apiName: 'ApiName',
      appCodeAuthType: 'AppCodeAuthType',
      authType: 'AuthType',
      backendEnable: 'BackendEnable',
      backendId: 'BackendId',
      constantParameters: 'ConstantParameters',
      description: 'Description',
      disableInternet: 'DisableInternet',
      errorCodeSamples: 'ErrorCodeSamples',
      failResultSample: 'FailResultSample',
      forceNonceCheck: 'ForceNonceCheck',
      groupId: 'GroupId',
      openIdConnectConfig: 'OpenIdConnectConfig',
      requestConfig: 'RequestConfig',
      requestParameters: 'RequestParameters',
      resultBodyModel: 'ResultBodyModel',
      resultDescriptions: 'ResultDescriptions',
      resultSample: 'ResultSample',
      resultType: 'ResultType',
      securityToken: 'SecurityToken',
      serviceConfig: 'ServiceConfig',
      serviceParameters: 'ServiceParameters',
      serviceParametersMap: 'ServiceParametersMap',
      systemParameters: 'SystemParameters',
      visibility: 'Visibility',
      webSocketApiType: 'WebSocketApiType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allowSignatureMethod: 'string',
      apiId: 'string',
      apiName: 'string',
      appCodeAuthType: 'string',
      authType: 'string',
      backendEnable: 'boolean',
      backendId: 'string',
      constantParameters: 'string',
      description: 'string',
      disableInternet: 'boolean',
      errorCodeSamples: 'string',
      failResultSample: 'string',
      forceNonceCheck: 'boolean',
      groupId: 'string',
      openIdConnectConfig: 'string',
      requestConfig: 'string',
      requestParameters: 'string',
      resultBodyModel: 'string',
      resultDescriptions: 'string',
      resultSample: 'string',
      resultType: 'string',
      securityToken: 'string',
      serviceConfig: 'string',
      serviceParameters: 'string',
      serviceParametersMap: 'string',
      systemParameters: 'string',
      visibility: 'string',
      webSocketApiType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyApiResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 6C87A26A-6A18-4B8E-8099-705278381A2C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyApiResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyApiResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyApiResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyApiConfigurationRequest extends $tea.Model {
  /**
   * @remarks
   * If the **AuthType** parameter is set to **APP**, you must include this parameter to specify the signature algorithm. If you do not specify a value, HmacSHA256 is used by default. Valid values:
   * 
   * *   HmacSHA256
   * *   HmacSHA1,HmacSHA256
   * 
   * @example
   * HmacSHA256
   */
  allowSignatureMethod?: string;
  /**
   * @remarks
   * The ID of the API.
   * 
   * This parameter is required.
   * 
   * @example
   * baacc592e63a4cb6a41920d9d3f91f38
   */
  apiId?: string;
  /**
   * @remarks
   * The name of the API.
   * 
   * @example
   * testModifyApiName
   */
  apiName?: string;
  /**
   * @remarks
   * If the **AuthType** parameter is set to **APP**, the valid values are:
   * 
   * *   **DEFAULT**: The default value that is used if no other values are passed. This value indicates that the settings of the group are used.
   * *   **DISABLE**: The authentication is disabled.
   * *   **HEADER**: AppCode can be placed in the Header parameter for authentication.
   * *   **HEADER_QUERY**: AppCode can be placed in the Header or Query parameter for authentication.
   * 
   * @example
   * DEFAULT
   */
  appCodeAuthType?: string;
  /**
   * @remarks
   * API安全认证类型，目前可以取值：
   * 
   * - **APP**：只允许已授权的APP调用
   * - **ANONYMOUS**：允许匿名调用，设置为允许匿名调用需要注意：
   *      - 任何能够获取该API服务信息的人，都将能够调用该API。网关不会对调用者做身份认证，也无法设置按用户的流量控制，若开放该API请设置好按API的流量控制；
   *      - AppCodeAuthType的值不会生效。
   * 
   * @example
   * APP
   */
  authType?: string;
  /**
   * @remarks
   * The name of the backend service. This parameter takes effect only when the UseBackendService parameter is set to TRUE.
   * 
   * @example
   * testBackendService
   */
  backendName?: string;
  /**
   * @remarks
   * This parameter takes effect only when the **RequestMode** parameter is set to **MAPPING**.
   * 
   * The format in which data is transmitted to the server for POST and PUT requests. Valid values: **FORM** and **STREAM**. FORM indicates that data is transmitted in the key-value pair format. STREAM indicates that data is transmitted as byte streams.
   * 
   * @example
   * STREAM
   */
  bodyFormat?: string;
  /**
   * @remarks
   * The body model.
   * 
   * @example
   * https://apigateway.aliyun.com/models/f4e7333c****40dcbaf7c9da553ccd8d/3ab61f775b****d4bc35e993****87aa8
   */
  bodyModel?: string;
  /**
   * @remarks
   * The ContentType configuration of the backend request.
   * 
   * *   DEFAULT: the default configuration in API Gateway
   * *   CUSTOM: a custom configuration
   * 
   * @example
   * DEFAULT
   */
  contentTypeCategory?: string;
  /**
   * @remarks
   * The value of the ContentType header when the ServiceProtocol parameter is set to HTTP and the ContentTypeCatagory parameter is set to DEFAULT or CUSTOM.
   * 
   * @example
   * application/x-www-form-urlencoded; charset=UTF-8
   */
  contentTypeValue?: string;
  /**
   * @remarks
   * The description of the API.
   * 
   * @example
   * TestModifyDescription
   */
  description?: string;
  /**
   * @remarks
   * *   Specifies whether to call the API only in an internal network. If the **DisableInternet** parameter is set to **true**, the API can be called only in an internal network.
   * *   If the **DisableInternet** parameter is set to **false**, the API can be called over the Internet and in an internal network.
   * 
   * @example
   * false
   */
  disableInternet?: boolean;
  /**
   * @remarks
   * The sample error codes returned by the backend service.
   * 
   * For more information, see [ErrorCodeSample](https://help.aliyun.com/document_detail/44392.html).
   * 
   * @example
   * [{"Code":"400","Message":"Missing the userId","Description":"param invalid"}]
   */
  errorCodeSamples?: string;
  /**
   * @remarks
   * The sample error response from the backend service. This value is used only to generate documents. It does not affect the returned result.
   * 
   * @example
   * {"errorCode":"fail","errorMessage":"param invalid"}
   */
  failResultSample?: string;
  /**
   * @remarks
   * *   Specifies whether to forcibly check X-Ca-Nonce. If the **ForceNonceCheck** parameter is set to **true**, X-Ca-Nonce is forcibly checked. X-Ca-Nonce is the unique identifier of the request and is generally identified by UUID. After receiving this parameter, API Gateway verifies the validity of this parameter. The same value can be used only once within 15 minutes. This helps prevent replay attacks.
   * *   If the **ForceNonceCheck** parameter is set to **false**, X-Ca-Nonce is not checked. If you do not modify this parameter when you modify an API, the original value is used.
   * 
   * @example
   * true
   */
  forceNonceCheck?: boolean;
  /**
   * @remarks
   * The Function Compute configuration.
   * 
   * @example
   * {"FcType":"FCEvent","FcRegionId":"cn-hangzhou","RoleArn":"acs:ram::xxxxxxxx:role/aliyunserviceroleforapigateway","selectServiceName":"fcTest","FunctionName":"funcTest","selectFunctionName":"funcTest","Qualifier":"LATEST","Path":"","FcBaseUrl":"","ServiceName":"fcTest"}
   */
  functionComputeConfig?: string;
  /**
   * @remarks
   * The HTTP configuration.
   * 
   * @example
   * {"serviceAddress":"http://test.api.com","servicePath":"/test/api","serviceHttpMethod":"GET"}
   */
  httpConfig?: string;
  /**
   * @remarks
   * The Mock configuration.
   * 
   * @example
   * {"MockResult":"test","MockHeaders":[{"HeaderName":"testHeader","HeaderValue":"testHeader"}],"MockStatusCode":"400"}
   */
  mockConfig?: string;
  /**
   * @remarks
   * The name of the model.
   * 
   * @example
   * Test
   */
  modelName?: string;
  /**
   * @remarks
   * The OSS configuration.
   * 
   * @example
   * {"OssRegionId":"cn-hangzhou","Key":"/test.html","BucketName":"test-api-oss","Action":"GetObject"}
   */
  ossConfig?: string;
  /**
   * @remarks
   * The description of the request body.
   * 
   * @example
   * The description of the request body
   */
  postBodyDescription?: string;
  /**
   * @remarks
   * The HTTP method used to make the request. Valid values: GET, POST, DELETE, PUT, HEADER, TRACE, PATCH, CONNECT, and OPTIONS.
   * 
   * @example
   * GET
   */
  requestHttpMethod?: string;
  /**
   * @remarks
   * The request mode. Valid values:
   * 
   * *   MAPPING: Parameters are mapped. Unknown parameters are filtered out.
   * *   PASSTHROUGH: Parameters are passed through.
   * *   MAPPING_PASSTHROUGH: Parameters are mapped. Unknown parameters are passed through.
   * 
   * @example
   * MAPPING
   */
  requestMode?: string;
  /**
   * @remarks
   * The parameters of API requests sent by the consumer to API Gateway.
   * 
   * For more information, see [RequestParameter](https://help.aliyun.com/document_detail/43986.html).
   * 
   * @example
   * [{"ParameterLocation":{"name":"Head","orderNumber":2},"ParameterType":"String","Required":"OPTIONAL","isHide":false,"ApiParameterName":"header1","DefaultValue":"123124","Location":"Head"},{"ParameterLocation":{"name":"Head","orderNumber":2},"ParameterType":"String","Required":"REQUIRED","isHide":false,"ApiParameterName":"header2","DefaultValue":"","Location":"Head"},{"ParameterLocation":{"name":"Query","orderNumber":3},"ParameterType":"String","Required":"OPTIONAL","isHide":false,"ApiParameterName":"query1","DefaultValue":"1245","Location":"Query"},{"ApiParameterName":"CaClientIp","ParameterLocation":{"name":"Query","orderNumber":0},"Location":"Query","ParameterType":"String","Required":"REQUIRED","Description":"ClientIP"},{"ApiParameterName":"testConstant","ParameterLocation":{"name":"Head","orderNumber":0},"Location":"Head","ParameterType":"String","Required":"REQUIRED","DefaultValue":"111"}]
   */
  requestParameters?: string;
  /**
   * @remarks
   * The path of the API request. If the complete API URL is `http://api.a.com:8080/object/add?key1=value1&key2=value2`, the path of the API request is `/object/add`.
   * 
   * @example
   * /test/api
   */
  requestPath?: string;
  /**
   * @remarks
   * The protocol type supported by the API. Valid values: HTTP and HTTPS. Separate multiple values with commas (,), such as "HTTP,HTTPS".
   * 
   * @example
   * HTTP
   */
  requestProtocol?: string;
  /**
   * @remarks
   * The sample response from the backend service. This value is used only to generate documents. It does not affect the returned result.
   * 
   * @example
   * {\\n  \\"status\\": 0,\\n  \\"data\\": {\\n    \\"count\\": 1,\\n    \\"list\\": [\\n      \\"352\\"\\n    ]\\n  },\\n  \\"message\\": \\"success\\"\\n}
   */
  resultSample?: string;
  /**
   * @remarks
   * The format of the response from the backend service. Valid values: JSON, TEXT, BINARY, XML, and HTML. This value is used only to generate documents. It does not affect the returned result.
   * 
   * @example
   * JSON
   */
  resultType?: string;
  securityToken?: string;
  /**
   * @remarks
   * The parameters of API requests sent by API Gateway to the backend service.
   * 
   * For more information, see [ServiceParameter](https://help.aliyun.com/document_detail/43988.html).
   * 
   * @example
   * [{"ServiceParameterName":"header1","Location":"Head","Type":"String","ParameterCatalog":"REQUEST"},{"ServiceParameterName":"header2","Location":"Query","Type":"String","ParameterCatalog":"REQUEST"},{"ServiceParameterName":"query1","Location":"Head","Type":"String","ParameterCatalog":"REQUEST"},{"ServiceParameterName":"ipp","Location":"Query","Type":"String","ParameterCatalog":"SYSTEM"},{"ServiceParameterName":"testConstant","Location":"Head","Type":"String","ParameterCatalog":"CONSTANT"}]
   */
  serviceParameters?: string;
  /**
   * @remarks
   * The mappings between parameters of requests sent by the consumer to API Gateway and parameters of requests sent by API Gateway to the backend service.
   * 
   * For more information, see [ServiceParameterMap](https://help.aliyun.com/document_detail/43989.html).
   * 
   * @example
   * [{"ServiceParameterName":"header1","RequestParameterName":"header1"},{"ServiceParameterName":"header2","RequestParameterName":"header2"},{"ServiceParameterName":"query1","RequestParameterName":"query1"},{"ServiceParameterName":"ipp","RequestParameterName":"CaClientIp"},{"ServiceParameterName":"testConstant","RequestParameterName":"testConstant"}]
   */
  serviceParametersMap?: string;
  /**
   * @remarks
   * The protocol that is used to access backend services. Valid values:
   * 
   * *   Http: for backend services that use HTTP or HTTPS
   * *   Vpc: for backend services that use VPC
   * *   FC: for Function Compute
   * *   OSS: for Object Storage Service
   * *   Mock: for backend services that use the Mock mode
   * *   EventBridge: for EventBridge
   * 
   * You must specify the config value for the corresponding backend service.
   * 
   * @example
   * HTTP
   */
  serviceProtocol?: string;
  /**
   * @remarks
   * The timeout period of the backend service. Unit: milliseconds.
   * 
   * @example
   * 10000
   */
  serviceTimeout?: number;
  /**
   * @remarks
   * Specifies whether to use the information about the created backend service. Valid values:
   * 
   * *   TRUE: uses the information about the created backend service.
   * *   FALSE: uses the information about the custom backend service.
   * 
   * @example
   * TRUE
   */
  useBackendService?: boolean;
  /**
   * @remarks
   * Specifies whether to make the API public. Valid values:
   * 
   * *   **PUBLIC:** The API is public. If this parameter is set to PUBLIC, the API is displayed on the APIs page for all users after the API is published to the production environment.
   * *   **PRIVATE:** The API is private. Private APIs are not displayed in the Alibaba Cloud Marketplace after the API group to which they belong is made available.
   * 
   * @example
   * PUBLIC
   */
  visibility?: string;
  /**
   * @remarks
   * The VPC configuration.
   * 
   * @example
   * {"VpcId":"vpc-xxxxxxx","Name":"testVpc","InstanceId":"i-p0ssssss","Port":80,"servicePath":"/test/vpc","serviceHttpMethod":"HEAD"}
   */
  vpcConfig?: string;
  static names(): { [key: string]: string } {
    return {
      allowSignatureMethod: 'AllowSignatureMethod',
      apiId: 'ApiId',
      apiName: 'ApiName',
      appCodeAuthType: 'AppCodeAuthType',
      authType: 'AuthType',
      backendName: 'BackendName',
      bodyFormat: 'BodyFormat',
      bodyModel: 'BodyModel',
      contentTypeCategory: 'ContentTypeCategory',
      contentTypeValue: 'ContentTypeValue',
      description: 'Description',
      disableInternet: 'DisableInternet',
      errorCodeSamples: 'ErrorCodeSamples',
      failResultSample: 'FailResultSample',
      forceNonceCheck: 'ForceNonceCheck',
      functionComputeConfig: 'FunctionComputeConfig',
      httpConfig: 'HttpConfig',
      mockConfig: 'MockConfig',
      modelName: 'ModelName',
      ossConfig: 'OssConfig',
      postBodyDescription: 'PostBodyDescription',
      requestHttpMethod: 'RequestHttpMethod',
      requestMode: 'RequestMode',
      requestParameters: 'RequestParameters',
      requestPath: 'RequestPath',
      requestProtocol: 'RequestProtocol',
      resultSample: 'ResultSample',
      resultType: 'ResultType',
      securityToken: 'SecurityToken',
      serviceParameters: 'ServiceParameters',
      serviceParametersMap: 'ServiceParametersMap',
      serviceProtocol: 'ServiceProtocol',
      serviceTimeout: 'ServiceTimeout',
      useBackendService: 'UseBackendService',
      visibility: 'Visibility',
      vpcConfig: 'VpcConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allowSignatureMethod: 'string',
      apiId: 'string',
      apiName: 'string',
      appCodeAuthType: 'string',
      authType: 'string',
      backendName: 'string',
      bodyFormat: 'string',
      bodyModel: 'string',
      contentTypeCategory: 'string',
      contentTypeValue: 'string',
      description: 'string',
      disableInternet: 'boolean',
      errorCodeSamples: 'string',
      failResultSample: 'string',
      forceNonceCheck: 'boolean',
      functionComputeConfig: 'string',
      httpConfig: 'string',
      mockConfig: 'string',
      modelName: 'string',
      ossConfig: 'string',
      postBodyDescription: 'string',
      requestHttpMethod: 'string',
      requestMode: 'string',
      requestParameters: 'string',
      requestPath: 'string',
      requestProtocol: 'string',
      resultSample: 'string',
      resultType: 'string',
      securityToken: 'string',
      serviceParameters: 'string',
      serviceParametersMap: 'string',
      serviceProtocol: 'string',
      serviceTimeout: 'number',
      useBackendService: 'boolean',
      visibility: 'string',
      vpcConfig: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyApiConfigurationResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 6C87A26A-6A18-4B8E-8099-705278381A2C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyApiConfigurationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyApiConfigurationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyApiConfigurationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyApiGroupRequest extends $tea.Model {
  /**
   * @remarks
   * The root path of the API.
   * 
   * @example
   * /eeee
   */
  basePath?: string;
  /**
   * @remarks
   * The list of associated tags. Separate multiple tags with commas (,).
   * 
   * @example
   * depart:dep1
   */
  compatibleFlags?: string;
  /**
   * @remarks
   * The custom trace configuration.
   * 
   * @example
   * {\\"parameterLocation\\":\\"HEADER\\",\\"parameterName\\":\\"traceId\\"}
   */
  customTraceConfig?: string;
  /**
   * @remarks
   * The data of custom configuration items.
   * 
   * @example
   * removeResponseServerHeader
   */
  customerConfigs?: string;
  /**
   * @remarks
   * The default domain name.
   * 
   * @example
   * mkt.api.gaore.com
   */
  defaultDomain?: string;
  /**
   * @remarks
   * The API group description that you want to specify, which cannot exceed 180 characters. If this parameter is not specified, the group description is not modified.
   * 
   * @example
   * New weather informations.
   */
  description?: string;
  filterAppCodeForBackend?: string;
  /**
   * @remarks
   * The ID of the API group. This ID is generated by the system and globally unique.
   * 
   * This parameter is required.
   * 
   * @example
   * 523e8dc7bbe04613b5b1d726c2a7889d
   */
  groupId?: string;
  /**
   * @remarks
   * The API group name must be globally unique. The name must be 4 to 50 characters in length. It must start with a letter and can contain letters, digits, and underscores (_). If this parameter is not specified, the group name is not modified.
   * 
   * @example
   * NewWeather
   */
  groupName?: string;
  /**
   * @remarks
   * Specifies whether to pass headers.
   * 
   * @example
   * eagleeye-rpcid,x-b3-traceid,host
   */
  passthroughHeaders?: string;
  /**
   * @remarks
   * The RPC mode.
   */
  rpcPattern?: string;
  securityToken?: string;
  /**
   * **if can be null:**
   * true
   */
  supportSSE?: string;
  /**
   * @remarks
   * The object tags that match the lifecycle rule. You can specify multiple tags.
   * 
   * @example
   * Key， Value
   */
  tag?: ModifyApiGroupRequestTag[];
  /**
   * @remarks
   * The user log configuration.
   * 
   * @example
   * {\\"requestBody\\":false,\\"responseBody\\":false,\\"queryString\\":\\"\\",\\"requestHeaders\\":\\"\\",\\"responseHeaders\\":\\"\\",\\"jwtClaims\\":\\"\\"}
   */
  userLogConfig?: string;
  static names(): { [key: string]: string } {
    return {
      basePath: 'BasePath',
      compatibleFlags: 'CompatibleFlags',
      customTraceConfig: 'CustomTraceConfig',
      customerConfigs: 'CustomerConfigs',
      defaultDomain: 'DefaultDomain',
      description: 'Description',
      filterAppCodeForBackend: 'FilterAppCodeForBackend',
      groupId: 'GroupId',
      groupName: 'GroupName',
      passthroughHeaders: 'PassthroughHeaders',
      rpcPattern: 'RpcPattern',
      securityToken: 'SecurityToken',
      supportSSE: 'SupportSSE',
      tag: 'Tag',
      userLogConfig: 'UserLogConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      basePath: 'string',
      compatibleFlags: 'string',
      customTraceConfig: 'string',
      customerConfigs: 'string',
      defaultDomain: 'string',
      description: 'string',
      filterAppCodeForBackend: 'string',
      groupId: 'string',
      groupName: 'string',
      passthroughHeaders: 'string',
      rpcPattern: 'string',
      securityToken: 'string',
      supportSSE: 'string',
      tag: { 'type': 'array', 'itemType': ModifyApiGroupRequestTag },
      userLogConfig: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyApiGroupResponseBody extends $tea.Model {
  /**
   * @remarks
   * The root path of the API.
   * 
   * @example
   * /test
   */
  basePath?: string;
  /**
   * @remarks
   * The description of the API group.
   * 
   * @example
   * New weather informations.
   */
  description?: string;
  /**
   * @remarks
   * The ID of the API group. This ID is generated by the system and globally unique.
   * 
   * @example
   * 523e8dc7bbe04613b5b1d726c2a7889d
   */
  groupId?: string;
  /**
   * @remarks
   * The name of the group to which an API belongs.
   * 
   * @example
   * NewWeather
   */
  groupName?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 4CF287C6-CE5B-477B-BE27-C48F99EADBC8
   */
  requestId?: string;
  /**
   * @remarks
   * The second-level domain name automatically assigned to the API group.
   * 
   * @example
   * 523e8dc7bbe04613b5b1d726c2a7889d-cn-hangzhou.alicloudapi.com
   */
  subDomain?: string;
  static names(): { [key: string]: string } {
    return {
      basePath: 'BasePath',
      description: 'Description',
      groupId: 'GroupId',
      groupName: 'GroupName',
      requestId: 'RequestId',
      subDomain: 'SubDomain',
    };
  }

  static types(): { [key: string]: any } {
    return {
      basePath: 'string',
      description: 'string',
      groupId: 'string',
      groupName: 'string',
      requestId: 'string',
      subDomain: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyApiGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyApiGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyApiGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyApiGroupInstanceRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 01c97ed08a614118849b00079753d1e2
   */
  groupId?: string;
  /**
   * @example
   * migrate
   */
  remark?: string;
  securityToken?: string;
  tag?: ModifyApiGroupInstanceRequestTag[];
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * apigateway-bj-c325375b1ebe
   */
  targetInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      remark: 'Remark',
      securityToken: 'SecurityToken',
      tag: 'Tag',
      targetInstanceId: 'TargetInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      remark: 'string',
      securityToken: 'string',
      tag: { 'type': 'array', 'itemType': ModifyApiGroupInstanceRequestTag },
      targetInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyApiGroupInstanceResponseBody extends $tea.Model {
  /**
   * @example
   * E07AEFF0-9FB0-599E-8F12-B418D8AE1F3D
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyApiGroupInstanceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyApiGroupInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyApiGroupInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyApiGroupNetworkPolicyRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the API group.
   * 
   * This parameter is required.
   * 
   * @example
   * b0162c75d7d34ff48506f1aff878b05e
   */
  groupId?: string;
  /**
   * @remarks
   * The HTTPS security policy.
   * 
   * @example
   * HTTPS1_1_TLS1_0
   */
  httpsPolicy?: string;
  /**
   * @remarks
   * Specifies whether to disable the public second-level domain name.
   * 
   * @example
   * true
   */
  innerDomainEnable?: boolean;
  /**
   * @remarks
   * Specifies whether to enable the virtual private cloud (VPC) second-level domain name.
   * 
   * @example
   * true
   */
  internetEnable?: boolean;
  /**
   * @remarks
   * Specifies whether to enable IPv6. Valid values: **true** and **false**.
   * 
   * @example
   * true
   */
  internetIPV6Enable?: boolean;
  securityToken?: string;
  /**
   * @remarks
   * Specifies whether to enable the VPC domain name. Valid values:
   * 
   * *   TRUE
   * *   FALSE
   * 
   * @example
   * false
   */
  vpcIntranetEnable?: boolean;
  /**
   * @remarks
   * Specifies whether to enable the self-calling domain name.
   * 
   * @example
   * false
   */
  vpcSlbIntranetEnable?: boolean;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      httpsPolicy: 'HttpsPolicy',
      innerDomainEnable: 'InnerDomainEnable',
      internetEnable: 'InternetEnable',
      internetIPV6Enable: 'InternetIPV6Enable',
      securityToken: 'SecurityToken',
      vpcIntranetEnable: 'VpcIntranetEnable',
      vpcSlbIntranetEnable: 'VpcSlbIntranetEnable',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      httpsPolicy: 'string',
      innerDomainEnable: 'boolean',
      internetEnable: 'boolean',
      internetIPV6Enable: 'boolean',
      securityToken: 'string',
      vpcIntranetEnable: 'boolean',
      vpcSlbIntranetEnable: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyApiGroupNetworkPolicyResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 4E707B25-5119-5ACF-9D26-7D2A2762F05C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyApiGroupNetworkPolicyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyApiGroupNetworkPolicyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyApiGroupNetworkPolicyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyApiGroupVpcWhitelistRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the API group.
   * 
   * This parameter is required.
   * 
   * @example
   * 9b80408147724ddab4c4e2703c6ca019
   */
  groupId?: string;
  securityToken?: string;
  /**
   * @remarks
   * The ID of the VPC instance.
   * 
   * This parameter is required.
   * 
   * @example
   * vpc-bp11w979o2s9rcr962w25
   */
  vpcIds?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      securityToken: 'SecurityToken',
      vpcIds: 'VpcIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      securityToken: 'string',
      vpcIds: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyApiGroupVpcWhitelistResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * F8B9DC8C-D6E2-5065-BD1F-0401866E7F10
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyApiGroupVpcWhitelistResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyApiGroupVpcWhitelistResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyApiGroupVpcWhitelistResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyAppRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the application.
   * 
   * This parameter is required.
   * 
   * @example
   * 20112314518278
   */
  appId?: number;
  /**
   * @remarks
   * The ID must be 4 to 26 characters in length and can contain letters, digits, and underscores (_). It must start with a letter.
   * 
   * If you do not want to modify the existing value, do not specify this parameter.
   * 
   * @example
   * jiedian_pord
   */
  appName?: string;
  /**
   * @remarks
   * The description of the application. The description can be up to 180 characters in length.
   * 
   * If you do not want to modify the existing value, do not specify this parameter.
   * 
   * @example
   * modidyTest
   */
  description?: string;
  extend?: string;
  securityToken?: string;
  /**
   * @remarks
   * The tag of objects that match the rule. You can specify multiple tags.
   * 
   * @example
   * Key， Value
   */
  tag?: ModifyAppRequestTag[];
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      appName: 'AppName',
      description: 'Description',
      extend: 'Extend',
      securityToken: 'SecurityToken',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'number',
      appName: 'string',
      description: 'string',
      extend: 'string',
      securityToken: 'string',
      tag: { 'type': 'array', 'itemType': ModifyAppRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyAppResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ015
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyAppResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyAppResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyAppResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyBackendRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 20bcdc9453524b78a8beb1f6de21edb7
   */
  backendId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * testHttpModify
   */
  backendName?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * HTTP
   */
  backendType?: string;
  /**
   * @example
   * test
   */
  description?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      backendId: 'BackendId',
      backendName: 'BackendName',
      backendType: 'BackendType',
      description: 'Description',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      backendId: 'string',
      backendName: 'string',
      backendType: 'string',
      description: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyBackendResponseBody extends $tea.Model {
  /**
   * @example
   * 06DACA61-9359-5EC6-AEDA-C73E620E49A9
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyBackendResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyBackendResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyBackendResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyBackendModelRequest extends $tea.Model {
  /**
   * @example
   * 20bcdc9453524b78a8beb1f6de21edb7
   */
  backendId?: string;
  /**
   * @example
   * {\\"ServiceAddress\\":\\"http://121.40.XX.XX\\"}
   */
  backendModelData?: string;
  /**
   * @example
   * 3bb6375bc71c4e4c95ce05b4e7a55a9d
   */
  backendModelId?: string;
  /**
   * @example
   * OSS
   */
  backendType?: string;
  /**
   * @example
   * modify plugin first
   */
  description?: string;
  securityToken?: string;
  /**
   * @example
   * TEST
   */
  stageName?: string;
  static names(): { [key: string]: string } {
    return {
      backendId: 'BackendId',
      backendModelData: 'BackendModelData',
      backendModelId: 'BackendModelId',
      backendType: 'BackendType',
      description: 'Description',
      securityToken: 'SecurityToken',
      stageName: 'StageName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      backendId: 'string',
      backendModelData: 'string',
      backendModelId: 'string',
      backendType: 'string',
      description: 'string',
      securityToken: 'string',
      stageName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyBackendModelResponseBody extends $tea.Model {
  /**
   * @example
   * c16a1880f5164d779f6a54f64d997cd9
   */
  operationId?: string;
  /**
   * @example
   * 19B89B04-418B-55EE-94A8-6B42CA06002A
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      operationId: 'OperationId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      operationId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyBackendModelResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyBackendModelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyBackendModelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDatasetRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the dataset.
   * 
   * This parameter is required.
   * 
   * @example
   * a25a6589b2584ff490e891cc********
   */
  datasetId?: string;
  /**
   * @remarks
   * The name of the dataset.
   * 
   * This parameter is required.
   * 
   * @example
   * NewDatasetName
   */
  datasetName?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      datasetId: 'DatasetId',
      datasetName: 'DatasetName',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      datasetId: 'string',
      datasetName: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDatasetResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876********
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDatasetResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyDatasetResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyDatasetResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDatasetItemRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the dataset.
   * 
   * This parameter is required.
   * 
   * @example
   * a25a6589b2584ff490e891cc********
   */
  datasetId?: string;
  /**
   * @remarks
   * The ID of the data entry.
   * 
   * This parameter is required.
   * 
   * @example
   * 5045****
   */
  datasetItemId?: string;
  /**
   * @remarks
   * The description of the data entry. The description cannot exceed 180 characters in length.
   * 
   * @example
   * description
   */
  description?: string;
  /**
   * @remarks
   * The time in UTC when the data entry expires. The time is in the **yyyy-MM-ddTHH:mm:ssZ** format.
   * 
   * @example
   * 2022-09-22T12:00:00Z
   */
  expiredTime?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      datasetId: 'DatasetId',
      datasetItemId: 'DatasetItemId',
      description: 'Description',
      expiredTime: 'ExpiredTime',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      datasetId: 'string',
      datasetItemId: 'string',
      description: 'string',
      expiredTime: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDatasetItemResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * F7DE77BC-0F7D-5A18-B494-BD2C********
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDatasetItemResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyDatasetItemResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyDatasetItemResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceAttributeRequest extends $tea.Model {
  /**
   * @example
   * true
   */
  deleteVpcIpBlock?: string;
  /**
   * @example
   * true
   */
  egressIpv6Enable?: string;
  /**
   * @example
   * HTTPS2_TLS1_0
   */
  httpsPolicy?: string;
  /**
   * @example
   * true
   */
  IPV6Enabled?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * apigateway-ht-8xxxxxxxxx
   */
  instanceId?: string;
  /**
   * @example
   * apigatewayInstance
   */
  instanceName?: string;
  /**
   * @example
   * 172.0.0.1/24
   */
  intranetSegments?: string;
  /**
   * @example
   * 23:00Z
   */
  maintainEndTime?: string;
  /**
   * @example
   * 18:00Z
   */
  maintainStartTime?: string;
  /**
   * @remarks
   * The information about the CIDR block that API Gateway can use to access the virtual private cloud (VPC) of the backend service.
   */
  toConnectVpcIpBlock?: ModifyInstanceAttributeRequestToConnectVpcIpBlock;
  /**
   * @example
   * c20d86c4-1eb3-4d0b-afe9-c586df1e2136
   */
  token?: string;
  /**
   * @example
   * false
   */
  vpcSlbIntranetEnable?: string;
  static names(): { [key: string]: string } {
    return {
      deleteVpcIpBlock: 'DeleteVpcIpBlock',
      egressIpv6Enable: 'EgressIpv6Enable',
      httpsPolicy: 'HttpsPolicy',
      IPV6Enabled: 'IPV6Enabled',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      intranetSegments: 'IntranetSegments',
      maintainEndTime: 'MaintainEndTime',
      maintainStartTime: 'MaintainStartTime',
      toConnectVpcIpBlock: 'ToConnectVpcIpBlock',
      token: 'Token',
      vpcSlbIntranetEnable: 'VpcSlbIntranetEnable',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deleteVpcIpBlock: 'string',
      egressIpv6Enable: 'string',
      httpsPolicy: 'string',
      IPV6Enabled: 'string',
      instanceId: 'string',
      instanceName: 'string',
      intranetSegments: 'string',
      maintainEndTime: 'string',
      maintainStartTime: 'string',
      toConnectVpcIpBlock: ModifyInstanceAttributeRequestToConnectVpcIpBlock,
      token: 'string',
      vpcSlbIntranetEnable: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceAttributeShrinkRequest extends $tea.Model {
  /**
   * @example
   * true
   */
  deleteVpcIpBlock?: string;
  /**
   * @example
   * true
   */
  egressIpv6Enable?: string;
  /**
   * @example
   * HTTPS2_TLS1_0
   */
  httpsPolicy?: string;
  /**
   * @example
   * true
   */
  IPV6Enabled?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * apigateway-ht-8xxxxxxxxx
   */
  instanceId?: string;
  /**
   * @example
   * apigatewayInstance
   */
  instanceName?: string;
  /**
   * @example
   * 172.0.0.1/24
   */
  intranetSegments?: string;
  /**
   * @example
   * 23:00Z
   */
  maintainEndTime?: string;
  /**
   * @example
   * 18:00Z
   */
  maintainStartTime?: string;
  /**
   * @remarks
   * The information about the CIDR block that API Gateway can use to access the virtual private cloud (VPC) of the backend service.
   */
  toConnectVpcIpBlockShrink?: string;
  /**
   * @example
   * c20d86c4-1eb3-4d0b-afe9-c586df1e2136
   */
  token?: string;
  /**
   * @example
   * false
   */
  vpcSlbIntranetEnable?: string;
  static names(): { [key: string]: string } {
    return {
      deleteVpcIpBlock: 'DeleteVpcIpBlock',
      egressIpv6Enable: 'EgressIpv6Enable',
      httpsPolicy: 'HttpsPolicy',
      IPV6Enabled: 'IPV6Enabled',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      intranetSegments: 'IntranetSegments',
      maintainEndTime: 'MaintainEndTime',
      maintainStartTime: 'MaintainStartTime',
      toConnectVpcIpBlockShrink: 'ToConnectVpcIpBlock',
      token: 'Token',
      vpcSlbIntranetEnable: 'VpcSlbIntranetEnable',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deleteVpcIpBlock: 'string',
      egressIpv6Enable: 'string',
      httpsPolicy: 'string',
      IPV6Enabled: 'string',
      instanceId: 'string',
      instanceName: 'string',
      intranetSegments: 'string',
      maintainEndTime: 'string',
      maintainStartTime: 'string',
      toConnectVpcIpBlockShrink: 'string',
      token: 'string',
      vpcSlbIntranetEnable: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceAttributeResponseBody extends $tea.Model {
  /**
   * @example
   * F3186326-2C57-58E1-B6E9-XXXXXXXXXXXX
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceAttributeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyInstanceAttributeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyInstanceAttributeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceSpecRequest extends $tea.Model {
  /**
   * @remarks
   * Specifies whether payment is automatically made during renewal. Valid values:
   * 
   * *   **True**: Automatic payment is enabled. Make sure that your Alibaba Cloud account has adequate balance.
   * *   **False**: Automatic payment is disabled. You have to manually pay in the console. Log on to the console. In the upper-right corner, choose **Expenses > User Center**. In the left-side navigation pane, click **Orders**. On the page that appears, find your order and complete the payment.
   * 
   * Default value: **False**.
   * 
   * @example
   * true
   */
  autoPay?: boolean;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * apigateway-cn-v6419k43xxxxx
   */
  instanceId?: string;
  /**
   * @remarks
   * The specifications of the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * api.s1.small
   */
  instanceSpec?: string;
  /**
   * @remarks
   * Specifies whether to upgrade or downgrade the instance. Valid values:
   * 
   * *   **UPGRADE**
   * *   **DOWNGRADE**
   * 
   * Default value: **UPGRADE**.
   * 
   * @example
   * UPGRADE
   */
  modifyAction?: string;
  /**
   * @remarks
   * Specifies whether to skip the Waiting for Traffic Switchover state. During the upgrade or downgrade, a new outbound IP address may be added to the API Gateway instance. The Waiting for Traffic Switchover state is used to remind users of adding the new outbound IP address to the whitelist. If you set the SkipWaitSwitch parameter to true, the instance does not enter the Waiting for Traffic Switchover state when a new outbound IP address is available. Instead, the system sends internal messages to the user.
   * 
   * @example
   * false
   */
  skipWaitSwitch?: boolean;
  /**
   * @remarks
   * The password.
   * 
   * This parameter is required.
   * 
   * @example
   * b5845042-2f2f-4e96-bd5c-36c6e5c2a68c
   */
  token?: string;
  static names(): { [key: string]: string } {
    return {
      autoPay: 'AutoPay',
      instanceId: 'InstanceId',
      instanceSpec: 'InstanceSpec',
      modifyAction: 'ModifyAction',
      skipWaitSwitch: 'SkipWaitSwitch',
      token: 'Token',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoPay: 'boolean',
      instanceId: 'string',
      instanceSpec: 'string',
      modifyAction: 'string',
      skipWaitSwitch: 'boolean',
      token: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceSpecResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 36BBBAD4-1CFB-489F-841A-8CA52EEA787E
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceSpecResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyInstanceSpecResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyInstanceSpecResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyIntranetDomainPolicyRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the API group. This ID is generated by the system and globally unique.
   * 
   * This parameter is required.
   * 
   * @example
   * 523e8dc7bbe04613b5b1d726c2a7889d
   */
  groupId?: string;
  securityToken?: string;
  /**
   * @remarks
   * Specifies whether to enable the VPC domain name. Valid values:
   * 
   * *   TRUE
   * *   FALSE
   * 
   * This parameter is required.
   * 
   * @example
   * true
   */
  vpcIntranetEnable?: boolean;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      securityToken: 'SecurityToken',
      vpcIntranetEnable: 'VpcIntranetEnable',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      securityToken: 'string',
      vpcIntranetEnable: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyIntranetDomainPolicyResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BA984
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyIntranetDomainPolicyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyIntranetDomainPolicyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyIntranetDomainPolicyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyIpControlRequest extends $tea.Model {
  /**
   * @remarks
   * The description. The description can be up to 200 characters in length.
   * 
   * @example
   * description
   */
  description?: string;
  /**
   * @remarks
   * The ID of the ACL. The ID is unique.
   * 
   * This parameter is required.
   * 
   * @example
   * 7ea91319a34d48a09b5c9c871d9768b1
   */
  ipControlId?: string;
  /**
   * @remarks
   * The name of the ACL. The name must be 4 to 50 characters in length, and can contain letters, digits, and underscores (_). The name cannot start with an underscore (_).
   * 
   * @example
   * testControl11
   */
  ipControlName?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      ipControlId: 'IpControlId',
      ipControlName: 'IpControlName',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      ipControlId: 'string',
      ipControlName: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyIpControlResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ004
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyIpControlResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyIpControlResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyIpControlResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyIpControlPolicyItemRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the application that is restricted by the policy. You can configure the AppId parameter only when the value of the IpControlType parameter is ALLOW.
   * 
   * *   You can add only one application ID at a time.
   * *   If this parameter is empty, no applications are restricted.
   * *   If this parameter is not empty, not only IP addresses but also applications are restricted.
   * *   If this parameter is not empty and no security authentication method is specified for the API, all API calls are restricted.
   * *   If the value of the IpControlType parameter is REFUSE and the AppId parameter is not empty, API Gateway automatically ignores the AppId parameter and restricts only the IP addresses.
   * 
   * @example
   * 123
   */
  appId?: string;
  /**
   * @remarks
   * The IP address or CIDR block that is defined in a policy. Separate multiple IP addresses or CIDR blocks with semicolons (;). You can add a maximum of 10 IP addresses or CIDR blocks.
   * 
   * This parameter is required.
   * 
   * @example
   * 113.125.1.101;101.11.1.1
   */
  cidrIp?: string;
  /**
   * @remarks
   * The ID of the ACL. The ID is unique.
   * 
   * This parameter is required.
   * 
   * @example
   * 7ea91319a34d48a09b5c9c871d9768b1
   */
  ipControlId?: string;
  /**
   * @remarks
   * The ID of the policy.
   * 
   * This parameter is required.
   * 
   * @example
   * P151617000829241
   */
  policyItemId?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      cidrIp: 'CidrIp',
      ipControlId: 'IpControlId',
      policyItemId: 'PolicyItemId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      cidrIp: 'string',
      ipControlId: 'string',
      policyItemId: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyIpControlPolicyItemResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ004
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyIpControlPolicyItemResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyIpControlPolicyItemResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyIpControlPolicyItemResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyLogConfigRequest extends $tea.Model {
  /**
   * @example
   * PROVIDER
   */
  logType?: string;
  securityToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * logs-gateway
   */
  slsLogStore?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * ford-api-gateway-log
   */
  slsProject?: string;
  static names(): { [key: string]: string } {
    return {
      logType: 'LogType',
      securityToken: 'SecurityToken',
      slsLogStore: 'SlsLogStore',
      slsProject: 'SlsProject',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logType: 'string',
      securityToken: 'string',
      slsLogStore: 'string',
      slsProject: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyLogConfigResponseBody extends $tea.Model {
  /**
   * @example
   * 75A4ADCB-AA26-51FB-94D4-AB3240040974
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyLogConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyLogConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyLogConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyModelRequest extends $tea.Model {
  /**
   * @remarks
   * The description of the new model definition.
   * 
   * @example
   * Model Description
   */
  description?: string;
  /**
   * @remarks
   * The ID of the API group to which the model belongs.
   * 
   * This parameter is required.
   * 
   * @example
   * 30e792398d6c4569b04c0e53a3494381
   */
  groupId?: string;
  /**
   * @remarks
   * The name of the model.
   * 
   * This parameter is required.
   * 
   * @example
   * Test
   */
  modelName?: string;
  /**
   * @remarks
   * The new name of the model.
   * 
   * @example
   * NewTest
   */
  newModelName?: string;
  /**
   * @remarks
   * The new definition of the model.
   * 
   * @example
   * {\\"type\\":\\"object\\",\\"properties\\":{\\"id\\":{\\"format\\":\\"int64\\",\\"maximum\\":100,\\"exclusiveMaximum\\":true,\\"type\\":\\"integer\\"},\\"name\\":{\\"maxLength\\":10,\\"type\\":\\"string\\"}}}
   */
  schema?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      groupId: 'GroupId',
      modelName: 'ModelName',
      newModelName: 'NewModelName',
      schema: 'Schema',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      groupId: 'string',
      modelName: 'string',
      newModelName: 'string',
      schema: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyModelResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 4173F95B-360C-460C-9F6C-4A960B904411
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyModelResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyModelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyModelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyPluginRequest extends $tea.Model {
  /**
   * @remarks
   * The description of the plug-in. The description can contain a maximum of 200 characters in length.
   * 
   * @example
   * modify plugin first
   */
  description?: string;
  /**
   * @remarks
   * The statement that is used to modify the plug-in definition.
   * 
   * @example
   * Plugin definition
   */
  pluginData?: string;
  /**
   * @remarks
   * The ID of the plug-in whose information you want to modify.
   * 
   * This parameter is required.
   * 
   * @example
   * a96926e82f994915a8da40a119374537
   */
  pluginId?: string;
  /**
   * @remarks
   * The name of the plug-in. The name must be 4 to 50 characters in length and can contain letters, digits, and underscores (_). However, it cannot start with an underscore.
   * 
   * @example
   * modifyCors
   */
  pluginName?: string;
  securityToken?: string;
  /**
   * @remarks
   * The tag of objects that match the rule. You can specify multiple tags.
   * 
   * @example
   * Key， Value
   */
  tag?: ModifyPluginRequestTag[];
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      pluginData: 'PluginData',
      pluginId: 'PluginId',
      pluginName: 'PluginName',
      securityToken: 'SecurityToken',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      pluginData: 'string',
      pluginId: 'string',
      pluginName: 'string',
      securityToken: 'string',
      tag: { 'type': 'array', 'itemType': ModifyPluginRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyPluginResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CE5722A6-AE78-4741-A9B0-6C817D360510
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyPluginResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyPluginResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyPluginResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifySignatureRequest extends $tea.Model {
  /**
   * @remarks
   * The security token included in the WebSocket request header. The system uses this token to authenticate the request.
   * 
   * @example
   * 436fa39b-b3b9-40c5-ae5d-ce3e000e38c5
   */
  securityToken?: string;
  /**
   * @remarks
   * The ID of the signature key that you want to manage.
   * 
   * This parameter is required.
   * 
   * @example
   * dd05f1c54d6749eda95f9fa6d491449a
   */
  signatureId?: string;
  /**
   * @remarks
   * The new Key value of the key. The value must be 6 to 20 characters in length and can contain letters, digits, and underscores (_). It must start with a letter.
   * 
   * @example
   * qwertyuiop
   */
  signatureKey?: string;
  /**
   * @remarks
   * The new name of the key. The name must be 4 to 50 characters in length and can contain letters, digits, and underscores (_). It must start with a letter.
   * 
   * @example
   * backendsignature
   */
  signatureName?: string;
  /**
   * @remarks
   * The new Secret value of the key. The value must be 6 to 30 characters in length and can contain letters, digits, and special characters. Special characters include underscores (_), at signs (@), number signs (#), exclamation points (!), and asterisks (\\*). The value must start with a letter.
   * 
   * @example
   * asdfghjkl
   */
  signatureSecret?: string;
  static names(): { [key: string]: string } {
    return {
      securityToken: 'SecurityToken',
      signatureId: 'SignatureId',
      signatureKey: 'SignatureKey',
      signatureName: 'SignatureName',
      signatureSecret: 'SignatureSecret',
    };
  }

  static types(): { [key: string]: any } {
    return {
      securityToken: 'string',
      signatureId: 'string',
      signatureKey: 'string',
      signatureName: 'string',
      signatureSecret: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifySignatureResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ004
   */
  requestId?: string;
  /**
   * @remarks
   * The ID of the key.
   * 
   * @example
   * dd05f1c54d6749eda95f9fa6d491449a
   */
  signatureId?: string;
  /**
   * @remarks
   * The name of the key.
   * 
   * @example
   * backendsignature
   */
  signatureName?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      signatureId: 'SignatureId',
      signatureName: 'SignatureName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      signatureId: 'string',
      signatureName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifySignatureResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifySignatureResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifySignatureResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTrafficControlRequest extends $tea.Model {
  /**
   * @remarks
   * The default throttling value for each API.
   * 
   * @example
   * 10000
   */
  apiDefault?: number;
  /**
   * @remarks
   * The default throttling value for each app.
   * 
   * @example
   * 10000
   */
  appDefault?: number;
  /**
   * @remarks
   * The description of the throttling policy.
   * 
   * @example
   * ThrottlingTestDescription
   */
  description?: string;
  /**
   * @remarks
   * The security token included in the WebSocket request header. The system uses this token to authenticate the request.
   * 
   * @example
   * 4223a10e-eed3-46a6-8b7c-23003f488153
   */
  securityToken?: string;
  /**
   * @remarks
   * The ID of the throttling policy.
   * 
   * This parameter is required.
   * 
   * @example
   * tf123456
   */
  trafficControlId?: string;
  /**
   * @remarks
   * The throttling policy name. The name must be 4 to 50 characters in length and can contain letters, digits, and underscores (_). It cannot start with an underscore.
   * 
   * @example
   * ThrottlingTest
   */
  trafficControlName?: string;
  /**
   * @remarks
   * The unit to be used in the throttling policy. Valid values:
   * 
   * *   **SECOND**
   * *   **MINUTE**
   * *   **HOUR**
   * *   **DAY**
   * 
   * @example
   * HOUR
   */
  trafficControlUnit?: string;
  /**
   * @remarks
   * The default throttling value for each user.
   * 
   * @example
   * 10000
   */
  userDefault?: number;
  static names(): { [key: string]: string } {
    return {
      apiDefault: 'ApiDefault',
      appDefault: 'AppDefault',
      description: 'Description',
      securityToken: 'SecurityToken',
      trafficControlId: 'TrafficControlId',
      trafficControlName: 'TrafficControlName',
      trafficControlUnit: 'TrafficControlUnit',
      userDefault: 'UserDefault',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiDefault: 'number',
      appDefault: 'number',
      description: 'string',
      securityToken: 'string',
      trafficControlId: 'string',
      trafficControlName: 'string',
      trafficControlUnit: 'string',
      userDefault: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTrafficControlResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ004
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTrafficControlResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyTrafficControlResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyTrafficControlResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyVpcAccessAndUpdateApisRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the new instance.
   * 
   * @example
   * i-uf6bzcg1pr4oh5jjmxxx
   */
  instanceId?: string;
  /**
   * @remarks
   * The name of the VPC authorization.
   * 
   * > 
   * 
   * *   The name of a VPC authorization cannot be changed. You cannot use this parameter to change the name of a VPC authorization.
   * 
   * *   You must set this parameter to the name of the current VPC authorization.
   * 
   * This parameter is required.
   * 
   * @example
   * VpcName
   */
  name?: string;
  /**
   * @remarks
   * Specifies whether to update the associated API.
   * 
   * **
   * 
   * **Warning:** If you want to update the VPC authorization of a published API, you must set this parameter to true. Otherwise, the update will not be synchronized to the backend service of the API.
   * 
   * @example
   * true
   */
  needBatchWork?: boolean;
  /**
   * @remarks
   * The new port number.
   * 
   * @example
   * 80
   */
  port?: number;
  /**
   * @remarks
   * Specifies whether to update the VPC authorization.
   * 
   * > 
   * 
   * *   If the ID of the instance in your VPC is changed but the IP address of the instance remains unchanged, you can set this parameter to true to update the VPC authorization.
   * 
   * @example
   * false
   */
  refresh?: boolean;
  securityToken?: string;
  /**
   * @remarks
   * The token of the request.
   * 
   * @example
   * c20d86c4-1eb3-4d0b-afe9-c586df1e2136
   */
  token?: string;
  /**
   * @remarks
   * The ID of the new VPC.
   * 
   * @example
   * vpc-m5e7jqfppv5wbvmdw5pg2
   */
  vpcId?: string;
  /**
   * @remarks
   * The hostname of the backend service.
   * 
   * @example
   * iot.hu***ng.com
   */
  vpcTargetHostName?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      name: 'Name',
      needBatchWork: 'NeedBatchWork',
      port: 'Port',
      refresh: 'Refresh',
      securityToken: 'SecurityToken',
      token: 'Token',
      vpcId: 'VpcId',
      vpcTargetHostName: 'VpcTargetHostName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      name: 'string',
      needBatchWork: 'boolean',
      port: 'number',
      refresh: 'boolean',
      securityToken: 'string',
      token: 'string',
      vpcId: 'string',
      vpcTargetHostName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyVpcAccessAndUpdateApisResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the asynchronous task.
   * 
   * > 
   * 
   * *   If the associated API is updated, you can use the task ID in the **DescribeUpdateVpcInfoTask** operation to query the update result.
   * 
   * @example
   * 7b6d0cb72b2e4215b0129f675c889746
   */
  operationId?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * C2CEC6EA-EEBA-5FD6-8BD9-2CF01980FE39
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      operationId: 'OperationId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      operationId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyVpcAccessAndUpdateApisResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyVpcAccessAndUpdateApisResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyVpcAccessAndUpdateApisResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OpenApiGatewayServiceResponseBody extends $tea.Model {
  /**
   * @example
   * 210981***530495
   */
  orderId?: string;
  /**
   * @example
   * 2D39D1B3-8548-508A-9CE2-7F4A3F2A7989
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OpenApiGatewayServiceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: OpenApiGatewayServiceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: OpenApiGatewayServiceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryRequestLogsRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the request log.
   * 
   * This parameter is required.
   * 
   * @example
   * 95657ED9-2F6F-426F-BD99-79C8********
   */
  requestLogId?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      requestLogId: 'RequestLogId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestLogId: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryRequestLogsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CE5722A6-AE78-4741-A9B0-6C81********
   */
  requestId?: string;
  /**
   * @remarks
   * The request logs.
   */
  requestLogs?: QueryRequestLogsResponseBodyRequestLogs;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      requestLogs: 'RequestLogs',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      requestLogs: QueryRequestLogsResponseBodyRequestLogs,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryRequestLogsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: QueryRequestLogsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryRequestLogsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReactivateDomainRequest extends $tea.Model {
  /**
   * @remarks
   * The custom domain name.
   * 
   * This parameter is required.
   * 
   * @example
   * api.demo.com
   */
  domainName?: string;
  /**
   * @remarks
   * The ID of the API group. This ID is generated by the system and globally unique.
   * 
   * This parameter is required.
   * 
   * @example
   * 927d50c0f2e54b359919923d908bb015
   */
  groupId?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      groupId: 'GroupId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      groupId: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReactivateDomainResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 6EF60BEC-0242-43AF-BB20-270359FB54A7
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReactivateDomainResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ReactivateDomainResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ReactivateDomainResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveAccessControlListEntryRequest extends $tea.Model {
  /**
   * @example
   * [{\\"entry\\":\\"192.168.1.0/24\\",\\"comment\\":\\"WhiteIp\\"}]
   */
  aclEntrys?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * acl-bp12ag0xxcfhq1ll68wp9
   */
  aclId?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      aclEntrys: 'AclEntrys',
      aclId: 'AclId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aclEntrys: 'string',
      aclId: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveAccessControlListEntryResponseBody extends $tea.Model {
  /**
   * @example
   * D1B18FFE-4A81-59D8-AA02-1817098977CD
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveAccessControlListEntryResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RemoveAccessControlListEntryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RemoveAccessControlListEntryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveApiProductsAuthoritiesRequest extends $tea.Model {
  /**
   * @remarks
   * The API products.
   * 
   * This parameter is required.
   */
  apiProductIds?: string[];
  /**
   * @remarks
   * The application ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 110982490
   */
  appId?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      apiProductIds: 'ApiProductIds',
      appId: 'AppId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiProductIds: { 'type': 'array', 'itemType': 'string' },
      appId: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveApiProductsAuthoritiesShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The API products.
   * 
   * This parameter is required.
   */
  apiProductIdsShrink?: string;
  /**
   * @remarks
   * The application ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 110982490
   */
  appId?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      apiProductIdsShrink: 'ApiProductIds',
      appId: 'AppId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiProductIdsShrink: 'string',
      appId: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveApiProductsAuthoritiesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * CEB6EC62-B6C7-5082-A45A-45A204724AC2
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveApiProductsAuthoritiesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RemoveApiProductsAuthoritiesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RemoveApiProductsAuthoritiesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveApisAuthoritiesRequest extends $tea.Model {
  /**
   * @remarks
   * The IDs of the APIs. Separate multiple API IDs with commas (,). A maximum of 100 API IDs can be entered.
   * 
   * This parameter is required.
   * 
   * @example
   * baacc592e63a4cb6a41920d9d3f91f38,jkscc489e63a4cb6a41920d9d3f92d78
   */
  apiIds?: string;
  /**
   * @remarks
   * The ID of the appplication. The ID is generated by the system and globally unique.
   * 
   * This parameter is required.
   * 
   * @example
   * 2386789
   */
  appId?: number;
  /**
   * @remarks
   * The description of the authorization.
   * 
   * @example
   * Queries weather based on the region name
   */
  description?: string;
  /**
   * @remarks
   * The ID of the API group. This ID is generated by the system and globally unique.
   * 
   * @example
   * 523e8dc7bbe04613b5b1d726c2a7889d
   */
  groupId?: string;
  securityToken?: string;
  /**
   * @remarks
   * The name of the runtime environment. Valid values:
   * 
   * *   **RELEASE**
   * *   **TEST**
   * 
   * This parameter is required.
   * 
   * @example
   * TEST
   */
  stageName?: string;
  static names(): { [key: string]: string } {
    return {
      apiIds: 'ApiIds',
      appId: 'AppId',
      description: 'Description',
      groupId: 'GroupId',
      securityToken: 'SecurityToken',
      stageName: 'StageName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiIds: 'string',
      appId: 'number',
      description: 'string',
      groupId: 'string',
      securityToken: 'string',
      stageName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveApisAuthoritiesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * D6E46F10-F26C-4AA0-BB69-FE2743D9AE62
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveApisAuthoritiesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RemoveApisAuthoritiesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RemoveApisAuthoritiesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveAppsAuthoritiesRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the API. This ID is generated by the system and globally unique.
   * 
   * This parameter is required.
   * 
   * @example
   * baacc592e63a4cb6a41920d9d3f91f38
   */
  apiId?: string;
  /**
   * @remarks
   * The IDs of applications. Separate multiple application IDs with commas (,). A maximum of 100 applications IDs can be entered.
   * 
   * This parameter is required.
   * 
   * @example
   * 2386789,3286798
   */
  appIds?: string;
  /**
   * @remarks
   * The ID of the API group. This ID is generated by the system and globally unique.
   * 
   * @example
   * 523e8dc7bbe04613b5b1d726c2a7889d
   */
  groupId?: string;
  securityToken?: string;
  /**
   * @remarks
   * The name of the runtime environment. Valid values:
   * 
   * *   **RELEASE**
   * *   **TEST**
   * 
   * This parameter is required.
   * 
   * @example
   * TEST
   */
  stageName?: string;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      appIds: 'AppIds',
      groupId: 'GroupId',
      securityToken: 'SecurityToken',
      stageName: 'StageName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'string',
      appIds: 'string',
      groupId: 'string',
      securityToken: 'string',
      stageName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveAppsAuthoritiesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * D6E46F10-F26C-4AA0-BB69-FE2743D9AE62
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveAppsAuthoritiesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RemoveAppsAuthoritiesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RemoveAppsAuthoritiesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveIpControlApisRequest extends $tea.Model {
  /**
   * @remarks
   * The IDs of the APIs from which you want to unbind the ACL.
   * 
   * *   If this parameter is not specified, the ACL is unbound from all the APIs in the specified environment of the API group.
   * *   The IDs of APIs that you want to query. Separate multiple API IDs with commas (,). A maximum of 100 API IDs can be entered.
   * 
   * @example
   * 123
   */
  apiIds?: string;
  /**
   * @remarks
   * The ID of the API group.
   * 
   * This parameter is required.
   * 
   * @example
   * 0009db9c828549768a200320714b8930
   */
  groupId?: string;
  /**
   * @remarks
   * The ID of the ACL.
   * 
   * This parameter is required.
   * 
   * @example
   * dd05f1c54d6749eda95f9fa6d491449a
   */
  ipControlId?: string;
  securityToken?: string;
  /**
   * @remarks
   * The name of the runtime environment. Valid values:
   * 
   * *   **RELEASE**
   * *   **TEST**
   * 
   * This parameter is required.
   * 
   * @example
   * TEST
   */
  stageName?: string;
  static names(): { [key: string]: string } {
    return {
      apiIds: 'ApiIds',
      groupId: 'GroupId',
      ipControlId: 'IpControlId',
      securityToken: 'SecurityToken',
      stageName: 'StageName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiIds: 'string',
      groupId: 'string',
      ipControlId: 'string',
      securityToken: 'string',
      stageName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveIpControlApisResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ004
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveIpControlApisResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RemoveIpControlApisResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RemoveIpControlApisResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveIpControlPolicyItemRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the ACL. The ID is unique.
   * 
   * This parameter is required.
   * 
   * @example
   * 7ea91319a34d48a09b5c9c871d9768b1
   */
  ipControlId?: string;
  /**
   * @remarks
   * The ID of a policy. Separate multiple IDs with semicolons (;). A maximum of 100 IDs can be entered.
   * 
   * This parameter is required.
   * 
   * @example
   * P151533572852362;P151533557750260
   */
  policyItemIds?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      ipControlId: 'IpControlId',
      policyItemIds: 'PolicyItemIds',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ipControlId: 'string',
      policyItemIds: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveIpControlPolicyItemResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ004
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveIpControlPolicyItemResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RemoveIpControlPolicyItemResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RemoveIpControlPolicyItemResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveSignatureApisRequest extends $tea.Model {
  /**
   * @remarks
   * The IDs of the APIs from which you want to unbind the signature key.
   * 
   * *   If this parameter is not specified, the signature key is unbound from all the APIs in the specified environment of the API group.
   * *   The IDs of the APIs that you want to manage. Separate multiple API IDs with commas (,). A maximum of 100 API IDs can be entered.
   * 
   * @example
   * 123
   */
  apiIds?: string;
  /**
   * @remarks
   * The ID of the API group to which the API that you want to manage belongs.
   * 
   * This parameter is required.
   * 
   * @example
   * 0009db9c828549768a200320714b8930
   */
  groupId?: string;
  securityToken?: string;
  /**
   * @remarks
   * The ID of the signature key.
   * 
   * This parameter is required.
   * 
   * @example
   * dd05f1c54d6749eda95f9fa6d491449a
   */
  signatureId?: string;
  /**
   * @remarks
   * The name of the runtime environment. Valid values:
   * 
   * *   **RELEASE**
   * *   **TEST**
   * 
   * This parameter is required.
   * 
   * @example
   * TEST
   */
  stageName?: string;
  static names(): { [key: string]: string } {
    return {
      apiIds: 'ApiIds',
      groupId: 'GroupId',
      securityToken: 'SecurityToken',
      signatureId: 'SignatureId',
      stageName: 'StageName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiIds: 'string',
      groupId: 'string',
      securityToken: 'string',
      signatureId: 'string',
      stageName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveSignatureApisResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ004
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveSignatureApisResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RemoveSignatureApisResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RemoveSignatureApisResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveTrafficControlApisRequest extends $tea.Model {
  /**
   * @remarks
   * The IDs of the APIs from which you want to unbind a specified throttling policy.
   * 
   * *   If this parameter is not specified, the throttling policy is unbound from all the APIs in the specified environment of the API group.
   * *   Separate multiple API IDs with commas (,). A maximum of 100 API IDs can be entered.
   * 
   * @example
   * 3b81fd160f5645e097cc8855d75a1cf6,46fbb52840d146f186e38e8e70fc8c12
   */
  apiIds?: string;
  /**
   * @remarks
   * The ID of the API group containing the APIs from which you want to unbind a specified throttling policy.
   * 
   * This parameter is required.
   * 
   * @example
   * 0009db9c828549768a200320714b8930
   */
  groupId?: string;
  /**
   * @remarks
   * The security token included in the WebSocket request header. The system uses this token to authenticate the request.
   * 
   * @example
   * 4223a10e-eed3-46a6-8b7c-23003f488153
   */
  securityToken?: string;
  /**
   * @remarks
   * The name of the runtime environment. Valid values:
   * 
   * *   **RELEASE**
   * *   **TEST**
   * 
   * This parameter is required.
   * 
   * @example
   * TEST
   */
  stageName?: string;
  /**
   * @remarks
   * The ID of the throttling policy that you want to unbind from APIs.
   * 
   * This parameter is required.
   * 
   * @example
   * dd05f1c54d6749eda95f9fa6d491449a
   */
  trafficControlId?: string;
  static names(): { [key: string]: string } {
    return {
      apiIds: 'ApiIds',
      groupId: 'GroupId',
      securityToken: 'SecurityToken',
      stageName: 'StageName',
      trafficControlId: 'TrafficControlId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiIds: 'string',
      groupId: 'string',
      securityToken: 'string',
      stageName: 'string',
      trafficControlId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveTrafficControlApisResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ004
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveTrafficControlApisResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RemoveTrafficControlApisResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RemoveTrafficControlApisResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveVpcAccessRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of an ECS or SLB instance in the VPC.
   * 
   * This parameter is required.
   * 
   * @example
   * i-uf6bzcg1pr4oh5jjmxxx
   */
  instanceId?: string;
  /**
   * @remarks
   * Specifies whether batch work is required.
   * 
   * @example
   * true
   */
  needBatchWork?: boolean;
  /**
   * @remarks
   * The port number that corresponds to the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * 80
   */
  port?: number;
  securityToken?: string;
  /**
   * @remarks
   * The ID of the VPC.
   * 
   * This parameter is required.
   * 
   * @example
   * vpc-uf657qec7lx42paw3qxxx
   */
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      needBatchWork: 'NeedBatchWork',
      port: 'Port',
      securityToken: 'SecurityToken',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      needBatchWork: 'boolean',
      port: 'number',
      securityToken: 'string',
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveVpcAccessResponseBody extends $tea.Model {
  /**
   * @remarks
   * API operations
   */
  apis?: RemoveVpcAccessResponseBodyApis;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ015
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      apis: 'Apis',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apis: RemoveVpcAccessResponseBodyApis,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveVpcAccessResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RemoveVpcAccessResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RemoveVpcAccessResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveVpcAccessAndAbolishApisRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * i-uf6iaale3gfef9t9cb41
   */
  instanceId?: string;
  /**
   * @example
   * true
   */
  needBatchWork?: boolean;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 8080
   */
  port?: number;
  securityToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * vpc-bp1iw82phcgkvupgfv0o8
   */
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      needBatchWork: 'NeedBatchWork',
      port: 'Port',
      securityToken: 'SecurityToken',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      needBatchWork: 'boolean',
      port: 'number',
      securityToken: 'string',
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveVpcAccessAndAbolishApisResponseBody extends $tea.Model {
  /**
   * @example
   * f7834d74be4e41aa8e607b0fafae9b33
   */
  operationId?: string;
  /**
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ016
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      operationId: 'OperationId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      operationId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveVpcAccessAndAbolishApisResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RemoveVpcAccessAndAbolishApisResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RemoveVpcAccessAndAbolishApisResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResetAppCodeRequest extends $tea.Model {
  /**
   * @remarks
   * The AppCode of the app.
   * 
   * This parameter is required.
   * 
   * @example
   * 3aaf905a0a1f4f0eabc6d891dfa08afc
   */
  appCode?: string;
  /**
   * @remarks
   * The new AppCode of the app.
   * 
   * @example
   * 6f0e7ab2aa5f4b8fb18421e6edf4fb6c2
   */
  newAppCode?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      appCode: 'AppCode',
      newAppCode: 'NewAppCode',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appCode: 'string',
      newAppCode: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResetAppCodeResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * D1B18FFE-4A81-59D8-AA02-1817098977CD
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResetAppCodeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ResetAppCodeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ResetAppCodeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResetAppSecretRequest extends $tea.Model {
  /**
   * @remarks
   * The key of the application that is used to make an API call.
   * 
   * This parameter is required.
   * 
   * @example
   * 60030986
   */
  appKey?: string;
  /**
   * @remarks
   * The new AppKey that you set must be globally unique.
   * 
   * @example
   * testAppKey
   */
  newAppKey?: string;
  /**
   * @remarks
   * The new key of the application. To improve compatibility, we recommend that you use other parameters.
   * 
   * @example
   * test***
   */
  newAppSecret?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      appKey: 'AppKey',
      newAppKey: 'NewAppKey',
      newAppSecret: 'NewAppSecret',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appKey: 'string',
      newAppKey: 'string',
      newAppSecret: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResetAppSecretResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ015
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResetAppSecretResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ResetAppSecretResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ResetAppSecretResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SdkGenerateByAppRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 110797019
   */
  appId?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * java
   */
  language?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      language: 'Language',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'number',
      language: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SdkGenerateByAppResponseBody extends $tea.Model {
  /**
   * @example
   * UEsDBBQACAAIADdwnFQAAAAAAAAAAAAAAAA2AAAAQ0FTREtfSkFWQV8xMjI3NDY2NjY0MzM0MTMzXzE2NTExMjU3MD......
   */
  downloadLink?: string;
  /**
   * @example
   * 61A16D46-EC04-5288-8A18-811B0F536CC2
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      downloadLink: 'DownloadLink',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      downloadLink: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SdkGenerateByAppResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SdkGenerateByAppResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SdkGenerateByAppResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SdkGenerateByAppForRegionRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 110906109
   */
  appId?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * java
   */
  language?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      language: 'Language',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'number',
      language: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SdkGenerateByAppForRegionResponseBody extends $tea.Model {
  /**
   * @example
   * UEsDBBQACAAIADdwnFQAAAAAAAAAAAAAAAA2AAAAQ0FTREtfSkFWQV8xMjI3NDY2NjY0MzM0MTMzXzE2NTExMjU3MD......
   */
  downloadLink?: string;
  /**
   * @example
   * CE5722A6-AE78-4741-A9B0-6C817D360510
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      downloadLink: 'DownloadLink',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      downloadLink: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SdkGenerateByAppForRegionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SdkGenerateByAppForRegionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SdkGenerateByAppForRegionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SdkGenerateByGroupRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1a991a450b9548a1a3df38fd3af117c2
   */
  groupId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * java
   */
  language?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      language: 'Language',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      language: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SdkGenerateByGroupResponseBody extends $tea.Model {
  /**
   * @example
   * http://oss-bucket/object
   */
  downloadLink?: string;
  /**
   * @example
   * D0075BDA-8AED-5073-A70A-FE44E86AB20F
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      downloadLink: 'DownloadLink',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      downloadLink: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SdkGenerateByGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SdkGenerateByGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SdkGenerateByGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetAccessControlListAttributeRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * acl-bp1ohqkonqybecf4llbrc
   */
  aclId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * testAcl
   */
  aclName?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      aclId: 'AclId',
      aclName: 'AclName',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aclId: 'string',
      aclName: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetAccessControlListAttributeResponseBody extends $tea.Model {
  /**
   * @example
   * CEB6EC62-B6C7-5082-A45A-45A204724AC2
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetAccessControlListAttributeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SetAccessControlListAttributeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetAccessControlListAttributeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetApiProductsAuthoritiesRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   */
  apiProductIds?: string[];
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 111385984
   */
  appId?: number;
  authValidTime?: string;
  description?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      apiProductIds: 'ApiProductIds',
      appId: 'AppId',
      authValidTime: 'AuthValidTime',
      description: 'Description',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiProductIds: { 'type': 'array', 'itemType': 'string' },
      appId: 'number',
      authValidTime: 'string',
      description: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetApiProductsAuthoritiesShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   */
  apiProductIdsShrink?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 111385984
   */
  appId?: number;
  authValidTime?: string;
  description?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      apiProductIdsShrink: 'ApiProductIds',
      appId: 'AppId',
      authValidTime: 'AuthValidTime',
      description: 'Description',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiProductIdsShrink: 'string',
      appId: 'number',
      authValidTime: 'string',
      description: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetApiProductsAuthoritiesResponseBody extends $tea.Model {
  /**
   * @example
   * 2603F41E-77FC-59A3-840E-296578A9BDE0
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetApiProductsAuthoritiesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SetApiProductsAuthoritiesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetApiProductsAuthoritiesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetApisAuthoritiesRequest extends $tea.Model {
  /**
   * @remarks
   * The IDs of the APIs. Separate multiple API IDs with commas (,). A maximum of 100 API IDs can be entered.
   * 
   * @example
   * baacc592e63a4cb6a41920d9d3f91f38,jkscc489e63a4cb6a41920d9d3f92d78
   */
  apiIds?: string;
  /**
   * @remarks
   * The ID of the application. This ID is generated by the system and globally unique.
   * 
   * This parameter is required.
   * 
   * @example
   * 2386789
   */
  appId?: number;
  /**
   * @remarks
   * The time (UTC) when the authorization expires. If this parameter is empty, the authorization does not expire.
   * 
   * @example
   * Fri,05Oct201816:00:00GMT
   */
  authValidTime?: string;
  /**
   * @remarks
   * The description of the authorization.
   * 
   * @example
   * Queries weather based on the region name
   */
  description?: string;
  /**
   * @remarks
   * The ID of the API group. This ID is generated by the system and globally unique.
   * 
   * @example
   * 523e8dc7bbe04613b5b1d726c2a7889d
   */
  groupId?: string;
  securityToken?: string;
  /**
   * @remarks
   * The name of the runtime environment. Valid values:
   * 
   * *   **RELEASE**
   * *   **TEST**
   * 
   * This parameter is required.
   * 
   * @example
   * TEST
   */
  stageName?: string;
  static names(): { [key: string]: string } {
    return {
      apiIds: 'ApiIds',
      appId: 'AppId',
      authValidTime: 'AuthValidTime',
      description: 'Description',
      groupId: 'GroupId',
      securityToken: 'SecurityToken',
      stageName: 'StageName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiIds: 'string',
      appId: 'number',
      authValidTime: 'string',
      description: 'string',
      groupId: 'string',
      securityToken: 'string',
      stageName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetApisAuthoritiesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * D6E46F10-F26C-4AA0-BB69-FE2743D9AE62
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetApisAuthoritiesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SetApisAuthoritiesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetApisAuthoritiesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetAppsAuthToApiProductRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 117b7a64a8b3f064eaa4a47ac62aac5e
   */
  apiProductId?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  appIds?: number[];
  /**
   * @example
   * 2023-05-31T08:15:39Z
   */
  authValidTime?: string;
  description?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      apiProductId: 'ApiProductId',
      appIds: 'AppIds',
      authValidTime: 'AuthValidTime',
      description: 'Description',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiProductId: 'string',
      appIds: { 'type': 'array', 'itemType': 'number' },
      authValidTime: 'string',
      description: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetAppsAuthToApiProductResponseBody extends $tea.Model {
  /**
   * @example
   * EF924FE4-2EDD-4CD3-89EC-34E4708574E7
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetAppsAuthToApiProductResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SetAppsAuthToApiProductResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetAppsAuthToApiProductResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetAppsAuthoritiesRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the API. This ID is generated by the system and globally unique.
   * 
   * This parameter is required.
   * 
   * @example
   * baacc592e63a4cb6a41920d9d3f91f38
   */
  apiId?: string;
  /**
   * @remarks
   * The IDs of applications. Separate multiple application IDs with commas (,). A maximum of 100 applications IDs can be entered.
   * 
   * This parameter is required.
   * 
   * @example
   * 2386789,3389798
   */
  appIds?: string;
  /**
   * @remarks
   * The time (UTC) when the authorization expires. If this parameter is empty, the authorization does not expire.
   * 
   * @example
   * Fri,05Oct201816:00:00GMT
   */
  authValidTime?: string;
  /**
   * @remarks
   * The description of the authorization.
   * 
   * @example
   * Queries weather based on the region name
   */
  description?: string;
  /**
   * @remarks
   * The ID of the API group. This ID is generated by the system and globally unique.
   * 
   * @example
   * 523e8dc7bbe04613b5b1d726c2a7889d
   */
  groupId?: string;
  securityToken?: string;
  /**
   * @remarks
   * The name of the runtime environment. Valid values:
   * 
   * *   **RELEASE**
   * *   **TEST**
   * 
   * This parameter is required.
   * 
   * @example
   * TEST
   */
  stageName?: string;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      appIds: 'AppIds',
      authValidTime: 'AuthValidTime',
      description: 'Description',
      groupId: 'GroupId',
      securityToken: 'SecurityToken',
      stageName: 'StageName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'string',
      appIds: 'string',
      authValidTime: 'string',
      description: 'string',
      groupId: 'string',
      securityToken: 'string',
      stageName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetAppsAuthoritiesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * D6E46F10-F26C-4AA0-BB69-FE2743D9AE62
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetAppsAuthoritiesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SetAppsAuthoritiesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetAppsAuthoritiesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDomainRequest extends $tea.Model {
  /**
   * @remarks
   * The environment which you can access by using the domain name. If you do not specify this parameter, the domain name can be used to access all environments.
   * 
   * If you specify an environment, the domain name can be used to access only the specified environment. Valid values:
   * 
   * *   TEST
   * *   PRE
   * *   RELEASE
   * 
   * If you want to use the domain name to access all environments, set this parameter to an empty string ("").
   * 
   * @example
   * RELEASE
   */
  bindStageName?: string;
  /**
   * @remarks
   * The network type of the domain name to be bound. Default value: INTERNET. Valid values:
   * 
   * *   INTERNET
   * *   INTRANET. If you set this parameter to this value, the domain name cannot be used on the Internet.
   * 
   * @example
   * INTERNET
   */
  customDomainType?: string;
  /**
   * @remarks
   * The custom domain name.
   * 
   * This parameter is required.
   * 
   * @example
   * api.demo.com
   */
  domainName?: string;
  /**
   * @remarks
   * The ID of the API group. This ID is generated by the system and globally unique.
   * 
   * This parameter is required.
   * 
   * @example
   * 927d50c0f2e54b359919923d908bb015
   */
  groupId?: string;
  /**
   * @remarks
   * Specifies whether this binding relationship takes precedence over the binding relationships between the domain name and other API groups. If you set this parameter to true, this binding relationship takes precedence, and the domain name is automatically unbound from other API groups. This operation brings risks. Proceed with caution.
   * 
   * @example
   * false
   */
  isForce?: boolean;
  /**
   * @remarks
   * Specifies whether to redirect HTTP requests to HTTPS requests.
   * 
   * @example
   * false
   */
  isHttpRedirectToHttps?: boolean;
  static names(): { [key: string]: string } {
    return {
      bindStageName: 'BindStageName',
      customDomainType: 'CustomDomainType',
      domainName: 'DomainName',
      groupId: 'GroupId',
      isForce: 'IsForce',
      isHttpRedirectToHttps: 'IsHttpRedirectToHttps',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bindStageName: 'string',
      customDomainType: 'string',
      domainName: 'string',
      groupId: 'string',
      isForce: 'boolean',
      isHttpRedirectToHttps: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDomainResponseBody extends $tea.Model {
  /**
   * @remarks
   * The binding status of the custom domain name. Valid values:
   * 
   * *   **BINDING**: The domain name has been bound.
   * *   **BOUND**: The domain name has not been bound.
   * 
   * @example
   * BINDING
   */
  domainBindingStatus?: string;
  /**
   * @remarks
   * The validity status of the domain name. Valid values:
   * 
   * *   **NORMAL**: The domain name is valid.
   * *   **ABNORMAL**: The domain name is invalid. This status affects API calls and must be resolved as soon as possible.
   * 
   * @example
   * NORMAL
   */
  domainLegalStatus?: string;
  /**
   * @remarks
   * The custom domain name.
   * 
   * @example
   * api.demo.com
   */
  domainName?: string;
  /**
   * @remarks
   * The remarks on the domain name, such as the cause of an exception.
   * 
   * @example
   * None
   */
  domainRemark?: string;
  /**
   * @remarks
   * The status of the domain name that uses the WebSocket feature.
   * 
   * @example
   * NORMAL
   */
  domainWebSocketStatus?: string;
  /**
   * @remarks
   * The ID of the API group. This ID is generated by the system and globally unique.
   * 
   * @example
   * 927d50c0f2e54b359919923d908bb015
   */
  groupId?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0AA90E87-3506-5AA6-AFFB-A4D53B4F6231
   */
  requestId?: string;
  /**
   * @remarks
   * The second-level domain name assigned to the API group. This domain name is used to test API calls.
   * 
   * @example
   * xxx-cn-hangzhou.alicloudapi.com
   */
  subDomain?: string;
  static names(): { [key: string]: string } {
    return {
      domainBindingStatus: 'DomainBindingStatus',
      domainLegalStatus: 'DomainLegalStatus',
      domainName: 'DomainName',
      domainRemark: 'DomainRemark',
      domainWebSocketStatus: 'DomainWebSocketStatus',
      groupId: 'GroupId',
      requestId: 'RequestId',
      subDomain: 'SubDomain',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainBindingStatus: 'string',
      domainLegalStatus: 'string',
      domainName: 'string',
      domainRemark: 'string',
      domainWebSocketStatus: 'string',
      groupId: 'string',
      requestId: 'string',
      subDomain: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDomainResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SetDomainResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetDomainResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDomainCertificateRequest extends $tea.Model {
  /**
   * @remarks
   * The content of the CA certificate.
   * 
   * @example
   * Content of the CA certificate
   */
  caCertificateBody?: string;
  /**
   * @remarks
   * The content of the certificate.
   * 
   * @example
   * For more information, see the following request examples
   */
  certificateBody?: string;
  /**
   * @remarks
   * The name of the SSL certificate.
   * 
   * This parameter is required.
   * 
   * @example
   * test_cert
   */
  certificateName?: string;
  /**
   * @remarks
   * The private key of the SSL certificate.
   * 
   * @example
   * For more information, see the following request examples
   */
  certificatePrivateKey?: string;
  /**
   * @remarks
   * The custom domain name.
   * 
   * This parameter is required.
   * 
   * @example
   * api.demo.com
   */
  domainName?: string;
  /**
   * @remarks
   * The ID of the API group. This ID is generated by the system and globally unique.
   * 
   * This parameter is required.
   * 
   * @example
   * 927d50c0f2e54b359919923d908bb015
   */
  groupId?: string;
  securityToken?: string;
  /**
   * @remarks
   * The certificate verification depth.
   * 
   * @example
   * 2
   */
  sslVerifyDepth?: string;
  static names(): { [key: string]: string } {
    return {
      caCertificateBody: 'CaCertificateBody',
      certificateBody: 'CertificateBody',
      certificateName: 'CertificateName',
      certificatePrivateKey: 'CertificatePrivateKey',
      domainName: 'DomainName',
      groupId: 'GroupId',
      securityToken: 'SecurityToken',
      sslVerifyDepth: 'SslVerifyDepth',
    };
  }

  static types(): { [key: string]: any } {
    return {
      caCertificateBody: 'string',
      certificateBody: 'string',
      certificateName: 'string',
      certificatePrivateKey: 'string',
      domainName: 'string',
      groupId: 'string',
      securityToken: 'string',
      sslVerifyDepth: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDomainCertificateResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 6EF60BEC-0242-43AF-BB20-270359FB54A7
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDomainCertificateResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SetDomainCertificateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetDomainCertificateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDomainWebSocketStatusRequest extends $tea.Model {
  /**
   * @remarks
   * The action.
   * 
   * This parameter is required.
   * 
   * @example
   * OPEN
   */
  actionValue?: string;
  /**
   * @remarks
   * The custom domain name.
   * 
   * This parameter is required.
   * 
   * @example
   * ac.fluvet.cn
   */
  domainName?: string;
  /**
   * @remarks
   * The ID of the API group.
   * 
   * This parameter is required.
   * 
   * @example
   * cf976e63b70c4993807e7bb9345d4695
   */
  groupId?: string;
  securityToken?: string;
  WSSEnable?: string;
  static names(): { [key: string]: string } {
    return {
      actionValue: 'ActionValue',
      domainName: 'DomainName',
      groupId: 'GroupId',
      securityToken: 'SecurityToken',
      WSSEnable: 'WSSEnable',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actionValue: 'string',
      domainName: 'string',
      groupId: 'string',
      securityToken: 'string',
      WSSEnable: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDomainWebSocketStatusResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 61A16D46-EC04-5288-8A18-811B0F536CC2
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDomainWebSocketStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SetDomainWebSocketStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetDomainWebSocketStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetGroupAuthAppCodeRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   */
  authAppCode?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  groupId?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      authAppCode: 'AuthAppCode',
      groupId: 'GroupId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authAppCode: 'string',
      groupId: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetGroupAuthAppCodeResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetGroupAuthAppCodeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SetGroupAuthAppCodeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetGroupAuthAppCodeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetIpControlApisRequest extends $tea.Model {
  /**
   * @remarks
   * The API IDs. Separate multiple API IDs with commas (,). A maximum of 100 API IDs can be entered.
   * 
   * This parameter is required.
   * 
   * @example
   * 3b81fd160f5645e097cc8855d75a1cf6,46fbb52840d146f186e38e8e70fc8c12
   */
  apiIds?: string;
  /**
   * @remarks
   * The ID of the API group.
   * 
   * This parameter is required.
   * 
   * @example
   * 0009db9c828549768a200320714b8930
   */
  groupId?: string;
  /**
   * @remarks
   * The ID of the ACL.
   * 
   * This parameter is required.
   * 
   * @example
   * dd05f1c54d6749eda95f9fa6d491449a
   */
  ipControlId?: string;
  securityToken?: string;
  /**
   * @remarks
   * The name of the runtime environment. Valid values:
   * 
   * *   **RELEASE**
   * *   **PRE**
   * *   **TEST**
   * 
   * This parameter is required.
   * 
   * @example
   * TEST
   */
  stageName?: string;
  static names(): { [key: string]: string } {
    return {
      apiIds: 'ApiIds',
      groupId: 'GroupId',
      ipControlId: 'IpControlId',
      securityToken: 'SecurityToken',
      stageName: 'StageName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiIds: 'string',
      groupId: 'string',
      ipControlId: 'string',
      securityToken: 'string',
      stageName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetIpControlApisResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ004
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetIpControlApisResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SetIpControlApisResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetIpControlApisResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetSignatureApisRequest extends $tea.Model {
  /**
   * @remarks
   * The API IDs.
   * 
   * This parameter is required.
   * 
   * @example
   * 3b81fd160f5645e097cc8855d75a1cf6,46fbb52840d146f186e38e8e70fc8c12
   */
  apiIds?: string;
  /**
   * @remarks
   * The API group ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 0009db9c828549768a200320714b8930
   */
  groupId?: string;
  securityToken?: string;
  /**
   * @remarks
   * The signature ID.
   * 
   * This parameter is required.
   * 
   * @example
   * dd05f1c54d6749eda95f9fa6d491449a
   */
  signatureId?: string;
  /**
   * @remarks
   * The environment. Valid values:
   * 
   * *   **RELEASE**: the production environment
   * *   **PRE**: the staging environment
   * *   **TEST**: the testing environment
   * 
   * This parameter is required.
   * 
   * @example
   * TEST
   */
  stageName?: string;
  static names(): { [key: string]: string } {
    return {
      apiIds: 'ApiIds',
      groupId: 'GroupId',
      securityToken: 'SecurityToken',
      signatureId: 'SignatureId',
      stageName: 'StageName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiIds: 'string',
      groupId: 'string',
      securityToken: 'string',
      signatureId: 'string',
      stageName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetSignatureApisResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ004
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetSignatureApisResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SetSignatureApisResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetSignatureApisResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetTrafficControlApisRequest extends $tea.Model {
  /**
   * @remarks
   * The API ID for the specified operation. Separate multiple API IDs with commas (,). A maximum of 100 API IDs can be entered.
   * 
   * This parameter is required.
   * 
   * @example
   * 3b81fd160f5645e097cc8855d75a1cf6,46fbb52840d146f186e38e8e70fc8c12
   */
  apiIds?: string;
  /**
   * @remarks
   * The ID of the API group containing the APIs to which you want to bind a specified throttling policy.
   * 
   * This parameter is required.
   * 
   * @example
   * 0009db9c828549768a200320714b8930
   */
  groupId?: string;
  /**
   * @remarks
   * The security token included in the WebSocket request header. The system uses this token to authenticate the request.
   * 
   * @example
   * 556d15cb-0808-432d-ab07-33e6b961b703
   */
  securityToken?: string;
  /**
   * @remarks
   * The name of the runtime environment. Valid values:
   * 
   * *   **RELEASE**
   * *   **TEST**
   * 
   * This parameter is required.
   * 
   * @example
   * RELEASE
   */
  stageName?: string;
  /**
   * @remarks
   * The ID of the throttling policy.
   * 
   * This parameter is required.
   * 
   * @example
   * dd05f1c54d6749eda95f9fa6d491449a
   */
  trafficControlId?: string;
  static names(): { [key: string]: string } {
    return {
      apiIds: 'ApiIds',
      groupId: 'GroupId',
      securityToken: 'SecurityToken',
      stageName: 'StageName',
      trafficControlId: 'TrafficControlId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiIds: 'string',
      groupId: 'string',
      securityToken: 'string',
      stageName: 'string',
      trafficControlId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetTrafficControlApisResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ004
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetTrafficControlApisResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SetTrafficControlApisResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetTrafficControlApisResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetVpcAccessRequest extends $tea.Model {
  /**
   * @remarks
   * The description of the VPC.
   * 
   * @example
   * description of the VPC
   */
  description?: string;
  /**
   * @remarks
   * The ID of an ECS or SLB instance in the VPC.
   * 
   * This parameter is required.
   * 
   * @example
   * i-uf6bzcg1pr4oh5jjmxxx
   */
  instanceId?: string;
  /**
   * @remarks
   * The name of the authorization. The name must be unique.
   * 
   * This parameter is required.
   * 
   * @example
   * test
   */
  name?: string;
  /**
   * @remarks
   * The port number that corresponds to the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * 80
   */
  port?: number;
  securityToken?: string;
  /**
   * @remarks
   * The tag of objects that match the rule. You can specify multiple tags.
   */
  tag?: SetVpcAccessRequestTag[];
  /**
   * @remarks
   * The ID of the VPC. The VPC must be an available one that belongs to the same account as the API.
   * 
   * This parameter is required.
   * 
   * @example
   * vpc-uf657qec7lx42paw3qxxx
   */
  vpcId?: string;
  /**
   * @remarks
   * The host of the backend service.
   * 
   * @example
   * iot.hu***ng.com
   */
  vpcTargetHostName?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      instanceId: 'InstanceId',
      name: 'Name',
      port: 'Port',
      securityToken: 'SecurityToken',
      tag: 'Tag',
      vpcId: 'VpcId',
      vpcTargetHostName: 'VpcTargetHostName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      instanceId: 'string',
      name: 'string',
      port: 'number',
      securityToken: 'string',
      tag: { 'type': 'array', 'itemType': SetVpcAccessRequestTag },
      vpcId: 'string',
      vpcTargetHostName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetVpcAccessResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ015
   */
  requestId?: string;
  /**
   * @remarks
   * The ID of the VPC access authorization.
   * 
   * @example
   * 4c68e061860f441ab72af7404137440e
   */
  vpcAccessId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      vpcAccessId: 'VpcAccessId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      vpcAccessId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetVpcAccessResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SetVpcAccessResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetVpcAccessResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetWildcardDomainPatternsRequest extends $tea.Model {
  /**
   * @remarks
   * The custom domain name.
   * 
   * This parameter is required.
   * 
   * @example
   * *.prd.e-eir.com
   */
  domainName?: string;
  /**
   * @remarks
   * The ID of the API group. This ID is generated by the system and globally unique.
   * 
   * This parameter is required.
   * 
   * @example
   * 0009db9c828549768a200320714b8930
   */
  groupId?: string;
  securityToken?: string;
  /**
   * @remarks
   * The wildcard domain name mode.
   * 
   * @example
   * [\\"{svc}.prd.e-eir.com\\"]
   */
  wildcardDomainPatterns?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      groupId: 'GroupId',
      securityToken: 'SecurityToken',
      wildcardDomainPatterns: 'WildcardDomainPatterns',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      groupId: 'string',
      securityToken: 'string',
      wildcardDomainPatterns: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetWildcardDomainPatternsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * D0075BDA-8AED-5073-A70A-FE44E86AB20F
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetWildcardDomainPatternsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SetWildcardDomainPatternsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetWildcardDomainPatternsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SwitchApiRequest extends $tea.Model {
  /**
   * @remarks
   * The API ID.
   * 
   * This parameter is required.
   * 
   * @example
   * d6f679aeb3be4b91b3688e887ca1fe16
   */
  apiId?: string;
  /**
   * @remarks
   * The description. The description can be up to 200 characters in length.
   * 
   * This parameter is required.
   * 
   * @example
   * for_demo
   */
  description?: string;
  /**
   * @remarks
   * The API group ID.
   * 
   * @example
   * 123
   */
  groupId?: string;
  /**
   * @remarks
   * The historical version number of the API.
   * 
   * This parameter is required.
   * 
   * @example
   * 20160705104552292
   */
  historyVersion?: string;
  securityToken?: string;
  /**
   * @remarks
   * The environment. Valid values:
   * 
   * *   **RELEASE**: the production environment
   * *   **PRE**: the staging environment
   * *   **TEST**: the test environment
   * 
   * This parameter is required.
   * 
   * @example
   * RELEASE
   */
  stageName?: string;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      description: 'Description',
      groupId: 'GroupId',
      historyVersion: 'HistoryVersion',
      securityToken: 'SecurityToken',
      stageName: 'StageName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'string',
      description: 'string',
      groupId: 'string',
      historyVersion: 'string',
      securityToken: 'string',
      stageName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SwitchApiResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BZ001
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SwitchApiResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SwitchApiResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SwitchApiResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TagResourcesRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the resource.
   * 
   * This parameter is required.
   * 
   * @example
   * 285bb759342649a1b70c2093a772e087
   */
  resourceId?: string[];
  /**
   * @remarks
   * The type of the resource. Tags are bound to API groups, plug-ins, and applications. You can use tags to manage cloud resources by group. Valid values:
   * 
   * *   **apiGroup**
   * *   **plugin**
   * *   **app**
   * 
   * This parameter is required.
   * 
   * @example
   * apiGroup
   */
  resourceType?: string;
  securityToken?: string;
  /**
   * @remarks
   * The tag of objects that match the lifecycle rule. You can specify multiple tags.
   * 
   * This parameter is required.
   * 
   * @example
   * 2021022811
   */
  tag?: TagResourcesRequestTag[];
  static names(): { [key: string]: string } {
    return {
      resourceId: 'ResourceId',
      resourceType: 'ResourceType',
      securityToken: 'SecurityToken',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceId: { 'type': 'array', 'itemType': 'string' },
      resourceType: 'string',
      securityToken: 'string',
      tag: { 'type': 'array', 'itemType': TagResourcesRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TagResourcesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * EF924FE4-2EDD-4CD3-89EC-34E4708574E7
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TagResourcesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: TagResourcesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: TagResourcesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UntagResourcesRequest extends $tea.Model {
  /**
   * @remarks
   * Specifies whether to delete all tags. This parameter is valid only when the **TagKey.N**parameter is not specified. Default value: false. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  all?: boolean;
  /**
   * @remarks
   * The resource IDs.
   * 
   * This parameter is required.
   * 
   * @example
   * 285bb759342649a1b70c2093a772e087
   */
  resourceId?: string[];
  /**
   * @remarks
   * The type of the resource. Tags are bound to API groups, plug-ins, and applications. You can use tags to manage cloud resources by group. Valid values:
   * 
   * *   **apiGroup**
   * *   **plugin**
   * *   **app**
   * 
   * This parameter is required.
   * 
   * @example
   * apiGroup
   */
  resourceType?: string;
  /**
   * @remarks
   * The security token included in the WebSocket request header. The system uses this token to authenticate the request.
   * 
   * @example
   * 0f96f124-1276-4f81-b52b-c554240beb4c
   */
  securityToken?: string;
  /**
   * @remarks
   * The tag keys of the resource.
   * 
   * @example
   * env
   */
  tagKey?: string[];
  static names(): { [key: string]: string } {
    return {
      all: 'All',
      resourceId: 'ResourceId',
      resourceType: 'ResourceType',
      securityToken: 'SecurityToken',
      tagKey: 'TagKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      all: 'boolean',
      resourceId: { 'type': 'array', 'itemType': 'string' },
      resourceType: 'string',
      securityToken: 'string',
      tagKey: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UntagResourcesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CEF72CEB-54B6-4AE8-B225-F876FF7BA984
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UntagResourcesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UntagResourcesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UntagResourcesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePrivateDNSRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * api.demo.com
   */
  intranetDomain?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  records?: UpdatePrivateDNSRequestRecords[];
  securityToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * A
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      intranetDomain: 'IntranetDomain',
      records: 'Records',
      securityToken: 'SecurityToken',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      intranetDomain: 'string',
      records: { 'type': 'array', 'itemType': UpdatePrivateDNSRequestRecords },
      securityToken: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePrivateDNSShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * api.demo.com
   */
  intranetDomain?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  recordsShrink?: string;
  securityToken?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * A
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      intranetDomain: 'IntranetDomain',
      recordsShrink: 'Records',
      securityToken: 'SecurityToken',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      intranetDomain: 'string',
      recordsShrink: 'string',
      securityToken: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePrivateDNSResponseBody extends $tea.Model {
  /**
   * @example
   * EF924FE4-2EDD-4CD3-89EC-34E4708574E7
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePrivateDNSResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdatePrivateDNSResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdatePrivateDNSResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ValidateVpcConnectivityRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the API Gateway instance.
   * 
   * This parameter is required.
   * 
   * @example
   * apigateway-hz-72bc18******
   */
  instanceId?: string;
  securityToken?: string;
  /**
   * @remarks
   * The ID of the VPC access authorization.
   * 
   * This parameter is required.
   * 
   * @example
   * 5f1b3216f9********e2c1297b6741dc
   */
  vpcAccessId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      securityToken: 'SecurityToken',
      vpcAccessId: 'VpcAccessId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      securityToken: 'string',
      vpcAccessId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ValidateVpcConnectivityResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the API Gateway instance is connected to the port. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * True
   */
  connected?: boolean;
  /**
   * @remarks
   * Indicates whether the instance in the authorization is an ECS instance or an SLB instance when the instance ID in the authorization is an IP address. Valid values:
   * 
   * *   **ECS**
   * *   **SLB**
   * *   **INVALID**: The instance type corresponding to the IP address is invalid.
   * 
   * @example
   * ECS
   */
  ipType?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 9A591B5B-0EC2-5463-B8B8-1984AE3AEBF1
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      connected: 'Connected',
      ipType: 'IpType',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      connected: 'boolean',
      ipType: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ValidateVpcConnectivityResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ValidateVpcConnectivityResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ValidateVpcConnectivityResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AttachApiProductRequestApis extends $tea.Model {
  /**
   * @remarks
   * The API ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 551877242a4b4f3a84a56b7c3570e4a7
   */
  apiId?: string;
  /**
   * @remarks
   * The environment. Valid values:
   * 
   * *   **RELEASE**: the production environment
   * *   **PRE**: the staging environment
   * *   **TEST**: the test environment
   * 
   * This parameter is required.
   * 
   * @example
   * RELEASE
   */
  stageName?: string;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      stageName: 'StageName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'string',
      stageName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchAbolishApisRequestApi extends $tea.Model {
  /**
   * @remarks
   * The ID of the API.
   * 
   * This parameter is required.
   * 
   * @example
   * 994f72dcdaf04af0b38022c65fdbd1ac
   */
  apiUid?: string;
  /**
   * @remarks
   * The ID of the API group.
   * 
   * This parameter is required.
   * 
   * @example
   * ced5ab777f7b440398ea70e4470124de
   */
  groupId?: string;
  /**
   * @remarks
   * The ID of the environment.
   * 
   * @example
   * 979fd16250644d5b82173534f465ac77
   */
  stageId?: string;
  /**
   * @remarks
   * The name of the environment.
   * 
   * @example
   * RELEASE
   */
  stageName?: string;
  static names(): { [key: string]: string } {
    return {
      apiUid: 'ApiUid',
      groupId: 'GroupId',
      stageId: 'StageId',
      stageName: 'StageName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiUid: 'string',
      groupId: 'string',
      stageId: 'string',
      stageName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchDeployApisRequestApi extends $tea.Model {
  /**
   * @remarks
   * The API ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 2b35dd68345b472f8051647306a16415
   */
  apiUid?: string;
  /**
   * @remarks
   * The API group ID.
   * 
   * This parameter is required.
   * 
   * @example
   * b4f5c342b8bc4ef88ccda0332402e0fa
   */
  groupId?: string;
  static names(): { [key: string]: string } {
    return {
      apiUid: 'ApiUid',
      groupId: 'GroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiUid: 'string',
      groupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateApiRequestTag extends $tea.Model {
  /**
   * @remarks
   * The key of the tag.
   * 
   * @example
   * env
   */
  key?: string;
  /**
   * @remarks
   * The value of the tag.
   * 
   * @example
   * value
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateApiGroupRequestTag extends $tea.Model {
  /**
   * @example
   * key
   */
  key?: string;
  /**
   * @example
   * value
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAppRequestTag extends $tea.Model {
  /**
   * @remarks
   * The key of the tag.
   * 
   * Valid values of n: `[1, 20]`.
   * 
   * @example
   * env
   */
  key?: string;
  /**
   * @remarks
   * The value of the tag.
   * 
   * Valid values of n: `[1, 20]`. If the parameter has a value, you must specify a value for the tag key with the same N as tag.N.Key. Otherwise, an error is reported.
   * 
   * @example
   * \\" \\"
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateBackendRequestTag extends $tea.Model {
  /**
   * @remarks
   * The key of the tag.
   * 
   * @example
   * key
   */
  key?: string;
  /**
   * @remarks
   * The value of the tag.
   * 
   * @example
   * 123
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDatasetRequestTag extends $tea.Model {
  /**
   * @remarks
   * The key of the tag.
   * 
   * @example
   * env
   */
  key?: string;
  /**
   * @remarks
   * The value of the tag.
   * 
   * @example
   * 123
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateInstanceRequestTag extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * test1
   */
  key?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * v1
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateInstanceRequestZoneVSwitchSecurityGroup extends $tea.Model {
  /**
   * @remarks
   * The IPv4 CIDR block for the vSwitch.
   * 
   * @example
   * 192.168.9.0/24
   */
  cidrBlock?: string;
  /**
   * @remarks
   * The ID of the security group. Services in the same security group can access each other.
   * 
   * @example
   * sg-2ze2ql9nozv8q7kmlt6e
   */
  securityGroupId?: string;
  /**
   * @remarks
   * The vSwitch ID.
   * 
   * @example
   * vsw-0xi349n11cxogmvm866tb
   */
  vSwitchId?: string;
  /**
   * @remarks
   * The zone ID.
   * 
   * @example
   * cn-beijing-c
   */
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      cidrBlock: 'CidrBlock',
      securityGroupId: 'SecurityGroupId',
      vSwitchId: 'VSwitchId',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cidrBlock: 'string',
      securityGroupId: 'string',
      vSwitchId: 'string',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateIpControlRequestIpControlPolicys extends $tea.Model {
  /**
   * @remarks
   * The ID of the application that is restricted by the policy. You can configure the AppId parameter only when the value of the IpControlType parameter is ALLOW.
   * 
   * *   You can add only one application ID at a time.
   * *   If this parameter is empty, no applications are restricted.
   * *   If this parameter is not empty, not only IP addresses but also applications are restricted.
   * *   If this parameter is not empty and no security authentication method is specified for the API, all API calls are restricted.
   * *   If the value of the IpControlType parameter is REFUSE and the AppId parameter is not empty, API Gateway automatically ignores the AppId parameter and restricts only the IP addresses.
   * *   Valid values of N in IpControlPolicys.N: `[1,100]`.
   * 
   * @example
   * 11111
   */
  appId?: string;
  /**
   * @remarks
   * The IP address or CIDR block involved in a policy.
   * 
   * *   If you want to specify a policy when you create an ACL, this parameter is required.
   * *   The IP address or CIDR block that is defined in each policy. Separate multiple IP addresses or CIDR blocks with semicolons (;). You can add a maximum of 10 IP addresses or CIDR blocks.
   * *   Valid values of N in IpControlPolicys.N: `[1,100]`.
   * 
   * @example
   * 114.1.1.0/24
   */
  cidrIp?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      cidrIp: 'CidrIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      cidrIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateModelRequestTag extends $tea.Model {
  /**
   * @remarks
   * The key of the tag.
   * 
   * @example
   * key
   */
  key?: string;
  /**
   * @remarks
   * The values of the tag.
   * 
   * @example
   * 123
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePluginRequestTag extends $tea.Model {
  /**
   * @remarks
   * The key of the tag.
   * 
   * N can be an integer from 1 to 20.``
   * 
   * This parameter is required.
   * 
   * @example
   * env
   */
  key?: string;
  /**
   * @remarks
   * The value of the tag.
   * 
   * N can be an integer from 1 to 20.``
   * 
   * This parameter is required.
   * 
   * @example
   * \\" \\"
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePrivateDNSRequestRecords extends $tea.Model {
  /**
   * @example
   * 192.168.0.1
   */
  record?: string;
  /**
   * @example
   * 100
   */
  weight?: number;
  static names(): { [key: string]: string } {
    return {
      record: 'Record',
      weight: 'Weight',
    };
  }

  static types(): { [key: string]: any } {
    return {
      record: 'string',
      weight: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteApiGroupRequestTag extends $tea.Model {
  /**
   * @remarks
   * The key of the tag.
   * 
   * This parameter is required.
   * 
   * @example
   * key
   */
  key?: string;
  /**
   * @remarks
   * The value of the tag.
   * 
   * This parameter is required.
   * 
   * @example
   * value
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAppRequestTag extends $tea.Model {
  /**
   * @remarks
   * The key of the tag.
   * 
   * This parameter is required.
   * 
   * @example
   * appname
   */
  key?: string;
  /**
   * @remarks
   * The value of the tag.
   * 
   * @example
   * testapp
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteInstanceRequestTag extends $tea.Model {
  /**
   * @remarks
   * The key of the tag.
   * 
   * This parameter is required.
   * 
   * @example
   * key
   */
  key?: string;
  /**
   * @remarks
   * The value of the tag.
   * 
   * This parameter is required.
   * 
   * @example
   * value
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePluginRequestTag extends $tea.Model {
  /**
   * @remarks
   * The key of the tag.
   * 
   * N can be an integer from 1 to 20.``
   * 
   * This parameter is required.
   * 
   * @example
   * env
   */
  key?: string;
  /**
   * @remarks
   * The value of the tag.
   * 
   * N can be an integer from 1 to 20.``
   * 
   * This parameter is required.
   * 
   * @example
   * \\" \\"
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAbolishApiTaskResponseBodyApiAbolishResultsApiAbolishResult extends $tea.Model {
  /**
   * @remarks
   * The unpublishing status.
   * 
   * @example
   * OVER
   */
  abolishStatus?: string;
  /**
   * @remarks
   * The name of the API.
   * 
   * @example
   * v2_page_consent
   */
  apiName?: string;
  /**
   * @remarks
   * The ID of the API.
   * 
   * @example
   * 4e26cdbbb113416dba1f0285bed29979
   */
  apiUid?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * Success. Request Success.
   */
  errorMsg?: string;
  /**
   * @remarks
   * The ID of the API group.
   * 
   * @example
   * 160cb6505e1c43a6b84346856d74eb47
   */
  groupId?: string;
  /**
   * @remarks
   * The name of the API group.
   * 
   * @example
   * wb2022021401619286
   */
  groupName?: string;
  /**
   * @remarks
   * The ID of the runtime environment.
   * 
   * @example
   * 0919f2854a88484c91dc9253347c78f9
   */
  stageId?: string;
  /**
   * @remarks
   * The name of the runtime environment. Valid values:
   * 
   * *   **RELEASE**
   * *   **TEST**
   * 
   * @example
   * RELEASE
   */
  stageName?: string;
  static names(): { [key: string]: string } {
    return {
      abolishStatus: 'AbolishStatus',
      apiName: 'ApiName',
      apiUid: 'ApiUid',
      errorMsg: 'ErrorMsg',
      groupId: 'GroupId',
      groupName: 'GroupName',
      stageId: 'StageId',
      stageName: 'StageName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      abolishStatus: 'string',
      apiName: 'string',
      apiUid: 'string',
      errorMsg: 'string',
      groupId: 'string',
      groupName: 'string',
      stageId: 'string',
      stageName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAbolishApiTaskResponseBodyApiAbolishResults extends $tea.Model {
  apiAbolishResult?: DescribeAbolishApiTaskResponseBodyApiAbolishResultsApiAbolishResult[];
  static names(): { [key: string]: string } {
    return {
      apiAbolishResult: 'ApiAbolishResult',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiAbolishResult: { 'type': 'array', 'itemType': DescribeAbolishApiTaskResponseBodyApiAbolishResultsApiAbolishResult },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAccessControlListAttributeResponseBodyAclEntrysAclEntry extends $tea.Model {
  /**
   * @remarks
   * The entry description.
   * 
   * @example
   * default
   */
  aclEntryComment?: string;
  /**
   * @remarks
   * The ACL entry.
   * 
   * @example
   * 192.168.1.0/24
   */
  aclEntryIp?: string;
  static names(): { [key: string]: string } {
    return {
      aclEntryComment: 'AclEntryComment',
      aclEntryIp: 'AclEntryIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aclEntryComment: 'string',
      aclEntryIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAccessControlListAttributeResponseBodyAclEntrys extends $tea.Model {
  aclEntry?: DescribeAccessControlListAttributeResponseBodyAclEntrysAclEntry[];
  static names(): { [key: string]: string } {
    return {
      aclEntry: 'AclEntry',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aclEntry: { 'type': 'array', 'itemType': DescribeAccessControlListAttributeResponseBodyAclEntrysAclEntry },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAccessControlListsResponseBodyAclsAcl extends $tea.Model {
  /**
   * @remarks
   * The ID of the access control policy.
   * 
   * @example
   * acl-3nsohdozz0ru8fi5onwz1
   */
  aclId?: string;
  /**
   * @remarks
   * The name of the access control policy.
   * 
   * @example
   * testAcl
   */
  aclName?: string;
  /**
   * @remarks
   * 访问控制策略组的IP版本。
   * - **IPv4**。
   * - **IPv6**。
   * 
   * @example
   * ipv4
   */
  addressIPVersion?: string;
  static names(): { [key: string]: string } {
    return {
      aclId: 'AclId',
      aclName: 'AclName',
      addressIPVersion: 'AddressIPVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aclId: 'string',
      aclName: 'string',
      addressIPVersion: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAccessControlListsResponseBodyAcls extends $tea.Model {
  acl?: DescribeAccessControlListsResponseBodyAclsAcl[];
  static names(): { [key: string]: string } {
    return {
      acl: 'Acl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acl: { 'type': 'array', 'itemType': DescribeAccessControlListsResponseBodyAclsAcl },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiResponseBodyBackendConfig extends $tea.Model {
  /**
   * @remarks
   * The ID of the backend service.
   * 
   * @example
   * 0038e00c3dca44fcba3a94015d8f5bbf
   */
  backendId?: string;
  /**
   * @remarks
   * The name of the backend service.
   * 
   * @example
   * testoss
   */
  backendName?: string;
  /**
   * @remarks
   * Backend service type
   * 
   * @example
   * HTTP
   */
  backendType?: string;
  static names(): { [key: string]: string } {
    return {
      backendId: 'BackendId',
      backendName: 'BackendName',
      backendType: 'BackendType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      backendId: 'string',
      backendName: 'string',
      backendType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiResponseBodyConstantParametersConstantParameter extends $tea.Model {
  /**
   * @remarks
   * The constant parameter value.
   * 
   * @example
   * constance
   */
  constantValue?: string;
  /**
   * @remarks
   * The parameter description.
   * 
   * @example
   * constance
   */
  description?: string;
  /**
   * @remarks
   * The parameter location. Valid values: BODY, HEAD, QUERY, and PATH.
   * 
   * @example
   * HEAD
   */
  location?: string;
  /**
   * @remarks
   * The mapped parameter name in the backend service.
   * 
   * @example
   * constance
   */
  serviceParameterName?: string;
  static names(): { [key: string]: string } {
    return {
      constantValue: 'ConstantValue',
      description: 'Description',
      location: 'Location',
      serviceParameterName: 'ServiceParameterName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      constantValue: 'string',
      description: 'string',
      location: 'string',
      serviceParameterName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiResponseBodyConstantParameters extends $tea.Model {
  constantParameter?: DescribeApiResponseBodyConstantParametersConstantParameter[];
  static names(): { [key: string]: string } {
    return {
      constantParameter: 'ConstantParameter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      constantParameter: { 'type': 'array', 'itemType': DescribeApiResponseBodyConstantParametersConstantParameter },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiResponseBodyCustomSystemParametersCustomSystemParameter extends $tea.Model {
  /**
   * @remarks
   * The example value.
   * 
   * @example
   * 192.168.1.1
   */
  demoValue?: string;
  /**
   * @remarks
   * The parameter description.
   * 
   * @example
   * Client IP Address
   */
  description?: string;
  /**
   * @remarks
   * The parameter location. Valid values: BODY, HEAD, QUERY, and PATH.
   * 
   * @example
   * HEAD
   */
  location?: string;
  /**
   * @remarks
   * The name of the system parameter. Valid values: CaClientIp, CaDomain, CaRequestHandleTime, CaAppId, CaRequestId, CaHttpSchema, and CaProxy.
   * 
   * @example
   * CaClientIp
   */
  parameterName?: string;
  /**
   * @remarks
   * The mapped parameter name in the backend service.
   * 
   * @example
   * clientIp
   */
  serviceParameterName?: string;
  static names(): { [key: string]: string } {
    return {
      demoValue: 'DemoValue',
      description: 'Description',
      location: 'Location',
      parameterName: 'ParameterName',
      serviceParameterName: 'ServiceParameterName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      demoValue: 'string',
      description: 'string',
      location: 'string',
      parameterName: 'string',
      serviceParameterName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiResponseBodyCustomSystemParameters extends $tea.Model {
  customSystemParameter?: DescribeApiResponseBodyCustomSystemParametersCustomSystemParameter[];
  static names(): { [key: string]: string } {
    return {
      customSystemParameter: 'CustomSystemParameter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      customSystemParameter: { 'type': 'array', 'itemType': DescribeApiResponseBodyCustomSystemParametersCustomSystemParameter },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiResponseBodyDeployedInfosDeployedInfo extends $tea.Model {
  /**
   * @remarks
   * The deployment status. Valid values: DEPLOYED and NONDEPLOYED.
   * 
   * @example
   * DEPLOYED
   */
  deployedStatus?: string;
  /**
   * @remarks
   * The effective version.
   * 
   * @example
   * xxx
   */
  effectiveVersion?: string;
  /**
   * @remarks
   * The environment to which the API is published. Valid values: RELEASE and TEST.
   * 
   * @example
   * RELEASE
   */
  stageName?: string;
  static names(): { [key: string]: string } {
    return {
      deployedStatus: 'DeployedStatus',
      effectiveVersion: 'EffectiveVersion',
      stageName: 'StageName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deployedStatus: 'string',
      effectiveVersion: 'string',
      stageName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiResponseBodyDeployedInfos extends $tea.Model {
  deployedInfo?: DescribeApiResponseBodyDeployedInfosDeployedInfo[];
  static names(): { [key: string]: string } {
    return {
      deployedInfo: 'DeployedInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deployedInfo: { 'type': 'array', 'itemType': DescribeApiResponseBodyDeployedInfosDeployedInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiResponseBodyErrorCodeSamplesErrorCodeSample extends $tea.Model {
  /**
   * @remarks
   * The returned error code.
   * 
   * @example
   * 400
   */
  code?: string;
  /**
   * @remarks
   * The error description.
   * 
   * @example
   * The UserId parameter is missing from the request.
   */
  description?: string;
  /**
   * @remarks
   * The returned error message.
   * 
   * @example
   * Missing the parameter UserId
   */
  message?: string;
  /**
   * @remarks
   * The model.
   * 
   * @example
   * [\\"*\\"]
   */
  model?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      description: 'Description',
      message: 'Message',
      model: 'Model',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      description: 'string',
      message: 'string',
      model: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiResponseBodyErrorCodeSamples extends $tea.Model {
  errorCodeSample?: DescribeApiResponseBodyErrorCodeSamplesErrorCodeSample[];
  static names(): { [key: string]: string } {
    return {
      errorCodeSample: 'ErrorCodeSample',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCodeSample: { 'type': 'array', 'itemType': DescribeApiResponseBodyErrorCodeSamplesErrorCodeSample },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiResponseBodyOpenIdConnectConfig extends $tea.Model {
  /**
   * @remarks
   * The name of the parameter that corresponds to the token.
   * 
   * @example
   * xxx
   */
  idTokenParamName?: string;
  /**
   * @remarks
   * The OpenID Connect mode. Valid values:
   * 
   * *   **IDTOKEN**: indicates the APIs that are called by clients to obtain tokens. If you specify this value, the PublicKeyId parameter and the PublicKey parameter are required.
   * *   **BUSINESS**: indicates business APIs. Tokens are used to call the business APIs. If you specify this value, the IdTokenParamName parameter is required.
   * 
   * @example
   * IDTOKEN
   */
  openIdApiType?: string;
  /**
   * @remarks
   * The public key.
   * 
   * @example
   * EB1837F8693CCED0BF750B3AD48467BEB569E780A14591CF92
   */
  publicKey?: string;
  /**
   * @remarks
   * The ID of the public key.
   * 
   * @example
   * 88483727556929326703309904351185815489
   */
  publicKeyId?: string;
  static names(): { [key: string]: string } {
    return {
      idTokenParamName: 'IdTokenParamName',
      openIdApiType: 'OpenIdApiType',
      publicKey: 'PublicKey',
      publicKeyId: 'PublicKeyId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      idTokenParamName: 'string',
      openIdApiType: 'string',
      publicKey: 'string',
      publicKeyId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiResponseBodyRequestConfig extends $tea.Model {
  /**
   * @remarks
   * This parameter takes effect only when the RequestMode parameter is set to MAPPING.********
   * 
   * The server data transmission method used for POST and PUT requests. Valid values: FORM and STREAM. FORM indicates that data in key-value pairs is transmitted as forms. STREAM indicates that data is transmitted as byte streams.
   * 
   * @example
   * STREAM
   */
  bodyFormat?: string;
  /**
   * @remarks
   * The body model.
   * 
   * @example
   * https://apigateway.aliyun.com/models/3a240a127dcc4afd9ab1bf7e947b4095/9e2df550e85b4121a79ec33e2619eaab
   */
  bodyModel?: string;
  /**
   * @remarks
   * Whether to escape the Path parameter, if true, the [param] on the Path will be treated as a regular character.
   * 
   * @example
   * true
   */
  escapePathParam?: boolean;
  /**
   * @remarks
   * The description of the request body.
   * 
   * @example
   * fwefwef
   */
  postBodyDescription?: string;
  /**
   * @remarks
   * The HTTP method used to make the request. Valid values: GET, POST, DELETE, PUT, HEADER, TRACE, PATCH, CONNECT, and OPTIONS.
   * 
   * @example
   * POST
   */
  requestHttpMethod?: string;
  /**
   * @remarks
   * The request mode. Valid values: MAPPING and PASSTHROUGH.
   * 
   * @example
   * MAPPING
   */
  requestMode?: string;
  /**
   * @remarks
   * The API request path. If the complete API URL is `http://api.a.com:8080/object/add?key1=value1&key2=value2`, the API request path is ` /object/add  `.
   * 
   * @example
   * /api/billing/test/[type]
   */
  requestPath?: string;
  /**
   * @remarks
   * The protocol type supported by the API. Valid values: HTTP and HTTPS. Separate multiple values with commas (,), such as "HTTP,HTTPS".
   * 
   * @example
   * HTTP
   */
  requestProtocol?: string;
  static names(): { [key: string]: string } {
    return {
      bodyFormat: 'BodyFormat',
      bodyModel: 'BodyModel',
      escapePathParam: 'EscapePathParam',
      postBodyDescription: 'PostBodyDescription',
      requestHttpMethod: 'RequestHttpMethod',
      requestMode: 'RequestMode',
      requestPath: 'RequestPath',
      requestProtocol: 'RequestProtocol',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bodyFormat: 'string',
      bodyModel: 'string',
      escapePathParam: 'boolean',
      postBodyDescription: 'string',
      requestHttpMethod: 'string',
      requestMode: 'string',
      requestPath: 'string',
      requestProtocol: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiResponseBodyRequestParametersRequestParameter extends $tea.Model {
  /**
   * @remarks
   * The parameter name.
   * 
   * @example
   * age
   */
  apiParameterName?: string;
  /**
   * @remarks
   * The type of the array element.
   * 
   * @example
   * String
   */
  arrayItemsType?: string;
  /**
   * @remarks
   * The default value.
   * 
   * @example
   * 20
   */
  defaultValue?: string;
  /**
   * @remarks
   * The example value.
   * 
   * @example
   * 20
   */
  demoValue?: string;
  /**
   * @remarks
   * The parameter description.
   * 
   * @example
   * Age
   */
  description?: string;
  /**
   * @remarks
   * The order in which the parameter is sorted in the document.
   * 
   * @example
   * 0
   */
  docOrder?: number;
  /**
   * @remarks
   * Indicates whether the document is public. Valid values: **PUBLIC** and **PRIVATE**.
   * 
   * @example
   * PUBLIC
   */
  docShow?: string;
  /**
   * @remarks
   * The hash values that are supported when **ParameterType** is set to Int, Long, Float, Double, or String. Separate values with commas (,). Examples: 1,2,3,4,9 and A,B,C,E,F.
   * 
   * @example
   * boy,girl
   */
  enumValue?: string;
  /**
   * @remarks
   * The JSON Schema used for JSON validation when **ParameterType** is set to String.
   * 
   * @example
   * JSON
   */
  jsonScheme?: string;
  /**
   * @remarks
   * The parameter location. Valid values: BODY, HEAD, QUERY, and PATH.
   * 
   * @example
   * HEAD
   */
  location?: string;
  /**
   * @remarks
   * The maximum parameter length when **ParameterType** is set to String.
   * 
   * @example
   * 123456
   */
  maxLength?: number;
  /**
   * @remarks
   * The maximum parameter value when **ParameterType** is set to Int, Long, Float, or Double.
   * 
   * @example
   * 123456
   */
  maxValue?: number;
  /**
   * @remarks
   * The minimum parameter length when **ParameterType** is set to String.
   * 
   * @example
   * 123456
   */
  minLength?: number;
  /**
   * @remarks
   * The minimum parameter value when **ParameterType** is set to Int, Long, Float, or Double.
   * 
   * @example
   * 123456
   */
  minValue?: number;
  /**
   * @remarks
   * The data type of the parameter. Valid values: String, Int, Long, Float, Double, and Boolean.
   * 
   * @example
   * String
   */
  parameterType?: string;
  /**
   * @remarks
   * The regular expression that is used for parameter validation when **ParameterType** is set to String.
   * 
   * @example
   * xxx
   */
  regularExpression?: string;
  /**
   * @remarks
   * Indicates whether the parameter is required. Valid values: **REQUIRED** and **OPTIONAL**.
   * 
   * @example
   * OPTIONAL
   */
  required?: string;
  static names(): { [key: string]: string } {
    return {
      apiParameterName: 'ApiParameterName',
      arrayItemsType: 'ArrayItemsType',
      defaultValue: 'DefaultValue',
      demoValue: 'DemoValue',
      description: 'Description',
      docOrder: 'DocOrder',
      docShow: 'DocShow',
      enumValue: 'EnumValue',
      jsonScheme: 'JsonScheme',
      location: 'Location',
      maxLength: 'MaxLength',
      maxValue: 'MaxValue',
      minLength: 'MinLength',
      minValue: 'MinValue',
      parameterType: 'ParameterType',
      regularExpression: 'RegularExpression',
      required: 'Required',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiParameterName: 'string',
      arrayItemsType: 'string',
      defaultValue: 'string',
      demoValue: 'string',
      description: 'string',
      docOrder: 'number',
      docShow: 'string',
      enumValue: 'string',
      jsonScheme: 'string',
      location: 'string',
      maxLength: 'number',
      maxValue: 'number',
      minLength: 'number',
      minValue: 'number',
      parameterType: 'string',
      regularExpression: 'string',
      required: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiResponseBodyRequestParameters extends $tea.Model {
  requestParameter?: DescribeApiResponseBodyRequestParametersRequestParameter[];
  static names(): { [key: string]: string } {
    return {
      requestParameter: 'RequestParameter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestParameter: { 'type': 'array', 'itemType': DescribeApiResponseBodyRequestParametersRequestParameter },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiResponseBodyServiceConfigEventBridgeConfig extends $tea.Model {
  /**
   * @remarks
   * The ID of the region where the EventBridge instance is located.
   * 
   * @example
   * cn-beijing
   */
  eventBridgeRegionId?: string;
  /**
   * @remarks
   * The event bus.
   * 
   * @example
   * testBus
   */
  eventBus?: string;
  /**
   * @remarks
   * The event source.
   * 
   * @example
   * baas_driver
   */
  eventSource?: string;
  /**
   * @remarks
   * The Arn that is authorized by a RAM user to EventBridge.
   * 
   * @example
   * acs:ram::1933122015759***:role/adminoidcaliyun
   */
  roleArn?: string;
  static names(): { [key: string]: string } {
    return {
      eventBridgeRegionId: 'EventBridgeRegionId',
      eventBus: 'EventBus',
      eventSource: 'EventSource',
      roleArn: 'RoleArn',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventBridgeRegionId: 'string',
      eventBus: 'string',
      eventSource: 'string',
      roleArn: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiResponseBodyServiceConfigFunctionComputeConfig extends $tea.Model {
  /**
   * @remarks
   * The ContentType header type used when you call the backend service over HTTP.
   * 
   * *   **DEFAULT**: the default header type in API Gateway
   * *   **CUSTOM**: a custom header type
   * *   **CLIENT**: the ContentType header type of the client
   * 
   * @example
   * DEFAULT
   */
  contentTypeCatagory?: string;
  /**
   * @remarks
   * The value of the ContentType header when the ContentTypeCatagory parameter is set to DEFAULT or CUSTOM.
   * 
   * @example
   * application/x-www-form-urlencoded; charset=UTF-8
   */
  contentTypeValue?: string;
  /**
   * @remarks
   * The root path of Function Compute.
   * 
   * @example
   * https://1227****64334133.ap-southeast-1-int***al.fc.aliyuncs.com/201****-15/proxy/test****ice.LATEST/testHttp/
   */
  fcBaseUrl?: string;
  /**
   * @remarks
   * The type of the Function Compute instance.
   * 
   * @example
   * HttpTrigger
   */
  fcType?: string;
  /**
   * @remarks
   * The function name defined in Function Compute.
   * 
   * @example
   * edge_function
   */
  functionName?: string;
  /**
   * @remarks
   * The request method.
   * 
   * @example
   * GET
   */
  method?: string;
  /**
   * @remarks
   * The backend only receives the service path.
   * 
   * @example
   * false
   */
  onlyBusinessPath?: boolean;
  /**
   * @remarks
   * The API request path.
   * 
   * @example
   * /api/offline/cacheData
   */
  path?: string;
  /**
   * @remarks
   * The alias of the function.
   * 
   * @example
   * 2
   */
  qualifier?: string;
  /**
   * @remarks
   * The region where the Function Compute instance is located.
   * 
   * @example
   * cn-qingdao
   */
  regionId?: string;
  /**
   * @remarks
   * The Alibaba Cloud Resource Name (ARN) of the RAM role to be assumed by API Gateway to access Function Compute.
   * 
   * @example
   * acs:ram::111***:role/aliyunserviceroleforsas
   */
  roleArn?: string;
  /**
   * @remarks
   * The service name defined in Function Compute.
   * 
   * @example
   * fcservicename
   */
  serviceName?: string;
  static names(): { [key: string]: string } {
    return {
      contentTypeCatagory: 'ContentTypeCatagory',
      contentTypeValue: 'ContentTypeValue',
      fcBaseUrl: 'FcBaseUrl',
      fcType: 'FcType',
      functionName: 'FunctionName',
      method: 'Method',
      onlyBusinessPath: 'OnlyBusinessPath',
      path: 'Path',
      qualifier: 'Qualifier',
      regionId: 'RegionId',
      roleArn: 'RoleArn',
      serviceName: 'ServiceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contentTypeCatagory: 'string',
      contentTypeValue: 'string',
      fcBaseUrl: 'string',
      fcType: 'string',
      functionName: 'string',
      method: 'string',
      onlyBusinessPath: 'boolean',
      path: 'string',
      qualifier: 'string',
      regionId: 'string',
      roleArn: 'string',
      serviceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiResponseBodyServiceConfigMockHeadersMockHeader extends $tea.Model {
  /**
   * @remarks
   * The HTTP header.
   * 
   * @example
   * Content-Length
   */
  headerName?: string;
  /**
   * @remarks
   * The value of the HTTP header.
   * 
   * @example
   * 86400
   */
  headerValue?: string;
  static names(): { [key: string]: string } {
    return {
      headerName: 'HeaderName',
      headerValue: 'HeaderValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headerName: 'string',
      headerValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiResponseBodyServiceConfigMockHeaders extends $tea.Model {
  mockHeader?: DescribeApiResponseBodyServiceConfigMockHeadersMockHeader[];
  static names(): { [key: string]: string } {
    return {
      mockHeader: 'MockHeader',
    };
  }

  static types(): { [key: string]: any } {
    return {
      mockHeader: { 'type': 'array', 'itemType': DescribeApiResponseBodyServiceConfigMockHeadersMockHeader },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiResponseBodyServiceConfigOssConfig extends $tea.Model {
  /**
   * @remarks
   * The operation options on OSS. Valid values:
   * 
   * *   GetObject
   * *   PostObject
   * *   DeleteObject
   * *   PutObject
   * *   HeadObject
   * *   GetObjectMeta
   * *   AppendObject
   * 
   * @example
   * GetObject
   */
  action?: string;
  /**
   * @remarks
   * The OSS bucket.
   * 
   * @example
   * cbg-db
   */
  bucketName?: string;
  /**
   * @remarks
   * The stored object or folder path.
   * 
   * @example
   * /folder/test.json
   */
  key?: string;
  /**
   * @remarks
   * The ID of the region where the OSS instance is located.
   * 
   * @example
   * cn-hangzhou
   */
  ossRegionId?: string;
  static names(): { [key: string]: string } {
    return {
      action: 'Action',
      bucketName: 'BucketName',
      key: 'Key',
      ossRegionId: 'OssRegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      action: 'string',
      bucketName: 'string',
      key: 'string',
      ossRegionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiResponseBodyServiceConfigVpcConfig extends $tea.Model {
  /**
   * @remarks
   * The ID of the ECS or SLB instance in the VPC.
   * 
   * @example
   * i-bp1h497hkijewv2***
   */
  instanceId?: string;
  /**
   * @remarks
   * The name of the VPC access authorization.
   * 
   * @example
   * glmall-app-test
   */
  name?: string;
  /**
   * @remarks
   * The port number that corresponds to the instance.
   * 
   * @example
   * 8080
   */
  port?: number;
  /**
   * @remarks
   * The ID of the VPC.
   * 
   * @example
   * vpc-2zeafsc3fygk1***
   */
  vpcId?: string;
  /**
   * @remarks
   * The VPC protocol.
   * 
   * @example
   * HTTP
   */
  vpcScheme?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      name: 'Name',
      port: 'Port',
      vpcId: 'VpcId',
      vpcScheme: 'VpcScheme',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      name: 'string',
      port: 'number',
      vpcId: 'string',
      vpcScheme: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiResponseBodyServiceConfig extends $tea.Model {
  /**
   * @remarks
   * The application name in AONE.
   * 
   * @example
   * ib-blank
   */
  aoneAppName?: string;
  /**
   * @remarks
   * The ContentType header type used when you call the backend service over HTTP.
   * 
   * *   **DEFAULT**: the default header type in API Gateway
   * *   **CUSTOM**: a custom header type
   * *   **CLIENT**: the ContentType header type of the client
   * 
   * @example
   * CUSTOM
   */
  contentTypeCatagory?: string;
  /**
   * @remarks
   * The value of the ContentType header when the ServiceProtocol parameter is set to HTTP and the ContentTypeCatagory parameter is set to DEFAULT or CUSTOM.
   * 
   * @example
   * application/x-www-form-urlencoded; charset=UTF-8
   */
  contentTypeValue?: string;
  /**
   * @remarks
   * Configuration items of EventBridge
   */
  eventBridgeConfig?: DescribeApiResponseBodyServiceConfigEventBridgeConfig;
  /**
   * @remarks
   * Backend configuration items when the backend service is Function Compute
   */
  functionComputeConfig?: DescribeApiResponseBodyServiceConfigFunctionComputeConfig;
  /**
   * @remarks
   * Specifies whether to enable the Mock mode. Valid values:
   * 
   * *   **TRUE**: The Mock mode is enabled.
   * *   **FALSE**: The Mock mode is not enabled.
   * 
   * @example
   * TRUE
   */
  mock?: string;
  /**
   * @remarks
   * The simulated headers.
   */
  mockHeaders?: DescribeApiResponseBodyServiceConfigMockHeaders;
  /**
   * @remarks
   * The result returned when the Mock mode is enabled.
   * 
   * @example
   * test result
   */
  mockResult?: string;
  /**
   * @remarks
   * The status code returned for service mocking.
   * 
   * @example
   * 200
   */
  mockStatusCode?: number;
  /**
   * @remarks
   * The information returned when the backend service is Object Storage Service (OSS).
   */
  ossConfig?: DescribeApiResponseBodyServiceConfigOssConfig;
  /**
   * @remarks
   * The URL used to call the back-end service. If the complete back-end service URL is `http://api.a.com:8080/object/add?key1=value1&key2=value2`, the value of ServiceAddress is **http://api.a.com:8080**.``
   * 
   * @example
   * http://api.a.com:8080
   */
  serviceAddress?: string;
  /**
   * @remarks
   * The HTTP method used to call a backend service. Valid values: GET, POST, DELETE, PUT, HEADER, TRACE, PATCH, CONNECT, and OPTIONS.
   * 
   * @example
   * POST
   */
  serviceHttpMethod?: string;
  /**
   * @example
   * /object/add
   */
  servicePath?: string;
  /**
   * @remarks
   * The protocol used by the backend service. Valid values: HTTP and HTTPS.
   * 
   * @example
   * HTTP
   */
  serviceProtocol?: string;
  /**
   * @remarks
   * The timeout period of the backend service. Unit: milliseconds.
   * 
   * @example
   * 1000
   */
  serviceTimeout?: number;
  /**
   * @remarks
   * Specifies whether to enable the VPC channel. Valid values:
   * 
   * *   **TRUE**: The VPC channel is enabled. You must create the corresponding VPC access authorization before you can enable a VPC channel.
   * *   **FALSE**: The VPC channel is not enabled.
   * 
   * @example
   * TRUE
   */
  serviceVpcEnable?: string;
  /**
   * @remarks
   * Configuration items related to VPC channels
   */
  vpcConfig?: DescribeApiResponseBodyServiceConfigVpcConfig;
  static names(): { [key: string]: string } {
    return {
      aoneAppName: 'AoneAppName',
      contentTypeCatagory: 'ContentTypeCatagory',
      contentTypeValue: 'ContentTypeValue',
      eventBridgeConfig: 'EventBridgeConfig',
      functionComputeConfig: 'FunctionComputeConfig',
      mock: 'Mock',
      mockHeaders: 'MockHeaders',
      mockResult: 'MockResult',
      mockStatusCode: 'MockStatusCode',
      ossConfig: 'OssConfig',
      serviceAddress: 'ServiceAddress',
      serviceHttpMethod: 'ServiceHttpMethod',
      servicePath: 'ServicePath',
      serviceProtocol: 'ServiceProtocol',
      serviceTimeout: 'ServiceTimeout',
      serviceVpcEnable: 'ServiceVpcEnable',
      vpcConfig: 'VpcConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aoneAppName: 'string',
      contentTypeCatagory: 'string',
      contentTypeValue: 'string',
      eventBridgeConfig: DescribeApiResponseBodyServiceConfigEventBridgeConfig,
      functionComputeConfig: DescribeApiResponseBodyServiceConfigFunctionComputeConfig,
      mock: 'string',
      mockHeaders: DescribeApiResponseBodyServiceConfigMockHeaders,
      mockResult: 'string',
      mockStatusCode: 'number',
      ossConfig: DescribeApiResponseBodyServiceConfigOssConfig,
      serviceAddress: 'string',
      serviceHttpMethod: 'string',
      servicePath: 'string',
      serviceProtocol: 'string',
      serviceTimeout: 'number',
      serviceVpcEnable: 'string',
      vpcConfig: DescribeApiResponseBodyServiceConfigVpcConfig,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiResponseBodyServiceParametersServiceParameter extends $tea.Model {
  /**
   * @remarks
   * The parameter location. Valid values: BODY, HEAD, QUERY, and PATH.
   * 
   * @example
   * HEAD
   */
  location?: string;
  /**
   * @remarks
   * The data type of the parameter. Valid values: STRING, NUMBER, and BOOLEAN.
   * 
   * @example
   * String
   */
  parameterType?: string;
  /**
   * @remarks
   * The mapped parameter name in the backend service.
   * 
   * @example
   * clientIp
   */
  serviceParameterName?: string;
  static names(): { [key: string]: string } {
    return {
      location: 'Location',
      parameterType: 'ParameterType',
      serviceParameterName: 'ServiceParameterName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      location: 'string',
      parameterType: 'string',
      serviceParameterName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiResponseBodyServiceParameters extends $tea.Model {
  serviceParameter?: DescribeApiResponseBodyServiceParametersServiceParameter[];
  static names(): { [key: string]: string } {
    return {
      serviceParameter: 'ServiceParameter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      serviceParameter: { 'type': 'array', 'itemType': DescribeApiResponseBodyServiceParametersServiceParameter },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiResponseBodyServiceParametersMapServiceParameterMap extends $tea.Model {
  /**
   * @remarks
   * The corresponding frontend parameter name. The value must be contained in RequestParametersObject and match RequestParam.ApiParameterName.
   * 
   * @example
   * sex
   */
  requestParameterName?: string;
  /**
   * @remarks
   * The mapped parameter name in the backend service.
   * 
   * @example
   * sex
   */
  serviceParameterName?: string;
  static names(): { [key: string]: string } {
    return {
      requestParameterName: 'RequestParameterName',
      serviceParameterName: 'ServiceParameterName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestParameterName: 'string',
      serviceParameterName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiResponseBodyServiceParametersMap extends $tea.Model {
  serviceParameterMap?: DescribeApiResponseBodyServiceParametersMapServiceParameterMap[];
  static names(): { [key: string]: string } {
    return {
      serviceParameterMap: 'ServiceParameterMap',
    };
  }

  static types(): { [key: string]: any } {
    return {
      serviceParameterMap: { 'type': 'array', 'itemType': DescribeApiResponseBodyServiceParametersMapServiceParameterMap },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiResponseBodySystemParametersSystemParameter extends $tea.Model {
  /**
   * @remarks
   * The example value.
   * 
   * @example
   * 192.168.1.1
   */
  demoValue?: string;
  /**
   * @remarks
   * The parameter description.
   * 
   * @example
   * Client IP Address
   */
  description?: string;
  /**
   * @remarks
   * The parameter location. Valid values: BODY, HEAD, QUERY, and PATH.
   * 
   * @example
   * HEAD
   */
  location?: string;
  /**
   * @remarks
   * The system parameter. Valid values: CaClientIp, CaDomain, CaRequestHandleTime, CaAppId, CaRequestId, CaHttpSchema, and CaProxy.
   * 
   * @example
   * CaClientIp
   */
  parameterName?: string;
  /**
   * @remarks
   * The mapped parameter name in the backend service.
   * 
   * @example
   * clientIp
   */
  serviceParameterName?: string;
  static names(): { [key: string]: string } {
    return {
      demoValue: 'DemoValue',
      description: 'Description',
      location: 'Location',
      parameterName: 'ParameterName',
      serviceParameterName: 'ServiceParameterName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      demoValue: 'string',
      description: 'string',
      location: 'string',
      parameterName: 'string',
      serviceParameterName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiResponseBodySystemParameters extends $tea.Model {
  systemParameter?: DescribeApiResponseBodySystemParametersSystemParameter[];
  static names(): { [key: string]: string } {
    return {
      systemParameter: 'SystemParameter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      systemParameter: { 'type': 'array', 'itemType': DescribeApiResponseBodySystemParametersSystemParameter },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiResponseBodyTagListTag extends $tea.Model {
  /**
   * @remarks
   * Label key.
   * 
   * @example
   * APP
   */
  tagKey?: string;
  /**
   * @remarks
   * Label value.
   * 
   * @example
   * value3
   */
  tagValue?: string;
  static names(): { [key: string]: string } {
    return {
      tagKey: 'TagKey',
      tagValue: 'TagValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagKey: 'string',
      tagValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiResponseBodyTagList extends $tea.Model {
  tag?: DescribeApiResponseBodyTagListTag[];
  static names(): { [key: string]: string } {
    return {
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tag: { 'type': 'array', 'itemType': DescribeApiResponseBodyTagListTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiDocResponseBodyErrorCodeSamplesErrorCodeSample extends $tea.Model {
  /**
   * @remarks
   * The returned error code.
   * 
   * @example
   * Error
   */
  code?: string;
  /**
   * @remarks
   * The error description.
   * 
   * @example
   * Unauthorized
   */
  description?: string;
  /**
   * @remarks
   * The returned error message.
   * 
   * @example
   * error message
   */
  message?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      description: 'Description',
      message: 'Message',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      description: 'string',
      message: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiDocResponseBodyErrorCodeSamples extends $tea.Model {
  errorCodeSample?: DescribeApiDocResponseBodyErrorCodeSamplesErrorCodeSample[];
  static names(): { [key: string]: string } {
    return {
      errorCodeSample: 'ErrorCodeSample',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCodeSample: { 'type': 'array', 'itemType': DescribeApiDocResponseBodyErrorCodeSamplesErrorCodeSample },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiDocResponseBodyRequestConfig extends $tea.Model {
  /**
   * @remarks
   * This parameter takes effect only when the RequestMode parameter is set to MAPPING.********
   * 
   * The server data transmission method used for POST and PUT requests. Valid values: FORM and STREAM. FORM indicates that data in key-value pairs is transmitted as forms. STREAM indicates that data is transmitted as byte streams.
   * 
   * @example
   * STREAM
   */
  bodyFormat?: string;
  /**
   * @remarks
   * Whether to escape the Path parameter, if true, the [param] on the Path will be treated as a regular character.
   * 
   * @example
   * true
   */
  escapePathParam?: boolean;
  /**
   * @remarks
   * The description of the request body.
   * 
   * @example
   * fwefwef
   */
  postBodyDescription?: string;
  /**
   * @remarks
   * The HTTP method used to make the request. Valid values: GET, POST, DELETE, PUT, HEADER, TRACE, PATCH, CONNECT, and OPTIONS.
   * 
   * @example
   * POST
   */
  requestHttpMethod?: string;
  /**
   * @remarks
   * The request mode. Valid values:
   * 
   * *   MAPPING: Parameters are mapped. Unknown parameters are filtered out.
   * *   PASSTHROUGH: Parameters are passed through.
   * *   MAPPING_PASSTHROUGH: Parameters are mapped. Unknown parameters are passed through.
   * 
   * @example
   * MAPPING
   */
  requestMode?: string;
  /**
   * @remarks
   * The API request path. If the complete API URL is `http://api.a.com:8080/object/add?key1=value1&key2=value2`, the API request path is ` /object/add  `.
   * 
   * @example
   * /api/billing/test/[type]
   */
  requestPath?: string;
  /**
   * @remarks
   * The protocol type supported by the API. Valid values: HTTP and HTTPS. Separate multiple values with commas (,), such as "HTTP,HTTPS".
   * 
   * @example
   * HTTP
   */
  requestProtocol?: string;
  static names(): { [key: string]: string } {
    return {
      bodyFormat: 'BodyFormat',
      escapePathParam: 'EscapePathParam',
      postBodyDescription: 'PostBodyDescription',
      requestHttpMethod: 'RequestHttpMethod',
      requestMode: 'RequestMode',
      requestPath: 'RequestPath',
      requestProtocol: 'RequestProtocol',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bodyFormat: 'string',
      escapePathParam: 'boolean',
      postBodyDescription: 'string',
      requestHttpMethod: 'string',
      requestMode: 'string',
      requestPath: 'string',
      requestProtocol: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiDocResponseBodyRequestParametersRequestParameter extends $tea.Model {
  /**
   * @remarks
   * The name of the parameter in the API request.
   * 
   * @example
   * Length
   */
  apiParameterName?: string;
  /**
   * @remarks
   * The type of the array element.
   * 
   * @example
   * String
   */
  arrayItemsType?: string;
  /**
   * @remarks
   * The default value.
   * 
   * @example
   * 20
   */
  defaultValue?: string;
  /**
   * @remarks
   * The example value.
   * 
   * @example
   * 20
   */
  demoValue?: string;
  /**
   * @remarks
   * The parameter description.
   * 
   * @example
   * Parameters
   */
  description?: string;
  /**
   * @remarks
   * The order in which the parameter is sorted in the document.
   * 
   * @example
   * 0
   */
  docOrder?: number;
  /**
   * @remarks
   * Indicates whether the document is public. Valid values: **PUBLIC** and **PRIVATE**.
   * 
   * @example
   * PUBLIC
   */
  docShow?: string;
  /**
   * @remarks
   * The hash values that are supported when **ParameterType** is set to Int, Long, Float, Double, or String. Separate values with commas (,). Examples: 1,2,3,4,9 and A,B,C,E,F.
   * 
   * @example
   * boy,girl
   */
  enumValue?: string;
  /**
   * @remarks
   * JSON scheme
   * 
   * @example
   * {}
   */
  jsonScheme?: string;
  /**
   * @remarks
   * The parameter location. Valid values: BODY, HEAD, QUERY, and PATH.
   * 
   * @example
   * HEAD
   */
  location?: string;
  /**
   * @remarks
   * The maximum length.
   * 
   * @example
   * 123456
   */
  maxLength?: number;
  /**
   * @remarks
   * The maximum value.
   * 
   * @example
   * 200
   */
  maxValue?: number;
  /**
   * @remarks
   * The minimum length.
   * 
   * @example
   * 2
   */
  minLength?: number;
  /**
   * @remarks
   * The minimum value.
   * 
   * @example
   * 123456
   */
  minValue?: number;
  /**
   * @remarks
   * The data type of the parameter.
   * 
   * @example
   * String
   */
  parameterType?: string;
  /**
   * @remarks
   * The regular expression that is used for parameter validation when **ParameterType** is set to String.
   * 
   * @example
   * xxx
   */
  regularExpression?: string;
  /**
   * @remarks
   * Indicates whether the parameter is required.
   * 
   * @example
   * OPTIONAL
   */
  required?: string;
  static names(): { [key: string]: string } {
    return {
      apiParameterName: 'ApiParameterName',
      arrayItemsType: 'ArrayItemsType',
      defaultValue: 'DefaultValue',
      demoValue: 'DemoValue',
      description: 'Description',
      docOrder: 'DocOrder',
      docShow: 'DocShow',
      enumValue: 'EnumValue',
      jsonScheme: 'JsonScheme',
      location: 'Location',
      maxLength: 'MaxLength',
      maxValue: 'MaxValue',
      minLength: 'MinLength',
      minValue: 'MinValue',
      parameterType: 'ParameterType',
      regularExpression: 'RegularExpression',
      required: 'Required',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiParameterName: 'string',
      arrayItemsType: 'string',
      defaultValue: 'string',
      demoValue: 'string',
      description: 'string',
      docOrder: 'number',
      docShow: 'string',
      enumValue: 'string',
      jsonScheme: 'string',
      location: 'string',
      maxLength: 'number',
      maxValue: 'number',
      minLength: 'number',
      minValue: 'number',
      parameterType: 'string',
      regularExpression: 'string',
      required: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiDocResponseBodyRequestParameters extends $tea.Model {
  requestParameter?: DescribeApiDocResponseBodyRequestParametersRequestParameter[];
  static names(): { [key: string]: string } {
    return {
      requestParameter: 'RequestParameter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestParameter: { 'type': 'array', 'itemType': DescribeApiDocResponseBodyRequestParametersRequestParameter },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiGroupRequestTag extends $tea.Model {
  /**
   * @remarks
   * The key of the tag.
   * 
   * @example
   * appname
   */
  key?: string;
  /**
   * @remarks
   * The value of the tag.
   * 
   * @example
   * test_app
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiGroupResponseBodyCustomDomainsDomainItem extends $tea.Model {
  /**
   * @remarks
   * The alias of the associated environment.
   * 
   * @example
   * TEST1
   */
  bindStageAlias?: string;
  /**
   * @remarks
   * The environment in which the associated API group runs.
   * 
   * @example
   * TEST
   */
  bindStageName?: string;
  /**
   * @remarks
   * The SSL certificate ID, which is automatically generated by the system.
   * 
   * @example
   * 6EF60BEC-0242-43AF-BB20-270359FB54A7
   */
  certificateId?: string;
  /**
   * @remarks
   * The name of the SSL certificate.
   * 
   * @example
   * myCertificate
   */
  certificateName?: string;
  /**
   * @remarks
   * The time when the certificate expires.
   * 
   * @example
   * 2635123476000
   */
  certificateValidEnd?: number;
  /**
   * @remarks
   * The time when the certificate takes effect.
   * 
   * @example
   * 1689043476000
   */
  certificateValidStart?: number;
  /**
   * @remarks
   * The type of the custom domain name.
   * 
   * @example
   * intranet
   */
  customDomainType?: string;
  /**
   * @remarks
   * The binding status of the custom domain name. Valid values:
   * 
   * *   **BINDING**: The domain name is bound.
   * *   **BOUND**: The domain name is not bound.
   * 
   * @example
   * BINDING
   */
  domainBindingStatus?: string;
  /**
   * @remarks
   * The domain name resolution status. Valid values:
   * 
   * *   **RESOLVED**
   * *   **UNRESOLVED**
   * 
   * @example
   * RESOLVED
   */
  domainCNAMEStatus?: string;
  /**
   * @remarks
   * The validity status of the domain name. Valid values:
   * 
   * *   **NORMAL**: The domain name is valid.
   * *   **ABNORMAL**: The domain name is invalid. This status affects API calls and needs to be rectified as soon as possible.
   * 
   * @example
   * ABNORMAL
   */
  domainLegalStatus?: string;
  /**
   * @remarks
   * The domain name.
   * 
   * @example
   * api.demo.com
   */
  domainName?: string;
  /**
   * @remarks
   * Remarks about the domain name, such as the cause of an exception.
   * 
   * @example
   * Indicates that the domain name does not have an ICP filing.
   */
  domainRemark?: string;
  /**
   * @remarks
   * The status of the domain that uses the WebSocket feature.
   * 
   * @example
   * CLOSE
   */
  domainWebSocketStatus?: string;
  /**
   * @remarks
   * Indicates whether to redirect HTTP requests to HTTPS.
   * 
   * @example
   * false
   */
  isHttpRedirectToHttps?: boolean;
  /**
   * @remarks
   * The wildcard domain name mode.
   * 
   * @example
   * [\\"{test}.test.com\\"]
   */
  wildcardDomainPatterns?: string;
  static names(): { [key: string]: string } {
    return {
      bindStageAlias: 'BindStageAlias',
      bindStageName: 'BindStageName',
      certificateId: 'CertificateId',
      certificateName: 'CertificateName',
      certificateValidEnd: 'CertificateValidEnd',
      certificateValidStart: 'CertificateValidStart',
      customDomainType: 'CustomDomainType',
      domainBindingStatus: 'DomainBindingStatus',
      domainCNAMEStatus: 'DomainCNAMEStatus',
      domainLegalStatus: 'DomainLegalStatus',
      domainName: 'DomainName',
      domainRemark: 'DomainRemark',
      domainWebSocketStatus: 'DomainWebSocketStatus',
      isHttpRedirectToHttps: 'IsHttpRedirectToHttps',
      wildcardDomainPatterns: 'WildcardDomainPatterns',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bindStageAlias: 'string',
      bindStageName: 'string',
      certificateId: 'string',
      certificateName: 'string',
      certificateValidEnd: 'number',
      certificateValidStart: 'number',
      customDomainType: 'string',
      domainBindingStatus: 'string',
      domainCNAMEStatus: 'string',
      domainLegalStatus: 'string',
      domainName: 'string',
      domainRemark: 'string',
      domainWebSocketStatus: 'string',
      isHttpRedirectToHttps: 'boolean',
      wildcardDomainPatterns: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiGroupResponseBodyCustomDomains extends $tea.Model {
  domainItem?: DescribeApiGroupResponseBodyCustomDomainsDomainItem[];
  static names(): { [key: string]: string } {
    return {
      domainItem: 'DomainItem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainItem: { 'type': 'array', 'itemType': DescribeApiGroupResponseBodyCustomDomainsDomainItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiGroupResponseBodyStageItemsStageInfo extends $tea.Model {
  /**
   * @remarks
   * The environment description.
   * 
   * @example
   * MYTEST
   */
  description?: string;
  /**
   * @remarks
   * The environment ID.
   * 
   * @example
   * 123e8dc7bbe01613b5b1d726c2a7888e
   */
  stageId?: string;
  /**
   * @remarks
   * The environment name.
   * 
   * @example
   * TEST
   */
  stageName?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      stageId: 'StageId',
      stageName: 'StageName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      stageId: 'string',
      stageName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiGroupResponseBodyStageItems extends $tea.Model {
  stageInfo?: DescribeApiGroupResponseBodyStageItemsStageInfo[];
  static names(): { [key: string]: string } {
    return {
      stageInfo: 'StageInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      stageInfo: { 'type': 'array', 'itemType': DescribeApiGroupResponseBodyStageItemsStageInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiGroupsRequestTag extends $tea.Model {
  /**
   * @remarks
   * The key of the tag.
   * 
   * @example
   * key
   */
  key?: string;
  /**
   * @remarks
   * The value of the tag.
   * 
   * @example
   * value
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttributeTagsTagInfo extends $tea.Model {
  /**
   * @remarks
   * The key of the tag.
   * 
   * @example
   * key
   */
  key?: string;
  /**
   * @remarks
   * The value of the tag.
   * 
   * @example
   * value
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttributeTags extends $tea.Model {
  tagInfo?: DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttributeTagsTagInfo[];
  static names(): { [key: string]: string } {
    return {
      tagInfo: 'TagInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagInfo: { 'type': 'array', 'itemType': DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttributeTagsTagInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttribute extends $tea.Model {
  /**
   * @remarks
   * The basepath.
   * 
   * @example
   * /v2/
   */
  basePath?: string;
  /**
   * @remarks
   * The billing status of the API group. Valid values:
   * 
   * *   **NORMAL**: The instance is normal.
   * *   **LOCKED**: The API group is locked due to overdue payments.
   * 
   * @example
   * NORMAL
   */
  billingStatus?: string;
  /**
   * @remarks
   * The creation time (UTC) of the API group.
   * 
   * @example
   * 2016-08-01T08:45:15Z
   */
  createdTime?: string;
  /**
   * @remarks
   * Group Description
   * 
   * @example
   * TrafficInformations.
   */
  description?: string;
  /**
   * @remarks
   * The ID of the API group. This ID is generated by the system and globally unique.
   * 
   * @example
   * be6d2abcc0dd4f749fc2d2edd6567164
   */
  groupId?: string;
  /**
   * @remarks
   * The name of the API group.
   * 
   * @example
   * Traffic
   */
  groupName?: string;
  /**
   * @remarks
   * The HTTPS security policy
   * 
   * @example
   * HTTPS2_TLS1_0
   */
  httpsPolicy?: string;
  /**
   * @remarks
   * The validity status of the API group. Valid values:
   * 
   * *   **NORMAL**: The instance is normal.
   * *   **LOCKED**: The API group is locked because it is not valid.
   * 
   * @example
   * NORMAL
   */
  illegalStatus?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * apigateway-cn-v6419k43245xx
   */
  instanceId?: string;
  /**
   * @remarks
   * The type of the instance.
   * 
   * @example
   * VPC_SHARED
   */
  instanceType?: string;
  /**
   * @remarks
   * The last modification time (UTC) of the API group.
   * 
   * @example
   * 2016-08-01T08:45:15Z
   */
  modifiedTime?: string;
  /**
   * @remarks
   * The region to which the API group belongs.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The second-level domain name that corresponds to the API group and is used by the CNAME of the custom domain name.
   * 
   * @example
   * be6d2abcc0dd4f749fc2d2edd6567164-cn-hangzhou.alicloudapi.com
   */
  subDomain?: string;
  /**
   * @remarks
   * The list of tags.
   */
  tags?: DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttributeTags;
  /**
   * @remarks
   * The upper QPS limit of the API group. The default value is 500. You can increase the upper limit by submitting an application.
   * 
   * @example
   * 500
   */
  trafficLimit?: number;
  static names(): { [key: string]: string } {
    return {
      basePath: 'BasePath',
      billingStatus: 'BillingStatus',
      createdTime: 'CreatedTime',
      description: 'Description',
      groupId: 'GroupId',
      groupName: 'GroupName',
      httpsPolicy: 'HttpsPolicy',
      illegalStatus: 'IllegalStatus',
      instanceId: 'InstanceId',
      instanceType: 'InstanceType',
      modifiedTime: 'ModifiedTime',
      regionId: 'RegionId',
      subDomain: 'SubDomain',
      tags: 'Tags',
      trafficLimit: 'TrafficLimit',
    };
  }

  static types(): { [key: string]: any } {
    return {
      basePath: 'string',
      billingStatus: 'string',
      createdTime: 'string',
      description: 'string',
      groupId: 'string',
      groupName: 'string',
      httpsPolicy: 'string',
      illegalStatus: 'string',
      instanceId: 'string',
      instanceType: 'string',
      modifiedTime: 'string',
      regionId: 'string',
      subDomain: 'string',
      tags: DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttributeTags,
      trafficLimit: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiGroupsResponseBodyApiGroupAttributes extends $tea.Model {
  apiGroupAttribute?: DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttribute[];
  static names(): { [key: string]: string } {
    return {
      apiGroupAttribute: 'ApiGroupAttribute',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiGroupAttribute: { 'type': 'array', 'itemType': DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttribute },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiHistoriesResponseBodyApiHisItemsApiHisItem extends $tea.Model {
  /**
   * @remarks
   * The ID of the API.
   * 
   * @example
   * 5af418828f0344a3b588c0cc1331a3bc
   */
  apiId?: string;
  /**
   * @remarks
   * The name of the API.
   * 
   * @example
   * CreateObject
   */
  apiName?: string;
  /**
   * @remarks
   * The publishing time (UTC) of the API.
   * 
   * @example
   * 2016-07-20T08:28:48Z
   */
  deployedTime?: string;
  /**
   * @remarks
   * The description of the API.
   * 
   * @example
   * Creates an object
   */
  description?: string;
  /**
   * @remarks
   * The ID of the API group.
   * 
   * @example
   * 1084f9034c744137901057206b39d2b6
   */
  groupId?: string;
  /**
   * @remarks
   * The name of the API group.
   * 
   * @example
   * myGroup2
   */
  groupName?: string;
  /**
   * @remarks
   * The historical version of the API.
   * 
   * @example
   * 20160705104552393
   */
  historyVersion?: string;
  /**
   * @remarks
   * The region in which the API is located.
   * 
   * @example
   * cn-qingdao
   */
  regionId?: string;
  /**
   * @remarks
   * The name of the runtime environment. Valid values:
   * 
   * *   **RELEASE**
   * *   **TEST**
   * 
   * @example
   * RELEASE
   */
  stageName?: string;
  /**
   * @remarks
   * Indicates whether an API version is effective. Valid values: **ONLINE** and **OFFLINE**.
   * 
   * @example
   * ONLINE
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      apiName: 'ApiName',
      deployedTime: 'DeployedTime',
      description: 'Description',
      groupId: 'GroupId',
      groupName: 'GroupName',
      historyVersion: 'HistoryVersion',
      regionId: 'RegionId',
      stageName: 'StageName',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'string',
      apiName: 'string',
      deployedTime: 'string',
      description: 'string',
      groupId: 'string',
      groupName: 'string',
      historyVersion: 'string',
      regionId: 'string',
      stageName: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiHistoriesResponseBodyApiHisItems extends $tea.Model {
  apiHisItem?: DescribeApiHistoriesResponseBodyApiHisItemsApiHisItem[];
  static names(): { [key: string]: string } {
    return {
      apiHisItem: 'ApiHisItem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiHisItem: { 'type': 'array', 'itemType': DescribeApiHistoriesResponseBodyApiHisItemsApiHisItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiHistoryResponseBodyBackendConfig extends $tea.Model {
  /**
   * @remarks
   * The ID of the backend service.
   * 
   * @example
   * a0305308908c4740aba9cbfd63ba99b7
   */
  backendId?: string;
  /**
   * @remarks
   * The name of the backend service.
   * 
   * @example
   * zmapi
   */
  backendName?: string;
  /**
   * @remarks
   * The type of the backend service.
   * 
   * @example
   * HTTP
   */
  backendType?: string;
  static names(): { [key: string]: string } {
    return {
      backendId: 'BackendId',
      backendName: 'BackendName',
      backendType: 'BackendType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      backendId: 'string',
      backendName: 'string',
      backendType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiHistoryResponseBodyConstantParametersConstantParameter extends $tea.Model {
  /**
   * @remarks
   * The value of the constant parameter.
   * 
   * @example
   * constance
   */
  constantValue?: string;
  /**
   * @remarks
   * The parameter description.
   * 
   * @example
   * for_test1
   */
  description?: string;
  /**
   * @remarks
   * The parameter location. Valid values: BODY, HEAD, QUERY, and PATH.
   * 
   * @example
   * HEAD
   */
  location?: string;
  /**
   * @remarks
   * The mapped parameter name in the backend service.
   * 
   * @example
   * constance
   */
  serviceParameterName?: string;
  static names(): { [key: string]: string } {
    return {
      constantValue: 'ConstantValue',
      description: 'Description',
      location: 'Location',
      serviceParameterName: 'ServiceParameterName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      constantValue: 'string',
      description: 'string',
      location: 'string',
      serviceParameterName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiHistoryResponseBodyConstantParameters extends $tea.Model {
  constantParameter?: DescribeApiHistoryResponseBodyConstantParametersConstantParameter[];
  static names(): { [key: string]: string } {
    return {
      constantParameter: 'ConstantParameter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      constantParameter: { 'type': 'array', 'itemType': DescribeApiHistoryResponseBodyConstantParametersConstantParameter },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiHistoryResponseBodyCustomSystemParametersCustomSystemParameter extends $tea.Model {
  /**
   * @remarks
   * The sample value.
   * 
   * @example
   * 192.168.1.1
   */
  demoValue?: string;
  /**
   * @remarks
   * The parameter description.
   * 
   * @example
   * balabala
   */
  description?: string;
  /**
   * @remarks
   * The parameter location. Valid values: BODY, HEAD, QUERY, and PATH.
   * 
   * @example
   * HEAD
   */
  location?: string;
  /**
   * @remarks
   * The parameter name.
   * 
   * @example
   * CaClientIp
   */
  parameterName?: string;
  /**
   * @remarks
   * The mapped parameter name in the backend service.
   * 
   * @example
   * clientIp
   */
  serviceParameterName?: string;
  static names(): { [key: string]: string } {
    return {
      demoValue: 'DemoValue',
      description: 'Description',
      location: 'Location',
      parameterName: 'ParameterName',
      serviceParameterName: 'ServiceParameterName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      demoValue: 'string',
      description: 'string',
      location: 'string',
      parameterName: 'string',
      serviceParameterName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiHistoryResponseBodyCustomSystemParameters extends $tea.Model {
  customSystemParameter?: DescribeApiHistoryResponseBodyCustomSystemParametersCustomSystemParameter[];
  static names(): { [key: string]: string } {
    return {
      customSystemParameter: 'CustomSystemParameter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      customSystemParameter: { 'type': 'array', 'itemType': DescribeApiHistoryResponseBodyCustomSystemParametersCustomSystemParameter },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiHistoryResponseBodyErrorCodeSamplesErrorCodeSample extends $tea.Model {
  /**
   * @remarks
   * The returned error code.
   * 
   * @example
   * 400
   */
  code?: string;
  /**
   * @remarks
   * The error description.
   * 
   * @example
   * Missing the parameter UserId
   */
  description?: string;
  /**
   * @remarks
   * The returned error message.
   * 
   * @example
   * MissingParameter
   */
  message?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      description: 'Description',
      message: 'Message',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      description: 'string',
      message: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiHistoryResponseBodyErrorCodeSamples extends $tea.Model {
  errorCodeSample?: DescribeApiHistoryResponseBodyErrorCodeSamplesErrorCodeSample[];
  static names(): { [key: string]: string } {
    return {
      errorCodeSample: 'ErrorCodeSample',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCodeSample: { 'type': 'array', 'itemType': DescribeApiHistoryResponseBodyErrorCodeSamplesErrorCodeSample },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiHistoryResponseBodyOpenIdConnectConfig extends $tea.Model {
  /**
   * @remarks
   * The name of the parameter that corresponds to the token.
   * 
   * @example
   * xxx
   */
  idTokenParamName?: string;
  /**
   * @remarks
   * The configuration of OpenID Connect authentication. Valid values:
   * 
   * *   **IDTOKEN: indicates the APIs that are called by clients to obtain tokens. If you specify this value, the PublicKeyId parameter and the PublicKey parameter are required.**
   * *   **BUSINESS: indicates business APIs. Tokens are used to call the business APIs. If you specify this value, the IdTokenParamName parameter is required.
   * 
   * @example
   * IDTOKEN
   */
  openIdApiType?: string;
  /**
   * @remarks
   * The public key of the API.
   * 
   * @example
   * EB1837F8693CCED0BF750B3AD48467BEB569E780A14591CF92
   */
  publicKey?: string;
  /**
   * @remarks
   * The ID of the public key.
   * 
   * @example
   * 88483727556929326703309904351185815489
   */
  publicKeyId?: string;
  static names(): { [key: string]: string } {
    return {
      idTokenParamName: 'IdTokenParamName',
      openIdApiType: 'OpenIdApiType',
      publicKey: 'PublicKey',
      publicKeyId: 'PublicKeyId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      idTokenParamName: 'string',
      openIdApiType: 'string',
      publicKey: 'string',
      publicKeyId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiHistoryResponseBodyRequestConfig extends $tea.Model {
  /**
   * @remarks
   * The server data transmission method used for POST and PUT requests. Valid values: FORM and STREAM. FORM indicates that data in key-value pairs is transmitted as forms. STREAM indicates that data is transmitted as byte streams. This parameter takes effect only when the RequestMode parameter is set to MAPPING.
   * 
   * @example
   * STREAM
   */
  bodyFormat?: string;
  /**
   * @remarks
   * The body model.
   * 
   * @example
   * https://apigateway.aliyun.com/models/3a240a1XXXXXXXXd9ab1bf7e947b4095/9e2df550e85b4XXXXXXXX619eaab
   */
  bodyModel?: string;
  /**
   * @remarks
   * Whether to escape the Path parameter, if true, the [param] on the Path will be treated as a regular character.
   * 
   * @example
   * true
   */
  escapePathParam?: boolean;
  /**
   * @remarks
   * The description of the request body.
   * 
   * @example
   * fwefwef
   */
  postBodyDescription?: string;
  /**
   * @remarks
   * The HTTP method. Valid values: GET, POST, DELETE, PUT, HEADER, TRACE, PATCH, CONNECT, and OPTIONS.
   * 
   * @example
   * POST
   */
  requestHttpMethod?: string;
  /**
   * @remarks
   * The request mode. Valid values:
   * 
   * *   MAPPING: Parameters are mapped. Unknown parameters are filtered out.
   * *   PASSTHROUGH: Parameters are passed through.
   * *   MAPPING_PASSTHROUGH: Parameters are mapped. Unknown parameters are passed through.
   * 
   * @example
   * MAPPING
   */
  requestMode?: string;
  /**
   * @remarks
   * API path
   * 
   * @example
   * /api/billing/test/[type]
   */
  requestPath?: string;
  /**
   * @remarks
   * The protocol type supported by the API. Valid values: HTTP, HTTPS, and WebSocket. Separate multiple values with commas (,), such as "HTTP,HTTPS".
   * 
   * @example
   * HTTP
   */
  requestProtocol?: string;
  static names(): { [key: string]: string } {
    return {
      bodyFormat: 'BodyFormat',
      bodyModel: 'BodyModel',
      escapePathParam: 'EscapePathParam',
      postBodyDescription: 'PostBodyDescription',
      requestHttpMethod: 'RequestHttpMethod',
      requestMode: 'RequestMode',
      requestPath: 'RequestPath',
      requestProtocol: 'RequestProtocol',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bodyFormat: 'string',
      bodyModel: 'string',
      escapePathParam: 'boolean',
      postBodyDescription: 'string',
      requestHttpMethod: 'string',
      requestMode: 'string',
      requestPath: 'string',
      requestProtocol: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiHistoryResponseBodyRequestParametersRequestParameter extends $tea.Model {
  /**
   * @remarks
   * The name of the parameter in the API request.
   * 
   * @example
   * age
   */
  apiParameterName?: string;
  /**
   * @remarks
   * The type of the array element.
   * 
   * @example
   * String
   */
  arrayItemsType?: string;
  /**
   * @remarks
   * The default value.
   * 
   * @example
   * 20
   */
  defaultValue?: string;
  /**
   * @remarks
   * The sample value.
   * 
   * @example
   * 20
   */
  demoValue?: string;
  /**
   * @remarks
   * The parameter description.
   * 
   * @example
   * modidyTest
   */
  description?: string;
  /**
   * @remarks
   * The order in which the parameter is sorted in the document.
   * 
   * @example
   * 0
   */
  docOrder?: number;
  /**
   * @remarks
   * Indicates whether the document is public. Valid values: **PUBLIC** and **PRIVATE**.
   * 
   * @example
   * PUBLIC
   */
  docShow?: string;
  /**
   * @remarks
   * The hash values that are supported when **ParameterType** is set to Int, Long, Float, Double, or String. Separate values with commas (,). Examples: 1,2,3,4,9 and A,B,C,E,F.
   * 
   * @example
   * boy,girl
   */
  enumValue?: string;
  /**
   * @remarks
   * JSON scheme
   * 
   * @example
   * {}
   */
  jsonScheme?: string;
  /**
   * @remarks
   * The parameter location. Valid values: BODY, HEAD, QUERY, and PATH.
   * 
   * @example
   * HEAD
   */
  location?: string;
  /**
   * @remarks
   * The maximum parameter length when **ParameterType** is set to String.
   * 
   * @example
   * 123456
   */
  maxLength?: number;
  /**
   * @remarks
   * The maximum parameter value when **ParameterType** is set to Int, Long, Float, or Double.
   * 
   * @example
   * 123456
   */
  maxValue?: number;
  /**
   * @remarks
   * The minimum parameter length when **ParameterType** is set to String.
   * 
   * @example
   * 123456
   */
  minLength?: number;
  /**
   * @remarks
   * The minimum parameter value when **ParameterType** is set to Int, Long, Float, or Double.
   * 
   * @example
   * 123456
   */
  minValue?: number;
  /**
   * @remarks
   * The data type of the parameter. Valid values: String, Int, Long, Float, Double, and Boolean.
   * 
   * @example
   * String
   */
  parameterType?: string;
  /**
   * @remarks
   * The regular expression that is used for parameter validation when **ParameterType** is set to String.
   * 
   * @example
   * xxx
   */
  regularExpression?: string;
  /**
   * @remarks
   * Indicates whether the parameter is required. Valid values: **REQUIRED** and **OPTIONAL**.
   * 
   * @example
   * OPTIONAL
   */
  required?: string;
  static names(): { [key: string]: string } {
    return {
      apiParameterName: 'ApiParameterName',
      arrayItemsType: 'ArrayItemsType',
      defaultValue: 'DefaultValue',
      demoValue: 'DemoValue',
      description: 'Description',
      docOrder: 'DocOrder',
      docShow: 'DocShow',
      enumValue: 'EnumValue',
      jsonScheme: 'JsonScheme',
      location: 'Location',
      maxLength: 'MaxLength',
      maxValue: 'MaxValue',
      minLength: 'MinLength',
      minValue: 'MinValue',
      parameterType: 'ParameterType',
      regularExpression: 'RegularExpression',
      required: 'Required',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiParameterName: 'string',
      arrayItemsType: 'string',
      defaultValue: 'string',
      demoValue: 'string',
      description: 'string',
      docOrder: 'number',
      docShow: 'string',
      enumValue: 'string',
      jsonScheme: 'string',
      location: 'string',
      maxLength: 'number',
      maxValue: 'number',
      minLength: 'number',
      minValue: 'number',
      parameterType: 'string',
      regularExpression: 'string',
      required: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiHistoryResponseBodyRequestParameters extends $tea.Model {
  requestParameter?: DescribeApiHistoryResponseBodyRequestParametersRequestParameter[];
  static names(): { [key: string]: string } {
    return {
      requestParameter: 'RequestParameter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestParameter: { 'type': 'array', 'itemType': DescribeApiHistoryResponseBodyRequestParametersRequestParameter },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiHistoryResponseBodyResultDescriptionsResultDescription extends $tea.Model {
  /**
   * @remarks
   * The subnode description.
   * 
   * @example
   * for_test1
   */
  description?: string;
  /**
   * @remarks
   * Indicates whether a subnode exists.
   * 
   * @example
   * true
   */
  hasChild?: boolean;
  /**
   * @remarks
   * The result ID.
   * 
   * @example
   * id
   */
  id?: string;
  /**
   * @remarks
   * The primary key of the result.
   * 
   * @example
   * groupName
   */
  key?: string;
  /**
   * @remarks
   * Indicates whether the parameter is required.
   * 
   * @example
   * true
   */
  mandatory?: boolean;
  /**
   * @remarks
   * The result name.
   * 
   * @example
   * fwqf
   */
  name?: string;
  /**
   * @remarks
   * The ID of the parent node.
   * 
   * @example
   * pid
   */
  pid?: string;
  /**
   * @remarks
   * The result type.
   * 
   * @example
   * String
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      hasChild: 'HasChild',
      id: 'Id',
      key: 'Key',
      mandatory: 'Mandatory',
      name: 'Name',
      pid: 'Pid',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      hasChild: 'boolean',
      id: 'string',
      key: 'string',
      mandatory: 'boolean',
      name: 'string',
      pid: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiHistoryResponseBodyResultDescriptions extends $tea.Model {
  resultDescription?: DescribeApiHistoryResponseBodyResultDescriptionsResultDescription[];
  static names(): { [key: string]: string } {
    return {
      resultDescription: 'ResultDescription',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resultDescription: { 'type': 'array', 'itemType': DescribeApiHistoryResponseBodyResultDescriptionsResultDescription },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiHistoryResponseBodyServiceConfigEventBridgeConfig extends $tea.Model {
  /**
   * @remarks
   * The ID of the region where the EventBridge instance is located.
   * 
   * @example
   * cn-beijing
   */
  eventBridgeRegionId?: string;
  /**
   * @remarks
   * The event bus.
   * 
   * @example
   * testBus
   */
  eventBus?: string;
  /**
   * @remarks
   * The event source of the managed rule.
   * 
   * @example
   * baas_driver
   */
  eventSource?: string;
  /**
   * @remarks
   * The Arn that is authorized by a RAM user to EventBridge.
   * 
   * @example
   * acs:ram::1933122015759***:role/adminoidcaliyun
   */
  roleArn?: string;
  static names(): { [key: string]: string } {
    return {
      eventBridgeRegionId: 'EventBridgeRegionId',
      eventBus: 'EventBus',
      eventSource: 'EventSource',
      roleArn: 'RoleArn',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventBridgeRegionId: 'string',
      eventBus: 'string',
      eventSource: 'string',
      roleArn: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiHistoryResponseBodyServiceConfigFunctionComputeConfig extends $tea.Model {
  /**
   * @remarks
   * The ContentType header type used when you call the backend service over HTTP.
   * 
   * *   **DEFAULT: the default header type in API Gateway.**
   * *   **CUSTOM: a custom header type.**
   * *   **CLIENT: the ContentType header type of the client.
   * 
   * @example
   * DEFAULT
   */
  contentTypeCatagory?: string;
  /**
   * @remarks
   * The value of the ContentType header when the ServiceProtocol parameter is set to HTTP and the ContentTypeCatagory parameter is set to DEFAULT or CUSTOM.
   * 
   * @example
   * application/json
   */
  contentTypeValue?: string;
  /**
   * @remarks
   * The root path of Function Compute.
   * 
   * @example
   * https://122xxxxxxx.fc.aliyun.com/2016xxxx/proxy/testSxxx.xxx/testHttp/
   */
  fcBaseUrl?: string;
  /**
   * @remarks
   * The type of the Function Compute instance.
   * 
   * @example
   * HttpTrigger
   */
  fcType?: string;
  /**
   * @remarks
   * The function name defined in Function Compute.
   * 
   * @example
   * domain_business_control
   */
  functionName?: string;
  /**
   * @remarks
   * The request method.
   * 
   * @example
   * GET
   */
  method?: string;
  /**
   * @remarks
   * The backend only receives the service path.
   * 
   * @example
   * false
   */
  onlyBusinessPath?: boolean;
  /**
   * @remarks
   * The API request path.
   * 
   * @example
   * /api/offline/cacheData
   */
  path?: string;
  /**
   * @remarks
   * The alias of the function.
   * 
   * @example
   * 2
   */
  qualifier?: string;
  /**
   * @remarks
   * The ID of the region.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The Alibaba Cloud Resource Name (ARN) of the RAM role to be assumed by API Gateway to access Function Compute.
   * 
   * @example
   * acs:ram::111***:role/aliyunserviceroleforsas
   */
  roleArn?: string;
  /**
   * @remarks
   * The service name defined in Function Compute.
   * 
   * @example
   * fcservicename
   */
  serviceName?: string;
  static names(): { [key: string]: string } {
    return {
      contentTypeCatagory: 'ContentTypeCatagory',
      contentTypeValue: 'ContentTypeValue',
      fcBaseUrl: 'FcBaseUrl',
      fcType: 'FcType',
      functionName: 'FunctionName',
      method: 'Method',
      onlyBusinessPath: 'OnlyBusinessPath',
      path: 'Path',
      qualifier: 'Qualifier',
      regionId: 'RegionId',
      roleArn: 'RoleArn',
      serviceName: 'ServiceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contentTypeCatagory: 'string',
      contentTypeValue: 'string',
      fcBaseUrl: 'string',
      fcType: 'string',
      functionName: 'string',
      method: 'string',
      onlyBusinessPath: 'boolean',
      path: 'string',
      qualifier: 'string',
      regionId: 'string',
      roleArn: 'string',
      serviceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiHistoryResponseBodyServiceConfigMockHeadersMockHeader extends $tea.Model {
  /**
   * @remarks
   * The HTTP headers.
   * 
   * @example
   * Content-Type
   */
  headerName?: string;
  /**
   * @remarks
   * The values of the HTTP headers.
   * 
   * @example
   * 86400
   */
  headerValue?: string;
  static names(): { [key: string]: string } {
    return {
      headerName: 'HeaderName',
      headerValue: 'HeaderValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headerName: 'string',
      headerValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiHistoryResponseBodyServiceConfigMockHeaders extends $tea.Model {
  mockHeader?: DescribeApiHistoryResponseBodyServiceConfigMockHeadersMockHeader[];
  static names(): { [key: string]: string } {
    return {
      mockHeader: 'MockHeader',
    };
  }

  static types(): { [key: string]: any } {
    return {
      mockHeader: { 'type': 'array', 'itemType': DescribeApiHistoryResponseBodyServiceConfigMockHeadersMockHeader },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiHistoryResponseBodyServiceConfigOssConfig extends $tea.Model {
  /**
   * @remarks
   * The operation options on OSS. Valid values:
   * 
   * *   GetObject
   * *   PostObject
   * *   DeleteObject
   * *   PutObject
   * *   HeadObject
   * *   GetObjectMeta
   * *   AppendObject
   * 
   * @example
   * GetObject
   */
  action?: string;
  /**
   * @remarks
   * The OSS bucket.
   * 
   * @example
   * phototest02
   */
  bucketName?: string;
  /**
   * @remarks
   * The stored object or folder path.
   * 
   * @example
   * ENV
   */
  key?: string;
  /**
   * @remarks
   * The ID of the region where the OSS instance is located.
   * 
   * @example
   * cn-hangzhou
   */
  ossRegionId?: string;
  static names(): { [key: string]: string } {
    return {
      action: 'Action',
      bucketName: 'BucketName',
      key: 'Key',
      ossRegionId: 'OssRegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      action: 'string',
      bucketName: 'string',
      key: 'string',
      ossRegionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiHistoryResponseBodyServiceConfigVpcConfig extends $tea.Model {
  /**
   * @remarks
   * The IDs of the ELB and SLB instances in the VPC.
   * 
   * @example
   * i-bp1h497hkijewv2***
   */
  instanceId?: string;
  /**
   * @remarks
   * The name of the VPC.
   * 
   * @example
   * glmall-app-test
   */
  name?: string;
  /**
   * @remarks
   * The port number that corresponds to the instance.
   * 
   * @example
   * 8080
   */
  port?: number;
  /**
   * @remarks
   * The ID of the VPC.
   * 
   * @example
   * vpc-2zeafsc3fygk1***
   */
  vpcId?: string;
  /**
   * @remarks
   * The VPC protocol.
   * 
   * @example
   * HTTP
   */
  vpcScheme?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      name: 'Name',
      port: 'Port',
      vpcId: 'VpcId',
      vpcScheme: 'VpcScheme',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      name: 'string',
      port: 'number',
      vpcId: 'string',
      vpcScheme: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiHistoryResponseBodyServiceConfig extends $tea.Model {
  /**
   * @remarks
   * The ContentType header type used when you call the backend service over HTTP.
   * 
   * *   DEFAULT: the default header type in API Gateway
   * *   CUSTOM: a custom header type
   * *   CLIENT: the ContentType header type of the client
   * 
   * @example
   * CUSTOM
   */
  contentTypeCatagory?: string;
  /**
   * @remarks
   * The value of the ContentType header when the ServiceProtocol parameter is set to HTTP and the ContentTypeCatagory parameter is set to DEFAULT or CUSTOM.
   * 
   * @example
   * application/json
   */
  contentTypeValue?: string;
  /**
   * @remarks
   * Configuration items of EventBridge
   */
  eventBridgeConfig?: DescribeApiHistoryResponseBodyServiceConfigEventBridgeConfig;
  /**
   * @remarks
   * Backend configuration items when the backend service is Function Compute
   */
  functionComputeConfig?: DescribeApiHistoryResponseBodyServiceConfigFunctionComputeConfig;
  /**
   * @remarks
   * Specifies whether to enable the MOCK mode. Valid values:
   * 
   * *   TRUE: The Mock mode is enabled.
   * *   FALSE: The Mock mode is not enabled.
   * 
   * @example
   * TRUE
   */
  mock?: string;
  /**
   * @remarks
   * The simulated Headers.
   */
  mockHeaders?: DescribeApiHistoryResponseBodyServiceConfigMockHeaders;
  /**
   * @remarks
   * The result returned when the Mock mode is enabled.
   * 
   * @example
   * test result
   */
  mockResult?: string;
  /**
   * @remarks
   * The status code returned for service mocking.
   * 
   * @example
   * 200
   */
  mockStatusCode?: number;
  /**
   * @remarks
   * Information when the backend service is OSS
   */
  ossConfig?: DescribeApiHistoryResponseBodyServiceConfigOssConfig;
  /**
   * @remarks
   * The URL used to call the backend service.
   * 
   * @example
   * http://api.a.com:8080
   */
  serviceAddress?: string;
  /**
   * @remarks
   * The HTTP request method used when calling the backend service. Valid values: PUT, GET, POST, DELETE, PATCH, HEAD, OPTIONS, and ANY.
   * 
   * @example
   * POST
   */
  serviceHttpMethod?: string;
  /**
   * @remarks
   * The path used when you call the backend service.
   * 
   * @example
   * /object/add
   */
  servicePath?: string;
  /**
   * @remarks
   * The backend service protocol. Currently, only HTTP, HTTPS, and FunctionCompute are supported.
   * 
   * @example
   * HTTP
   */
  serviceProtocol?: string;
  /**
   * @remarks
   * The timeout period of the backend service, in millisecond.
   * 
   * @example
   * 1000
   */
  serviceTimeout?: number;
  /**
   * @remarks
   * Specifies whether to enable the VPC channel. Valid values:
   * 
   * *   TRUE: The VPC channel is enabled.
   * *   FALSE: The VPC channel is not enabled.
   * 
   * You must create the corresponding VPC access authorization before you can enable a VPC channel.
   * 
   * @example
   * TRUE
   */
  serviceVpcEnable?: string;
  /**
   * @remarks
   * Configuration items related to VPC channels
   */
  vpcConfig?: DescribeApiHistoryResponseBodyServiceConfigVpcConfig;
  /**
   * @remarks
   * The ID of the VPC.
   * 
   * @example
   * vpc-uf6kg9x8sx2tbxxxx
   */
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      contentTypeCatagory: 'ContentTypeCatagory',
      contentTypeValue: 'ContentTypeValue',
      eventBridgeConfig: 'EventBridgeConfig',
      functionComputeConfig: 'FunctionComputeConfig',
      mock: 'Mock',
      mockHeaders: 'MockHeaders',
      mockResult: 'MockResult',
      mockStatusCode: 'MockStatusCode',
      ossConfig: 'OssConfig',
      serviceAddress: 'ServiceAddress',
      serviceHttpMethod: 'ServiceHttpMethod',
      servicePath: 'ServicePath',
      serviceProtocol: 'ServiceProtocol',
      serviceTimeout: 'ServiceTimeout',
      serviceVpcEnable: 'ServiceVpcEnable',
      vpcConfig: 'VpcConfig',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contentTypeCatagory: 'string',
      contentTypeValue: 'string',
      eventBridgeConfig: DescribeApiHistoryResponseBodyServiceConfigEventBridgeConfig,
      functionComputeConfig: DescribeApiHistoryResponseBodyServiceConfigFunctionComputeConfig,
      mock: 'string',
      mockHeaders: DescribeApiHistoryResponseBodyServiceConfigMockHeaders,
      mockResult: 'string',
      mockStatusCode: 'number',
      ossConfig: DescribeApiHistoryResponseBodyServiceConfigOssConfig,
      serviceAddress: 'string',
      serviceHttpMethod: 'string',
      servicePath: 'string',
      serviceProtocol: 'string',
      serviceTimeout: 'number',
      serviceVpcEnable: 'string',
      vpcConfig: DescribeApiHistoryResponseBodyServiceConfigVpcConfig,
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiHistoryResponseBodyServiceParametersServiceParameter extends $tea.Model {
  /**
   * @remarks
   * The parameter location. Valid values: BODY, HEAD, QUERY, and PATH.
   * 
   * @example
   * HEAD
   */
  location?: string;
  /**
   * @remarks
   * The data type of the parameter. Valid values: STRING, NUMBER, and BOOLEAN.
   * 
   * @example
   * String
   */
  parameterType?: string;
  /**
   * @remarks
   * The mapped parameter name in the backend service.
   * 
   * @example
   * clientIp
   */
  serviceParameterName?: string;
  static names(): { [key: string]: string } {
    return {
      location: 'Location',
      parameterType: 'ParameterType',
      serviceParameterName: 'ServiceParameterName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      location: 'string',
      parameterType: 'string',
      serviceParameterName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiHistoryResponseBodyServiceParameters extends $tea.Model {
  serviceParameter?: DescribeApiHistoryResponseBodyServiceParametersServiceParameter[];
  static names(): { [key: string]: string } {
    return {
      serviceParameter: 'ServiceParameter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      serviceParameter: { 'type': 'array', 'itemType': DescribeApiHistoryResponseBodyServiceParametersServiceParameter },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiHistoryResponseBodyServiceParametersMapServiceParameterMap extends $tea.Model {
  /**
   * @remarks
   * The corresponding frontend parameter name. The value must be contained in RequestParametersObject and match RequestParam.ApiParameterName.
   * 
   * @example
   * sex
   */
  requestParameterName?: string;
  /**
   * @remarks
   * The mapped parameter name in the backend service.
   * 
   * @example
   * sex
   */
  serviceParameterName?: string;
  static names(): { [key: string]: string } {
    return {
      requestParameterName: 'RequestParameterName',
      serviceParameterName: 'ServiceParameterName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestParameterName: 'string',
      serviceParameterName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiHistoryResponseBodyServiceParametersMap extends $tea.Model {
  serviceParameterMap?: DescribeApiHistoryResponseBodyServiceParametersMapServiceParameterMap[];
  static names(): { [key: string]: string } {
    return {
      serviceParameterMap: 'ServiceParameterMap',
    };
  }

  static types(): { [key: string]: any } {
    return {
      serviceParameterMap: { 'type': 'array', 'itemType': DescribeApiHistoryResponseBodyServiceParametersMapServiceParameterMap },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiHistoryResponseBodySystemParametersSystemParameter extends $tea.Model {
  /**
   * @remarks
   * The sample value.
   * 
   * @example
   * 192.168.1.1
   */
  demoValue?: string;
  /**
   * @remarks
   * The description.
   * 
   * @example
   * system parameters description
   */
  description?: string;
  /**
   * @remarks
   * The parameter location. Valid values: BODY, HEAD, QUERY, and PATH.
   * 
   * @example
   * HEAD
   */
  location?: string;
  /**
   * @remarks
   * The system parameter. Valid values: CaClientIp, CaDomain, CaRequestHandleTime, CaAppId, CaRequestId, CaHttpSchema, and CaProxy.
   * 
   * @example
   * CaClientIp
   */
  parameterName?: string;
  /**
   * @remarks
   * The mapped parameter name in the backend service.
   * 
   * @example
   * clientIp
   */
  serviceParameterName?: string;
  static names(): { [key: string]: string } {
    return {
      demoValue: 'DemoValue',
      description: 'Description',
      location: 'Location',
      parameterName: 'ParameterName',
      serviceParameterName: 'ServiceParameterName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      demoValue: 'string',
      description: 'string',
      location: 'string',
      parameterName: 'string',
      serviceParameterName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiHistoryResponseBodySystemParameters extends $tea.Model {
  systemParameter?: DescribeApiHistoryResponseBodySystemParametersSystemParameter[];
  static names(): { [key: string]: string } {
    return {
      systemParameter: 'SystemParameter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      systemParameter: { 'type': 'array', 'itemType': DescribeApiHistoryResponseBodySystemParametersSystemParameter },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiIpControlsResponseBodyApiIpControlsApiIpControlItem extends $tea.Model {
  /**
   * @remarks
   * The ID of the API.
   * 
   * @example
   * 46fbb52840d146f186e38e8e70fc8c90
   */
  apiId?: string;
  /**
   * @remarks
   * The name of the API.
   * 
   * @example
   * testapi
   */
  apiName?: string;
  /**
   * @remarks
   * The time of binding.
   * 
   * @example
   * 2016-07-23T08:28:48Z
   */
  boundTime?: string;
  /**
   * @remarks
   * The ID of the ACL.
   * 
   * @example
   * dd05f1c54d6749eda95f9fa6d491449a
   */
  ipControlId?: string;
  /**
   * @remarks
   * The name of the ACL.
   * 
   * @example
   * testControlName
   */
  ipControlName?: string;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      apiName: 'ApiName',
      boundTime: 'BoundTime',
      ipControlId: 'IpControlId',
      ipControlName: 'IpControlName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'string',
      apiName: 'string',
      boundTime: 'string',
      ipControlId: 'string',
      ipControlName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiIpControlsResponseBodyApiIpControls extends $tea.Model {
  apiIpControlItem?: DescribeApiIpControlsResponseBodyApiIpControlsApiIpControlItem[];
  static names(): { [key: string]: string } {
    return {
      apiIpControlItem: 'ApiIpControlItem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiIpControlItem: { 'type': 'array', 'itemType': DescribeApiIpControlsResponseBodyApiIpControlsApiIpControlItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiLatencyDataResponseBodyCallLatencysMonitorItem extends $tea.Model {
  /**
   * @remarks
   * The time of the monitoring metric. The time format follows the ISO 8601 standard and UTC time is used. Format: YYYY-MM-DDThh:mm:ssZ
   * 
   * @example
   * 2016-07-28T08:20:00Z
   */
  itemTime?: string;
  /**
   * @remarks
   * The value corresponding to the monitoring metric.
   * 
   * @example
   * 15
   */
  itemValue?: string;
  static names(): { [key: string]: string } {
    return {
      itemTime: 'ItemTime',
      itemValue: 'ItemValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      itemTime: 'string',
      itemValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiLatencyDataResponseBodyCallLatencys extends $tea.Model {
  monitorItem?: DescribeApiLatencyDataResponseBodyCallLatencysMonitorItem[];
  static names(): { [key: string]: string } {
    return {
      monitorItem: 'MonitorItem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      monitorItem: { 'type': 'array', 'itemType': DescribeApiLatencyDataResponseBodyCallLatencysMonitorItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiProductApisResponseBodyApiInfoListApiInfo extends $tea.Model {
  /**
   * @remarks
   * The API ID.
   * 
   * @example
   * dd46297680014a7e8e318308f3345951
   */
  apiId?: string;
  /**
   * @remarks
   * The API name.
   * 
   * @example
   * testApi
   */
  apiName?: string;
  /**
   * @remarks
   * The API description.
   * 
   * @example
   * test
   */
  description?: string;
  /**
   * @remarks
   * The ID of the API group.
   * 
   * @example
   * 1e377f18142345dfb700cd8911c2463a
   */
  groupId?: string;
  /**
   * @remarks
   * The name of the API group to which the API belongs.
   * 
   * @example
   * testApiGroup
   */
  groupName?: string;
  /**
   * @remarks
   * The request method of the API.
   * 
   * @example
   * POST
   */
  method?: string;
  /**
   * @remarks
   * The request path of the API.
   * 
   * @example
   * /test
   */
  path?: string;
  /**
   * @remarks
   * The ID of the region where the API is deployed.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The environment to which the API is published. Valid values:
   * 
   * *   **RELEASE**: the production environment
   * *   **PRE**: the staging environment
   * *   **TEST**: the test environment
   * 
   * @example
   * RELEASE
   */
  stageName?: string;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      apiName: 'ApiName',
      description: 'Description',
      groupId: 'GroupId',
      groupName: 'GroupName',
      method: 'Method',
      path: 'Path',
      regionId: 'RegionId',
      stageName: 'StageName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'string',
      apiName: 'string',
      description: 'string',
      groupId: 'string',
      groupName: 'string',
      method: 'string',
      path: 'string',
      regionId: 'string',
      stageName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiProductApisResponseBodyApiInfoList extends $tea.Model {
  apiInfo?: DescribeApiProductApisResponseBodyApiInfoListApiInfo[];
  static names(): { [key: string]: string } {
    return {
      apiInfo: 'ApiInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiInfo: { 'type': 'array', 'itemType': DescribeApiProductApisResponseBodyApiInfoListApiInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiProductsByAppResponseBodyApiProductInfoListApiProductInfo extends $tea.Model {
  /**
   * @remarks
   * The ID of the API product.
   * 
   * @example
   * 117b7a64a8b3f064eaa4a47ac62aac5e
   */
  apiProductId?: string;
  static names(): { [key: string]: string } {
    return {
      apiProductId: 'ApiProductId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiProductId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiProductsByAppResponseBodyApiProductInfoList extends $tea.Model {
  apiProductInfo?: DescribeApiProductsByAppResponseBodyApiProductInfoListApiProductInfo[];
  static names(): { [key: string]: string } {
    return {
      apiProductInfo: 'ApiProductInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiProductInfo: { 'type': 'array', 'itemType': DescribeApiProductsByAppResponseBodyApiProductInfoListApiProductInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiQpsDataResponseBodyCallFailsMonitorItem extends $tea.Model {
  /**
   * @remarks
   * The time of the monitoring metric. The time format follows the ISO 8601 standard and UTC time is used. Format: YYYY-MM-DDThh:mm:ssZ
   * 
   * @example
   * 2016-07-28T08:20:00Z
   */
  itemTime?: string;
  /**
   * @remarks
   * The value corresponding to the monitoring metric.
   * 
   * @example
   * 0
   */
  itemValue?: string;
  static names(): { [key: string]: string } {
    return {
      itemTime: 'ItemTime',
      itemValue: 'ItemValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      itemTime: 'string',
      itemValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiQpsDataResponseBodyCallFails extends $tea.Model {
  monitorItem?: DescribeApiQpsDataResponseBodyCallFailsMonitorItem[];
  static names(): { [key: string]: string } {
    return {
      monitorItem: 'MonitorItem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      monitorItem: { 'type': 'array', 'itemType': DescribeApiQpsDataResponseBodyCallFailsMonitorItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiQpsDataResponseBodyCallSuccessesMonitorItem extends $tea.Model {
  /**
   * @remarks
   * The time of the monitoring metric. The time format follows the ISO 8601 standard and UTC time is used. Format: YYYY-MM-DDThh:mm:ssZ
   * 
   * @example
   * 2016-07-28T08:24:00Z
   */
  itemTime?: string;
  /**
   * @remarks
   * The value corresponding to the monitoring metric.
   * 
   * @example
   * 650
   */
  itemValue?: string;
  static names(): { [key: string]: string } {
    return {
      itemTime: 'ItemTime',
      itemValue: 'ItemValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      itemTime: 'string',
      itemValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiQpsDataResponseBodyCallSuccesses extends $tea.Model {
  monitorItem?: DescribeApiQpsDataResponseBodyCallSuccessesMonitorItem[];
  static names(): { [key: string]: string } {
    return {
      monitorItem: 'MonitorItem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      monitorItem: { 'type': 'array', 'itemType': DescribeApiQpsDataResponseBodyCallSuccessesMonitorItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiSignaturesResponseBodyApiSignaturesApiSignatureItem extends $tea.Model {
  /**
   * @remarks
   * The ID of the API.
   * 
   * @example
   * 46fbb52840d146f186e38e8e70fc8c90
   */
  apiId?: string;
  /**
   * @remarks
   * The name of the API.
   * 
   * @example
   * testapi
   */
  apiName?: string;
  /**
   * @remarks
   * The time when the backend signature key was bound.
   * 
   * @example
   * 2016-07-23T08:28:48Z
   */
  boundTime?: string;
  /**
   * @remarks
   * The ID of the backend signature key.
   * 
   * @example
   * dd05f1c54d6749eda95f9fa6d491449a
   */
  signatureId?: string;
  /**
   * @remarks
   * The name of the backend signature key.
   * 
   * @example
   * backendsignature
   */
  signatureName?: string;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      apiName: 'ApiName',
      boundTime: 'BoundTime',
      signatureId: 'SignatureId',
      signatureName: 'SignatureName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'string',
      apiName: 'string',
      boundTime: 'string',
      signatureId: 'string',
      signatureName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiSignaturesResponseBodyApiSignatures extends $tea.Model {
  apiSignatureItem?: DescribeApiSignaturesResponseBodyApiSignaturesApiSignatureItem[];
  static names(): { [key: string]: string } {
    return {
      apiSignatureItem: 'ApiSignatureItem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiSignatureItem: { 'type': 'array', 'itemType': DescribeApiSignaturesResponseBodyApiSignaturesApiSignatureItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiTrafficControlsResponseBodyApiTrafficControlsApiTrafficControlItem extends $tea.Model {
  /**
   * @remarks
   * The ID of the API.
   * 
   * @example
   * 46fbb52840d146f186e38e8e70fc8c90
   */
  apiId?: string;
  /**
   * @remarks
   * API operation
   * 
   * @example
   * testapi
   */
  apiName?: string;
  /**
   * @remarks
   * The binding time of the throttling policy.
   * 
   * @example
   * 2016-07-23T08:28:48Z
   */
  boundTime?: string;
  /**
   * @remarks
   * The ID of the throttling policy.
   * 
   * @example
   * dd05f1c54d6749eda95f9fa6d491449a
   */
  trafficControlId?: string;
  /**
   * @remarks
   * The name of the throttling policy.
   * 
   * @example
   * backendsignature
   */
  trafficControlName?: string;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      apiName: 'ApiName',
      boundTime: 'BoundTime',
      trafficControlId: 'TrafficControlId',
      trafficControlName: 'TrafficControlName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'string',
      apiName: 'string',
      boundTime: 'string',
      trafficControlId: 'string',
      trafficControlName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiTrafficControlsResponseBodyApiTrafficControls extends $tea.Model {
  apiTrafficControlItem?: DescribeApiTrafficControlsResponseBodyApiTrafficControlsApiTrafficControlItem[];
  static names(): { [key: string]: string } {
    return {
      apiTrafficControlItem: 'ApiTrafficControlItem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiTrafficControlItem: { 'type': 'array', 'itemType': DescribeApiTrafficControlsResponseBodyApiTrafficControlsApiTrafficControlItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiTrafficDataResponseBodyCallDownloadsMonitorItem extends $tea.Model {
  /**
   * @remarks
   * The time of the monitoring metric. The time format follows the ISO 8601 standard and UTC time is used. Format: YYYY-MM-DDThh:mm:ssZ
   * 
   * @example
   * 2016-07-28T08:20:00Z
   */
  itemTime?: string;
  /**
   * @remarks
   * The value corresponding to the monitoring metric.
   * 
   * @example
   * 0
   */
  itemValue?: string;
  static names(): { [key: string]: string } {
    return {
      itemTime: 'ItemTime',
      itemValue: 'ItemValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      itemTime: 'string',
      itemValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiTrafficDataResponseBodyCallDownloads extends $tea.Model {
  monitorItem?: DescribeApiTrafficDataResponseBodyCallDownloadsMonitorItem[];
  static names(): { [key: string]: string } {
    return {
      monitorItem: 'MonitorItem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      monitorItem: { 'type': 'array', 'itemType': DescribeApiTrafficDataResponseBodyCallDownloadsMonitorItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiTrafficDataResponseBodyCallUploadsMonitorItem extends $tea.Model {
  /**
   * @remarks
   * The time of the monitoring metric. The time format follows the ISO 8601 standard and UTC time is used. Format: YYYY-MM-DDThh:mm:ssZ
   * 
   * @example
   * 2016-07-28T08:20:00Z
   */
  itemTime?: string;
  /**
   * @remarks
   * The value corresponding to the monitoring metric.
   * 
   * @example
   * 670
   */
  itemValue?: string;
  static names(): { [key: string]: string } {
    return {
      itemTime: 'ItemTime',
      itemValue: 'ItemValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      itemTime: 'string',
      itemValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApiTrafficDataResponseBodyCallUploads extends $tea.Model {
  monitorItem?: DescribeApiTrafficDataResponseBodyCallUploadsMonitorItem[];
  static names(): { [key: string]: string } {
    return {
      monitorItem: 'MonitorItem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      monitorItem: { 'type': 'array', 'itemType': DescribeApiTrafficDataResponseBodyCallUploadsMonitorItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApisRequestTag extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * key
   */
  key?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * value
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApisResponseBodyApiSummarysApiSummaryDeployedInfosDeployedInfo extends $tea.Model {
  /**
   * @remarks
   * The deployment status. Valid values: DEPLOYED and NONDEPLOYED.
   * 
   * @example
   * DEPLOYED
   */
  deployedStatus?: string;
  /**
   * @remarks
   * The deployed version.
   * 
   * @example
   * 20220103170737313
   */
  effectiveVersion?: string;
  /**
   * @remarks
   * Stage Name:
   * 
   * *   **RELEASE**: production environment
   * *   **PRE**: staging environment
   * *   **TEST**: test environment
   * 
   * @example
   * RELEASE
   */
  stageName?: string;
  static names(): { [key: string]: string } {
    return {
      deployedStatus: 'DeployedStatus',
      effectiveVersion: 'EffectiveVersion',
      stageName: 'StageName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deployedStatus: 'string',
      effectiveVersion: 'string',
      stageName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApisResponseBodyApiSummarysApiSummaryDeployedInfos extends $tea.Model {
  deployedInfo?: DescribeApisResponseBodyApiSummarysApiSummaryDeployedInfosDeployedInfo[];
  static names(): { [key: string]: string } {
    return {
      deployedInfo: 'DeployedInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deployedInfo: { 'type': 'array', 'itemType': DescribeApisResponseBodyApiSummarysApiSummaryDeployedInfosDeployedInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApisResponseBodyApiSummarysApiSummaryTagListTag extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * tagKey
   */
  tagKey?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * tagValue
   */
  tagValue?: string;
  static names(): { [key: string]: string } {
    return {
      tagKey: 'TagKey',
      tagValue: 'TagValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagKey: 'string',
      tagValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApisResponseBodyApiSummarysApiSummaryTagList extends $tea.Model {
  tag?: DescribeApisResponseBodyApiSummarysApiSummaryTagListTag[];
  static names(): { [key: string]: string } {
    return {
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tag: { 'type': 'array', 'itemType': DescribeApisResponseBodyApiSummarysApiSummaryTagListTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApisResponseBodyApiSummarysApiSummary extends $tea.Model {
  /**
   * @remarks
   * The API ID.
   * 
   * @example
   * 5af418828f0344a3b588c0cc1331a3bc
   */
  apiId?: string;
  /**
   * @remarks
   * The HTTP method of the API request.
   * 
   * @example
   * GET
   */
  apiMethod?: string;
  /**
   * @remarks
   * The API name.
   * 
   * @example
   * CreateObject
   */
  apiName?: string;
  /**
   * @remarks
   * The request path of the API.
   * 
   * @example
   * /sqb/
   */
  apiPath?: string;
  /**
   * @remarks
   * The time when the API was created. The time is displayed in UTC.
   * 
   * @example
   * 2016-05-20T18:18:25Z
   */
  createdTime?: string;
  /**
   * @remarks
   * The API publishing statuses.
   */
  deployedInfos?: DescribeApisResponseBodyApiSummarysApiSummaryDeployedInfos;
  /**
   * @remarks
   * The API description.
   * 
   * @example
   * Creates an object
   */
  description?: string;
  /**
   * @remarks
   * The API group ID.
   * 
   * @example
   * 1084f9034c744137901057206b39d2b6
   */
  groupId?: string;
  /**
   * @remarks
   * The name of the API group to which the API belongs.
   * 
   * @example
   * myGroup2
   */
  groupName?: string;
  /**
   * @remarks
   * The time when the API was modified. The time is displayed in UTC.
   * 
   * @example
   * 2016-07-23T08:28:48Z
   */
  modifiedTime?: string;
  /**
   * @remarks
   * The ID of the region to which the API belongs.
   * 
   * @example
   * cn-qingdao
   */
  regionId?: string;
  /**
   * @remarks
   * The tags that are added to the APIs.
   */
  tagList?: DescribeApisResponseBodyApiSummarysApiSummaryTagList;
  /**
   * @remarks
   * Indicates whether the API is public. Valid values:
   * 
   * *   **PUBLIC**: The API is public.
   * *   **PRIVATE**: The API is private.
   * 
   * @example
   * PUBLIC
   */
  visibility?: string;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      apiMethod: 'ApiMethod',
      apiName: 'ApiName',
      apiPath: 'ApiPath',
      createdTime: 'CreatedTime',
      deployedInfos: 'DeployedInfos',
      description: 'Description',
      groupId: 'GroupId',
      groupName: 'GroupName',
      modifiedTime: 'ModifiedTime',
      regionId: 'RegionId',
      tagList: 'TagList',
      visibility: 'Visibility',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'string',
      apiMethod: 'string',
      apiName: 'string',
      apiPath: 'string',
      createdTime: 'string',
      deployedInfos: DescribeApisResponseBodyApiSummarysApiSummaryDeployedInfos,
      description: 'string',
      groupId: 'string',
      groupName: 'string',
      modifiedTime: 'string',
      regionId: 'string',
      tagList: DescribeApisResponseBodyApiSummarysApiSummaryTagList,
      visibility: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApisResponseBodyApiSummarys extends $tea.Model {
  apiSummary?: DescribeApisResponseBodyApiSummarysApiSummary[];
  static names(): { [key: string]: string } {
    return {
      apiSummary: 'ApiSummary',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiSummary: { 'type': 'array', 'itemType': DescribeApisResponseBodyApiSummarysApiSummary },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApisByAppResponseBodyAppApiRelationInfosAppApiRelationInfo extends $tea.Model {
  /**
   * @remarks
   * The API ID.
   * 
   * @example
   * c625795a1e664782a918eaa629e96ab5
   */
  apiId?: string;
  /**
   * @remarks
   * The API name.
   * 
   * @example
   * sd2_h5_player_history_competition
   */
  apiName?: string;
  /**
   * @remarks
   * The validity period of the authorization.
   * 
   * @example
   * Sun, 02 Jan 2022 16:00:00 GMT
   */
  authVaildTime?: string;
  /**
   * @remarks
   * The authorization source.
   * 
   * @example
   * SELF
   */
  authorizationSource?: string;
  /**
   * @remarks
   * The time when the authorization was created.
   * 
   * @example
   * Sun, 02 Jan 2022 16:00:00 GMT
   */
  createdTime?: string;
  /**
   * @remarks
   * The authorization description.
   * 
   * @example
   * b1008kz
   */
  description?: string;
  /**
   * @remarks
   * The ID of the API group.
   * 
   * @example
   * 38bed48d664149e4b9b5ea576319673f
   */
  groupId?: string;
  /**
   * @remarks
   * The name of the API group.
   * 
   * @example
   * wb2022012101605749
   */
  groupName?: string;
  /**
   * @remarks
   * The HTTP method of the API.
   * 
   * @example
   * GET
   */
  method?: string;
  /**
   * @remarks
   * The authorizer. Valid values:
   * 
   * *   **PROVIDER**: API owner
   * *   **CONSUMER**: API caller
   * 
   * @example
   * PROVIDER
   */
  operator?: string;
  /**
   * @remarks
   * The request path of the API.
   * 
   * @example
   * /api/offline/cacheData
   */
  path?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-shanghai
   */
  regionId?: string;
  /**
   * @remarks
   * The environment alias.
   * 
   * @example
   * Online
   */
  stageAlias?: string;
  /**
   * @remarks
   * The environment name.
   * 
   * @example
   * RELEASE
   */
  stageName?: string;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      apiName: 'ApiName',
      authVaildTime: 'AuthVaildTime',
      authorizationSource: 'AuthorizationSource',
      createdTime: 'CreatedTime',
      description: 'Description',
      groupId: 'GroupId',
      groupName: 'GroupName',
      method: 'Method',
      operator: 'Operator',
      path: 'Path',
      regionId: 'RegionId',
      stageAlias: 'StageAlias',
      stageName: 'StageName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'string',
      apiName: 'string',
      authVaildTime: 'string',
      authorizationSource: 'string',
      createdTime: 'string',
      description: 'string',
      groupId: 'string',
      groupName: 'string',
      method: 'string',
      operator: 'string',
      path: 'string',
      regionId: 'string',
      stageAlias: 'string',
      stageName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApisByAppResponseBodyAppApiRelationInfos extends $tea.Model {
  appApiRelationInfo?: DescribeApisByAppResponseBodyAppApiRelationInfosAppApiRelationInfo[];
  static names(): { [key: string]: string } {
    return {
      appApiRelationInfo: 'AppApiRelationInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appApiRelationInfo: { 'type': 'array', 'itemType': DescribeApisByAppResponseBodyAppApiRelationInfosAppApiRelationInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApisByBackendResponseBodyApiInfoListApiInfo extends $tea.Model {
  /**
   * @remarks
   * The ID of the API.
   * 
   * @example
   * 20bcdc9453524b78a8beb1f6de21edb7
   */
  apiId?: string;
  /**
   * @remarks
   * The name of the API.
   * 
   * @example
   * testApi
   */
  apiName?: string;
  /**
   * @remarks
   * The description of the API.
   * 
   * @example
   * test
   */
  description?: string;
  /**
   * @remarks
   * The ID of the API group.
   * 
   * @example
   * 15bcdc9453524b7gs8beb1f6de21edb7
   */
  groupId?: string;
  /**
   * @remarks
   * The name of the API group.
   * 
   * @example
   * testApiGroup
   */
  groupName?: string;
  /**
   * @remarks
   * The request method of the API.
   * 
   * @example
   * GET
   */
  method?: string;
  /**
   * @remarks
   * The request path of the API.
   * 
   * @example
   * /test
   */
  path?: string;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      apiName: 'ApiName',
      description: 'Description',
      groupId: 'GroupId',
      groupName: 'GroupName',
      method: 'Method',
      path: 'Path',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'string',
      apiName: 'string',
      description: 'string',
      groupId: 'string',
      groupName: 'string',
      method: 'string',
      path: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApisByBackendResponseBodyApiInfoList extends $tea.Model {
  apiInfo?: DescribeApisByBackendResponseBodyApiInfoListApiInfo[];
  static names(): { [key: string]: string } {
    return {
      apiInfo: 'ApiInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiInfo: { 'type': 'array', 'itemType': DescribeApisByBackendResponseBodyApiInfoListApiInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApisByIpControlResponseBodyApiInfosApiInfo extends $tea.Model {
  /**
   * @remarks
   * The ID of the API.
   * 
   * @example
   * 3b81fd160f5645e097cc8855d75a1cf6
   */
  apiId?: string;
  /**
   * @remarks
   * The name of the API
   * 
   * @example
   * testapi
   */
  apiName?: string;
  /**
   * @remarks
   * The time of API binding.
   * 
   * @example
   * 2016-07-23T08:28:48Z
   */
  boundTime?: string;
  /**
   * @remarks
   * The description of the API.
   * 
   * @example
   * Description
   */
  description?: string;
  /**
   * @remarks
   * The ID of the API group.
   * 
   * @example
   * 0009db9c828549768a200320714b8930
   */
  groupId?: string;
  /**
   * @remarks
   * The name of the API group.
   * 
   * @example
   * mygroup
   */
  groupName?: string;
  /**
   * @remarks
   * The region in which the API is located.
   * 
   * @example
   * cn-qingdao
   */
  regionId?: string;
  /**
   * @remarks
   * The name of the runtime environment. Valid values:
   * 
   * *   **RELEASE**
   * *   **TEST.
   * 
   * @example
   * TEST
   */
  stageName?: string;
  /**
   * @remarks
   * The visibility of the API. Valid values:
   * 
   * *   **PUBLIC**
   * *   **PRIVATE**
   * 
   * @example
   * PUBLIC
   */
  visibility?: string;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      apiName: 'ApiName',
      boundTime: 'BoundTime',
      description: 'Description',
      groupId: 'GroupId',
      groupName: 'GroupName',
      regionId: 'RegionId',
      stageName: 'StageName',
      visibility: 'Visibility',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'string',
      apiName: 'string',
      boundTime: 'string',
      description: 'string',
      groupId: 'string',
      groupName: 'string',
      regionId: 'string',
      stageName: 'string',
      visibility: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApisByIpControlResponseBodyApiInfos extends $tea.Model {
  apiInfo?: DescribeApisByIpControlResponseBodyApiInfosApiInfo[];
  static names(): { [key: string]: string } {
    return {
      apiInfo: 'ApiInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiInfo: { 'type': 'array', 'itemType': DescribeApisByIpControlResponseBodyApiInfosApiInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApisBySignatureResponseBodyApiInfosApiInfo extends $tea.Model {
  /**
   * @remarks
   * The ID of the API.
   * 
   * @example
   * 3b81fd160f5645e097cc8855d75a1cf6
   */
  apiId?: string;
  /**
   * @remarks
   * The name of the API.
   * 
   * @example
   * testapi
   */
  apiName?: string;
  /**
   * @remarks
   * The binding time of the API.
   * 
   * @example
   * 2016-07-23T08:28:48Z
   */
  boundTime?: string;
  /**
   * @remarks
   * The description of the API.
   * 
   * @example
   * Description
   */
  description?: string;
  /**
   * @remarks
   * The ID of the API group.
   * 
   * @example
   * 0009db9c828549768a200320714b8930
   */
  groupId?: string;
  /**
   * @remarks
   * The name of the group to which the API belongs.
   * 
   * @example
   * mygroup
   */
  groupName?: string;
  /**
   * @remarks
   * The region where the API is located.
   * 
   * @example
   * cn-qingdao
   */
  regionId?: string;
  /**
   * @remarks
   * The name of the runtime environment. Valid values:
   * 
   * *   **RELEASE**
   * *   **TEST**
   * 
   * @example
   * TEST
   */
  stageName?: string;
  /**
   * @remarks
   * Indicates whether the API is public. Valid values:
   * 
   * *   **PUBLIC**
   * *   **PRIVATE**
   * 
   * @example
   * PUBLIC
   */
  visibility?: string;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      apiName: 'ApiName',
      boundTime: 'BoundTime',
      description: 'Description',
      groupId: 'GroupId',
      groupName: 'GroupName',
      regionId: 'RegionId',
      stageName: 'StageName',
      visibility: 'Visibility',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'string',
      apiName: 'string',
      boundTime: 'string',
      description: 'string',
      groupId: 'string',
      groupName: 'string',
      regionId: 'string',
      stageName: 'string',
      visibility: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApisBySignatureResponseBodyApiInfos extends $tea.Model {
  apiInfo?: DescribeApisBySignatureResponseBodyApiInfosApiInfo[];
  static names(): { [key: string]: string } {
    return {
      apiInfo: 'ApiInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiInfo: { 'type': 'array', 'itemType': DescribeApisBySignatureResponseBodyApiInfosApiInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApisByTrafficControlResponseBodyApiInfosApiInfo extends $tea.Model {
  /**
   * @remarks
   * The ID of the API.
   * 
   * @example
   * 3b81fd160f5645e097cc8855d75a1cf6
   */
  apiId?: string;
  /**
   * @remarks
   * The name of the API
   * 
   * @example
   * testapi
   */
  apiName?: string;
  /**
   * @remarks
   * The binding time of the API.
   * 
   * @example
   * 2016-07-23T08:28:48Z
   */
  boundTime?: string;
  /**
   * @remarks
   * The description of the API.
   * 
   * @example
   * Description
   */
  description?: string;
  /**
   * @remarks
   * The ID of the API group.
   * 
   * @example
   * 0009db9c828549768a200320714b8930
   */
  groupId?: string;
  /**
   * @remarks
   * The name of the group to which an API belongs.
   * 
   * @example
   * mygroup
   */
  groupName?: string;
  /**
   * @remarks
   * The region where the API is located.
   * 
   * @example
   * cn-qingdao
   */
  regionId?: string;
  /**
   * @remarks
   * The name of the runtime environment. Valid values:
   * 
   * *   **RELEASE**
   * *   **TEST**
   * 
   * @example
   * TEST
   */
  stageName?: string;
  /**
   * @remarks
   * Indicates whether the API is public. Valid values:
   * 
   * *   **PUBLIC**
   * *   **PRIVATE**
   * 
   * @example
   * PUBLIC
   */
  visibility?: string;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      apiName: 'ApiName',
      boundTime: 'BoundTime',
      description: 'Description',
      groupId: 'GroupId',
      groupName: 'GroupName',
      regionId: 'RegionId',
      stageName: 'StageName',
      visibility: 'Visibility',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'string',
      apiName: 'string',
      boundTime: 'string',
      description: 'string',
      groupId: 'string',
      groupName: 'string',
      regionId: 'string',
      stageName: 'string',
      visibility: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApisByTrafficControlResponseBodyApiInfos extends $tea.Model {
  apiInfo?: DescribeApisByTrafficControlResponseBodyApiInfosApiInfo[];
  static names(): { [key: string]: string } {
    return {
      apiInfo: 'ApiInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiInfo: { 'type': 'array', 'itemType': DescribeApisByTrafficControlResponseBodyApiInfosApiInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApisByVpcAccessResponseBodyApiVpcAccessInfosApiVpcAccessInfo extends $tea.Model {
  /**
   * @remarks
   * The API ID.
   * 
   * @example
   * 09839002de484e76b5a213b040a6a3ca
   */
  apiId?: string;
  /**
   * @remarks
   * The API name.
   * 
   * @example
   * iwc
   */
  apiName?: string;
  /**
   * @remarks
   * The description, which can be up to 200 characters in length.
   * 
   * @example
   * 123
   */
  description?: string;
  /**
   * @remarks
   * The ID of the API group to which the API belongs.
   * 
   * @example
   * 41c33748cbfb41f6b00870156203b72a
   */
  groupId?: string;
  /**
   * @remarks
   * The name of the API group to which the API belongs.
   * 
   * @example
   * RT_PLU_IP_CTRL_group
   */
  groupName?: string;
  /**
   * @remarks
   * The instance ID or IP address in the VPC access authorization.
   * 
   * @example
   * Ib-04e41XXXXXd95e9c1
   */
  instanceId?: string;
  /**
   * @remarks
   * The HTTP request method of the API.
   * 
   * @example
   * POST
   */
  method?: string;
  /**
   * @remarks
   * The request path of the API.
   * 
   * @example
   * /api/v1/friends/rc/status
   */
  path?: string;
  /**
   * @remarks
   * The port number.
   * 
   * @example
   * 443
   */
  port?: number;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-shanghai
   */
  regionId?: string;
  /**
   * @remarks
   * The environment ID.
   * 
   * @example
   * 57e17906a69b4424914fb1e05f67c78a
   */
  stageId?: string;
  /**
   * @remarks
   * The environment to which the API is published. Valid values:
   * 
   * *   **RELEASE**: the production environment
   * *   **PRE**: the staging environment
   * *   **TEST**: the test environment
   * 
   * @example
   * RELEASE
   */
  stageName?: string;
  /**
   * @remarks
   * vpc id
   * 
   * @example
   * vpc-2ze7bj64wstznvftrskbk
   */
  vpcId?: string;
  /**
   * @remarks
   * The name of the VPC access authorization.
   * 
   * @example
   * aliYun_service_prod
   */
  vpcName?: string;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      apiName: 'ApiName',
      description: 'Description',
      groupId: 'GroupId',
      groupName: 'GroupName',
      instanceId: 'InstanceId',
      method: 'Method',
      path: 'Path',
      port: 'Port',
      regionId: 'RegionId',
      stageId: 'StageId',
      stageName: 'StageName',
      vpcId: 'VpcId',
      vpcName: 'VpcName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'string',
      apiName: 'string',
      description: 'string',
      groupId: 'string',
      groupName: 'string',
      instanceId: 'string',
      method: 'string',
      path: 'string',
      port: 'number',
      regionId: 'string',
      stageId: 'string',
      stageName: 'string',
      vpcId: 'string',
      vpcName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApisByVpcAccessResponseBodyApiVpcAccessInfos extends $tea.Model {
  apiVpcAccessInfo?: DescribeApisByVpcAccessResponseBodyApiVpcAccessInfosApiVpcAccessInfo[];
  static names(): { [key: string]: string } {
    return {
      apiVpcAccessInfo: 'ApiVpcAccessInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiVpcAccessInfo: { 'type': 'array', 'itemType': DescribeApisByVpcAccessResponseBodyApiVpcAccessInfosApiVpcAccessInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApisWithStageNameIntegratedByAppResponseBodyAppApiRelationInfosAppApiRelationInfo extends $tea.Model {
  /**
   * @remarks
   * The API ID.
   * 
   * @example
   * c625795a1e664782a918eaa629e96ab5
   */
  apiId?: string;
  /**
   * @remarks
   * The API name.
   * 
   * @example
   * sd2_h5_player_history_competition
   */
  apiName?: string;
  /**
   * @remarks
   * The authorization source.
   * 
   * @example
   * SELF
   */
  authorizationSource?: string;
  /**
   * @remarks
   * The time when the authorization was created.
   * 
   * @example
   * Sun, 02 Jan 2022 16:00:00 GMT
   */
  createdTime?: string;
  /**
   * @remarks
   * The API description.
   * 
   * @example
   * b1008kz
   */
  description?: string;
  /**
   * @remarks
   * The ID of the API group.
   * 
   * @example
   * 38bed48d664149e4b9b5ea576319673f
   */
  groupId?: string;
  /**
   * @remarks
   * The name of the API group.
   * 
   * @example
   * manager_vehicles
   */
  groupName?: string;
  /**
   * @remarks
   * The request HTTP method of the API.
   * 
   * @example
   * POST
   */
  method?: string;
  /**
   * @remarks
   * The authorizer. Valid values:
   * 
   * *   **PROVIDER:** the API owner
   * *   **CONSUMER:** the API caller
   * 
   * @example
   * PROVIDER
   */
  operator?: string;
  /**
   * @remarks
   * The request path of the API.
   * 
   * @example
   * /api/offline/cacheData
   */
  path?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-shanghai
   */
  regionId?: string;
  /**
   * @remarks
   * The mapping information between environments and authorizations.
   */
  stageNameAndAuth?: { [key: string]: string };
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      apiName: 'ApiName',
      authorizationSource: 'AuthorizationSource',
      createdTime: 'CreatedTime',
      description: 'Description',
      groupId: 'GroupId',
      groupName: 'GroupName',
      method: 'Method',
      operator: 'Operator',
      path: 'Path',
      regionId: 'RegionId',
      stageNameAndAuth: 'StageNameAndAuth',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'string',
      apiName: 'string',
      authorizationSource: 'string',
      createdTime: 'string',
      description: 'string',
      groupId: 'string',
      groupName: 'string',
      method: 'string',
      operator: 'string',
      path: 'string',
      regionId: 'string',
      stageNameAndAuth: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeApisWithStageNameIntegratedByAppResponseBodyAppApiRelationInfos extends $tea.Model {
  appApiRelationInfo?: DescribeApisWithStageNameIntegratedByAppResponseBodyAppApiRelationInfosAppApiRelationInfo[];
  static names(): { [key: string]: string } {
    return {
      appApiRelationInfo: 'AppApiRelationInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appApiRelationInfo: { 'type': 'array', 'itemType': DescribeApisWithStageNameIntegratedByAppResponseBodyAppApiRelationInfosAppApiRelationInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAppAttributesRequestTag extends $tea.Model {
  /**
   * @remarks
   * The key of the tag.
   * 
   * N can be an integer from 1 to 20.``
   * 
   * This parameter is required.
   * 
   * @example
   * env
   */
  key?: string;
  /**
   * @remarks
   * The key of the tag.
   * 
   * N can be an integer from 1 to 20.``
   * 
   * @example
   * \\" \\"
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAppAttributesResponseBodyAppsAppAttributeTagsTagInfo extends $tea.Model {
  /**
   * @remarks
   * The key of the tag.
   * 
   * @example
   * appid
   */
  key?: string;
  /**
   * @remarks
   * The value of the tag.
   * 
   * @example
   * 123
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAppAttributesResponseBodyAppsAppAttributeTags extends $tea.Model {
  tagInfo?: DescribeAppAttributesResponseBodyAppsAppAttributeTagsTagInfo[];
  static names(): { [key: string]: string } {
    return {
      tagInfo: 'TagInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagInfo: { 'type': 'array', 'itemType': DescribeAppAttributesResponseBodyAppsAppAttributeTagsTagInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAppAttributesResponseBodyAppsAppAttribute extends $tea.Model {
  /**
   * @remarks
   * The ID of the app.
   * 
   * @example
   * 20112314518278
   */
  appId?: number;
  /**
   * @remarks
   * The name of the app.
   * 
   * @example
   * CreateApptest
   */
  appName?: string;
  /**
   * @remarks
   * The creation time (UTC) of the app.
   * 
   * @example
   * 2016-07-31T04:10:19Z
   */
  createdTime?: string;
  /**
   * @remarks
   * The description of the app.
   * 
   * @example
   * App test
   */
  description?: string;
  /**
   * @remarks
   * 扩展信息
   * 
   * @example
   * 110461946884
   */
  extend?: string;
  /**
   * @remarks
   * The modification time (UTC) of the app.
   * 
   * @example
   * 2016-07-31T04:10:19Z
   */
  modifiedTime?: string;
  /**
   * @remarks
   * The tags.
   */
  tags?: DescribeAppAttributesResponseBodyAppsAppAttributeTags;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      appName: 'AppName',
      createdTime: 'CreatedTime',
      description: 'Description',
      extend: 'Extend',
      modifiedTime: 'ModifiedTime',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'number',
      appName: 'string',
      createdTime: 'string',
      description: 'string',
      extend: 'string',
      modifiedTime: 'string',
      tags: DescribeAppAttributesResponseBodyAppsAppAttributeTags,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAppAttributesResponseBodyApps extends $tea.Model {
  appAttribute?: DescribeAppAttributesResponseBodyAppsAppAttribute[];
  static names(): { [key: string]: string } {
    return {
      appAttribute: 'AppAttribute',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appAttribute: { 'type': 'array', 'itemType': DescribeAppAttributesResponseBodyAppsAppAttribute },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAppSecuritiesResponseBodyAppSecuritysAppSecurity extends $tea.Model {
  /**
   * @remarks
   * The application AppCode.
   * 
   * @example
   * d2350ecd62c44cbfbe35a7f182e35105
   */
  appCode?: string;
  /**
   * @remarks
   * The application AppKey.
   * 
   * @example
   * 34379343
   */
  appKey?: string;
  /**
   * @remarks
   * The application AppSecret.
   * 
   * @example
   * ea5291a7aff343769eb3139a2f6de8c9
   */
  appSecret?: string;
  /**
   * @remarks
   * The time when the AppKey was created.
   * 
   * @example
   * 2021-09-14T18:50:59
   */
  createdTime?: string;
  /**
   * @remarks
   * The time when the AppSecret was last modified. The time is displayed in UTC.
   * 
   * @example
   * 2023-08-14T18:03:00+08:00
   */
  modifiedTime?: string;
  static names(): { [key: string]: string } {
    return {
      appCode: 'AppCode',
      appKey: 'AppKey',
      appSecret: 'AppSecret',
      createdTime: 'CreatedTime',
      modifiedTime: 'ModifiedTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appCode: 'string',
      appKey: 'string',
      appSecret: 'string',
      createdTime: 'string',
      modifiedTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAppSecuritiesResponseBodyAppSecuritys extends $tea.Model {
  appSecurity?: DescribeAppSecuritiesResponseBodyAppSecuritysAppSecurity[];
  static names(): { [key: string]: string } {
    return {
      appSecurity: 'AppSecurity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appSecurity: { 'type': 'array', 'itemType': DescribeAppSecuritiesResponseBodyAppSecuritysAppSecurity },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAppSecurityRequestTag extends $tea.Model {
  /**
   * @remarks
   * The key of the tag.
   * 
   * This parameter is required.
   * 
   * @example
   * app
   */
  key?: string;
  /**
   * @remarks
   * The value of the tag.
   * 
   * @example
   * 123
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAppsResponseBodyAppsAppItem extends $tea.Model {
  /**
   * @remarks
   * The ID of the app.
   * 
   * @example
   * 20112314518278
   */
  appId?: number;
  /**
   * @remarks
   * The name of the app.
   * 
   * @example
   * CreateApptest
   */
  appName?: string;
  /**
   * @remarks
   * The description of the app.
   * 
   * @example
   * App test
   */
  description?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      appName: 'AppName',
      description: 'Description',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'number',
      appName: 'string',
      description: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAppsResponseBodyApps extends $tea.Model {
  appItem?: DescribeAppsResponseBodyAppsAppItem[];
  static names(): { [key: string]: string } {
    return {
      appItem: 'AppItem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appItem: { 'type': 'array', 'itemType': DescribeAppsResponseBodyAppsAppItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAppsByApiProductResponseBodyAuthorizedAppsAuthorizedApp extends $tea.Model {
  /**
   * @remarks
   * The application ID.
   * 
   * @example
   * 110982419
   */
  appId?: number;
  /**
   * @remarks
   * The application name.
   * 
   * @example
   * APP_02580_DEV
   */
  appName?: string;
  /**
   * @remarks
   * The expiration time of the authorization. The time is in GMT. An empty value indicates that the authorization does not expire.
   * 
   * @example
   * 2023-06-17T03:41:53Z
   */
  authValidTime?: string;
  /**
   * @remarks
   * The time when the authorization was created. The time is in GMT.
   * 
   * @example
   * 2016-07-21T06:17:20Z
   */
  authorizedTime?: string;
  /**
   * @remarks
   * The authorization description.
   */
  description?: string;
  /**
   * @remarks
   * The extended information.
   * 
   * @example
   * extra info
   */
  extend?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      appName: 'AppName',
      authValidTime: 'AuthValidTime',
      authorizedTime: 'AuthorizedTime',
      description: 'Description',
      extend: 'Extend',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'number',
      appName: 'string',
      authValidTime: 'string',
      authorizedTime: 'string',
      description: 'string',
      extend: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAppsByApiProductResponseBodyAuthorizedApps extends $tea.Model {
  authorizedApp?: DescribeAppsByApiProductResponseBodyAuthorizedAppsAuthorizedApp[];
  static names(): { [key: string]: string } {
    return {
      authorizedApp: 'AuthorizedApp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authorizedApp: { 'type': 'array', 'itemType': DescribeAppsByApiProductResponseBodyAuthorizedAppsAuthorizedApp },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAuthorizedApisResponseBodyAuthorizedApisAuthorizedApi extends $tea.Model {
  /**
   * @remarks
   * The unique identifier of the API, which is automatically generated by the system.
   * 
   * @example
   * baacc592e63a4cb6a41920d9d3f91f38
   */
  apiId?: string;
  /**
   * @remarks
   * The name of the API
   * 
   * @example
   * AreaWeather
   */
  apiName?: string;
  /**
   * @remarks
   * The expiration time of the authorization in UTC.
   * 
   * @example
   * 2018-10-05T16:00:00Z
   */
  authVaildTime?: string;
  /**
   * @remarks
   * The authorization source. Valid values:
   * 
   * *   **CONSOLE**
   * *   **API**
   * 
   * @example
   * CONSOLE
   */
  authorizationSource?: string;
  /**
   * @remarks
   * The authorization time in UTC.
   * 
   * @example
   * 2016-07-21T06:17:20
   */
  authorizedTime?: string;
  /**
   * @remarks
   * Authorization description
   * 
   * @example
   * Queries weather based on the region name
   */
  description?: string;
  /**
   * @remarks
   * The ID of the API group. This ID is generated by the system and globally unique.
   * 
   * @example
   * 523e8dc7bbe04613b5b1d726c2a7889d
   */
  groupId?: string;
  /**
   * @remarks
   * The name of the API group.
   * 
   * @example
   * Weather
   */
  groupName?: string;
  /**
   * @remarks
   * The authorizer. Valid values:
   * 
   * *   **PROVIDER:** API owner
   * *   **CONSUMER:** API caller
   * 
   * @example
   * PROVIDER
   */
  operator?: string;
  /**
   * @remarks
   * The region to which the API belongs.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The name of the runtime environment. Valid values:
   * 
   * *   **RELEASE**
   * *   **TEST**: the test environment
   * 
   * @example
   * RELEASE
   */
  stageName?: string;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      apiName: 'ApiName',
      authVaildTime: 'AuthVaildTime',
      authorizationSource: 'AuthorizationSource',
      authorizedTime: 'AuthorizedTime',
      description: 'Description',
      groupId: 'GroupId',
      groupName: 'GroupName',
      operator: 'Operator',
      regionId: 'RegionId',
      stageName: 'StageName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'string',
      apiName: 'string',
      authVaildTime: 'string',
      authorizationSource: 'string',
      authorizedTime: 'string',
      description: 'string',
      groupId: 'string',
      groupName: 'string',
      operator: 'string',
      regionId: 'string',
      stageName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAuthorizedApisResponseBodyAuthorizedApis extends $tea.Model {
  authorizedApi?: DescribeAuthorizedApisResponseBodyAuthorizedApisAuthorizedApi[];
  static names(): { [key: string]: string } {
    return {
      authorizedApi: 'AuthorizedApi',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authorizedApi: { 'type': 'array', 'itemType': DescribeAuthorizedApisResponseBodyAuthorizedApisAuthorizedApi },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAuthorizedAppsResponseBodyAuthorizedAppsAuthorizedAppTagTagInfo extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * DEV
   */
  key?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * 240
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAuthorizedAppsResponseBodyAuthorizedAppsAuthorizedAppTag extends $tea.Model {
  tagInfo?: DescribeAuthorizedAppsResponseBodyAuthorizedAppsAuthorizedAppTagTagInfo[];
  static names(): { [key: string]: string } {
    return {
      tagInfo: 'TagInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagInfo: { 'type': 'array', 'itemType': DescribeAuthorizedAppsResponseBodyAuthorizedAppsAuthorizedAppTagTagInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAuthorizedAppsResponseBodyAuthorizedAppsAuthorizedApp extends $tea.Model {
  /**
   * @remarks
   * The application description.
   * 
   * @example
   * Production application
   */
  appDescription?: string;
  /**
   * @remarks
   * The application ID, which is generated by the system and globally unique.
   * 
   * @example
   * 2386789
   */
  appId?: number;
  /**
   * @remarks
   * The application name.
   * 
   * @example
   * Weather
   */
  appName?: string;
  /**
   * @remarks
   * The application name.
   * 
   * @example
   * 2018-10-05T16:00:00Z
   */
  authVaildTime?: string;
  /**
   * @remarks
   * The authorization source. Valid values:
   * 
   * *   **CONSOLE**
   * *   **API**
   * 
   * @example
   * CONSOLE
   */
  authorizationSource?: string;
  /**
   * @remarks
   * The authorization time (UTC).
   * 
   * @example
   * 2016-07-21T06:17:20Z
   */
  authorizedTime?: string;
  /**
   * @remarks
   * The authorization description.
   * 
   * @example
   * Queries weather based on the region name
   */
  description?: string;
  /**
   * @remarks
   * The authorizer. Valid values:
   * 
   * *   **PROVIDER**: API owner
   * *   **CONSUMER**: API caller
   * 
   * @example
   * PROVIDER
   */
  operator?: string;
  /**
   * @remarks
   * The environment alias.
   * 
   * @example
   * Production
   */
  stageAlias?: string;
  /**
   * @remarks
   * The environment to which the API is published. Valid values:
   * 
   * *   **RELEASE**: the production environment
   * *   **PRE**: the staging environment
   * *   **TEST**: the test environment
   * 
   * @example
   * RELEASE
   */
  stageName?: string;
  /**
   * @remarks
   * The key of the tag.
   */
  tag?: DescribeAuthorizedAppsResponseBodyAuthorizedAppsAuthorizedAppTag;
  static names(): { [key: string]: string } {
    return {
      appDescription: 'AppDescription',
      appId: 'AppId',
      appName: 'AppName',
      authVaildTime: 'AuthVaildTime',
      authorizationSource: 'AuthorizationSource',
      authorizedTime: 'AuthorizedTime',
      description: 'Description',
      operator: 'Operator',
      stageAlias: 'StageAlias',
      stageName: 'StageName',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appDescription: 'string',
      appId: 'number',
      appName: 'string',
      authVaildTime: 'string',
      authorizationSource: 'string',
      authorizedTime: 'string',
      description: 'string',
      operator: 'string',
      stageAlias: 'string',
      stageName: 'string',
      tag: DescribeAuthorizedAppsResponseBodyAuthorizedAppsAuthorizedAppTag,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAuthorizedAppsResponseBodyAuthorizedApps extends $tea.Model {
  authorizedApp?: DescribeAuthorizedAppsResponseBodyAuthorizedAppsAuthorizedApp[];
  static names(): { [key: string]: string } {
    return {
      authorizedApp: 'AuthorizedApp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authorizedApp: { 'type': 'array', 'itemType': DescribeAuthorizedAppsResponseBodyAuthorizedAppsAuthorizedApp },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigDiscoveryConfigNacosConfig extends $tea.Model {
  /**
   * @remarks
   * The AccessKey of the RAM user that has the resource management permissions on Microservices Engine (MSE).
   * 
   * @example
   * A5FIDxxxxxx
   */
  accessKey?: string;
  /**
   * @remarks
   * The authentication method.
   * 
   * @example
   * PASSWORD
   */
  authType?: string;
  /**
   * @remarks
   * The name of the cluster to which the microservice belongs.
   * 
   * @example
   * cluster1
   */
  clusters?: string;
  /**
   * @remarks
   * The name of the group to which the microservice that is registered with Nacos belongs.
   * 
   * @example
   * DEFAULT_GROUP
   */
  groupName?: string;
  /**
   * @remarks
   * The ID of the namespace where the microservice that is registered with Nacos resides.
   * 
   * @example
   * public
   */
  namespace?: string;
  /**
   * @remarks
   * The password.
   * 
   * @example
   * password
   */
  password?: string;
  /**
   * @remarks
   * The SecretKey of the RAM user that has the resource management permissions on MSE.
   * 
   * @example
   * dl5loxxxxxx
   */
  secretKey?: string;
  /**
   * @remarks
   * The Nacos service address.
   * 
   * @example
   * http://1xx.2xx.3xx.4xx:8848
   */
  serverAddress?: string;
  /**
   * @remarks
   * The microservice name.
   * 
   * @example
   * service-provider
   */
  serviceName?: string;
  /**
   * @remarks
   * The username.
   * 
   * @example
   * username
   */
  userName?: string;
  static names(): { [key: string]: string } {
    return {
      accessKey: 'AccessKey',
      authType: 'AuthType',
      clusters: 'Clusters',
      groupName: 'GroupName',
      namespace: 'Namespace',
      password: 'Password',
      secretKey: 'SecretKey',
      serverAddress: 'ServerAddress',
      serviceName: 'ServiceName',
      userName: 'UserName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessKey: 'string',
      authType: 'string',
      clusters: 'string',
      groupName: 'string',
      namespace: 'string',
      password: 'string',
      secretKey: 'string',
      serverAddress: 'string',
      serviceName: 'string',
      userName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigDiscoveryConfigZookeeperConfig extends $tea.Model {
  /**
   * @example
   * http://192.168.1.xxx:2181
   */
  connectString?: string;
  /**
   * @example
   * provider
   */
  namespace?: string;
  /**
   * @example
   * service
   */
  serviceName?: string;
  static names(): { [key: string]: string } {
    return {
      connectString: 'ConnectString',
      namespace: 'Namespace',
      serviceName: 'ServiceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      connectString: 'string',
      namespace: 'string',
      serviceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigDiscoveryConfig extends $tea.Model {
  /**
   * @remarks
   * The Nacos configurations.
   */
  nacosConfig?: DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigDiscoveryConfigNacosConfig;
  /**
   * @remarks
   * The registry type.
   * 
   * @example
   * NACOS
   */
  rcType?: string;
  zookeeperConfig?: DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigDiscoveryConfigZookeeperConfig;
  static names(): { [key: string]: string } {
    return {
      nacosConfig: 'NacosConfig',
      rcType: 'RcType',
      zookeeperConfig: 'ZookeeperConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nacosConfig: DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigDiscoveryConfigNacosConfig,
      rcType: 'string',
      zookeeperConfig: DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigDiscoveryConfigZookeeperConfig,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigEdasConfig extends $tea.Model {
  /**
   * @example
   * 6cd0c599-dxxx-496d-b3d5-6a71c657xxxxx
   */
  edasAppId?: string;
  /**
   * @example
   * cn-hangzhou:edasNacos
   */
  microserviceNamespace?: string;
  /**
   * @example
   * cn-hangzhou:edasNacos
   */
  microserviceNamespaceId?: string;
  /**
   * @example
   * Edas-Nacos
   */
  microserviceNamespaceName?: string;
  /**
   * @example
   * mse-cn-jia3n1rxxxx
   */
  mseInstanceId?: string;
  /**
   * @example
   * EDAS
   */
  registryType?: string;
  /**
   * @example
   * service
   */
  serviceName?: string;
  static names(): { [key: string]: string } {
    return {
      edasAppId: 'EdasAppId',
      microserviceNamespace: 'MicroserviceNamespace',
      microserviceNamespaceId: 'MicroserviceNamespaceId',
      microserviceNamespaceName: 'MicroserviceNamespaceName',
      mseInstanceId: 'MseInstanceId',
      registryType: 'RegistryType',
      serviceName: 'ServiceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      edasAppId: 'string',
      microserviceNamespace: 'string',
      microserviceNamespaceId: 'string',
      microserviceNamespaceName: 'string',
      mseInstanceId: 'string',
      registryType: 'string',
      serviceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigEventBridgeConfig extends $tea.Model {
  /**
   * @remarks
   * The region ID of the event bus in EventBridge.
   * 
   * @example
   * cn-hangzhou
   */
  eventBridgeRegionId?: string;
  /**
   * @remarks
   * The event bus.
   * 
   * @example
   * testBus
   */
  eventBus?: string;
  /**
   * @remarks
   * The event source.
   * 
   * @example
   * dds_driver
   */
  eventSource?: string;
  /**
   * @remarks
   * The ARN of the RAM role to be assumed by API Gateway to access EventBridge.
   * 
   * @example
   * acs:ram::1975133748561***:role/aliyunserviceroleforiotlogexport
   */
  roleArn?: string;
  static names(): { [key: string]: string } {
    return {
      eventBridgeRegionId: 'EventBridgeRegionId',
      eventBus: 'EventBus',
      eventSource: 'EventSource',
      roleArn: 'RoleArn',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventBridgeRegionId: 'string',
      eventBus: 'string',
      eventSource: 'string',
      roleArn: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigFunctionComputeConfig extends $tea.Model {
  /**
   * @remarks
   * The root path of the Function Compute service.
   * 
   * @example
   * https://t*******.ap-*****.fcapp.run/
   */
  fcBaseUrl?: string;
  /**
   * @remarks
   * The region ID of the Function Compute service.
   * 
   * @example
   * cn-hangzhou
   */
  fcRegionId?: string;
  /**
   * @remarks
   * The type of the service in Function Compute.
   * 
   * @example
   * HttpTrigger
   */
  fcType?: string;
  /**
   * @remarks
   * The function name that is defined in Function Compute.
   * 
   * @example
   * edge_function
   */
  functionName?: string;
  /**
   * @remarks
   * Indicates whether the backend service receives only the service path.
   * 
   * @example
   * false
   */
  onlyBusinessPath?: boolean;
  /**
   * @remarks
   * The alias of the function.
   * 
   * @example
   * testQualifier
   */
  qualifier?: string;
  /**
   * @remarks
   * The Alibaba Cloud Resource Name (ARN) of the RAM role that is assumed by API Gateway to access Function Compute.
   * 
   * @example
   * acs:ram::31985*:role/aliyunserviceroleforbastionhostpam
   */
  roleArn?: string;
  /**
   * @remarks
   * The service name that is defined in Function Compute.
   * 
   * @example
   * myservice
   */
  serviceName?: string;
  static names(): { [key: string]: string } {
    return {
      fcBaseUrl: 'FcBaseUrl',
      fcRegionId: 'FcRegionId',
      fcType: 'FcType',
      functionName: 'FunctionName',
      onlyBusinessPath: 'OnlyBusinessPath',
      qualifier: 'Qualifier',
      roleArn: 'RoleArn',
      serviceName: 'ServiceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fcBaseUrl: 'string',
      fcRegionId: 'string',
      fcType: 'string',
      functionName: 'string',
      onlyBusinessPath: 'boolean',
      qualifier: 'string',
      roleArn: 'string',
      serviceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigMockConfigMockHeaders extends $tea.Model {
  /**
   * @remarks
   * The name of the header parameter.
   * 
   * @example
   * test
   */
  headerName?: string;
  /**
   * @remarks
   * The value of the header parameter.
   * 
   * @example
   * 123
   */
  headerValue?: string;
  static names(): { [key: string]: string } {
    return {
      headerName: 'HeaderName',
      headerValue: 'HeaderValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headerName: 'string',
      headerValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigMockConfig extends $tea.Model {
  /**
   * @remarks
   * The header returned for service mocking.
   */
  mockHeaders?: DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigMockConfigMockHeaders[];
  /**
   * @remarks
   * The result returned for service mocking.
   * 
   * @example
   * test
   */
  mockResult?: string;
  /**
   * @remarks
   * The status code that is returned for service mocking.
   * 
   * @example
   * 200
   */
  mockStatusCode?: string;
  static names(): { [key: string]: string } {
    return {
      mockHeaders: 'MockHeaders',
      mockResult: 'MockResult',
      mockStatusCode: 'MockStatusCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      mockHeaders: { 'type': 'array', 'itemType': DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigMockConfigMockHeaders },
      mockResult: 'string',
      mockStatusCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigOssConfig extends $tea.Model {
  /**
   * @remarks
   * The name of the OSS bucket.
   * 
   * @example
   * my_bucket
   */
  bucketName?: string;
  /**
   * @remarks
   * The region ID of the OSS bucket.
   * 
   * @example
   * cn-hangzhou
   */
  ossRegionId?: string;
  static names(): { [key: string]: string } {
    return {
      bucketName: 'BucketName',
      ossRegionId: 'OssRegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bucketName: 'string',
      ossRegionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigVpcConfig extends $tea.Model {
  /**
   * @remarks
   * The ID of the Elastic Compute Service (ECS) or Server Load Balancer (SLB) instance in the VPC.
   * 
   * @example
   * i-uf6iaale3gfef9t9cb41
   */
  instanceId?: string;
  /**
   * @remarks
   * The name of the VPC configuration.
   * 
   * @example
   * dypls-cn-beijing-slb-pre
   */
  name?: string;
  /**
   * @remarks
   * The port number that corresponds to the instance.
   * 
   * @example
   * 8080
   */
  port?: number;
  /**
   * @remarks
   * The ID of the VPC access authorization.
   * 
   * @example
   * 2zej3ehuzg9m77kvwnfpn
   */
  vpcAccessId?: string;
  /**
   * @remarks
   * The ID of the VPC.
   * 
   * @example
   * vpc-wz9v96hqi6d14744sxqmx
   */
  vpcId?: string;
  /**
   * @remarks
   * Indicates whether HTTP or HTTPS is used.
   * 
   * @example
   * http
   */
  vpcScheme?: string;
  /**
   * @remarks
   * The host of the backend service.
   * 
   * @example
   * openapi.alipan.com
   */
  vpcTargetHostName?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      name: 'Name',
      port: 'Port',
      vpcAccessId: 'VpcAccessId',
      vpcId: 'VpcId',
      vpcScheme: 'VpcScheme',
      vpcTargetHostName: 'VpcTargetHostName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      name: 'string',
      port: 'number',
      vpcAccessId: 'string',
      vpcId: 'string',
      vpcScheme: 'string',
      vpcTargetHostName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfig extends $tea.Model {
  /**
   * @remarks
   * The information about the backend service whose type is Service Discovery.
   */
  discoveryConfig?: DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigDiscoveryConfig;
  edasConfig?: DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigEdasConfig;
  /**
   * @remarks
   * The information about the backend service whose type is EventBridge.
   */
  eventBridgeConfig?: DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigEventBridgeConfig;
  /**
   * @remarks
   * The information about the backend service whose type is Function Compute.
   */
  functionComputeConfig?: DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigFunctionComputeConfig;
  /**
   * @remarks
   * The host of the backend service.
   * 
   * @example
   * www.host.com
   */
  httpTargetHostName?: string;
  /**
   * @remarks
   * The information about the backend service whose type is Mock.
   */
  mockConfig?: DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigMockConfig;
  /**
   * @remarks
   * The information about the backend service whose type is Object Storage Service (OSS).
   */
  ossConfig?: DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigOssConfig;
  /**
   * @remarks
   * The URL of the backend service.
   * 
   * @example
   * 10.0.0.1
   */
  serviceAddress?: string;
  /**
   * @example
   * 10000
   */
  serviceTimeout?: number;
  /**
   * @remarks
   * The type of the backend service.
   * 
   * @example
   * VPC
   */
  type?: string;
  /**
   * @remarks
   * The information about the virtual private cloud (VPC). This parameter is available only for backend services whose type is VPC.
   */
  vpcConfig?: DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigVpcConfig;
  static names(): { [key: string]: string } {
    return {
      discoveryConfig: 'DiscoveryConfig',
      edasConfig: 'EdasConfig',
      eventBridgeConfig: 'EventBridgeConfig',
      functionComputeConfig: 'FunctionComputeConfig',
      httpTargetHostName: 'HttpTargetHostName',
      mockConfig: 'MockConfig',
      ossConfig: 'OssConfig',
      serviceAddress: 'ServiceAddress',
      serviceTimeout: 'ServiceTimeout',
      type: 'Type',
      vpcConfig: 'VpcConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      discoveryConfig: DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigDiscoveryConfig,
      edasConfig: DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigEdasConfig,
      eventBridgeConfig: DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigEventBridgeConfig,
      functionComputeConfig: DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigFunctionComputeConfig,
      httpTargetHostName: 'string',
      mockConfig: DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigMockConfig,
      ossConfig: DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigOssConfig,
      serviceAddress: 'string',
      serviceTimeout: 'number',
      type: 'string',
      vpcConfig: DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigVpcConfig,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackendInfoResponseBodyBackendInfoBackendModels extends $tea.Model {
  /**
   * @remarks
   * The backend service configurations.
   */
  backendConfig?: DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfig;
  /**
   * @remarks
   * The ID of the backend service in the environment.
   * 
   * @example
   * 5c4995d08e8b4954b0f326e8e4f2b97d
   */
  backendModelId?: string;
  /**
   * @remarks
   * The description of the backend service.
   * 
   * @example
   * testDvs 1
   */
  description?: string;
  /**
   * @remarks
   * The time when the backend service was created.
   * 
   * @example
   * 2021-12-20T03:22:03.000+0000
   */
  gmtCreate?: string;
  /**
   * @remarks
   * The time when the backend service was modified.
   * 
   * @example
   * 2021-12-20T03:22:03.000+0000
   */
  gmtModified?: string;
  /**
   * @remarks
   * The ID of the environment.
   * 
   * @example
   * 6fc978bb63574146b766863dd7bdf661
   */
  stageModeId?: string;
  /**
   * @remarks
   * The environment name.
   * 
   * @example
   * RELEASE
   */
  stageName?: string;
  static names(): { [key: string]: string } {
    return {
      backendConfig: 'BackendConfig',
      backendModelId: 'BackendModelId',
      description: 'Description',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      stageModeId: 'StageModeId',
      stageName: 'StageName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      backendConfig: DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfig,
      backendModelId: 'string',
      description: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      stageModeId: 'string',
      stageName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackendInfoResponseBodyBackendInfo extends $tea.Model {
  /**
   * @remarks
   * The ID of the backend service.
   * 
   * @example
   * 6fc978bb63574146b766863dd7bdf661
   */
  backendId?: string;
  /**
   * @remarks
   * The configurations of the backend service in the environment.
   */
  backendModels?: DescribeBackendInfoResponseBodyBackendInfoBackendModels[];
  /**
   * @remarks
   * The name of the backend service.
   * 
   * @example
   * testoss2
   */
  backendName?: string;
  /**
   * @remarks
   * The type of the backend service.
   * 
   * @example
   * HTTP
   */
  backendType?: string;
  /**
   * @remarks
   * The time when the backend service was created.
   * 
   * @example
   * 2021-11-22T11:10:46+08:00
   */
  createdTime?: string;
  /**
   * @remarks
   * The description of the backend service.
   * 
   * @example
   * add
   */
  description?: string;
  /**
   * @remarks
   * The time when the backend service was modified.
   * 
   * @example
   * 2017-12-11T15:18:09+08:00
   */
  modifiedTime?: string;
  static names(): { [key: string]: string } {
    return {
      backendId: 'BackendId',
      backendModels: 'BackendModels',
      backendName: 'BackendName',
      backendType: 'BackendType',
      createdTime: 'CreatedTime',
      description: 'Description',
      modifiedTime: 'ModifiedTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      backendId: 'string',
      backendModels: { 'type': 'array', 'itemType': DescribeBackendInfoResponseBodyBackendInfoBackendModels },
      backendName: 'string',
      backendType: 'string',
      createdTime: 'string',
      description: 'string',
      modifiedTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackendListRequestTag extends $tea.Model {
  /**
   * @remarks
   * The key of the tag.
   * 
   * @example
   * test1
   */
  key?: string;
  /**
   * @remarks
   * The value of the tag.
   * 
   * @example
   * value
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackendListResponseBodyBackendInfoListTags extends $tea.Model {
  /**
   * @remarks
   * The name of the tag.
   * 
   * @example
   * groupName
   */
  key?: string;
  /**
   * @remarks
   * The value of the tag.
   * 
   * @example
   * e3b881d0-e2d0-4dfb-b1fb-a2a3d1e534b7
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackendListResponseBodyBackendInfoList extends $tea.Model {
  /**
   * @remarks
   * The ID of the backend service.
   * 
   * @example
   * 35bd31d32c9c425ebbe9330db9f8c375
   */
  backendId?: string;
  /**
   * @remarks
   * The name of the backend service.
   * 
   * @example
   * test
   */
  backendName?: string;
  /**
   * @remarks
   * The type of the backend service.
   * 
   * @example
   * HTTP
   */
  backendType?: string;
  /**
   * @remarks
   * The time when the backend service was created.
   * 
   * @example
   * 2022-01-25T11:22:29Z
   */
  createdTime?: string;
  /**
   * @remarks
   * The description of the backend service.
   * 
   * @example
   * test
   */
  description?: string;
  /**
   * @remarks
   * The time when the backend service was modified.
   * 
   * @example
   * 2022-01-25T11:22:29Z
   */
  modifiedTime?: string;
  /**
   * @remarks
   * The list of tags.
   */
  tags?: DescribeBackendListResponseBodyBackendInfoListTags[];
  static names(): { [key: string]: string } {
    return {
      backendId: 'BackendId',
      backendName: 'BackendName',
      backendType: 'BackendType',
      createdTime: 'CreatedTime',
      description: 'Description',
      modifiedTime: 'ModifiedTime',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      backendId: 'string',
      backendName: 'string',
      backendType: 'string',
      createdTime: 'string',
      description: 'string',
      modifiedTime: 'string',
      tags: { 'type': 'array', 'itemType': DescribeBackendListResponseBodyBackendInfoListTags },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDatasetInfoResponseBodyDatasetInfo extends $tea.Model {
  /**
   * @remarks
   * The creation time (UTC) of the dataset.
   * 
   * @example
   * 2022-09-21T12:58:43Z
   */
  createdTime?: string;
  /**
   * @remarks
   * The ID of the dataset.
   * 
   * @example
   * 62b91a790a693238********
   */
  datasetId?: string;
  /**
   * @remarks
   * The name of the dataset.
   * 
   * @example
   * DatasetName
   */
  datasetName?: string;
  /**
   * @remarks
   * The type of the dataset. Valid values:
   * 
   * *   JWT_BLOCKING: a JSON Web Token (JWT) blacklist
   * *   IP_WHITELIST_CIDR : an IP address whitelist
   * *   PARAMETER_ACCESS : parameter-based access control
   * 
   * @example
   * JWT_BLOCKING
   */
  datasetType?: string;
  /**
   * @remarks
   * The last modification time (UTC) of the dataset.
   * 
   * @example
   * 2022-09-21T12:58:43Z
   */
  modifiedTime?: string;
  static names(): { [key: string]: string } {
    return {
      createdTime: 'CreatedTime',
      datasetId: 'DatasetId',
      datasetName: 'DatasetName',
      datasetType: 'DatasetType',
      modifiedTime: 'ModifiedTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createdTime: 'string',
      datasetId: 'string',
      datasetName: 'string',
      datasetType: 'string',
      modifiedTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDatasetItemInfoResponseBodyDatasetItemInfo extends $tea.Model {
  /**
   * @remarks
   * The creation time (UTC) of the data entry.
   * 
   * @example
   * 2022-09-21T12:58:43Z
   */
  createdTime?: string;
  /**
   * @remarks
   * The ID of the dataset.
   * 
   * @example
   * 626238665db4a5140eea3e40********
   */
  datasetId?: string;
  /**
   * @remarks
   * The ID of the data entry.
   * 
   * @example
   * 5045****
   */
  datasetItemId?: string;
  /**
   * @remarks
   * The description of the data entry.
   * 
   * @example
   * Description
   */
  description?: string;
  /**
   * @remarks
   * The time in UTC when the data entry expires. The time is in the **yyyy-MM-ddTHH:mm:ssZ** format. If this parameter is empty, the data entry does not expire.
   * 
   * @example
   * 2022-09-22T12:00:00Z
   */
  expiredTime?: string;
  /**
   * @remarks
   * The last modification time (UTC) of the data entry.
   * 
   * @example
   * 2022-09-21T12:58:43Z
   */
  modifiedTime?: string;
  /**
   * @remarks
   * The value of the data entry.
   * 
   * @example
   * 106.43.XXX.XXX
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      createdTime: 'CreatedTime',
      datasetId: 'DatasetId',
      datasetItemId: 'DatasetItemId',
      description: 'Description',
      expiredTime: 'ExpiredTime',
      modifiedTime: 'ModifiedTime',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createdTime: 'string',
      datasetId: 'string',
      datasetItemId: 'string',
      description: 'string',
      expiredTime: 'string',
      modifiedTime: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDatasetItemListResponseBodyDatasetItemInfoList extends $tea.Model {
  /**
   * @remarks
   * The time when the data entry was created.
   * 
   * @example
   * 2022-09-21T12:58:43Z
   */
  createdTime?: string;
  /**
   * @remarks
   * The ID of the dataset.
   * 
   * @example
   * 4add6a61804e47858266883e********
   */
  datasetId?: string;
  /**
   * @remarks
   * The ID of the data entry.
   * 
   * @example
   * 5045****
   */
  datasetItemId?: string;
  /**
   * @remarks
   * The description of the data entry.
   * 
   * @example
   * Description
   */
  description?: string;
  /**
   * @remarks
   * The time in UTC when the data entry expires. The time is in the **yyyy-MM-ddTHH:mm:ssZ** format. If this parameter is empty, the data entry does not expire.
   * 
   * @example
   * 2022-09-22T12:00:00Z
   */
  expiredTime?: string;
  /**
   * @remarks
   * The last modification time (UTC) of the data entry.
   * 
   * @example
   * 2022-09-21T12:58:43Z
   */
  modifiedTime?: string;
  /**
   * @remarks
   * The value of the data entry.
   * 
   * @example
   * 106.43.XXX.XXX
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      createdTime: 'CreatedTime',
      datasetId: 'DatasetId',
      datasetItemId: 'DatasetItemId',
      description: 'Description',
      expiredTime: 'ExpiredTime',
      modifiedTime: 'ModifiedTime',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createdTime: 'string',
      datasetId: 'string',
      datasetItemId: 'string',
      description: 'string',
      expiredTime: 'string',
      modifiedTime: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDatasetListRequestTag extends $tea.Model {
  /**
   * @remarks
   * 标签键
   * 
   * @example
   * env
   */
  key?: string;
  /**
   * @remarks
   * 标签值
   * 
   * @example
   * value
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDatasetListResponseBodyDatasetInfoListTags extends $tea.Model {
  /**
   * @remarks
   * 标签的键
   * 
   * @example
   * ENV
   */
  key?: string;
  /**
   * @remarks
   * 标签值
   * 
   * @example
   * 123
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDatasetListResponseBodyDatasetInfoList extends $tea.Model {
  /**
   * @remarks
   * The time when the dataset was created. The time is displayed in UTC.
   * 
   * @example
   * 2022-09-21T12:58:43Z
   */
  createdTime?: string;
  /**
   * @remarks
   * The dataset ID.
   * 
   * @example
   * 6304ce6b4ae6453f********
   */
  datasetId?: string;
  /**
   * @remarks
   * The dataset name.
   * 
   * @example
   * DatasetName
   */
  datasetName?: string;
  /**
   * @remarks
   * The dataset type. Valid values:
   * 
   * *   JWT_BLOCKING : a JSON Web Token (JWT) blacklist
   * *   IP_WHITELIST_CIDR : an IP address whitelist
   * *   PARAMETER_ACCESS: a list of parameters for parameter-based access control
   * 
   * @example
   * IP_WHITELIST_CIDR
   */
  datasetType?: string;
  /**
   * @remarks
   * The time when the dataset was last modified. The time is displayed in UTC.
   * 
   * @example
   * 2022-09-21T12:58:43Z
   */
  modifiedTime?: string;
  /**
   * @remarks
   * 标签
   */
  tags?: DescribeDatasetListResponseBodyDatasetInfoListTags[];
  static names(): { [key: string]: string } {
    return {
      createdTime: 'CreatedTime',
      datasetId: 'DatasetId',
      datasetName: 'DatasetName',
      datasetType: 'DatasetType',
      modifiedTime: 'ModifiedTime',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createdTime: 'string',
      datasetId: 'string',
      datasetName: 'string',
      datasetType: 'string',
      modifiedTime: 'string',
      tags: { 'type': 'array', 'itemType': DescribeDatasetListResponseBodyDatasetInfoListTags },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDeployApiTaskResponseBodyDeployedResultsDeployedResult extends $tea.Model {
  /**
   * @remarks
   * The ID of the API.
   * 
   * @example
   * 0433c1cd84724923b7a4f9ca1cfc249c
   */
  apiUid?: string;
  /**
   * @remarks
   * The deployment status of the API.
   * 
   * @example
   * OVER
   */
  deployedStatus?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * Success. Request Success.
   */
  errorMsg?: string;
  /**
   * @remarks
   * The ID of the API group.
   * 
   * @example
   * e8da6f6346184da9a30d0dc1888b1f3b
   */
  groupId?: string;
  /**
   * @remarks
   * The runtime environment of the API. Valid values:
   * 
   * *   **RELEASE**
   * *   **TEST**
   * 
   * @example
   * RELEASE
   */
  stageName?: string;
  static names(): { [key: string]: string } {
    return {
      apiUid: 'ApiUid',
      deployedStatus: 'DeployedStatus',
      errorMsg: 'ErrorMsg',
      groupId: 'GroupId',
      stageName: 'StageName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiUid: 'string',
      deployedStatus: 'string',
      errorMsg: 'string',
      groupId: 'string',
      stageName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDeployApiTaskResponseBodyDeployedResults extends $tea.Model {
  deployedResult?: DescribeDeployApiTaskResponseBodyDeployedResultsDeployedResult[];
  static names(): { [key: string]: string } {
    return {
      deployedResult: 'DeployedResult',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deployedResult: { 'type': 'array', 'itemType': DescribeDeployApiTaskResponseBodyDeployedResultsDeployedResult },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDeployedApiResponseBodyConstantParametersConstantParameter extends $tea.Model {
  /**
   * @remarks
   * The constant value.
   * 
   * @example
   * constance
   */
  constantValue?: string;
  /**
   * @remarks
   * The description.
   * 
   * @example
   * 123
   */
  description?: string;
  /**
   * @remarks
   * The parameter location. Valid values: BODY, HEAD, QUERY, and PATH.
   * 
   * @example
   * HEAD
   */
  location?: string;
  /**
   * @remarks
   * The name of the backend service parameter.
   * 
   * @example
   * constance
   */
  serviceParameterName?: string;
  static names(): { [key: string]: string } {
    return {
      constantValue: 'ConstantValue',
      description: 'Description',
      location: 'Location',
      serviceParameterName: 'ServiceParameterName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      constantValue: 'string',
      description: 'string',
      location: 'string',
      serviceParameterName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDeployedApiResponseBodyConstantParameters extends $tea.Model {
  constantParameter?: DescribeDeployedApiResponseBodyConstantParametersConstantParameter[];
  static names(): { [key: string]: string } {
    return {
      constantParameter: 'ConstantParameter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      constantParameter: { 'type': 'array', 'itemType': DescribeDeployedApiResponseBodyConstantParametersConstantParameter },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDeployedApiResponseBodyCustomSystemParametersCustomSystemParameter extends $tea.Model {
  /**
   * @remarks
   * Example
   * 
   * @example
   * 192.168.1.1
   */
  demoValue?: string;
  /**
   * @remarks
   * The description.
   * 
   * @example
   * 123
   */
  description?: string;
  /**
   * @remarks
   * The parameter location. Valid values: BODY, HEAD, QUERY, and PATH.
   * 
   * @example
   * HEAD
   */
  location?: string;
  /**
   * @remarks
   * The name of the custom system parameter.
   * 
   * @example
   * appid
   */
  parameterName?: string;
  /**
   * @remarks
   * The name of the corresponding backend parameter.
   * 
   * @example
   * clientIp
   */
  serviceParameterName?: string;
  static names(): { [key: string]: string } {
    return {
      demoValue: 'DemoValue',
      description: 'Description',
      location: 'Location',
      parameterName: 'ParameterName',
      serviceParameterName: 'ServiceParameterName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      demoValue: 'string',
      description: 'string',
      location: 'string',
      parameterName: 'string',
      serviceParameterName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDeployedApiResponseBodyCustomSystemParameters extends $tea.Model {
  customSystemParameter?: DescribeDeployedApiResponseBodyCustomSystemParametersCustomSystemParameter[];
  static names(): { [key: string]: string } {
    return {
      customSystemParameter: 'CustomSystemParameter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      customSystemParameter: { 'type': 'array', 'itemType': DescribeDeployedApiResponseBodyCustomSystemParametersCustomSystemParameter },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDeployedApiResponseBodyErrorCodeSamplesErrorCodeSample extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * Error
   */
  code?: string;
  /**
   * @remarks
   * The description.
   * 
   * @example
   * Description
   */
  description?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * error message
   */
  message?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      description: 'Description',
      message: 'Message',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      description: 'string',
      message: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDeployedApiResponseBodyErrorCodeSamples extends $tea.Model {
  errorCodeSample?: DescribeDeployedApiResponseBodyErrorCodeSamplesErrorCodeSample[];
  static names(): { [key: string]: string } {
    return {
      errorCodeSample: 'ErrorCodeSample',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCodeSample: { 'type': 'array', 'itemType': DescribeDeployedApiResponseBodyErrorCodeSamplesErrorCodeSample },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDeployedApiResponseBodyOpenIdConnectConfig extends $tea.Model {
  /**
   * @remarks
   * The name of the parameter that corresponds to the token.
   * 
   * @example
   * xxx
   */
  idTokenParamName?: string;
  /**
   * @remarks
   * The configuration of OpenID Connect authentication. Valid values:
   * 
   * *   **IDTOKEN: indicates the APIs that are called by clients to obtain tokens. If you specify this value, the PublicKeyId parameter and the PublicKey parameter are required.**
   * *   **BUSINESS: indicates business APIs. Tokens are used to call the business APIs. If you specify this value, the IdTokenParamName parameter is required.
   * 
   * @example
   * IDTOKEN
   */
  openIdApiType?: string;
  /**
   * @remarks
   * The public key of the API.
   * 
   * @example
   * EB1837F8693CCED0BF750B3AD48467BEB569E780A14591CF92
   */
  publicKey?: string;
  /**
   * @remarks
   * The ID of the public key.
   * 
   * @example
   * 88483727556929326703309904351185815489
   */
  publicKeyId?: string;
  static names(): { [key: string]: string } {
    return {
      idTokenParamName: 'IdTokenParamName',
      openIdApiType: 'OpenIdApiType',
      publicKey: 'PublicKey',
      publicKeyId: 'PublicKeyId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      idTokenParamName: 'string',
      openIdApiType: 'string',
      publicKey: 'string',
      publicKeyId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDeployedApiResponseBodyRequestConfig extends $tea.Model {
  /**
   * @remarks
   * This parameter takes effect only when the RequestMode parameter is set to MAPPING.
   * 
   * The server data transmission method used for POST and PUT requests. Valid values: FORM and STREAM. FORM indicates that data in key-value pairs is transmitted as forms. STREAM indicates that data is transmitted as byte streams.
   * 
   * @example
   * STREAM
   */
  bodyFormat?: string;
  /**
   * @remarks
   * The body model.
   * 
   * @example
   * https://apigateway.aliyun.com/models/3a240a127dccXXXXXXXX947b4095/9e2df550e85b4121a79XXXXXxaab
   */
  bodyModel?: string;
  /**
   * @remarks
   * The description of the request body.
   * 
   * @example
   * fwefwef
   */
  postBodyDescription?: string;
  /**
   * @remarks
   * The HTTP method used to make the request. Valid values: GET, POST, DELETE, PUT, HEADER, TRACE, PATCH, CONNECT, and OPTIONS.
   * 
   * @example
   * POST
   */
  requestHttpMethod?: string;
  /**
   * @remarks
   * The request mode. Valid values:
   * 
   * *   MAPPING: Parameters are mapped. Unknown parameters are filtered out.
   * *   PASSTHROUGH: Parameters are passed through.
   * *   MAPPING_PASSTHROUGH: Parameters are mapped. Unknown parameters are passed through.
   * 
   * @example
   * MAPPING
   */
  requestMode?: string;
  /**
   * @remarks
   * The API request path. If the complete API URL is `http://api.a.com:8080/object/add?key1=value1&key2=value2`, the API request path is ` /object/add  `.
   * 
   * @example
   * /api/billing/test/[type]
   */
  requestPath?: string;
  /**
   * @remarks
   * The protocol type supported by the API. Valid values: HTTP, HTTPS, and WebSocket. Separate multiple values with commas (,), such as "HTTP,HTTPS".
   * 
   * @example
   * HTTP
   */
  requestProtocol?: string;
  static names(): { [key: string]: string } {
    return {
      bodyFormat: 'BodyFormat',
      bodyModel: 'BodyModel',
      postBodyDescription: 'PostBodyDescription',
      requestHttpMethod: 'RequestHttpMethod',
      requestMode: 'RequestMode',
      requestPath: 'RequestPath',
      requestProtocol: 'RequestProtocol',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bodyFormat: 'string',
      bodyModel: 'string',
      postBodyDescription: 'string',
      requestHttpMethod: 'string',
      requestMode: 'string',
      requestPath: 'string',
      requestProtocol: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDeployedApiResponseBodyRequestParametersRequestParameter extends $tea.Model {
  /**
   * @remarks
   * The name of the API parameter.
   * 
   * @example
   * age
   */
  apiParameterName?: string;
  /**
   * @remarks
   * The type of the array element.
   * 
   * @example
   * String
   */
  arrayItemsType?: string;
  /**
   * @remarks
   * The default value.
   * 
   * @example
   * 20
   */
  defaultValue?: string;
  /**
   * @remarks
   * Example
   * 
   * @example
   * 20
   */
  demoValue?: string;
  /**
   * @remarks
   * Description
   * 
   * @example
   * parameter description
   */
  description?: string;
  /**
   * @remarks
   * The order in the document.
   * 
   * @example
   * 0
   */
  docOrder?: number;
  /**
   * @remarks
   * Specifies whether the document is public. Valid values: PUBLIC and PRIVATE.
   * 
   * @example
   * PUBLIC
   */
  docShow?: string;
  /**
   * @remarks
   * The hash values that can be entered when ParameterType is set to Int, Long, Float, Double, or String. Separate different values with commas (,), such as 1,2,3,4,9 or A,B,C,E,F.
   * 
   * @example
   * boy,girl
   */
  enumValue?: string;
  /**
   * @remarks
   * JSON scheme
   * 
   * @example
   * {}
   */
  jsonScheme?: string;
  /**
   * @remarks
   * The parameter location. Valid values: BODY, HEAD, QUERY, and PATH.
   * 
   * @example
   * HEAD
   */
  location?: string;
  /**
   * @remarks
   * The maximum parameter length when ParameterType is set to String.
   * 
   * @example
   * 123456
   */
  maxLength?: number;
  /**
   * @remarks
   * The maximum parameter value when ParameterType is set to Int, Long, Float, or Double.
   * 
   * @example
   * 123456
   */
  maxValue?: number;
  /**
   * @remarks
   * The minimum parameter length when ParameterType is set to String.
   * 
   * @example
   * 123456
   */
  minLength?: number;
  /**
   * @remarks
   * The minimum parameter value when ParameterType is set to Int, Long, Float, or Double.
   * 
   * @example
   * 123456
   */
  minValue?: number;
  /**
   * @remarks
   * The type of a request parameter. Valid values: String, Int, Long, Float, Double, and Boolean.
   * 
   * @example
   * String
   */
  parameterType?: string;
  /**
   * @remarks
   * The regular expression used for parameter validation when ParameterType is set to String.
   * 
   * @example
   * xxx
   */
  regularExpression?: string;
  /**
   * @remarks
   * Indicates whether the parameter is required. Valid values: REQUIRED and OPTIONAL.
   * 
   * @example
   * OPTIONAL
   */
  required?: string;
  static names(): { [key: string]: string } {
    return {
      apiParameterName: 'ApiParameterName',
      arrayItemsType: 'ArrayItemsType',
      defaultValue: 'DefaultValue',
      demoValue: 'DemoValue',
      description: 'Description',
      docOrder: 'DocOrder',
      docShow: 'DocShow',
      enumValue: 'EnumValue',
      jsonScheme: 'JsonScheme',
      location: 'Location',
      maxLength: 'MaxLength',
      maxValue: 'MaxValue',
      minLength: 'MinLength',
      minValue: 'MinValue',
      parameterType: 'ParameterType',
      regularExpression: 'RegularExpression',
      required: 'Required',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiParameterName: 'string',
      arrayItemsType: 'string',
      defaultValue: 'string',
      demoValue: 'string',
      description: 'string',
      docOrder: 'number',
      docShow: 'string',
      enumValue: 'string',
      jsonScheme: 'string',
      location: 'string',
      maxLength: 'number',
      maxValue: 'number',
      minLength: 'number',
      minValue: 'number',
      parameterType: 'string',
      regularExpression: 'string',
      required: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDeployedApiResponseBodyRequestParameters extends $tea.Model {
  requestParameter?: DescribeDeployedApiResponseBodyRequestParametersRequestParameter[];
  static names(): { [key: string]: string } {
    return {
      requestParameter: 'RequestParameter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestParameter: { 'type': 'array', 'itemType': DescribeDeployedApiResponseBodyRequestParametersRequestParameter },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDeployedApiResponseBodyResultDescriptionsResultDescription extends $tea.Model {
  /**
   * @remarks
   * The description.
   * 
   * @example
   * result description
   */
  description?: string;
  /**
   * @remarks
   * Specifies whether a subnode exists.
   * 
   * @example
   * false
   */
  hasChild?: boolean;
  /**
   * @remarks
   * The ID of the result.
   * 
   * @example
   * id
   */
  id?: string;
  /**
   * @remarks
   * The primary key of the result.
   * 
   * @example
   * DEMO
   */
  key?: string;
  /**
   * @remarks
   * Specifies whether the parameter is required.
   * 
   * @example
   * true
   */
  mandatory?: boolean;
  /**
   * @remarks
   * The name of the result.
   * 
   * @example
   * fwqf
   */
  name?: string;
  /**
   * @remarks
   * The ID of the parent node.
   * 
   * @example
   * pid
   */
  pid?: string;
  /**
   * @remarks
   * The type of the result.
   * 
   * @example
   * String
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      hasChild: 'HasChild',
      id: 'Id',
      key: 'Key',
      mandatory: 'Mandatory',
      name: 'Name',
      pid: 'Pid',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      hasChild: 'boolean',
      id: 'string',
      key: 'string',
      mandatory: 'boolean',
      name: 'string',
      pid: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDeployedApiResponseBodyResultDescriptions extends $tea.Model {
  resultDescription?: DescribeDeployedApiResponseBodyResultDescriptionsResultDescription[];
  static names(): { [key: string]: string } {
    return {
      resultDescription: 'ResultDescription',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resultDescription: { 'type': 'array', 'itemType': DescribeDeployedApiResponseBodyResultDescriptionsResultDescription },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDeployedApiResponseBodyServiceConfigFunctionComputeConfig extends $tea.Model {
  /**
   * @remarks
   * The ContentType header type used when you call the backend service over HTTP.
   * 
   * *   **DEFAULT: the default header type in API Gateway.**
   * *   **CUSTOM: a custom header type.**
   * *   **CLIENT: the ContentType header type of the client.
   * 
   * @example
   * DEFAULT
   */
  contentTypeCatagory?: string;
  /**
   * @remarks
   * The value of the ContentType header when the ServiceProtocol parameter is set to HTTP and the ContentTypeCatagory parameter is set to DEFAULT or CUSTOM.
   * 
   * @example
   * application/x-www-form-urlencoded; charset=UTF-8
   */
  contentTypeValue?: string;
  /**
   * @remarks
   * The root path of Function Compute.
   * 
   * @example
   * https://122xxxxxxx.fc.aliyun.com/2016xxxx/proxy/testSxxx.xxx/testHttp/
   */
  fcBaseUrl?: string;
  /**
   * @remarks
   * The type of the Function Compute instance.
   * 
   * @example
   * HttpTrigger
   */
  fcType?: string;
  /**
   * @remarks
   * The function name defined in Function Compute.
   * 
   * @example
   * domain_business_control
   */
  functionName?: string;
  /**
   * @remarks
   * The request method.
   * 
   * @example
   * GET
   */
  method?: string;
  /**
   * @remarks
   * The backend only receives the service path.
   * 
   * @example
   * false
   */
  onlyBusinessPath?: boolean;
  /**
   * @remarks
   * The API request path.
   * 
   * @example
   * /api/offline/cacheData
   */
  path?: string;
  /**
   * @remarks
   * The alias of the function.
   * 
   * @example
   * 2
   */
  qualifier?: string;
  /**
   * @remarks
   * The region where the API is located.
   * 
   * @example
   * cn-beijing
   */
  regionId?: string;
  /**
   * @remarks
   * The Alibaba Cloud Resource Name (ARN) of the RAM role to be assumed by API Gateway to access Function Compute.
   * 
   * @example
   * acs:ram::111***:role/aliyunserviceroleforsas
   */
  roleArn?: string;
  /**
   * @remarks
   * The service name defined in Function Compute.
   * 
   * @example
   * fcservicename
   */
  serviceName?: string;
  static names(): { [key: string]: string } {
    return {
      contentTypeCatagory: 'ContentTypeCatagory',
      contentTypeValue: 'ContentTypeValue',
      fcBaseUrl: 'FcBaseUrl',
      fcType: 'FcType',
      functionName: 'FunctionName',
      method: 'Method',
      onlyBusinessPath: 'OnlyBusinessPath',
      path: 'Path',
      qualifier: 'Qualifier',
      regionId: 'RegionId',
      roleArn: 'RoleArn',
      serviceName: 'ServiceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contentTypeCatagory: 'string',
      contentTypeValue: 'string',
      fcBaseUrl: 'string',
      fcType: 'string',
      functionName: 'string',
      method: 'string',
      onlyBusinessPath: 'boolean',
      path: 'string',
      qualifier: 'string',
      regionId: 'string',
      roleArn: 'string',
      serviceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDeployedApiResponseBodyServiceConfigMockHeadersMockHeader extends $tea.Model {
  /**
   * @remarks
   * The name of the HTTP header parameter.
   * 
   * @example
   * Content-Type
   */
  headerName?: string;
  /**
   * @remarks
   * The value of the HTTP header parameter.
   * 
   * @example
   * 86400
   */
  headerValue?: string;
  static names(): { [key: string]: string } {
    return {
      headerName: 'HeaderName',
      headerValue: 'HeaderValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headerName: 'string',
      headerValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDeployedApiResponseBodyServiceConfigMockHeaders extends $tea.Model {
  mockHeader?: DescribeDeployedApiResponseBodyServiceConfigMockHeadersMockHeader[];
  static names(): { [key: string]: string } {
    return {
      mockHeader: 'MockHeader',
    };
  }

  static types(): { [key: string]: any } {
    return {
      mockHeader: { 'type': 'array', 'itemType': DescribeDeployedApiResponseBodyServiceConfigMockHeadersMockHeader },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDeployedApiResponseBodyServiceConfigVpcConfig extends $tea.Model {
  /**
   * @remarks
   * The IDs of the ELB and SLB instances in the VPC.
   * 
   * @example
   * i-bp1h497hkijewv2***
   */
  instanceId?: string;
  /**
   * @remarks
   * The name of the VPC access authorization.
   * 
   * @example
   * glmall-app-test
   */
  name?: string;
  /**
   * @remarks
   * The port number that corresponds to the instance.
   * 
   * @example
   * 8080
   */
  port?: number;
  /**
   * @remarks
   * The ID of the VPC.
   * 
   * @example
   * vpc-2zeafsc3fygk1***
   */
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      name: 'Name',
      port: 'Port',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      name: 'string',
      port: 'number',
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDeployedApiResponseBodyServiceConfig extends $tea.Model {
  /**
   * @remarks
   * Backend configuration items when the backend service is Function Compute
   */
  functionComputeConfig?: DescribeDeployedApiResponseBodyServiceConfigFunctionComputeConfig;
  /**
   * @remarks
   * Specifies whether to enable the Mock mode. Valid values:
   * 
   * *   **TRUE: The Mock mode is enabled.**
   * *   **FALSE: The Mock mode is not enabled.
   * 
   * @example
   * TRUE
   */
  mock?: string;
  /**
   * @remarks
   * The simulated Headers.
   */
  mockHeaders?: DescribeDeployedApiResponseBodyServiceConfigMockHeaders;
  /**
   * @remarks
   * The result returned when the Mock mode is enabled.
   * 
   * @example
   * test result
   */
  mockResult?: string;
  /**
   * @remarks
   * The status code returned for service mocking.
   * 
   * @example
   * 200
   */
  mockStatusCode?: number;
  /**
   * @remarks
   * The URL used to call the back-end service. If the complete back-end service URL is `http://api.a.com:8080/object/add?key1=value1&key2=value2`, the value of ServiceAddress is **http://api.a.com:8080**.``
   * 
   * @example
   * http://api.a.com:8080
   */
  serviceAddress?: string;
  /**
   * @remarks
   * The HTTP method used to call a backend service. Valid values: GET, POST, DELETE, PUT, HEADER, TRACE, PATCH, CONNECT, and OPTIONS.
   * 
   * @example
   * POST
   */
  serviceHttpMethod?: string;
  /**
   * @example
   * /object/add
   */
  servicePath?: string;
  /**
   * @remarks
   * The backend service protocol. Currently, only HTTP, HTTPS, and FunctionCompute are supported.
   * 
   * @example
   * HTTP
   */
  serviceProtocol?: string;
  /**
   * @remarks
   * The timeout period of the backend service, in millisecond.
   * 
   * @example
   * 1000
   */
  serviceTimeout?: number;
  /**
   * @remarks
   * Specifies whether to enable the VPC channel. Valid values:
   * 
   * *   **TRUE**: The VPC channel is enabled. You must create the corresponding VPC access authorization before you can enable a VPC channel.
   * *   **FALSE**: The VPC channel is not enabled.
   * 
   * @example
   * TRUE
   */
  serviceVpcEnable?: string;
  /**
   * @remarks
   * Configuration items related to VPC channels
   */
  vpcConfig?: DescribeDeployedApiResponseBodyServiceConfigVpcConfig;
  /**
   * @remarks
   * The ID of the VPC.
   * 
   * @example
   * vpc-uf6kg9x8sx2tbxxxx
   */
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      functionComputeConfig: 'FunctionComputeConfig',
      mock: 'Mock',
      mockHeaders: 'MockHeaders',
      mockResult: 'MockResult',
      mockStatusCode: 'MockStatusCode',
      serviceAddress: 'ServiceAddress',
      serviceHttpMethod: 'ServiceHttpMethod',
      servicePath: 'ServicePath',
      serviceProtocol: 'ServiceProtocol',
      serviceTimeout: 'ServiceTimeout',
      serviceVpcEnable: 'ServiceVpcEnable',
      vpcConfig: 'VpcConfig',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      functionComputeConfig: DescribeDeployedApiResponseBodyServiceConfigFunctionComputeConfig,
      mock: 'string',
      mockHeaders: DescribeDeployedApiResponseBodyServiceConfigMockHeaders,
      mockResult: 'string',
      mockStatusCode: 'number',
      serviceAddress: 'string',
      serviceHttpMethod: 'string',
      servicePath: 'string',
      serviceProtocol: 'string',
      serviceTimeout: 'number',
      serviceVpcEnable: 'string',
      vpcConfig: DescribeDeployedApiResponseBodyServiceConfigVpcConfig,
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDeployedApiResponseBodyServiceParametersServiceParameter extends $tea.Model {
  /**
   * @remarks
   * The parameter location. Valid values: BODY, HEAD, QUERY, and PATH.
   * 
   * @example
   * HEAD
   */
  location?: string;
  /**
   * @remarks
   * The data type of the back-end service parameter.
   * 
   * @example
   * String
   */
  parameterType?: string;
  /**
   * @remarks
   * The name of the backend service parameter.
   * 
   * @example
   * clientIp
   */
  serviceParameterName?: string;
  static names(): { [key: string]: string } {
    return {
      location: 'Location',
      parameterType: 'ParameterType',
      serviceParameterName: 'ServiceParameterName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      location: 'string',
      parameterType: 'string',
      serviceParameterName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDeployedApiResponseBodyServiceParameters extends $tea.Model {
  serviceParameter?: DescribeDeployedApiResponseBodyServiceParametersServiceParameter[];
  static names(): { [key: string]: string } {
    return {
      serviceParameter: 'ServiceParameter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      serviceParameter: { 'type': 'array', 'itemType': DescribeDeployedApiResponseBodyServiceParametersServiceParameter },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDeployedApiResponseBodyServiceParametersMapServiceParameterMap extends $tea.Model {
  /**
   * @remarks
   * The name of the front-end input parameter.
   * 
   * @example
   * sex
   */
  requestParameterName?: string;
  /**
   * @remarks
   * The name of the backend service parameter.
   * 
   * @example
   * sex
   */
  serviceParameterName?: string;
  static names(): { [key: string]: string } {
    return {
      requestParameterName: 'RequestParameterName',
      serviceParameterName: 'ServiceParameterName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestParameterName: 'string',
      serviceParameterName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDeployedApiResponseBodyServiceParametersMap extends $tea.Model {
  serviceParameterMap?: DescribeDeployedApiResponseBodyServiceParametersMapServiceParameterMap[];
  static names(): { [key: string]: string } {
    return {
      serviceParameterMap: 'ServiceParameterMap',
    };
  }

  static types(): { [key: string]: any } {
    return {
      serviceParameterMap: { 'type': 'array', 'itemType': DescribeDeployedApiResponseBodyServiceParametersMapServiceParameterMap },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDeployedApiResponseBodySystemParametersSystemParameter extends $tea.Model {
  /**
   * @remarks
   * Examples
   * 
   * @example
   * 192.168.1.1
   */
  demoValue?: string;
  /**
   * @remarks
   * The description.
   * 
   * @example
   * QueryParamDTO
   */
  description?: string;
  /**
   * @remarks
   * The parameter location. Valid values: BODY, HEAD, QUERY, and PATH.
   * 
   * @example
   * HEAD
   */
  location?: string;
  /**
   * @remarks
   * The name of the system parameter. Valid values: CaClientIp, CaDomain, CaRequestHandleTime, CaAppId, CaRequestId, CaHttpSchema, and CaProxy.
   * 
   * @example
   * CaClientIp
   */
  parameterName?: string;
  /**
   * @remarks
   * The name of the corresponding backend parameter.
   * 
   * @example
   * clientIp
   */
  serviceParameterName?: string;
  static names(): { [key: string]: string } {
    return {
      demoValue: 'DemoValue',
      description: 'Description',
      location: 'Location',
      parameterName: 'ParameterName',
      serviceParameterName: 'ServiceParameterName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      demoValue: 'string',
      description: 'string',
      location: 'string',
      parameterName: 'string',
      serviceParameterName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDeployedApiResponseBodySystemParameters extends $tea.Model {
  systemParameter?: DescribeDeployedApiResponseBodySystemParametersSystemParameter[];
  static names(): { [key: string]: string } {
    return {
      systemParameter: 'SystemParameter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      systemParameter: { 'type': 'array', 'itemType': DescribeDeployedApiResponseBodySystemParametersSystemParameter },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDeployedApisRequestTag extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * appname
   */
  key?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * testapp
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDeployedApisResponseBodyDeployedApisDeployedApiItem extends $tea.Model {
  /**
   * @remarks
   * The ID of the API.
   * 
   * @example
   * c076144d7878437b8f82fb85890ce6a0
   */
  apiId?: string;
  /**
   * @example
   * POST
   */
  apiMethod?: string;
  /**
   * @remarks
   * The name of the API.
   * 
   * @example
   * DescribeObjects
   */
  apiName?: string;
  /**
   * @example
   * /trademark/search
   */
  apiPath?: string;
  /**
   * @remarks
   * The publising time (UTC) of the API.
   * 
   * @example
   * 2016-07-23T08:28:48Z
   */
  deployedTime?: string;
  /**
   * @remarks
   * The description of the API.
   * 
   * @example
   * Queries objects by pages
   */
  description?: string;
  /**
   * @remarks
   * The ID of the API group.
   * 
   * @example
   * 63be9002440b4778a61122f14c2b2bbb
   */
  groupId?: string;
  /**
   * @remarks
   * The name of the group to which the API belongs.
   * 
   * @example
   * myGroup3
   */
  groupName?: string;
  /**
   * @remarks
   * The region where the API is located.
   * 
   * @example
   * cn-qingdao
   */
  regionId?: string;
  /**
   * @remarks
   * The name of the runtime environment. Valid values:
   * 
   * *   **RELEASE**
   * *   **TEST**
   * 
   * @example
   * RELEASE
   */
  stageName?: string;
  /**
   * @remarks
   * Indicates whether the API is public. Valid values:
   * 
   * *   **PUBLIC**
   * *   **PRIVATE**
   * 
   * @example
   * PUBLIC
   */
  visibility?: string;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      apiMethod: 'ApiMethod',
      apiName: 'ApiName',
      apiPath: 'ApiPath',
      deployedTime: 'DeployedTime',
      description: 'Description',
      groupId: 'GroupId',
      groupName: 'GroupName',
      regionId: 'RegionId',
      stageName: 'StageName',
      visibility: 'Visibility',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'string',
      apiMethod: 'string',
      apiName: 'string',
      apiPath: 'string',
      deployedTime: 'string',
      description: 'string',
      groupId: 'string',
      groupName: 'string',
      regionId: 'string',
      stageName: 'string',
      visibility: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDeployedApisResponseBodyDeployedApis extends $tea.Model {
  deployedApiItem?: DescribeDeployedApisResponseBodyDeployedApisDeployedApiItem[];
  static names(): { [key: string]: string } {
    return {
      deployedApiItem: 'DeployedApiItem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deployedApiItem: { 'type': 'array', 'itemType': DescribeDeployedApisResponseBodyDeployedApisDeployedApiItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGroupLatencyResponseBodyLatencyPacketMonitorItem extends $tea.Model {
  /**
   * @remarks
   * The metric. Valid values:
   * 
   * *   latency: the backend processing latency
   * *   gatewayLatency: the API Gateway processing latency
   * 
   * @example
   * latency
   */
  item?: string;
  /**
   * @remarks
   * The point in time when the latency data was collected. The format is YYYY-MM-DDThh:mm:ssZ.
   * 
   * @example
   * 2023-03-30T16:10:00Z
   */
  itemTime?: string;
  /**
   * @remarks
   * The latency. Unit: ms.
   * 
   * @example
   * 100.0
   */
  itemValue?: string;
  static names(): { [key: string]: string } {
    return {
      item: 'Item',
      itemTime: 'ItemTime',
      itemValue: 'ItemValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      item: 'string',
      itemTime: 'string',
      itemValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGroupLatencyResponseBodyLatencyPacket extends $tea.Model {
  monitorItem?: DescribeGroupLatencyResponseBodyLatencyPacketMonitorItem[];
  static names(): { [key: string]: string } {
    return {
      monitorItem: 'MonitorItem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      monitorItem: { 'type': 'array', 'itemType': DescribeGroupLatencyResponseBodyLatencyPacketMonitorItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGroupQpsResponseBodyGroupQpsMonitorItem extends $tea.Model {
  /**
   * @remarks
   * The point in time.
   * 
   * @example
   * 2023-08-02T09:15:00Z
   */
  itemTime?: string;
  /**
   * @remarks
   * The number of requests at the specified point in time.
   * 
   * @example
   * 17
   */
  itemValue?: string;
  static names(): { [key: string]: string } {
    return {
      itemTime: 'ItemTime',
      itemValue: 'ItemValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      itemTime: 'string',
      itemValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGroupQpsResponseBodyGroupQps extends $tea.Model {
  monitorItem?: DescribeGroupQpsResponseBodyGroupQpsMonitorItem[];
  static names(): { [key: string]: string } {
    return {
      monitorItem: 'MonitorItem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      monitorItem: { 'type': 'array', 'itemType': DescribeGroupQpsResponseBodyGroupQpsMonitorItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGroupTrafficResponseBodyTrafficPerSecondMonitorItem extends $tea.Model {
  /**
   * @remarks
   * The metric. Valid values:
   * 
   * *   inbound: traffic consumed by requests
   * *   outbound: traffic consumed by responses
   * 
   * @example
   * inbound
   */
  item?: string;
  /**
   * @remarks
   * The corresponding time. The time follows the ISO 8601 standard and UTC time is used. Format: YYYY-MM-DDThh:mm:ssZ.
   * 
   * @example
   * 2023-01-29T01:30:00Z
   */
  itemTime?: string;
  /**
   * @remarks
   * The traffic volume per second.
   * 
   * @example
   * 100.0
   */
  itemValue?: string;
  static names(): { [key: string]: string } {
    return {
      item: 'Item',
      itemTime: 'ItemTime',
      itemValue: 'ItemValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      item: 'string',
      itemTime: 'string',
      itemValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGroupTrafficResponseBodyTrafficPerSecond extends $tea.Model {
  monitorItem?: DescribeGroupTrafficResponseBodyTrafficPerSecondMonitorItem[];
  static names(): { [key: string]: string } {
    return {
      monitorItem: 'MonitorItem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      monitorItem: { 'type': 'array', 'itemType': DescribeGroupTrafficResponseBodyTrafficPerSecondMonitorItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHistoryApisResponseBodyApiHisItemsApiHisItem extends $tea.Model {
  /**
   * @remarks
   * The API ID.
   * 
   * @example
   * 5af418828f0344a3b588c0cc1331a3bc
   */
  apiId?: string;
  /**
   * @remarks
   * The API name.
   * 
   * @example
   * v2_role_assign
   */
  apiName?: string;
  /**
   * @remarks
   * The time when the API was published. The time is displayed in UTC.
   * 
   * @example
   * 2016-07-20T08:28:48Z
   */
  deployedTime?: string;
  /**
   * @remarks
   * The API description.
   * 
   * @example
   * Creates an object
   */
  description?: string;
  /**
   * @remarks
   * The API group ID.
   * 
   * @example
   * 1084f9034c744137901057206b39d2b6
   */
  groupId?: string;
  /**
   * @remarks
   * The name of the API group to which the API belongs.
   * 
   * @example
   * myGroup2
   */
  groupName?: string;
  /**
   * @remarks
   * The historical version of the API definition.
   * 
   * @example
   * 20210915101416294
   */
  historyVersion?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-qingdao
   */
  regionId?: string;
  /**
   * @remarks
   * The environment alias.
   * 
   * @example
   * Online
   */
  stageAlias?: string;
  /**
   * @remarks
   * The environment name. Valid values:
   * 
   * *   **RELEASE**
   * *   **TEST**
   * 
   * @example
   * RELEASE
   */
  stageName?: string;
  /**
   * @remarks
   * Indicates whether an API version is effective. Valid values: ONLINE and OFFLINE.
   * 
   * @example
   * ONLINE
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      apiName: 'ApiName',
      deployedTime: 'DeployedTime',
      description: 'Description',
      groupId: 'GroupId',
      groupName: 'GroupName',
      historyVersion: 'HistoryVersion',
      regionId: 'RegionId',
      stageAlias: 'StageAlias',
      stageName: 'StageName',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'string',
      apiName: 'string',
      deployedTime: 'string',
      description: 'string',
      groupId: 'string',
      groupName: 'string',
      historyVersion: 'string',
      regionId: 'string',
      stageAlias: 'string',
      stageName: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHistoryApisResponseBodyApiHisItems extends $tea.Model {
  apiHisItem?: DescribeHistoryApisResponseBodyApiHisItemsApiHisItem[];
  static names(): { [key: string]: string } {
    return {
      apiHisItem: 'ApiHisItem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiHisItem: { 'type': 'array', 'itemType': DescribeHistoryApisResponseBodyApiHisItemsApiHisItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImportOASTaskResponseBodyApiResultsApiResult extends $tea.Model {
  /**
   * @remarks
   * The API ID.
   * 
   * @example
   * c5a0c2900ff746b789c007545be22fb8
   */
  apiId?: string;
  /**
   * @remarks
   * The API name.
   * 
   * @example
   * GetByCreatorIdUsingGET
   */
  apiName?: string;
  /**
   * @remarks
   * The API description.
   * 
   * @example
   * release data api 411055691505041
   */
  description?: string;
  /**
   * @remarks
   * The cause of the failure if the API fails to be imported.
   * 
   * @example
   * Internal Error
   */
  errorMessage?: string;
  /**
   * @remarks
   * The API group ID.
   * 
   * @example
   * 736508d885074167ba8fbce3bc95ea0b
   */
  groupId?: string;
  /**
   * @remarks
   * The HTTP request HTTP method of the API.
   * 
   * @example
   * GET
   */
  method?: string;
  /**
   * @remarks
   * The request path of the API.
   * 
   * @example
   * /creator/getByCreatorId
   */
  path?: string;
  /**
   * @remarks
   * The execution status of the subtask. Valid values:
   * 
   * *   RUNNING
   * *   WAIT
   * *   OVER
   * *   FAIL
   * *   CANCEL
   * 
   * @example
   * WAIT
   */
  updateStatus?: string;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      apiName: 'ApiName',
      description: 'Description',
      errorMessage: 'ErrorMessage',
      groupId: 'GroupId',
      method: 'Method',
      path: 'Path',
      updateStatus: 'UpdateStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'string',
      apiName: 'string',
      description: 'string',
      errorMessage: 'string',
      groupId: 'string',
      method: 'string',
      path: 'string',
      updateStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImportOASTaskResponseBodyApiResults extends $tea.Model {
  apiResult?: DescribeImportOASTaskResponseBodyApiResultsApiResult[];
  static names(): { [key: string]: string } {
    return {
      apiResult: 'ApiResult',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiResult: { 'type': 'array', 'itemType': DescribeImportOASTaskResponseBodyApiResultsApiResult },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImportOASTaskResponseBodyModelResultsModelResult extends $tea.Model {
  /**
   * @remarks
   * The cause of the failure if the model fails to be imported.
   * 
   * @example
   * Internal Error
   */
  errorMessage?: string;
  /**
   * @remarks
   * The API group ID.
   * 
   * @example
   * 736508d885074167ba8fbce3bc95ea0b
   */
  groupId?: string;
  /**
   * @remarks
   * The ID of the imported model.
   * 
   * @example
   * 6b48d724c921415486e190c494dd6bf8
   */
  modelId?: string;
  /**
   * @remarks
   * The model name.
   * 
   * @example
   * Pet
   */
  modelName?: string;
  /**
   * @remarks
   * The execution status of the subtask. Valid values:
   * 
   * *   RUNNING
   * *   WAIT
   * *   OVER
   * *   FAIL
   * *   CANCEL
   * 
   * @example
   * FAIL
   */
  updateStatus?: string;
  static names(): { [key: string]: string } {
    return {
      errorMessage: 'ErrorMessage',
      groupId: 'GroupId',
      modelId: 'ModelId',
      modelName: 'ModelName',
      updateStatus: 'UpdateStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorMessage: 'string',
      groupId: 'string',
      modelId: 'string',
      modelName: 'string',
      updateStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImportOASTaskResponseBodyModelResults extends $tea.Model {
  modelResult?: DescribeImportOASTaskResponseBodyModelResultsModelResult[];
  static names(): { [key: string]: string } {
    return {
      modelResult: 'ModelResult',
    };
  }

  static types(): { [key: string]: any } {
    return {
      modelResult: { 'type': 'array', 'itemType': DescribeImportOASTaskResponseBodyModelResultsModelResult },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceClusterInfoResponseBodyInstanceClusterAttribute extends $tea.Model {
  /**
   * @remarks
   * The internal CIDR block of the user VPC that can be accessed by the cluster if the cluster consists of VPC integration instances.
   * 
   * @example
   * ["192.168.1.0/24","192.168.0.0/24"]
   */
  connectCidrBlocks?: string;
  /**
   * @remarks
   * The ID of the user VPC that is connected to the cluster if the cluster consists of VPC integration instances.
   * 
   * @example
   * vpc-p0w3kxxxxxxxxxxxxxxxx
   */
  connectVpcId?: string;
  /**
   * @remarks
   * Indicates whether outbound IPv6 traffic is supported.
   * 
   * @example
   * true
   */
  egressIpv6Enable?: boolean;
  /**
   * @remarks
   * The HTTPS security policy.
   * 
   * @example
   * HTTPS2_TLS1_0
   */
  httpsPolicies?: string;
  /**
   * @remarks
   * The ID of the IPv4 access control list (ACL).
   * 
   * @example
   * acl-t4n8i4rvvp70kcyuoXXXX
   */
  IPV4AclId?: string;
  /**
   * @remarks
   * The name of the IPv4 ACL.
   * 
   * @example
   * test-black
   */
  IPV4AclName?: string;
  /**
   * @remarks
   * Indicates whether IPv4 access control is enabled. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  IPV4AclStatus?: string;
  /**
   * @remarks
   * The type of the IPv4 ACL.
   * 
   * *   black: blacklist
   * *   white: whitelist
   * 
   * @example
   * black
   */
  IPV4AclType?: string;
  /**
   * @remarks
   * The ID of the IPv6 ACL.
   * 
   * @example
   * acl-t4nevzhwbpe7cup18XXXX
   */
  IPV6AclId?: string;
  /**
   * @remarks
   * The name of the IPv6 ACL.
   * 
   * @example
   * test
   */
  IPV6AclName?: string;
  /**
   * @remarks
   * Indicates whether IPv6 access control is enabled. Valid values:
   * 
   * *   **on**
   * *   **off**
   * 
   * @example
   * on
   */
  IPV6AclStatus?: string;
  /**
   * @remarks
   * The type of the IPv6 ACL. Valid values:
   * 
   * *   black: blacklist
   * *   white: whitelist
   * 
   * @example
   * white
   */
  IPV6AclType?: string;
  /**
   * @remarks
   * The outbound public IP address.
   * 
   * @example
   * 39.106.XX.XX
   */
  internetEgressAddress?: string;
  /**
   * @remarks
   * The outbound private IP address.
   * 
   * @example
   * 100.104.XX.XX/26
   */
  intranetEgressAddress?: string;
  /**
   * @remarks
   * The custom CIDR block. The configured CIDR block is considered as a private block.
   * 
   * @example
   * 123.0.0.1
   */
  intranetSegments?: string;
  /**
   * @remarks
   * Indicates whether IPv6 traffic is supported.
   * 
   * @example
   * true
   */
  supportIpv6?: boolean;
  /**
   * @remarks
   * The ID of the client VPC.
   * 
   * @example
   * vpc-2zew2v4vcg78mXXXX
   */
  userVpcId?: string;
  /**
   * @remarks
   * The vSwitch of the client VPC.
   * 
   * @example
   * vsw-2zecr5r7ao44tslsXXXX
   */
  userVswitchId?: string;
  /**
   * @remarks
   * The VIPs of the cluster.
   * 
   * @example
   * VPC_INTERNET_IPV6
   */
  vipTypeList?: string;
  /**
   * @remarks
   * Indicates whether a virtual private cloud (VPC) domain name is enabled.
   */
  vpcIntranetEnable?: boolean;
  /**
   * @remarks
   * The ID of the account to which the VPC belongs.
   * 
   * @example
   * 165438596694XXXX
   */
  vpcOwnerId?: number;
  /**
   * @remarks
   * Indicates whether self-calling is enabled.
   * 
   * @example
   * false
   */
  vpcSlbIntranetEnable?: boolean;
  static names(): { [key: string]: string } {
    return {
      connectCidrBlocks: 'ConnectCidrBlocks',
      connectVpcId: 'ConnectVpcId',
      egressIpv6Enable: 'EgressIpv6Enable',
      httpsPolicies: 'HttpsPolicies',
      IPV4AclId: 'IPV4AclId',
      IPV4AclName: 'IPV4AclName',
      IPV4AclStatus: 'IPV4AclStatus',
      IPV4AclType: 'IPV4AclType',
      IPV6AclId: 'IPV6AclId',
      IPV6AclName: 'IPV6AclName',
      IPV6AclStatus: 'IPV6AclStatus',
      IPV6AclType: 'IPV6AclType',
      internetEgressAddress: 'InternetEgressAddress',
      intranetEgressAddress: 'IntranetEgressAddress',
      intranetSegments: 'IntranetSegments',
      supportIpv6: 'SupportIpv6',
      userVpcId: 'UserVpcId',
      userVswitchId: 'UserVswitchId',
      vipTypeList: 'VipTypeList',
      vpcIntranetEnable: 'VpcIntranetEnable',
      vpcOwnerId: 'VpcOwnerId',
      vpcSlbIntranetEnable: 'VpcSlbIntranetEnable',
    };
  }

  static types(): { [key: string]: any } {
    return {
      connectCidrBlocks: 'string',
      connectVpcId: 'string',
      egressIpv6Enable: 'boolean',
      httpsPolicies: 'string',
      IPV4AclId: 'string',
      IPV4AclName: 'string',
      IPV4AclStatus: 'string',
      IPV4AclType: 'string',
      IPV6AclId: 'string',
      IPV6AclName: 'string',
      IPV6AclStatus: 'string',
      IPV6AclType: 'string',
      internetEgressAddress: 'string',
      intranetEgressAddress: 'string',
      intranetSegments: 'string',
      supportIpv6: 'boolean',
      userVpcId: 'string',
      userVswitchId: 'string',
      vipTypeList: 'string',
      vpcIntranetEnable: 'boolean',
      vpcOwnerId: 'number',
      vpcSlbIntranetEnable: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceClusterInfoResponseBodyInstanceListInstance extends $tea.Model {
  /**
   * @remarks
   * The error message returned if the call fails.
   * 
   * @example
   * Instance not found.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The instance ID.
   * 
   * @example
   * apigateway-ht-04e41d95e9c1
   */
  instanceId?: string;
  /**
   * @remarks
   * The instance name.
   * 
   * @example
   * tf-testacceu-central-1apigatewayinstance8752
   */
  instanceName?: string;
  /**
   * @remarks
   * The instance status.
   * 
   * @example
   * RUNNING
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      errorMessage: 'ErrorMessage',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorMessage: 'string',
      instanceId: 'string',
      instanceName: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceClusterInfoResponseBodyInstanceList extends $tea.Model {
  instance?: DescribeInstanceClusterInfoResponseBodyInstanceListInstance[];
  static names(): { [key: string]: string } {
    return {
      instance: 'Instance',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instance: { 'type': 'array', 'itemType': DescribeInstanceClusterInfoResponseBodyInstanceListInstance },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceClusterListResponseBodyInstanceClustersInstanceCluster extends $tea.Model {
  /**
   * @remarks
   * The time when the cluster was created. The time is displayed in UTC.
   * 
   * @example
   * 2023-08-14T17:46:59+08:00
   */
  createdTime?: string;
  /**
   * @remarks
   * The cluster description.
   * 
   * @example
   * Test TrafficControl
   */
  description?: string;
  /**
   * @remarks
   * The cluster ID.
   * 
   * @example
   * apigateway-cluster-hz-xxxxxxxxxxxx
   */
  instanceClusterId?: string;
  /**
   * @remarks
   * The cluster name.
   * 
   * @example
   * test-cluster
   */
  instanceClusterName?: string;
  /**
   * @remarks
   * The cluster status.
   * 
   * @example
   * RUNNING
   */
  instanceClusterStatus?: string;
  /**
   * @remarks
   * The cluster type.
   * 
   * @example
   * normal
   */
  instanceClusterType?: string;
  /**
   * @remarks
   * The time when the cluster was last modified. The time is displayed in UTC.
   * 
   * @example
   * 2024-01-12T10:11:08+08:00
   */
  modifiedTime?: string;
  /**
   * @remarks
   * The region ID of the cluster.
   * 
   * @example
   * cn-shenzhen
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      createdTime: 'CreatedTime',
      description: 'Description',
      instanceClusterId: 'InstanceClusterId',
      instanceClusterName: 'InstanceClusterName',
      instanceClusterStatus: 'InstanceClusterStatus',
      instanceClusterType: 'InstanceClusterType',
      modifiedTime: 'ModifiedTime',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createdTime: 'string',
      description: 'string',
      instanceClusterId: 'string',
      instanceClusterName: 'string',
      instanceClusterStatus: 'string',
      instanceClusterType: 'string',
      modifiedTime: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceClusterListResponseBodyInstanceClusters extends $tea.Model {
  instanceCluster?: DescribeInstanceClusterListResponseBodyInstanceClustersInstanceCluster[];
  static names(): { [key: string]: string } {
    return {
      instanceCluster: 'InstanceCluster',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceCluster: { 'type': 'array', 'itemType': DescribeInstanceClusterListResponseBodyInstanceClustersInstanceCluster },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceDropConnectionsResponseBodyInstanceDropConnectionsMonitorItem extends $tea.Model {
  /**
   * @remarks
   * The monitoring time. The time follows the ISO 8601 standard. Format: YYYY-MM-DDThh:mm:ssZ
   * 
   * @example
   * 2023-01-31T01:11:00Z
   */
  itemTime?: string;
  /**
   * @remarks
   * The number of dropped packets in the instance.
   * 
   * @example
   * 0.0
   */
  itemValue?: string;
  static names(): { [key: string]: string } {
    return {
      itemTime: 'ItemTime',
      itemValue: 'ItemValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      itemTime: 'string',
      itemValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceDropConnectionsResponseBodyInstanceDropConnections extends $tea.Model {
  monitorItem?: DescribeInstanceDropConnectionsResponseBodyInstanceDropConnectionsMonitorItem[];
  static names(): { [key: string]: string } {
    return {
      monitorItem: 'MonitorItem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      monitorItem: { 'type': 'array', 'itemType': DescribeInstanceDropConnectionsResponseBodyInstanceDropConnectionsMonitorItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceDropPacketResponseBodyInstanceDropPacketMonitorItem extends $tea.Model {
  /**
   * @remarks
   * The metric. Valid values:
   * 
   * *   InstanceDropPacketRX: the number of inbound packets dropped in the instance per second.
   * *   InstanceDropPacketTX: the number of outbound packets dropped in the instance per second.
   * 
   * @example
   * InstanceDropPacketRX
   */
  item?: string;
  /**
   * @remarks
   * The monitoring time. The time follows the ISO 8601 standard. Format: YYYY-MM-DDThh:mm:ssZ
   * 
   * @example
   * 2022-09-06T04:00:36Z
   */
  itemTime?: string;
  /**
   * @remarks
   * The number of dropped packets in the instance.
   * 
   * @example
   * 0.0
   */
  itemValue?: string;
  static names(): { [key: string]: string } {
    return {
      item: 'Item',
      itemTime: 'ItemTime',
      itemValue: 'ItemValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      item: 'string',
      itemTime: 'string',
      itemValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceDropPacketResponseBodyInstanceDropPacket extends $tea.Model {
  monitorItem?: DescribeInstanceDropPacketResponseBodyInstanceDropPacketMonitorItem[];
  static names(): { [key: string]: string } {
    return {
      monitorItem: 'MonitorItem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      monitorItem: { 'type': 'array', 'itemType': DescribeInstanceDropPacketResponseBodyInstanceDropPacketMonitorItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceHttpCodeResponseBodyInstanceHttpCodeMonitorItem extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 404
   */
  itemTime?: string;
  /**
   * @remarks
   * The corresponding value.
   * 
   * @example
   * 1
   */
  itemValue?: string;
  static names(): { [key: string]: string } {
    return {
      itemTime: 'ItemTime',
      itemValue: 'ItemValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      itemTime: 'string',
      itemValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceHttpCodeResponseBodyInstanceHttpCode extends $tea.Model {
  monitorItem?: DescribeInstanceHttpCodeResponseBodyInstanceHttpCodeMonitorItem[];
  static names(): { [key: string]: string } {
    return {
      monitorItem: 'MonitorItem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      monitorItem: { 'type': 'array', 'itemType': DescribeInstanceHttpCodeResponseBodyInstanceHttpCodeMonitorItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceLatencyResponseBodyInstanceLatencyMonitorItem extends $tea.Model {
  /**
   * @remarks
   * The metric. Valid values:
   * 
   * *   gatewayLatency API: the processing latency of API Gateway
   * *   latency: the processing latency of the backend service.
   * 
   * @example
   * latency
   */
  item?: string;
  /**
   * @remarks
   * The monitoring time. The time follows the ISO 8601 standard and UTC time is used. Format: YYYY-MM-DDThh:mm:ssZ
   * 
   * @example
   * 2022-09-06T02:05:13Z
   */
  itemTime?: string;
  /**
   * @remarks
   * The value of the average latency.
   * 
   * @example
   * 10
   */
  itemValue?: string;
  static names(): { [key: string]: string } {
    return {
      item: 'Item',
      itemTime: 'ItemTime',
      itemValue: 'ItemValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      item: 'string',
      itemTime: 'string',
      itemValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceLatencyResponseBodyInstanceLatency extends $tea.Model {
  monitorItem?: DescribeInstanceLatencyResponseBodyInstanceLatencyMonitorItem[];
  static names(): { [key: string]: string } {
    return {
      monitorItem: 'MonitorItem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      monitorItem: { 'type': 'array', 'itemType': DescribeInstanceLatencyResponseBodyInstanceLatencyMonitorItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceNewConnectionsResponseBodyInstanceNewConnectionsMonitorItem extends $tea.Model {
  /**
   * @remarks
   * The monitoring time. The time follows the ISO 8601 standard and UTC time is used. Format: YYYY-MM-DDThh:mm:ssZ
   * 
   * @example
   * 2022-10-08T02:08:00Z
   */
  itemTime?: string;
  /**
   * @remarks
   * The number of new connections in the instance.
   * 
   * @example
   * 16
   */
  itemValue?: string;
  static names(): { [key: string]: string } {
    return {
      itemTime: 'ItemTime',
      itemValue: 'ItemValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      itemTime: 'string',
      itemValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceNewConnectionsResponseBodyInstanceNewConnections extends $tea.Model {
  monitorItem?: DescribeInstanceNewConnectionsResponseBodyInstanceNewConnectionsMonitorItem[];
  static names(): { [key: string]: string } {
    return {
      monitorItem: 'MonitorItem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      monitorItem: { 'type': 'array', 'itemType': DescribeInstanceNewConnectionsResponseBodyInstanceNewConnectionsMonitorItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancePacketsResponseBodyInstancePacketsMonitorItem extends $tea.Model {
  /**
   * @remarks
   * The metric. Valid values:
   * 
   * *   InstancePacketRX: inbound data packets
   * *   InstancePacketTX: outbound data packets
   * 
   * @example
   * InstancePacketRX
   */
  item?: string;
  /**
   * @remarks
   * The monitoring time. The time follows the ISO 8601 standard and UTC time is used. Format: YYYY-MM-DDThh:mm:ssZ
   * 
   * @example
   * 2022-05-24T10:14:53Z
   */
  itemTime?: string;
  /**
   * @remarks
   * The number of inbound and outbound data packets in the instance.
   * 
   * @example
   * 0
   */
  itemValue?: string;
  static names(): { [key: string]: string } {
    return {
      item: 'Item',
      itemTime: 'ItemTime',
      itemValue: 'ItemValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      item: 'string',
      itemTime: 'string',
      itemValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancePacketsResponseBodyInstancePackets extends $tea.Model {
  monitorItem?: DescribeInstancePacketsResponseBodyInstancePacketsMonitorItem[];
  static names(): { [key: string]: string } {
    return {
      monitorItem: 'MonitorItem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      monitorItem: { 'type': 'array', 'itemType': DescribeInstancePacketsResponseBodyInstancePacketsMonitorItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceQpsResponseBodyInstanceQpsMonitorItem extends $tea.Model {
  /**
   * @remarks
   * The monitoring time. The time follows the ISO 8601 standard. Format: YYYY-MM-DDThh:mm:ssZ
   * 
   * @example
   * 2022-03-29T06:25:00Z
   */
  itemTime?: string;
  /**
   * @remarks
   * The number of requests sent to the APIs in the instance.
   * 
   * @example
   * 500
   */
  itemValue?: string;
  static names(): { [key: string]: string } {
    return {
      itemTime: 'ItemTime',
      itemValue: 'ItemValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      itemTime: 'string',
      itemValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceQpsResponseBodyInstanceQps extends $tea.Model {
  monitorItem?: DescribeInstanceQpsResponseBodyInstanceQpsMonitorItem[];
  static names(): { [key: string]: string } {
    return {
      monitorItem: 'MonitorItem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      monitorItem: { 'type': 'array', 'itemType': DescribeInstanceQpsResponseBodyInstanceQpsMonitorItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceSlbConnectResponseBodyInstanceSlbConnectMonitorItem extends $tea.Model {
  /**
   * @remarks
   * The metric. Valid values:
   * 
   * *   InstanceMaxConnection: the maximum number of connections
   * *   InstanceInactiveConnection: the number of inactive connections
   * *   InstanceActiveConnection: the number of active connections
   * 
   * @example
   * InstanceActiveConnection
   */
  item?: string;
  /**
   * @remarks
   * The monitoring time. The time follows the ISO 8601 standard and UTC time is used. Format: YYYY-MM-DDThh:mm:ssZ
   * 
   * @example
   * 2022-09-15T15:07:06Z
   */
  itemTime?: string;
  /**
   * @remarks
   * The number of concurrent connections in the instance.
   * 
   * @example
   * 12
   */
  itemValue?: string;
  static names(): { [key: string]: string } {
    return {
      item: 'Item',
      itemTime: 'ItemTime',
      itemValue: 'ItemValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      item: 'string',
      itemTime: 'string',
      itemValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceSlbConnectResponseBodyInstanceSlbConnect extends $tea.Model {
  monitorItem?: DescribeInstanceSlbConnectResponseBodyInstanceSlbConnectMonitorItem[];
  static names(): { [key: string]: string } {
    return {
      monitorItem: 'MonitorItem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      monitorItem: { 'type': 'array', 'itemType': DescribeInstanceSlbConnectResponseBodyInstanceSlbConnectMonitorItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTrafficResponseBodyInstanceTrafficMonitorItem extends $tea.Model {
  /**
   * @remarks
   * The metric. Valid values:
   * 
   * *   inbound: traffic consumed by requests
   * *   outbound: traffic consumed by responses
   * 
   * @example
   * inbound
   */
  item?: string;
  /**
   * @remarks
   * The monitoring time. The time follows the ISO 8601 standard and UTC time is used. Format: YYYY-MM-DDThh:mm:ssZ
   * 
   * @example
   * 2022-04-01T06:34:03Z
   */
  itemTime?: string;
  /**
   * @remarks
   * The amount of traffic consumed by the requests and responses in the instance.
   * 
   * @example
   * 10
   */
  itemValue?: string;
  static names(): { [key: string]: string } {
    return {
      item: 'Item',
      itemTime: 'ItemTime',
      itemValue: 'ItemValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      item: 'string',
      itemTime: 'string',
      itemValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceTrafficResponseBodyInstanceTraffic extends $tea.Model {
  monitorItem?: DescribeInstanceTrafficResponseBodyInstanceTrafficMonitorItem[];
  static names(): { [key: string]: string } {
    return {
      monitorItem: 'MonitorItem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      monitorItem: { 'type': 'array', 'itemType': DescribeInstanceTrafficResponseBodyInstanceTrafficMonitorItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesRequestTag extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * key1
   */
  key?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * value
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesResponseBodyInstancesInstanceAttributeInstanceSpecAttributesSpecAttribute extends $tea.Model {
  /**
   * @remarks
   * The variable name.
   */
  localName?: string;
  /**
   * @remarks
   * The variable value.
   * 
   * @example
   * 2500
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      localName: 'LocalName',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      localName: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesResponseBodyInstancesInstanceAttributeInstanceSpecAttributes extends $tea.Model {
  specAttribute?: DescribeInstancesResponseBodyInstancesInstanceAttributeInstanceSpecAttributesSpecAttribute[];
  static names(): { [key: string]: string } {
    return {
      specAttribute: 'SpecAttribute',
    };
  }

  static types(): { [key: string]: any } {
    return {
      specAttribute: { 'type': 'array', 'itemType': DescribeInstancesResponseBodyInstancesInstanceAttributeInstanceSpecAttributesSpecAttribute },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesResponseBodyInstancesInstanceAttributeNetworkInterfaceAttributesNetworkInterfaceAttribute extends $tea.Model {
  /**
   * @remarks
   * The CIDR block of the vSwitch.
   * 
   * @example
   * 192.168.17.0/24
   */
  cidrBlock?: string;
  /**
   * @remarks
   * The security group ID. Services in the same security group can access each other.
   * 
   * @example
   * sg-2zeehz13zcyj1kfk3o85
   */
  securityGroupId?: string;
  /**
   * @remarks
   * The vSwitch ID.
   * 
   * @example
   * vsw-2zeqals6rbj51bhjn8b89
   */
  vswitchId?: string;
  /**
   * @remarks
   * The zone ID.
   * 
   * @example
   * cn-shenzhen-d
   */
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      cidrBlock: 'CidrBlock',
      securityGroupId: 'SecurityGroupId',
      vswitchId: 'VswitchId',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cidrBlock: 'string',
      securityGroupId: 'string',
      vswitchId: 'string',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesResponseBodyInstancesInstanceAttributeNetworkInterfaceAttributes extends $tea.Model {
  networkInterfaceAttribute?: DescribeInstancesResponseBodyInstancesInstanceAttributeNetworkInterfaceAttributesNetworkInterfaceAttribute[];
  static names(): { [key: string]: string } {
    return {
      networkInterfaceAttribute: 'NetworkInterfaceAttribute',
    };
  }

  static types(): { [key: string]: any } {
    return {
      networkInterfaceAttribute: { 'type': 'array', 'itemType': DescribeInstancesResponseBodyInstancesInstanceAttributeNetworkInterfaceAttributesNetworkInterfaceAttribute },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesResponseBodyInstancesInstanceAttributePrivateDnsList extends $tea.Model {
  privateDns?: string[];
  static names(): { [key: string]: string } {
    return {
      privateDns: 'PrivateDns',
    };
  }

  static types(): { [key: string]: any } {
    return {
      privateDns: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesResponseBodyInstancesInstanceAttributeTagsTagInfo extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesResponseBodyInstancesInstanceAttributeTags extends $tea.Model {
  tagInfo?: DescribeInstancesResponseBodyInstancesInstanceAttributeTagsTagInfo[];
  static names(): { [key: string]: string } {
    return {
      tagInfo: 'TagInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagInfo: { 'type': 'array', 'itemType': DescribeInstancesResponseBodyInstancesInstanceAttributeTagsTagInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesResponseBodyInstancesInstanceAttribute extends $tea.Model {
  /**
   * @remarks
   * The ACL ID.
   * 
   * @example
   * acl-uf6f9zfxfxtp5j9ng3yv4
   */
  aclId?: string;
  /**
   * @remarks
   * The name of the access control list (ACL).
   * 
   * @example
   * test
   */
  aclName?: string;
  /**
   * @remarks
   * Indicates whether the ACL is enabled. Valid values:
   * 
   * *   **on**
   * *   **off**
   * 
   * @example
   * on
   */
  aclStatus?: string;
  /**
   * @remarks
   * The ACL type. Valid values:
   * 
   * *   black: blacklist
   * *   white: whitelist
   * 
   * @example
   * white
   */
  aclType?: string;
  /**
   * @remarks
   * The egress IP address.
   * 
   * @example
   * 10.0.0.1
   */
  classicEgressAddress?: string;
  /**
   * @remarks
   * The internal CIDR block of the user\\"s VPC that can be accessed if the instance is a VPC integration instance.
   * 
   * @example
   * [\\"172.16.0.0/24\\",\\"172.16.1.0/24\\"]
   */
  connectCidrBlocks?: string;
  /**
   * @remarks
   * The ID of the user\\"s VPC if the instance is a VPC integration instance.
   * 
   * @example
   * vpc-m5eo7khlb4h4f8y9egsdg
   */
  connectVpcId?: string;
  /**
   * @remarks
   * The time when the instance was created.
   * 
   * @example
   * 2021-10-22 15:36:53.0
   */
  createdTime?: string;
  /**
   * @remarks
   * The type of the dedicated instance. Valid values:
   * 
   * *   vpc_connect: VPC integration instance
   * *   normal: conventional dedicated instance
   * 
   * @example
   * vpc_connect
   */
  dedicatedInstanceType?: string;
  /**
   * @remarks
   * Indicates whether outbound IPv6 traffic is supported.
   * 
   * @example
   * true
   */
  egressIpv6Enable?: boolean;
  /**
   * @remarks
   * The time when the instance expires.
   * 
   * @example
   * 1659801600000
   */
  expiredTime?: string;
  /**
   * @remarks
   * The HTTPS security policy.
   * 
   * @example
   * HTTPS2_TLS1_2
   */
  httpsPolicies?: string;
  /**
   * @remarks
   * The ID of the IPv6 ACL.
   * 
   * @example
   * acl-124resFfs235
   */
  IPV6AclId?: string;
  /**
   * @remarks
   * The name of the IPv6 ACL.
   * 
   * @example
   * testIPV6
   */
  IPV6AclName?: string;
  /**
   * @remarks
   * Indicates whether the IPv6 ACL is enabled. Valid values:
   * 
   * *   **on**
   * *   **off**
   * 
   * @example
   * on
   */
  IPV6AclStatus?: string;
  /**
   * @remarks
   * The type of the IPv6 ACL. Valid values:
   * 
   * *   black: blacklist
   * *   white: whitelist
   * 
   * @example
   * black
   */
  IPV6AclType?: string;
  /**
   * @remarks
   * The billing method of the instance. Valid values:
   * 
   * *   PrePaid: subscription
   * *   PayAsYouGo: pay-as-you-go
   * 
   * @example
   * PrePaid
   */
  instanceChargeType?: string;
  /**
   * @remarks
   * The CIDR block of the dedicated instance.
   * 
   * *   172.16.0.0/12
   * *   192.168.0.0/16
   * 
   * @example
   * 192.168.0.0/16
   */
  instanceCidrBlock?: string;
  /**
   * @remarks
   * The ID of the cluster to which the dedicated instance cluster belongs.
   * 
   * @example
   * apigateway-cluster-sh-1523cafbgffd
   */
  instanceClusterId?: string;
  /**
   * @remarks
   * The instance ID.
   * 
   * @example
   * api-shared-vpc-020
   */
  instanceId?: string;
  /**
   * @remarks
   * The instance name.
   * 
   * @example
   * test
   */
  instanceName?: string;
  /**
   * @remarks
   * The requests per second (RPS) limit on the instance.
   * 
   * @example
   * 500
   */
  instanceRpsLimit?: number;
  /**
   * @remarks
   * The instance specification.
   * 
   * @example
   * api.s1.small
   */
  instanceSpec?: string;
  /**
   * @remarks
   * The instance specification details.
   */
  instanceSpecAttributes?: DescribeInstancesResponseBodyInstancesInstanceAttributeInstanceSpecAttributes;
  /**
   * @remarks
   * The instance type. Valid values:
   * 
   * *   VPC_SHARED: shared instance (VPC)
   * *   VPC_DEDICATED: dedicated instance (VPC)
   * 
   * @example
   * VPC_SHARED
   */
  instanceType?: string;
  /**
   * @remarks
   * The outbound public IP address.
   * 
   * @example
   * 47.241.89.244
   */
  internetEgressAddress?: string;
  /**
   * @remarks
   * The internal CIDR block that is allowed to access the API Gateway instance.
   * 
   * @example
   * [\\"172.36.0.0/16\\",\\"172.31.16.0/20\\"]
   */
  intranetSegments?: string;
  /**
   * @remarks
   * The end time of the maintenance window. The time is in the *HH:mm*Z format. The time is displayed in UTC.
   * 
   * @example
   * 01:00Z
   */
  maintainEndTime?: string;
  /**
   * @remarks
   * The start time of the maintenance window. The time is in the *HH:mm*Z format. The time is displayed in UTC.
   * 
   * @example
   * 22:00Z
   */
  maintainStartTime?: string;
  /**
   * @remarks
   * The network information of the user\\"s VPC if the instance is a VPC integration instance.
   */
  networkInterfaceAttributes?: DescribeInstancesResponseBodyInstancesInstanceAttributeNetworkInterfaceAttributes;
  privateDnsList?: DescribeInstancesResponseBodyInstancesInstanceAttributePrivateDnsList;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-beijing
   */
  regionId?: string;
  /**
   * @remarks
   * The instance status.
   * 
   * @example
   * RUNNING
   */
  status?: string;
  /**
   * @remarks
   * Indicates whether IPv6 traffic is supported.
   * 
   * @example
   * true
   */
  supportIpv6?: boolean;
  tags?: DescribeInstancesResponseBodyInstancesInstanceAttributeTags;
  /**
   * @remarks
   * The user VPC ID.
   * 
   * @example
   * vpc-t***hx****yu9****t0g4
   */
  userVpcId?: string;
  /**
   * @remarks
   * The user vSwitch ID.
   * 
   * @example
   * vsw-t4***eh****d7q****i2f
   */
  userVswitchId?: string;
  /**
   * @remarks
   * The VPC egress CIDR block.
   * 
   * @example
   * 100.104.254.0/26
   */
  vpcEgressAddress?: string;
  /**
   * @remarks
   * Indicates whether VPC access is enabled.
   * 
   * @example
   * true
   */
  vpcIntranetEnable?: boolean;
  /**
   * @remarks
   * The ID of the account to which the VPC-based instance belongs.
   * 
   * @example
   * 1408453217640291****
   */
  vpcOwnerId?: number;
  /**
   * @remarks
   * Indicates whether virtual private cloud (VPC) Server Load Balancer (SLB) is enabled.
   * 
   * @example
   * true
   */
  vpcSlbIntranetEnable?: boolean;
  /**
   * @remarks
   * The zone ID.
   * 
   * @example
   * cn-hangzhou-MAZ5(g,h)
   */
  zoneId?: string;
  /**
   * @remarks
   * The zone.
   */
  zoneLocalName?: string;
  static names(): { [key: string]: string } {
    return {
      aclId: 'AclId',
      aclName: 'AclName',
      aclStatus: 'AclStatus',
      aclType: 'AclType',
      classicEgressAddress: 'ClassicEgressAddress',
      connectCidrBlocks: 'ConnectCidrBlocks',
      connectVpcId: 'ConnectVpcId',
      createdTime: 'CreatedTime',
      dedicatedInstanceType: 'DedicatedInstanceType',
      egressIpv6Enable: 'EgressIpv6Enable',
      expiredTime: 'ExpiredTime',
      httpsPolicies: 'HttpsPolicies',
      IPV6AclId: 'IPV6AclId',
      IPV6AclName: 'IPV6AclName',
      IPV6AclStatus: 'IPV6AclStatus',
      IPV6AclType: 'IPV6AclType',
      instanceChargeType: 'InstanceChargeType',
      instanceCidrBlock: 'InstanceCidrBlock',
      instanceClusterId: 'InstanceClusterId',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      instanceRpsLimit: 'InstanceRpsLimit',
      instanceSpec: 'InstanceSpec',
      instanceSpecAttributes: 'InstanceSpecAttributes',
      instanceType: 'InstanceType',
      internetEgressAddress: 'InternetEgressAddress',
      intranetSegments: 'IntranetSegments',
      maintainEndTime: 'MaintainEndTime',
      maintainStartTime: 'MaintainStartTime',
      networkInterfaceAttributes: 'NetworkInterfaceAttributes',
      privateDnsList: 'PrivateDnsList',
      regionId: 'RegionId',
      status: 'Status',
      supportIpv6: 'SupportIpv6',
      tags: 'Tags',
      userVpcId: 'UserVpcId',
      userVswitchId: 'UserVswitchId',
      vpcEgressAddress: 'VpcEgressAddress',
      vpcIntranetEnable: 'VpcIntranetEnable',
      vpcOwnerId: 'VpcOwnerId',
      vpcSlbIntranetEnable: 'VpcSlbIntranetEnable',
      zoneId: 'ZoneId',
      zoneLocalName: 'ZoneLocalName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aclId: 'string',
      aclName: 'string',
      aclStatus: 'string',
      aclType: 'string',
      classicEgressAddress: 'string',
      connectCidrBlocks: 'string',
      connectVpcId: 'string',
      createdTime: 'string',
      dedicatedInstanceType: 'string',
      egressIpv6Enable: 'boolean',
      expiredTime: 'string',
      httpsPolicies: 'string',
      IPV6AclId: 'string',
      IPV6AclName: 'string',
      IPV6AclStatus: 'string',
      IPV6AclType: 'string',
      instanceChargeType: 'string',
      instanceCidrBlock: 'string',
      instanceClusterId: 'string',
      instanceId: 'string',
      instanceName: 'string',
      instanceRpsLimit: 'number',
      instanceSpec: 'string',
      instanceSpecAttributes: DescribeInstancesResponseBodyInstancesInstanceAttributeInstanceSpecAttributes,
      instanceType: 'string',
      internetEgressAddress: 'string',
      intranetSegments: 'string',
      maintainEndTime: 'string',
      maintainStartTime: 'string',
      networkInterfaceAttributes: DescribeInstancesResponseBodyInstancesInstanceAttributeNetworkInterfaceAttributes,
      privateDnsList: DescribeInstancesResponseBodyInstancesInstanceAttributePrivateDnsList,
      regionId: 'string',
      status: 'string',
      supportIpv6: 'boolean',
      tags: DescribeInstancesResponseBodyInstancesInstanceAttributeTags,
      userVpcId: 'string',
      userVswitchId: 'string',
      vpcEgressAddress: 'string',
      vpcIntranetEnable: 'boolean',
      vpcOwnerId: 'number',
      vpcSlbIntranetEnable: 'boolean',
      zoneId: 'string',
      zoneLocalName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstancesResponseBodyInstances extends $tea.Model {
  instanceAttribute?: DescribeInstancesResponseBodyInstancesInstanceAttribute[];
  static names(): { [key: string]: string } {
    return {
      instanceAttribute: 'InstanceAttribute',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceAttribute: { 'type': 'array', 'itemType': DescribeInstancesResponseBodyInstancesInstanceAttribute },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeIpControlPolicyItemsResponseBodyIpControlPolicyItemsIpControlPolicyItem extends $tea.Model {
  /**
   * @remarks
   * The ID of the application.
   * 
   * @example
   * 11112
   */
  appId?: string;
  /**
   * @remarks
   * The IP addresses or CIDR blocks.
   * 
   * @example
   * 113.125.XX.XX;101.11.XX.XX
   */
  cidrIp?: string;
  /**
   * @remarks
   * The time when the policy was created. The time is displayed in UTC.
   * 
   * @example
   * 2018-01-17T06:20:08Z
   */
  createTime?: string;
  /**
   * @remarks
   * The time when the policy was modified. The time is displayed in UTC.
   * 
   * @example
   * 2018-01-17T06:25:13Z
   */
  modifiedTime?: string;
  /**
   * @remarks
   * The ID of the policy.
   * 
   * @example
   * P151617000829241
   */
  policyItemId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      cidrIp: 'CidrIp',
      createTime: 'CreateTime',
      modifiedTime: 'ModifiedTime',
      policyItemId: 'PolicyItemId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      cidrIp: 'string',
      createTime: 'string',
      modifiedTime: 'string',
      policyItemId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeIpControlPolicyItemsResponseBodyIpControlPolicyItems extends $tea.Model {
  ipControlPolicyItem?: DescribeIpControlPolicyItemsResponseBodyIpControlPolicyItemsIpControlPolicyItem[];
  static names(): { [key: string]: string } {
    return {
      ipControlPolicyItem: 'IpControlPolicyItem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ipControlPolicyItem: { 'type': 'array', 'itemType': DescribeIpControlPolicyItemsResponseBodyIpControlPolicyItemsIpControlPolicyItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeIpControlsResponseBodyIpControlInfosIpControlInfo extends $tea.Model {
  /**
   * @remarks
   * The time when the ACL was created. The time is displayed in UTC.
   * 
   * @example
   * 2018-01-17T05:48:11Z
   */
  createTime?: string;
  /**
   * @remarks
   * The description of the ACL.
   * 
   * @example
   * description
   */
  description?: string;
  /**
   * @remarks
   * The ID of the ACL.
   * 
   * @example
   * 7ea91319a34d48a09b5c9c871d9768b1
   */
  ipControlId?: string;
  /**
   * @remarks
   * The name of the ACL.
   * 
   * @example
   * testControl11
   */
  ipControlName?: string;
  /**
   * @remarks
   * The type of the ACL.
   * 
   * @example
   * ALLOW
   */
  ipControlType?: string;
  /**
   * @remarks
   * The time when the ACL was modified. The time is displayed in UTC.
   * 
   * @example
   * 2018-01-17T06:00:38Z
   */
  modifiedTime?: string;
  /**
   * @remarks
   * The ID of the region in which the ACL is deployed.
   * 
   * @example
   * cn-qingdao
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      description: 'Description',
      ipControlId: 'IpControlId',
      ipControlName: 'IpControlName',
      ipControlType: 'IpControlType',
      modifiedTime: 'ModifiedTime',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'string',
      description: 'string',
      ipControlId: 'string',
      ipControlName: 'string',
      ipControlType: 'string',
      modifiedTime: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeIpControlsResponseBodyIpControlInfos extends $tea.Model {
  ipControlInfo?: DescribeIpControlsResponseBodyIpControlInfosIpControlInfo[];
  static names(): { [key: string]: string } {
    return {
      ipControlInfo: 'IpControlInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ipControlInfo: { 'type': 'array', 'itemType': DescribeIpControlsResponseBodyIpControlInfosIpControlInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLogConfigResponseBodyLogInfosLogInfo extends $tea.Model {
  /**
   * @example
   * PROVIDER
   */
  logType?: string;
  /**
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @example
   * slsstore
   */
  slsLogStore?: string;
  /**
   * @example
   * slsproject
   */
  slsProject?: string;
  static names(): { [key: string]: string } {
    return {
      logType: 'LogType',
      regionId: 'RegionId',
      slsLogStore: 'SlsLogStore',
      slsProject: 'SlsProject',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logType: 'string',
      regionId: 'string',
      slsLogStore: 'string',
      slsProject: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLogConfigResponseBodyLogInfos extends $tea.Model {
  logInfo?: DescribeLogConfigResponseBodyLogInfosLogInfo[];
  static names(): { [key: string]: string } {
    return {
      logInfo: 'LogInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logInfo: { 'type': 'array', 'itemType': DescribeLogConfigResponseBodyLogInfosLogInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeModelsRequestTag extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * key
   */
  key?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * value
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeModelsResponseBodyModelDetailsModelDetailTagsTagInfo extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * ENV
   */
  key?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * ST4
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeModelsResponseBodyModelDetailsModelDetailTags extends $tea.Model {
  tagInfo?: DescribeModelsResponseBodyModelDetailsModelDetailTagsTagInfo[];
  static names(): { [key: string]: string } {
    return {
      tagInfo: 'TagInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagInfo: { 'type': 'array', 'itemType': DescribeModelsResponseBodyModelDetailsModelDetailTagsTagInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeModelsResponseBodyModelDetailsModelDetail extends $tea.Model {
  /**
   * @remarks
   * The time when the model was created.
   * 
   * @example
   * 2019-01-29T11:07:48Z
   */
  createdTime?: string;
  /**
   * @remarks
   * The description of the model definition.
   * 
   * @example
   * Model Description
   */
  description?: string;
  /**
   * @remarks
   * The ID of the API group to which the model belongs.
   * 
   * @example
   * 30e792398d6c4569b04c0e53a3494381
   */
  groupId?: string;
  /**
   * @remarks
   * The ID of the model.
   * 
   * @example
   * 766c0b9538a04bdf974953b5576783ba
   */
  modelId?: string;
  /**
   * @remarks
   * The name of the model.
   * 
   * @example
   * Test
   */
  modelName?: string;
  /**
   * @remarks
   * The URI of the model.
   * 
   * @example
   * https://apigateway.aliyun.com/models/30e792398d6c4569b04c0e53a3494381/766c0b9538a04bdf974953b5576783ba
   */
  modelRef?: string;
  /**
   * @remarks
   * The time when the model was last modified.
   * 
   * @example
   * 2019-01-29T11:07:48Z
   */
  modifiedTime?: string;
  /**
   * @remarks
   * The definition of the model.
   * 
   * @example
   * {\\"type\\":\\"object\\",\\"properties\\":{\\"id\\":{\\"format\\":\\"int64\\",\\"maximum\\":100,\\"exclusiveMaximum\\":true,\\"type\\":\\"integer\\"},\\"name\\":{\\"maxLength\\":10,\\"type\\":\\"string\\"}}}
   */
  schema?: string;
  /**
   * @remarks
   * The tags of the model.
   */
  tags?: DescribeModelsResponseBodyModelDetailsModelDetailTags;
  static names(): { [key: string]: string } {
    return {
      createdTime: 'CreatedTime',
      description: 'Description',
      groupId: 'GroupId',
      modelId: 'ModelId',
      modelName: 'ModelName',
      modelRef: 'ModelRef',
      modifiedTime: 'ModifiedTime',
      schema: 'Schema',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createdTime: 'string',
      description: 'string',
      groupId: 'string',
      modelId: 'string',
      modelName: 'string',
      modelRef: 'string',
      modifiedTime: 'string',
      schema: 'string',
      tags: DescribeModelsResponseBodyModelDetailsModelDetailTags,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeModelsResponseBodyModelDetails extends $tea.Model {
  modelDetail?: DescribeModelsResponseBodyModelDetailsModelDetail[];
  static names(): { [key: string]: string } {
    return {
      modelDetail: 'ModelDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      modelDetail: { 'type': 'array', 'itemType': DescribeModelsResponseBodyModelDetailsModelDetail },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePluginApisResponseBodyApiSummarysApiPluginSummary extends $tea.Model {
  /**
   * @remarks
   * The API ID.
   * 
   * @example
   * accc8c68b7294b1cb4928741********
   */
  apiId?: string;
  /**
   * @remarks
   * The API name.
   * 
   * @example
   * fhosQueryDayOfStock_V2
   */
  apiName?: string;
  /**
   * @remarks
   * The API description.
   * 
   * @example
   * API description
   */
  description?: string;
  /**
   * @remarks
   * The ID of the API group.
   * 
   * @example
   * 5f51f89261854fd9ad5116be********
   */
  groupId?: string;
  /**
   * @remarks
   * The API group to which the API belongs.
   * 
   * @example
   * myGroup2
   */
  groupName?: string;
  /**
   * @remarks
   * The HTTP method of the API.
   * 
   * @example
   * GET
   */
  method?: string;
  /**
   * @remarks
   * The request path of the API.
   * 
   * @example
   * /mqTest
   */
  path?: string;
  /**
   * @remarks
   * The ID of the region in which the API resides.
   * 
   * @example
   * cn-shanghai
   */
  regionId?: string;
  /**
   * @remarks
   * The environment alias.
   * 
   * @example
   * Production
   */
  stageAlias?: string;
  /**
   * @remarks
   * The environment to which the API is published. Valid values:
   * 
   * *   **RELEASE**: the production environment
   * *   **PRE**: the pre-release environment
   * *   **TEST**: the test environment
   * 
   * @example
   * RELEASE
   */
  stageName?: string;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      apiName: 'ApiName',
      description: 'Description',
      groupId: 'GroupId',
      groupName: 'GroupName',
      method: 'Method',
      path: 'Path',
      regionId: 'RegionId',
      stageAlias: 'StageAlias',
      stageName: 'StageName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'string',
      apiName: 'string',
      description: 'string',
      groupId: 'string',
      groupName: 'string',
      method: 'string',
      path: 'string',
      regionId: 'string',
      stageAlias: 'string',
      stageName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePluginApisResponseBodyApiSummarys extends $tea.Model {
  apiPluginSummary?: DescribePluginApisResponseBodyApiSummarysApiPluginSummary[];
  static names(): { [key: string]: string } {
    return {
      apiPluginSummary: 'ApiPluginSummary',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiPluginSummary: { 'type': 'array', 'itemType': DescribePluginApisResponseBodyApiSummarysApiPluginSummary },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePluginSchemasResponseBodyPluginSchemasPluginSchema extends $tea.Model {
  /**
   * @example
   * plugin scheme description
   */
  description?: string;
  /**
   * @example
   * 4107**
   */
  documentId?: string;
  /**
   * @example
   * VPC_C
   */
  name?: string;
  /**
   * @example
   * true
   */
  supportClassic?: boolean;
  /**
   * @example
   * plugin schema title
   */
  title?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      documentId: 'DocumentId',
      name: 'Name',
      supportClassic: 'SupportClassic',
      title: 'Title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      documentId: 'string',
      name: 'string',
      supportClassic: 'boolean',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePluginSchemasResponseBodyPluginSchemas extends $tea.Model {
  pluginSchema?: DescribePluginSchemasResponseBodyPluginSchemasPluginSchema[];
  static names(): { [key: string]: string } {
    return {
      pluginSchema: 'PluginSchema',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pluginSchema: { 'type': 'array', 'itemType': DescribePluginSchemasResponseBodyPluginSchemasPluginSchema },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePluginTemplatesResponseBodyTemplatesTemplate extends $tea.Model {
  /**
   * @remarks
   * The description.
   * 
   * @example
   * balabala
   */
  description?: string;
  /**
   * @remarks
   * The document anchor point.
   * 
   * @example
   * anchor
   */
  documentAnchor?: string;
  /**
   * @remarks
   * The ID of the document.
   * 
   * @example
   * 41079
   */
  documentId?: string;
  /**
   * @remarks
   * The sample.
   * 
   * @example
   * 1
   */
  sample?: string;
  /**
   * @remarks
   * The title of the plug-in template title.
   * 
   * @example
   * template title
   */
  title?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      documentAnchor: 'DocumentAnchor',
      documentId: 'DocumentId',
      sample: 'Sample',
      title: 'Title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      documentAnchor: 'string',
      documentId: 'string',
      sample: 'string',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePluginTemplatesResponseBodyTemplates extends $tea.Model {
  template?: DescribePluginTemplatesResponseBodyTemplatesTemplate[];
  static names(): { [key: string]: string } {
    return {
      template: 'Template',
    };
  }

  static types(): { [key: string]: any } {
    return {
      template: { 'type': 'array', 'itemType': DescribePluginTemplatesResponseBodyTemplatesTemplate },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePluginsRequestTag extends $tea.Model {
  /**
   * @remarks
   * The key of the tag.
   * 
   * N can be an integer from 1 to 20.``
   * 
   * @example
   * env
   */
  key?: string;
  /**
   * @remarks
   * The value of the tag.
   * 
   * N can be an integer from 1 to 20.``
   * 
   * @example
   * \\" \\"
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePluginsResponseBodyPluginsPluginAttributeTagsTagInfo extends $tea.Model {
  /**
   * @remarks
   * The key of the tag.
   * 
   * @example
   * testkey
   */
  key?: string;
  /**
   * @remarks
   * The value of the tag.
   * 
   * @example
   * tetstvalue
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePluginsResponseBodyPluginsPluginAttributeTags extends $tea.Model {
  tagInfo?: DescribePluginsResponseBodyPluginsPluginAttributeTagsTagInfo[];
  static names(): { [key: string]: string } {
    return {
      tagInfo: 'TagInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagInfo: { 'type': 'array', 'itemType': DescribePluginsResponseBodyPluginsPluginAttributeTagsTagInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePluginsResponseBodyPluginsPluginAttribute extends $tea.Model {
  /**
   * @remarks
   * The creation time (UTC) of the plug-in.
   * 
   * @example
   * 2019-01-11T09:29:58Z
   */
  createdTime?: string;
  /**
   * @remarks
   * The plug-in description.
   * 
   * @example
   * Throttling
   */
  description?: string;
  /**
   * @remarks
   * The last modification time (UTC) of the plug-in.
   * 
   * @example
   * 2019-01-11T09:29:58Z
   */
  modifiedTime?: string;
  /**
   * @remarks
   * The definition statement of the plug-in.
   * 
   * @example
   * {"unit":"MINUTE","apiDefault":20}
   */
  pluginData?: string;
  /**
   * @remarks
   * The ID of the plug-in.
   * 
   * @example
   * 9a3f1a5279434f2ba74ccd91c295af9f
   */
  pluginId?: string;
  /**
   * @remarks
   * The name of the plug-in.
   * 
   * @example
   * firstPlugin
   */
  pluginName?: string;
  /**
   * @remarks
   * The type of the plug-in.
   * 
   * @example
   * trafficControl
   */
  pluginType?: string;
  /**
   * @remarks
   * The region where the plug-in is located.
   * 
   * @example
   * cn-qingdao
   */
  regionId?: string;
  /**
   * @remarks
   * The tags.
   */
  tags?: DescribePluginsResponseBodyPluginsPluginAttributeTags;
  static names(): { [key: string]: string } {
    return {
      createdTime: 'CreatedTime',
      description: 'Description',
      modifiedTime: 'ModifiedTime',
      pluginData: 'PluginData',
      pluginId: 'PluginId',
      pluginName: 'PluginName',
      pluginType: 'PluginType',
      regionId: 'RegionId',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createdTime: 'string',
      description: 'string',
      modifiedTime: 'string',
      pluginData: 'string',
      pluginId: 'string',
      pluginName: 'string',
      pluginType: 'string',
      regionId: 'string',
      tags: DescribePluginsResponseBodyPluginsPluginAttributeTags,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePluginsResponseBodyPlugins extends $tea.Model {
  pluginAttribute?: DescribePluginsResponseBodyPluginsPluginAttribute[];
  static names(): { [key: string]: string } {
    return {
      pluginAttribute: 'PluginAttribute',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pluginAttribute: { 'type': 'array', 'itemType': DescribePluginsResponseBodyPluginsPluginAttribute },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePluginsByApiResponseBodyPluginsPluginAttribute extends $tea.Model {
  /**
   * @remarks
   * The time when the plug-in was created. The time is displayed in UTC.
   * 
   * @example
   * 2019-01-11T09:29:58Z
   */
  createdTime?: string;
  /**
   * @remarks
   * The plug-in description.
   * 
   * @example
   * Traffic throttling
   */
  description?: string;
  /**
   * @remarks
   * The time when the plug-in was last modified. The time is displayed in UTC.
   * 
   * @example
   * 2019-01-11T09:29:58Z
   */
  modifiedTime?: string;
  /**
   * @remarks
   * The definition statement of the plug-in.
   * 
   * @example
   * {\\"unit\\":\\"MINUTE\\",\\"apiDefault\\":20}
   */
  pluginData?: string;
  /**
   * @remarks
   * The plug-in ID.
   * 
   * @example
   * 9a3f1a5279434f2ba74ccd91c295af9f
   */
  pluginId?: string;
  /**
   * @remarks
   * The plug-in name.
   * 
   * @example
   * firstPlugin
   */
  pluginName?: string;
  /**
   * @remarks
   * The plug-in type.
   * 
   * @example
   * trafficControl
   */
  pluginType?: string;
  /**
   * @remarks
   * The region where the plug-in resides.
   * 
   * @example
   * cn-qingdao
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      createdTime: 'CreatedTime',
      description: 'Description',
      modifiedTime: 'ModifiedTime',
      pluginData: 'PluginData',
      pluginId: 'PluginId',
      pluginName: 'PluginName',
      pluginType: 'PluginType',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createdTime: 'string',
      description: 'string',
      modifiedTime: 'string',
      pluginData: 'string',
      pluginId: 'string',
      pluginName: 'string',
      pluginType: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePluginsByApiResponseBodyPlugins extends $tea.Model {
  pluginAttribute?: DescribePluginsByApiResponseBodyPluginsPluginAttribute[];
  static names(): { [key: string]: string } {
    return {
      pluginAttribute: 'PluginAttribute',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pluginAttribute: { 'type': 'array', 'itemType': DescribePluginsByApiResponseBodyPluginsPluginAttribute },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePurchasedApiGroupResponseBodyDomainsDomainItem extends $tea.Model {
  /**
   * @remarks
   * The domain name.
   * 
   * @example
   * test_domain.com
   */
  domainName?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePurchasedApiGroupResponseBodyDomains extends $tea.Model {
  domainItem?: DescribePurchasedApiGroupResponseBodyDomainsDomainItem[];
  static names(): { [key: string]: string } {
    return {
      domainItem: 'DomainItem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainItem: { 'type': 'array', 'itemType': DescribePurchasedApiGroupResponseBodyDomainsDomainItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePurchasedApiGroupsResponseBodyPurchasedApiGroupAttributesPurchasedApiGroupAttribute extends $tea.Model {
  /**
   * @remarks
   * The billing method.
   * 
   * @example
   * POSTPAID
   */
  billingType?: string;
  /**
   * @remarks
   * The description of the API group.
   * 
   * @example
   * 1
   */
  description?: string;
  /**
   * @remarks
   * The time when the API group expires.
   * 
   * @example
   * 2021-12-19T00:00:00
   */
  expireTime?: string;
  /**
   * @remarks
   * The ID of the API group.
   * 
   * @example
   * 8e91f23f88f94348855b82c9a73209f3
   */
  groupId?: string;
  /**
   * @remarks
   * The name of the API group.
   * 
   * @example
   * group1
   */
  groupName?: string;
  /**
   * @remarks
   * The maximum number of calls.
   * 
   * @example
   * 10
   */
  invokeTimesMax?: number;
  /**
   * @remarks
   * The current number of calls.
   * 
   * @example
   * 10
   */
  invokeTimesNow?: number;
  /**
   * @remarks
   * The time when the API group was purchased.
   * 
   * @example
   * 2021-12-19T00:00:00
   */
  purchasedTime?: string;
  /**
   * @remarks
   * The ID of the region where the API group is located.
   * 
   * @example
   * cn-shanghai
   */
  regionId?: string;
  /**
   * @remarks
   * The status of the API group.
   * 
   * *   **NORMAL**: The API group is normal.
   * *   **DELETE**: The API group is deleted.
   * 
   * @example
   * NORMAL
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      billingType: 'BillingType',
      description: 'Description',
      expireTime: 'ExpireTime',
      groupId: 'GroupId',
      groupName: 'GroupName',
      invokeTimesMax: 'InvokeTimesMax',
      invokeTimesNow: 'InvokeTimesNow',
      purchasedTime: 'PurchasedTime',
      regionId: 'RegionId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      billingType: 'string',
      description: 'string',
      expireTime: 'string',
      groupId: 'string',
      groupName: 'string',
      invokeTimesMax: 'number',
      invokeTimesNow: 'number',
      purchasedTime: 'string',
      regionId: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePurchasedApiGroupsResponseBodyPurchasedApiGroupAttributes extends $tea.Model {
  purchasedApiGroupAttribute?: DescribePurchasedApiGroupsResponseBodyPurchasedApiGroupAttributesPurchasedApiGroupAttribute[];
  static names(): { [key: string]: string } {
    return {
      purchasedApiGroupAttribute: 'PurchasedApiGroupAttribute',
    };
  }

  static types(): { [key: string]: any } {
    return {
      purchasedApiGroupAttribute: { 'type': 'array', 'itemType': DescribePurchasedApiGroupsResponseBodyPurchasedApiGroupAttributesPurchasedApiGroupAttribute },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePurchasedApisResponseBodyPurchasedApisPurchasedApi extends $tea.Model {
  /**
   * @remarks
   * The ID of the API.
   * 
   * @example
   * eb6e54c1576d41149746e8e69b0a0792
   */
  apiId?: string;
  /**
   * @remarks
   * The name of the API.
   * 
   * @example
   * gw_rado_tissot_
   */
  apiName?: string;
  /**
   * @remarks
   * The deployment time. Format: yyyy-mm-ddhh:mm:ss.
   * 
   * @example
   * 2021-06-1113:57:38
   */
  deployedTime?: string;
  /**
   * @remarks
   * The description of the API.
   * 
   * @example
   * test
   */
  description?: string;
  /**
   * @remarks
   * The ID of the API group to which the API belongs. This ID is generated by the system and globally unique.
   * 
   * @example
   * 3013a55c0c44483f984d26df27120513
   */
  groupId?: string;
  /**
   * @remarks
   * The name of the API group.
   * 
   * @example
   * DMS_DEFAULT_GROUP_408589
   */
  groupName?: string;
  /**
   * @remarks
   * The last modification time (UTC) of the API.
   * 
   * @example
   * 2021-06-11T13:57:38+08:00
   */
  modifiedTime?: string;
  /**
   * @remarks
   * The time when the API was purchased.
   * 
   * @example
   * 2021-06-11T13:57:38+08:00
   */
  purchasedTime?: string;
  /**
   * @remarks
   * The ID of the region in which the API is located.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The name of the runtime environment. Valid values:
   * 
   * *   **RELEASE**
   * *   **PRE**
   * *   **TEST**
   * 
   * @example
   * TEST
   */
  stageName?: string;
  /**
   * @remarks
   * Indicates whether the API is public. Valid values:
   * 
   * *   **PUBLIC**
   * *   **PRIVATE**
   * 
   * @example
   * PUBLIC
   */
  visibility?: string;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      apiName: 'ApiName',
      deployedTime: 'DeployedTime',
      description: 'Description',
      groupId: 'GroupId',
      groupName: 'GroupName',
      modifiedTime: 'ModifiedTime',
      purchasedTime: 'PurchasedTime',
      regionId: 'RegionId',
      stageName: 'StageName',
      visibility: 'Visibility',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'string',
      apiName: 'string',
      deployedTime: 'string',
      description: 'string',
      groupId: 'string',
      groupName: 'string',
      modifiedTime: 'string',
      purchasedTime: 'string',
      regionId: 'string',
      stageName: 'string',
      visibility: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePurchasedApisResponseBodyPurchasedApis extends $tea.Model {
  purchasedApi?: DescribePurchasedApisResponseBodyPurchasedApisPurchasedApi[];
  static names(): { [key: string]: string } {
    return {
      purchasedApi: 'PurchasedApi',
    };
  }

  static types(): { [key: string]: any } {
    return {
      purchasedApi: { 'type': 'array', 'itemType': DescribePurchasedApisResponseBodyPurchasedApisPurchasedApi },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRegionsResponseBodyRegionsRegion extends $tea.Model {
  /**
   * @remarks
   * The name of the region.
   * 
   * @example
   * China (Shenzhen)
   */
  localName?: string;
  /**
   * @remarks
   * The endpoint of the service for the region.
   * 
   * @example
   * apigateway.cn-shenzhen.aliyuncs.com
   */
  regionEndpoint?: string;
  /**
   * @remarks
   * The ID of the region.
   * 
   * @example
   * cn-shenzhen
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      localName: 'LocalName',
      regionEndpoint: 'RegionEndpoint',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      localName: 'string',
      regionEndpoint: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRegionsResponseBodyRegions extends $tea.Model {
  region?: DescribeRegionsResponseBodyRegionsRegion[];
  static names(): { [key: string]: string } {
    return {
      region: 'Region',
    };
  }

  static types(): { [key: string]: any } {
    return {
      region: { 'type': 'array', 'itemType': DescribeRegionsResponseBodyRegionsRegion },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSignaturesResponseBodySignatureInfosSignatureInfo extends $tea.Model {
  /**
   * @remarks
   * The creation time of the key.
   * 
   * @example
   * 2016-07-23T08:28:48Z
   */
  createdTime?: string;
  /**
   * @remarks
   * The last modification time of the key.
   * 
   * @example
   * 2016-07-24T08:28:48Z
   */
  modifiedTime?: string;
  /**
   * @remarks
   * The region where the key is located.
   * 
   * @example
   * cn-qingdao
   */
  regionId?: string;
  /**
   * @remarks
   * The ID of the backend signature key.
   * 
   * @example
   * dd05f1c54d6749eda95f9fa6d491449a
   */
  signatureId?: string;
  /**
   * @remarks
   * The Key value of the backend signature key.
   * 
   * @example
   * qwertyuiop
   */
  signatureKey?: string;
  /**
   * @remarks
   * The name of the backend signature key.
   * 
   * @example
   * backendsignature
   */
  signatureName?: string;
  /**
   * @remarks
   * The Secret value of the backend signature key.
   * 
   * @example
   * asdfghjkl
   */
  signatureSecret?: string;
  static names(): { [key: string]: string } {
    return {
      createdTime: 'CreatedTime',
      modifiedTime: 'ModifiedTime',
      regionId: 'RegionId',
      signatureId: 'SignatureId',
      signatureKey: 'SignatureKey',
      signatureName: 'SignatureName',
      signatureSecret: 'SignatureSecret',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createdTime: 'string',
      modifiedTime: 'string',
      regionId: 'string',
      signatureId: 'string',
      signatureKey: 'string',
      signatureName: 'string',
      signatureSecret: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSignaturesResponseBodySignatureInfos extends $tea.Model {
  signatureInfo?: DescribeSignaturesResponseBodySignatureInfosSignatureInfo[];
  static names(): { [key: string]: string } {
    return {
      signatureInfo: 'SignatureInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      signatureInfo: { 'type': 'array', 'itemType': DescribeSignaturesResponseBodySignatureInfosSignatureInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSignaturesByApiResponseBodySignaturesSignatureItem extends $tea.Model {
  /**
   * @remarks
   * The time when the key was bound.
   * 
   * @example
   * 2016-07-23T08:28:48Z
   */
  boundTime?: string;
  /**
   * @remarks
   * The ID of the backend signature key.
   * 
   * @example
   * dd05f1c54d6749eda95f9fa6d491449a
   */
  signatureId?: string;
  /**
   * @remarks
   * The name of the backend signature key.
   * 
   * @example
   * mysecret
   */
  signatureName?: string;
  static names(): { [key: string]: string } {
    return {
      boundTime: 'BoundTime',
      signatureId: 'SignatureId',
      signatureName: 'SignatureName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      boundTime: 'string',
      signatureId: 'string',
      signatureName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSignaturesByApiResponseBodySignatures extends $tea.Model {
  signatureItem?: DescribeSignaturesByApiResponseBodySignaturesSignatureItem[];
  static names(): { [key: string]: string } {
    return {
      signatureItem: 'SignatureItem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      signatureItem: { 'type': 'array', 'itemType': DescribeSignaturesByApiResponseBodySignaturesSignatureItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSystemParametersResponseBodySystemParamsSystemParamItem extends $tea.Model {
  /**
   * @remarks
   * Examples
   * 
   * @example
   * 192.168.1.1
   */
  demoValue?: string;
  /**
   * @remarks
   * The description of a parameter.
   * 
   * @example
   * Client IP Address
   */
  description?: string;
  /**
   * @remarks
   * The name of the parameter.
   * 
   * @example
   * CaClientIp
   */
  paramName?: string;
  /**
   * @remarks
   * The type of the parameter.
   * 
   * @example
   * string
   */
  paramType?: string;
  static names(): { [key: string]: string } {
    return {
      demoValue: 'DemoValue',
      description: 'Description',
      paramName: 'ParamName',
      paramType: 'ParamType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      demoValue: 'string',
      description: 'string',
      paramName: 'string',
      paramType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSystemParametersResponseBodySystemParams extends $tea.Model {
  systemParamItem?: DescribeSystemParametersResponseBodySystemParamsSystemParamItem[];
  static names(): { [key: string]: string } {
    return {
      systemParamItem: 'SystemParamItem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      systemParamItem: { 'type': 'array', 'itemType': DescribeSystemParametersResponseBodySystemParamsSystemParamItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicySpecialsSpecial extends $tea.Model {
  /**
   * @remarks
   * The AppId or user account corresponding to SpecialType.
   * 
   * @example
   * test_wg@aliyun.com
   */
  specialKey?: string;
  /**
   * @remarks
   * The throttling value.
   * 
   * @example
   * 100
   */
  trafficValue?: number;
  static names(): { [key: string]: string } {
    return {
      specialKey: 'SpecialKey',
      trafficValue: 'TrafficValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      specialKey: 'string',
      trafficValue: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicySpecials extends $tea.Model {
  special?: DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicySpecialsSpecial[];
  static names(): { [key: string]: string } {
    return {
      special: 'Special',
    };
  }

  static types(): { [key: string]: any } {
    return {
      special: { 'type': 'array', 'itemType': DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicySpecialsSpecial },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicy extends $tea.Model {
  /**
   * @remarks
   * The type of the special throttling policy. Valid values:
   * 
   * *   **APP**
   * *   **USER**
   * 
   * @example
   * USER
   */
  specialType?: string;
  /**
   * @remarks
   * The returned information about a special throttling policy. It is an array consisting of Special data.
   */
  specials?: DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicySpecials;
  static names(): { [key: string]: string } {
    return {
      specialType: 'SpecialType',
      specials: 'Specials',
    };
  }

  static types(): { [key: string]: any } {
    return {
      specialType: 'string',
      specials: DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicySpecials,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPolicies extends $tea.Model {
  specialPolicy?: DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicy[];
  static names(): { [key: string]: string } {
    return {
      specialPolicy: 'SpecialPolicy',
    };
  }

  static types(): { [key: string]: any } {
    return {
      specialPolicy: { 'type': 'array', 'itemType': DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicy },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTrafficControlsResponseBodyTrafficControlsTrafficControl extends $tea.Model {
  /**
   * @remarks
   * The default throttling value for each API.
   * 
   * @example
   * 20000
   */
  apiDefault?: number;
  /**
   * @remarks
   * The default throttling value for each app.
   * 
   * @example
   * 8000
   */
  appDefault?: number;
  /**
   * @remarks
   * The creation time (UTC) of the throttling policy.
   * 
   * @example
   * 2016-01-27T10:19:39Z
   */
  createdTime?: string;
  /**
   * @remarks
   * The description of the throttling policy.
   * 
   * @example
   * test
   */
  description?: string;
  /**
   * @remarks
   * The last modification time (UTC) of the throttling policy.
   * 
   * @example
   * 2016-01-27T10:34:38Z
   */
  modifiedTime?: string;
  /**
   * @remarks
   * The returned information about a special throttling policy. It is an array consisting of SpecialPolicy data.
   */
  specialPolicies?: DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPolicies;
  /**
   * @remarks
   * The ID of the throttling policy.
   * 
   * @example
   * cfed6c970d45481dbe136d6b5ac68c41
   */
  trafficControlId?: string;
  /**
   * @remarks
   * The name of the throttling policy.
   * 
   * @example
   * wulingtestq1
   */
  trafficControlName?: string;
  /**
   * @remarks
   * The unit to be used in the throttling policy. Valid values:
   * 
   * *   MINUTE
   * *   HOUR
   * *   DAY
   * 
   * @example
   * Minute
   */
  trafficControlUnit?: string;
  /**
   * @remarks
   * The default throttling value for each user.
   * 
   * @example
   * 15000
   */
  userDefault?: number;
  static names(): { [key: string]: string } {
    return {
      apiDefault: 'ApiDefault',
      appDefault: 'AppDefault',
      createdTime: 'CreatedTime',
      description: 'Description',
      modifiedTime: 'ModifiedTime',
      specialPolicies: 'SpecialPolicies',
      trafficControlId: 'TrafficControlId',
      trafficControlName: 'TrafficControlName',
      trafficControlUnit: 'TrafficControlUnit',
      userDefault: 'UserDefault',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiDefault: 'number',
      appDefault: 'number',
      createdTime: 'string',
      description: 'string',
      modifiedTime: 'string',
      specialPolicies: DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPolicies,
      trafficControlId: 'string',
      trafficControlName: 'string',
      trafficControlUnit: 'string',
      userDefault: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTrafficControlsResponseBodyTrafficControls extends $tea.Model {
  trafficControl?: DescribeTrafficControlsResponseBodyTrafficControlsTrafficControl[];
  static names(): { [key: string]: string } {
    return {
      trafficControl: 'TrafficControl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      trafficControl: { 'type': 'array', 'itemType': DescribeTrafficControlsResponseBodyTrafficControlsTrafficControl },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTrafficControlsByApiResponseBodyTrafficControlItemsTrafficControlItem extends $tea.Model {
  /**
   * @remarks
   * The binding time of the policy.
   * 
   * @example
   * 2016-07-23T08:28:48Z
   */
  boundTime?: string;
  /**
   * @remarks
   * The ID of the throttling policy.
   * 
   * @example
   * dd05f1c54d6749eda95f9fa6d491449a
   */
  trafficControlItemId?: string;
  /**
   * @remarks
   * The name of the throttling policy.
   * 
   * @example
   * mysecret
   */
  trafficControlItemName?: string;
  static names(): { [key: string]: string } {
    return {
      boundTime: 'BoundTime',
      trafficControlItemId: 'TrafficControlItemId',
      trafficControlItemName: 'TrafficControlItemName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      boundTime: 'string',
      trafficControlItemId: 'string',
      trafficControlItemName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTrafficControlsByApiResponseBodyTrafficControlItems extends $tea.Model {
  trafficControlItem?: DescribeTrafficControlsByApiResponseBodyTrafficControlItemsTrafficControlItem[];
  static names(): { [key: string]: string } {
    return {
      trafficControlItem: 'TrafficControlItem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      trafficControlItem: { 'type': 'array', 'itemType': DescribeTrafficControlsByApiResponseBodyTrafficControlItemsTrafficControlItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUpdateBackendTaskResponseBodyApiUpdateBackendResultsApiUpdateBackendResult extends $tea.Model {
  /**
   * @example
   * checkin_linechart_today
   */
  apiName?: string;
  /**
   * @example
   * 14faa7ba0572445685866ddb6a6f19da
   */
  apiUid?: string;
  /**
   * @example
   * c09b078bcb8f4ade9677bd8b18cdf43f
   */
  backendId?: string;
  /**
   * @example
   * Failed
   */
  errorMsg?: string;
  /**
   * @example
   * 3013a55c0c44483f984d26df27120513
   */
  groupId?: string;
  /**
   * @example
   * imotob1
   */
  groupName?: string;
  /**
   * @example
   * d8f2f54f3309458b8aaceb36c01c2dd9
   */
  stageId?: string;
  /**
   * @example
   * RELEASE
   */
  stageName?: string;
  /**
   * @example
   * OVER
   */
  updateStatus?: string;
  static names(): { [key: string]: string } {
    return {
      apiName: 'ApiName',
      apiUid: 'ApiUid',
      backendId: 'BackendId',
      errorMsg: 'ErrorMsg',
      groupId: 'GroupId',
      groupName: 'GroupName',
      stageId: 'StageId',
      stageName: 'StageName',
      updateStatus: 'UpdateStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiName: 'string',
      apiUid: 'string',
      backendId: 'string',
      errorMsg: 'string',
      groupId: 'string',
      groupName: 'string',
      stageId: 'string',
      stageName: 'string',
      updateStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUpdateBackendTaskResponseBodyApiUpdateBackendResults extends $tea.Model {
  apiUpdateBackendResult?: DescribeUpdateBackendTaskResponseBodyApiUpdateBackendResultsApiUpdateBackendResult[];
  static names(): { [key: string]: string } {
    return {
      apiUpdateBackendResult: 'ApiUpdateBackendResult',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiUpdateBackendResult: { 'type': 'array', 'itemType': DescribeUpdateBackendTaskResponseBodyApiUpdateBackendResultsApiUpdateBackendResult },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUpdateVpcInfoTaskResponseBodyApiUpdateVpcInfoResultsApiUpdateVpcInfoResult extends $tea.Model {
  /**
   * @example
   * api_test2
   */
  apiName?: string;
  /**
   * @example
   * 86364e7c166c47ba819b3f8f95ac0913
   */
  apiUid?: string;
  /**
   * @example
   * Success. Request Success.
   */
  errorMsg?: string;
  /**
   * @example
   * e8da6f6346184da9a30d0dc1888b1f3b
   */
  groupId?: string;
  /**
   * @example
   * test
   */
  groupName?: string;
  /**
   * @example
   * fe952b95072747e2a8dfd336bcff8d7f
   */
  stageId?: string;
  /**
   * @example
   * RELEASE
   */
  stageName?: string;
  /**
   * @example
   * success
   */
  updateStatus?: string;
  static names(): { [key: string]: string } {
    return {
      apiName: 'ApiName',
      apiUid: 'ApiUid',
      errorMsg: 'ErrorMsg',
      groupId: 'GroupId',
      groupName: 'GroupName',
      stageId: 'StageId',
      stageName: 'StageName',
      updateStatus: 'UpdateStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiName: 'string',
      apiUid: 'string',
      errorMsg: 'string',
      groupId: 'string',
      groupName: 'string',
      stageId: 'string',
      stageName: 'string',
      updateStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUpdateVpcInfoTaskResponseBodyApiUpdateVpcInfoResults extends $tea.Model {
  apiUpdateVpcInfoResult?: DescribeUpdateVpcInfoTaskResponseBodyApiUpdateVpcInfoResultsApiUpdateVpcInfoResult[];
  static names(): { [key: string]: string } {
    return {
      apiUpdateVpcInfoResult: 'ApiUpdateVpcInfoResult',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiUpdateVpcInfoResult: { 'type': 'array', 'itemType': DescribeUpdateVpcInfoTaskResponseBodyApiUpdateVpcInfoResultsApiUpdateVpcInfoResult },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVpcAccessesRequestTag extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * appname
   */
  key?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * product
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVpcAccessesResponseBodyVpcAccessAttributesVpcAccessAttributeTagsTagInfo extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * PROJECT
   */
  key?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * 6427a17ae6041d1be62414e4
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVpcAccessesResponseBodyVpcAccessAttributesVpcAccessAttributeTags extends $tea.Model {
  tagInfo?: DescribeVpcAccessesResponseBodyVpcAccessAttributesVpcAccessAttributeTagsTagInfo[];
  static names(): { [key: string]: string } {
    return {
      tagInfo: 'TagInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagInfo: { 'type': 'array', 'itemType': DescribeVpcAccessesResponseBodyVpcAccessAttributesVpcAccessAttributeTagsTagInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVpcAccessesResponseBodyVpcAccessAttributesVpcAccessAttribute extends $tea.Model {
  /**
   * @remarks
   * The time when the authorization was created.
   * 
   * @example
   * 2017-01-30T04:10:19Z
   */
  createdTime?: string;
  /**
   * @remarks
   * The description of the VPC access authorization.
   * 
   * @example
   * Test
   */
  description?: string;
  /**
   * @remarks
   * The ID of an Elastic Compute Service (ECS) or Server Load Balancer (SLB) instance in the VPC.
   * 
   * @example
   * i-uf6bzcg1pr4oh5jjmxxx
   */
  instanceId?: string;
  /**
   * @remarks
   * The name of the authorization.
   * 
   * @example
   * test
   */
  name?: string;
  /**
   * @remarks
   * The port number that corresponds to the instance.
   * 
   * @example
   * 80
   */
  port?: number;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The tags.
   */
  tags?: DescribeVpcAccessesResponseBodyVpcAccessAttributesVpcAccessAttributeTags;
  /**
   * @remarks
   * The ID of the VPC access authorization.
   * 
   * @example
   * vpc-*****ssds24
   */
  vpcAccessId?: string;
  /**
   * @remarks
   * The VPC ID.
   * 
   * @example
   * vpc-uf657qec7lx42paw3qxxx
   */
  vpcId?: string;
  /**
   * @remarks
   * The host of the backend service.
   * 
   * @example
   * hos-a***.fh-**nc.com
   */
  vpcTargetHostName?: string;
  static names(): { [key: string]: string } {
    return {
      createdTime: 'CreatedTime',
      description: 'Description',
      instanceId: 'InstanceId',
      name: 'Name',
      port: 'Port',
      regionId: 'RegionId',
      tags: 'Tags',
      vpcAccessId: 'VpcAccessId',
      vpcId: 'VpcId',
      vpcTargetHostName: 'VpcTargetHostName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createdTime: 'string',
      description: 'string',
      instanceId: 'string',
      name: 'string',
      port: 'number',
      regionId: 'string',
      tags: DescribeVpcAccessesResponseBodyVpcAccessAttributesVpcAccessAttributeTags,
      vpcAccessId: 'string',
      vpcId: 'string',
      vpcTargetHostName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVpcAccessesResponseBodyVpcAccessAttributes extends $tea.Model {
  vpcAccessAttribute?: DescribeVpcAccessesResponseBodyVpcAccessAttributesVpcAccessAttribute[];
  static names(): { [key: string]: string } {
    return {
      vpcAccessAttribute: 'VpcAccessAttribute',
    };
  }

  static types(): { [key: string]: any } {
    return {
      vpcAccessAttribute: { 'type': 'array', 'itemType': DescribeVpcAccessesResponseBodyVpcAccessAttributesVpcAccessAttribute },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeZonesResponseBodyZonesZone extends $tea.Model {
  /**
   * @remarks
   * The name of the zone.
   * 
   * @example
   * China (Hangzhou) Multi-zone 2(j,g)
   */
  localName?: string;
  /**
   * @remarks
   * The ID of the zone.
   * 
   * @example
   * cn-hangzhou-MAZ2(j,g)
   */
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      localName: 'LocalName',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      localName: 'string',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeZonesResponseBodyZones extends $tea.Model {
  zone?: DescribeZonesResponseBodyZonesZone[];
  static names(): { [key: string]: string } {
    return {
      zone: 'Zone',
    };
  }

  static types(): { [key: string]: any } {
    return {
      zone: { 'type': 'array', 'itemType': DescribeZonesResponseBodyZonesZone },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DetachApiProductRequestApis extends $tea.Model {
  /**
   * @remarks
   * The API ID.
   * 
   * This parameter is required.
   * 
   * @example
   * ba84c55eca46488598da17c0609f3ead
   */
  apiId?: string;
  /**
   * @remarks
   * The environment to which the API is published. Valid values:
   * 
   * *   **RELEASE**: the production environment
   * *   **PRE**: the pre-release environment
   * *   **TEST**: the test environment
   * 
   * This parameter is required.
   * 
   * @example
   * RELEASE
   */
  stageName?: string;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      stageName: 'StageName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'string',
      stageName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DryRunSwaggerResponseBodyFailedApiImportSwaggerFailed extends $tea.Model {
  /**
   * @remarks
   * The error message returned when the API is created.
   * 
   * @example
   * api already exists : apiUid ===> 8e274ec61cf6468e83b68371956831cb
   */
  errorMsg?: string;
  /**
   * @remarks
   * The HTTP method configured when the API is created.
   * 
   * @example
   * post
   */
  httpMethod?: string;
  /**
   * @remarks
   * The request path configured when the API is created.
   * 
   * @example
   * /http/get/mapping
   */
  path?: string;
  static names(): { [key: string]: string } {
    return {
      errorMsg: 'ErrorMsg',
      httpMethod: 'HttpMethod',
      path: 'Path',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorMsg: 'string',
      httpMethod: 'string',
      path: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DryRunSwaggerResponseBodyFailed extends $tea.Model {
  apiImportSwaggerFailed?: DryRunSwaggerResponseBodyFailedApiImportSwaggerFailed[];
  static names(): { [key: string]: string } {
    return {
      apiImportSwaggerFailed: 'ApiImportSwaggerFailed',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiImportSwaggerFailed: { 'type': 'array', 'itemType': DryRunSwaggerResponseBodyFailedApiImportSwaggerFailed },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DryRunSwaggerResponseBodyModelFailedApiImportModelFailed extends $tea.Model {
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * Not Found
   */
  errorMsg?: string;
  /**
   * @remarks
   * The ID of the API group.
   * 
   * @example
   * 36d4bcfaec1946e1870d90b2d7519710
   */
  groupId?: string;
  /**
   * @remarks
   * The name of the model.
   * 
   * @example
   * Region
   */
  modelName?: string;
  static names(): { [key: string]: string } {
    return {
      errorMsg: 'ErrorMsg',
      groupId: 'GroupId',
      modelName: 'ModelName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorMsg: 'string',
      groupId: 'string',
      modelName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DryRunSwaggerResponseBodyModelFailed extends $tea.Model {
  apiImportModelFailed?: DryRunSwaggerResponseBodyModelFailedApiImportModelFailed[];
  static names(): { [key: string]: string } {
    return {
      apiImportModelFailed: 'ApiImportModelFailed',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiImportModelFailed: { 'type': 'array', 'itemType': DryRunSwaggerResponseBodyModelFailedApiImportModelFailed },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DryRunSwaggerResponseBodyModelSuccessApiImportModelSuccess extends $tea.Model {
  /**
   * @remarks
   * The ID of the API group.
   * 
   * @example
   * b2d552ed90ca435b86f7bf8d45414793
   */
  groupId?: string;
  /**
   * @remarks
   * The name of the model.
   * 
   * @example
   * NewInstance
   */
  modelName?: string;
  /**
   * @remarks
   * The model operation.
   * 
   * @example
   * CREATE
   */
  modelOperation?: string;
  /**
   * @remarks
   * The UID of the model.
   * 
   * @example
   * ec1946e1870d90b2d7519
   */
  modelUid?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      modelName: 'ModelName',
      modelOperation: 'ModelOperation',
      modelUid: 'ModelUid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      modelName: 'string',
      modelOperation: 'string',
      modelUid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DryRunSwaggerResponseBodyModelSuccess extends $tea.Model {
  apiImportModelSuccess?: DryRunSwaggerResponseBodyModelSuccessApiImportModelSuccess[];
  static names(): { [key: string]: string } {
    return {
      apiImportModelSuccess: 'ApiImportModelSuccess',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiImportModelSuccess: { 'type': 'array', 'itemType': DryRunSwaggerResponseBodyModelSuccessApiImportModelSuccess },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DryRunSwaggerResponseBodySuccessApiDryRunSwaggerSuccess extends $tea.Model {
  /**
   * @remarks
   * Specifies whether the operation is CREATE or MODIFY.
   * 
   * @example
   * CREATE
   */
  apiOperation?: string;
  /**
   * @remarks
   * The API definition that complies with the Swagger specification.
   * 
   * @example
   * "A Swagger API definition in YAML"
   */
  apiSwagger?: string;
  /**
   * @remarks
   * The UID of the successfully imported API.
   * 
   * @example
   * 8e274ec61cf6468e83b68371956831cb
   */
  apiUid?: string;
  /**
   * @remarks
   * The HTTP method configured when the API is created.
   * 
   * @example
   * get
   */
  httpMethod?: string;
  /**
   * @remarks
   * The request path configured when the API is created.
   * 
   * @example
   * /http/get/mapping
   */
  path?: string;
  static names(): { [key: string]: string } {
    return {
      apiOperation: 'ApiOperation',
      apiSwagger: 'ApiSwagger',
      apiUid: 'ApiUid',
      httpMethod: 'HttpMethod',
      path: 'Path',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiOperation: 'string',
      apiSwagger: 'string',
      apiUid: 'string',
      httpMethod: 'string',
      path: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DryRunSwaggerResponseBodySuccess extends $tea.Model {
  apiDryRunSwaggerSuccess?: DryRunSwaggerResponseBodySuccessApiDryRunSwaggerSuccess[];
  static names(): { [key: string]: string } {
    return {
      apiDryRunSwaggerSuccess: 'ApiDryRunSwaggerSuccess',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiDryRunSwaggerSuccess: { 'type': 'array', 'itemType': DryRunSwaggerResponseBodySuccessApiDryRunSwaggerSuccess },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportOASResponseBodyErrorMessages extends $tea.Model {
  errorMessage?: string[];
  static names(): { [key: string]: string } {
    return {
      errorMessage: 'ErrorMessage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorMessage: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportOASResponseBodyFailedApisFailedApi extends $tea.Model {
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * Invalid Api Definition.
   */
  errorMsg?: string;
  /**
   * @remarks
   * The HTTP method configured when you created the API.
   * 
   * @example
   * POST
   */
  httpMethod?: string;
  /**
   * @remarks
   * The request path configured when you created the API.
   * 
   * @example
   * /st1
   */
  path?: string;
  static names(): { [key: string]: string } {
    return {
      errorMsg: 'ErrorMsg',
      httpMethod: 'HttpMethod',
      path: 'Path',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorMsg: 'string',
      httpMethod: 'string',
      path: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportOASResponseBodyFailedApis extends $tea.Model {
  failedApi?: ImportOASResponseBodyFailedApisFailedApi[];
  static names(): { [key: string]: string } {
    return {
      failedApi: 'FailedApi',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failedApi: { 'type': 'array', 'itemType': ImportOASResponseBodyFailedApisFailedApi },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportOASResponseBodyFailedModelsFailedModel extends $tea.Model {
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * Invalid Model Definition.
   */
  errorMsg?: string;
  /**
   * @remarks
   * The ID of the API group.
   * 
   * @example
   * 2c1bc62e19614cc68c6b0b484bc9c5db
   */
  groupId?: string;
  /**
   * @remarks
   * The name of the model.
   * 
   * @example
   * test
   */
  modelName?: string;
  static names(): { [key: string]: string } {
    return {
      errorMsg: 'ErrorMsg',
      groupId: 'GroupId',
      modelName: 'ModelName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorMsg: 'string',
      groupId: 'string',
      modelName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportOASResponseBodyFailedModels extends $tea.Model {
  failedModel?: ImportOASResponseBodyFailedModelsFailedModel[];
  static names(): { [key: string]: string } {
    return {
      failedModel: 'FailedModel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failedModel: { 'type': 'array', 'itemType': ImportOASResponseBodyFailedModelsFailedModel },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportOASResponseBodySuccessApisSuccessApi extends $tea.Model {
  /**
   * @remarks
   * The ID of the API.
   * 
   * @example
   * 92af1abffc2443eaa2b815fdbd9c13f1
   */
  apiId?: string;
  /**
   * @remarks
   * Indicates that the operation is CREATE or MODIFY.
   * 
   * @example
   * CREATE
   */
  apiOperation?: string;
  /**
   * @remarks
   * The HTTP method configured when you created the API.
   * 
   * @example
   * POST
   */
  httpMethod?: string;
  /**
   * @remarks
   * The request path configured when you created the API.
   * 
   * @example
   * /st1
   */
  path?: string;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      apiOperation: 'ApiOperation',
      httpMethod: 'HttpMethod',
      path: 'Path',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'string',
      apiOperation: 'string',
      httpMethod: 'string',
      path: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportOASResponseBodySuccessApis extends $tea.Model {
  successApi?: ImportOASResponseBodySuccessApisSuccessApi[];
  static names(): { [key: string]: string } {
    return {
      successApi: 'SuccessApi',
    };
  }

  static types(): { [key: string]: any } {
    return {
      successApi: { 'type': 'array', 'itemType': ImportOASResponseBodySuccessApisSuccessApi },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportOASResponseBodySuccessModelsSuccessModel extends $tea.Model {
  /**
   * @remarks
   * The ID of the API group.
   * 
   * @example
   * feaccf67040643bcbdedb253e59eb527
   */
  groupId?: string;
  /**
   * @remarks
   * The name of the model.
   * 
   * @example
   * test
   */
  modelName?: string;
  /**
   * @remarks
   * The operation of the model. Valid values: CREATE and MODIFY.
   * 
   * @example
   * CREATE
   */
  modelOperation?: string;
  /**
   * @remarks
   * The UID of the model.
   * 
   * @example
   * 1r4efwee19614cc68c6b0b484bc9c5dbs
   */
  modelUid?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      modelName: 'ModelName',
      modelOperation: 'ModelOperation',
      modelUid: 'ModelUid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      modelName: 'string',
      modelOperation: 'string',
      modelUid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportOASResponseBodySuccessModels extends $tea.Model {
  successModel?: ImportOASResponseBodySuccessModelsSuccessModel[];
  static names(): { [key: string]: string } {
    return {
      successModel: 'SuccessModel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      successModel: { 'type': 'array', 'itemType': ImportOASResponseBodySuccessModelsSuccessModel },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportOASResponseBodyWarningMessages extends $tea.Model {
  warningMessage?: string[];
  static names(): { [key: string]: string } {
    return {
      warningMessage: 'WarningMessage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      warningMessage: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportSwaggerResponseBodyFailedApiImportSwaggerFailed extends $tea.Model {
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * api already exists : apiUid ===> 8e274ec61cf6468e83b68371956831cb
   */
  errorMsg?: string;
  /**
   * @remarks
   * The HTTP method of the API.
   * 
   * @example
   * post
   */
  httpMethod?: string;
  /**
   * @remarks
   * The request path of the API.
   * 
   * @example
   * /http/get/mapping
   */
  path?: string;
  static names(): { [key: string]: string } {
    return {
      errorMsg: 'ErrorMsg',
      httpMethod: 'HttpMethod',
      path: 'Path',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorMsg: 'string',
      httpMethod: 'string',
      path: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportSwaggerResponseBodyFailed extends $tea.Model {
  apiImportSwaggerFailed?: ImportSwaggerResponseBodyFailedApiImportSwaggerFailed[];
  static names(): { [key: string]: string } {
    return {
      apiImportSwaggerFailed: 'ApiImportSwaggerFailed',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiImportSwaggerFailed: { 'type': 'array', 'itemType': ImportSwaggerResponseBodyFailedApiImportSwaggerFailed },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportSwaggerResponseBodyModelFailedApiImportModelFailed extends $tea.Model {
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * error msg
   */
  errorMsg?: string;
  /**
   * @remarks
   * The ID of the API group.
   * 
   * @example
   * 36d4bcfaec1946e1870d90b2d7519710
   */
  groupId?: string;
  /**
   * @remarks
   * The name of the model.
   * 
   * @example
   * Region
   */
  modelName?: string;
  static names(): { [key: string]: string } {
    return {
      errorMsg: 'ErrorMsg',
      groupId: 'GroupId',
      modelName: 'ModelName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorMsg: 'string',
      groupId: 'string',
      modelName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportSwaggerResponseBodyModelFailed extends $tea.Model {
  apiImportModelFailed?: ImportSwaggerResponseBodyModelFailedApiImportModelFailed[];
  static names(): { [key: string]: string } {
    return {
      apiImportModelFailed: 'ApiImportModelFailed',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiImportModelFailed: { 'type': 'array', 'itemType': ImportSwaggerResponseBodyModelFailedApiImportModelFailed },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportSwaggerResponseBodyModelSuccessApiImportModelSuccess extends $tea.Model {
  /**
   * @remarks
   * The ID of the API group.
   * 
   * @example
   * b2d552ed90ca435b86f7bf8d45414793
   */
  groupId?: string;
  /**
   * @remarks
   * The name of the model.
   * 
   * @example
   * NewInstance
   */
  modelName?: string;
  /**
   * @remarks
   * The model operation.
   */
  modelOperation?: string;
  /**
   * @remarks
   * The UID of the model.
   * 
   * @example
   * d4bcfaec1946e1870d
   */
  modelUid?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      modelName: 'ModelName',
      modelOperation: 'ModelOperation',
      modelUid: 'ModelUid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      modelName: 'string',
      modelOperation: 'string',
      modelUid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportSwaggerResponseBodyModelSuccess extends $tea.Model {
  apiImportModelSuccess?: ImportSwaggerResponseBodyModelSuccessApiImportModelSuccess[];
  static names(): { [key: string]: string } {
    return {
      apiImportModelSuccess: 'ApiImportModelSuccess',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiImportModelSuccess: { 'type': 'array', 'itemType': ImportSwaggerResponseBodyModelSuccessApiImportModelSuccess },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportSwaggerResponseBodySuccessApiImportSwaggerSuccess extends $tea.Model {
  /**
   * @remarks
   * Specifies that the operation is CREATE or MODIFY.
   * 
   * @example
   * CREATE
   */
  apiOperation?: string;
  /**
   * @remarks
   * The UID of the imported API.
   * 
   * @example
   * 8e274ec61cf6468e83b68371956831cb
   */
  apiUid?: string;
  /**
   * @remarks
   * The HTTP method of the API.
   * 
   * @example
   * get
   */
  httpMethod?: string;
  /**
   * @remarks
   * The request path of the API.
   * 
   * @example
   * /http/get/mapping
   */
  path?: string;
  static names(): { [key: string]: string } {
    return {
      apiOperation: 'ApiOperation',
      apiUid: 'ApiUid',
      httpMethod: 'HttpMethod',
      path: 'Path',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiOperation: 'string',
      apiUid: 'string',
      httpMethod: 'string',
      path: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportSwaggerResponseBodySuccess extends $tea.Model {
  apiImportSwaggerSuccess?: ImportSwaggerResponseBodySuccessApiImportSwaggerSuccess[];
  static names(): { [key: string]: string } {
    return {
      apiImportSwaggerSuccess: 'ApiImportSwaggerSuccess',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiImportSwaggerSuccess: { 'type': 'array', 'itemType': ImportSwaggerResponseBodySuccessApiImportSwaggerSuccess },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPrivateDNSResponseBodyPrivateDNSListRecords extends $tea.Model {
  /**
   * @example
   * 192.168.0.1
   */
  record?: string;
  /**
   * @example
   * 100
   */
  weight?: number;
  static names(): { [key: string]: string } {
    return {
      record: 'Record',
      weight: 'Weight',
    };
  }

  static types(): { [key: string]: any } {
    return {
      record: 'string',
      weight: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPrivateDNSResponseBodyPrivateDNSList extends $tea.Model {
  bindInstances?: string[];
  /**
   * @example
   * 2023-05-10T08:17:00Z
   */
  createdTime?: string;
  /**
   * @example
   * api.demo.com
   */
  intranetDomain?: string;
  records?: ListPrivateDNSResponseBodyPrivateDNSListRecords[];
  /**
   * @example
   * A
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      bindInstances: 'BindInstances',
      createdTime: 'CreatedTime',
      intranetDomain: 'IntranetDomain',
      records: 'Records',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bindInstances: { 'type': 'array', 'itemType': 'string' },
      createdTime: 'string',
      intranetDomain: 'string',
      records: { 'type': 'array', 'itemType': ListPrivateDNSResponseBodyPrivateDNSListRecords },
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTagResourcesRequestTag extends $tea.Model {
  /**
   * @remarks
   * The key of the tag.
   * 
   * Valid values of N: `[1,20]`.
   * 
   * @example
   * env
   */
  key?: string;
  /**
   * @remarks
   * The value of the tag. If the parameter has a value, a value is also required for the tag key of the same N in the corresponding **tag.N.Key**. Otherwise, an error is reported.
   * 
   * Valid values of N: `[1,20]`.
   * 
   * @example
   * product
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTagResourcesResponseBodyTagResourcesTagResource extends $tea.Model {
  /**
   * @remarks
   * The ID of the resource.
   * 
   * @example
   * 285bb759342649a1b70c2093a772e087
   */
  resourceId?: string;
  /**
   * @remarks
   * The type of the resource.
   * 
   * @example
   * apiGroup
   */
  resourceType?: string;
  /**
   * @remarks
   * The key of the tag.
   * 
   * @example
   * owner
   */
  tagKey?: string;
  /**
   * @remarks
   * The value of the tag.
   * 
   * @example
   * zhangsan
   */
  tagValue?: string;
  static names(): { [key: string]: string } {
    return {
      resourceId: 'ResourceId',
      resourceType: 'ResourceType',
      tagKey: 'TagKey',
      tagValue: 'TagValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceId: 'string',
      resourceType: 'string',
      tagKey: 'string',
      tagValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTagResourcesResponseBodyTagResources extends $tea.Model {
  tagResource?: ListTagResourcesResponseBodyTagResourcesTagResource[];
  static names(): { [key: string]: string } {
    return {
      tagResource: 'TagResource',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagResource: { 'type': 'array', 'itemType': ListTagResourcesResponseBodyTagResourcesTagResource },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyApiGroupRequestTag extends $tea.Model {
  /**
   * @remarks
   * The key of the tag.
   * 
   * This parameter is required.
   * 
   * @example
   * env
   */
  key?: string;
  /**
   * @remarks
   * The value of the tag.
   * 
   * This parameter is required.
   * 
   * @example
   * uat
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyApiGroupInstanceRequestTag extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * env
   */
  key?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 123
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyAppRequestTag extends $tea.Model {
  /**
   * @remarks
   * The key of the tag.
   * 
   * Valid values of n: `[1, 20]`.
   * 
   * This parameter is required.
   * 
   * @example
   * key
   */
  key?: string;
  /**
   * @remarks
   * The value of the tag.
   * 
   * Valid values of n: `[1, 20]`.
   * 
   * @example
   * value
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceAttributeRequestToConnectVpcIpBlock extends $tea.Model {
  /**
   * @remarks
   * The CIDR block of the VSwitch.
   * 
   * @example
   * 172.16.0.0/16
   */
  cidrBlock?: string;
  /**
   * @remarks
   * Specifies whether the CIDR block is a custom CIDR block.
   * 
   * @example
   * false
   */
  customized?: boolean;
  /**
   * @remarks
   * The vSwitch ID.
   * 
   * @example
   * vsw-wz94cqvaoe1ipxxxxxx
   */
  vswitchId?: string;
  /**
   * @remarks
   * The zone ID.
   * 
   * @example
   * cn-hangzhou-a
   */
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      cidrBlock: 'CidrBlock',
      customized: 'Customized',
      vswitchId: 'VswitchId',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cidrBlock: 'string',
      customized: 'boolean',
      vswitchId: 'string',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyPluginRequestTag extends $tea.Model {
  /**
   * @remarks
   * The key of the tag.
   * 
   * N can be an integer from 1 to 20.``
   * 
   * This parameter is required.
   * 
   * @example
   * env
   */
  key?: string;
  /**
   * @remarks
   * The value of the tag.
   * 
   * N can be an integer from 1 to 20.``
   * 
   * This parameter is required.
   * 
   * @example
   * \\" \\"
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryRequestLogsResponseBodyRequestLogsRequestLog extends $tea.Model {
  /**
   * @remarks
   * The API ID.
   * 
   * @example
   * 4b83229ebcab4ecd88956fb3********
   */
  apiId?: string;
  /**
   * @remarks
   * The API name.
   * 
   * @example
   * ApiName
   */
  apiName?: string;
  /**
   * @remarks
   * The application name.
   * 
   * @example
   * VIPROOM_VIPROOM
   */
  appName?: string;
  /**
   * @remarks
   * The time when API Gateway finished forwarding the request to the backend service.
   */
  backendRequestEnd?: number;
  /**
   * @remarks
   * The time when API Gateway started to forward the request to the backend service.
   */
  backendRequestStart?: number;
  /**
   * @remarks
   * The time when API Gateway finished receiving the response from the backend service.
   */
  backendResponseEnd?: number;
  /**
   * @remarks
   * The time when API Gateway started to receive the response from the backend service.
   */
  backendResponseStart?: number;
  /**
   * @remarks
   * The IP address of the client that sends the request.
   * 
   * @example
   * 21.237.XXX.XXX
   */
  clientIp?: string;
  /**
   * @remarks
   * The X-Ca-Nonce header included in the request from the client.
   * 
   * @example
   * d43df9db-3b05-4cd6-888a-1c0b********
   */
  clientNonce?: string;
  /**
   * @remarks
   * The application ID that is used by the caller.
   * 
   * @example
   * 11096****
   */
  consumerAppId?: string;
  /**
   * @remarks
   * The App Key that is used by the caller.
   * 
   * @example
   * 20412****
   */
  consumerAppKey?: string;
  /**
   * @remarks
   * The custom trace ID.
   * 
   * @example
   * 95657ED9-2F6F-426F-BD99-79C8********
   */
  customTraceId?: string;
  /**
   * @remarks
   * The requested domain name in the request.
   * 
   * @example
   * 360bdd88695c48ae8085c7f2********-ap-southeast-1.alicloudapi.com
   */
  domain?: string;
  /**
   * @remarks
   * The error code that is returned.
   * 
   * @example
   * X500ER
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the call fails.
   * 
   * @example
   * Backend service connect failed `Timeout connecting to [/1XX.20.0.XX:8080]`
   */
  errorMessage?: string;
  /**
   * @remarks
   * The specific error message returned by the backend service.
   * 
   * @example
   * error msg
   */
  exception?: string;
  /**
   * @remarks
   * The time when API Gateway finished receiving the request.
   */
  frontRequestEnd?: number;
  /**
   * @remarks
   * The time when API Gateway started to receive the request.
   */
  frontRequestStart?: number;
  /**
   * @remarks
   * The time when API Gateway finished forwarding the response to the client.
   */
  frontResponseEnd?: number;
  /**
   * @remarks
   * The time when API Gateway started to forward the response to the client.
   */
  frontResponseStart?: number;
  /**
   * @remarks
   * The ID of the API group to which the API belongs.
   * 
   * @example
   * dc024277fe6c4cada79ba0bd6********
   */
  groupId?: string;
  /**
   * @remarks
   * The name of the API group to which the API belongs.
   * 
   * @example
   * GroupName
   */
  groupName?: string;
  /**
   * @remarks
   * The HTTP method that is used to send the request.
   * 
   * @example
   * POST
   */
  httpMethod?: string;
  /**
   * @remarks
   * The path of the request.
   * 
   * @example
   * /testPath
   */
  httpPath?: string;
  /**
   * @remarks
   * The initial request ID when API Gateway calls an API. For example, if API-1 calls API-2, the initialRequestId parameter in the log of API-2 indicates the ID of the request from API-1.
   * 
   * @example
   * 95657ED9-2F6F-426F-BD99-79C8********
   */
  initialRequestId?: string;
  /**
   * @remarks
   * The ID of the API Gateway instance to which the API belongs.
   * 
   * @example
   * apigateway-bj-ab2b********
   */
  instanceId?: string;
  /**
   * @remarks
   * The JSON web token (JWT) claims. The claims can be configured at the group level.
   * 
   * @example
   * {}
   */
  jwtClaims?: string;
  /**
   * @remarks
   * The region in which the instance resides.
   * 
   * @example
   * cn-hangzhou
   */
  region?: string;
  /**
   * @remarks
   * The request body. A request body cannot exceed 1,024 bytes in size.
   * 
   * @example
   * param=paramName
   */
  requestBody?: string;
  /**
   * @remarks
   * The request headers.
   * 
   * @example
   * content-type: application/x-www-form-urlencoded
   */
  requestHeaders?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 95657ED9-2F6F-426F-BD99-79C8********
   */
  requestId?: string;
  /**
   * @remarks
   * The protocol used by the client to send the request. Valid values: HTTP, HTTPS, and WS.
   * 
   * @example
   * HTTP
   */
  requestProtocol?: string;
  /**
   * @remarks
   * The query string for the request.
   * 
   * @example
   * username=name
   */
  requestQueryString?: string;
  /**
   * @remarks
   * The size of the request. Unit: bytes.
   * 
   * @example
   * 1923
   */
  requestSize?: string;
  /**
   * @remarks
   * The request time, in UTC.
   * 
   * @example
   * 2022-10-29T03:59:59Z
   */
  requestTime?: string;
  /**
   * @remarks
   * The response body. A response body cannot exceed 1,024 bytes in size.
   * 
   * @example
   * param=paramName
   */
  responseBody?: string;
  /**
   * @remarks
   * The headers in the API response.
   * 
   * @example
   * content-type: application/x-www-form-urlencoded
   */
  responseHeaders?: string;
  /**
   * @remarks
   * The size of returned data. Unit: bytes.
   * 
   * @example
   * 23441
   */
  responseSize?: string;
  /**
   * @remarks
   * The total time consumed to access the backend resources. The total time includes the time consumed to request a connection to the resources, the time consumed to establish the connection, and the time consumed to call the backend service. Unit: milliseconds.
   * 
   * @example
   * 324
   */
  serviceLatency?: string;
  /**
   * @remarks
   * The ID of the API environment.
   * 
   * @example
   * 8a305b7f10334052a52d9156********
   */
  stageId?: string;
  /**
   * @remarks
   * The name of the API environment.
   * 
   * @example
   * RELEASE
   */
  stageName?: string;
  /**
   * @remarks
   * The status code returned.
   * 
   * @example
   * 200
   */
  statusCode?: string;
  /**
   * @remarks
   * The total time consumed by the request. Unit: milliseconds.
   * 
   * @example
   * 1345
   */
  totalLatency?: string;
  /**
   * @remarks
   * The plug-in hit by the request and the relevant context.
   * 
   * @example
   * []
   */
  plugin?: string;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      apiName: 'ApiName',
      appName: 'AppName',
      backendRequestEnd: 'BackendRequestEnd',
      backendRequestStart: 'BackendRequestStart',
      backendResponseEnd: 'BackendResponseEnd',
      backendResponseStart: 'BackendResponseStart',
      clientIp: 'ClientIp',
      clientNonce: 'ClientNonce',
      consumerAppId: 'ConsumerAppId',
      consumerAppKey: 'ConsumerAppKey',
      customTraceId: 'CustomTraceId',
      domain: 'Domain',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      exception: 'Exception',
      frontRequestEnd: 'FrontRequestEnd',
      frontRequestStart: 'FrontRequestStart',
      frontResponseEnd: 'FrontResponseEnd',
      frontResponseStart: 'FrontResponseStart',
      groupId: 'GroupId',
      groupName: 'GroupName',
      httpMethod: 'HttpMethod',
      httpPath: 'HttpPath',
      initialRequestId: 'InitialRequestId',
      instanceId: 'InstanceId',
      jwtClaims: 'JwtClaims',
      region: 'Region',
      requestBody: 'RequestBody',
      requestHeaders: 'RequestHeaders',
      requestId: 'RequestId',
      requestProtocol: 'RequestProtocol',
      requestQueryString: 'RequestQueryString',
      requestSize: 'RequestSize',
      requestTime: 'RequestTime',
      responseBody: 'ResponseBody',
      responseHeaders: 'ResponseHeaders',
      responseSize: 'ResponseSize',
      serviceLatency: 'ServiceLatency',
      stageId: 'StageId',
      stageName: 'StageName',
      statusCode: 'StatusCode',
      totalLatency: 'TotalLatency',
      plugin: 'plugin',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'string',
      apiName: 'string',
      appName: 'string',
      backendRequestEnd: 'number',
      backendRequestStart: 'number',
      backendResponseEnd: 'number',
      backendResponseStart: 'number',
      clientIp: 'string',
      clientNonce: 'string',
      consumerAppId: 'string',
      consumerAppKey: 'string',
      customTraceId: 'string',
      domain: 'string',
      errorCode: 'string',
      errorMessage: 'string',
      exception: 'string',
      frontRequestEnd: 'number',
      frontRequestStart: 'number',
      frontResponseEnd: 'number',
      frontResponseStart: 'number',
      groupId: 'string',
      groupName: 'string',
      httpMethod: 'string',
      httpPath: 'string',
      initialRequestId: 'string',
      instanceId: 'string',
      jwtClaims: 'string',
      region: 'string',
      requestBody: 'string',
      requestHeaders: 'string',
      requestId: 'string',
      requestProtocol: 'string',
      requestQueryString: 'string',
      requestSize: 'string',
      requestTime: 'string',
      responseBody: 'string',
      responseHeaders: 'string',
      responseSize: 'string',
      serviceLatency: 'string',
      stageId: 'string',
      stageName: 'string',
      statusCode: 'string',
      totalLatency: 'string',
      plugin: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryRequestLogsResponseBodyRequestLogs extends $tea.Model {
  requestLog?: QueryRequestLogsResponseBodyRequestLogsRequestLog[];
  static names(): { [key: string]: string } {
    return {
      requestLog: 'RequestLog',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestLog: { 'type': 'array', 'itemType': QueryRequestLogsResponseBodyRequestLogsRequestLog },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveVpcAccessResponseBodyApisApi extends $tea.Model {
  /**
   * @remarks
   * API Id
   * 
   * @example
   * 551877242a4b4f3a84a56b7c3570e4a7
   */
  apiId?: string;
  /**
   * @remarks
   * The ID of the API group.
   * 
   * @example
   * 78d54ac4424d4b1792e33ca35637e8e4
   */
  groupId?: string;
  /**
   * @remarks
   * The ID of the runtime environment.
   * 
   * @example
   * d1e1ee28f9fb4b729db0ee8ca76ff0a5
   */
  stageId?: string;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      groupId: 'GroupId',
      stageId: 'StageId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'string',
      groupId: 'string',
      stageId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveVpcAccessResponseBodyApis extends $tea.Model {
  api?: RemoveVpcAccessResponseBodyApisApi[];
  static names(): { [key: string]: string } {
    return {
      api: 'Api',
    };
  }

  static types(): { [key: string]: any } {
    return {
      api: { 'type': 'array', 'itemType': RemoveVpcAccessResponseBodyApisApi },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetVpcAccessRequestTag extends $tea.Model {
  /**
   * @remarks
   * The key of the tag.
   * 
   * @example
   * key
   */
  key?: string;
  /**
   * @remarks
   * The value of the tag.
   * 
   * @example
   * 123
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TagResourcesRequestTag extends $tea.Model {
  /**
   * @remarks
   * The key of tag N.
   * 
   * This parameter is required.
   * 
   * @example
   * env
   */
  key?: string;
  /**
   * @remarks
   * The value of tag N.
   * 
   * This parameter is required.
   * 
   * @example
   * \\" \\"
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePrivateDNSRequestRecords extends $tea.Model {
  /**
   * @example
   * 192.168.0.2
   */
  record?: string;
  /**
   * @example
   * 100
   */
  weight?: number;
  static names(): { [key: string]: string } {
    return {
      record: 'Record',
      weight: 'Weight',
    };
  }

  static types(): { [key: string]: any } {
    return {
      record: 'string',
      weight: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}


export default class Client extends OpenApi {

  constructor(config: $OpenApi.Config) {
    super(config);
    this._endpointRule = "regional";
    this._endpointMap = {
      'cn-qingdao': "apigateway.cn-qingdao.aliyuncs.com",
      'cn-beijing': "apigateway.cn-beijing.aliyuncs.com",
      'cn-zhangjiakou': "apigateway.cn-zhangjiakou.aliyuncs.com",
      'cn-huhehaote': "apigateway.cn-huhehaote.aliyuncs.com",
      'cn-wulanchabu': "apigateway.cn-wulanchabu.aliyuncs.com",
      'cn-hangzhou': "apigateway.cn-hangzhou.aliyuncs.com",
      'cn-shanghai': "apigateway.cn-shanghai.aliyuncs.com",
      'cn-shenzhen': "apigateway.cn-shenzhen.aliyuncs.com",
      'cn-heyuan': "apigateway.cn-heyuan.aliyuncs.com",
      'cn-guangzhou': "apigateway.cn-guangzhou.aliyuncs.com",
      'cn-chengdu': "apigateway.cn-chengdu.aliyuncs.com",
      'cn-hongkong': "apigateway.cn-hongkong.aliyuncs.com",
      'ap-northeast-1': "apigateway.ap-northeast-1.aliyuncs.com",
      'ap-southeast-1': "apigateway.ap-southeast-1.aliyuncs.com",
      'ap-southeast-2': "apigateway.ap-southeast-2.aliyuncs.com",
      'ap-southeast-3': "apigateway.ap-southeast-3.aliyuncs.com",
      'ap-southeast-5': "apigateway.ap-southeast-5.aliyuncs.com",
      'ap-southeast-6': "apigateway.ap-southeast-6.aliyuncs.com",
      'ap-southeast-7': "apigateway.ap-southeast-7.aliyuncs.com",
      'us-east-1': "apigateway.us-east-1.aliyuncs.com",
      'us-west-1': "apigateway.us-west-1.aliyuncs.com",
      'eu-west-1': "apigateway.eu-west-1.aliyuncs.com",
      'eu-central-1': "apigateway.eu-central-1.aliyuncs.com",
      'ap-south-1': "apigateway.ap-south-1.aliyuncs.com",
      'me-east-1': "apigateway.me-east-1.aliyuncs.com",
      'me-central-1': "apigateway.me-central-1.aliyuncs.com",
      'cn-hangzhou-finance': "apigateway.cn-hangzhou-finance.aliyuncs.com",
      'cn-shanghai-finance-1': "apigateway.cn-shanghai-finance-1.aliyuncs.com",
      'cn-shenzhen-finance-1': "apigateway.cn-shenzhen-finance-1.aliyuncs.com",
      'cn-north-2-gov-1': "apigateway.cn-north-2-gov-1.aliyuncs.com",
      'ap-northeast-2-pop': "apigateway.aliyuncs.com",
      'cn-beijing-finance-1': "apigateway.cn-beijing-finance-1.aliyuncs.com",
      'cn-beijing-finance-pop': "apigateway.aliyuncs.com",
      'cn-beijing-gov-1': "apigateway.aliyuncs.com",
      'cn-beijing-nu16-b01': "apigateway.aliyuncs.com",
      'cn-edge-1': "apigateway.aliyuncs.com",
      'cn-fujian': "apigateway.aliyuncs.com",
      'cn-haidian-cm12-c01': "apigateway.aliyuncs.com",
      'cn-hangzhou-bj-b01': "apigateway.aliyuncs.com",
      'cn-hangzhou-internal-prod-1': "apigateway.aliyuncs.com",
      'cn-hangzhou-internal-test-1': "apigateway.aliyuncs.com",
      'cn-hangzhou-internal-test-2': "apigateway.aliyuncs.com",
      'cn-hangzhou-internal-test-3': "apigateway.aliyuncs.com",
      'cn-hangzhou-test-306': "apigateway.aliyuncs.com",
      'cn-hongkong-finance-pop': "apigateway.aliyuncs.com",
      'cn-huhehaote-nebula-1': "apigateway.aliyuncs.com",
      'cn-qingdao-nebula': "apigateway.aliyuncs.com",
      'cn-shanghai-et15-b01': "apigateway.aliyuncs.com",
      'cn-shanghai-et2-b01': "apigateway.aliyuncs.com",
      'cn-shanghai-inner': "apigateway.cn-shanghai-inner.aliyuncs.com",
      'cn-shanghai-internal-test-1': "apigateway.aliyuncs.com",
      'cn-shenzhen-inner': "apigateway.aliyuncs.com",
      'cn-shenzhen-st4-d01': "apigateway.aliyuncs.com",
      'cn-shenzhen-su18-b01': "apigateway.aliyuncs.com",
      'cn-wuhan': "apigateway.aliyuncs.com",
      'cn-yushanfang': "apigateway.aliyuncs.com",
      'cn-zhangbei': "apigateway.aliyuncs.com",
      'cn-zhangbei-na61-b01': "apigateway.aliyuncs.com",
      'cn-zhangjiakou-na62-a01': "apigateway.aliyuncs.com",
      'cn-zhengzhou-nebula-1': "apigateway.aliyuncs.com",
      'eu-west-1-oxs': "apigateway.aliyuncs.com",
      'rus-west-1-pop': "apigateway.aliyuncs.com",
    };
    this.checkConfig(config);
    this._endpoint = this.getEndpoint("cloudapi", this._regionId, this._endpointRule, this._network, this._suffix, this._endpointMap, this._endpoint);
  }


  getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: {[key: string ]: string}, endpoint: string): string {
    if (!Util.empty(endpoint)) {
      return endpoint;
    }

    if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
      return endpointMap[regionId];
    }

    return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
  }

  /**
   * Unpublishes a specified API from a specified runtime environment.
   * 
   * @remarks
   *   This operation is intended for API providers and is the opposite of DeployApi.
   * *   An API can be unpublished from a specified runtime environment in under 5 seconds.
   * *   An unpublished API cannot be called in the specified runtime environment.
   * 
   * @param request - AbolishApiRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AbolishApiResponse
   */
  async abolishApiWithOptions(request: AbolishApiRequest, runtime: $Util.RuntimeOptions): Promise<AbolishApiResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.apiId)) {
      query["ApiId"] = request.apiId;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.stageName)) {
      query["StageName"] = request.stageName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AbolishApi",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AbolishApiResponse>(await this.callApi(params, req, runtime), new AbolishApiResponse({}));
  }

  /**
   * Unpublishes a specified API from a specified runtime environment.
   * 
   * @remarks
   *   This operation is intended for API providers and is the opposite of DeployApi.
   * *   An API can be unpublished from a specified runtime environment in under 5 seconds.
   * *   An unpublished API cannot be called in the specified runtime environment.
   * 
   * @param request - AbolishApiRequest
   * @returns AbolishApiResponse
   */
  async abolishApi(request: AbolishApiRequest): Promise<AbolishApiResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.abolishApiWithOptions(request, runtime);
  }

  /**
   * This feature provides instance-level access control capabilities for dedicated instances. Adds an IP address entry to the access control polocy of an instance.
   * 
   * @param request - AddAccessControlListEntryRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddAccessControlListEntryResponse
   */
  async addAccessControlListEntryWithOptions(request: AddAccessControlListEntryRequest, runtime: $Util.RuntimeOptions): Promise<AddAccessControlListEntryResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.aclEntrys)) {
      query["AclEntrys"] = request.aclEntrys;
    }

    if (!Util.isUnset(request.aclId)) {
      query["AclId"] = request.aclId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddAccessControlListEntry",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddAccessControlListEntryResponse>(await this.callApi(params, req, runtime), new AddAccessControlListEntryResponse({}));
  }

  /**
   * This feature provides instance-level access control capabilities for dedicated instances. Adds an IP address entry to the access control polocy of an instance.
   * 
   * @param request - AddAccessControlListEntryRequest
   * @returns AddAccessControlListEntryResponse
   */
  async addAccessControlListEntry(request: AddAccessControlListEntryRequest): Promise<AddAccessControlListEntryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addAccessControlListEntryWithOptions(request, runtime);
  }

  /**
   * Adds a policy to an existing ACL.
   * 
   * @remarks
   * When you call this operation, note that:
   * *   This operation is intended for API providers.
   * *   An added policy immediately takes effect on all APIs that are bound to the access control list (ACL).
   * *   A maximum of 100 policies can be added to an ACL.
   * 
   * @param request - AddIpControlPolicyItemRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddIpControlPolicyItemResponse
   */
  async addIpControlPolicyItemWithOptions(request: AddIpControlPolicyItemRequest, runtime: $Util.RuntimeOptions): Promise<AddIpControlPolicyItemResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.cidrIp)) {
      query["CidrIp"] = request.cidrIp;
    }

    if (!Util.isUnset(request.ipControlId)) {
      query["IpControlId"] = request.ipControlId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddIpControlPolicyItem",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddIpControlPolicyItemResponse>(await this.callApi(params, req, runtime), new AddIpControlPolicyItemResponse({}));
  }

  /**
   * Adds a policy to an existing ACL.
   * 
   * @remarks
   * When you call this operation, note that:
   * *   This operation is intended for API providers.
   * *   An added policy immediately takes effect on all APIs that are bound to the access control list (ACL).
   * *   A maximum of 100 policies can be added to an ACL.
   * 
   * @param request - AddIpControlPolicyItemRequest
   * @returns AddIpControlPolicyItemResponse
   */
  async addIpControlPolicyItem(request: AddIpControlPolicyItemRequest): Promise<AddIpControlPolicyItemResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addIpControlPolicyItemWithOptions(request, runtime);
  }

  /**
   * Adds a custom special policy to a specified throttling policy.
   * 
   * @remarks
   *   This API is intended for API providers.
   * *   If the input SpecialKey already exists, the previous configuration is overwritten. Use caution when calling this operation.
   * *   Special throttling policies must be added to an existing throttling policy, and can take effect on all the APIs to which the throttling policy is bound.
   * 
   * @param request - AddTrafficSpecialControlRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddTrafficSpecialControlResponse
   */
  async addTrafficSpecialControlWithOptions(request: AddTrafficSpecialControlRequest, runtime: $Util.RuntimeOptions): Promise<AddTrafficSpecialControlResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.specialKey)) {
      query["SpecialKey"] = request.specialKey;
    }

    if (!Util.isUnset(request.specialType)) {
      query["SpecialType"] = request.specialType;
    }

    if (!Util.isUnset(request.trafficControlId)) {
      query["TrafficControlId"] = request.trafficControlId;
    }

    if (!Util.isUnset(request.trafficValue)) {
      query["TrafficValue"] = request.trafficValue;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddTrafficSpecialControl",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddTrafficSpecialControlResponse>(await this.callApi(params, req, runtime), new AddTrafficSpecialControlResponse({}));
  }

  /**
   * Adds a custom special policy to a specified throttling policy.
   * 
   * @remarks
   *   This API is intended for API providers.
   * *   If the input SpecialKey already exists, the previous configuration is overwritten. Use caution when calling this operation.
   * *   Special throttling policies must be added to an existing throttling policy, and can take effect on all the APIs to which the throttling policy is bound.
   * 
   * @param request - AddTrafficSpecialControlRequest
   * @returns AddTrafficSpecialControlResponse
   */
  async addTrafficSpecialControl(request: AddTrafficSpecialControlRequest): Promise<AddTrafficSpecialControlResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addTrafficSpecialControlWithOptions(request, runtime);
  }

  /**
   * 专享实例关联内网域名解析记录
   * 
   * @param tmpReq - AssociateInstanceWithPrivateDNSRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AssociateInstanceWithPrivateDNSResponse
   */
  async associateInstanceWithPrivateDNSWithOptions(tmpReq: AssociateInstanceWithPrivateDNSRequest, runtime: $Util.RuntimeOptions): Promise<AssociateInstanceWithPrivateDNSResponse> {
    Util.validateModel(tmpReq);
    let request = new AssociateInstanceWithPrivateDNSShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.intranetDomains)) {
      request.intranetDomainsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.intranetDomains, "IntranetDomains", "json");
    }

    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.intranetDomainsShrink)) {
      body["IntranetDomains"] = request.intranetDomainsShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "AssociateInstanceWithPrivateDNS",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AssociateInstanceWithPrivateDNSResponse>(await this.callApi(params, req, runtime), new AssociateInstanceWithPrivateDNSResponse({}));
  }

  /**
   * 专享实例关联内网域名解析记录
   * 
   * @param request - AssociateInstanceWithPrivateDNSRequest
   * @returns AssociateInstanceWithPrivateDNSResponse
   */
  async associateInstanceWithPrivateDNS(request: AssociateInstanceWithPrivateDNSRequest): Promise<AssociateInstanceWithPrivateDNSResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.associateInstanceWithPrivateDNSWithOptions(request, runtime);
  }

  /**
   * Attaches APIs to an API product. If the API product does not exist, the system automatically creates the API product.
   * 
   * @param request - AttachApiProductRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AttachApiProductResponse
   */
  async attachApiProductWithOptions(request: AttachApiProductRequest, runtime: $Util.RuntimeOptions): Promise<AttachApiProductResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.apiProductId)) {
      query["ApiProductId"] = request.apiProductId;
    }

    if (!Util.isUnset(request.apis)) {
      query["Apis"] = request.apis;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AttachApiProduct",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AttachApiProductResponse>(await this.callApi(params, req, runtime), new AttachApiProductResponse({}));
  }

  /**
   * Attaches APIs to an API product. If the API product does not exist, the system automatically creates the API product.
   * 
   * @param request - AttachApiProductRequest
   * @returns AttachApiProductResponse
   */
  async attachApiProduct(request: AttachApiProductRequest): Promise<AttachApiProductResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.attachApiProductWithOptions(request, runtime);
  }

  /**
   * Binds a plug-in to an API.
   * 
   * @remarks
   *   This operation is intended for API providers.
   * *   You can only bind plug-ins to published APIs.
   * *   The plug-in takes effect immediately after it is bound to an API.
   * *   If you bind a different plug-in to an API, this plug-in takes effect immediately.
   * 
   * @param request - AttachPluginRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AttachPluginResponse
   */
  async attachPluginWithOptions(request: AttachPluginRequest, runtime: $Util.RuntimeOptions): Promise<AttachPluginResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.apiId)) {
      query["ApiId"] = request.apiId;
    }

    if (!Util.isUnset(request.apiIds)) {
      query["ApiIds"] = request.apiIds;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.pluginId)) {
      query["PluginId"] = request.pluginId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.stageName)) {
      query["StageName"] = request.stageName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AttachPlugin",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AttachPluginResponse>(await this.callApi(params, req, runtime), new AttachPluginResponse({}));
  }

  /**
   * Binds a plug-in to an API.
   * 
   * @remarks
   *   This operation is intended for API providers.
   * *   You can only bind plug-ins to published APIs.
   * *   The plug-in takes effect immediately after it is bound to an API.
   * *   If you bind a different plug-in to an API, this plug-in takes effect immediately.
   * 
   * @param request - AttachPluginRequest
   * @returns AttachPluginResponse
   */
  async attachPlugin(request: AttachPluginRequest): Promise<AttachPluginResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.attachPluginWithOptions(request, runtime);
  }

  /**
   * Unpublishes multiple published APIs at a time.
   * 
   * @param request - BatchAbolishApisRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns BatchAbolishApisResponse
   */
  async batchAbolishApisWithOptions(request: BatchAbolishApisRequest, runtime: $Util.RuntimeOptions): Promise<BatchAbolishApisResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.api)) {
      query["Api"] = request.api;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchAbolishApis",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchAbolishApisResponse>(await this.callApi(params, req, runtime), new BatchAbolishApisResponse({}));
  }

  /**
   * Unpublishes multiple published APIs at a time.
   * 
   * @param request - BatchAbolishApisRequest
   * @returns BatchAbolishApisResponse
   */
  async batchAbolishApis(request: BatchAbolishApisRequest): Promise<BatchAbolishApisResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchAbolishApisWithOptions(request, runtime);
  }

  /**
   * Publishes multiple APIs at a time.
   * 
   * @param request - BatchDeployApisRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns BatchDeployApisResponse
   */
  async batchDeployApisWithOptions(request: BatchDeployApisRequest, runtime: $Util.RuntimeOptions): Promise<BatchDeployApisResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.api)) {
      query["Api"] = request.api;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.stageName)) {
      query["StageName"] = request.stageName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchDeployApis",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchDeployApisResponse>(await this.callApi(params, req, runtime), new BatchDeployApisResponse({}));
  }

  /**
   * Publishes multiple APIs at a time.
   * 
   * @param request - BatchDeployApisRequest
   * @returns BatchDeployApisResponse
   */
  async batchDeployApis(request: BatchDeployApisRequest): Promise<BatchDeployApisResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchDeployApisWithOptions(request, runtime);
  }

  /**
   * This feature provides instance-level access control capabilities for dedicated instances. Creates an Access Control List (ACL). Each user is allowed to create five ACLs in each region.
   * 
   * @param request - CreateAccessControlListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateAccessControlListResponse
   */
  async createAccessControlListWithOptions(request: CreateAccessControlListRequest, runtime: $Util.RuntimeOptions): Promise<CreateAccessControlListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.aclName)) {
      query["AclName"] = request.aclName;
    }

    if (!Util.isUnset(request.addressIPVersion)) {
      query["AddressIPVersion"] = request.addressIPVersion;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateAccessControlList",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateAccessControlListResponse>(await this.callApi(params, req, runtime), new CreateAccessControlListResponse({}));
  }

  /**
   * This feature provides instance-level access control capabilities for dedicated instances. Creates an Access Control List (ACL). Each user is allowed to create five ACLs in each region.
   * 
   * @param request - CreateAccessControlListRequest
   * @returns CreateAccessControlListResponse
   */
  async createAccessControlList(request: CreateAccessControlListRequest): Promise<CreateAccessControlListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createAccessControlListWithOptions(request, runtime);
  }

  /**
   * Creates an API.
   * 
   * @remarks
   *   This operation is intended for API providers.
   * *   The name of an API must be unique within an API group.
   * *   A request path must be unique within an API group.
   * *   The QPS limit on this operation is 50 per user.
   * 
   * @param request - CreateApiRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateApiResponse
   */
  async createApiWithOptions(request: CreateApiRequest, runtime: $Util.RuntimeOptions): Promise<CreateApiResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.allowSignatureMethod)) {
      query["AllowSignatureMethod"] = request.allowSignatureMethod;
    }

    if (!Util.isUnset(request.apiName)) {
      query["ApiName"] = request.apiName;
    }

    if (!Util.isUnset(request.appCodeAuthType)) {
      query["AppCodeAuthType"] = request.appCodeAuthType;
    }

    if (!Util.isUnset(request.authType)) {
      query["AuthType"] = request.authType;
    }

    if (!Util.isUnset(request.backendEnable)) {
      query["BackendEnable"] = request.backendEnable;
    }

    if (!Util.isUnset(request.backendId)) {
      query["BackendId"] = request.backendId;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.disableInternet)) {
      query["DisableInternet"] = request.disableInternet;
    }

    if (!Util.isUnset(request.forceNonceCheck)) {
      query["ForceNonceCheck"] = request.forceNonceCheck;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.openIdConnectConfig)) {
      query["OpenIdConnectConfig"] = request.openIdConnectConfig;
    }

    if (!Util.isUnset(request.requestConfig)) {
      query["RequestConfig"] = request.requestConfig;
    }

    if (!Util.isUnset(request.resultBodyModel)) {
      query["ResultBodyModel"] = request.resultBodyModel;
    }

    if (!Util.isUnset(request.resultType)) {
      query["ResultType"] = request.resultType;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.serviceConfig)) {
      query["ServiceConfig"] = request.serviceConfig;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!Util.isUnset(request.visibility)) {
      query["Visibility"] = request.visibility;
    }

    if (!Util.isUnset(request.webSocketApiType)) {
      query["WebSocketApiType"] = request.webSocketApiType;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.constantParameters)) {
      body["ConstantParameters"] = request.constantParameters;
    }

    if (!Util.isUnset(request.errorCodeSamples)) {
      body["ErrorCodeSamples"] = request.errorCodeSamples;
    }

    if (!Util.isUnset(request.failResultSample)) {
      body["FailResultSample"] = request.failResultSample;
    }

    if (!Util.isUnset(request.requestParameters)) {
      body["RequestParameters"] = request.requestParameters;
    }

    if (!Util.isUnset(request.resultDescriptions)) {
      body["ResultDescriptions"] = request.resultDescriptions;
    }

    if (!Util.isUnset(request.resultSample)) {
      body["ResultSample"] = request.resultSample;
    }

    if (!Util.isUnset(request.serviceParameters)) {
      body["ServiceParameters"] = request.serviceParameters;
    }

    if (!Util.isUnset(request.serviceParametersMap)) {
      body["ServiceParametersMap"] = request.serviceParametersMap;
    }

    if (!Util.isUnset(request.systemParameters)) {
      body["SystemParameters"] = request.systemParameters;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateApi",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateApiResponse>(await this.callApi(params, req, runtime), new CreateApiResponse({}));
  }

  /**
   * Creates an API.
   * 
   * @remarks
   *   This operation is intended for API providers.
   * *   The name of an API must be unique within an API group.
   * *   A request path must be unique within an API group.
   * *   The QPS limit on this operation is 50 per user.
   * 
   * @param request - CreateApiRequest
   * @returns CreateApiResponse
   */
  async createApi(request: CreateApiRequest): Promise<CreateApiResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createApiWithOptions(request, runtime);
  }

  /**
   * @param request - CreateApiGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateApiGroupResponse
   */
  async createApiGroupWithOptions(request: CreateApiGroupRequest, runtime: $Util.RuntimeOptions): Promise<CreateApiGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.basePath)) {
      query["BasePath"] = request.basePath;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.groupName)) {
      query["GroupName"] = request.groupName;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateApiGroup",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateApiGroupResponse>(await this.callApi(params, req, runtime), new CreateApiGroupResponse({}));
  }

  /**
   * @param request - CreateApiGroupRequest
   * @returns CreateApiGroupResponse
   */
  async createApiGroup(request: CreateApiGroupRequest): Promise<CreateApiGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createApiGroupWithOptions(request, runtime);
  }

  /**
   * Adds a variable to an environment.
   * 
   * @remarks
   *   This operation is intended for API providers.
   * 
   * @param request - CreateApiStageVariableRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateApiStageVariableResponse
   */
  async createApiStageVariableWithOptions(request: CreateApiStageVariableRequest, runtime: $Util.RuntimeOptions): Promise<CreateApiStageVariableResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.stageId)) {
      query["StageId"] = request.stageId;
    }

    if (!Util.isUnset(request.stageRouteModel)) {
      query["StageRouteModel"] = request.stageRouteModel;
    }

    if (!Util.isUnset(request.supportRoute)) {
      query["SupportRoute"] = request.supportRoute;
    }

    if (!Util.isUnset(request.variableName)) {
      query["VariableName"] = request.variableName;
    }

    if (!Util.isUnset(request.variableValue)) {
      query["VariableValue"] = request.variableValue;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateApiStageVariable",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateApiStageVariableResponse>(await this.callApi(params, req, runtime), new CreateApiStageVariableResponse({}));
  }

  /**
   * Adds a variable to an environment.
   * 
   * @remarks
   *   This operation is intended for API providers.
   * 
   * @param request - CreateApiStageVariableRequest
   * @returns CreateApiStageVariableResponse
   */
  async createApiStageVariable(request: CreateApiStageVariableRequest): Promise<CreateApiStageVariableResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createApiStageVariableWithOptions(request, runtime);
  }

  /**
   * Creates an application for calling APIs in API Gateway.
   * 
   * @remarks
   *   This operation is intended for API callers.
   * *   Each application has a key-value pair which is used for identity verification when you call an API.
   * *   An application must be authorized to call an API.
   * *   Each application has only one key-value pair, which can be reset if the pair is leaked.
   * *   A maximum of 1,000 applications can be created for each Alibaba Cloud account.
   * *   You can call this operation up to 50 times per second per account.
   * 
   * @param request - CreateAppRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateAppResponse
   */
  async createAppWithOptions(request: CreateAppRequest, runtime: $Util.RuntimeOptions): Promise<CreateAppResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appCode)) {
      query["AppCode"] = request.appCode;
    }

    if (!Util.isUnset(request.appKey)) {
      query["AppKey"] = request.appKey;
    }

    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.appSecret)) {
      query["AppSecret"] = request.appSecret;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.extend)) {
      query["Extend"] = request.extend;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateApp",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateAppResponse>(await this.callApi(params, req, runtime), new CreateAppResponse({}));
  }

  /**
   * Creates an application for calling APIs in API Gateway.
   * 
   * @remarks
   *   This operation is intended for API callers.
   * *   Each application has a key-value pair which is used for identity verification when you call an API.
   * *   An application must be authorized to call an API.
   * *   Each application has only one key-value pair, which can be reset if the pair is leaked.
   * *   A maximum of 1,000 applications can be created for each Alibaba Cloud account.
   * *   You can call this operation up to 50 times per second per account.
   * 
   * @param request - CreateAppRequest
   * @returns CreateAppResponse
   */
  async createApp(request: CreateAppRequest): Promise<CreateAppResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createAppWithOptions(request, runtime);
  }

  /**
   * Adds an AppCode to an application.
   * 
   * @param request - CreateAppCodeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateAppCodeResponse
   */
  async createAppCodeWithOptions(request: CreateAppCodeRequest, runtime: $Util.RuntimeOptions): Promise<CreateAppCodeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appCode)) {
      query["AppCode"] = request.appCode;
    }

    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateAppCode",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateAppCodeResponse>(await this.callApi(params, req, runtime), new CreateAppCodeResponse({}));
  }

  /**
   * Adds an AppCode to an application.
   * 
   * @param request - CreateAppCodeRequest
   * @returns CreateAppCodeResponse
   */
  async createAppCode(request: CreateAppCodeRequest): Promise<CreateAppCodeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createAppCodeWithOptions(request, runtime);
  }

  /**
   * Adds an AppKey and AppSecret pair to an application.
   * 
   * @param request - CreateAppKeyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateAppKeyResponse
   */
  async createAppKeyWithOptions(request: CreateAppKeyRequest, runtime: $Util.RuntimeOptions): Promise<CreateAppKeyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.appKey)) {
      query["AppKey"] = request.appKey;
    }

    if (!Util.isUnset(request.appSecret)) {
      query["AppSecret"] = request.appSecret;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateAppKey",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateAppKeyResponse>(await this.callApi(params, req, runtime), new CreateAppKeyResponse({}));
  }

  /**
   * Adds an AppKey and AppSecret pair to an application.
   * 
   * @param request - CreateAppKeyRequest
   * @returns CreateAppKeyResponse
   */
  async createAppKey(request: CreateAppKeyRequest): Promise<CreateAppKeyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createAppKeyWithOptions(request, runtime);
  }

  /**
   * Creates a backend service in API Gateway.
   * 
   * @param request - CreateBackendRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateBackendResponse
   */
  async createBackendWithOptions(request: CreateBackendRequest, runtime: $Util.RuntimeOptions): Promise<CreateBackendResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.backendName)) {
      query["BackendName"] = request.backendName;
    }

    if (!Util.isUnset(request.backendType)) {
      query["BackendType"] = request.backendType;
    }

    if (!Util.isUnset(request.createEventBridgeServiceLinkedRole)) {
      query["CreateEventBridgeServiceLinkedRole"] = request.createEventBridgeServiceLinkedRole;
    }

    if (!Util.isUnset(request.createSlr)) {
      query["CreateSlr"] = request.createSlr;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateBackend",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateBackendResponse>(await this.callApi(params, req, runtime), new CreateBackendResponse({}));
  }

  /**
   * Creates a backend service in API Gateway.
   * 
   * @param request - CreateBackendRequest
   * @returns CreateBackendResponse
   */
  async createBackend(request: CreateBackendRequest): Promise<CreateBackendResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createBackendWithOptions(request, runtime);
  }

  /**
   * 创建后端服务在环境上的配置
   * 
   * @param request - CreateBackendModelRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateBackendModelResponse
   */
  async createBackendModelWithOptions(request: CreateBackendModelRequest, runtime: $Util.RuntimeOptions): Promise<CreateBackendModelResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.backendId)) {
      query["BackendId"] = request.backendId;
    }

    if (!Util.isUnset(request.backendModelData)) {
      query["BackendModelData"] = request.backendModelData;
    }

    if (!Util.isUnset(request.backendType)) {
      query["BackendType"] = request.backendType;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.stageName)) {
      query["StageName"] = request.stageName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateBackendModel",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateBackendModelResponse>(await this.callApi(params, req, runtime), new CreateBackendModelResponse({}));
  }

  /**
   * 创建后端服务在环境上的配置
   * 
   * @param request - CreateBackendModelRequest
   * @returns CreateBackendModelResponse
   */
  async createBackendModel(request: CreateBackendModelRequest): Promise<CreateBackendModelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createBackendModelWithOptions(request, runtime);
  }

  /**
   * Creates a custom dataset.
   * 
   * @param request - CreateDatasetRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateDatasetResponse
   */
  async createDatasetWithOptions(request: CreateDatasetRequest, runtime: $Util.RuntimeOptions): Promise<CreateDatasetResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.datasetName)) {
      query["DatasetName"] = request.datasetName;
    }

    if (!Util.isUnset(request.datasetType)) {
      query["DatasetType"] = request.datasetType;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateDataset",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateDatasetResponse>(await this.callApi(params, req, runtime), new CreateDatasetResponse({}));
  }

  /**
   * Creates a custom dataset.
   * 
   * @param request - CreateDatasetRequest
   * @returns CreateDatasetResponse
   */
  async createDataset(request: CreateDatasetRequest): Promise<CreateDatasetResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDatasetWithOptions(request, runtime);
  }

  /**
   * 创建自定义数据集条目
   * 
   * @param request - CreateDatasetItemRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateDatasetItemResponse
   */
  async createDatasetItemWithOptions(request: CreateDatasetItemRequest, runtime: $Util.RuntimeOptions): Promise<CreateDatasetItemResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.datasetId)) {
      query["DatasetId"] = request.datasetId;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.expiredTime)) {
      query["ExpiredTime"] = request.expiredTime;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.value)) {
      query["Value"] = request.value;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateDatasetItem",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateDatasetItemResponse>(await this.callApi(params, req, runtime), new CreateDatasetItemResponse({}));
  }

  /**
   * 创建自定义数据集条目
   * 
   * @param request - CreateDatasetItemRequest
   * @returns CreateDatasetItemResponse
   */
  async createDatasetItem(request: CreateDatasetItemRequest): Promise<CreateDatasetItemResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDatasetItemWithOptions(request, runtime);
  }

  /**
   * Creates an API Gateway instance.
   * 
   * @param request - CreateInstanceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateInstanceResponse
   */
  async createInstanceWithOptions(request: CreateInstanceRequest, runtime: $Util.RuntimeOptions): Promise<CreateInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.autoPay)) {
      query["AutoPay"] = request.autoPay;
    }

    if (!Util.isUnset(request.chargeType)) {
      query["ChargeType"] = request.chargeType;
    }

    if (!Util.isUnset(request.duration)) {
      query["Duration"] = request.duration;
    }

    if (!Util.isUnset(request.httpsPolicy)) {
      query["HttpsPolicy"] = request.httpsPolicy;
    }

    if (!Util.isUnset(request.instanceCidr)) {
      query["InstanceCidr"] = request.instanceCidr;
    }

    if (!Util.isUnset(request.instanceName)) {
      query["InstanceName"] = request.instanceName;
    }

    if (!Util.isUnset(request.instanceSpec)) {
      query["InstanceSpec"] = request.instanceSpec;
    }

    if (!Util.isUnset(request.instanceType)) {
      query["InstanceType"] = request.instanceType;
    }

    if (!Util.isUnset(request.pricingCycle)) {
      query["PricingCycle"] = request.pricingCycle;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!Util.isUnset(request.token)) {
      query["Token"] = request.token;
    }

    if (!Util.isUnset(request.userVpcId)) {
      query["UserVpcId"] = request.userVpcId;
    }

    if (!Util.isUnset(request.zoneId)) {
      query["ZoneId"] = request.zoneId;
    }

    if (!Util.isUnset(request.zoneVSwitchSecurityGroup)) {
      query["ZoneVSwitchSecurityGroup"] = request.zoneVSwitchSecurityGroup;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateInstance",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateInstanceResponse>(await this.callApi(params, req, runtime), new CreateInstanceResponse({}));
  }

  /**
   * Creates an API Gateway instance.
   * 
   * @param request - CreateInstanceRequest
   * @returns CreateInstanceResponse
   */
  async createInstance(request: CreateInstanceRequest): Promise<CreateInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createInstanceWithOptions(request, runtime);
  }

  /**
   * @param request - CreateIntranetDomainRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateIntranetDomainResponse
   */
  async createIntranetDomainWithOptions(request: CreateIntranetDomainRequest, runtime: $Util.RuntimeOptions): Promise<CreateIntranetDomainResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateIntranetDomain",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateIntranetDomainResponse>(await this.callApi(params, req, runtime), new CreateIntranetDomainResponse({}));
  }

  /**
   * @param request - CreateIntranetDomainRequest
   * @returns CreateIntranetDomainResponse
   */
  async createIntranetDomain(request: CreateIntranetDomainRequest): Promise<CreateIntranetDomainResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createIntranetDomainWithOptions(request, runtime);
  }

  /**
   * Creates an access control list (ACL) in a region.
   * 
   * @remarks
   *   This operation is intended for API providers.
   * *   An ACL must be bound to an API to take effect. After an ACL is bound to an API, the ACL takes effect on the API immediately.
   * *   You can add policies to an ACL when you create the ACL.
   * *   If an ACL does not have any policy, the ACL is ineffective.
   * 
   * @param request - CreateIpControlRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateIpControlResponse
   */
  async createIpControlWithOptions(request: CreateIpControlRequest, runtime: $Util.RuntimeOptions): Promise<CreateIpControlResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.ipControlName)) {
      query["IpControlName"] = request.ipControlName;
    }

    if (!Util.isUnset(request.ipControlPolicys)) {
      query["IpControlPolicys"] = request.ipControlPolicys;
    }

    if (!Util.isUnset(request.ipControlType)) {
      query["IpControlType"] = request.ipControlType;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateIpControl",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateIpControlResponse>(await this.callApi(params, req, runtime), new CreateIpControlResponse({}));
  }

  /**
   * Creates an access control list (ACL) in a region.
   * 
   * @remarks
   *   This operation is intended for API providers.
   * *   An ACL must be bound to an API to take effect. After an ACL is bound to an API, the ACL takes effect on the API immediately.
   * *   You can add policies to an ACL when you create the ACL.
   * *   If an ACL does not have any policy, the ACL is ineffective.
   * 
   * @param request - CreateIpControlRequest
   * @returns CreateIpControlResponse
   */
  async createIpControl(request: CreateIpControlRequest): Promise<CreateIpControlResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createIpControlWithOptions(request, runtime);
  }

  /**
   * @param request - CreateLogConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateLogConfigResponse
   */
  async createLogConfigWithOptions(request: CreateLogConfigRequest, runtime: $Util.RuntimeOptions): Promise<CreateLogConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.logType)) {
      query["LogType"] = request.logType;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.slsLogStore)) {
      query["SlsLogStore"] = request.slsLogStore;
    }

    if (!Util.isUnset(request.slsProject)) {
      query["SlsProject"] = request.slsProject;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateLogConfig",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateLogConfigResponse>(await this.callApi(params, req, runtime), new CreateLogConfigResponse({}));
  }

  /**
   * @param request - CreateLogConfigRequest
   * @returns CreateLogConfigResponse
   */
  async createLogConfig(request: CreateLogConfigRequest): Promise<CreateLogConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createLogConfigWithOptions(request, runtime);
  }

  /**
   * Creates a model for an API group.
   * 
   * @remarks
   *   For more information about the model definition, see [JSON Schema Draft 4](https://tools.ietf.org/html/draft-zyp-json-schema-04?spm=a2c4g.11186623.2.10.2e977ff7p4BpQd).
   * *   JSON Schema supports only element attributes of the Object type.
   * 
   * @param request - CreateModelRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateModelResponse
   */
  async createModelWithOptions(request: CreateModelRequest, runtime: $Util.RuntimeOptions): Promise<CreateModelResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.modelName)) {
      query["ModelName"] = request.modelName;
    }

    if (!Util.isUnset(request.schema)) {
      query["Schema"] = request.schema;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateModel",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateModelResponse>(await this.callApi(params, req, runtime), new CreateModelResponse({}));
  }

  /**
   * Creates a model for an API group.
   * 
   * @remarks
   *   For more information about the model definition, see [JSON Schema Draft 4](https://tools.ietf.org/html/draft-zyp-json-schema-04?spm=a2c4g.11186623.2.10.2e977ff7p4BpQd).
   * *   JSON Schema supports only element attributes of the Object type.
   * 
   * @param request - CreateModelRequest
   * @returns CreateModelResponse
   */
  async createModel(request: CreateModelRequest): Promise<CreateModelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createModelWithOptions(request, runtime);
  }

  /**
   * Enables CloudMonitor alerting for a specified API group.
   * 
   * @param request - CreateMonitorGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateMonitorGroupResponse
   */
  async createMonitorGroupWithOptions(request: CreateMonitorGroupRequest, runtime: $Util.RuntimeOptions): Promise<CreateMonitorGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.auth)) {
      query["Auth"] = request.auth;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.rawMonitorGroupId)) {
      query["RawMonitorGroupId"] = request.rawMonitorGroupId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateMonitorGroup",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateMonitorGroupResponse>(await this.callApi(params, req, runtime), new CreateMonitorGroupResponse({}));
  }

  /**
   * Enables CloudMonitor alerting for a specified API group.
   * 
   * @param request - CreateMonitorGroupRequest
   * @returns CreateMonitorGroupResponse
   */
  async createMonitorGroup(request: CreateMonitorGroupRequest): Promise<CreateMonitorGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createMonitorGroupWithOptions(request, runtime);
  }

  /**
   * Creates a plug-in.
   * 
   * @remarks
   *   This operation is intended for API providers.
   * *   The number of plug-ins of the same type that each user can create is limited. Different limits apply to different plug-in types.
   * *   The plug-in definitions for advanced features are restricted.
   * *   Plug-ins must be bound to APIs to take effect. After a plug-in is bound, it takes effect on that API immediately.
   * 
   * @param request - CreatePluginRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreatePluginResponse
   */
  async createPluginWithOptions(request: CreatePluginRequest, runtime: $Util.RuntimeOptions): Promise<CreatePluginResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.pluginData)) {
      query["PluginData"] = request.pluginData;
    }

    if (!Util.isUnset(request.pluginName)) {
      query["PluginName"] = request.pluginName;
    }

    if (!Util.isUnset(request.pluginType)) {
      query["PluginType"] = request.pluginType;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreatePlugin",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreatePluginResponse>(await this.callApi(params, req, runtime), new CreatePluginResponse({}));
  }

  /**
   * Creates a plug-in.
   * 
   * @remarks
   *   This operation is intended for API providers.
   * *   The number of plug-ins of the same type that each user can create is limited. Different limits apply to different plug-in types.
   * *   The plug-in definitions for advanced features are restricted.
   * *   Plug-ins must be bound to APIs to take effect. After a plug-in is bound, it takes effect on that API immediately.
   * 
   * @param request - CreatePluginRequest
   * @returns CreatePluginResponse
   */
  async createPlugin(request: CreatePluginRequest): Promise<CreatePluginResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createPluginWithOptions(request, runtime);
  }

  /**
   * 创建内网域名解析
   * 
   * @param tmpReq - CreatePrivateDNSRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreatePrivateDNSResponse
   */
  async createPrivateDNSWithOptions(tmpReq: CreatePrivateDNSRequest, runtime: $Util.RuntimeOptions): Promise<CreatePrivateDNSResponse> {
    Util.validateModel(tmpReq);
    let request = new CreatePrivateDNSShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.records)) {
      request.recordsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.records, "Records", "json");
    }

    let query = { };
    if (!Util.isUnset(request.intranetDomain)) {
      query["IntranetDomain"] = request.intranetDomain;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.recordsShrink)) {
      body["Records"] = request.recordsShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreatePrivateDNS",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreatePrivateDNSResponse>(await this.callApi(params, req, runtime), new CreatePrivateDNSResponse({}));
  }

  /**
   * 创建内网域名解析
   * 
   * @param request - CreatePrivateDNSRequest
   * @returns CreatePrivateDNSResponse
   */
  async createPrivateDNS(request: CreatePrivateDNSRequest): Promise<CreatePrivateDNSResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createPrivateDNSWithOptions(request, runtime);
  }

  /**
   * Creates a backend signature key.
   * 
   * @remarks
   *   This API is intended for API providers.
   * *   The API operation only creates a key policy. You must call the binding operation to bind the key to an API.
   * *   After the key is bound to the API, requests sent from API Gateway to the backend service contain signature strings. You can specify whether your backend service verifies these signature strings.
   * *   The QPS limit on this operation is 50 per user.
   * 
   * @param request - CreateSignatureRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateSignatureResponse
   */
  async createSignatureWithOptions(request: CreateSignatureRequest, runtime: $Util.RuntimeOptions): Promise<CreateSignatureResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.signatureKey)) {
      query["SignatureKey"] = request.signatureKey;
    }

    if (!Util.isUnset(request.signatureName)) {
      query["SignatureName"] = request.signatureName;
    }

    if (!Util.isUnset(request.signatureSecret)) {
      query["SignatureSecret"] = request.signatureSecret;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateSignature",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateSignatureResponse>(await this.callApi(params, req, runtime), new CreateSignatureResponse({}));
  }

  /**
   * Creates a backend signature key.
   * 
   * @remarks
   *   This API is intended for API providers.
   * *   The API operation only creates a key policy. You must call the binding operation to bind the key to an API.
   * *   After the key is bound to the API, requests sent from API Gateway to the backend service contain signature strings. You can specify whether your backend service verifies these signature strings.
   * *   The QPS limit on this operation is 50 per user.
   * 
   * @param request - CreateSignatureRequest
   * @returns CreateSignatureResponse
   */
  async createSignature(request: CreateSignatureRequest): Promise<CreateSignatureResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createSignatureWithOptions(request, runtime);
  }

  /**
   * Creates a custom throttling policy.
   * 
   * @remarks
   *   This API is intended for API providers.
   * *   Throttling policies must be bound to APIs to take effect. After a policy is bound to an API, it goes into effect on that API immediately.
   * *   The QPS limit on this operation is 50 per user.
   * 
   * @param request - CreateTrafficControlRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateTrafficControlResponse
   */
  async createTrafficControlWithOptions(request: CreateTrafficControlRequest, runtime: $Util.RuntimeOptions): Promise<CreateTrafficControlResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.apiDefault)) {
      query["ApiDefault"] = request.apiDefault;
    }

    if (!Util.isUnset(request.appDefault)) {
      query["AppDefault"] = request.appDefault;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.trafficControlName)) {
      query["TrafficControlName"] = request.trafficControlName;
    }

    if (!Util.isUnset(request.trafficControlUnit)) {
      query["TrafficControlUnit"] = request.trafficControlUnit;
    }

    if (!Util.isUnset(request.userDefault)) {
      query["UserDefault"] = request.userDefault;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateTrafficControl",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateTrafficControlResponse>(await this.callApi(params, req, runtime), new CreateTrafficControlResponse({}));
  }

  /**
   * Creates a custom throttling policy.
   * 
   * @remarks
   *   This API is intended for API providers.
   * *   Throttling policies must be bound to APIs to take effect. After a policy is bound to an API, it goes into effect on that API immediately.
   * *   The QPS limit on this operation is 50 per user.
   * 
   * @param request - CreateTrafficControlRequest
   * @returns CreateTrafficControlResponse
   */
  async createTrafficControl(request: CreateTrafficControlRequest): Promise<CreateTrafficControlResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createTrafficControlWithOptions(request, runtime);
  }

  /**
   * This feature provides instance-level access control capabilities for dedicated instances. Deletes an access control policy.
   * 
   * @param request - DeleteAccessControlListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteAccessControlListResponse
   */
  async deleteAccessControlListWithOptions(request: DeleteAccessControlListRequest, runtime: $Util.RuntimeOptions): Promise<DeleteAccessControlListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.aclId)) {
      query["AclId"] = request.aclId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteAccessControlList",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteAccessControlListResponse>(await this.callApi(params, req, runtime), new DeleteAccessControlListResponse({}));
  }

  /**
   * This feature provides instance-level access control capabilities for dedicated instances. Deletes an access control policy.
   * 
   * @param request - DeleteAccessControlListRequest
   * @returns DeleteAccessControlListResponse
   */
  async deleteAccessControlList(request: DeleteAccessControlListRequest): Promise<DeleteAccessControlListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteAccessControlListWithOptions(request, runtime);
  }

  /**
   * Deletes all custom special policies of a specified throttling policy.
   * 
   * @remarks
   *   This API is intended for API providers.
   * 
   * @param request - DeleteAllTrafficSpecialControlRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteAllTrafficSpecialControlResponse
   */
  async deleteAllTrafficSpecialControlWithOptions(request: DeleteAllTrafficSpecialControlRequest, runtime: $Util.RuntimeOptions): Promise<DeleteAllTrafficSpecialControlResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.trafficControlId)) {
      query["TrafficControlId"] = request.trafficControlId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteAllTrafficSpecialControl",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteAllTrafficSpecialControlResponse>(await this.callApi(params, req, runtime), new DeleteAllTrafficSpecialControlResponse({}));
  }

  /**
   * Deletes all custom special policies of a specified throttling policy.
   * 
   * @remarks
   *   This API is intended for API providers.
   * 
   * @param request - DeleteAllTrafficSpecialControlRequest
   * @returns DeleteAllTrafficSpecialControlResponse
   */
  async deleteAllTrafficSpecialControl(request: DeleteAllTrafficSpecialControlRequest): Promise<DeleteAllTrafficSpecialControlResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteAllTrafficSpecialControlWithOptions(request, runtime);
  }

  /**
   * Deletes the definition of a specified API.
   * 
   * @remarks
   *   This operation is intended for API providers and cannot be undone after it is complete.
   * *   An API that is running in the runtime environment must be unpublished before you can delete the API.****
   * *   The QPS limit on this operation is 50 per user.
   * 
   * @param request - DeleteApiRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteApiResponse
   */
  async deleteApiWithOptions(request: DeleteApiRequest, runtime: $Util.RuntimeOptions): Promise<DeleteApiResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.apiId)) {
      query["ApiId"] = request.apiId;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteApi",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteApiResponse>(await this.callApi(params, req, runtime), new DeleteApiResponse({}));
  }

  /**
   * Deletes the definition of a specified API.
   * 
   * @remarks
   *   This operation is intended for API providers and cannot be undone after it is complete.
   * *   An API that is running in the runtime environment must be unpublished before you can delete the API.****
   * *   The QPS limit on this operation is 50 per user.
   * 
   * @param request - DeleteApiRequest
   * @returns DeleteApiResponse
   */
  async deleteApi(request: DeleteApiRequest): Promise<DeleteApiResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteApiWithOptions(request, runtime);
  }

  /**
   * Deletes an API group.
   * 
   * @remarks
   *   This operation is intended for API providers.
   * *   An API group that contains APIs cannot be deleted. To delete the API group, you must first delete its APIs.
   * *   After an API group is deleted, the second-level domain name bound to the API group is automatically invalidated.
   * *   If the specified API group does not exist, a success response is returned.
   * *   The QPS limit on this operation is 50 per user.
   * 
   * @param request - DeleteApiGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteApiGroupResponse
   */
  async deleteApiGroupWithOptions(request: DeleteApiGroupRequest, runtime: $Util.RuntimeOptions): Promise<DeleteApiGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteApiGroup",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteApiGroupResponse>(await this.callApi(params, req, runtime), new DeleteApiGroupResponse({}));
  }

  /**
   * Deletes an API group.
   * 
   * @remarks
   *   This operation is intended for API providers.
   * *   An API group that contains APIs cannot be deleted. To delete the API group, you must first delete its APIs.
   * *   After an API group is deleted, the second-level domain name bound to the API group is automatically invalidated.
   * *   If the specified API group does not exist, a success response is returned.
   * *   The QPS limit on this operation is 50 per user.
   * 
   * @param request - DeleteApiGroupRequest
   * @returns DeleteApiGroupResponse
   */
  async deleteApiGroup(request: DeleteApiGroupRequest): Promise<DeleteApiGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteApiGroupWithOptions(request, runtime);
  }

  /**
   * Deletes an API product. Deleting an API product causes the association between APIs and the deleted API product to be deleted as well. Exercise caution when you delete an API product. If any API in the API product is associated with an application, the API product fails to be deleted.
   * 
   * @param request - DeleteApiProductRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteApiProductResponse
   */
  async deleteApiProductWithOptions(request: DeleteApiProductRequest, runtime: $Util.RuntimeOptions): Promise<DeleteApiProductResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.apiProductId)) {
      query["ApiProductId"] = request.apiProductId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteApiProduct",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteApiProductResponse>(await this.callApi(params, req, runtime), new DeleteApiProductResponse({}));
  }

  /**
   * Deletes an API product. Deleting an API product causes the association between APIs and the deleted API product to be deleted as well. Exercise caution when you delete an API product. If any API in the API product is associated with an application, the API product fails to be deleted.
   * 
   * @param request - DeleteApiProductRequest
   * @returns DeleteApiProductResponse
   */
  async deleteApiProduct(request: DeleteApiProductRequest): Promise<DeleteApiProductResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteApiProductWithOptions(request, runtime);
  }

  /**
   * Deletes a specified variable in a specified environment.
   * 
   * @remarks
   *   This operation is intended for API providers.
   * 
   * @param request - DeleteApiStageVariableRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteApiStageVariableResponse
   */
  async deleteApiStageVariableWithOptions(request: DeleteApiStageVariableRequest, runtime: $Util.RuntimeOptions): Promise<DeleteApiStageVariableResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.stageId)) {
      query["StageId"] = request.stageId;
    }

    if (!Util.isUnset(request.variableName)) {
      query["VariableName"] = request.variableName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteApiStageVariable",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteApiStageVariableResponse>(await this.callApi(params, req, runtime), new DeleteApiStageVariableResponse({}));
  }

  /**
   * Deletes a specified variable in a specified environment.
   * 
   * @remarks
   *   This operation is intended for API providers.
   * 
   * @param request - DeleteApiStageVariableRequest
   * @returns DeleteApiStageVariableResponse
   */
  async deleteApiStageVariable(request: DeleteApiStageVariableRequest): Promise<DeleteApiStageVariableResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteApiStageVariableWithOptions(request, runtime);
  }

  /**
   * Deletes an application.
   * 
   * @remarks
   *   This operation is intended for API callers.
   * *   After an application is deleted, the application and its API authorization cannot be restored.
   * *   You can call this operation up to 50 times per second per account.
   * 
   * @param request - DeleteAppRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteAppResponse
   */
  async deleteAppWithOptions(request: DeleteAppRequest, runtime: $Util.RuntimeOptions): Promise<DeleteAppResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteApp",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteAppResponse>(await this.callApi(params, req, runtime), new DeleteAppResponse({}));
  }

  /**
   * Deletes an application.
   * 
   * @remarks
   *   This operation is intended for API callers.
   * *   After an application is deleted, the application and its API authorization cannot be restored.
   * *   You can call this operation up to 50 times per second per account.
   * 
   * @param request - DeleteAppRequest
   * @returns DeleteAppResponse
   */
  async deleteApp(request: DeleteAppRequest): Promise<DeleteAppResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteAppWithOptions(request, runtime);
  }

  /**
   * Deletes the AppCode of an application.
   * 
   * @param request - DeleteAppCodeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteAppCodeResponse
   */
  async deleteAppCodeWithOptions(request: DeleteAppCodeRequest, runtime: $Util.RuntimeOptions): Promise<DeleteAppCodeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appCode)) {
      query["AppCode"] = request.appCode;
    }

    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteAppCode",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteAppCodeResponse>(await this.callApi(params, req, runtime), new DeleteAppCodeResponse({}));
  }

  /**
   * Deletes the AppCode of an application.
   * 
   * @param request - DeleteAppCodeRequest
   * @returns DeleteAppCodeResponse
   */
  async deleteAppCode(request: DeleteAppCodeRequest): Promise<DeleteAppCodeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteAppCodeWithOptions(request, runtime);
  }

  /**
   * Deletes the AppKey and AppSecret of an application.
   * 
   * @param request - DeleteAppKeyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteAppKeyResponse
   */
  async deleteAppKeyWithOptions(request: DeleteAppKeyRequest, runtime: $Util.RuntimeOptions): Promise<DeleteAppKeyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.appKey)) {
      query["AppKey"] = request.appKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteAppKey",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteAppKeyResponse>(await this.callApi(params, req, runtime), new DeleteAppKeyResponse({}));
  }

  /**
   * Deletes the AppKey and AppSecret of an application.
   * 
   * @param request - DeleteAppKeyRequest
   * @returns DeleteAppKeyResponse
   */
  async deleteAppKey(request: DeleteAppKeyRequest): Promise<DeleteAppKeyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteAppKeyWithOptions(request, runtime);
  }

  /**
   * Deletes a backend service.
   * 
   * @param request - DeleteBackendRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteBackendResponse
   */
  async deleteBackendWithOptions(request: DeleteBackendRequest, runtime: $Util.RuntimeOptions): Promise<DeleteBackendResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.backendId)) {
      query["BackendId"] = request.backendId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteBackend",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteBackendResponse>(await this.callApi(params, req, runtime), new DeleteBackendResponse({}));
  }

  /**
   * Deletes a backend service.
   * 
   * @param request - DeleteBackendRequest
   * @returns DeleteBackendResponse
   */
  async deleteBackend(request: DeleteBackendRequest): Promise<DeleteBackendResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteBackendWithOptions(request, runtime);
  }

  /**
   * Deletes the definition of a backend service in an environment. After the definition is deleted, the API that uses the backend service and is published to this environment will be unpublished.
   * 
   * @param request - DeleteBackendModelRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteBackendModelResponse
   */
  async deleteBackendModelWithOptions(request: DeleteBackendModelRequest, runtime: $Util.RuntimeOptions): Promise<DeleteBackendModelResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.backendId)) {
      query["BackendId"] = request.backendId;
    }

    if (!Util.isUnset(request.backendModelId)) {
      query["BackendModelId"] = request.backendModelId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.stageName)) {
      query["StageName"] = request.stageName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteBackendModel",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteBackendModelResponse>(await this.callApi(params, req, runtime), new DeleteBackendModelResponse({}));
  }

  /**
   * Deletes the definition of a backend service in an environment. After the definition is deleted, the API that uses the backend service and is published to this environment will be unpublished.
   * 
   * @param request - DeleteBackendModelRequest
   * @returns DeleteBackendModelResponse
   */
  async deleteBackendModel(request: DeleteBackendModelRequest): Promise<DeleteBackendModelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteBackendModelWithOptions(request, runtime);
  }

  /**
   * 删除自定义数据集
   * 
   * @param request - DeleteDatasetRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteDatasetResponse
   */
  async deleteDatasetWithOptions(request: DeleteDatasetRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDatasetResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.datasetId)) {
      query["DatasetId"] = request.datasetId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteDataset",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteDatasetResponse>(await this.callApi(params, req, runtime), new DeleteDatasetResponse({}));
  }

  /**
   * 删除自定义数据集
   * 
   * @param request - DeleteDatasetRequest
   * @returns DeleteDatasetResponse
   */
  async deleteDataset(request: DeleteDatasetRequest): Promise<DeleteDatasetResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDatasetWithOptions(request, runtime);
  }

  /**
   * Deletes a data entry from a custom dataset.
   * 
   * @param request - DeleteDatasetItemRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteDatasetItemResponse
   */
  async deleteDatasetItemWithOptions(request: DeleteDatasetItemRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDatasetItemResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.datasetId)) {
      query["DatasetId"] = request.datasetId;
    }

    if (!Util.isUnset(request.datasetItemId)) {
      query["DatasetItemId"] = request.datasetItemId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteDatasetItem",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteDatasetItemResponse>(await this.callApi(params, req, runtime), new DeleteDatasetItemResponse({}));
  }

  /**
   * Deletes a data entry from a custom dataset.
   * 
   * @param request - DeleteDatasetItemRequest
   * @returns DeleteDatasetItemResponse
   */
  async deleteDatasetItem(request: DeleteDatasetItemRequest): Promise<DeleteDatasetItemResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDatasetItemWithOptions(request, runtime);
  }

  /**
   * Unbinds a custom domain name from an API group.
   * 
   * @remarks
   *   This operation is intended for API providers.
   * *   If the specified domain name does not exist, a successful response will still appear.
   * *   Unbinding a domain name from an API group will affect access to the APIs in the group. Exercise caution when using this operation.
   * 
   * @param request - DeleteDomainRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteDomainResponse
   */
  async deleteDomainWithOptions(request: DeleteDomainRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDomainResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteDomain",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteDomainResponse>(await this.callApi(params, req, runtime), new DeleteDomainResponse({}));
  }

  /**
   * Unbinds a custom domain name from an API group.
   * 
   * @remarks
   *   This operation is intended for API providers.
   * *   If the specified domain name does not exist, a successful response will still appear.
   * *   Unbinding a domain name from an API group will affect access to the APIs in the group. Exercise caution when using this operation.
   * 
   * @param request - DeleteDomainRequest
   * @returns DeleteDomainResponse
   */
  async deleteDomain(request: DeleteDomainRequest): Promise<DeleteDomainResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDomainWithOptions(request, runtime);
  }

  /**
   * Deletes the SSL certificate of a specified domain name. This operation is intended for API providers. If the SSL certificate does not exist, a success response is still returned. If the specified API group does not exist, the InvalidGroupId.NotFound error is returned. Access over HTTPS is not supported after the SSL certificate is deleted. Exercise caution when using this API operation.
   * 
   * @param request - DeleteDomainCertificateRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteDomainCertificateResponse
   */
  async deleteDomainCertificateWithOptions(request: DeleteDomainCertificateRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDomainCertificateResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.certificateId)) {
      query["CertificateId"] = request.certificateId;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteDomainCertificate",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteDomainCertificateResponse>(await this.callApi(params, req, runtime), new DeleteDomainCertificateResponse({}));
  }

  /**
   * Deletes the SSL certificate of a specified domain name. This operation is intended for API providers. If the SSL certificate does not exist, a success response is still returned. If the specified API group does not exist, the InvalidGroupId.NotFound error is returned. Access over HTTPS is not supported after the SSL certificate is deleted. Exercise caution when using this API operation.
   * 
   * @param request - DeleteDomainCertificateRequest
   * @returns DeleteDomainCertificateResponse
   */
  async deleteDomainCertificate(request: DeleteDomainCertificateRequest): Promise<DeleteDomainCertificateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDomainCertificateWithOptions(request, runtime);
  }

  /**
   * Deletes an API Gateway instance.
   * 
   * @param request - DeleteInstanceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteInstanceResponse
   */
  async deleteInstanceWithOptions(request: DeleteInstanceRequest, runtime: $Util.RuntimeOptions): Promise<DeleteInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteInstance",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteInstanceResponse>(await this.callApi(params, req, runtime), new DeleteInstanceResponse({}));
  }

  /**
   * Deletes an API Gateway instance.
   * 
   * @param request - DeleteInstanceRequest
   * @returns DeleteInstanceResponse
   */
  async deleteInstance(request: DeleteInstanceRequest): Promise<DeleteInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteInstanceWithOptions(request, runtime);
  }

  /**
   * Deletes an access control list (ACL).
   * 
   * @remarks
   *   This operation is intended for API providers.
   * *   If the ACL is bound to an API, you must unbind the ACL from the API before you can delete the ACL. Otherwise, an error is returned.
   * *   If you call this operation on an ACL that does not exist, a success message is returned.
   * 
   * @param request - DeleteIpControlRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteIpControlResponse
   */
  async deleteIpControlWithOptions(request: DeleteIpControlRequest, runtime: $Util.RuntimeOptions): Promise<DeleteIpControlResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ipControlId)) {
      query["IpControlId"] = request.ipControlId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteIpControl",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteIpControlResponse>(await this.callApi(params, req, runtime), new DeleteIpControlResponse({}));
  }

  /**
   * Deletes an access control list (ACL).
   * 
   * @remarks
   *   This operation is intended for API providers.
   * *   If the ACL is bound to an API, you must unbind the ACL from the API before you can delete the ACL. Otherwise, an error is returned.
   * *   If you call this operation on an ACL that does not exist, a success message is returned.
   * 
   * @param request - DeleteIpControlRequest
   * @returns DeleteIpControlResponse
   */
  async deleteIpControl(request: DeleteIpControlRequest): Promise<DeleteIpControlResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteIpControlWithOptions(request, runtime);
  }

  /**
   * Delete the specified log configuration.
   * 
   * @param request - DeleteLogConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteLogConfigResponse
   */
  async deleteLogConfigWithOptions(request: DeleteLogConfigRequest, runtime: $Util.RuntimeOptions): Promise<DeleteLogConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.logType)) {
      query["LogType"] = request.logType;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteLogConfig",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteLogConfigResponse>(await this.callApi(params, req, runtime), new DeleteLogConfigResponse({}));
  }

  /**
   * Delete the specified log configuration.
   * 
   * @param request - DeleteLogConfigRequest
   * @returns DeleteLogConfigResponse
   */
  async deleteLogConfig(request: DeleteLogConfigRequest): Promise<DeleteLogConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteLogConfigWithOptions(request, runtime);
  }

  /**
   * Deletes a model.
   * 
   * @param request - DeleteModelRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteModelResponse
   */
  async deleteModelWithOptions(request: DeleteModelRequest, runtime: $Util.RuntimeOptions): Promise<DeleteModelResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.modelName)) {
      query["ModelName"] = request.modelName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteModel",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteModelResponse>(await this.callApi(params, req, runtime), new DeleteModelResponse({}));
  }

  /**
   * Deletes a model.
   * 
   * @param request - DeleteModelRequest
   * @returns DeleteModelResponse
   */
  async deleteModel(request: DeleteModelRequest): Promise<DeleteModelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteModelWithOptions(request, runtime);
  }

  /**
   * Deletes a CloudMonitor application group corresponding to an API group.
   * 
   * @param request - DeleteMonitorGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteMonitorGroupResponse
   */
  async deleteMonitorGroupWithOptions(request: DeleteMonitorGroupRequest, runtime: $Util.RuntimeOptions): Promise<DeleteMonitorGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.rawMonitorGroupId)) {
      query["RawMonitorGroupId"] = request.rawMonitorGroupId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteMonitorGroup",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteMonitorGroupResponse>(await this.callApi(params, req, runtime), new DeleteMonitorGroupResponse({}));
  }

  /**
   * Deletes a CloudMonitor application group corresponding to an API group.
   * 
   * @param request - DeleteMonitorGroupRequest
   * @returns DeleteMonitorGroupResponse
   */
  async deleteMonitorGroup(request: DeleteMonitorGroupRequest): Promise<DeleteMonitorGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteMonitorGroupWithOptions(request, runtime);
  }

  /**
   * Deletes a plug-in.
   * 
   * @remarks
   *   This operation is intended for API providers.
   * *   You must first unbind the plug-in from the API. Otherwise, an error is reported when you delete the plug-in.
   * 
   * @param request - DeletePluginRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeletePluginResponse
   */
  async deletePluginWithOptions(request: DeletePluginRequest, runtime: $Util.RuntimeOptions): Promise<DeletePluginResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.pluginId)) {
      query["PluginId"] = request.pluginId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeletePlugin",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeletePluginResponse>(await this.callApi(params, req, runtime), new DeletePluginResponse({}));
  }

  /**
   * Deletes a plug-in.
   * 
   * @remarks
   *   This operation is intended for API providers.
   * *   You must first unbind the plug-in from the API. Otherwise, an error is reported when you delete the plug-in.
   * 
   * @param request - DeletePluginRequest
   * @returns DeletePluginResponse
   */
  async deletePlugin(request: DeletePluginRequest): Promise<DeletePluginResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deletePluginWithOptions(request, runtime);
  }

  /**
   * 删除内网域名解析
   * 
   * @param request - DeletePrivateDNSRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeletePrivateDNSResponse
   */
  async deletePrivateDNSWithOptions(request: DeletePrivateDNSRequest, runtime: $Util.RuntimeOptions): Promise<DeletePrivateDNSResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.force)) {
      query["Force"] = request.force;
    }

    if (!Util.isUnset(request.intranetDomain)) {
      query["IntranetDomain"] = request.intranetDomain;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeletePrivateDNS",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeletePrivateDNSResponse>(await this.callApi(params, req, runtime), new DeletePrivateDNSResponse({}));
  }

  /**
   * 删除内网域名解析
   * 
   * @param request - DeletePrivateDNSRequest
   * @returns DeletePrivateDNSResponse
   */
  async deletePrivateDNS(request: DeletePrivateDNSRequest): Promise<DeletePrivateDNSResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deletePrivateDNSWithOptions(request, runtime);
  }

  /**
   * Deletes a backend signature key.
   * 
   * @remarks
   *   This API is intended for API providers.
   * *   This API operation deletes an existing backend signature key.
   * *   You cannot delete a key that is bound to an API. To delete the key, you must unbind it first.
   * *   The QPS limit on this operation is 50 per user.
   * 
   * @param request - DeleteSignatureRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteSignatureResponse
   */
  async deleteSignatureWithOptions(request: DeleteSignatureRequest, runtime: $Util.RuntimeOptions): Promise<DeleteSignatureResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.signatureId)) {
      query["SignatureId"] = request.signatureId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteSignature",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteSignatureResponse>(await this.callApi(params, req, runtime), new DeleteSignatureResponse({}));
  }

  /**
   * Deletes a backend signature key.
   * 
   * @remarks
   *   This API is intended for API providers.
   * *   This API operation deletes an existing backend signature key.
   * *   You cannot delete a key that is bound to an API. To delete the key, you must unbind it first.
   * *   The QPS limit on this operation is 50 per user.
   * 
   * @param request - DeleteSignatureRequest
   * @returns DeleteSignatureResponse
   */
  async deleteSignature(request: DeleteSignatureRequest): Promise<DeleteSignatureResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteSignatureWithOptions(request, runtime);
  }

  /**
   * Deletes a custom throttling policy and the special throttling rules in the policy.
   * 
   * @remarks
   *   This API is intended for API providers.
   * *   If the throttling policy you want to delete is bound to APIs, you need to unbind the policy first. Otherwise, an error is reported when you delete the policy.
   * *   The QPS limit on this operation is 50 per user.
   * 
   * @param request - DeleteTrafficControlRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteTrafficControlResponse
   */
  async deleteTrafficControlWithOptions(request: DeleteTrafficControlRequest, runtime: $Util.RuntimeOptions): Promise<DeleteTrafficControlResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.trafficControlId)) {
      query["TrafficControlId"] = request.trafficControlId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteTrafficControl",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteTrafficControlResponse>(await this.callApi(params, req, runtime), new DeleteTrafficControlResponse({}));
  }

  /**
   * Deletes a custom throttling policy and the special throttling rules in the policy.
   * 
   * @remarks
   *   This API is intended for API providers.
   * *   If the throttling policy you want to delete is bound to APIs, you need to unbind the policy first. Otherwise, an error is reported when you delete the policy.
   * *   The QPS limit on this operation is 50 per user.
   * 
   * @param request - DeleteTrafficControlRequest
   * @returns DeleteTrafficControlResponse
   */
  async deleteTrafficControl(request: DeleteTrafficControlRequest): Promise<DeleteTrafficControlResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteTrafficControlWithOptions(request, runtime);
  }

  /**
   * Deletes a custom special throttling policy.
   * 
   * @remarks
   *   This API is intended for API providers.
   * *   You can obtain the input parameters required in this operation by calling other APIs.
   * 
   * @param request - DeleteTrafficSpecialControlRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteTrafficSpecialControlResponse
   */
  async deleteTrafficSpecialControlWithOptions(request: DeleteTrafficSpecialControlRequest, runtime: $Util.RuntimeOptions): Promise<DeleteTrafficSpecialControlResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.specialKey)) {
      query["SpecialKey"] = request.specialKey;
    }

    if (!Util.isUnset(request.specialType)) {
      query["SpecialType"] = request.specialType;
    }

    if (!Util.isUnset(request.trafficControlId)) {
      query["TrafficControlId"] = request.trafficControlId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteTrafficSpecialControl",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteTrafficSpecialControlResponse>(await this.callApi(params, req, runtime), new DeleteTrafficSpecialControlResponse({}));
  }

  /**
   * Deletes a custom special throttling policy.
   * 
   * @remarks
   *   This API is intended for API providers.
   * *   You can obtain the input parameters required in this operation by calling other APIs.
   * 
   * @param request - DeleteTrafficSpecialControlRequest
   * @returns DeleteTrafficSpecialControlResponse
   */
  async deleteTrafficSpecialControl(request: DeleteTrafficSpecialControlRequest): Promise<DeleteTrafficSpecialControlResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteTrafficSpecialControlWithOptions(request, runtime);
  }

  /**
   * Publishes an API to an environment.
   * 
   * @remarks
   *   This operation is intended for API providers. Only the API that you have defined and published to a runtime environment can be called.
   * *   An API is published to a cluster in under 5 seconds.
   * *   The QPS limit on this operation is 50 per user.
   * 
   * @param request - DeployApiRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeployApiResponse
   */
  async deployApiWithOptions(request: DeployApiRequest, runtime: $Util.RuntimeOptions): Promise<DeployApiResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.apiId)) {
      query["ApiId"] = request.apiId;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.stageName)) {
      query["StageName"] = request.stageName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeployApi",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeployApiResponse>(await this.callApi(params, req, runtime), new DeployApiResponse({}));
  }

  /**
   * Publishes an API to an environment.
   * 
   * @remarks
   *   This operation is intended for API providers. Only the API that you have defined and published to a runtime environment can be called.
   * *   An API is published to a cluster in under 5 seconds.
   * *   The QPS limit on this operation is 50 per user.
   * 
   * @param request - DeployApiRequest
   * @returns DeployApiResponse
   */
  async deployApi(request: DeployApiRequest): Promise<DeployApiResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deployApiWithOptions(request, runtime);
  }

  /**
   * @param request - DescribeAbolishApiTaskRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeAbolishApiTaskResponse
   */
  async describeAbolishApiTaskWithOptions(request: DescribeAbolishApiTaskRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAbolishApiTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.operationUid)) {
      query["OperationUid"] = request.operationUid;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAbolishApiTask",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAbolishApiTaskResponse>(await this.callApi(params, req, runtime), new DescribeAbolishApiTaskResponse({}));
  }

  /**
   * @param request - DescribeAbolishApiTaskRequest
   * @returns DescribeAbolishApiTaskResponse
   */
  async describeAbolishApiTask(request: DescribeAbolishApiTaskRequest): Promise<DescribeAbolishApiTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAbolishApiTaskWithOptions(request, runtime);
  }

  /**
   * This feature provides instance-level access control for dedicated instances. Queries the details of an access control policy.
   * 
   * @param request - DescribeAccessControlListAttributeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeAccessControlListAttributeResponse
   */
  async describeAccessControlListAttributeWithOptions(request: DescribeAccessControlListAttributeRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAccessControlListAttributeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.aclId)) {
      query["AclId"] = request.aclId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAccessControlListAttribute",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAccessControlListAttributeResponse>(await this.callApi(params, req, runtime), new DescribeAccessControlListAttributeResponse({}));
  }

  /**
   * This feature provides instance-level access control for dedicated instances. Queries the details of an access control policy.
   * 
   * @param request - DescribeAccessControlListAttributeRequest
   * @returns DescribeAccessControlListAttributeResponse
   */
  async describeAccessControlListAttribute(request: DescribeAccessControlListAttributeRequest): Promise<DescribeAccessControlListAttributeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAccessControlListAttributeWithOptions(request, runtime);
  }

  /**
   * This feature provides instance-level access control for dedicated instances. Queries access control policies.
   * 
   * @param request - DescribeAccessControlListsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeAccessControlListsResponse
   */
  async describeAccessControlListsWithOptions(request: DescribeAccessControlListsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAccessControlListsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.aclName)) {
      query["AclName"] = request.aclName;
    }

    if (!Util.isUnset(request.addressIPVersion)) {
      query["AddressIPVersion"] = request.addressIPVersion;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAccessControlLists",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAccessControlListsResponse>(await this.callApi(params, req, runtime), new DescribeAccessControlListsResponse({}));
  }

  /**
   * This feature provides instance-level access control for dedicated instances. Queries access control policies.
   * 
   * @param request - DescribeAccessControlListsRequest
   * @returns DescribeAccessControlListsResponse
   */
  async describeAccessControlLists(request: DescribeAccessControlListsRequest): Promise<DescribeAccessControlListsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAccessControlListsWithOptions(request, runtime);
  }

  /**
   * Queries the definition of an API.
   * 
   * @remarks
   *   This operation is intended for API providers.
   * 
   * @param request - DescribeApiRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeApiResponse
   */
  async describeApiWithOptions(request: DescribeApiRequest, runtime: $Util.RuntimeOptions): Promise<DescribeApiResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.apiId)) {
      query["ApiId"] = request.apiId;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeApi",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeApiResponse>(await this.callApi(params, req, runtime), new DescribeApiResponse({}));
  }

  /**
   * Queries the definition of an API.
   * 
   * @remarks
   *   This operation is intended for API providers.
   * 
   * @param request - DescribeApiRequest
   * @returns DescribeApiResponse
   */
  async describeApi(request: DescribeApiRequest): Promise<DescribeApiResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeApiWithOptions(request, runtime);
  }

  /**
   * Queries the documentation of an API.
   * 
   * @remarks
   *   For API callers, the specified API must be a public or authorized private API that has been published to a runtime environment.
   * *   When you call this operation as an API caller, the service information, parameter definitions, and other details of the API you specify are returned.
   * *   When you call this operation as an API provider, the definition of the specified API running in the specified runtime environment is returned. The returned definition takes effect in the runtime environment, and may be different from the definition of the API you modify.
   * *   Before you call this operation as an API provider, ensure that the API to be queried is a public one or that your application has been authorized to call the API, because authentication on API callers is required.
   * 
   * @param request - DescribeApiDocRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeApiDocResponse
   */
  async describeApiDocWithOptions(request: DescribeApiDocRequest, runtime: $Util.RuntimeOptions): Promise<DescribeApiDocResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.apiId)) {
      query["ApiId"] = request.apiId;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.stageName)) {
      query["StageName"] = request.stageName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeApiDoc",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeApiDocResponse>(await this.callApi(params, req, runtime), new DescribeApiDocResponse({}));
  }

  /**
   * Queries the documentation of an API.
   * 
   * @remarks
   *   For API callers, the specified API must be a public or authorized private API that has been published to a runtime environment.
   * *   When you call this operation as an API caller, the service information, parameter definitions, and other details of the API you specify are returned.
   * *   When you call this operation as an API provider, the definition of the specified API running in the specified runtime environment is returned. The returned definition takes effect in the runtime environment, and may be different from the definition of the API you modify.
   * *   Before you call this operation as an API provider, ensure that the API to be queried is a public one or that your application has been authorized to call the API, because authentication on API callers is required.
   * 
   * @param request - DescribeApiDocRequest
   * @returns DescribeApiDocResponse
   */
  async describeApiDoc(request: DescribeApiDocRequest): Promise<DescribeApiDocResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeApiDocWithOptions(request, runtime);
  }

  /**
   * You can call this operation to query details about an API group, including the automatically assigned second-level domain name, custom domain name, and SSL certificate.
   * 
   * @remarks
   *   This operation is intended for API providers.
   * 
   * @param request - DescribeApiGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeApiGroupResponse
   */
  async describeApiGroupWithOptions(request: DescribeApiGroupRequest, runtime: $Util.RuntimeOptions): Promise<DescribeApiGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeApiGroup",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeApiGroupResponse>(await this.callApi(params, req, runtime), new DescribeApiGroupResponse({}));
  }

  /**
   * You can call this operation to query details about an API group, including the automatically assigned second-level domain name, custom domain name, and SSL certificate.
   * 
   * @remarks
   *   This operation is intended for API providers.
   * 
   * @param request - DescribeApiGroupRequest
   * @returns DescribeApiGroupResponse
   */
  async describeApiGroup(request: DescribeApiGroupRequest): Promise<DescribeApiGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeApiGroupWithOptions(request, runtime);
  }

  /**
   * Queries the VPC whitelist that is allowed to access an API group.
   * 
   * @param request - DescribeApiGroupVpcWhitelistRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeApiGroupVpcWhitelistResponse
   */
  async describeApiGroupVpcWhitelistWithOptions(request: DescribeApiGroupVpcWhitelistRequest, runtime: $Util.RuntimeOptions): Promise<DescribeApiGroupVpcWhitelistResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeApiGroupVpcWhitelist",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeApiGroupVpcWhitelistResponse>(await this.callApi(params, req, runtime), new DescribeApiGroupVpcWhitelistResponse({}));
  }

  /**
   * Queries the VPC whitelist that is allowed to access an API group.
   * 
   * @param request - DescribeApiGroupVpcWhitelistRequest
   * @returns DescribeApiGroupVpcWhitelistResponse
   */
  async describeApiGroupVpcWhitelist(request: DescribeApiGroupVpcWhitelistRequest): Promise<DescribeApiGroupVpcWhitelistResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeApiGroupVpcWhitelistWithOptions(request, runtime);
  }

  /**
   * Queries existing API groups and their basic information.
   * 
   * @remarks
   *   This operation is intended for API providers.
   * 
   * @param request - DescribeApiGroupsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeApiGroupsResponse
   */
  async describeApiGroupsWithOptions(request: DescribeApiGroupsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeApiGroupsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.enableTagAuth)) {
      query["EnableTagAuth"] = request.enableTagAuth;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.groupName)) {
      query["GroupName"] = request.groupName;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.sort)) {
      query["Sort"] = request.sort;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeApiGroups",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeApiGroupsResponse>(await this.callApi(params, req, runtime), new DescribeApiGroupsResponse({}));
  }

  /**
   * Queries existing API groups and their basic information.
   * 
   * @remarks
   *   This operation is intended for API providers.
   * 
   * @param request - DescribeApiGroupsRequest
   * @returns DescribeApiGroupsResponse
   */
  async describeApiGroups(request: DescribeApiGroupsRequest): Promise<DescribeApiGroupsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeApiGroupsWithOptions(request, runtime);
  }

  /**
   * Queries the historical versions of a specified API.
   * 
   * @remarks
   *   This operation is intended for API providers. Only APIs that have been published have historical version records.
   * *   This operation allows you to obtain the historical versions of an API. This operation is always called by other operations.
   * 
   * @param request - DescribeApiHistoriesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeApiHistoriesResponse
   */
  async describeApiHistoriesWithOptions(request: DescribeApiHistoriesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeApiHistoriesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.apiId)) {
      query["ApiId"] = request.apiId;
    }

    if (!Util.isUnset(request.apiName)) {
      query["ApiName"] = request.apiName;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.stageName)) {
      query["StageName"] = request.stageName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeApiHistories",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeApiHistoriesResponse>(await this.callApi(params, req, runtime), new DescribeApiHistoriesResponse({}));
  }

  /**
   * Queries the historical versions of a specified API.
   * 
   * @remarks
   *   This operation is intended for API providers. Only APIs that have been published have historical version records.
   * *   This operation allows you to obtain the historical versions of an API. This operation is always called by other operations.
   * 
   * @param request - DescribeApiHistoriesRequest
   * @returns DescribeApiHistoriesResponse
   */
  async describeApiHistories(request: DescribeApiHistoriesRequest): Promise<DescribeApiHistoriesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeApiHistoriesWithOptions(request, runtime);
  }

  /**
   * Queries the details of a specified historical version of a specified API definition.
   * 
   * @remarks
   * Queries the details of a specified historical version of a specified API definition.
   * *   This API is intended for API providers.
   * *   API Gateway records the time and definition of an API every time the API is published. You can use the version number obtained from other operations to query definition details at a certain publication.
   * 
   * @param request - DescribeApiHistoryRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeApiHistoryResponse
   */
  async describeApiHistoryWithOptions(request: DescribeApiHistoryRequest, runtime: $Util.RuntimeOptions): Promise<DescribeApiHistoryResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.apiId)) {
      query["ApiId"] = request.apiId;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.historyVersion)) {
      query["HistoryVersion"] = request.historyVersion;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.stageName)) {
      query["StageName"] = request.stageName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeApiHistory",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeApiHistoryResponse>(await this.callApi(params, req, runtime), new DescribeApiHistoryResponse({}));
  }

  /**
   * Queries the details of a specified historical version of a specified API definition.
   * 
   * @remarks
   * Queries the details of a specified historical version of a specified API definition.
   * *   This API is intended for API providers.
   * *   API Gateway records the time and definition of an API every time the API is published. You can use the version number obtained from other operations to query definition details at a certain publication.
   * 
   * @param request - DescribeApiHistoryRequest
   * @returns DescribeApiHistoryResponse
   */
  async describeApiHistory(request: DescribeApiHistoryRequest): Promise<DescribeApiHistoryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeApiHistoryWithOptions(request, runtime);
  }

  /**
   * Queries the access control lists (ACLs) that are bound to all the APIs in an API group in a specified environment.
   * 
   * @remarks
   *   This operation is intended for API callers.
   * *   If an optional parameter is not specified, all results are returned on separate pages.
   * ·
   * 
   * @param request - DescribeApiIpControlsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeApiIpControlsResponse
   */
  async describeApiIpControlsWithOptions(request: DescribeApiIpControlsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeApiIpControlsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.apiIds)) {
      query["ApiIds"] = request.apiIds;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.stageName)) {
      query["StageName"] = request.stageName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeApiIpControls",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeApiIpControlsResponse>(await this.callApi(params, req, runtime), new DescribeApiIpControlsResponse({}));
  }

  /**
   * Queries the access control lists (ACLs) that are bound to all the APIs in an API group in a specified environment.
   * 
   * @remarks
   *   This operation is intended for API callers.
   * *   If an optional parameter is not specified, all results are returned on separate pages.
   * ·
   * 
   * @param request - DescribeApiIpControlsRequest
   * @returns DescribeApiIpControlsResponse
   */
  async describeApiIpControls(request: DescribeApiIpControlsRequest): Promise<DescribeApiIpControlsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeApiIpControlsWithOptions(request, runtime);
  }

  /**
   * Queries the response time statistics of an API.
   * 
   * @remarks
   * You can call this operation to query the latency metrics in milliseconds for a specified API.
   * *   This API is intended for API providers.
   * *   Only statistics for API calls made in the release environment are collected by default.
   * 
   * @param request - DescribeApiLatencyDataRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeApiLatencyDataResponse
   */
  async describeApiLatencyDataWithOptions(request: DescribeApiLatencyDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeApiLatencyDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.apiId)) {
      query["ApiId"] = request.apiId;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.stageName)) {
      query["StageName"] = request.stageName;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeApiLatencyData",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeApiLatencyDataResponse>(await this.callApi(params, req, runtime), new DescribeApiLatencyDataResponse({}));
  }

  /**
   * Queries the response time statistics of an API.
   * 
   * @remarks
   * You can call this operation to query the latency metrics in milliseconds for a specified API.
   * *   This API is intended for API providers.
   * *   Only statistics for API calls made in the release environment are collected by default.
   * 
   * @param request - DescribeApiLatencyDataRequest
   * @returns DescribeApiLatencyDataResponse
   */
  async describeApiLatencyData(request: DescribeApiLatencyDataRequest): Promise<DescribeApiLatencyDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeApiLatencyDataWithOptions(request, runtime);
  }

  /**
   * Queries the Alibaba Cloud Marketplace attributes of an API.
   * 
   * @param request - DescribeApiMarketAttributesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeApiMarketAttributesResponse
   */
  async describeApiMarketAttributesWithOptions(request: DescribeApiMarketAttributesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeApiMarketAttributesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.apiId)) {
      query["ApiId"] = request.apiId;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeApiMarketAttributes",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeApiMarketAttributesResponse>(await this.callApi(params, req, runtime), new DescribeApiMarketAttributesResponse({}));
  }

  /**
   * Queries the Alibaba Cloud Marketplace attributes of an API.
   * 
   * @param request - DescribeApiMarketAttributesRequest
   * @returns DescribeApiMarketAttributesResponse
   */
  async describeApiMarketAttributes(request: DescribeApiMarketAttributesRequest): Promise<DescribeApiMarketAttributesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeApiMarketAttributesWithOptions(request, runtime);
  }

  /**
   * Queries the attached APIs of an API product.
   * 
   * @param request - DescribeApiProductApisRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeApiProductApisResponse
   */
  async describeApiProductApisWithOptions(request: DescribeApiProductApisRequest, runtime: $Util.RuntimeOptions): Promise<DescribeApiProductApisResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.apiProductId)) {
      query["ApiProductId"] = request.apiProductId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeApiProductApis",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeApiProductApisResponse>(await this.callApi(params, req, runtime), new DescribeApiProductApisResponse({}));
  }

  /**
   * Queries the attached APIs of an API product.
   * 
   * @param request - DescribeApiProductApisRequest
   * @returns DescribeApiProductApisResponse
   */
  async describeApiProductApis(request: DescribeApiProductApisRequest): Promise<DescribeApiProductApisResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeApiProductApisWithOptions(request, runtime);
  }

  /**
   * Queries API products by application.
   * 
   * @param request - DescribeApiProductsByAppRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeApiProductsByAppResponse
   */
  async describeApiProductsByAppWithOptions(request: DescribeApiProductsByAppRequest, runtime: $Util.RuntimeOptions): Promise<DescribeApiProductsByAppResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeApiProductsByApp",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeApiProductsByAppResponse>(await this.callApi(params, req, runtime), new DescribeApiProductsByAppResponse({}));
  }

  /**
   * Queries API products by application.
   * 
   * @param request - DescribeApiProductsByAppRequest
   * @returns DescribeApiProductsByAppResponse
   */
  async describeApiProductsByApp(request: DescribeApiProductsByAppRequest): Promise<DescribeApiProductsByAppResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeApiProductsByAppWithOptions(request, runtime);
  }

  /**
   * Queries the QPS statistics of an API.
   * 
   * @remarks
   *   This API is intended for API providers.
   * *   Only statistics for API calls made in the release environment are collected by default.
   * 
   * @param request - DescribeApiQpsDataRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeApiQpsDataResponse
   */
  async describeApiQpsDataWithOptions(request: DescribeApiQpsDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeApiQpsDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.apiId)) {
      query["ApiId"] = request.apiId;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.stageName)) {
      query["StageName"] = request.stageName;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeApiQpsData",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeApiQpsDataResponse>(await this.callApi(params, req, runtime), new DescribeApiQpsDataResponse({}));
  }

  /**
   * Queries the QPS statistics of an API.
   * 
   * @remarks
   *   This API is intended for API providers.
   * *   Only statistics for API calls made in the release environment are collected by default.
   * 
   * @param request - DescribeApiQpsDataRequest
   * @returns DescribeApiQpsDataResponse
   */
  async describeApiQpsData(request: DescribeApiQpsDataRequest): Promise<DescribeApiQpsDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeApiQpsDataWithOptions(request, runtime);
  }

  /**
   * Queries the backend signature keys that are bound to the APIs of a specified API group in a specified environment.
   * 
   * @remarks
   *   This API is intended for API providers.
   * *   The ApiIds parameter is optional. If this parameter is not specified, all results in the specified environment of an API group are returned.
   * 
   * @param request - DescribeApiSignaturesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeApiSignaturesResponse
   */
  async describeApiSignaturesWithOptions(request: DescribeApiSignaturesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeApiSignaturesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.apiIds)) {
      query["ApiIds"] = request.apiIds;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.stageName)) {
      query["StageName"] = request.stageName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeApiSignatures",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeApiSignaturesResponse>(await this.callApi(params, req, runtime), new DescribeApiSignaturesResponse({}));
  }

  /**
   * Queries the backend signature keys that are bound to the APIs of a specified API group in a specified environment.
   * 
   * @remarks
   *   This API is intended for API providers.
   * *   The ApiIds parameter is optional. If this parameter is not specified, all results in the specified environment of an API group are returned.
   * 
   * @param request - DescribeApiSignaturesRequest
   * @returns DescribeApiSignaturesResponse
   */
  async describeApiSignatures(request: DescribeApiSignaturesRequest): Promise<DescribeApiSignaturesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeApiSignaturesWithOptions(request, runtime);
  }

  /**
   * Queries the throttling policies bound to all members of an API group in a specified environment.
   * 
   * @remarks
   *   This API is intended for API providers.
   * *   The ApiIds parameter is optional. If this parameter is not specified, all results in the specified environment of an API group are returned.
   * 
   * @param request - DescribeApiTrafficControlsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeApiTrafficControlsResponse
   */
  async describeApiTrafficControlsWithOptions(request: DescribeApiTrafficControlsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeApiTrafficControlsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.apiIds)) {
      query["ApiIds"] = request.apiIds;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.stageName)) {
      query["StageName"] = request.stageName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeApiTrafficControls",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeApiTrafficControlsResponse>(await this.callApi(params, req, runtime), new DescribeApiTrafficControlsResponse({}));
  }

  /**
   * Queries the throttling policies bound to all members of an API group in a specified environment.
   * 
   * @remarks
   *   This API is intended for API providers.
   * *   The ApiIds parameter is optional. If this parameter is not specified, all results in the specified environment of an API group are returned.
   * 
   * @param request - DescribeApiTrafficControlsRequest
   * @returns DescribeApiTrafficControlsResponse
   */
  async describeApiTrafficControls(request: DescribeApiTrafficControlsRequest): Promise<DescribeApiTrafficControlsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeApiTrafficControlsWithOptions(request, runtime);
  }

  /**
   * Queries the statistics on the traffic of an API.
   * 
   * @remarks
   *   This API is intended for API providers.
   * *   Only statistics for API calls made in the release environment are collected by default.
   * 
   * @param request - DescribeApiTrafficDataRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeApiTrafficDataResponse
   */
  async describeApiTrafficDataWithOptions(request: DescribeApiTrafficDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeApiTrafficDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.apiId)) {
      query["ApiId"] = request.apiId;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.stageName)) {
      query["StageName"] = request.stageName;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeApiTrafficData",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeApiTrafficDataResponse>(await this.callApi(params, req, runtime), new DescribeApiTrafficDataResponse({}));
  }

  /**
   * Queries the statistics on the traffic of an API.
   * 
   * @remarks
   *   This API is intended for API providers.
   * *   Only statistics for API calls made in the release environment are collected by default.
   * 
   * @param request - DescribeApiTrafficDataRequest
   * @returns DescribeApiTrafficDataResponse
   */
  async describeApiTrafficData(request: DescribeApiTrafficDataRequest): Promise<DescribeApiTrafficDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeApiTrafficDataWithOptions(request, runtime);
  }

  /**
   * Queries a list of APIs that are being defined.
   * 
   * @remarks
   *   This operation is intended for API callers.
   * *   This operation returns a list of all APIs that are being defined. The basic information about these APIs is also returned in the list.
   * *   This operation returns all APIs that are being edited, regardless of their environments. The returned definitions may be different from the definitions in the environments.
   * 
   * @param request - DescribeApisRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeApisResponse
   */
  async describeApisWithOptions(request: DescribeApisRequest, runtime: $Util.RuntimeOptions): Promise<DescribeApisResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.apiId)) {
      query["ApiId"] = request.apiId;
    }

    if (!Util.isUnset(request.apiMethod)) {
      query["ApiMethod"] = request.apiMethod;
    }

    if (!Util.isUnset(request.apiName)) {
      query["ApiName"] = request.apiName;
    }

    if (!Util.isUnset(request.apiPath)) {
      query["ApiPath"] = request.apiPath;
    }

    if (!Util.isUnset(request.catalogId)) {
      query["CatalogId"] = request.catalogId;
    }

    if (!Util.isUnset(request.enableTagAuth)) {
      query["EnableTagAuth"] = request.enableTagAuth;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.stageName)) {
      query["StageName"] = request.stageName;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!Util.isUnset(request.unDeployed)) {
      query["UnDeployed"] = request.unDeployed;
    }

    if (!Util.isUnset(request.visibility)) {
      query["Visibility"] = request.visibility;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeApis",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeApisResponse>(await this.callApi(params, req, runtime), new DescribeApisResponse({}));
  }

  /**
   * Queries a list of APIs that are being defined.
   * 
   * @remarks
   *   This operation is intended for API callers.
   * *   This operation returns a list of all APIs that are being defined. The basic information about these APIs is also returned in the list.
   * *   This operation returns all APIs that are being edited, regardless of their environments. The returned definitions may be different from the definitions in the environments.
   * 
   * @param request - DescribeApisRequest
   * @returns DescribeApisResponse
   */
  async describeApis(request: DescribeApisRequest): Promise<DescribeApisResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeApisWithOptions(request, runtime);
  }

  /**
   * Queries the APIs with which an application is associated.
   * 
   * @param request - DescribeApisByAppRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeApisByAppResponse
   */
  async describeApisByAppWithOptions(request: DescribeApisByAppRequest, runtime: $Util.RuntimeOptions): Promise<DescribeApisByAppResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.apiName)) {
      query["ApiName"] = request.apiName;
    }

    if (!Util.isUnset(request.apiUid)) {
      query["ApiUid"] = request.apiUid;
    }

    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.method)) {
      query["Method"] = request.method;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.path)) {
      query["Path"] = request.path;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeApisByApp",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeApisByAppResponse>(await this.callApi(params, req, runtime), new DescribeApisByAppResponse({}));
  }

  /**
   * Queries the APIs with which an application is associated.
   * 
   * @param request - DescribeApisByAppRequest
   * @returns DescribeApisByAppResponse
   */
  async describeApisByApp(request: DescribeApisByAppRequest): Promise<DescribeApisByAppResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeApisByAppWithOptions(request, runtime);
  }

  /**
   * Queries APIs in the draft or published state that are created by using a specified backend service.
   * 
   * @param request - DescribeApisByBackendRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeApisByBackendResponse
   */
  async describeApisByBackendWithOptions(request: DescribeApisByBackendRequest, runtime: $Util.RuntimeOptions): Promise<DescribeApisByBackendResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.backendId)) {
      query["BackendId"] = request.backendId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.stageName)) {
      query["StageName"] = request.stageName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeApisByBackend",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeApisByBackendResponse>(await this.callApi(params, req, runtime), new DescribeApisByBackendResponse({}));
  }

  /**
   * Queries APIs in the draft or published state that are created by using a specified backend service.
   * 
   * @param request - DescribeApisByBackendRequest
   * @returns DescribeApisByBackendResponse
   */
  async describeApisByBackend(request: DescribeApisByBackendRequest): Promise<DescribeApisByBackendResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeApisByBackendWithOptions(request, runtime);
  }

  /**
   * Queries the APIs that are bound to an access control list (ACL).
   * 
   * @remarks
   *   This operation is intended for API callers.
   * *   You can specify PageNumber to obtain the result on the specified page.
   * 
   * @param request - DescribeApisByIpControlRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeApisByIpControlResponse
   */
  async describeApisByIpControlWithOptions(request: DescribeApisByIpControlRequest, runtime: $Util.RuntimeOptions): Promise<DescribeApisByIpControlResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ipControlId)) {
      query["IpControlId"] = request.ipControlId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeApisByIpControl",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeApisByIpControlResponse>(await this.callApi(params, req, runtime), new DescribeApisByIpControlResponse({}));
  }

  /**
   * Queries the APIs that are bound to an access control list (ACL).
   * 
   * @remarks
   *   This operation is intended for API callers.
   * *   You can specify PageNumber to obtain the result on the specified page.
   * 
   * @param request - DescribeApisByIpControlRequest
   * @returns DescribeApisByIpControlResponse
   */
  async describeApisByIpControl(request: DescribeApisByIpControlRequest): Promise<DescribeApisByIpControlResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeApisByIpControlWithOptions(request, runtime);
  }

  /**
   * Queries the APIs to which a specified backend signature key is bound.
   * 
   * @remarks
   *   This API is intended for API providers.
   * *   The results are returned on separate pages. You can specify PageNumber to obtain the result on the specified page.
   * 
   * @param request - DescribeApisBySignatureRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeApisBySignatureResponse
   */
  async describeApisBySignatureWithOptions(request: DescribeApisBySignatureRequest, runtime: $Util.RuntimeOptions): Promise<DescribeApisBySignatureResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.signatureId)) {
      query["SignatureId"] = request.signatureId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeApisBySignature",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeApisBySignatureResponse>(await this.callApi(params, req, runtime), new DescribeApisBySignatureResponse({}));
  }

  /**
   * Queries the APIs to which a specified backend signature key is bound.
   * 
   * @remarks
   *   This API is intended for API providers.
   * *   The results are returned on separate pages. You can specify PageNumber to obtain the result on the specified page.
   * 
   * @param request - DescribeApisBySignatureRequest
   * @returns DescribeApisBySignatureResponse
   */
  async describeApisBySignature(request: DescribeApisBySignatureRequest): Promise<DescribeApisBySignatureResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeApisBySignatureWithOptions(request, runtime);
  }

  /**
   * Queries the APIs to which a specified throttling policy is bound.
   * 
   * @remarks
   *   This API is intended for API providers.
   * *   You can specify PageNumber to obtain the result on the specified page.
   * 
   * @param request - DescribeApisByTrafficControlRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeApisByTrafficControlResponse
   */
  async describeApisByTrafficControlWithOptions(request: DescribeApisByTrafficControlRequest, runtime: $Util.RuntimeOptions): Promise<DescribeApisByTrafficControlResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.trafficControlId)) {
      query["TrafficControlId"] = request.trafficControlId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeApisByTrafficControl",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeApisByTrafficControlResponse>(await this.callApi(params, req, runtime), new DescribeApisByTrafficControlResponse({}));
  }

  /**
   * Queries the APIs to which a specified throttling policy is bound.
   * 
   * @remarks
   *   This API is intended for API providers.
   * *   You can specify PageNumber to obtain the result on the specified page.
   * 
   * @param request - DescribeApisByTrafficControlRequest
   * @returns DescribeApisByTrafficControlResponse
   */
  async describeApisByTrafficControl(request: DescribeApisByTrafficControlRequest): Promise<DescribeApisByTrafficControlResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeApisByTrafficControlWithOptions(request, runtime);
  }

  /**
   * Queries the APIs that are associated with a virtual private cloud (VPC) access authorization in a region.
   * 
   * @param request - DescribeApisByVpcAccessRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeApisByVpcAccessResponse
   */
  async describeApisByVpcAccessWithOptions(request: DescribeApisByVpcAccessRequest, runtime: $Util.RuntimeOptions): Promise<DescribeApisByVpcAccessResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.vpcName)) {
      query["VpcName"] = request.vpcName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeApisByVpcAccess",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeApisByVpcAccessResponse>(await this.callApi(params, req, runtime), new DescribeApisByVpcAccessResponse({}));
  }

  /**
   * Queries the APIs that are associated with a virtual private cloud (VPC) access authorization in a region.
   * 
   * @param request - DescribeApisByVpcAccessRequest
   * @returns DescribeApisByVpcAccessResponse
   */
  async describeApisByVpcAccess(request: DescribeApisByVpcAccessRequest): Promise<DescribeApisByVpcAccessResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeApisByVpcAccessWithOptions(request, runtime);
  }

  /**
   * Queries APIs by application. The environment information is also returned.
   * 
   * @param request - DescribeApisWithStageNameIntegratedByAppRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeApisWithStageNameIntegratedByAppResponse
   */
  async describeApisWithStageNameIntegratedByAppWithOptions(request: DescribeApisWithStageNameIntegratedByAppRequest, runtime: $Util.RuntimeOptions): Promise<DescribeApisWithStageNameIntegratedByAppResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.apiName)) {
      query["ApiName"] = request.apiName;
    }

    if (!Util.isUnset(request.apiUid)) {
      query["ApiUid"] = request.apiUid;
    }

    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.method)) {
      query["Method"] = request.method;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.path)) {
      query["Path"] = request.path;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeApisWithStageNameIntegratedByApp",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeApisWithStageNameIntegratedByAppResponse>(await this.callApi(params, req, runtime), new DescribeApisWithStageNameIntegratedByAppResponse({}));
  }

  /**
   * Queries APIs by application. The environment information is also returned.
   * 
   * @param request - DescribeApisWithStageNameIntegratedByAppRequest
   * @returns DescribeApisWithStageNameIntegratedByAppResponse
   */
  async describeApisWithStageNameIntegratedByApp(request: DescribeApisWithStageNameIntegratedByAppRequest): Promise<DescribeApisWithStageNameIntegratedByAppResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeApisWithStageNameIntegratedByAppWithOptions(request, runtime);
  }

  /**
   * Queries the apps that can be authorized.
   * 
   * @param request - DescribeAppRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeAppResponse
   */
  async describeAppWithOptions(request: DescribeAppRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAppResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeApp",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAppResponse>(await this.callApi(params, req, runtime), new DescribeAppResponse({}));
  }

  /**
   * Queries the apps that can be authorized.
   * 
   * @param request - DescribeAppRequest
   * @returns DescribeAppResponse
   */
  async describeApp(request: DescribeAppRequest): Promise<DescribeAppResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAppWithOptions(request, runtime);
  }

  /**
   * Queries apps and their basic information.
   * 
   * @remarks
   *   This operation is intended for API callers.
   * *   AppId is optional.
   * 
   * @param request - DescribeAppAttributesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeAppAttributesResponse
   */
  async describeAppAttributesWithOptions(request: DescribeAppAttributesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAppAttributesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appCode)) {
      query["AppCode"] = request.appCode;
    }

    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.appKey)) {
      query["AppKey"] = request.appKey;
    }

    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.enableTagAuth)) {
      query["EnableTagAuth"] = request.enableTagAuth;
    }

    if (!Util.isUnset(request.extend)) {
      query["Extend"] = request.extend;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.sort)) {
      query["Sort"] = request.sort;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAppAttributes",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAppAttributesResponse>(await this.callApi(params, req, runtime), new DescribeAppAttributesResponse({}));
  }

  /**
   * Queries apps and their basic information.
   * 
   * @remarks
   *   This operation is intended for API callers.
   * *   AppId is optional.
   * 
   * @param request - DescribeAppAttributesRequest
   * @returns DescribeAppAttributesResponse
   */
  async describeAppAttributes(request: DescribeAppAttributesRequest): Promise<DescribeAppAttributesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAppAttributesWithOptions(request, runtime);
  }

  /**
   * Queries the key-related information of an application.
   * 
   * @param request - DescribeAppSecuritiesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeAppSecuritiesResponse
   */
  async describeAppSecuritiesWithOptions(request: DescribeAppSecuritiesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAppSecuritiesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAppSecurities",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAppSecuritiesResponse>(await this.callApi(params, req, runtime), new DescribeAppSecuritiesResponse({}));
  }

  /**
   * Queries the key-related information of an application.
   * 
   * @param request - DescribeAppSecuritiesRequest
   * @returns DescribeAppSecuritiesResponse
   */
  async describeAppSecurities(request: DescribeAppSecuritiesRequest): Promise<DescribeAppSecuritiesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAppSecuritiesWithOptions(request, runtime);
  }

  /**
   * This key is used for authentication when an API call is made.
   * 
   * @remarks
   *   This operation is intended for API callers.
   * 
   * @param request - DescribeAppSecurityRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeAppSecurityResponse
   */
  async describeAppSecurityWithOptions(request: DescribeAppSecurityRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAppSecurityResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAppSecurity",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAppSecurityResponse>(await this.callApi(params, req, runtime), new DescribeAppSecurityResponse({}));
  }

  /**
   * This key is used for authentication when an API call is made.
   * 
   * @remarks
   *   This operation is intended for API callers.
   * 
   * @param request - DescribeAppSecurityRequest
   * @returns DescribeAppSecurityResponse
   */
  async describeAppSecurity(request: DescribeAppSecurityRequest): Promise<DescribeAppSecurityResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAppSecurityWithOptions(request, runtime);
  }

  /**
   * Queries the apps of a user. App information is returned only to the app owner.
   * 
   * @remarks
   *   This API is intended for API providers.
   * *   API providers can use the app IDs or their Alibaba Cloud accounts to query app information.
   * *   Each provider can call this operation for a maximum of 200 times every day in a region.
   * 
   * @param request - DescribeAppsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeAppsResponse
   */
  async describeAppsWithOptions(request: DescribeAppsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAppsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.appOwner)) {
      query["AppOwner"] = request.appOwner;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeApps",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAppsResponse>(await this.callApi(params, req, runtime), new DescribeAppsResponse({}));
  }

  /**
   * Queries the apps of a user. App information is returned only to the app owner.
   * 
   * @remarks
   *   This API is intended for API providers.
   * *   API providers can use the app IDs or their Alibaba Cloud accounts to query app information.
   * *   Each provider can call this operation for a maximum of 200 times every day in a region.
   * 
   * @param request - DescribeAppsRequest
   * @returns DescribeAppsResponse
   */
  async describeApps(request: DescribeAppsRequest): Promise<DescribeAppsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAppsWithOptions(request, runtime);
  }

  /**
   * Queries authorized applications by API product.
   * 
   * @param request - DescribeAppsByApiProductRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeAppsByApiProductResponse
   */
  async describeAppsByApiProductWithOptions(request: DescribeAppsByApiProductRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAppsByApiProductResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.apiProductId)) {
      query["ApiProductId"] = request.apiProductId;
    }

    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAppsByApiProduct",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAppsByApiProductResponse>(await this.callApi(params, req, runtime), new DescribeAppsByApiProductResponse({}));
  }

  /**
   * Queries authorized applications by API product.
   * 
   * @param request - DescribeAppsByApiProductRequest
   * @returns DescribeAppsByApiProductResponse
   */
  async describeAppsByApiProduct(request: DescribeAppsByApiProductRequest): Promise<DescribeAppsByApiProductResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAppsByApiProductWithOptions(request, runtime);
  }

  /**
   * Queries the authorized APIs of a specified APP.
   * 
   * @remarks
   *   This operation is intended for API callers.
   * *   The specified application can call all APIs included in the responses.
   * 
   * @param request - DescribeAuthorizedApisRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeAuthorizedApisResponse
   */
  async describeAuthorizedApisWithOptions(request: DescribeAuthorizedApisRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAuthorizedApisResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAuthorizedApis",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAuthorizedApisResponse>(await this.callApi(params, req, runtime), new DescribeAuthorizedApisResponse({}));
  }

  /**
   * Queries the authorized APIs of a specified APP.
   * 
   * @remarks
   *   This operation is intended for API callers.
   * *   The specified application can call all APIs included in the responses.
   * 
   * @param request - DescribeAuthorizedApisRequest
   * @returns DescribeAuthorizedApisResponse
   */
  async describeAuthorizedApis(request: DescribeAuthorizedApisRequest): Promise<DescribeAuthorizedApisResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAuthorizedApisWithOptions(request, runtime);
  }

  /**
   * Queries the current apps.
   * 
   * @remarks
   *   This operation is intended for API providers.
   * *   All applications included in the responses have access to the specified API.
   * 
   * @param request - DescribeAuthorizedAppsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeAuthorizedAppsResponse
   */
  async describeAuthorizedAppsWithOptions(request: DescribeAuthorizedAppsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAuthorizedAppsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.apiId)) {
      query["ApiId"] = request.apiId;
    }

    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.appOwnerId)) {
      query["AppOwnerId"] = request.appOwnerId;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.stageName)) {
      query["StageName"] = request.stageName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAuthorizedApps",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAuthorizedAppsResponse>(await this.callApi(params, req, runtime), new DescribeAuthorizedAppsResponse({}));
  }

  /**
   * Queries the current apps.
   * 
   * @remarks
   *   This operation is intended for API providers.
   * *   All applications included in the responses have access to the specified API.
   * 
   * @param request - DescribeAuthorizedAppsRequest
   * @returns DescribeAuthorizedAppsResponse
   */
  async describeAuthorizedApps(request: DescribeAuthorizedAppsRequest): Promise<DescribeAuthorizedAppsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAuthorizedAppsWithOptions(request, runtime);
  }

  /**
   * Queries the information about a backend service and its URL configured for each environment.
   * 
   * @param request - DescribeBackendInfoRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeBackendInfoResponse
   */
  async describeBackendInfoWithOptions(request: DescribeBackendInfoRequest, runtime: $Util.RuntimeOptions): Promise<DescribeBackendInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.backendId)) {
      query["BackendId"] = request.backendId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeBackendInfo",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeBackendInfoResponse>(await this.callApi(params, req, runtime), new DescribeBackendInfoResponse({}));
  }

  /**
   * Queries the information about a backend service and its URL configured for each environment.
   * 
   * @param request - DescribeBackendInfoRequest
   * @returns DescribeBackendInfoResponse
   */
  async describeBackendInfo(request: DescribeBackendInfoRequest): Promise<DescribeBackendInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeBackendInfoWithOptions(request, runtime);
  }

  /**
   * Queries backend services. You can filter backend services by backend service name and backend service type.
   * 
   * @param request - DescribeBackendListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeBackendListResponse
   */
  async describeBackendListWithOptions(request: DescribeBackendListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeBackendListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.backendName)) {
      query["BackendName"] = request.backendName;
    }

    if (!Util.isUnset(request.backendType)) {
      query["BackendType"] = request.backendType;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeBackendList",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeBackendListResponse>(await this.callApi(params, req, runtime), new DescribeBackendListResponse({}));
  }

  /**
   * Queries backend services. You can filter backend services by backend service name and backend service type.
   * 
   * @param request - DescribeBackendListRequest
   * @returns DescribeBackendListResponse
   */
  async describeBackendList(request: DescribeBackendListRequest): Promise<DescribeBackendListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeBackendListWithOptions(request, runtime);
  }

  /**
   * Queries the information about a single dataset.
   * 
   * @param request - DescribeDatasetInfoRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDatasetInfoResponse
   */
  async describeDatasetInfoWithOptions(request: DescribeDatasetInfoRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDatasetInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.datasetId)) {
      query["DatasetId"] = request.datasetId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDatasetInfo",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDatasetInfoResponse>(await this.callApi(params, req, runtime), new DescribeDatasetInfoResponse({}));
  }

  /**
   * Queries the information about a single dataset.
   * 
   * @param request - DescribeDatasetInfoRequest
   * @returns DescribeDatasetInfoResponse
   */
  async describeDatasetInfo(request: DescribeDatasetInfoRequest): Promise<DescribeDatasetInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDatasetInfoWithOptions(request, runtime);
  }

  /**
   * Queries a data entry in a custom dataset.
   * 
   * @param request - DescribeDatasetItemInfoRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDatasetItemInfoResponse
   */
  async describeDatasetItemInfoWithOptions(request: DescribeDatasetItemInfoRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDatasetItemInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.datasetId)) {
      query["DatasetId"] = request.datasetId;
    }

    if (!Util.isUnset(request.datasetItemId)) {
      query["DatasetItemId"] = request.datasetItemId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.value)) {
      query["Value"] = request.value;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDatasetItemInfo",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDatasetItemInfoResponse>(await this.callApi(params, req, runtime), new DescribeDatasetItemInfoResponse({}));
  }

  /**
   * Queries a data entry in a custom dataset.
   * 
   * @param request - DescribeDatasetItemInfoRequest
   * @returns DescribeDatasetItemInfoResponse
   */
  async describeDatasetItemInfo(request: DescribeDatasetItemInfoRequest): Promise<DescribeDatasetItemInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDatasetItemInfoWithOptions(request, runtime);
  }

  /**
   * Queries the data entries of a custom dataset.
   * 
   * @param request - DescribeDatasetItemListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDatasetItemListResponse
   */
  async describeDatasetItemListWithOptions(request: DescribeDatasetItemListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDatasetItemListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.datasetId)) {
      query["DatasetId"] = request.datasetId;
    }

    if (!Util.isUnset(request.datasetItemIds)) {
      query["DatasetItemIds"] = request.datasetItemIds;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDatasetItemList",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDatasetItemListResponse>(await this.callApi(params, req, runtime), new DescribeDatasetItemListResponse({}));
  }

  /**
   * Queries the data entries of a custom dataset.
   * 
   * @param request - DescribeDatasetItemListRequest
   * @returns DescribeDatasetItemListResponse
   */
  async describeDatasetItemList(request: DescribeDatasetItemListRequest): Promise<DescribeDatasetItemListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDatasetItemListWithOptions(request, runtime);
  }

  /**
   * Queries custom datasets.
   * 
   * @param request - DescribeDatasetListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDatasetListResponse
   */
  async describeDatasetListWithOptions(request: DescribeDatasetListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDatasetListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.datasetIds)) {
      query["DatasetIds"] = request.datasetIds;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDatasetList",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDatasetListResponse>(await this.callApi(params, req, runtime), new DescribeDatasetListResponse({}));
  }

  /**
   * Queries custom datasets.
   * 
   * @param request - DescribeDatasetListRequest
   * @returns DescribeDatasetListResponse
   */
  async describeDatasetList(request: DescribeDatasetListRequest): Promise<DescribeDatasetListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDatasetListWithOptions(request, runtime);
  }

  /**
   * Queries the progress of an asynchronous API publishing task.
   * 
   * @param request - DescribeDeployApiTaskRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDeployApiTaskResponse
   */
  async describeDeployApiTaskWithOptions(request: DescribeDeployApiTaskRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDeployApiTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.operationUid)) {
      query["OperationUid"] = request.operationUid;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDeployApiTask",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDeployApiTaskResponse>(await this.callApi(params, req, runtime), new DescribeDeployApiTaskResponse({}));
  }

  /**
   * Queries the progress of an asynchronous API publishing task.
   * 
   * @param request - DescribeDeployApiTaskRequest
   * @returns DescribeDeployApiTaskResponse
   */
  async describeDeployApiTask(request: DescribeDeployApiTaskRequest): Promise<DescribeDeployApiTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDeployApiTaskWithOptions(request, runtime);
  }

  /**
   * Queries the definition of an API that takes effect in an environment. The definition may differ from the definition being edited.
   * 
   * @param request - DescribeDeployedApiRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDeployedApiResponse
   */
  async describeDeployedApiWithOptions(request: DescribeDeployedApiRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDeployedApiResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.apiId)) {
      query["ApiId"] = request.apiId;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.stageName)) {
      query["StageName"] = request.stageName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDeployedApi",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDeployedApiResponse>(await this.callApi(params, req, runtime), new DescribeDeployedApiResponse({}));
  }

  /**
   * Queries the definition of an API that takes effect in an environment. The definition may differ from the definition being edited.
   * 
   * @param request - DescribeDeployedApiRequest
   * @returns DescribeDeployedApiResponse
   */
  async describeDeployedApi(request: DescribeDeployedApiRequest): Promise<DescribeDeployedApiResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDeployedApiWithOptions(request, runtime);
  }

  /**
   * Queries the APIs that have been published to a specified environment.
   * 
   * @remarks
   *   This API is intended for API providers.
   * 
   * @param request - DescribeDeployedApisRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDeployedApisResponse
   */
  async describeDeployedApisWithOptions(request: DescribeDeployedApisRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDeployedApisResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.apiId)) {
      query["ApiId"] = request.apiId;
    }

    if (!Util.isUnset(request.apiMethod)) {
      query["ApiMethod"] = request.apiMethod;
    }

    if (!Util.isUnset(request.apiName)) {
      query["ApiName"] = request.apiName;
    }

    if (!Util.isUnset(request.apiPath)) {
      query["ApiPath"] = request.apiPath;
    }

    if (!Util.isUnset(request.enableTagAuth)) {
      query["EnableTagAuth"] = request.enableTagAuth;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.stageName)) {
      query["StageName"] = request.stageName;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDeployedApis",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDeployedApisResponse>(await this.callApi(params, req, runtime), new DescribeDeployedApisResponse({}));
  }

  /**
   * Queries the APIs that have been published to a specified environment.
   * 
   * @remarks
   *   This API is intended for API providers.
   * 
   * @param request - DescribeDeployedApisRequest
   * @returns DescribeDeployedApisResponse
   */
  async describeDeployedApis(request: DescribeDeployedApisRequest): Promise<DescribeDeployedApisResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDeployedApisWithOptions(request, runtime);
  }

  /**
   * Queries details about a bound custom domain name, including the automatically assigned second-level domain name, custom domain name, and SSL certificate.
   * 
   * @param request - DescribeDomainRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDomainResponse
   */
  async describeDomainWithOptions(request: DescribeDomainRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDomainResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDomain",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDomainResponse>(await this.callApi(params, req, runtime), new DescribeDomainResponse({}));
  }

  /**
   * Queries details about a bound custom domain name, including the automatically assigned second-level domain name, custom domain name, and SSL certificate.
   * 
   * @param request - DescribeDomainRequest
   * @returns DescribeDomainResponse
   */
  async describeDomain(request: DescribeDomainRequest): Promise<DescribeDomainResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDomainWithOptions(request, runtime);
  }

  /**
   * Queries the average latency of an API group in an environment.
   * 
   * @param request - DescribeGroupLatencyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeGroupLatencyResponse
   */
  async describeGroupLatencyWithOptions(request: DescribeGroupLatencyRequest, runtime: $Util.RuntimeOptions): Promise<DescribeGroupLatencyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.stageName)) {
      query["StageName"] = request.stageName;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeGroupLatency",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeGroupLatencyResponse>(await this.callApi(params, req, runtime), new DescribeGroupLatencyResponse({}));
  }

  /**
   * Queries the average latency of an API group in an environment.
   * 
   * @param request - DescribeGroupLatencyRequest
   * @returns DescribeGroupLatencyResponse
   */
  async describeGroupLatency(request: DescribeGroupLatencyRequest): Promise<DescribeGroupLatencyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeGroupLatencyWithOptions(request, runtime);
  }

  /**
   * Queries the statistics on the number of requests directed to an API group within a period of time.
   * 
   * @param request - DescribeGroupQpsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeGroupQpsResponse
   */
  async describeGroupQpsWithOptions(request: DescribeGroupQpsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeGroupQpsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.stageName)) {
      query["StageName"] = request.stageName;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeGroupQps",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeGroupQpsResponse>(await this.callApi(params, req, runtime), new DescribeGroupQpsResponse({}));
  }

  /**
   * Queries the statistics on the number of requests directed to an API group within a period of time.
   * 
   * @param request - DescribeGroupQpsRequest
   * @returns DescribeGroupQpsResponse
   */
  async describeGroupQps(request: DescribeGroupQpsRequest): Promise<DescribeGroupQpsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeGroupQpsWithOptions(request, runtime);
  }

  /**
   * Queries the traffic of an API group.
   * 
   * @param request - DescribeGroupTrafficRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeGroupTrafficResponse
   */
  async describeGroupTrafficWithOptions(request: DescribeGroupTrafficRequest, runtime: $Util.RuntimeOptions): Promise<DescribeGroupTrafficResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.stageName)) {
      query["StageName"] = request.stageName;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeGroupTraffic",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeGroupTrafficResponse>(await this.callApi(params, req, runtime), new DescribeGroupTrafficResponse({}));
  }

  /**
   * Queries the traffic of an API group.
   * 
   * @param request - DescribeGroupTrafficRequest
   * @returns DescribeGroupTrafficResponse
   */
  async describeGroupTraffic(request: DescribeGroupTrafficRequest): Promise<DescribeGroupTrafficResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeGroupTrafficWithOptions(request, runtime);
  }

  /**
   * Queries the historical versions of an API.
   * 
   * @param request - DescribeHistoryApisRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeHistoryApisResponse
   */
  async describeHistoryApisWithOptions(request: DescribeHistoryApisRequest, runtime: $Util.RuntimeOptions): Promise<DescribeHistoryApisResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.apiId)) {
      query["ApiId"] = request.apiId;
    }

    if (!Util.isUnset(request.apiName)) {
      query["ApiName"] = request.apiName;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.stageName)) {
      query["StageName"] = request.stageName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeHistoryApis",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeHistoryApisResponse>(await this.callApi(params, req, runtime), new DescribeHistoryApisResponse({}));
  }

  /**
   * Queries the historical versions of an API.
   * 
   * @param request - DescribeHistoryApisRequest
   * @returns DescribeHistoryApisResponse
   */
  async describeHistoryApis(request: DescribeHistoryApisRequest): Promise<DescribeHistoryApisResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeHistoryApisWithOptions(request, runtime);
  }

  /**
   * Queries the result of an OAS API import task.
   * 
   * @param request - DescribeImportOASTaskRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeImportOASTaskResponse
   */
  async describeImportOASTaskWithOptions(request: DescribeImportOASTaskRequest, runtime: $Util.RuntimeOptions): Promise<DescribeImportOASTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.operationId)) {
      query["OperationId"] = request.operationId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeImportOASTask",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeImportOASTaskResponse>(await this.callApi(params, req, runtime), new DescribeImportOASTaskResponse({}));
  }

  /**
   * Queries the result of an OAS API import task.
   * 
   * @param request - DescribeImportOASTaskRequest
   * @returns DescribeImportOASTaskResponse
   */
  async describeImportOASTask(request: DescribeImportOASTaskRequest): Promise<DescribeImportOASTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeImportOASTaskWithOptions(request, runtime);
  }

  /**
   * Queries the information about a dedicated instance cluster.
   * 
   * @param request - DescribeInstanceClusterInfoRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeInstanceClusterInfoResponse
   */
  async describeInstanceClusterInfoWithOptions(request: DescribeInstanceClusterInfoRequest, runtime: $Util.RuntimeOptions): Promise<DescribeInstanceClusterInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceClusterName)) {
      query["InstanceClusterName"] = request.instanceClusterName;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeInstanceClusterInfo",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeInstanceClusterInfoResponse>(await this.callApi(params, req, runtime), new DescribeInstanceClusterInfoResponse({}));
  }

  /**
   * Queries the information about a dedicated instance cluster.
   * 
   * @param request - DescribeInstanceClusterInfoRequest
   * @returns DescribeInstanceClusterInfoResponse
   */
  async describeInstanceClusterInfo(request: DescribeInstanceClusterInfoRequest): Promise<DescribeInstanceClusterInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeInstanceClusterInfoWithOptions(request, runtime);
  }

  /**
   * Queries dedicated instance clusters.
   * 
   * @param request - DescribeInstanceClusterListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeInstanceClusterListResponse
   */
  async describeInstanceClusterListWithOptions(request: DescribeInstanceClusterListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeInstanceClusterListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceClusterId)) {
      query["InstanceClusterId"] = request.instanceClusterId;
    }

    if (!Util.isUnset(request.instanceClusterName)) {
      query["InstanceClusterName"] = request.instanceClusterName;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeInstanceClusterList",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeInstanceClusterListResponse>(await this.callApi(params, req, runtime), new DescribeInstanceClusterListResponse({}));
  }

  /**
   * Queries dedicated instance clusters.
   * 
   * @param request - DescribeInstanceClusterListRequest
   * @returns DescribeInstanceClusterListResponse
   */
  async describeInstanceClusterList(request: DescribeInstanceClusterListRequest): Promise<DescribeInstanceClusterListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeInstanceClusterListWithOptions(request, runtime);
  }

  /**
   * Queries the number of lost connections to a dedicated instance within a period of time.
   * 
   * @param request - DescribeInstanceDropConnectionsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeInstanceDropConnectionsResponse
   */
  async describeInstanceDropConnectionsWithOptions(request: DescribeInstanceDropConnectionsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeInstanceDropConnectionsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.sbcName)) {
      query["SbcName"] = request.sbcName;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeInstanceDropConnections",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeInstanceDropConnectionsResponse>(await this.callApi(params, req, runtime), new DescribeInstanceDropConnectionsResponse({}));
  }

  /**
   * Queries the number of lost connections to a dedicated instance within a period of time.
   * 
   * @param request - DescribeInstanceDropConnectionsRequest
   * @returns DescribeInstanceDropConnectionsResponse
   */
  async describeInstanceDropConnections(request: DescribeInstanceDropConnectionsRequest): Promise<DescribeInstanceDropConnectionsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeInstanceDropConnectionsWithOptions(request, runtime);
  }

  /**
   * Queries the number of dropped packets within a period of time.
   * 
   * @param request - DescribeInstanceDropPacketRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeInstanceDropPacketResponse
   */
  async describeInstanceDropPacketWithOptions(request: DescribeInstanceDropPacketRequest, runtime: $Util.RuntimeOptions): Promise<DescribeInstanceDropPacketResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.sbcName)) {
      query["SbcName"] = request.sbcName;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeInstanceDropPacket",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeInstanceDropPacketResponse>(await this.callApi(params, req, runtime), new DescribeInstanceDropPacketResponse({}));
  }

  /**
   * Queries the number of dropped packets within a period of time.
   * 
   * @param request - DescribeInstanceDropPacketRequest
   * @returns DescribeInstanceDropPacketResponse
   */
  async describeInstanceDropPacket(request: DescribeInstanceDropPacketRequest): Promise<DescribeInstanceDropPacketResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeInstanceDropPacketWithOptions(request, runtime);
  }

  /**
   * Queries the distribution of HTTP status codes of requests to a dedicated instance within a period of time.
   * 
   * @param request - DescribeInstanceHttpCodeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeInstanceHttpCodeResponse
   */
  async describeInstanceHttpCodeWithOptions(request: DescribeInstanceHttpCodeRequest, runtime: $Util.RuntimeOptions): Promise<DescribeInstanceHttpCodeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.stageName)) {
      query["StageName"] = request.stageName;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeInstanceHttpCode",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeInstanceHttpCodeResponse>(await this.callApi(params, req, runtime), new DescribeInstanceHttpCodeResponse({}));
  }

  /**
   * Queries the distribution of HTTP status codes of requests to a dedicated instance within a period of time.
   * 
   * @param request - DescribeInstanceHttpCodeRequest
   * @returns DescribeInstanceHttpCodeResponse
   */
  async describeInstanceHttpCode(request: DescribeInstanceHttpCodeRequest): Promise<DescribeInstanceHttpCodeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeInstanceHttpCodeWithOptions(request, runtime);
  }

  /**
   * Queries the average latency of a dedicated instance over a period of time.
   * 
   * @param request - DescribeInstanceLatencyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeInstanceLatencyResponse
   */
  async describeInstanceLatencyWithOptions(request: DescribeInstanceLatencyRequest, runtime: $Util.RuntimeOptions): Promise<DescribeInstanceLatencyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.stageName)) {
      query["StageName"] = request.stageName;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeInstanceLatency",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeInstanceLatencyResponse>(await this.callApi(params, req, runtime), new DescribeInstanceLatencyResponse({}));
  }

  /**
   * Queries the average latency of a dedicated instance over a period of time.
   * 
   * @param request - DescribeInstanceLatencyRequest
   * @returns DescribeInstanceLatencyResponse
   */
  async describeInstanceLatency(request: DescribeInstanceLatencyRequest): Promise<DescribeInstanceLatencyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeInstanceLatencyWithOptions(request, runtime);
  }

  /**
   * Queries the number of new connections to a dedicated instance within a period of time.
   * 
   * @param request - DescribeInstanceNewConnectionsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeInstanceNewConnectionsResponse
   */
  async describeInstanceNewConnectionsWithOptions(request: DescribeInstanceNewConnectionsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeInstanceNewConnectionsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.sbcName)) {
      query["SbcName"] = request.sbcName;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeInstanceNewConnections",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeInstanceNewConnectionsResponse>(await this.callApi(params, req, runtime), new DescribeInstanceNewConnectionsResponse({}));
  }

  /**
   * Queries the number of new connections to a dedicated instance within a period of time.
   * 
   * @param request - DescribeInstanceNewConnectionsRequest
   * @returns DescribeInstanceNewConnectionsResponse
   */
  async describeInstanceNewConnections(request: DescribeInstanceNewConnectionsRequest): Promise<DescribeInstanceNewConnectionsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeInstanceNewConnectionsWithOptions(request, runtime);
  }

  /**
   * Queries the numbers of inbound and outbound packets of a dedicated instance within a period of time.
   * 
   * @param request - DescribeInstancePacketsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeInstancePacketsResponse
   */
  async describeInstancePacketsWithOptions(request: DescribeInstancePacketsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeInstancePacketsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.sbcName)) {
      query["SbcName"] = request.sbcName;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeInstancePackets",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeInstancePacketsResponse>(await this.callApi(params, req, runtime), new DescribeInstancePacketsResponse({}));
  }

  /**
   * Queries the numbers of inbound and outbound packets of a dedicated instance within a period of time.
   * 
   * @param request - DescribeInstancePacketsRequest
   * @returns DescribeInstancePacketsResponse
   */
  async describeInstancePackets(request: DescribeInstancePacketsRequest): Promise<DescribeInstancePacketsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeInstancePacketsWithOptions(request, runtime);
  }

  /**
   * Queries the number of requests to a dedicated instance within a period of time.
   * 
   * @param request - DescribeInstanceQpsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeInstanceQpsResponse
   */
  async describeInstanceQpsWithOptions(request: DescribeInstanceQpsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeInstanceQpsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.stageName)) {
      query["StageName"] = request.stageName;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeInstanceQps",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeInstanceQpsResponse>(await this.callApi(params, req, runtime), new DescribeInstanceQpsResponse({}));
  }

  /**
   * Queries the number of requests to a dedicated instance within a period of time.
   * 
   * @param request - DescribeInstanceQpsRequest
   * @returns DescribeInstanceQpsResponse
   */
  async describeInstanceQps(request: DescribeInstanceQpsRequest): Promise<DescribeInstanceQpsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeInstanceQpsWithOptions(request, runtime);
  }

  /**
   * Queries the number of concurrent connections to a dedicated instance within a period of time.
   * 
   * @param request - DescribeInstanceSlbConnectRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeInstanceSlbConnectResponse
   */
  async describeInstanceSlbConnectWithOptions(request: DescribeInstanceSlbConnectRequest, runtime: $Util.RuntimeOptions): Promise<DescribeInstanceSlbConnectResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.sbcName)) {
      query["SbcName"] = request.sbcName;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeInstanceSlbConnect",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeInstanceSlbConnectResponse>(await this.callApi(params, req, runtime), new DescribeInstanceSlbConnectResponse({}));
  }

  /**
   * Queries the number of concurrent connections to a dedicated instance within a period of time.
   * 
   * @param request - DescribeInstanceSlbConnectRequest
   * @returns DescribeInstanceSlbConnectResponse
   */
  async describeInstanceSlbConnect(request: DescribeInstanceSlbConnectRequest): Promise<DescribeInstanceSlbConnectResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeInstanceSlbConnectWithOptions(request, runtime);
  }

  /**
   * Queries the request traffic and response traffic of a dedicated instance within a period of time.
   * 
   * @param request - DescribeInstanceTrafficRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeInstanceTrafficResponse
   */
  async describeInstanceTrafficWithOptions(request: DescribeInstanceTrafficRequest, runtime: $Util.RuntimeOptions): Promise<DescribeInstanceTrafficResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.stageName)) {
      query["StageName"] = request.stageName;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeInstanceTraffic",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeInstanceTrafficResponse>(await this.callApi(params, req, runtime), new DescribeInstanceTrafficResponse({}));
  }

  /**
   * Queries the request traffic and response traffic of a dedicated instance within a period of time.
   * 
   * @param request - DescribeInstanceTrafficRequest
   * @returns DescribeInstanceTrafficResponse
   */
  async describeInstanceTraffic(request: DescribeInstanceTrafficRequest): Promise<DescribeInstanceTrafficResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeInstanceTrafficWithOptions(request, runtime);
  }

  /**
   * Queries the details of instances in a region. The instances include shared instances and dedicated instances.
   * 
   * @param request - DescribeInstancesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeInstancesResponse
   */
  async describeInstancesWithOptions(request: DescribeInstancesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeInstancesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.enableTagAuthorization)) {
      query["EnableTagAuthorization"] = request.enableTagAuthorization;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.language)) {
      query["Language"] = request.language;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeInstances",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeInstancesResponse>(await this.callApi(params, req, runtime), new DescribeInstancesResponse({}));
  }

  /**
   * Queries the details of instances in a region. The instances include shared instances and dedicated instances.
   * 
   * @param request - DescribeInstancesRequest
   * @returns DescribeInstancesResponse
   */
  async describeInstances(request: DescribeInstancesRequest): Promise<DescribeInstancesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeInstancesWithOptions(request, runtime);
  }

  /**
   * Queries the rule entries of an IP address-based traffic control policy.
   * 
   * @remarks
   *   This operation is intended for API providers.
   * *   You can filter the query results by policy ID.
   * 
   * @param request - DescribeIpControlPolicyItemsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeIpControlPolicyItemsResponse
   */
  async describeIpControlPolicyItemsWithOptions(request: DescribeIpControlPolicyItemsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeIpControlPolicyItemsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ipControlId)) {
      query["IpControlId"] = request.ipControlId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.policyItemId)) {
      query["PolicyItemId"] = request.policyItemId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeIpControlPolicyItems",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeIpControlPolicyItemsResponse>(await this.callApi(params, req, runtime), new DescribeIpControlPolicyItemsResponse({}));
  }

  /**
   * Queries the rule entries of an IP address-based traffic control policy.
   * 
   * @remarks
   *   This operation is intended for API providers.
   * *   You can filter the query results by policy ID.
   * 
   * @param request - DescribeIpControlPolicyItemsRequest
   * @returns DescribeIpControlPolicyItemsResponse
   */
  async describeIpControlPolicyItems(request: DescribeIpControlPolicyItemsRequest): Promise<DescribeIpControlPolicyItemsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeIpControlPolicyItemsWithOptions(request, runtime);
  }

  /**
   * Queries custom access control lists (ACLs) on separate pages.
   * 
   * @remarks
   *   This operation is intended for API providers.
   * *   This operation is used to query the ACLs in a region. Region is a system parameter.
   * *   You can filter the query results by ACL ID, name, or type.
   * *   This operation cannot be used to query specific policies. If you want to query specific policies, call the [DescribeIpControlPolicyItems](~~DescribeIpControlPolicyItems~~) operation.
   * 
   * @param request - DescribeIpControlsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeIpControlsResponse
   */
  async describeIpControlsWithOptions(request: DescribeIpControlsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeIpControlsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ipControlId)) {
      query["IpControlId"] = request.ipControlId;
    }

    if (!Util.isUnset(request.ipControlName)) {
      query["IpControlName"] = request.ipControlName;
    }

    if (!Util.isUnset(request.ipControlType)) {
      query["IpControlType"] = request.ipControlType;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeIpControls",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeIpControlsResponse>(await this.callApi(params, req, runtime), new DescribeIpControlsResponse({}));
  }

  /**
   * Queries custom access control lists (ACLs) on separate pages.
   * 
   * @remarks
   *   This operation is intended for API providers.
   * *   This operation is used to query the ACLs in a region. Region is a system parameter.
   * *   You can filter the query results by ACL ID, name, or type.
   * *   This operation cannot be used to query specific policies. If you want to query specific policies, call the [DescribeIpControlPolicyItems](~~DescribeIpControlPolicyItems~~) operation.
   * 
   * @param request - DescribeIpControlsRequest
   * @returns DescribeIpControlsResponse
   */
  async describeIpControls(request: DescribeIpControlsRequest): Promise<DescribeIpControlsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeIpControlsWithOptions(request, runtime);
  }

  /**
   * @param request - DescribeLogConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeLogConfigResponse
   */
  async describeLogConfigWithOptions(request: DescribeLogConfigRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLogConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.logType)) {
      query["LogType"] = request.logType;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLogConfig",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLogConfigResponse>(await this.callApi(params, req, runtime), new DescribeLogConfigResponse({}));
  }

  /**
   * @param request - DescribeLogConfigRequest
   * @returns DescribeLogConfigResponse
   */
  async describeLogConfig(request: DescribeLogConfigRequest): Promise<DescribeLogConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLogConfigWithOptions(request, runtime);
  }

  /**
   * Queries the number of remaining ordered relationships for a purchaser.
   * 
   * @param request - DescribeMarketRemainsQuotaRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeMarketRemainsQuotaResponse
   */
  async describeMarketRemainsQuotaWithOptions(request: DescribeMarketRemainsQuotaRequest, runtime: $Util.RuntimeOptions): Promise<DescribeMarketRemainsQuotaResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeMarketRemainsQuota",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeMarketRemainsQuotaResponse>(await this.callApi(params, req, runtime), new DescribeMarketRemainsQuotaResponse({}));
  }

  /**
   * Queries the number of remaining ordered relationships for a purchaser.
   * 
   * @param request - DescribeMarketRemainsQuotaRequest
   * @returns DescribeMarketRemainsQuotaResponse
   */
  async describeMarketRemainsQuota(request: DescribeMarketRemainsQuotaRequest): Promise<DescribeMarketRemainsQuotaResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeMarketRemainsQuotaWithOptions(request, runtime);
  }

  /**
   * Queries the created models of an API group.
   * 
   * @remarks
   *   Fuzzy queries are supported.
   * 
   * @param request - DescribeModelsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeModelsResponse
   */
  async describeModelsWithOptions(request: DescribeModelsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeModelsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.modelId)) {
      query["ModelId"] = request.modelId;
    }

    if (!Util.isUnset(request.modelName)) {
      query["ModelName"] = request.modelName;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeModels",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeModelsResponse>(await this.callApi(params, req, runtime), new DescribeModelsResponse({}));
  }

  /**
   * Queries the created models of an API group.
   * 
   * @remarks
   *   Fuzzy queries are supported.
   * 
   * @param request - DescribeModelsRequest
   * @returns DescribeModelsResponse
   */
  async describeModels(request: DescribeModelsRequest): Promise<DescribeModelsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeModelsWithOptions(request, runtime);
  }

  /**
   * Queries the APIs to which a specified plug-in is bound.
   * 
   * @param request - DescribePluginApisRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribePluginApisResponse
   */
  async describePluginApisWithOptions(request: DescribePluginApisRequest, runtime: $Util.RuntimeOptions): Promise<DescribePluginApisResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.apiId)) {
      query["ApiId"] = request.apiId;
    }

    if (!Util.isUnset(request.apiName)) {
      query["ApiName"] = request.apiName;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.method)) {
      query["Method"] = request.method;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.path)) {
      query["Path"] = request.path;
    }

    if (!Util.isUnset(request.pluginId)) {
      query["PluginId"] = request.pluginId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribePluginApis",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribePluginApisResponse>(await this.callApi(params, req, runtime), new DescribePluginApisResponse({}));
  }

  /**
   * Queries the APIs to which a specified plug-in is bound.
   * 
   * @param request - DescribePluginApisRequest
   * @returns DescribePluginApisResponse
   */
  async describePluginApis(request: DescribePluginApisRequest): Promise<DescribePluginApisResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describePluginApisWithOptions(request, runtime);
  }

  /**
   * @param request - DescribePluginSchemasRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribePluginSchemasResponse
   */
  async describePluginSchemasWithOptions(request: DescribePluginSchemasRequest, runtime: $Util.RuntimeOptions): Promise<DescribePluginSchemasResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.language)) {
      query["Language"] = request.language;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribePluginSchemas",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribePluginSchemasResponse>(await this.callApi(params, req, runtime), new DescribePluginSchemasResponse({}));
  }

  /**
   * @param request - DescribePluginSchemasRequest
   * @returns DescribePluginSchemasResponse
   */
  async describePluginSchemas(request: DescribePluginSchemasRequest): Promise<DescribePluginSchemasResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describePluginSchemasWithOptions(request, runtime);
  }

  /**
   * @param request - DescribePluginTemplatesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribePluginTemplatesResponse
   */
  async describePluginTemplatesWithOptions(request: DescribePluginTemplatesRequest, runtime: $Util.RuntimeOptions): Promise<DescribePluginTemplatesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.language)) {
      query["Language"] = request.language;
    }

    if (!Util.isUnset(request.pluginName)) {
      query["PluginName"] = request.pluginName;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribePluginTemplates",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribePluginTemplatesResponse>(await this.callApi(params, req, runtime), new DescribePluginTemplatesResponse({}));
  }

  /**
   * @param request - DescribePluginTemplatesRequest
   * @returns DescribePluginTemplatesResponse
   */
  async describePluginTemplates(request: DescribePluginTemplatesRequest): Promise<DescribePluginTemplatesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describePluginTemplatesWithOptions(request, runtime);
  }

  /**
   * Queries API Gateway plug-ins and the details of the plug-ins.
   * 
   * @remarks
   *   This operation supports pagination.
   * *   This operation allows you to query plug-ins by business type.
   * *   This operation allows you to query plug-ins by ID.
   * *   This operation allows you to query plug-ins by name.
   * 
   * @param request - DescribePluginsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribePluginsResponse
   */
  async describePluginsWithOptions(request: DescribePluginsRequest, runtime: $Util.RuntimeOptions): Promise<DescribePluginsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.pluginId)) {
      query["PluginId"] = request.pluginId;
    }

    if (!Util.isUnset(request.pluginName)) {
      query["PluginName"] = request.pluginName;
    }

    if (!Util.isUnset(request.pluginType)) {
      query["PluginType"] = request.pluginType;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribePlugins",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribePluginsResponse>(await this.callApi(params, req, runtime), new DescribePluginsResponse({}));
  }

  /**
   * Queries API Gateway plug-ins and the details of the plug-ins.
   * 
   * @remarks
   *   This operation supports pagination.
   * *   This operation allows you to query plug-ins by business type.
   * *   This operation allows you to query plug-ins by ID.
   * *   This operation allows you to query plug-ins by name.
   * 
   * @param request - DescribePluginsRequest
   * @returns DescribePluginsResponse
   */
  async describePlugins(request: DescribePluginsRequest): Promise<DescribePluginsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describePluginsWithOptions(request, runtime);
  }

  /**
   * Queries the plug-ins that are bound to a running API in an environment.
   * 
   * @remarks
   *   This operation is intended for API callers.
   * *   This operation supports pagination.
   * 
   * @param request - DescribePluginsByApiRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribePluginsByApiResponse
   */
  async describePluginsByApiWithOptions(request: DescribePluginsByApiRequest, runtime: $Util.RuntimeOptions): Promise<DescribePluginsByApiResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.apiId)) {
      query["ApiId"] = request.apiId;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.stageName)) {
      query["StageName"] = request.stageName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribePluginsByApi",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribePluginsByApiResponse>(await this.callApi(params, req, runtime), new DescribePluginsByApiResponse({}));
  }

  /**
   * Queries the plug-ins that are bound to a running API in an environment.
   * 
   * @remarks
   *   This operation is intended for API callers.
   * *   This operation supports pagination.
   * 
   * @param request - DescribePluginsByApiRequest
   * @returns DescribePluginsByApiResponse
   */
  async describePluginsByApi(request: DescribePluginsByApiRequest): Promise<DescribePluginsByApiResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describePluginsByApiWithOptions(request, runtime);
  }

  /**
   * Queries the details about an API group purchased from Alibaba Cloud Marketplace.
   * 
   * @param request - DescribePurchasedApiGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribePurchasedApiGroupResponse
   */
  async describePurchasedApiGroupWithOptions(request: DescribePurchasedApiGroupRequest, runtime: $Util.RuntimeOptions): Promise<DescribePurchasedApiGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribePurchasedApiGroup",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribePurchasedApiGroupResponse>(await this.callApi(params, req, runtime), new DescribePurchasedApiGroupResponse({}));
  }

  /**
   * Queries the details about an API group purchased from Alibaba Cloud Marketplace.
   * 
   * @param request - DescribePurchasedApiGroupRequest
   * @returns DescribePurchasedApiGroupResponse
   */
  async describePurchasedApiGroup(request: DescribePurchasedApiGroupRequest): Promise<DescribePurchasedApiGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describePurchasedApiGroupWithOptions(request, runtime);
  }

  /**
   * Queries the API groups purchased from Alibaba Cloud Marketplace.
   * 
   * @param request - DescribePurchasedApiGroupsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribePurchasedApiGroupsResponse
   */
  async describePurchasedApiGroupsWithOptions(request: DescribePurchasedApiGroupsRequest, runtime: $Util.RuntimeOptions): Promise<DescribePurchasedApiGroupsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribePurchasedApiGroups",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribePurchasedApiGroupsResponse>(await this.callApi(params, req, runtime), new DescribePurchasedApiGroupsResponse({}));
  }

  /**
   * Queries the API groups purchased from Alibaba Cloud Marketplace.
   * 
   * @param request - DescribePurchasedApiGroupsRequest
   * @returns DescribePurchasedApiGroupsResponse
   */
  async describePurchasedApiGroups(request: DescribePurchasedApiGroupsRequest): Promise<DescribePurchasedApiGroupsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describePurchasedApiGroupsWithOptions(request, runtime);
  }

  /**
   * Queries APIs that are purchased from Alibaba Cloud Marketplace.
   * 
   * @param request - DescribePurchasedApisRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribePurchasedApisResponse
   */
  async describePurchasedApisWithOptions(request: DescribePurchasedApisRequest, runtime: $Util.RuntimeOptions): Promise<DescribePurchasedApisResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.apiId)) {
      query["ApiId"] = request.apiId;
    }

    if (!Util.isUnset(request.apiName)) {
      query["ApiName"] = request.apiName;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.stageName)) {
      query["StageName"] = request.stageName;
    }

    if (!Util.isUnset(request.visibility)) {
      query["Visibility"] = request.visibility;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribePurchasedApis",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribePurchasedApisResponse>(await this.callApi(params, req, runtime), new DescribePurchasedApisResponse({}));
  }

  /**
   * Queries APIs that are purchased from Alibaba Cloud Marketplace.
   * 
   * @param request - DescribePurchasedApisRequest
   * @returns DescribePurchasedApisResponse
   */
  async describePurchasedApis(request: DescribePurchasedApisRequest): Promise<DescribePurchasedApisResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describePurchasedApisWithOptions(request, runtime);
  }

  /**
   * Queries the Alibaba Cloud regions that are supported by API Gateway.
   * 
   * @remarks
   * This operation queries regions in which API Gateway is available.
   * *   This operation is intended for API providers and callers.
   * 
   * @param request - DescribeRegionsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeRegionsResponse
   */
  async describeRegionsWithOptions(request: DescribeRegionsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeRegionsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.language)) {
      query["Language"] = request.language;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeRegions",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeRegionsResponse>(await this.callApi(params, req, runtime), new DescribeRegionsResponse({}));
  }

  /**
   * Queries the Alibaba Cloud regions that are supported by API Gateway.
   * 
   * @remarks
   * This operation queries regions in which API Gateway is available.
   * *   This operation is intended for API providers and callers.
   * 
   * @param request - DescribeRegionsRequest
   * @returns DescribeRegionsResponse
   */
  async describeRegions(request: DescribeRegionsRequest): Promise<DescribeRegionsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeRegionsWithOptions(request, runtime);
  }

  /**
   * Queries backend signature keys.
   * 
   * @remarks
   *   This API is intended for API providers.
   * *   This operation is used to query the backend signature keys in a Region. Region is a system parameter.
   * 
   * @param request - DescribeSignaturesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeSignaturesResponse
   */
  async describeSignaturesWithOptions(request: DescribeSignaturesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSignaturesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.signatureId)) {
      query["SignatureId"] = request.signatureId;
    }

    if (!Util.isUnset(request.signatureName)) {
      query["SignatureName"] = request.signatureName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeSignatures",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSignaturesResponse>(await this.callApi(params, req, runtime), new DescribeSignaturesResponse({}));
  }

  /**
   * Queries backend signature keys.
   * 
   * @remarks
   *   This API is intended for API providers.
   * *   This operation is used to query the backend signature keys in a Region. Region is a system parameter.
   * 
   * @param request - DescribeSignaturesRequest
   * @returns DescribeSignaturesResponse
   */
  async describeSignatures(request: DescribeSignaturesRequest): Promise<DescribeSignaturesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSignaturesWithOptions(request, runtime);
  }

  /**
   * Queries the backend signature keys that are bound to a specified API.
   * 
   * @remarks
   *   This API is intended for API providers.
   * 
   * @param request - DescribeSignaturesByApiRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeSignaturesByApiResponse
   */
  async describeSignaturesByApiWithOptions(request: DescribeSignaturesByApiRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSignaturesByApiResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.apiId)) {
      query["ApiId"] = request.apiId;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.stageName)) {
      query["StageName"] = request.stageName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeSignaturesByApi",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSignaturesByApiResponse>(await this.callApi(params, req, runtime), new DescribeSignaturesByApiResponse({}));
  }

  /**
   * Queries the backend signature keys that are bound to a specified API.
   * 
   * @remarks
   *   This API is intended for API providers.
   * 
   * @param request - DescribeSignaturesByApiRequest
   * @returns DescribeSignaturesByApiResponse
   */
  async describeSignaturesByApi(request: DescribeSignaturesByApiRequest): Promise<DescribeSignaturesByApiResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSignaturesByApiWithOptions(request, runtime);
  }

  /**
   * Queries the number of API Gateway resources in a region.
   * 
   * @param request - DescribeSummaryDataRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeSummaryDataResponse
   */
  async describeSummaryDataWithOptions(request: DescribeSummaryDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSummaryDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeSummaryData",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSummaryDataResponse>(await this.callApi(params, req, runtime), new DescribeSummaryDataResponse({}));
  }

  /**
   * Queries the number of API Gateway resources in a region.
   * 
   * @param request - DescribeSummaryDataRequest
   * @returns DescribeSummaryDataResponse
   */
  async describeSummaryData(request: DescribeSummaryDataRequest): Promise<DescribeSummaryDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSummaryDataWithOptions(request, runtime);
  }

  /**
   * Queries the common parameters supported by the system.
   * 
   * @remarks
   *   This API is intended for API callers.
   * *   The response of this API contains the system parameters that are optional in API definitions.
   * 
   * @param request - DescribeSystemParametersRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeSystemParametersResponse
   */
  async describeSystemParametersWithOptions(request: DescribeSystemParametersRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSystemParametersResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeSystemParameters",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSystemParametersResponse>(await this.callApi(params, req, runtime), new DescribeSystemParametersResponse({}));
  }

  /**
   * Queries the common parameters supported by the system.
   * 
   * @remarks
   *   This API is intended for API callers.
   * *   The response of this API contains the system parameters that are optional in API definitions.
   * 
   * @param request - DescribeSystemParametersRequest
   * @returns DescribeSystemParametersResponse
   */
  async describeSystemParameters(request: DescribeSystemParametersRequest): Promise<DescribeSystemParametersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSystemParametersWithOptions(request, runtime);
  }

  /**
   * Queries custom throttling policies and their details. Conditional queries are supported.
   * 
   * @remarks
   *   This API is intended for API providers.
   * *   This API can be used to query all existing throttling policies (including special throttling policies) and their details.
   * *   You can specify query conditions. For example, you can query the throttling policies bound to a specified API or in a specified environment.
   * 
   * @param request - DescribeTrafficControlsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeTrafficControlsResponse
   */
  async describeTrafficControlsWithOptions(request: DescribeTrafficControlsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeTrafficControlsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.apiId)) {
      query["ApiId"] = request.apiId;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.stageName)) {
      query["StageName"] = request.stageName;
    }

    if (!Util.isUnset(request.trafficControlId)) {
      query["TrafficControlId"] = request.trafficControlId;
    }

    if (!Util.isUnset(request.trafficControlName)) {
      query["TrafficControlName"] = request.trafficControlName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeTrafficControls",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeTrafficControlsResponse>(await this.callApi(params, req, runtime), new DescribeTrafficControlsResponse({}));
  }

  /**
   * Queries custom throttling policies and their details. Conditional queries are supported.
   * 
   * @remarks
   *   This API is intended for API providers.
   * *   This API can be used to query all existing throttling policies (including special throttling policies) and their details.
   * *   You can specify query conditions. For example, you can query the throttling policies bound to a specified API or in a specified environment.
   * 
   * @param request - DescribeTrafficControlsRequest
   * @returns DescribeTrafficControlsResponse
   */
  async describeTrafficControls(request: DescribeTrafficControlsRequest): Promise<DescribeTrafficControlsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeTrafficControlsWithOptions(request, runtime);
  }

  /**
   * Queries the throttling policy that is bound to a specific API.
   * 
   * @remarks
   *   This API is intended for API providers.
   * 
   * @param request - DescribeTrafficControlsByApiRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeTrafficControlsByApiResponse
   */
  async describeTrafficControlsByApiWithOptions(request: DescribeTrafficControlsByApiRequest, runtime: $Util.RuntimeOptions): Promise<DescribeTrafficControlsByApiResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.apiId)) {
      query["ApiId"] = request.apiId;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.stageName)) {
      query["StageName"] = request.stageName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeTrafficControlsByApi",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeTrafficControlsByApiResponse>(await this.callApi(params, req, runtime), new DescribeTrafficControlsByApiResponse({}));
  }

  /**
   * Queries the throttling policy that is bound to a specific API.
   * 
   * @remarks
   *   This API is intended for API providers.
   * 
   * @param request - DescribeTrafficControlsByApiRequest
   * @returns DescribeTrafficControlsByApiResponse
   */
  async describeTrafficControlsByApi(request: DescribeTrafficControlsByApiRequest): Promise<DescribeTrafficControlsByApiResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeTrafficControlsByApiWithOptions(request, runtime);
  }

  /**
   * 查询批量更新API后端元定结果
   * 
   * @param request - DescribeUpdateBackendTaskRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeUpdateBackendTaskResponse
   */
  async describeUpdateBackendTaskWithOptions(request: DescribeUpdateBackendTaskRequest, runtime: $Util.RuntimeOptions): Promise<DescribeUpdateBackendTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.operationUid)) {
      query["OperationUid"] = request.operationUid;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeUpdateBackendTask",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeUpdateBackendTaskResponse>(await this.callApi(params, req, runtime), new DescribeUpdateBackendTaskResponse({}));
  }

  /**
   * 查询批量更新API后端元定结果
   * 
   * @param request - DescribeUpdateBackendTaskRequest
   * @returns DescribeUpdateBackendTaskResponse
   */
  async describeUpdateBackendTask(request: DescribeUpdateBackendTaskRequest): Promise<DescribeUpdateBackendTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeUpdateBackendTaskWithOptions(request, runtime);
  }

  /**
   * @param request - DescribeUpdateVpcInfoTaskRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeUpdateVpcInfoTaskResponse
   */
  async describeUpdateVpcInfoTaskWithOptions(request: DescribeUpdateVpcInfoTaskRequest, runtime: $Util.RuntimeOptions): Promise<DescribeUpdateVpcInfoTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.operationUid)) {
      query["OperationUid"] = request.operationUid;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeUpdateVpcInfoTask",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeUpdateVpcInfoTaskResponse>(await this.callApi(params, req, runtime), new DescribeUpdateVpcInfoTaskResponse({}));
  }

  /**
   * @param request - DescribeUpdateVpcInfoTaskRequest
   * @returns DescribeUpdateVpcInfoTaskResponse
   */
  async describeUpdateVpcInfoTask(request: DescribeUpdateVpcInfoTaskRequest): Promise<DescribeUpdateVpcInfoTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeUpdateVpcInfoTaskWithOptions(request, runtime);
  }

  /**
   * Queries VPC access authorizations.
   * 
   * @param request - DescribeVpcAccessesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeVpcAccessesResponse
   */
  async describeVpcAccessesWithOptions(request: DescribeVpcAccessesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeVpcAccessesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.accurateQuery)) {
      query["AccurateQuery"] = request.accurateQuery;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.port)) {
      query["Port"] = request.port;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!Util.isUnset(request.vpcAccessId)) {
      query["VpcAccessId"] = request.vpcAccessId;
    }

    if (!Util.isUnset(request.vpcId)) {
      query["VpcId"] = request.vpcId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeVpcAccesses",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeVpcAccessesResponse>(await this.callApi(params, req, runtime), new DescribeVpcAccessesResponse({}));
  }

  /**
   * Queries VPC access authorizations.
   * 
   * @param request - DescribeVpcAccessesRequest
   * @returns DescribeVpcAccessesResponse
   */
  async describeVpcAccesses(request: DescribeVpcAccessesRequest): Promise<DescribeVpcAccessesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeVpcAccessesWithOptions(request, runtime);
  }

  /**
   * Queries zones in a region.
   * 
   * @param request - DescribeZonesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeZonesResponse
   */
  async describeZonesWithOptions(request: DescribeZonesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeZonesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.language)) {
      query["Language"] = request.language;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeZones",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeZonesResponse>(await this.callApi(params, req, runtime), new DescribeZonesResponse({}));
  }

  /**
   * Queries zones in a region.
   * 
   * @param request - DescribeZonesRequest
   * @returns DescribeZonesResponse
   */
  async describeZones(request: DescribeZonesRequest): Promise<DescribeZonesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeZonesWithOptions(request, runtime);
  }

  /**
   * Detaches APIs from an API product.
   * 
   * @param request - DetachApiProductRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DetachApiProductResponse
   */
  async detachApiProductWithOptions(request: DetachApiProductRequest, runtime: $Util.RuntimeOptions): Promise<DetachApiProductResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.apiProductId)) {
      query["ApiProductId"] = request.apiProductId;
    }

    if (!Util.isUnset(request.apis)) {
      query["Apis"] = request.apis;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DetachApiProduct",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DetachApiProductResponse>(await this.callApi(params, req, runtime), new DetachApiProductResponse({}));
  }

  /**
   * Detaches APIs from an API product.
   * 
   * @param request - DetachApiProductRequest
   * @returns DetachApiProductResponse
   */
  async detachApiProduct(request: DetachApiProductRequest): Promise<DetachApiProductResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.detachApiProductWithOptions(request, runtime);
  }

  /**
   * 解绑插件
   * 
   * @param request - DetachPluginRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DetachPluginResponse
   */
  async detachPluginWithOptions(request: DetachPluginRequest, runtime: $Util.RuntimeOptions): Promise<DetachPluginResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.apiId)) {
      query["ApiId"] = request.apiId;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.pluginId)) {
      query["PluginId"] = request.pluginId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.stageName)) {
      query["StageName"] = request.stageName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DetachPlugin",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DetachPluginResponse>(await this.callApi(params, req, runtime), new DetachPluginResponse({}));
  }

  /**
   * 解绑插件
   * 
   * @param request - DetachPluginRequest
   * @returns DetachPluginResponse
   */
  async detachPlugin(request: DetachPluginRequest): Promise<DetachPluginResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.detachPluginWithOptions(request, runtime);
  }

  /**
   * This feature provides instance-level access control capabilities for dedicated API Gateway instances. Disables access control on an instance.
   * 
   * @param request - DisableInstanceAccessControlRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DisableInstanceAccessControlResponse
   */
  async disableInstanceAccessControlWithOptions(request: DisableInstanceAccessControlRequest, runtime: $Util.RuntimeOptions): Promise<DisableInstanceAccessControlResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.aclId)) {
      query["AclId"] = request.aclId;
    }

    if (!Util.isUnset(request.addressIPVersion)) {
      query["AddressIPVersion"] = request.addressIPVersion;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DisableInstanceAccessControl",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DisableInstanceAccessControlResponse>(await this.callApi(params, req, runtime), new DisableInstanceAccessControlResponse({}));
  }

  /**
   * This feature provides instance-level access control capabilities for dedicated API Gateway instances. Disables access control on an instance.
   * 
   * @param request - DisableInstanceAccessControlRequest
   * @returns DisableInstanceAccessControlResponse
   */
  async disableInstanceAccessControl(request: DisableInstanceAccessControlRequest): Promise<DisableInstanceAccessControlResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.disableInstanceAccessControlWithOptions(request, runtime);
  }

  /**
   * 专享实例解除的关联内网域名解析记录
   * 
   * @param tmpReq - DissociateInstanceWithPrivateDNSRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DissociateInstanceWithPrivateDNSResponse
   */
  async dissociateInstanceWithPrivateDNSWithOptions(tmpReq: DissociateInstanceWithPrivateDNSRequest, runtime: $Util.RuntimeOptions): Promise<DissociateInstanceWithPrivateDNSResponse> {
    Util.validateModel(tmpReq);
    let request = new DissociateInstanceWithPrivateDNSShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.intranetDomains)) {
      request.intranetDomainsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.intranetDomains, "IntranetDomains", "json");
    }

    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.intranetDomainsShrink)) {
      body["IntranetDomains"] = request.intranetDomainsShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DissociateInstanceWithPrivateDNS",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DissociateInstanceWithPrivateDNSResponse>(await this.callApi(params, req, runtime), new DissociateInstanceWithPrivateDNSResponse({}));
  }

  /**
   * 专享实例解除的关联内网域名解析记录
   * 
   * @param request - DissociateInstanceWithPrivateDNSRequest
   * @returns DissociateInstanceWithPrivateDNSResponse
   */
  async dissociateInstanceWithPrivateDNS(request: DissociateInstanceWithPrivateDNSRequest): Promise<DissociateInstanceWithPrivateDNSResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.dissociateInstanceWithPrivateDNSWithOptions(request, runtime);
  }

  /**
   * Checks the syntax before Swagger-compliant data is imported.
   * 
   * @param tmpReq - DryRunSwaggerRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DryRunSwaggerResponse
   */
  async dryRunSwaggerWithOptions(tmpReq: DryRunSwaggerRequest, runtime: $Util.RuntimeOptions): Promise<DryRunSwaggerResponse> {
    Util.validateModel(tmpReq);
    let request = new DryRunSwaggerShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.globalCondition)) {
      request.globalConditionShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.globalCondition, "GlobalCondition", "json");
    }

    let query = { };
    if (!Util.isUnset(request.dataFormat)) {
      query["DataFormat"] = request.dataFormat;
    }

    if (!Util.isUnset(request.globalConditionShrink)) {
      query["GlobalCondition"] = request.globalConditionShrink;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.overwrite)) {
      query["Overwrite"] = request.overwrite;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.data)) {
      body["Data"] = request.data;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DryRunSwagger",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DryRunSwaggerResponse>(await this.callApi(params, req, runtime), new DryRunSwaggerResponse({}));
  }

  /**
   * Checks the syntax before Swagger-compliant data is imported.
   * 
   * @param request - DryRunSwaggerRequest
   * @returns DryRunSwaggerResponse
   */
  async dryRunSwagger(request: DryRunSwaggerRequest): Promise<DryRunSwaggerResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.dryRunSwaggerWithOptions(request, runtime);
  }

  /**
   * 开启实例的访问控制
   * 
   * @param request - EnableInstanceAccessControlRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns EnableInstanceAccessControlResponse
   */
  async enableInstanceAccessControlWithOptions(request: EnableInstanceAccessControlRequest, runtime: $Util.RuntimeOptions): Promise<EnableInstanceAccessControlResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.aclId)) {
      query["AclId"] = request.aclId;
    }

    if (!Util.isUnset(request.aclType)) {
      query["AclType"] = request.aclType;
    }

    if (!Util.isUnset(request.addressIPVersion)) {
      query["AddressIPVersion"] = request.addressIPVersion;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "EnableInstanceAccessControl",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<EnableInstanceAccessControlResponse>(await this.callApi(params, req, runtime), new EnableInstanceAccessControlResponse({}));
  }

  /**
   * 开启实例的访问控制
   * 
   * @param request - EnableInstanceAccessControlRequest
   * @returns EnableInstanceAccessControlResponse
   */
  async enableInstanceAccessControl(request: EnableInstanceAccessControlRequest): Promise<EnableInstanceAccessControlResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.enableInstanceAccessControlWithOptions(request, runtime);
  }

  /**
   * 导出OAS
   * 
   * @param tmpReq - ExportOASRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ExportOASResponse
   */
  async exportOASWithOptions(tmpReq: ExportOASRequest, runtime: $Util.RuntimeOptions): Promise<ExportOASResponse> {
    Util.validateModel(tmpReq);
    let request = new ExportOASShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.apiIdList)) {
      request.apiIdListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.apiIdList, "ApiIdList", "json");
    }

    let query = { };
    if (!Util.isUnset(request.apiIdListShrink)) {
      query["ApiIdList"] = request.apiIdListShrink;
    }

    if (!Util.isUnset(request.dataFormat)) {
      query["DataFormat"] = request.dataFormat;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.oasVersion)) {
      query["OasVersion"] = request.oasVersion;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.stageName)) {
      query["StageName"] = request.stageName;
    }

    if (!Util.isUnset(request.withXExtensions)) {
      query["WithXExtensions"] = request.withXExtensions;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ExportOAS",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ExportOASResponse>(await this.callApi(params, req, runtime), new ExportOASResponse({}));
  }

  /**
   * 导出OAS
   * 
   * @param request - ExportOASRequest
   * @returns ExportOASResponse
   */
  async exportOAS(request: ExportOASRequest): Promise<ExportOASResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.exportOASWithOptions(request, runtime);
  }

  /**
   * Imports APIs based on the OAS standard.
   * 
   * @param request - ImportOASRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ImportOASResponse
   */
  async importOASWithOptions(request: ImportOASRequest, runtime: $Util.RuntimeOptions): Promise<ImportOASResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.authType)) {
      query["AuthType"] = request.authType;
    }

    if (!Util.isUnset(request.backendName)) {
      query["BackendName"] = request.backendName;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.ignoreWarning)) {
      query["IgnoreWarning"] = request.ignoreWarning;
    }

    if (!Util.isUnset(request.OASVersion)) {
      query["OASVersion"] = request.OASVersion;
    }

    if (!Util.isUnset(request.overwrite)) {
      query["Overwrite"] = request.overwrite;
    }

    if (!Util.isUnset(request.requestMode)) {
      query["RequestMode"] = request.requestMode;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.skipDryRun)) {
      query["SkipDryRun"] = request.skipDryRun;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.data)) {
      body["Data"] = request.data;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ImportOAS",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ImportOASResponse>(await this.callApi(params, req, runtime), new ImportOASResponse({}));
  }

  /**
   * Imports APIs based on the OAS standard.
   * 
   * @param request - ImportOASRequest
   * @returns ImportOASResponse
   */
  async importOAS(request: ImportOASRequest): Promise<ImportOASResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.importOASWithOptions(request, runtime);
  }

  /**
   * Creates an API by importing Swagger-compliant data.
   * 
   * @remarks
   *   Alibaba Cloud supports extensions based on Swagger 2.0.
   * *   Alibaba Cloud supports Swagger configuration files in JSON and YAML formats.
   * 
   * @param tmpReq - ImportSwaggerRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ImportSwaggerResponse
   */
  async importSwaggerWithOptions(tmpReq: ImportSwaggerRequest, runtime: $Util.RuntimeOptions): Promise<ImportSwaggerResponse> {
    Util.validateModel(tmpReq);
    let request = new ImportSwaggerShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.globalCondition)) {
      request.globalConditionShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.globalCondition, "GlobalCondition", "json");
    }

    let query = { };
    if (!Util.isUnset(request.dataFormat)) {
      query["DataFormat"] = request.dataFormat;
    }

    if (!Util.isUnset(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!Util.isUnset(request.globalConditionShrink)) {
      query["GlobalCondition"] = request.globalConditionShrink;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.overwrite)) {
      query["Overwrite"] = request.overwrite;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.data)) {
      body["Data"] = request.data;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ImportSwagger",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ImportSwaggerResponse>(await this.callApi(params, req, runtime), new ImportSwaggerResponse({}));
  }

  /**
   * Creates an API by importing Swagger-compliant data.
   * 
   * @remarks
   *   Alibaba Cloud supports extensions based on Swagger 2.0.
   * *   Alibaba Cloud supports Swagger configuration files in JSON and YAML formats.
   * 
   * @param request - ImportSwaggerRequest
   * @returns ImportSwaggerResponse
   */
  async importSwagger(request: ImportSwaggerRequest): Promise<ImportSwaggerResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.importSwaggerWithOptions(request, runtime);
  }

  /**
   * 查询内网域名解析
   * 
   * @param request - ListPrivateDNSRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListPrivateDNSResponse
   */
  async listPrivateDNSWithOptions(request: ListPrivateDNSRequest, runtime: $Util.RuntimeOptions): Promise<ListPrivateDNSResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.intranetDomain)) {
      query["IntranetDomain"] = request.intranetDomain;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListPrivateDNS",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListPrivateDNSResponse>(await this.callApi(params, req, runtime), new ListPrivateDNSResponse({}));
  }

  /**
   * 查询内网域名解析
   * 
   * @param request - ListPrivateDNSRequest
   * @returns ListPrivateDNSResponse
   */
  async listPrivateDNS(request: ListPrivateDNSRequest): Promise<ListPrivateDNSResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listPrivateDNSWithOptions(request, runtime);
  }

  /**
   * Queries the visible resource tags.
   * 
   * @remarks
   *   The Tag.N.Key and Tag.N.Value parameters constitute a key-value pair.
   * *   ResourceId.N must meet all the key-value pairs that are entered. If you enter multiple key-value pairs, resources that contain the specified key-value pairs are returned.
   * *   This operation is used to query resource tags based on conditions. If no relationship matches the conditions, an empty list is returned.
   * *   You can query both user tags and visible system tags.
   * *   In addition to the required parameters, you can also specify ResourceId.N to query the visible resource tags of a specified resource in a region.
   * *   You can also specify Tag.N.Key to query the visible keys of a specified key in a region.
   * *   At least one of ResourceId.N, Tag.N.Key, and Tag.N.Value exists.
   * *   You can query tags of the same type or different types in a single operation.
   * *   You can query all your user types and visible system tags.
   * 
   * @param request - ListTagResourcesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListTagResourcesResponse
   */
  async listTagResourcesWithOptions(request: ListTagResourcesRequest, runtime: $Util.RuntimeOptions): Promise<ListTagResourcesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!Util.isUnset(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListTagResources",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListTagResourcesResponse>(await this.callApi(params, req, runtime), new ListTagResourcesResponse({}));
  }

  /**
   * Queries the visible resource tags.
   * 
   * @remarks
   *   The Tag.N.Key and Tag.N.Value parameters constitute a key-value pair.
   * *   ResourceId.N must meet all the key-value pairs that are entered. If you enter multiple key-value pairs, resources that contain the specified key-value pairs are returned.
   * *   This operation is used to query resource tags based on conditions. If no relationship matches the conditions, an empty list is returned.
   * *   You can query both user tags and visible system tags.
   * *   In addition to the required parameters, you can also specify ResourceId.N to query the visible resource tags of a specified resource in a region.
   * *   You can also specify Tag.N.Key to query the visible keys of a specified key in a region.
   * *   At least one of ResourceId.N, Tag.N.Key, and Tag.N.Value exists.
   * *   You can query tags of the same type or different types in a single operation.
   * *   You can query all your user types and visible system tags.
   * 
   * @param request - ListTagResourcesRequest
   * @returns ListTagResourcesResponse
   */
  async listTagResources(request: ListTagResourcesRequest): Promise<ListTagResourcesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listTagResourcesWithOptions(request, runtime);
  }

  /**
   * Modifies the definition of an API.
   * 
   * @remarks
   * *This operation is intended for API providers.**
   * *   This API operation requires a full update. Updates of partial parameters are not supported.
   * *   When you modify an API name, make sure that the name of each API within the same group is unique.
   * *   When you modify the request path, make sure that each request path within the same group is unique.
   * *   The QPS limit on this operation is 50 per user.
   * 
   * @param request - ModifyApiRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyApiResponse
   */
  async modifyApiWithOptions(request: ModifyApiRequest, runtime: $Util.RuntimeOptions): Promise<ModifyApiResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.allowSignatureMethod)) {
      query["AllowSignatureMethod"] = request.allowSignatureMethod;
    }

    if (!Util.isUnset(request.apiId)) {
      query["ApiId"] = request.apiId;
    }

    if (!Util.isUnset(request.apiName)) {
      query["ApiName"] = request.apiName;
    }

    if (!Util.isUnset(request.appCodeAuthType)) {
      query["AppCodeAuthType"] = request.appCodeAuthType;
    }

    if (!Util.isUnset(request.authType)) {
      query["AuthType"] = request.authType;
    }

    if (!Util.isUnset(request.backendEnable)) {
      query["BackendEnable"] = request.backendEnable;
    }

    if (!Util.isUnset(request.backendId)) {
      query["BackendId"] = request.backendId;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.disableInternet)) {
      query["DisableInternet"] = request.disableInternet;
    }

    if (!Util.isUnset(request.forceNonceCheck)) {
      query["ForceNonceCheck"] = request.forceNonceCheck;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.openIdConnectConfig)) {
      query["OpenIdConnectConfig"] = request.openIdConnectConfig;
    }

    if (!Util.isUnset(request.requestConfig)) {
      query["RequestConfig"] = request.requestConfig;
    }

    if (!Util.isUnset(request.resultBodyModel)) {
      query["ResultBodyModel"] = request.resultBodyModel;
    }

    if (!Util.isUnset(request.resultType)) {
      query["ResultType"] = request.resultType;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.serviceConfig)) {
      query["ServiceConfig"] = request.serviceConfig;
    }

    if (!Util.isUnset(request.visibility)) {
      query["Visibility"] = request.visibility;
    }

    if (!Util.isUnset(request.webSocketApiType)) {
      query["WebSocketApiType"] = request.webSocketApiType;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.constantParameters)) {
      body["ConstantParameters"] = request.constantParameters;
    }

    if (!Util.isUnset(request.errorCodeSamples)) {
      body["ErrorCodeSamples"] = request.errorCodeSamples;
    }

    if (!Util.isUnset(request.failResultSample)) {
      body["FailResultSample"] = request.failResultSample;
    }

    if (!Util.isUnset(request.requestParameters)) {
      body["RequestParameters"] = request.requestParameters;
    }

    if (!Util.isUnset(request.resultDescriptions)) {
      body["ResultDescriptions"] = request.resultDescriptions;
    }

    if (!Util.isUnset(request.resultSample)) {
      body["ResultSample"] = request.resultSample;
    }

    if (!Util.isUnset(request.serviceParameters)) {
      body["ServiceParameters"] = request.serviceParameters;
    }

    if (!Util.isUnset(request.serviceParametersMap)) {
      body["ServiceParametersMap"] = request.serviceParametersMap;
    }

    if (!Util.isUnset(request.systemParameters)) {
      body["SystemParameters"] = request.systemParameters;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ModifyApi",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyApiResponse>(await this.callApi(params, req, runtime), new ModifyApiResponse({}));
  }

  /**
   * Modifies the definition of an API.
   * 
   * @remarks
   * *This operation is intended for API providers.**
   * *   This API operation requires a full update. Updates of partial parameters are not supported.
   * *   When you modify an API name, make sure that the name of each API within the same group is unique.
   * *   When you modify the request path, make sure that each request path within the same group is unique.
   * *   The QPS limit on this operation is 50 per user.
   * 
   * @param request - ModifyApiRequest
   * @returns ModifyApiResponse
   */
  async modifyApi(request: ModifyApiRequest): Promise<ModifyApiResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyApiWithOptions(request, runtime);
  }

  /**
   * Modifies the draft definition of an API. This operation is different from the ModifyApi operation. This operation does not require all information about the API. You need to only specify the parameters that you want to modify. For example, if you want to change the authentication method of the API from Anonymous to APP, you specify APP as the value of AuthType and do not need to configure other parameters.
   * 
   * @param request - ModifyApiConfigurationRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyApiConfigurationResponse
   */
  async modifyApiConfigurationWithOptions(request: ModifyApiConfigurationRequest, runtime: $Util.RuntimeOptions): Promise<ModifyApiConfigurationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.allowSignatureMethod)) {
      query["AllowSignatureMethod"] = request.allowSignatureMethod;
    }

    if (!Util.isUnset(request.apiId)) {
      query["ApiId"] = request.apiId;
    }

    if (!Util.isUnset(request.apiName)) {
      query["ApiName"] = request.apiName;
    }

    if (!Util.isUnset(request.appCodeAuthType)) {
      query["AppCodeAuthType"] = request.appCodeAuthType;
    }

    if (!Util.isUnset(request.authType)) {
      query["AuthType"] = request.authType;
    }

    if (!Util.isUnset(request.backendName)) {
      query["BackendName"] = request.backendName;
    }

    if (!Util.isUnset(request.bodyFormat)) {
      query["BodyFormat"] = request.bodyFormat;
    }

    if (!Util.isUnset(request.bodyModel)) {
      query["BodyModel"] = request.bodyModel;
    }

    if (!Util.isUnset(request.contentTypeCategory)) {
      query["ContentTypeCategory"] = request.contentTypeCategory;
    }

    if (!Util.isUnset(request.contentTypeValue)) {
      query["ContentTypeValue"] = request.contentTypeValue;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.disableInternet)) {
      query["DisableInternet"] = request.disableInternet;
    }

    if (!Util.isUnset(request.errorCodeSamples)) {
      query["ErrorCodeSamples"] = request.errorCodeSamples;
    }

    if (!Util.isUnset(request.failResultSample)) {
      query["FailResultSample"] = request.failResultSample;
    }

    if (!Util.isUnset(request.forceNonceCheck)) {
      query["ForceNonceCheck"] = request.forceNonceCheck;
    }

    if (!Util.isUnset(request.functionComputeConfig)) {
      query["FunctionComputeConfig"] = request.functionComputeConfig;
    }

    if (!Util.isUnset(request.httpConfig)) {
      query["HttpConfig"] = request.httpConfig;
    }

    if (!Util.isUnset(request.mockConfig)) {
      query["MockConfig"] = request.mockConfig;
    }

    if (!Util.isUnset(request.modelName)) {
      query["ModelName"] = request.modelName;
    }

    if (!Util.isUnset(request.ossConfig)) {
      query["OssConfig"] = request.ossConfig;
    }

    if (!Util.isUnset(request.postBodyDescription)) {
      query["PostBodyDescription"] = request.postBodyDescription;
    }

    if (!Util.isUnset(request.requestHttpMethod)) {
      query["RequestHttpMethod"] = request.requestHttpMethod;
    }

    if (!Util.isUnset(request.requestMode)) {
      query["RequestMode"] = request.requestMode;
    }

    if (!Util.isUnset(request.requestParameters)) {
      query["RequestParameters"] = request.requestParameters;
    }

    if (!Util.isUnset(request.requestPath)) {
      query["RequestPath"] = request.requestPath;
    }

    if (!Util.isUnset(request.requestProtocol)) {
      query["RequestProtocol"] = request.requestProtocol;
    }

    if (!Util.isUnset(request.resultSample)) {
      query["ResultSample"] = request.resultSample;
    }

    if (!Util.isUnset(request.resultType)) {
      query["ResultType"] = request.resultType;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.serviceParameters)) {
      query["ServiceParameters"] = request.serviceParameters;
    }

    if (!Util.isUnset(request.serviceParametersMap)) {
      query["ServiceParametersMap"] = request.serviceParametersMap;
    }

    if (!Util.isUnset(request.serviceProtocol)) {
      query["ServiceProtocol"] = request.serviceProtocol;
    }

    if (!Util.isUnset(request.serviceTimeout)) {
      query["ServiceTimeout"] = request.serviceTimeout;
    }

    if (!Util.isUnset(request.useBackendService)) {
      query["UseBackendService"] = request.useBackendService;
    }

    if (!Util.isUnset(request.visibility)) {
      query["Visibility"] = request.visibility;
    }

    if (!Util.isUnset(request.vpcConfig)) {
      query["VpcConfig"] = request.vpcConfig;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyApiConfiguration",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyApiConfigurationResponse>(await this.callApi(params, req, runtime), new ModifyApiConfigurationResponse({}));
  }

  /**
   * Modifies the draft definition of an API. This operation is different from the ModifyApi operation. This operation does not require all information about the API. You need to only specify the parameters that you want to modify. For example, if you want to change the authentication method of the API from Anonymous to APP, you specify APP as the value of AuthType and do not need to configure other parameters.
   * 
   * @param request - ModifyApiConfigurationRequest
   * @returns ModifyApiConfigurationResponse
   */
  async modifyApiConfiguration(request: ModifyApiConfigurationRequest): Promise<ModifyApiConfigurationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyApiConfigurationWithOptions(request, runtime);
  }

  /**
   * Modifies the name, description, or basepath of an existing API group.
   * 
   * @remarks
   *   This operation is intended for API providers.
   * *   The QPS limit on this operation is 50 per user.
   * 
   * @param request - ModifyApiGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyApiGroupResponse
   */
  async modifyApiGroupWithOptions(request: ModifyApiGroupRequest, runtime: $Util.RuntimeOptions): Promise<ModifyApiGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.basePath)) {
      query["BasePath"] = request.basePath;
    }

    if (!Util.isUnset(request.compatibleFlags)) {
      query["CompatibleFlags"] = request.compatibleFlags;
    }

    if (!Util.isUnset(request.customTraceConfig)) {
      query["CustomTraceConfig"] = request.customTraceConfig;
    }

    if (!Util.isUnset(request.customerConfigs)) {
      query["CustomerConfigs"] = request.customerConfigs;
    }

    if (!Util.isUnset(request.defaultDomain)) {
      query["DefaultDomain"] = request.defaultDomain;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.filterAppCodeForBackend)) {
      query["FilterAppCodeForBackend"] = request.filterAppCodeForBackend;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.groupName)) {
      query["GroupName"] = request.groupName;
    }

    if (!Util.isUnset(request.passthroughHeaders)) {
      query["PassthroughHeaders"] = request.passthroughHeaders;
    }

    if (!Util.isUnset(request.rpcPattern)) {
      query["RpcPattern"] = request.rpcPattern;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.supportSSE)) {
      query["SupportSSE"] = request.supportSSE;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!Util.isUnset(request.userLogConfig)) {
      query["UserLogConfig"] = request.userLogConfig;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyApiGroup",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyApiGroupResponse>(await this.callApi(params, req, runtime), new ModifyApiGroupResponse({}));
  }

  /**
   * Modifies the name, description, or basepath of an existing API group.
   * 
   * @remarks
   *   This operation is intended for API providers.
   * *   The QPS limit on this operation is 50 per user.
   * 
   * @param request - ModifyApiGroupRequest
   * @returns ModifyApiGroupResponse
   */
  async modifyApiGroup(request: ModifyApiGroupRequest): Promise<ModifyApiGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyApiGroupWithOptions(request, runtime);
  }

  /**
   * @param request - ModifyApiGroupInstanceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyApiGroupInstanceResponse
   */
  async modifyApiGroupInstanceWithOptions(request: ModifyApiGroupInstanceRequest, runtime: $Util.RuntimeOptions): Promise<ModifyApiGroupInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.remark)) {
      query["Remark"] = request.remark;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!Util.isUnset(request.targetInstanceId)) {
      query["TargetInstanceId"] = request.targetInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyApiGroupInstance",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyApiGroupInstanceResponse>(await this.callApi(params, req, runtime), new ModifyApiGroupInstanceResponse({}));
  }

  /**
   * @param request - ModifyApiGroupInstanceRequest
   * @returns ModifyApiGroupInstanceResponse
   */
  async modifyApiGroupInstance(request: ModifyApiGroupInstanceRequest): Promise<ModifyApiGroupInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyApiGroupInstanceWithOptions(request, runtime);
  }

  /**
   * Modifies the network policy of an API group.
   * 
   * @param request - ModifyApiGroupNetworkPolicyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyApiGroupNetworkPolicyResponse
   */
  async modifyApiGroupNetworkPolicyWithOptions(request: ModifyApiGroupNetworkPolicyRequest, runtime: $Util.RuntimeOptions): Promise<ModifyApiGroupNetworkPolicyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.httpsPolicy)) {
      query["HttpsPolicy"] = request.httpsPolicy;
    }

    if (!Util.isUnset(request.innerDomainEnable)) {
      query["InnerDomainEnable"] = request.innerDomainEnable;
    }

    if (!Util.isUnset(request.internetEnable)) {
      query["InternetEnable"] = request.internetEnable;
    }

    if (!Util.isUnset(request.internetIPV6Enable)) {
      query["InternetIPV6Enable"] = request.internetIPV6Enable;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.vpcIntranetEnable)) {
      query["VpcIntranetEnable"] = request.vpcIntranetEnable;
    }

    if (!Util.isUnset(request.vpcSlbIntranetEnable)) {
      query["VpcSlbIntranetEnable"] = request.vpcSlbIntranetEnable;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyApiGroupNetworkPolicy",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyApiGroupNetworkPolicyResponse>(await this.callApi(params, req, runtime), new ModifyApiGroupNetworkPolicyResponse({}));
  }

  /**
   * Modifies the network policy of an API group.
   * 
   * @param request - ModifyApiGroupNetworkPolicyRequest
   * @returns ModifyApiGroupNetworkPolicyResponse
   */
  async modifyApiGroupNetworkPolicy(request: ModifyApiGroupNetworkPolicyRequest): Promise<ModifyApiGroupNetworkPolicyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyApiGroupNetworkPolicyWithOptions(request, runtime);
  }

  /**
   * Modifies the VPC whitelist of an API group.
   * 
   * @param request - ModifyApiGroupVpcWhitelistRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyApiGroupVpcWhitelistResponse
   */
  async modifyApiGroupVpcWhitelistWithOptions(request: ModifyApiGroupVpcWhitelistRequest, runtime: $Util.RuntimeOptions): Promise<ModifyApiGroupVpcWhitelistResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.vpcIds)) {
      query["VpcIds"] = request.vpcIds;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyApiGroupVpcWhitelist",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyApiGroupVpcWhitelistResponse>(await this.callApi(params, req, runtime), new ModifyApiGroupVpcWhitelistResponse({}));
  }

  /**
   * Modifies the VPC whitelist of an API group.
   * 
   * @param request - ModifyApiGroupVpcWhitelistRequest
   * @returns ModifyApiGroupVpcWhitelistResponse
   */
  async modifyApiGroupVpcWhitelist(request: ModifyApiGroupVpcWhitelistRequest): Promise<ModifyApiGroupVpcWhitelistResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyApiGroupVpcWhitelistWithOptions(request, runtime);
  }

  /**
   * Modifies a specified application.
   * 
   * @remarks
   *   This operation is intended for API callers.
   * *   **AppName** or **Description** can be modified. If these parameters are not specified, no modifications are made and the operation will directly return a success response.
   * *   You can call this operation up to 50 times per second per account.
   * 
   * @param request - ModifyAppRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyAppResponse
   */
  async modifyAppWithOptions(request: ModifyAppRequest, runtime: $Util.RuntimeOptions): Promise<ModifyAppResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.extend)) {
      query["Extend"] = request.extend;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyApp",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyAppResponse>(await this.callApi(params, req, runtime), new ModifyAppResponse({}));
  }

  /**
   * Modifies a specified application.
   * 
   * @remarks
   *   This operation is intended for API callers.
   * *   **AppName** or **Description** can be modified. If these parameters are not specified, no modifications are made and the operation will directly return a success response.
   * *   You can call this operation up to 50 times per second per account.
   * 
   * @param request - ModifyAppRequest
   * @returns ModifyAppResponse
   */
  async modifyApp(request: ModifyAppRequest): Promise<ModifyAppResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyAppWithOptions(request, runtime);
  }

  /**
   * 修改后端服务
   * 
   * @param request - ModifyBackendRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyBackendResponse
   */
  async modifyBackendWithOptions(request: ModifyBackendRequest, runtime: $Util.RuntimeOptions): Promise<ModifyBackendResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.backendId)) {
      query["BackendId"] = request.backendId;
    }

    if (!Util.isUnset(request.backendName)) {
      query["BackendName"] = request.backendName;
    }

    if (!Util.isUnset(request.backendType)) {
      query["BackendType"] = request.backendType;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyBackend",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyBackendResponse>(await this.callApi(params, req, runtime), new ModifyBackendResponse({}));
  }

  /**
   * 修改后端服务
   * 
   * @param request - ModifyBackendRequest
   * @returns ModifyBackendResponse
   */
  async modifyBackend(request: ModifyBackendRequest): Promise<ModifyBackendResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyBackendWithOptions(request, runtime);
  }

  /**
   * 修改后端服务在环境上的定义
   * 
   * @param request - ModifyBackendModelRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyBackendModelResponse
   */
  async modifyBackendModelWithOptions(request: ModifyBackendModelRequest, runtime: $Util.RuntimeOptions): Promise<ModifyBackendModelResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.backendId)) {
      query["BackendId"] = request.backendId;
    }

    if (!Util.isUnset(request.backendModelData)) {
      query["BackendModelData"] = request.backendModelData;
    }

    if (!Util.isUnset(request.backendModelId)) {
      query["BackendModelId"] = request.backendModelId;
    }

    if (!Util.isUnset(request.backendType)) {
      query["BackendType"] = request.backendType;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.stageName)) {
      query["StageName"] = request.stageName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyBackendModel",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyBackendModelResponse>(await this.callApi(params, req, runtime), new ModifyBackendModelResponse({}));
  }

  /**
   * 修改后端服务在环境上的定义
   * 
   * @param request - ModifyBackendModelRequest
   * @returns ModifyBackendModelResponse
   */
  async modifyBackendModel(request: ModifyBackendModelRequest): Promise<ModifyBackendModelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyBackendModelWithOptions(request, runtime);
  }

  /**
   * Modifies the name of a custom dataset.
   * 
   * @param request - ModifyDatasetRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyDatasetResponse
   */
  async modifyDatasetWithOptions(request: ModifyDatasetRequest, runtime: $Util.RuntimeOptions): Promise<ModifyDatasetResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.datasetId)) {
      query["DatasetId"] = request.datasetId;
    }

    if (!Util.isUnset(request.datasetName)) {
      query["DatasetName"] = request.datasetName;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyDataset",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyDatasetResponse>(await this.callApi(params, req, runtime), new ModifyDatasetResponse({}));
  }

  /**
   * Modifies the name of a custom dataset.
   * 
   * @param request - ModifyDatasetRequest
   * @returns ModifyDatasetResponse
   */
  async modifyDataset(request: ModifyDatasetRequest): Promise<ModifyDatasetResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyDatasetWithOptions(request, runtime);
  }

  /**
   * Modifies the expiration time and description of a data entry in a custom dataset.
   * 
   * @param request - ModifyDatasetItemRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyDatasetItemResponse
   */
  async modifyDatasetItemWithOptions(request: ModifyDatasetItemRequest, runtime: $Util.RuntimeOptions): Promise<ModifyDatasetItemResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.datasetId)) {
      query["DatasetId"] = request.datasetId;
    }

    if (!Util.isUnset(request.datasetItemId)) {
      query["DatasetItemId"] = request.datasetItemId;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.expiredTime)) {
      query["ExpiredTime"] = request.expiredTime;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyDatasetItem",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyDatasetItemResponse>(await this.callApi(params, req, runtime), new ModifyDatasetItemResponse({}));
  }

  /**
   * Modifies the expiration time and description of a data entry in a custom dataset.
   * 
   * @param request - ModifyDatasetItemRequest
   * @returns ModifyDatasetItemResponse
   */
  async modifyDatasetItem(request: ModifyDatasetItemRequest): Promise<ModifyDatasetItemResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyDatasetItemWithOptions(request, runtime);
  }

  /**
   * 修改API网关实例属性
   * 
   * @param tmpReq - ModifyInstanceAttributeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyInstanceAttributeResponse
   */
  async modifyInstanceAttributeWithOptions(tmpReq: ModifyInstanceAttributeRequest, runtime: $Util.RuntimeOptions): Promise<ModifyInstanceAttributeResponse> {
    Util.validateModel(tmpReq);
    let request = new ModifyInstanceAttributeShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.toConnectVpcIpBlock)) {
      request.toConnectVpcIpBlockShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.toConnectVpcIpBlock, "ToConnectVpcIpBlock", "json");
    }

    let query = { };
    if (!Util.isUnset(request.deleteVpcIpBlock)) {
      query["DeleteVpcIpBlock"] = request.deleteVpcIpBlock;
    }

    if (!Util.isUnset(request.egressIpv6Enable)) {
      query["EgressIpv6Enable"] = request.egressIpv6Enable;
    }

    if (!Util.isUnset(request.httpsPolicy)) {
      query["HttpsPolicy"] = request.httpsPolicy;
    }

    if (!Util.isUnset(request.IPV6Enabled)) {
      query["IPV6Enabled"] = request.IPV6Enabled;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.instanceName)) {
      query["InstanceName"] = request.instanceName;
    }

    if (!Util.isUnset(request.intranetSegments)) {
      query["IntranetSegments"] = request.intranetSegments;
    }

    if (!Util.isUnset(request.maintainEndTime)) {
      query["MaintainEndTime"] = request.maintainEndTime;
    }

    if (!Util.isUnset(request.maintainStartTime)) {
      query["MaintainStartTime"] = request.maintainStartTime;
    }

    if (!Util.isUnset(request.toConnectVpcIpBlockShrink)) {
      query["ToConnectVpcIpBlock"] = request.toConnectVpcIpBlockShrink;
    }

    if (!Util.isUnset(request.token)) {
      query["Token"] = request.token;
    }

    if (!Util.isUnset(request.vpcSlbIntranetEnable)) {
      query["VpcSlbIntranetEnable"] = request.vpcSlbIntranetEnable;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyInstanceAttribute",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyInstanceAttributeResponse>(await this.callApi(params, req, runtime), new ModifyInstanceAttributeResponse({}));
  }

  /**
   * 修改API网关实例属性
   * 
   * @param request - ModifyInstanceAttributeRequest
   * @returns ModifyInstanceAttributeResponse
   */
  async modifyInstanceAttribute(request: ModifyInstanceAttributeRequest): Promise<ModifyInstanceAttributeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyInstanceAttributeWithOptions(request, runtime);
  }

  /**
   * Upgrades or downgrades the configurations of an API Gateway instance.
   * 
   * @param request - ModifyInstanceSpecRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyInstanceSpecResponse
   */
  async modifyInstanceSpecWithOptions(request: ModifyInstanceSpecRequest, runtime: $Util.RuntimeOptions): Promise<ModifyInstanceSpecResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.autoPay)) {
      query["AutoPay"] = request.autoPay;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.instanceSpec)) {
      query["InstanceSpec"] = request.instanceSpec;
    }

    if (!Util.isUnset(request.modifyAction)) {
      query["ModifyAction"] = request.modifyAction;
    }

    if (!Util.isUnset(request.skipWaitSwitch)) {
      query["SkipWaitSwitch"] = request.skipWaitSwitch;
    }

    if (!Util.isUnset(request.token)) {
      query["Token"] = request.token;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyInstanceSpec",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyInstanceSpecResponse>(await this.callApi(params, req, runtime), new ModifyInstanceSpecResponse({}));
  }

  /**
   * Upgrades or downgrades the configurations of an API Gateway instance.
   * 
   * @param request - ModifyInstanceSpecRequest
   * @returns ModifyInstanceSpecResponse
   */
  async modifyInstanceSpec(request: ModifyInstanceSpecRequest): Promise<ModifyInstanceSpecResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyInstanceSpecWithOptions(request, runtime);
  }

  /**
   * Modifies the VPC domain name policy of an API group.
   * 
   * @param request - ModifyIntranetDomainPolicyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyIntranetDomainPolicyResponse
   */
  async modifyIntranetDomainPolicyWithOptions(request: ModifyIntranetDomainPolicyRequest, runtime: $Util.RuntimeOptions): Promise<ModifyIntranetDomainPolicyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.vpcIntranetEnable)) {
      query["VpcIntranetEnable"] = request.vpcIntranetEnable;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyIntranetDomainPolicy",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyIntranetDomainPolicyResponse>(await this.callApi(params, req, runtime), new ModifyIntranetDomainPolicyResponse({}));
  }

  /**
   * Modifies the VPC domain name policy of an API group.
   * 
   * @param request - ModifyIntranetDomainPolicyRequest
   * @returns ModifyIntranetDomainPolicyResponse
   */
  async modifyIntranetDomainPolicy(request: ModifyIntranetDomainPolicyRequest): Promise<ModifyIntranetDomainPolicyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyIntranetDomainPolicyWithOptions(request, runtime);
  }

  /**
   * Modifies an access control list (ACL).
   * 
   * @remarks
   *   This operation is intended for API providers.
   * *   This operation allows you to modify only the name and description of an ACL. You cannot modify the type of the ACL.
   * 
   * @param request - ModifyIpControlRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyIpControlResponse
   */
  async modifyIpControlWithOptions(request: ModifyIpControlRequest, runtime: $Util.RuntimeOptions): Promise<ModifyIpControlResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.ipControlId)) {
      query["IpControlId"] = request.ipControlId;
    }

    if (!Util.isUnset(request.ipControlName)) {
      query["IpControlName"] = request.ipControlName;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyIpControl",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyIpControlResponse>(await this.callApi(params, req, runtime), new ModifyIpControlResponse({}));
  }

  /**
   * Modifies an access control list (ACL).
   * 
   * @remarks
   *   This operation is intended for API providers.
   * *   This operation allows you to modify only the name and description of an ACL. You cannot modify the type of the ACL.
   * 
   * @param request - ModifyIpControlRequest
   * @returns ModifyIpControlResponse
   */
  async modifyIpControl(request: ModifyIpControlRequest): Promise<ModifyIpControlResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyIpControlWithOptions(request, runtime);
  }

  /**
   * Modifies a policy in an access control list (ACL).
   * 
   * @remarks
   *   This operation is intended for API providers.
   * *   The modification immediately takes effect on all the APIs that are bound to the policy.
   * *   This operation causes a full modification of the content of a policy.
   * 
   * @param request - ModifyIpControlPolicyItemRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyIpControlPolicyItemResponse
   */
  async modifyIpControlPolicyItemWithOptions(request: ModifyIpControlPolicyItemRequest, runtime: $Util.RuntimeOptions): Promise<ModifyIpControlPolicyItemResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.cidrIp)) {
      query["CidrIp"] = request.cidrIp;
    }

    if (!Util.isUnset(request.ipControlId)) {
      query["IpControlId"] = request.ipControlId;
    }

    if (!Util.isUnset(request.policyItemId)) {
      query["PolicyItemId"] = request.policyItemId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyIpControlPolicyItem",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyIpControlPolicyItemResponse>(await this.callApi(params, req, runtime), new ModifyIpControlPolicyItemResponse({}));
  }

  /**
   * Modifies a policy in an access control list (ACL).
   * 
   * @remarks
   *   This operation is intended for API providers.
   * *   The modification immediately takes effect on all the APIs that are bound to the policy.
   * *   This operation causes a full modification of the content of a policy.
   * 
   * @param request - ModifyIpControlPolicyItemRequest
   * @returns ModifyIpControlPolicyItemResponse
   */
  async modifyIpControlPolicyItem(request: ModifyIpControlPolicyItemRequest): Promise<ModifyIpControlPolicyItemResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyIpControlPolicyItemWithOptions(request, runtime);
  }

  /**
   * @param request - ModifyLogConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyLogConfigResponse
   */
  async modifyLogConfigWithOptions(request: ModifyLogConfigRequest, runtime: $Util.RuntimeOptions): Promise<ModifyLogConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.logType)) {
      query["LogType"] = request.logType;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.slsLogStore)) {
      query["SlsLogStore"] = request.slsLogStore;
    }

    if (!Util.isUnset(request.slsProject)) {
      query["SlsProject"] = request.slsProject;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyLogConfig",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyLogConfigResponse>(await this.callApi(params, req, runtime), new ModifyLogConfigResponse({}));
  }

  /**
   * @param request - ModifyLogConfigRequest
   * @returns ModifyLogConfigResponse
   */
  async modifyLogConfig(request: ModifyLogConfigRequest): Promise<ModifyLogConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyLogConfigWithOptions(request, runtime);
  }

  /**
   * Updates the model of an API group.
   * 
   * @param request - ModifyModelRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyModelResponse
   */
  async modifyModelWithOptions(request: ModifyModelRequest, runtime: $Util.RuntimeOptions): Promise<ModifyModelResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.modelName)) {
      query["ModelName"] = request.modelName;
    }

    if (!Util.isUnset(request.newModelName)) {
      query["NewModelName"] = request.newModelName;
    }

    if (!Util.isUnset(request.schema)) {
      query["Schema"] = request.schema;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyModel",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyModelResponse>(await this.callApi(params, req, runtime), new ModifyModelResponse({}));
  }

  /**
   * Updates the model of an API group.
   * 
   * @param request - ModifyModelRequest
   * @returns ModifyModelResponse
   */
  async modifyModel(request: ModifyModelRequest): Promise<ModifyModelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyModelWithOptions(request, runtime);
  }

  /**
   * Modifies the information of a plug-in.
   * 
   * @remarks
   *   This operation is intended for API providers.
   * *   The name of the plug-in must be unique.
   * 
   * @param request - ModifyPluginRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyPluginResponse
   */
  async modifyPluginWithOptions(request: ModifyPluginRequest, runtime: $Util.RuntimeOptions): Promise<ModifyPluginResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.pluginData)) {
      query["PluginData"] = request.pluginData;
    }

    if (!Util.isUnset(request.pluginId)) {
      query["PluginId"] = request.pluginId;
    }

    if (!Util.isUnset(request.pluginName)) {
      query["PluginName"] = request.pluginName;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyPlugin",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyPluginResponse>(await this.callApi(params, req, runtime), new ModifyPluginResponse({}));
  }

  /**
   * Modifies the information of a plug-in.
   * 
   * @remarks
   *   This operation is intended for API providers.
   * *   The name of the plug-in must be unique.
   * 
   * @param request - ModifyPluginRequest
   * @returns ModifyPluginResponse
   */
  async modifyPlugin(request: ModifyPluginRequest): Promise<ModifyPluginResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyPluginWithOptions(request, runtime);
  }

  /**
   * Modifies a backend signature key.
   * 
   * @remarks
   *   This API is intended for API providers.
   * *   This API operation modifies the name, Key value, and Secret value of an existing signature key.
   * *   Note that the modification takes effect immediately. If the key has been bound to an API, you must adjust the backend signature verification based on the new key accordingly.
   * *   The QPS limit on this operation is 50 per user.
   * 
   * @param request - ModifySignatureRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifySignatureResponse
   */
  async modifySignatureWithOptions(request: ModifySignatureRequest, runtime: $Util.RuntimeOptions): Promise<ModifySignatureResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.signatureId)) {
      query["SignatureId"] = request.signatureId;
    }

    if (!Util.isUnset(request.signatureKey)) {
      query["SignatureKey"] = request.signatureKey;
    }

    if (!Util.isUnset(request.signatureName)) {
      query["SignatureName"] = request.signatureName;
    }

    if (!Util.isUnset(request.signatureSecret)) {
      query["SignatureSecret"] = request.signatureSecret;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifySignature",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifySignatureResponse>(await this.callApi(params, req, runtime), new ModifySignatureResponse({}));
  }

  /**
   * Modifies a backend signature key.
   * 
   * @remarks
   *   This API is intended for API providers.
   * *   This API operation modifies the name, Key value, and Secret value of an existing signature key.
   * *   Note that the modification takes effect immediately. If the key has been bound to an API, you must adjust the backend signature verification based on the new key accordingly.
   * *   The QPS limit on this operation is 50 per user.
   * 
   * @param request - ModifySignatureRequest
   * @returns ModifySignatureResponse
   */
  async modifySignature(request: ModifySignatureRequest): Promise<ModifySignatureResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifySignatureWithOptions(request, runtime);
  }

  /**
   * Modifies the settings of a custom throttling policy.
   * 
   * @remarks
   *   This API is intended for API providers.
   * *   The modifications take effect on the bound APIs instantly.
   * *   The QPS limit on this operation is 50 per user.
   * 
   * @param request - ModifyTrafficControlRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyTrafficControlResponse
   */
  async modifyTrafficControlWithOptions(request: ModifyTrafficControlRequest, runtime: $Util.RuntimeOptions): Promise<ModifyTrafficControlResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.apiDefault)) {
      query["ApiDefault"] = request.apiDefault;
    }

    if (!Util.isUnset(request.appDefault)) {
      query["AppDefault"] = request.appDefault;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.trafficControlId)) {
      query["TrafficControlId"] = request.trafficControlId;
    }

    if (!Util.isUnset(request.trafficControlName)) {
      query["TrafficControlName"] = request.trafficControlName;
    }

    if (!Util.isUnset(request.trafficControlUnit)) {
      query["TrafficControlUnit"] = request.trafficControlUnit;
    }

    if (!Util.isUnset(request.userDefault)) {
      query["UserDefault"] = request.userDefault;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyTrafficControl",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyTrafficControlResponse>(await this.callApi(params, req, runtime), new ModifyTrafficControlResponse({}));
  }

  /**
   * Modifies the settings of a custom throttling policy.
   * 
   * @remarks
   *   This API is intended for API providers.
   * *   The modifications take effect on the bound APIs instantly.
   * *   The QPS limit on this operation is 50 per user.
   * 
   * @param request - ModifyTrafficControlRequest
   * @returns ModifyTrafficControlResponse
   */
  async modifyTrafficControl(request: ModifyTrafficControlRequest): Promise<ModifyTrafficControlResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyTrafficControlWithOptions(request, runtime);
  }

  /**
   * Modifies a virtual private cloud (VPC) authorization and updates the metadata of the API associated with the VPC authorization.
   * 
   * @param request - ModifyVpcAccessAndUpdateApisRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyVpcAccessAndUpdateApisResponse
   */
  async modifyVpcAccessAndUpdateApisWithOptions(request: ModifyVpcAccessAndUpdateApisRequest, runtime: $Util.RuntimeOptions): Promise<ModifyVpcAccessAndUpdateApisResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.needBatchWork)) {
      query["NeedBatchWork"] = request.needBatchWork;
    }

    if (!Util.isUnset(request.port)) {
      query["Port"] = request.port;
    }

    if (!Util.isUnset(request.refresh)) {
      query["Refresh"] = request.refresh;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.token)) {
      query["Token"] = request.token;
    }

    if (!Util.isUnset(request.vpcId)) {
      query["VpcId"] = request.vpcId;
    }

    if (!Util.isUnset(request.vpcTargetHostName)) {
      query["VpcTargetHostName"] = request.vpcTargetHostName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyVpcAccessAndUpdateApis",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyVpcAccessAndUpdateApisResponse>(await this.callApi(params, req, runtime), new ModifyVpcAccessAndUpdateApisResponse({}));
  }

  /**
   * Modifies a virtual private cloud (VPC) authorization and updates the metadata of the API associated with the VPC authorization.
   * 
   * @param request - ModifyVpcAccessAndUpdateApisRequest
   * @returns ModifyVpcAccessAndUpdateApisResponse
   */
  async modifyVpcAccessAndUpdateApis(request: ModifyVpcAccessAndUpdateApisRequest): Promise<ModifyVpcAccessAndUpdateApisResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyVpcAccessAndUpdateApisWithOptions(request, runtime);
  }

  /**
   * @param request - OpenApiGatewayServiceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns OpenApiGatewayServiceResponse
   */
  async openApiGatewayServiceWithOptions(runtime: $Util.RuntimeOptions): Promise<OpenApiGatewayServiceResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "OpenApiGatewayService",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<OpenApiGatewayServiceResponse>(await this.callApi(params, req, runtime), new OpenApiGatewayServiceResponse({}));
  }

  /**
   * @returns OpenApiGatewayServiceResponse
   */
  async openApiGatewayService(): Promise<OpenApiGatewayServiceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.openApiGatewayServiceWithOptions(runtime);
  }

  /**
   * Queries the request logs of a user.
   * 
   * @param request - QueryRequestLogsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns QueryRequestLogsResponse
   */
  async queryRequestLogsWithOptions(request: QueryRequestLogsRequest, runtime: $Util.RuntimeOptions): Promise<QueryRequestLogsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.requestLogId)) {
      query["RequestLogId"] = request.requestLogId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryRequestLogs",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryRequestLogsResponse>(await this.callApi(params, req, runtime), new QueryRequestLogsResponse({}));
  }

  /**
   * Queries the request logs of a user.
   * 
   * @param request - QueryRequestLogsRequest
   * @returns QueryRequestLogsResponse
   */
  async queryRequestLogs(request: QueryRequestLogsRequest): Promise<QueryRequestLogsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryRequestLogsWithOptions(request, runtime);
  }

  /**
   * Reactivates a custom domain name whose validity status is Abnormal.
   * 
   * @remarks
   *   This operation is intended for API providers.
   * *   You must solve the problem that is mentioned in the domain name exception prompt before you can reactivate the domain name.
   * *   A typical reason why a custom domain name becomes abnormal is that the domain name does not have an ICP filing or the domain name is included in a blacklist by the administration. When a custom domain name is abnormal, users cannot use it to call APIs.
   * *   You can call this operation to reactivate the domain name to resume normal access.
   * 
   * @param request - ReactivateDomainRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ReactivateDomainResponse
   */
  async reactivateDomainWithOptions(request: ReactivateDomainRequest, runtime: $Util.RuntimeOptions): Promise<ReactivateDomainResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ReactivateDomain",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ReactivateDomainResponse>(await this.callApi(params, req, runtime), new ReactivateDomainResponse({}));
  }

  /**
   * Reactivates a custom domain name whose validity status is Abnormal.
   * 
   * @remarks
   *   This operation is intended for API providers.
   * *   You must solve the problem that is mentioned in the domain name exception prompt before you can reactivate the domain name.
   * *   A typical reason why a custom domain name becomes abnormal is that the domain name does not have an ICP filing or the domain name is included in a blacklist by the administration. When a custom domain name is abnormal, users cannot use it to call APIs.
   * *   You can call this operation to reactivate the domain name to resume normal access.
   * 
   * @param request - ReactivateDomainRequest
   * @returns ReactivateDomainResponse
   */
  async reactivateDomain(request: ReactivateDomainRequest): Promise<ReactivateDomainResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.reactivateDomainWithOptions(request, runtime);
  }

  /**
   * 删除访问控制策略中IP条目
   * 
   * @param request - RemoveAccessControlListEntryRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RemoveAccessControlListEntryResponse
   */
  async removeAccessControlListEntryWithOptions(request: RemoveAccessControlListEntryRequest, runtime: $Util.RuntimeOptions): Promise<RemoveAccessControlListEntryResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.aclEntrys)) {
      query["AclEntrys"] = request.aclEntrys;
    }

    if (!Util.isUnset(request.aclId)) {
      query["AclId"] = request.aclId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RemoveAccessControlListEntry",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RemoveAccessControlListEntryResponse>(await this.callApi(params, req, runtime), new RemoveAccessControlListEntryResponse({}));
  }

  /**
   * 删除访问控制策略中IP条目
   * 
   * @param request - RemoveAccessControlListEntryRequest
   * @returns RemoveAccessControlListEntryResponse
   */
  async removeAccessControlListEntry(request: RemoveAccessControlListEntryRequest): Promise<RemoveAccessControlListEntryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.removeAccessControlListEntryWithOptions(request, runtime);
  }

  /**
   * Revokes permissions on API products from an application.
   * 
   * @param tmpReq - RemoveApiProductsAuthoritiesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RemoveApiProductsAuthoritiesResponse
   */
  async removeApiProductsAuthoritiesWithOptions(tmpReq: RemoveApiProductsAuthoritiesRequest, runtime: $Util.RuntimeOptions): Promise<RemoveApiProductsAuthoritiesResponse> {
    Util.validateModel(tmpReq);
    let request = new RemoveApiProductsAuthoritiesShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.apiProductIds)) {
      request.apiProductIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.apiProductIds, "ApiProductIds", "simple");
    }

    let query = { };
    if (!Util.isUnset(request.apiProductIdsShrink)) {
      query["ApiProductIds"] = request.apiProductIdsShrink;
    }

    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RemoveApiProductsAuthorities",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RemoveApiProductsAuthoritiesResponse>(await this.callApi(params, req, runtime), new RemoveApiProductsAuthoritiesResponse({}));
  }

  /**
   * Revokes permissions on API products from an application.
   * 
   * @param request - RemoveApiProductsAuthoritiesRequest
   * @returns RemoveApiProductsAuthoritiesResponse
   */
  async removeApiProductsAuthorities(request: RemoveApiProductsAuthoritiesRequest): Promise<RemoveApiProductsAuthoritiesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.removeApiProductsAuthoritiesWithOptions(request, runtime);
  }

  /**
   * Revokes the access permissions on multiple APIs from a specified application.
   * 
   * @remarks
   *   This operation is intended for API providers and callers.
   * *   Before you revoke access permissions, check by whom the permissions were granted. API providers can only revoke permissions granted by a Provider, and API callers can only revoke permissions granted by a Consumer.
   * 
   * @param request - RemoveApisAuthoritiesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RemoveApisAuthoritiesResponse
   */
  async removeApisAuthoritiesWithOptions(request: RemoveApisAuthoritiesRequest, runtime: $Util.RuntimeOptions): Promise<RemoveApisAuthoritiesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.apiIds)) {
      query["ApiIds"] = request.apiIds;
    }

    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.stageName)) {
      query["StageName"] = request.stageName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RemoveApisAuthorities",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RemoveApisAuthoritiesResponse>(await this.callApi(params, req, runtime), new RemoveApisAuthoritiesResponse({}));
  }

  /**
   * Revokes the access permissions on multiple APIs from a specified application.
   * 
   * @remarks
   *   This operation is intended for API providers and callers.
   * *   Before you revoke access permissions, check by whom the permissions were granted. API providers can only revoke permissions granted by a Provider, and API callers can only revoke permissions granted by a Consumer.
   * 
   * @param request - RemoveApisAuthoritiesRequest
   * @returns RemoveApisAuthoritiesResponse
   */
  async removeApisAuthorities(request: RemoveApisAuthoritiesRequest): Promise<RemoveApisAuthoritiesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.removeApisAuthoritiesWithOptions(request, runtime);
  }

  /**
   * Revokes the access permissions on a specified API from multiple applications. In this case, multiple applications map to a single API.
   * 
   * @remarks
   *   This operation is intended for API providers and callers.
   * *   Before you revoke access permissions, check by whom the permissions were granted. API providers can only revoke permissions granted by a Provider, and API callers can only revoke permissions granted by a Consumer.
   * 
   * @param request - RemoveAppsAuthoritiesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RemoveAppsAuthoritiesResponse
   */
  async removeAppsAuthoritiesWithOptions(request: RemoveAppsAuthoritiesRequest, runtime: $Util.RuntimeOptions): Promise<RemoveAppsAuthoritiesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.apiId)) {
      query["ApiId"] = request.apiId;
    }

    if (!Util.isUnset(request.appIds)) {
      query["AppIds"] = request.appIds;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.stageName)) {
      query["StageName"] = request.stageName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RemoveAppsAuthorities",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RemoveAppsAuthoritiesResponse>(await this.callApi(params, req, runtime), new RemoveAppsAuthoritiesResponse({}));
  }

  /**
   * Revokes the access permissions on a specified API from multiple applications. In this case, multiple applications map to a single API.
   * 
   * @remarks
   *   This operation is intended for API providers and callers.
   * *   Before you revoke access permissions, check by whom the permissions were granted. API providers can only revoke permissions granted by a Provider, and API callers can only revoke permissions granted by a Consumer.
   * 
   * @param request - RemoveAppsAuthoritiesRequest
   * @returns RemoveAppsAuthoritiesResponse
   */
  async removeAppsAuthorities(request: RemoveAppsAuthoritiesRequest): Promise<RemoveAppsAuthoritiesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.removeAppsAuthoritiesWithOptions(request, runtime);
  }

  /**
   * Unbinds an API from an access control list (ACL).
   * 
   * @remarks
   *   This operation is intended for API callers.
   * *   The unbinding takes effect immediately. After the API is unbound from the ACL, the corresponding environment does not have any IP address access control in place for the API.
   * 
   * @param request - RemoveIpControlApisRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RemoveIpControlApisResponse
   */
  async removeIpControlApisWithOptions(request: RemoveIpControlApisRequest, runtime: $Util.RuntimeOptions): Promise<RemoveIpControlApisResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.apiIds)) {
      query["ApiIds"] = request.apiIds;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.ipControlId)) {
      query["IpControlId"] = request.ipControlId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.stageName)) {
      query["StageName"] = request.stageName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RemoveIpControlApis",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RemoveIpControlApisResponse>(await this.callApi(params, req, runtime), new RemoveIpControlApisResponse({}));
  }

  /**
   * Unbinds an API from an access control list (ACL).
   * 
   * @remarks
   *   This operation is intended for API callers.
   * *   The unbinding takes effect immediately. After the API is unbound from the ACL, the corresponding environment does not have any IP address access control in place for the API.
   * 
   * @param request - RemoveIpControlApisRequest
   * @returns RemoveIpControlApisResponse
   */
  async removeIpControlApis(request: RemoveIpControlApisRequest): Promise<RemoveIpControlApisResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.removeIpControlApisWithOptions(request, runtime);
  }

  /**
   * Removes one or more policies from an access control list (ACL).
   * 
   * @remarks
   *   This operation is intended for API providers.
   * 
   * @param request - RemoveIpControlPolicyItemRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RemoveIpControlPolicyItemResponse
   */
  async removeIpControlPolicyItemWithOptions(request: RemoveIpControlPolicyItemRequest, runtime: $Util.RuntimeOptions): Promise<RemoveIpControlPolicyItemResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ipControlId)) {
      query["IpControlId"] = request.ipControlId;
    }

    if (!Util.isUnset(request.policyItemIds)) {
      query["PolicyItemIds"] = request.policyItemIds;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RemoveIpControlPolicyItem",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RemoveIpControlPolicyItemResponse>(await this.callApi(params, req, runtime), new RemoveIpControlPolicyItemResponse({}));
  }

  /**
   * Removes one or more policies from an access control list (ACL).
   * 
   * @remarks
   *   This operation is intended for API providers.
   * 
   * @param request - RemoveIpControlPolicyItemRequest
   * @returns RemoveIpControlPolicyItemResponse
   */
  async removeIpControlPolicyItem(request: RemoveIpControlPolicyItemRequest): Promise<RemoveIpControlPolicyItemResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.removeIpControlPolicyItemWithOptions(request, runtime);
  }

  /**
   * Unbinds a backend signature key from APIs.
   * 
   * @remarks
   *   This API is intended for API providers.
   * *   The operation takes effect immediately. The request sent from API Gateway to the backend service does not contain the signature string. The corresponding verification step can be removed from the backend.
   * 
   * @param request - RemoveSignatureApisRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RemoveSignatureApisResponse
   */
  async removeSignatureApisWithOptions(request: RemoveSignatureApisRequest, runtime: $Util.RuntimeOptions): Promise<RemoveSignatureApisResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.apiIds)) {
      query["ApiIds"] = request.apiIds;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.signatureId)) {
      query["SignatureId"] = request.signatureId;
    }

    if (!Util.isUnset(request.stageName)) {
      query["StageName"] = request.stageName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RemoveSignatureApis",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RemoveSignatureApisResponse>(await this.callApi(params, req, runtime), new RemoveSignatureApisResponse({}));
  }

  /**
   * Unbinds a backend signature key from APIs.
   * 
   * @remarks
   *   This API is intended for API providers.
   * *   The operation takes effect immediately. The request sent from API Gateway to the backend service does not contain the signature string. The corresponding verification step can be removed from the backend.
   * 
   * @param request - RemoveSignatureApisRequest
   * @returns RemoveSignatureApisResponse
   */
  async removeSignatureApis(request: RemoveSignatureApisRequest): Promise<RemoveSignatureApisResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.removeSignatureApisWithOptions(request, runtime);
  }

  /**
   * Unbinds a specified throttling policy from APIs.
   * 
   * @remarks
   *   This API is intended for API providers.
   * *   This API allows you to unbind a specified throttling policy from up to 100 APIs at a time.
   * 
   * @param request - RemoveTrafficControlApisRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RemoveTrafficControlApisResponse
   */
  async removeTrafficControlApisWithOptions(request: RemoveTrafficControlApisRequest, runtime: $Util.RuntimeOptions): Promise<RemoveTrafficControlApisResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.apiIds)) {
      query["ApiIds"] = request.apiIds;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.stageName)) {
      query["StageName"] = request.stageName;
    }

    if (!Util.isUnset(request.trafficControlId)) {
      query["TrafficControlId"] = request.trafficControlId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RemoveTrafficControlApis",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RemoveTrafficControlApisResponse>(await this.callApi(params, req, runtime), new RemoveTrafficControlApisResponse({}));
  }

  /**
   * Unbinds a specified throttling policy from APIs.
   * 
   * @remarks
   *   This API is intended for API providers.
   * *   This API allows you to unbind a specified throttling policy from up to 100 APIs at a time.
   * 
   * @param request - RemoveTrafficControlApisRequest
   * @returns RemoveTrafficControlApisResponse
   */
  async removeTrafficControlApis(request: RemoveTrafficControlApisRequest): Promise<RemoveTrafficControlApisResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.removeTrafficControlApisWithOptions(request, runtime);
  }

  /**
   * Deletes a VPC authorization without unpublishing the associated APIs.
   * 
   * @remarks
   *   This API is intended for API providers.
   * *   Revokes the permissions of API Gateway to access your VPC instance.
   * >  Deleting an authorization affects the associated API. Before you delete the authorization, make sure that it is not used by the API.
   * 
   * @param request - RemoveVpcAccessRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RemoveVpcAccessResponse
   */
  async removeVpcAccessWithOptions(request: RemoveVpcAccessRequest, runtime: $Util.RuntimeOptions): Promise<RemoveVpcAccessResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.needBatchWork)) {
      query["NeedBatchWork"] = request.needBatchWork;
    }

    if (!Util.isUnset(request.port)) {
      query["Port"] = request.port;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.vpcId)) {
      query["VpcId"] = request.vpcId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RemoveVpcAccess",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RemoveVpcAccessResponse>(await this.callApi(params, req, runtime), new RemoveVpcAccessResponse({}));
  }

  /**
   * Deletes a VPC authorization without unpublishing the associated APIs.
   * 
   * @remarks
   *   This API is intended for API providers.
   * *   Revokes the permissions of API Gateway to access your VPC instance.
   * >  Deleting an authorization affects the associated API. Before you delete the authorization, make sure that it is not used by the API.
   * 
   * @param request - RemoveVpcAccessRequest
   * @returns RemoveVpcAccessResponse
   */
  async removeVpcAccess(request: RemoveVpcAccessRequest): Promise<RemoveVpcAccessResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.removeVpcAccessWithOptions(request, runtime);
  }

  /**
   * @param request - RemoveVpcAccessAndAbolishApisRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RemoveVpcAccessAndAbolishApisResponse
   */
  async removeVpcAccessAndAbolishApisWithOptions(request: RemoveVpcAccessAndAbolishApisRequest, runtime: $Util.RuntimeOptions): Promise<RemoveVpcAccessAndAbolishApisResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.needBatchWork)) {
      query["NeedBatchWork"] = request.needBatchWork;
    }

    if (!Util.isUnset(request.port)) {
      query["Port"] = request.port;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.vpcId)) {
      query["VpcId"] = request.vpcId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RemoveVpcAccessAndAbolishApis",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RemoveVpcAccessAndAbolishApisResponse>(await this.callApi(params, req, runtime), new RemoveVpcAccessAndAbolishApisResponse({}));
  }

  /**
   * @param request - RemoveVpcAccessAndAbolishApisRequest
   * @returns RemoveVpcAccessAndAbolishApisResponse
   */
  async removeVpcAccessAndAbolishApis(request: RemoveVpcAccessAndAbolishApisRequest): Promise<RemoveVpcAccessAndAbolishApisResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.removeVpcAccessAndAbolishApisWithOptions(request, runtime);
  }

  /**
   * Resets the AppCode of an application. You can call this operation only once per minute.
   * 
   * @param request - ResetAppCodeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ResetAppCodeResponse
   */
  async resetAppCodeWithOptions(request: ResetAppCodeRequest, runtime: $Util.RuntimeOptions): Promise<ResetAppCodeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appCode)) {
      query["AppCode"] = request.appCode;
    }

    if (!Util.isUnset(request.newAppCode)) {
      query["NewAppCode"] = request.newAppCode;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ResetAppCode",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ResetAppCodeResponse>(await this.callApi(params, req, runtime), new ResetAppCodeResponse({}));
  }

  /**
   * Resets the AppCode of an application. You can call this operation only once per minute.
   * 
   * @param request - ResetAppCodeRequest
   * @returns ResetAppCodeResponse
   */
  async resetAppCode(request: ResetAppCodeRequest): Promise<ResetAppCodeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.resetAppCodeWithOptions(request, runtime);
  }

  /**
   * Resets the key of an application.
   * 
   * @remarks
   *   This operation is intended for API callers.
   * *   A new secret is automatically generated after you have called this operation. This secret cannot be customized.
   * *   The results returned by this operation do not contain the application secret. You can obtain the secret by calling DescribeAppSecurity.
   * 
   * @param request - ResetAppSecretRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ResetAppSecretResponse
   */
  async resetAppSecretWithOptions(request: ResetAppSecretRequest, runtime: $Util.RuntimeOptions): Promise<ResetAppSecretResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appKey)) {
      query["AppKey"] = request.appKey;
    }

    if (!Util.isUnset(request.newAppKey)) {
      query["NewAppKey"] = request.newAppKey;
    }

    if (!Util.isUnset(request.newAppSecret)) {
      query["NewAppSecret"] = request.newAppSecret;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ResetAppSecret",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ResetAppSecretResponse>(await this.callApi(params, req, runtime), new ResetAppSecretResponse({}));
  }

  /**
   * Resets the key of an application.
   * 
   * @remarks
   *   This operation is intended for API callers.
   * *   A new secret is automatically generated after you have called this operation. This secret cannot be customized.
   * *   The results returned by this operation do not contain the application secret. You can obtain the secret by calling DescribeAppSecurity.
   * 
   * @param request - ResetAppSecretRequest
   * @returns ResetAppSecretResponse
   */
  async resetAppSecret(request: ResetAppSecretRequest): Promise<ResetAppSecretResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.resetAppSecretWithOptions(request, runtime);
  }

  /**
   * @param request - SdkGenerateByAppRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SdkGenerateByAppResponse
   */
  async sdkGenerateByAppWithOptions(request: SdkGenerateByAppRequest, runtime: $Util.RuntimeOptions): Promise<SdkGenerateByAppResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.language)) {
      query["Language"] = request.language;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SdkGenerateByApp",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SdkGenerateByAppResponse>(await this.callApi(params, req, runtime), new SdkGenerateByAppResponse({}));
  }

  /**
   * @param request - SdkGenerateByAppRequest
   * @returns SdkGenerateByAppResponse
   */
  async sdkGenerateByApp(request: SdkGenerateByAppRequest): Promise<SdkGenerateByAppResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.sdkGenerateByAppWithOptions(request, runtime);
  }

  /**
   * 生成与App关联的API的SDK
   * 
   * @param request - SdkGenerateByAppForRegionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SdkGenerateByAppForRegionResponse
   */
  async sdkGenerateByAppForRegionWithOptions(request: SdkGenerateByAppForRegionRequest, runtime: $Util.RuntimeOptions): Promise<SdkGenerateByAppForRegionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.language)) {
      query["Language"] = request.language;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SdkGenerateByAppForRegion",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SdkGenerateByAppForRegionResponse>(await this.callApi(params, req, runtime), new SdkGenerateByAppForRegionResponse({}));
  }

  /**
   * 生成与App关联的API的SDK
   * 
   * @param request - SdkGenerateByAppForRegionRequest
   * @returns SdkGenerateByAppForRegionResponse
   */
  async sdkGenerateByAppForRegion(request: SdkGenerateByAppForRegionRequest): Promise<SdkGenerateByAppForRegionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.sdkGenerateByAppForRegionWithOptions(request, runtime);
  }

  /**
   * @param request - SdkGenerateByGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SdkGenerateByGroupResponse
   */
  async sdkGenerateByGroupWithOptions(request: SdkGenerateByGroupRequest, runtime: $Util.RuntimeOptions): Promise<SdkGenerateByGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.language)) {
      query["Language"] = request.language;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SdkGenerateByGroup",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SdkGenerateByGroupResponse>(await this.callApi(params, req, runtime), new SdkGenerateByGroupResponse({}));
  }

  /**
   * @param request - SdkGenerateByGroupRequest
   * @returns SdkGenerateByGroupResponse
   */
  async sdkGenerateByGroup(request: SdkGenerateByGroupRequest): Promise<SdkGenerateByGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.sdkGenerateByGroupWithOptions(request, runtime);
  }

  /**
   * 修改访问控制策略的名称
   * 
   * @param request - SetAccessControlListAttributeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SetAccessControlListAttributeResponse
   */
  async setAccessControlListAttributeWithOptions(request: SetAccessControlListAttributeRequest, runtime: $Util.RuntimeOptions): Promise<SetAccessControlListAttributeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.aclId)) {
      query["AclId"] = request.aclId;
    }

    if (!Util.isUnset(request.aclName)) {
      query["AclName"] = request.aclName;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetAccessControlListAttribute",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetAccessControlListAttributeResponse>(await this.callApi(params, req, runtime), new SetAccessControlListAttributeResponse({}));
  }

  /**
   * 修改访问控制策略的名称
   * 
   * @param request - SetAccessControlListAttributeRequest
   * @returns SetAccessControlListAttributeResponse
   */
  async setAccessControlListAttribute(request: SetAccessControlListAttributeRequest): Promise<SetAccessControlListAttributeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setAccessControlListAttributeWithOptions(request, runtime);
  }

  /**
   * 给多个API产品添加APP授权
   * 
   * @param tmpReq - SetApiProductsAuthoritiesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SetApiProductsAuthoritiesResponse
   */
  async setApiProductsAuthoritiesWithOptions(tmpReq: SetApiProductsAuthoritiesRequest, runtime: $Util.RuntimeOptions): Promise<SetApiProductsAuthoritiesResponse> {
    Util.validateModel(tmpReq);
    let request = new SetApiProductsAuthoritiesShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.apiProductIds)) {
      request.apiProductIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.apiProductIds, "ApiProductIds", "simple");
    }

    let query = { };
    if (!Util.isUnset(request.apiProductIdsShrink)) {
      query["ApiProductIds"] = request.apiProductIdsShrink;
    }

    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.authValidTime)) {
      query["AuthValidTime"] = request.authValidTime;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetApiProductsAuthorities",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetApiProductsAuthoritiesResponse>(await this.callApi(params, req, runtime), new SetApiProductsAuthoritiesResponse({}));
  }

  /**
   * 给多个API产品添加APP授权
   * 
   * @param request - SetApiProductsAuthoritiesRequest
   * @returns SetApiProductsAuthoritiesResponse
   */
  async setApiProductsAuthorities(request: SetApiProductsAuthoritiesRequest): Promise<SetApiProductsAuthoritiesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setApiProductsAuthoritiesWithOptions(request, runtime);
  }

  /**
   * Authorizes a specified application to call multiple APIs.
   * 
   * @remarks
   *   This operation is intended for API providers and callers.
   * *   API providers can authorize all applications to call their APIs.
   * *   API callers can authorize their own applications to call the APIs that they have purchased.
   * 
   * @param request - SetApisAuthoritiesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SetApisAuthoritiesResponse
   */
  async setApisAuthoritiesWithOptions(request: SetApisAuthoritiesRequest, runtime: $Util.RuntimeOptions): Promise<SetApisAuthoritiesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.apiIds)) {
      query["ApiIds"] = request.apiIds;
    }

    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.authValidTime)) {
      query["AuthValidTime"] = request.authValidTime;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.stageName)) {
      query["StageName"] = request.stageName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetApisAuthorities",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetApisAuthoritiesResponse>(await this.callApi(params, req, runtime), new SetApisAuthoritiesResponse({}));
  }

  /**
   * Authorizes a specified application to call multiple APIs.
   * 
   * @remarks
   *   This operation is intended for API providers and callers.
   * *   API providers can authorize all applications to call their APIs.
   * *   API callers can authorize their own applications to call the APIs that they have purchased.
   * 
   * @param request - SetApisAuthoritiesRequest
   * @returns SetApisAuthoritiesResponse
   */
  async setApisAuthorities(request: SetApisAuthoritiesRequest): Promise<SetApisAuthoritiesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setApisAuthoritiesWithOptions(request, runtime);
  }

  /**
   * 将多个APP授权给API产品
   * 
   * @param request - SetAppsAuthToApiProductRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SetAppsAuthToApiProductResponse
   */
  async setAppsAuthToApiProductWithOptions(request: SetAppsAuthToApiProductRequest, runtime: $Util.RuntimeOptions): Promise<SetAppsAuthToApiProductResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.apiProductId)) {
      query["ApiProductId"] = request.apiProductId;
    }

    if (!Util.isUnset(request.appIds)) {
      query["AppIds"] = request.appIds;
    }

    if (!Util.isUnset(request.authValidTime)) {
      query["AuthValidTime"] = request.authValidTime;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetAppsAuthToApiProduct",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetAppsAuthToApiProductResponse>(await this.callApi(params, req, runtime), new SetAppsAuthToApiProductResponse({}));
  }

  /**
   * 将多个APP授权给API产品
   * 
   * @param request - SetAppsAuthToApiProductRequest
   * @returns SetAppsAuthToApiProductResponse
   */
  async setAppsAuthToApiProduct(request: SetAppsAuthToApiProductRequest): Promise<SetAppsAuthToApiProductResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setAppsAuthToApiProductWithOptions(request, runtime);
  }

  /**
   * Grants access permissions on a specified API to multiple applications.
   * 
   * @remarks
   *   This operation is intended for API providers and callers.
   * *   API providers can authorize all applications to call their APIs.
   * *   API callers can authorize their own applications to call the APIs that they have purchased.
   * 
   * @param request - SetAppsAuthoritiesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SetAppsAuthoritiesResponse
   */
  async setAppsAuthoritiesWithOptions(request: SetAppsAuthoritiesRequest, runtime: $Util.RuntimeOptions): Promise<SetAppsAuthoritiesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.apiId)) {
      query["ApiId"] = request.apiId;
    }

    if (!Util.isUnset(request.appIds)) {
      query["AppIds"] = request.appIds;
    }

    if (!Util.isUnset(request.authValidTime)) {
      query["AuthValidTime"] = request.authValidTime;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.stageName)) {
      query["StageName"] = request.stageName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetAppsAuthorities",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetAppsAuthoritiesResponse>(await this.callApi(params, req, runtime), new SetAppsAuthoritiesResponse({}));
  }

  /**
   * Grants access permissions on a specified API to multiple applications.
   * 
   * @remarks
   *   This operation is intended for API providers and callers.
   * *   API providers can authorize all applications to call their APIs.
   * *   API callers can authorize their own applications to call the APIs that they have purchased.
   * 
   * @param request - SetAppsAuthoritiesRequest
   * @returns SetAppsAuthoritiesResponse
   */
  async setAppsAuthorities(request: SetAppsAuthoritiesRequest): Promise<SetAppsAuthoritiesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setAppsAuthoritiesWithOptions(request, runtime);
  }

  /**
   * Binds a custom domain name to a specified API group.
   * 
   * @param request - SetDomainRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SetDomainResponse
   */
  async setDomainWithOptions(request: SetDomainRequest, runtime: $Util.RuntimeOptions): Promise<SetDomainResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.bindStageName)) {
      query["BindStageName"] = request.bindStageName;
    }

    if (!Util.isUnset(request.customDomainType)) {
      query["CustomDomainType"] = request.customDomainType;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.isForce)) {
      query["IsForce"] = request.isForce;
    }

    if (!Util.isUnset(request.isHttpRedirectToHttps)) {
      query["IsHttpRedirectToHttps"] = request.isHttpRedirectToHttps;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetDomain",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetDomainResponse>(await this.callApi(params, req, runtime), new SetDomainResponse({}));
  }

  /**
   * Binds a custom domain name to a specified API group.
   * 
   * @param request - SetDomainRequest
   * @returns SetDomainResponse
   */
  async setDomain(request: SetDomainRequest): Promise<SetDomainResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setDomainWithOptions(request, runtime);
  }

  /**
   * Uploads an SSL certificate for a specified custom domain name.
   * 
   * @remarks
   *   This operation is intended for API providers.
   * *   The SSL certificate must match the custom domain name.
   * *   After the SSL certificate is bound, HTTPS-based API services become available.
   * 
   * @param request - SetDomainCertificateRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SetDomainCertificateResponse
   */
  async setDomainCertificateWithOptions(request: SetDomainCertificateRequest, runtime: $Util.RuntimeOptions): Promise<SetDomainCertificateResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.caCertificateBody)) {
      query["CaCertificateBody"] = request.caCertificateBody;
    }

    if (!Util.isUnset(request.certificateBody)) {
      query["CertificateBody"] = request.certificateBody;
    }

    if (!Util.isUnset(request.certificateName)) {
      query["CertificateName"] = request.certificateName;
    }

    if (!Util.isUnset(request.certificatePrivateKey)) {
      query["CertificatePrivateKey"] = request.certificatePrivateKey;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.sslVerifyDepth)) {
      query["SslVerifyDepth"] = request.sslVerifyDepth;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetDomainCertificate",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetDomainCertificateResponse>(await this.callApi(params, req, runtime), new SetDomainCertificateResponse({}));
  }

  /**
   * Uploads an SSL certificate for a specified custom domain name.
   * 
   * @remarks
   *   This operation is intended for API providers.
   * *   The SSL certificate must match the custom domain name.
   * *   After the SSL certificate is bound, HTTPS-based API services become available.
   * 
   * @param request - SetDomainCertificateRequest
   * @returns SetDomainCertificateResponse
   */
  async setDomainCertificate(request: SetDomainCertificateRequest): Promise<SetDomainCertificateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setDomainCertificateWithOptions(request, runtime);
  }

  /**
   * Enables or disables WebSocket for a custom domain name.
   * 
   * @param request - SetDomainWebSocketStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SetDomainWebSocketStatusResponse
   */
  async setDomainWebSocketStatusWithOptions(request: SetDomainWebSocketStatusRequest, runtime: $Util.RuntimeOptions): Promise<SetDomainWebSocketStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.actionValue)) {
      query["ActionValue"] = request.actionValue;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.WSSEnable)) {
      query["WSSEnable"] = request.WSSEnable;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetDomainWebSocketStatus",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetDomainWebSocketStatusResponse>(await this.callApi(params, req, runtime), new SetDomainWebSocketStatusResponse({}));
  }

  /**
   * Enables or disables WebSocket for a custom domain name.
   * 
   * @param request - SetDomainWebSocketStatusRequest
   * @returns SetDomainWebSocketStatusResponse
   */
  async setDomainWebSocketStatus(request: SetDomainWebSocketStatusRequest): Promise<SetDomainWebSocketStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setDomainWebSocketStatusWithOptions(request, runtime);
  }

  /**
   * @param request - SetGroupAuthAppCodeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SetGroupAuthAppCodeResponse
   */
  async setGroupAuthAppCodeWithOptions(request: SetGroupAuthAppCodeRequest, runtime: $Util.RuntimeOptions): Promise<SetGroupAuthAppCodeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.authAppCode)) {
      query["AuthAppCode"] = request.authAppCode;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetGroupAuthAppCode",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetGroupAuthAppCodeResponse>(await this.callApi(params, req, runtime), new SetGroupAuthAppCodeResponse({}));
  }

  /**
   * @param request - SetGroupAuthAppCodeRequest
   * @returns SetGroupAuthAppCodeResponse
   */
  async setGroupAuthAppCode(request: SetGroupAuthAppCodeRequest): Promise<SetGroupAuthAppCodeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setGroupAuthAppCodeWithOptions(request, runtime);
  }

  /**
   * Creates a binding relationship between specified access control lists (ACLs) and APIs.
   * 
   * @remarks
   *   This operation is intended for API callers.
   * *   A maximum of 100 APIs can be bound at a time.
   * 
   * @param request - SetIpControlApisRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SetIpControlApisResponse
   */
  async setIpControlApisWithOptions(request: SetIpControlApisRequest, runtime: $Util.RuntimeOptions): Promise<SetIpControlApisResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.apiIds)) {
      query["ApiIds"] = request.apiIds;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.ipControlId)) {
      query["IpControlId"] = request.ipControlId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.stageName)) {
      query["StageName"] = request.stageName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetIpControlApis",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetIpControlApisResponse>(await this.callApi(params, req, runtime), new SetIpControlApisResponse({}));
  }

  /**
   * Creates a binding relationship between specified access control lists (ACLs) and APIs.
   * 
   * @remarks
   *   This operation is intended for API callers.
   * *   A maximum of 100 APIs can be bound at a time.
   * 
   * @param request - SetIpControlApisRequest
   * @returns SetIpControlApisResponse
   */
  async setIpControlApis(request: SetIpControlApisRequest): Promise<SetIpControlApisResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setIpControlApisWithOptions(request, runtime);
  }

  /**
   * Binds a signature key to APIs.
   * 
   * @param request - SetSignatureApisRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SetSignatureApisResponse
   */
  async setSignatureApisWithOptions(request: SetSignatureApisRequest, runtime: $Util.RuntimeOptions): Promise<SetSignatureApisResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.apiIds)) {
      query["ApiIds"] = request.apiIds;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.signatureId)) {
      query["SignatureId"] = request.signatureId;
    }

    if (!Util.isUnset(request.stageName)) {
      query["StageName"] = request.stageName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetSignatureApis",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetSignatureApisResponse>(await this.callApi(params, req, runtime), new SetSignatureApisResponse({}));
  }

  /**
   * Binds a signature key to APIs.
   * 
   * @param request - SetSignatureApisRequest
   * @returns SetSignatureApisResponse
   */
  async setSignatureApis(request: SetSignatureApisRequest): Promise<SetSignatureApisResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setSignatureApisWithOptions(request, runtime);
  }

  /**
   * Binds a throttling policy to APIs.
   * 
   * @remarks
   *   This API is intended for API providers.
   * *   This API allows you to bind a specific throttling policy to up to 100 APIs at a time.
   * 
   * @param request - SetTrafficControlApisRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SetTrafficControlApisResponse
   */
  async setTrafficControlApisWithOptions(request: SetTrafficControlApisRequest, runtime: $Util.RuntimeOptions): Promise<SetTrafficControlApisResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.apiIds)) {
      query["ApiIds"] = request.apiIds;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.stageName)) {
      query["StageName"] = request.stageName;
    }

    if (!Util.isUnset(request.trafficControlId)) {
      query["TrafficControlId"] = request.trafficControlId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetTrafficControlApis",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetTrafficControlApisResponse>(await this.callApi(params, req, runtime), new SetTrafficControlApisResponse({}));
  }

  /**
   * Binds a throttling policy to APIs.
   * 
   * @remarks
   *   This API is intended for API providers.
   * *   This API allows you to bind a specific throttling policy to up to 100 APIs at a time.
   * 
   * @param request - SetTrafficControlApisRequest
   * @returns SetTrafficControlApisResponse
   */
  async setTrafficControlApis(request: SetTrafficControlApisRequest): Promise<SetTrafficControlApisResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setTrafficControlApisWithOptions(request, runtime);
  }

  /**
   * Creates a virtual private cloud (VPC) access authorization and enables reverse access.
   * 
   * @remarks
   * This operation is intended for API providers.
   * * This operation is used to authorize API Gateway to access your VPC instance.
   * 
   * @param request - SetVpcAccessRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SetVpcAccessResponse
   */
  async setVpcAccessWithOptions(request: SetVpcAccessRequest, runtime: $Util.RuntimeOptions): Promise<SetVpcAccessResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.port)) {
      query["Port"] = request.port;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!Util.isUnset(request.vpcId)) {
      query["VpcId"] = request.vpcId;
    }

    if (!Util.isUnset(request.vpcTargetHostName)) {
      query["VpcTargetHostName"] = request.vpcTargetHostName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetVpcAccess",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetVpcAccessResponse>(await this.callApi(params, req, runtime), new SetVpcAccessResponse({}));
  }

  /**
   * Creates a virtual private cloud (VPC) access authorization and enables reverse access.
   * 
   * @remarks
   * This operation is intended for API providers.
   * * This operation is used to authorize API Gateway to access your VPC instance.
   * 
   * @param request - SetVpcAccessRequest
   * @returns SetVpcAccessResponse
   */
  async setVpcAccess(request: SetVpcAccessRequest): Promise<SetVpcAccessResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setVpcAccessWithOptions(request, runtime);
  }

  /**
   * Specifies a wildcard domain name template for a bound custom domain name.
   * 
   * @param request - SetWildcardDomainPatternsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SetWildcardDomainPatternsResponse
   */
  async setWildcardDomainPatternsWithOptions(request: SetWildcardDomainPatternsRequest, runtime: $Util.RuntimeOptions): Promise<SetWildcardDomainPatternsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.wildcardDomainPatterns)) {
      query["WildcardDomainPatterns"] = request.wildcardDomainPatterns;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetWildcardDomainPatterns",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetWildcardDomainPatternsResponse>(await this.callApi(params, req, runtime), new SetWildcardDomainPatternsResponse({}));
  }

  /**
   * Specifies a wildcard domain name template for a bound custom domain name.
   * 
   * @param request - SetWildcardDomainPatternsRequest
   * @returns SetWildcardDomainPatternsResponse
   */
  async setWildcardDomainPatterns(request: SetWildcardDomainPatternsRequest): Promise<SetWildcardDomainPatternsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setWildcardDomainPatternsWithOptions(request, runtime);
  }

  /**
   * Switches the definition of an API in a specified runtime environment to a historical version.
   * 
   * @param request - SwitchApiRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SwitchApiResponse
   */
  async switchApiWithOptions(request: SwitchApiRequest, runtime: $Util.RuntimeOptions): Promise<SwitchApiResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.apiId)) {
      query["ApiId"] = request.apiId;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.historyVersion)) {
      query["HistoryVersion"] = request.historyVersion;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.stageName)) {
      query["StageName"] = request.stageName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SwitchApi",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SwitchApiResponse>(await this.callApi(params, req, runtime), new SwitchApiResponse({}));
  }

  /**
   * Switches the definition of an API in a specified runtime environment to a historical version.
   * 
   * @param request - SwitchApiRequest
   * @returns SwitchApiResponse
   */
  async switchApi(request: SwitchApiRequest): Promise<SwitchApiResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.switchApiWithOptions(request, runtime);
  }

  /**
   * Creates a tag-resource relationship.
   * 
   * @remarks
   *   All tags (key-value pairs) are applied to all resources of a specified ResourceId, with each resource specified as ResourceId.N.
   * *   Tag.N is a resource tag consisting of a key-value pair: Tag.N.Key and Tag.N.Value.
   * *   If you call this operation to tag multiple resources simultaneously, either all or none of the resources will be tagged.
   * *   If you specify Tag.1.Value in addition to required parameters, you must also specify Tag.1.Key. Otherwise, an InvalidParameter.TagKey error is reported. A tag that has a value must have the corresponding key, but the key can be an empty string.
   * *   If a tag with the same key has been bound to a resource, the new tag will overwrite the existing one.
   * 
   * @param request - TagResourcesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns TagResourcesResponse
   */
  async tagResourcesWithOptions(request: TagResourcesRequest, runtime: $Util.RuntimeOptions): Promise<TagResourcesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!Util.isUnset(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "TagResources",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<TagResourcesResponse>(await this.callApi(params, req, runtime), new TagResourcesResponse({}));
  }

  /**
   * Creates a tag-resource relationship.
   * 
   * @remarks
   *   All tags (key-value pairs) are applied to all resources of a specified ResourceId, with each resource specified as ResourceId.N.
   * *   Tag.N is a resource tag consisting of a key-value pair: Tag.N.Key and Tag.N.Value.
   * *   If you call this operation to tag multiple resources simultaneously, either all or none of the resources will be tagged.
   * *   If you specify Tag.1.Value in addition to required parameters, you must also specify Tag.1.Key. Otherwise, an InvalidParameter.TagKey error is reported. A tag that has a value must have the corresponding key, but the key can be an empty string.
   * *   If a tag with the same key has been bound to a resource, the new tag will overwrite the existing one.
   * 
   * @param request - TagResourcesRequest
   * @returns TagResourcesResponse
   */
  async tagResources(request: TagResourcesRequest): Promise<TagResourcesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.tagResourcesWithOptions(request, runtime);
  }

  /**
   * Removes tags from resources.
   * 
   * @remarks
   *   If you call this operation to untag multiple resources simultaneously, either all or none of the resources will be untagged.
   * *   If you specify resource IDs without specifying tag keys and set the All parameter to true, all tags bound to the specified resources will be deleted. If a resource does not have any tags, the request is not processed but a success is returned.
   * *   If you specify resource IDs without specifying tag keys and set the All parameter to false, the request is not processed but a success is returned.
   * *   When tag keys are specified, the All parameter is invalid.
   * *   When multiple resources and key-value pairs are specified, the specified tags bound to the resources are deleted.
   * 
   * @param request - UntagResourcesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UntagResourcesResponse
   */
  async untagResourcesWithOptions(request: UntagResourcesRequest, runtime: $Util.RuntimeOptions): Promise<UntagResourcesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.all)) {
      query["All"] = request.all;
    }

    if (!Util.isUnset(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!Util.isUnset(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.tagKey)) {
      query["TagKey"] = request.tagKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UntagResources",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UntagResourcesResponse>(await this.callApi(params, req, runtime), new UntagResourcesResponse({}));
  }

  /**
   * Removes tags from resources.
   * 
   * @remarks
   *   If you call this operation to untag multiple resources simultaneously, either all or none of the resources will be untagged.
   * *   If you specify resource IDs without specifying tag keys and set the All parameter to true, all tags bound to the specified resources will be deleted. If a resource does not have any tags, the request is not processed but a success is returned.
   * *   If you specify resource IDs without specifying tag keys and set the All parameter to false, the request is not processed but a success is returned.
   * *   When tag keys are specified, the All parameter is invalid.
   * *   When multiple resources and key-value pairs are specified, the specified tags bound to the resources are deleted.
   * 
   * @param request - UntagResourcesRequest
   * @returns UntagResourcesResponse
   */
  async untagResources(request: UntagResourcesRequest): Promise<UntagResourcesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.untagResourcesWithOptions(request, runtime);
  }

  /**
   * 更新内网域名解析
   * 
   * @param tmpReq - UpdatePrivateDNSRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdatePrivateDNSResponse
   */
  async updatePrivateDNSWithOptions(tmpReq: UpdatePrivateDNSRequest, runtime: $Util.RuntimeOptions): Promise<UpdatePrivateDNSResponse> {
    Util.validateModel(tmpReq);
    let request = new UpdatePrivateDNSShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.records)) {
      request.recordsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.records, "Records", "json");
    }

    let query = { };
    if (!Util.isUnset(request.intranetDomain)) {
      query["IntranetDomain"] = request.intranetDomain;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.recordsShrink)) {
      body["Records"] = request.recordsShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdatePrivateDNS",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdatePrivateDNSResponse>(await this.callApi(params, req, runtime), new UpdatePrivateDNSResponse({}));
  }

  /**
   * 更新内网域名解析
   * 
   * @param request - UpdatePrivateDNSRequest
   * @returns UpdatePrivateDNSResponse
   */
  async updatePrivateDNS(request: UpdatePrivateDNSRequest): Promise<UpdatePrivateDNSResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updatePrivateDNSWithOptions(request, runtime);
  }

  /**
   * Tests the network connectivity between an API Gateway instance and a port on an Elastic Compute Service (ECS) or Server Load Balance (SLB) instance in a virtual private cloud (VPC) access authorization.
   * 
   * @param request - ValidateVpcConnectivityRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ValidateVpcConnectivityResponse
   */
  async validateVpcConnectivityWithOptions(request: ValidateVpcConnectivityRequest, runtime: $Util.RuntimeOptions): Promise<ValidateVpcConnectivityResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.vpcAccessId)) {
      query["VpcAccessId"] = request.vpcAccessId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ValidateVpcConnectivity",
      version: "2016-07-14",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ValidateVpcConnectivityResponse>(await this.callApi(params, req, runtime), new ValidateVpcConnectivityResponse({}));
  }

  /**
   * Tests the network connectivity between an API Gateway instance and a port on an Elastic Compute Service (ECS) or Server Load Balance (SLB) instance in a virtual private cloud (VPC) access authorization.
   * 
   * @param request - ValidateVpcConnectivityRequest
   * @returns ValidateVpcConnectivityResponse
   */
  async validateVpcConnectivity(request: ValidateVpcConnectivityRequest): Promise<ValidateVpcConnectivityResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.validateVpcConnectivityWithOptions(request, runtime);
  }

}
